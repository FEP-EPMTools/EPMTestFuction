; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\sr04tdrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\sr04tdrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\sr04tdrv.crf src\UserDrv\sr04tdrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETIMER_Is_Active PROC
;;;102      */
;;;103    static __inline int ETIMER_Is_Active(UINT timer)
000000  e1a02000          MOV      r2,r0
;;;104    {
;;;105        int reg;
;;;106    
;;;107        if(timer == 0) {
000004  e3520000          CMP      r2,#0
000008  1a000002          BNE      |L1.24|
;;;108            reg = inpw(REG_ETMR0_CTL);
00000c  e59f0874          LDR      r0,|L1.2184|
000010  e5901000          LDR      r1,[r0,#0]
000014  ea00000b          B        |L1.72|
                  |L1.24|
;;;109        } else if(timer == 1) {
000018  e3520001          CMP      r2,#1
00001c  1a000002          BNE      |L1.44|
;;;110            reg = inpw(REG_ETMR1_CTL);
000020  e59f0864          LDR      r0,|L1.2188|
000024  e5901000          LDR      r1,[r0,#0]
000028  ea000006          B        |L1.72|
                  |L1.44|
;;;111        } else if(timer == 2) {
00002c  e3520002          CMP      r2,#2
000030  1a000002          BNE      |L1.64|
;;;112            reg = inpw(REG_ETMR2_CTL);
000034  e59f0854          LDR      r0,|L1.2192|
000038  e5901000          LDR      r1,[r0,#0]
00003c  ea000001          B        |L1.72|
                  |L1.64|
;;;113        } else {
;;;114            reg = inpw(REG_ETMR3_CTL);
000040  e59f084c          LDR      r0,|L1.2196|
000044  e5901000          LDR      r1,[r0,#0]
                  |L1.72|
;;;115        }
;;;116        return reg & 0x80 ? 1 : 0;
000048  e2010080          AND      r0,r1,#0x80
00004c  e1a003a0          LSR      r0,r0,#7
;;;117    }
000050  e12fff1e          BX       lr
;;;118    
                          ENDP

                  ETIMER_Start PROC
;;;123      */
;;;124    static __inline void ETIMER_Start(UINT timer)
000054  e3500000          CMP      r0,#0
;;;125    {
;;;126    
;;;127        if(timer == 0) {
000058  1a000005          BNE      |L1.116|
;;;128            outpw(REG_ETMR0_CTL, inpw(REG_ETMR0_CTL) | 1);
00005c  e59f1824          LDR      r1,|L1.2184|
000060  e5911000          LDR      r1,[r1,#0]
000064  e3811001          ORR      r1,r1,#1
000068  e59f2818          LDR      r2,|L1.2184|
00006c  e5821000          STR      r1,[r2,#0]
000070  ea000014          B        |L1.200|
                  |L1.116|
;;;129        } else if(timer == 1) {
000074  e3500001          CMP      r0,#1
000078  1a000005          BNE      |L1.148|
;;;130            outpw(REG_ETMR1_CTL, inpw(REG_ETMR1_CTL) | 1);
00007c  e59f1808          LDR      r1,|L1.2188|
000080  e5911000          LDR      r1,[r1,#0]
000084  e3811001          ORR      r1,r1,#1
000088  e59f27fc          LDR      r2,|L1.2188|
00008c  e5821000          STR      r1,[r2,#0]
000090  ea00000c          B        |L1.200|
                  |L1.148|
;;;131        } else if(timer == 2) {
000094  e3500002          CMP      r0,#2
000098  1a000005          BNE      |L1.180|
;;;132            outpw(REG_ETMR2_CTL, inpw(REG_ETMR2_CTL) | 1);
00009c  e59f17ec          LDR      r1,|L1.2192|
0000a0  e5911000          LDR      r1,[r1,#0]
0000a4  e3811001          ORR      r1,r1,#1
0000a8  e59f27e0          LDR      r2,|L1.2192|
0000ac  e5821000          STR      r1,[r2,#0]
0000b0  ea000004          B        |L1.200|
                  |L1.180|
;;;133        } else {
;;;134            outpw(REG_ETMR3_CTL, inpw(REG_ETMR3_CTL) | 1);
0000b4  e59f17d8          LDR      r1,|L1.2196|
0000b8  e5911000          LDR      r1,[r1,#0]
0000bc  e3811001          ORR      r1,r1,#1
0000c0  e59f27cc          LDR      r2,|L1.2196|
0000c4  e5821000          STR      r1,[r2,#0]
                  |L1.200|
;;;135        }
;;;136    }
0000c8  e12fff1e          BX       lr
;;;137    
                          ENDP

                  ETIMER_Stop PROC
;;;142      */
;;;143    static __inline void ETIMER_Stop(UINT timer)
0000cc  e3500000          CMP      r0,#0
;;;144    {
;;;145        if(timer == 0) {
0000d0  1a000005          BNE      |L1.236|
;;;146            outpw(REG_ETMR0_CTL, inpw(REG_ETMR0_CTL) & ~1);
0000d4  e59f17ac          LDR      r1,|L1.2184|
0000d8  e5911000          LDR      r1,[r1,#0]
0000dc  e3c11001          BIC      r1,r1,#1
0000e0  e59f27a0          LDR      r2,|L1.2184|
0000e4  e5821000          STR      r1,[r2,#0]
0000e8  ea000014          B        |L1.320|
                  |L1.236|
;;;147        } else if(timer == 1) {
0000ec  e3500001          CMP      r0,#1
0000f0  1a000005          BNE      |L1.268|
;;;148            outpw(REG_ETMR1_CTL, inpw(REG_ETMR1_CTL) & ~1);
0000f4  e59f1790          LDR      r1,|L1.2188|
0000f8  e5911000          LDR      r1,[r1,#0]
0000fc  e3c11001          BIC      r1,r1,#1
000100  e59f2784          LDR      r2,|L1.2188|
000104  e5821000          STR      r1,[r2,#0]
000108  ea00000c          B        |L1.320|
                  |L1.268|
;;;149        } else if(timer == 2) {
00010c  e3500002          CMP      r0,#2
000110  1a000005          BNE      |L1.300|
;;;150            outpw(REG_ETMR2_CTL, inpw(REG_ETMR2_CTL) & ~1);
000114  e59f1774          LDR      r1,|L1.2192|
000118  e5911000          LDR      r1,[r1,#0]
00011c  e3c11001          BIC      r1,r1,#1
000120  e59f2768          LDR      r2,|L1.2192|
000124  e5821000          STR      r1,[r2,#0]
000128  ea000004          B        |L1.320|
                  |L1.300|
;;;151        } else {
;;;152            outpw(REG_ETMR3_CTL, inpw(REG_ETMR3_CTL) & ~1);
00012c  e59f1760          LDR      r1,|L1.2196|
000130  e5911000          LDR      r1,[r1,#0]
000134  e3c11001          BIC      r1,r1,#1
000138  e59f2754          LDR      r2,|L1.2196|
00013c  e5821000          STR      r1,[r2,#0]
                  |L1.320|
;;;153        }
;;;154    }
000140  e12fff1e          BX       lr
;;;155    
                          ENDP

                  ETIMER_EnableInt PROC
;;;235      */
;;;236    static __inline void ETIMER_EnableInt(UINT timer)
000144  e3500000          CMP      r0,#0
;;;237    {
;;;238        if(timer == 0) {
000148  1a000005          BNE      |L1.356|
;;;239            outpw(REG_ETMR0_IER, inpw(REG_ETMR0_IER) | 1);
00014c  e59f1744          LDR      r1,|L1.2200|
000150  e5911000          LDR      r1,[r1,#0]
000154  e3811001          ORR      r1,r1,#1
000158  e59f2738          LDR      r2,|L1.2200|
00015c  e5821000          STR      r1,[r2,#0]
000160  ea000014          B        |L1.440|
                  |L1.356|
;;;240        } else if(timer == 1) {
000164  e3500001          CMP      r0,#1
000168  1a000005          BNE      |L1.388|
;;;241            outpw(REG_ETMR1_IER, inpw(REG_ETMR1_IER) | 1);
00016c  e59f1728          LDR      r1,|L1.2204|
000170  e5911000          LDR      r1,[r1,#0]
000174  e3811001          ORR      r1,r1,#1
000178  e59f271c          LDR      r2,|L1.2204|
00017c  e5821000          STR      r1,[r2,#0]
000180  ea00000c          B        |L1.440|
                  |L1.388|
;;;242        } else if(timer == 2) {
000184  e3500002          CMP      r0,#2
000188  1a000005          BNE      |L1.420|
;;;243            outpw(REG_ETMR2_IER, inpw(REG_ETMR2_IER) | 1);
00018c  e59f170c          LDR      r1,|L1.2208|
000190  e5911000          LDR      r1,[r1,#0]
000194  e3811001          ORR      r1,r1,#1
000198  e59f2700          LDR      r2,|L1.2208|
00019c  e5821000          STR      r1,[r2,#0]
0001a0  ea000004          B        |L1.440|
                  |L1.420|
;;;244        } else {
;;;245            outpw(REG_ETMR3_IER, inpw(REG_ETMR3_IER) | 1);
0001a4  e59f16f8          LDR      r1,|L1.2212|
0001a8  e5911000          LDR      r1,[r1,#0]
0001ac  e3811001          ORR      r1,r1,#1
0001b0  e59f26ec          LDR      r2,|L1.2212|
0001b4  e5821000          STR      r1,[r2,#0]
                  |L1.440|
;;;246        }
;;;247    }
0001b8  e12fff1e          BX       lr
;;;248    
                          ENDP

                  ETIMER_EnableCaptureInt PROC
;;;271      */
;;;272    static __inline void ETIMER_EnableCaptureInt(UINT timer)
0001bc  e3500000          CMP      r0,#0
;;;273    {
;;;274        if(timer == 0) {
0001c0  1a000005          BNE      |L1.476|
;;;275            outpw(REG_ETMR0_IER, inpw(REG_ETMR0_IER) | 2);
0001c4  e59f16cc          LDR      r1,|L1.2200|
0001c8  e5911000          LDR      r1,[r1,#0]
0001cc  e3811002          ORR      r1,r1,#2
0001d0  e59f26c0          LDR      r2,|L1.2200|
0001d4  e5821000          STR      r1,[r2,#0]
0001d8  ea000014          B        |L1.560|
                  |L1.476|
;;;276        } else if(timer == 1) {
0001dc  e3500001          CMP      r0,#1
0001e0  1a000005          BNE      |L1.508|
;;;277            outpw(REG_ETMR1_IER, inpw(REG_ETMR1_IER) | 2);
0001e4  e59f16b0          LDR      r1,|L1.2204|
0001e8  e5911000          LDR      r1,[r1,#0]
0001ec  e3811002          ORR      r1,r1,#2
0001f0  e59f26a4          LDR      r2,|L1.2204|
0001f4  e5821000          STR      r1,[r2,#0]
0001f8  ea00000c          B        |L1.560|
                  |L1.508|
;;;278        } else if(timer == 2) {
0001fc  e3500002          CMP      r0,#2
000200  1a000005          BNE      |L1.540|
;;;279            outpw(REG_ETMR2_IER, inpw(REG_ETMR2_IER) | 2);
000204  e59f1694          LDR      r1,|L1.2208|
000208  e5911000          LDR      r1,[r1,#0]
00020c  e3811002          ORR      r1,r1,#2
000210  e59f2688          LDR      r2,|L1.2208|
000214  e5821000          STR      r1,[r2,#0]
000218  ea000004          B        |L1.560|
                  |L1.540|
;;;280        } else {
;;;281            outpw(REG_ETMR3_IER, inpw(REG_ETMR3_IER) | 2);
00021c  e59f1680          LDR      r1,|L1.2212|
000220  e5911000          LDR      r1,[r1,#0]
000224  e3811002          ORR      r1,r1,#2
000228  e59f2674          LDR      r2,|L1.2212|
00022c  e5821000          STR      r1,[r2,#0]
                  |L1.560|
;;;282        }
;;;283    }
000230  e12fff1e          BX       lr
;;;284    
                          ENDP

                  ETIMER_DisableCaptureInt PROC
;;;289      */
;;;290    static __inline void ETIMER_DisableCaptureInt(UINT timer)
000234  e3500000          CMP      r0,#0
;;;291    {
;;;292        if(timer == 0) {
000238  1a000005          BNE      |L1.596|
;;;293            outpw(REG_ETMR0_IER, inpw(REG_ETMR0_IER) & ~2);
00023c  e59f1654          LDR      r1,|L1.2200|
000240  e5911000          LDR      r1,[r1,#0]
000244  e3c11002          BIC      r1,r1,#2
000248  e59f2648          LDR      r2,|L1.2200|
00024c  e5821000          STR      r1,[r2,#0]
000250  ea000014          B        |L1.680|
                  |L1.596|
;;;294        } else if(timer == 1) {
000254  e3500001          CMP      r0,#1
000258  1a000005          BNE      |L1.628|
;;;295            outpw(REG_ETMR1_IER, inpw(REG_ETMR1_IER) & ~2);
00025c  e59f1638          LDR      r1,|L1.2204|
000260  e5911000          LDR      r1,[r1,#0]
000264  e3c11002          BIC      r1,r1,#2
000268  e59f262c          LDR      r2,|L1.2204|
00026c  e5821000          STR      r1,[r2,#0]
000270  ea00000c          B        |L1.680|
                  |L1.628|
;;;296        } else if(timer == 2) {
000274  e3500002          CMP      r0,#2
000278  1a000005          BNE      |L1.660|
;;;297            outpw(REG_ETMR2_IER, inpw(REG_ETMR2_IER) & ~2);
00027c  e59f161c          LDR      r1,|L1.2208|
000280  e5911000          LDR      r1,[r1,#0]
000284  e3c11002          BIC      r1,r1,#2
000288  e59f2610          LDR      r2,|L1.2208|
00028c  e5821000          STR      r1,[r2,#0]
000290  ea000004          B        |L1.680|
                  |L1.660|
;;;298        } else {
;;;299            outpw(REG_ETMR3_IER, inpw(REG_ETMR3_IER) & ~2);
000294  e59f1608          LDR      r1,|L1.2212|
000298  e5911000          LDR      r1,[r1,#0]
00029c  e3c11002          BIC      r1,r1,#2
0002a0  e59f25fc          LDR      r2,|L1.2212|
0002a4  e5821000          STR      r1,[r2,#0]
                  |L1.680|
;;;300        }
;;;301    }
0002a8  e12fff1e          BX       lr
;;;302    
                          ENDP

                  ETIMER_GetIntFlag PROC
;;;309      */
;;;310    static __inline UINT ETIMER_GetIntFlag(UINT timer)
0002ac  e1a02000          MOV      r2,r0
;;;311    {
;;;312        int reg;
;;;313    
;;;314        if(timer == 0) {
0002b0  e3520000          CMP      r2,#0
0002b4  1a000002          BNE      |L1.708|
;;;315            reg = inpw(REG_ETMR0_ISR);
0002b8  e59f05e8          LDR      r0,|L1.2216|
0002bc  e5901000          LDR      r1,[r0,#0]
0002c0  ea00000b          B        |L1.756|
                  |L1.708|
;;;316        } else if(timer == 1) {
0002c4  e3520001          CMP      r2,#1
0002c8  1a000002          BNE      |L1.728|
;;;317            reg = inpw(REG_ETMR1_ISR);
0002cc  e59f05d8          LDR      r0,|L1.2220|
0002d0  e5901000          LDR      r1,[r0,#0]
0002d4  ea000006          B        |L1.756|
                  |L1.728|
;;;318        } else if(timer == 2) {
0002d8  e3520002          CMP      r2,#2
0002dc  1a000002          BNE      |L1.748|
;;;319            reg = inpw(REG_ETMR2_ISR);
0002e0  e59f05c8          LDR      r0,|L1.2224|
0002e4  e5901000          LDR      r1,[r0,#0]
0002e8  ea000001          B        |L1.756|
                  |L1.748|
;;;320        } else {
;;;321            reg = inpw(REG_ETMR3_ISR);
0002ec  e59f05c0          LDR      r0,|L1.2228|
0002f0  e5901000          LDR      r1,[r0,#0]
                  |L1.756|
;;;322        }
;;;323        return reg & 1;
0002f4  e2010001          AND      r0,r1,#1
;;;324    }
0002f8  e12fff1e          BX       lr
;;;325    
                          ENDP

                  ETIMER_ClearIntFlag PROC
;;;330      */
;;;331    static __inline void ETIMER_ClearIntFlag(UINT timer)
0002fc  e3500000          CMP      r0,#0
;;;332    {
;;;333        if(timer == 0) {
000300  1a000003          BNE      |L1.788|
;;;334            outpw(REG_ETMR0_ISR, 1);
000304  e3a01001          MOV      r1,#1
000308  e59f2598          LDR      r2,|L1.2216|
00030c  e5821000          STR      r1,[r2,#0]
000310  ea00000e          B        |L1.848|
                  |L1.788|
;;;335        } else if(timer == 1) {
000314  e3500001          CMP      r0,#1
000318  1a000003          BNE      |L1.812|
;;;336            outpw(REG_ETMR1_ISR, 1);
00031c  e3a01001          MOV      r1,#1
000320  e59f2584          LDR      r2,|L1.2220|
000324  e5821000          STR      r1,[r2,#0]
000328  ea000008          B        |L1.848|
                  |L1.812|
;;;337        } else if(timer == 2) {
00032c  e3500002          CMP      r0,#2
000330  1a000003          BNE      |L1.836|
;;;338            outpw(REG_ETMR2_ISR, 1);
000334  e3a01001          MOV      r1,#1
000338  e59f2570          LDR      r2,|L1.2224|
00033c  e5821000          STR      r1,[r2,#0]
000340  ea000002          B        |L1.848|
                  |L1.836|
;;;339        } else {
;;;340            outpw(REG_ETMR3_ISR, 1);
000344  e3a01001          MOV      r1,#1
000348  e59f2564          LDR      r2,|L1.2228|
00034c  e5821000          STR      r1,[r2,#0]
                  |L1.848|
;;;341        }
;;;342    }
000350  e12fff1e          BX       lr
;;;343    
                          ENDP

                  ETIMER_GetCaptureIntFlag PROC
;;;350      */
;;;351    static __inline UINT ETIMER_GetCaptureIntFlag(UINT timer)
000354  e1a02000          MOV      r2,r0
;;;352    {
;;;353        int reg;
;;;354    
;;;355        if(timer == 0) {
000358  e3520000          CMP      r2,#0
00035c  1a000002          BNE      |L1.876|
;;;356            reg = inpw(REG_ETMR0_ISR);
000360  e59f0540          LDR      r0,|L1.2216|
000364  e5901000          LDR      r1,[r0,#0]
000368  ea00000b          B        |L1.924|
                  |L1.876|
;;;357        } else if(timer == 1) {
00036c  e3520001          CMP      r2,#1
000370  1a000002          BNE      |L1.896|
;;;358            reg = inpw(REG_ETMR1_ISR);
000374  e59f0530          LDR      r0,|L1.2220|
000378  e5901000          LDR      r1,[r0,#0]
00037c  ea000006          B        |L1.924|
                  |L1.896|
;;;359        } else if(timer == 2) {
000380  e3520002          CMP      r2,#2
000384  1a000002          BNE      |L1.916|
;;;360            reg = inpw(REG_ETMR2_ISR);
000388  e59f0520          LDR      r0,|L1.2224|
00038c  e5901000          LDR      r1,[r0,#0]
000390  ea000001          B        |L1.924|
                  |L1.916|
;;;361        } else {
;;;362            reg = inpw(REG_ETMR3_ISR);
000394  e59f0518          LDR      r0,|L1.2228|
000398  e5901000          LDR      r1,[r0,#0]
                  |L1.924|
;;;363        }
;;;364        return (reg & 2) >> 1;
00039c  e2010002          AND      r0,r1,#2
0003a0  e1a000c0          ASR      r0,r0,#1
;;;365    }
0003a4  e12fff1e          BX       lr
;;;366    
                          ENDP

                  ETIMER_ClearCaptureIntFlag PROC
;;;371      */
;;;372    static __inline void ETIMER_ClearCaptureIntFlag(UINT timer)
0003a8  e3500000          CMP      r0,#0
;;;373    {
;;;374        if(timer == 0) {
0003ac  1a000003          BNE      |L1.960|
;;;375            outpw(REG_ETMR0_ISR, 2);
0003b0  e3a01002          MOV      r1,#2
0003b4  e59f24ec          LDR      r2,|L1.2216|
0003b8  e5821000          STR      r1,[r2,#0]
0003bc  ea00000e          B        |L1.1020|
                  |L1.960|
;;;376        } else if(timer == 1) {
0003c0  e3500001          CMP      r0,#1
0003c4  1a000003          BNE      |L1.984|
;;;377            outpw(REG_ETMR1_ISR, 2);
0003c8  e3a01002          MOV      r1,#2
0003cc  e59f24d8          LDR      r2,|L1.2220|
0003d0  e5821000          STR      r1,[r2,#0]
0003d4  ea000008          B        |L1.1020|
                  |L1.984|
;;;378        } else if(timer == 2) {
0003d8  e3500002          CMP      r0,#2
0003dc  1a000003          BNE      |L1.1008|
;;;379            outpw(REG_ETMR2_ISR, 2);
0003e0  e3a01002          MOV      r1,#2
0003e4  e59f24c4          LDR      r2,|L1.2224|
0003e8  e5821000          STR      r1,[r2,#0]
0003ec  ea000002          B        |L1.1020|
                  |L1.1008|
;;;380        } else {
;;;381            outpw(REG_ETMR3_ISR, 2);
0003f0  e3a01002          MOV      r1,#2
0003f4  e59f24b8          LDR      r2,|L1.2228|
0003f8  e5821000          STR      r1,[r2,#0]
                  |L1.1020|
;;;382        }
;;;383    }
0003fc  e12fff1e          BX       lr
;;;384    
                          ENDP

                  ETIMER_GetCaptureData PROC
;;;430      */
;;;431    static __inline UINT ETIMER_GetCaptureData(UINT timer)
000400  e1a01000          MOV      r1,r0
;;;432    {
;;;433    
;;;434        if(timer == 0) {
000404  e3510000          CMP      r1,#0
000408  1a000002          BNE      |L1.1048|
;;;435            return inpw(REG_ETMR0_TCAP);
00040c  e59f04a4          LDR      r0,|L1.2232|
000410  e5900000          LDR      r0,[r0,#0]
                  |L1.1044|
;;;436        } else if(timer == 1) {
;;;437            return inpw(REG_ETMR1_TCAP);
;;;438        } else if(timer == 2) {
;;;439            return inpw(REG_ETMR2_TCAP);
;;;440        } else {
;;;441            return inpw(REG_ETMR3_TCAP);
;;;442        }
;;;443    }
000414  e12fff1e          BX       lr
                  |L1.1048|
000418  e3510001          CMP      r1,#1                 ;436
00041c  1a000002          BNE      |L1.1068|
000420  e59f0494          LDR      r0,|L1.2236|
000424  e5900000          LDR      r0,[r0,#0]            ;437
000428  eafffff9          B        |L1.1044|
                  |L1.1068|
00042c  e3510002          CMP      r1,#2                 ;438
000430  1a000002          BNE      |L1.1088|
000434  e59f0484          LDR      r0,|L1.2240|
000438  e5900000          LDR      r0,[r0,#0]            ;439
00043c  eafffff4          B        |L1.1044|
                  |L1.1088|
000440  e59f047c          LDR      r0,|L1.2244|
000444  e5900000          LDR      r0,[r0,#0]            ;441
000448  eafffff1          B        |L1.1044|
;;;444    
                          ENDP

                  setPower PROC
;;;52     /*-----------------------------------------*/
;;;53     static void setPower(uint8_t id, BOOL flag)
00044c  e92d4070          PUSH     {r4-r6,lr}
;;;54     {
000450  e1a05000          MOV      r5,r0
000454  e1a04001          MOV      r4,r1
;;;55         #if(0)
;;;56         if(flag)
;;;57             sysprintf("-> setPower (%d) enter: true\r\n", id);
;;;58         else
;;;59             sysprintf("-> setPower (%d) enter: false\r\n", id);
;;;60         #endif
;;;61         //ETIMER_Stop(0);
;;;62         //ETIMER_DisableInt(0);
;;;63         //ETIMER_ClearIntFlag(0);
;;;64         //ETIMER_ClearCaptureIntFlag(0);
;;;65         //ETIMER_Close(0);
;;;66         if(DIST_DEVICE_1 == id)
000458  e3550000          CMP      r5,#0
00045c  1a000008          BNE      |L1.1156|
;;;67         {
;;;68             if(flag)
000460  e3540000          CMP      r4,#0
000464  0a000003          BEQ      |L1.1144|
;;;69                 GPIO_SetBit(POWER_PORT_1, POWER_PIN_1); 
000468  e3a01020          MOV      r1,#0x20
00046c  e3a00040          MOV      r0,#0x40
000470  ebfffffe          BL       GPIO_SetBit
000474  ea000002          B        |L1.1156|
                  |L1.1144|
;;;70             else
;;;71                 GPIO_ClrBit(POWER_PORT_1, POWER_PIN_1); 
000478  e3a01020          MOV      r1,#0x20
00047c  e3a00040          MOV      r0,#0x40
000480  ebfffffe          BL       GPIO_ClrBit
                  |L1.1156|
;;;72         }
;;;73         
;;;74         if(DIST_DEVICE_2 == id)
000484  e3550001          CMP      r5,#1
000488  1a000008          BNE      |L1.1200|
;;;75         {
;;;76             if(flag)
00048c  e3540000          CMP      r4,#0
000490  0a000003          BEQ      |L1.1188|
;;;77                 GPIO_SetBit(POWER_PORT_2, POWER_PIN_2); 
000494  e3a01004          MOV      r1,#4
000498  e3a00040          MOV      r0,#0x40
00049c  ebfffffe          BL       GPIO_SetBit
0004a0  ea000002          B        |L1.1200|
                  |L1.1188|
;;;78             else
;;;79                 GPIO_ClrBit(POWER_PORT_2, POWER_PIN_2); 
0004a4  e3a01004          MOV      r1,#4
0004a8  e3a00040          MOV      r0,#0x40
0004ac  ebfffffe          BL       GPIO_ClrBit
                  |L1.1200|
;;;80         } 
;;;81         #if(0)
;;;82         if(flag)
;;;83             sysprintf("-> setPower (%d) exit: true\r\n", id);
;;;84         else
;;;85             sysprintf("-> setPower (%d) exit: false\r\n", id);
;;;86         #endif
;;;87     }
0004b0  e8bd8070          POP      {r4-r6,pc}
;;;88     
                          ENDP

                  settingToggle PROC
;;;89     static void settingToggle(uint16_t ns, uint8_t id)
0004b4  e92d4070          PUSH     {r4-r6,lr}
;;;90     {
0004b8  e1a05000          MOV      r5,r0
0004bc  e1a04001          MOV      r4,r1
;;;91         //sysprintf("-> settingToggle [%d]\r\n", ns);
;;;92         //toggleTimes = 0;
;;;93         //targetToggleTimes = ns/(1000000/TOGGLE_HZ_VALUE);
;;;94         //sysprintf("-> settingToggle [%d], targetToggleTimes = %d\r\n", ns, targetToggleTimes);
;;;95         //ETIMER_Open(0, ETIMER_TOGGLE_MODE, TOGGLE_HZ_VALUE);  
;;;96         //ETIMER_Stop(0);
;;;97         //ETIMER_DisableInt(0);
;;;98         //ETIMER_ClearIntFlag(0);
;;;99         //ETIMER_ClearCaptureIntFlag(0);  
;;;100        if(DIST_DEVICE_1 == id)
0004c0  e3540000          CMP      r4,#0
0004c4  1a000002          BNE      |L1.1236|
;;;101        {
;;;102            GPIO_ClrBit(OUTPUT_PORT_1, OUTPUT_PIN_1); 
0004c8  e3a01010          MOV      r1,#0x10
0004cc  e3a00040          MOV      r0,#0x40
0004d0  ebfffffe          BL       GPIO_ClrBit
                  |L1.1236|
;;;103        }
;;;104        
;;;105        if(DIST_DEVICE_2 == id)
0004d4  e3540001          CMP      r4,#1
0004d8  1a000002          BNE      |L1.1256|
;;;106        {
;;;107            GPIO_ClrBit(OUTPUT_PORT_2, OUTPUT_PIN_2); 
0004dc  e3a01001          MOV      r1,#1
0004e0  e3a00040          MOV      r0,#0x40
0004e4  ebfffffe          BL       GPIO_ClrBit
                  |L1.1256|
;;;108        }    
;;;109        
;;;110    }
0004e8  e8bd8070          POP      {r4-r6,pc}
;;;111    
                          ENDP

                  startToggle PROC
;;;112    static void startToggle(uint8_t id)
0004ec  e92d4010          PUSH     {r4,lr}
;;;113    {
0004f0  e1a04000          MOV      r4,r0
;;;114        //sysprintf("-> startToggle\r\n");
;;;115        //ETIMER_EnableInt(0);    
;;;116        //ETIMER_Start(0);
;;;117        if(DIST_DEVICE_1 == id)
0004f4  e3540000          CMP      r4,#0
0004f8  1a000007          BNE      |L1.1308|
;;;118        {
;;;119            GPIO_SetBit(OUTPUT_PORT_1, OUTPUT_PIN_1); 
0004fc  e3a01010          MOV      r1,#0x10
000500  e3a00040          MOV      r0,#0x40
000504  ebfffffe          BL       GPIO_SetBit
;;;120            #if(FREERTOS_USE_1000MHZ)
;;;121            vTaskDelay(1/portTICK_RATE_MS); 
;;;122            #else
;;;123            //#error
;;;124            vTaskDelay(10/portTICK_RATE_MS); 
000508  e3a00001          MOV      r0,#1
00050c  ebfffffe          BL       vTaskDelay
;;;125            #endif
;;;126            GPIO_ClrBit(OUTPUT_PORT_1, OUTPUT_PIN_1); 
000510  e3a01010          MOV      r1,#0x10
000514  e3a00040          MOV      r0,#0x40
000518  ebfffffe          BL       GPIO_ClrBit
                  |L1.1308|
;;;127        }
;;;128        
;;;129        if(DIST_DEVICE_2 == id)
00051c  e3540001          CMP      r4,#1
000520  1a000007          BNE      |L1.1348|
;;;130        {
;;;131            GPIO_SetBit(OUTPUT_PORT_2, OUTPUT_PIN_2); 
000524  e3a01001          MOV      r1,#1
000528  e3a00040          MOV      r0,#0x40
00052c  ebfffffe          BL       GPIO_SetBit
;;;132            #if(FREERTOS_USE_1000MHZ)
;;;133            vTaskDelay(1/portTICK_RATE_MS); 
;;;134            #else
;;;135            //#error
;;;136            vTaskDelay(10/portTICK_RATE_MS); 
000530  e3a00001          MOV      r0,#1
000534  ebfffffe          BL       vTaskDelay
;;;137            #endif
;;;138            GPIO_ClrBit(OUTPUT_PORT_2, OUTPUT_PIN_2); 
000538  e3a01001          MOV      r1,#1
00053c  e3a00040          MOV      r0,#0x40
000540  ebfffffe          BL       GPIO_ClrBit
                  |L1.1348|
;;;139        }    
;;;140        
;;;141    }
000544  e8bd8010          POP      {r4,pc}
;;;142    static void stopToggle(uint8_t id)
                          ENDP

                  stopToggle PROC
000548  e92d4010          PUSH     {r4,lr}
;;;143    {
00054c  e1a04000          MOV      r4,r0
;;;144        //sysprintf("-> stopToggle\r\n");
;;;145        //ETIMER_Stop(0);
;;;146        //ETIMER_DisableInt(0);
;;;147        //ETIMER_ClearIntFlag(0);
;;;148        //ETIMER_ClearCaptureIntFlag(0);
;;;149        //ETIMER_Close(0);
;;;150        if(DIST_DEVICE_1 == id)
000550  e3540000          CMP      r4,#0
000554  1a000002          BNE      |L1.1380|
;;;151        {
;;;152            GPIO_ClrBit(OUTPUT_PORT_1, OUTPUT_PIN_1); 
000558  e3a01010          MOV      r1,#0x10
00055c  e3a00040          MOV      r0,#0x40
000560  ebfffffe          BL       GPIO_ClrBit
                  |L1.1380|
;;;153        }
;;;154        
;;;155        if(DIST_DEVICE_2 == id)
000564  e3540001          CMP      r4,#1
000568  1a000002          BNE      |L1.1400|
;;;156        {
;;;157            GPIO_ClrBit(OUTPUT_PORT_2, OUTPUT_PIN_2); 
00056c  e3a01001          MOV      r1,#1
000570  e3a00040          MOV      r0,#0x40
000574  ebfffffe          BL       GPIO_ClrBit
                  |L1.1400|
;;;158        }    
;;;159    }
000578  e8bd8010          POP      {r4,pc}
;;;160    
                          ENDP

                  startCapture PROC
;;;161    static void startCapture(uint8_t id)
00057c  e92d4010          PUSH     {r4,lr}
;;;162    {
000580  e1a04000          MOV      r4,r0
;;;163        //sysprintf("-> startCapture\r\n");
;;;164        if(DIST_DEVICE_1 == id)
000584  e3540000          CMP      r4,#0
000588  1a00000b          BNE      |L1.1468|
;;;165        {
;;;166            ETIMER_Open(0, ETIMER_ONESHOT_MODE, 10); //100ms
00058c  e3a0200a          MOV      r2,#0xa
000590  e3a01000          MOV      r1,#0
000594  e1a00001          MOV      r0,r1
000598  ebfffffe          BL       ETIMER_Open
;;;167            ETIMER_EnableCaptureInt(0);
00059c  e3a00000          MOV      r0,#0
0005a0  ebfffffe          BL       ETIMER_EnableCaptureInt
;;;168            ETIMER_EnableCapture(0, ETIMER_CAPTURE_TRIGGER_COUNTING_MODE, ETIMER_CAPTURE_RISING_THEN_FALLING_EDGE);
0005a4  e3a02703          MOV      r2,#0xc0000
0005a8  e3a01601          MOV      r1,#0x100000
0005ac  e3a00000          MOV      r0,#0
0005b0  ebfffffe          BL       ETIMER_EnableCapture
;;;169            ETIMER_Start(0);
0005b4  e3a00000          MOV      r0,#0
0005b8  ebfffffe          BL       ETIMER_Start
                  |L1.1468|
;;;170        }
;;;171        
;;;172        if(DIST_DEVICE_2 == id)
0005bc  e3540001          CMP      r4,#1
0005c0  1a00000b          BNE      |L1.1524|
;;;173        {
;;;174            ETIMER_Open(1, ETIMER_ONESHOT_MODE, 10); //100ms
0005c4  e3a0200a          MOV      r2,#0xa
0005c8  e3a01000          MOV      r1,#0
0005cc  e3a00001          MOV      r0,#1
0005d0  ebfffffe          BL       ETIMER_Open
;;;175            ETIMER_EnableCaptureInt(1);
0005d4  e3a00001          MOV      r0,#1
0005d8  ebfffffe          BL       ETIMER_EnableCaptureInt
;;;176            ETIMER_EnableCapture(1, ETIMER_CAPTURE_TRIGGER_COUNTING_MODE, ETIMER_CAPTURE_RISING_THEN_FALLING_EDGE);
0005dc  e3a02703          MOV      r2,#0xc0000
0005e0  e3a01601          MOV      r1,#0x100000
0005e4  e3a00001          MOV      r0,#1
0005e8  ebfffffe          BL       ETIMER_EnableCapture
;;;177            ETIMER_Start(1);
0005ec  e3a00001          MOV      r0,#1
0005f0  ebfffffe          BL       ETIMER_Start
                  |L1.1524|
;;;178        }
;;;179        
;;;180        
;;;181    }
0005f4  e8bd8010          POP      {r4,pc}
;;;182    static void stopCapture(uint8_t id)
                          ENDP

                  stopCapture PROC
0005f8  e92d4010          PUSH     {r4,lr}
;;;183    {
0005fc  e1a04000          MOV      r4,r0
;;;184        //sysprintf("-> stopCapture\r\n");
;;;185        if(DIST_DEVICE_1 == id)
000600  e3540000          CMP      r4,#0
000604  1a000007          BNE      |L1.1576|
;;;186        {    
;;;187            ETIMER_Stop(0);
000608  e3a00000          MOV      r0,#0
00060c  ebfffffe          BL       ETIMER_Stop
;;;188            ETIMER_DisableCapture(0);        
000610  e3a00000          MOV      r0,#0
000614  ebfffffe          BL       ETIMER_DisableCapture
;;;189            ETIMER_DisableCaptureInt(0);        
000618  e3a00000          MOV      r0,#0
00061c  ebfffffe          BL       ETIMER_DisableCaptureInt
;;;190            ETIMER_Close(0);
000620  e3a00000          MOV      r0,#0
000624  ebfffffe          BL       ETIMER_Close
                  |L1.1576|
;;;191        }
;;;192        if(DIST_DEVICE_2 == id)
000628  e3540001          CMP      r4,#1
00062c  1a000007          BNE      |L1.1616|
;;;193        {
;;;194            ETIMER_Stop(1);
000630  e3a00001          MOV      r0,#1
000634  ebfffffe          BL       ETIMER_Stop
;;;195            ETIMER_DisableCapture(1);        
000638  e3a00001          MOV      r0,#1
00063c  ebfffffe          BL       ETIMER_DisableCapture
;;;196            ETIMER_DisableCaptureInt(1);        
000640  e3a00001          MOV      r0,#1
000644  ebfffffe          BL       ETIMER_DisableCaptureInt
;;;197            ETIMER_Close(1);
000648  e3a00001          MOV      r0,#1
00064c  ebfffffe          BL       ETIMER_Close
                  |L1.1616|
;;;198        }
;;;199    }
000650  e8bd8010          POP      {r4,pc}
;;;200    static int checkActive(uint8_t id)
                          ENDP

                  checkActive PROC
000654  e92d4010          PUSH     {r4,lr}
;;;201    {
000658  e1a04000          MOV      r4,r0
;;;202        if(DIST_DEVICE_1 == id)
00065c  e3540000          CMP      r4,#0
000660  1a000002          BNE      |L1.1648|
;;;203        {    
;;;204            return ETIMER_Is_Active(0);
000664  e3a00000          MOV      r0,#0
000668  ebfffffe          BL       ETIMER_Is_Active
                  |L1.1644|
;;;205        }
;;;206        else
;;;207        {
;;;208            return ETIMER_Is_Active(1);
;;;209        }
;;;210    }
00066c  e8bd8010          POP      {r4,pc}
                  |L1.1648|
000670  e3a00001          MOV      r0,#1                 ;208
000674  ebfffffe          BL       ETIMER_Is_Active
000678  eafffffb          B        |L1.1644|
;;;211    static BOOL runCapture(uint8_t id, int* detectResult)
                          ENDP

                  runCapture PROC
00067c  e92d47f0          PUSH     {r4-r10,lr}
;;;212    {
000680  e1a05000          MOV      r5,r0
000684  e1a04001          MOV      r4,r1
;;;213        sysprintf("-> runCapture\r\n");
000688  e28f0f8e          ADR      r0,|L1.2248|
00068c  ebfffffe          BL       sysprintf
;;;214        BOOL reVal = TRUE;
000690  e3a07001          MOV      r7,#1
;;;215        int totalTimes = 4;
000694  e3a08004          MOV      r8,#4
;;;216        int getTimes = 0;
000698  e3a06000          MOV      r6,#0
;;;217        int totalDist = 0;
00069c  e3a09000          MOV      r9,#0
;;;218        uint16_t counter = 0;
0006a0  e3a0a000          MOV      r10,#0
;;;219        distValue[id] = 0;
0006a4  e3a00000          MOV      r0,#0
0006a8  e59f1228          LDR      r1,|L1.2264|
0006ac  e7810105          STR      r0,[r1,r5,LSL #2]
;;;220        //distValue[DIST_DEVICE_2] = 0;
;;;221        setPower(id, TRUE);
0006b0  e3a01001          MOV      r1,#1
0006b4  e1a00005          MOV      r0,r5
0006b8  ebfffffe          BL       setPower
;;;222        vTaskDelay(300/portTICK_RATE_MS); 
0006bc  e3a0001e          MOV      r0,#0x1e
0006c0  ebfffffe          BL       vTaskDelay
;;;223        while(totalTimes>0)
0006c4  ea000027          B        |L1.1896|
                  |L1.1736|
;;;224        {
;;;225            reVal = TRUE;
0006c8  e3a07001          MOV      r7,#1
;;;226            settingToggle(10, id);
0006cc  e1a01005          MOV      r1,r5
0006d0  e3a0000a          MOV      r0,#0xa
0006d4  ebfffffe          BL       settingToggle
;;;227            startCapture(id);
0006d8  e1a00005          MOV      r0,r5
0006dc  ebfffffe          BL       startCapture
;;;228            startToggle(id);
0006e0  e1a00005          MOV      r0,r5
0006e4  ebfffffe          BL       startToggle
;;;229            counter = 10;
0006e8  e3a0a00a          MOV      r10,#0xa
;;;230            while(checkActive(id))
0006ec  ea00000a          B        |L1.1820|
                  |L1.1776|
;;;231            {
;;;232                vTaskDelay(10/portTICK_RATE_MS);
0006f0  e3a00001          MOV      r0,#1
0006f4  ebfffffe          BL       vTaskDelay
;;;233                sysprintf(".");
0006f8  e28f0f77          ADR      r0,|L1.2268|
0006fc  ebfffffe          BL       sysprintf
;;;234                counter--;
000700  e24a0001          SUB      r0,r10,#1
000704  e1a0a800          LSL      r10,r0,#16
000708  e1a0a82a          LSR      r10,r10,#16
;;;235                if(counter == 0)
00070c  e35a0000          CMP      r10,#0
000710  1a000001          BNE      |L1.1820|
;;;236                {
;;;237                    //sysprintf("runCapture[%d]: timeout\r\n", id);            
;;;238                    //xSemaphoreGive(xSemaphore);
;;;239                    reVal = FALSE;
000714  e3a07000          MOV      r7,#0
;;;240                    break;
000718  ea000003          B        |L1.1836|
                  |L1.1820|
00071c  e1a00005          MOV      r0,r5                 ;230
000720  ebfffffe          BL       checkActive
000724  e3500000          CMP      r0,#0                 ;230
000728  1afffff0          BNE      |L1.1776|
                  |L1.1836|
00072c  e1a00000          MOV      r0,r0
;;;241                }
;;;242            }
;;;243            stopToggle(id); 
000730  e1a00005          MOV      r0,r5
000734  ebfffffe          BL       stopToggle
;;;244            stopCapture(id); 
000738  e1a00005          MOV      r0,r5
00073c  ebfffffe          BL       stopCapture
;;;245            totalTimes--;
000740  e2488001          SUB      r8,r8,#1
;;;246            if(reVal)
000744  e3570000          CMP      r7,#0
000748  0a000006          BEQ      |L1.1896|
;;;247            {
;;;248                getTimes++;
00074c  e2866001          ADD      r6,r6,#1
;;;249                terninalPrintf("getTimes = %d \r\n", getTimes);
000750  e1a01006          MOV      r1,r6
000754  e28f0f61          ADR      r0,|L1.2272|
000758  ebfffffe          BL       terninalPrintf
;;;250                totalDist = totalDist + distValue[id];
00075c  e59f0174          LDR      r0,|L1.2264|
000760  e7900105          LDR      r0,[r0,r5,LSL #2]
000764  e0899000          ADD      r9,r9,r0
                  |L1.1896|
000768  e3580000          CMP      r8,#0                 ;223
00076c  caffffd5          BGT      |L1.1736|
;;;251            }
;;;252        }
;;;253        if(getTimes>=4)
000770  e3560004          CMP      r6,#4
000774  ba000009          BLT      |L1.1952|
;;;254        {        
;;;255            *detectResult = totalDist/getTimes;
000778  e1a01006          MOV      r1,r6
00077c  e1a00009          MOV      r0,r9
000780  ebfffffe          BL       __aeabi_idivmod
000784  e5840000          STR      r0,[r4,#0]
;;;256            reVal = TRUE;
000788  e3a07001          MOV      r7,#1
;;;257            sysprintf("runCapture TRUE [%d]: %d cm\r\n", getTimes, *detectResult); 
00078c  e1a01006          MOV      r1,r6
000790  e28f0f57          ADR      r0,|L1.2292|
000794  e5942000          LDR      r2,[r4,#0]
000798  ebfffffe          BL       sysprintf
00079c  ea000006          B        |L1.1980|
                  |L1.1952|
;;;258        }
;;;259        else
;;;260        {
;;;261            *detectResult = 0;
0007a0  e3a00000          MOV      r0,#0
0007a4  e5840000          STR      r0,[r4,#0]
;;;262            reVal = FALSE;
0007a8  e3a07000          MOV      r7,#0
;;;263            sysprintf("runCapture FALSE [%d]: %d cm\r\n", getTimes, *detectResult); 
0007ac  e1a01006          MOV      r1,r6
0007b0  e28f0f57          ADR      r0,|L1.2324|
0007b4  e5942000          LDR      r2,[r4,#0]
0007b8  ebfffffe          BL       sysprintf
                  |L1.1980|
;;;264        }   
;;;265        setPower(id, FALSE);
0007bc  e3a01000          MOV      r1,#0
0007c0  e1a00005          MOV      r0,r5
0007c4  ebfffffe          BL       setPower
;;;266        return reVal;
0007c8  e1a00007          MOV      r0,r7
;;;267    }
0007cc  e8bd87f0          POP      {r4-r10,pc}
;;;268    /*
                          ENDP

                  swInit PROC
;;;306    */
;;;307    static BOOL swInit(void)
0007d0  e3a00001          MOV      r0,#1
;;;308    {
;;;309        //xSemaphore = xSemaphoreCreateBinary();
;;;310        //xBuzzerSemaphore = xSemaphoreCreateBinary(); 
;;;311        //xTaskCreate( vSR04TTestTask, "vSR04TTestTask", 1024, NULL, 5, NULL );    
;;;312        //xTaskCreate( vSR04TReadTask, "vSR04TReadTask", 1024, NULL, 4, NULL );
;;;313        //xTaskCreate( vBuzzerTask, "vBuzzerTask", 1024, NULL, 6, NULL );
;;;314        return TRUE;
;;;315    }
0007d4  e12fff1e          BX       lr
;;;316    
                          ENDP

                  ETMR0_IRQHandler PROC
;;;317    static void ETMR0_IRQHandler(void)
0007d8  e92d41f0          PUSH     {r4-r8,lr}
;;;318    {
;;;319        // clear timer interrupt flag
;;;320        if(ETIMER_GetIntFlag(0))
0007dc  e3a00000          MOV      r0,#0
0007e0  ebfffffe          BL       ETIMER_GetIntFlag
0007e4  e3500000          CMP      r0,#0
0007e8  0a000001          BEQ      |L1.2036|
;;;321        {
;;;322            ETIMER_ClearIntFlag(0);
0007ec  e3a00000          MOV      r0,#0
0007f0  ebfffffe          BL       ETIMER_ClearIntFlag
                  |L1.2036|
;;;323        }
;;;324        if(ETIMER_GetCaptureIntFlag(0))
0007f4  e3a00000          MOV      r0,#0
0007f8  ebfffffe          BL       ETIMER_GetCaptureIntFlag
0007fc  e3500000          CMP      r0,#0
000800  0a00001f          BEQ      |L1.2180|
;;;325        {
;;;326            uint16_t distance;//, distance2;
;;;327            uint32_t data5 = (uint32_t)((uint64_t)ETIMER_GetCaptureData(0) * (uint64_t)100*(uint64_t)1000 /(uint64_t)inpw(REG_ETMR0_CMPR)); 
000804  e3a00000          MOV      r0,#0
000808  ebfffffe          BL       ETIMER_GetCaptureData
00080c  e3a01064          MOV      r1,#0x64
000810  e0832190          UMULL    r2,r3,r0,r1
000814  e3a01ffa          MOV      r1,#0x3e8
000818  e3a00000          MOV      r0,#0
00081c  e0886192          UMULL    r6,r8,r2,r1
000820  e0218193          MLA      r1,r3,r1,r8
000824  e0211092          MLA      r1,r2,r0,r1
000828  e59f0104          LDR      r0,|L1.2356|
00082c  e590c000          LDR      r12,[r0,#0]
000830  e1a0200c          MOV      r2,r12
000834  e3a03000          MOV      r3,#0
000838  e1a00006          MOV      r0,r6
00083c  ebfffffe          BL       __aeabi_uldivmod
000840  e1a05000          MOV      r5,r0
;;;328    
;;;329            distance = data5*34/100/2;
000844  e0851205          ADD      r1,r5,r5,LSL #4
000848  e1a00081          LSL      r0,r1,#1
00084c  e3a01064          MOV      r1,#0x64
000850  ebfffffe          BL       __aeabi_uidivmod
000854  e59f10dc          LDR      r1,|L1.2360|
000858  e00140a0          AND      r4,r1,r0,LSR #1
;;;330            //distance2 = data5*10/58;
;;;331            //sysprintf(" **> Get Capture (%d/%d): [%d] us, %d cm (%d mm, %d mm)\n", ETIMER_GetCaptureData(0), inpw(REG_ETMR0_CMPR), data5, distance/10, distance, distance2);
;;;332            //sysprintf(" **> [<1>: %03d cm]\n", distance/10);
;;;333            distValue[DIST_DEVICE_1] = distance/10;
00085c  e3a0100a          MOV      r1,#0xa
000860  e1a00004          MOV      r0,r4
000864  ebfffffe          BL       __aeabi_idivmod
000868  e59f1068          LDR      r1,|L1.2264|
00086c  e5810000          STR      r0,[r1,#0]  ; distValue
;;;334            ETIMER_ClearCaptureIntFlag(0);
000870  e3a00000          MOV      r0,#0
000874  ebfffffe          BL       ETIMER_ClearCaptureIntFlag
;;;335            stopCapture(DIST_DEVICE_1);
000878  e3a00000          MOV      r0,#0
00087c  ebfffffe          BL       stopCapture
;;;336        }   
000880  e1a00000          MOV      r0,r0
                  |L1.2180|
;;;337    
;;;338    }
000884  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2184|
                          DCD      0xb8001400
                  |L1.2188|
                          DCD      0xb8001500
                  |L1.2192|
                          DCD      0xb8001600
                  |L1.2196|
                          DCD      0xb8001700
                  |L1.2200|
                          DCD      0xb800140c
                  |L1.2204|
                          DCD      0xb800150c
                  |L1.2208|
                          DCD      0xb800160c
                  |L1.2212|
                          DCD      0xb800170c
                  |L1.2216|
                          DCD      0xb8001410
                  |L1.2220|
                          DCD      0xb8001510
                  |L1.2224|
                          DCD      0xb8001610
                  |L1.2228|
                          DCD      0xb8001710
                  |L1.2232|
                          DCD      0xb8001418
                  |L1.2236|
                          DCD      0xb8001518
                  |L1.2240|
                          DCD      0xb8001618
                  |L1.2244|
                          DCD      0xb8001718
                  |L1.2248|
0008c8  2d3e2072          DCB      "-> runCapture\r\n",0
0008cc  756e4361
0008d0  70747572
0008d4  650d0a00
                  |L1.2264|
                          DCD      distValue
                  |L1.2268|
0008dc  2e00              DCB      ".",0
0008de  00                DCB      0
0008df  00                DCB      0
                  |L1.2272|
0008e0  67657454          DCB      "getTimes = %d \r\n",0
0008e4  696d6573
0008e8  203d2025
0008ec  64200d0a
0008f0  00      
0008f1  00                DCB      0
0008f2  00                DCB      0
0008f3  00                DCB      0
                  |L1.2292|
0008f4  72756e43          DCB      "runCapture TRUE [%d]: %d cm\r\n",0
0008f8  61707475
0008fc  72652054
000900  52554520
000904  5b25645d
000908  3a202564
00090c  20636d0d
000910  0a00    
000912  00                DCB      0
000913  00                DCB      0
                  |L1.2324|
000914  72756e43          DCB      "runCapture FALSE [%d]: %d cm\r\n",0
000918  61707475
00091c  72652046
000920  414c5345
000924  205b2564
000928  5d3a2025
00092c  6420636d
000930  0d0a00  
000933  00                DCB      0
                  |L1.2356|
                          DCD      0xb8001408
                  |L1.2360|
                          DCD      0x0000ffff
                          ENDP

                  ETMR1_IRQHandler PROC
;;;340    
;;;341    static void ETMR1_IRQHandler(void)
00093c  e92d41f0          PUSH     {r4-r8,lr}
;;;342    {
;;;343        // clear timer interrupt flag
;;;344        if(ETIMER_GetIntFlag(1))
000940  e3a00001          MOV      r0,#1
000944  ebfffffe          BL       ETIMER_GetIntFlag
000948  e3500000          CMP      r0,#0
00094c  0a000001          BEQ      |L1.2392|
;;;345        {
;;;346            ETIMER_ClearIntFlag(1);
000950  e3a00001          MOV      r0,#1
000954  ebfffffe          BL       ETIMER_ClearIntFlag
                  |L1.2392|
;;;347        }
;;;348        if(ETIMER_GetCaptureIntFlag(1))
000958  e3a00001          MOV      r0,#1
00095c  ebfffffe          BL       ETIMER_GetCaptureIntFlag
000960  e3500000          CMP      r0,#0
000964  0a00001f          BEQ      |L1.2536|
;;;349        {
;;;350            uint16_t distance;//, distance2;
;;;351            uint32_t data5 = (uint32_t)((uint64_t)ETIMER_GetCaptureData(1) * (uint64_t)100*(uint64_t)1000 /(uint64_t)inpw(REG_ETMR1_CMPR)); 
000968  e3a00001          MOV      r0,#1
00096c  ebfffffe          BL       ETIMER_GetCaptureData
000970  e3a01064          MOV      r1,#0x64
000974  e0832190          UMULL    r2,r3,r0,r1
000978  e3a01ffa          MOV      r1,#0x3e8
00097c  e3a00000          MOV      r0,#0
000980  e0886192          UMULL    r6,r8,r2,r1
000984  e0218193          MLA      r1,r3,r1,r8
000988  e0211092          MLA      r1,r2,r0,r1
00098c  e59f029c          LDR      r0,|L1.3120|
000990  e590c000          LDR      r12,[r0,#0]
000994  e1a0200c          MOV      r2,r12
000998  e3a03000          MOV      r3,#0
00099c  e1a00006          MOV      r0,r6
0009a0  ebfffffe          BL       __aeabi_uldivmod
0009a4  e1a05000          MOV      r5,r0
;;;352    
;;;353            distance = data5*34/100/2;
0009a8  e0851205          ADD      r1,r5,r5,LSL #4
0009ac  e1a00081          LSL      r0,r1,#1
0009b0  e3a01064          MOV      r1,#0x64
0009b4  ebfffffe          BL       __aeabi_uidivmod
0009b8  e51f1088          LDR      r1,|L1.2360|
0009bc  e00140a0          AND      r4,r1,r0,LSR #1
;;;354            //distance2 = data5*10/58;
;;;355            //sysprintf(" **> Get Capture (%d/%d): [%d] us, %d cm (%d mm, %d mm)\n", ETIMER_GetCaptureData(0), inpw(REG_ETMR0_CMPR), data5, distance/10, distance, distance2);
;;;356            //sysprintf(" **> [<2>: %03d cm]\n", distance/10);
;;;357            distValue[DIST_DEVICE_2] = distance/10;
0009c0  e3a0100a          MOV      r1,#0xa
0009c4  e1a00004          MOV      r0,r4
0009c8  ebfffffe          BL       __aeabi_idivmod
0009cc  e51f10fc          LDR      r1,|L1.2264|
0009d0  e5810004          STR      r0,[r1,#4]  ; distValue
;;;358            ETIMER_ClearCaptureIntFlag(1);
0009d4  e3a00001          MOV      r0,#1
0009d8  ebfffffe          BL       ETIMER_ClearCaptureIntFlag
;;;359            stopCapture(DIST_DEVICE_2);
0009dc  e3a00001          MOV      r0,#1
0009e0  ebfffffe          BL       stopCapture
;;;360        }   
0009e4  e1a00000          MOV      r0,r0
                  |L1.2536|
;;;361    
;;;362    }
0009e8  e8bd81f0          POP      {r4-r8,pc}
;;;363    static BOOL hwInit(void)
                          ENDP

                  hwInit PROC
0009ec  e92d4010          PUSH     {r4,lr}
;;;364    {       
;;;365        //outpw(REG_CLK_DIVCTL8,inpw(REG_CLK_DIVCTL8) | 0x550000); //Enable GPIO engin clock.
;;;366        //outpw(REG_CLK_DIVCTL8,(inpw(REG_CLK_DIVCTL8) & ~(0x550000)) | (0x550000));
;;;367        //outpw(REG_CLK_DIVCTL8,(inpw(REG_CLK_DIVCTL8) & ~(0x550000)));
;;;368        
;;;369        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
0009f0  e3a0020b          MOV      r0,#0xb0000000
0009f4  e5900218          LDR      r0,[r0,#0x218]
0009f8  e3800008          ORR      r0,r0,#8
0009fc  e3a0120b          MOV      r1,#0xb0000000
000a00  e5810218          STR      r0,[r1,#0x218]
;;;370        /* Configure PB4 PB0 to output mode */
;;;371        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<16)) | (0x0<<16));
000a04  e3a0020b          MOV      r0,#0xb0000000
000a08  e5900078          LDR      r0,[r0,#0x78]
000a0c  e3c0080f          BIC      r0,r0,#0xf0000
000a10  e5810078          STR      r0,[r1,#0x78]
;;;372        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<0)) | (0x0<<0));
000a14  e3a0020b          MOV      r0,#0xb0000000
000a18  e5900078          LDR      r0,[r0,#0x78]
000a1c  e3c0000f          BIC      r0,r0,#0xf
000a20  e5810078          STR      r0,[r1,#0x78]
;;;373        GPIO_OpenBit(OUTPUT_PORT_1, OUTPUT_PIN_1, DIR_OUTPUT, NO_PULL_UP);  
000a24  e3a03000          MOV      r3,#0
000a28  e3a02001          MOV      r2,#1
000a2c  e3a01010          MOV      r1,#0x10
000a30  e3a00040          MOV      r0,#0x40
000a34  ebfffffe          BL       GPIO_OpenBit
;;;374        GPIO_OpenBit(OUTPUT_PORT_2, OUTPUT_PIN_2, DIR_OUTPUT, NO_PULL_UP);  
000a38  e3a03000          MOV      r3,#0
000a3c  e3a02001          MOV      r2,#1
000a40  e1a01002          MOV      r1,r2
000a44  e3a00040          MOV      r0,#0x40
000a48  ebfffffe          BL       GPIO_OpenBit
;;;375        stopToggle(DIST_DEVICE_1);
000a4c  e3a00000          MOV      r0,#0
000a50  ebfffffe          BL       stopToggle
;;;376        stopToggle(DIST_DEVICE_2);
000a54  e3a00001          MOV      r0,#1
000a58  ebfffffe          BL       stopToggle
;;;377        
;;;378        /* Configure PB5 PB2 to output mode */
;;;379        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<20)) | (0x0<<20));
000a5c  e3a0020b          MOV      r0,#0xb0000000
000a60  e5900078          LDR      r0,[r0,#0x78]
000a64  e3c0060f          BIC      r0,r0,#0xf00000
000a68  e3a0120b          MOV      r1,#0xb0000000
000a6c  e5810078          STR      r0,[r1,#0x78]
;;;380        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<8)) | (0x0<<8));
000a70  e3a0020b          MOV      r0,#0xb0000000
000a74  e5900078          LDR      r0,[r0,#0x78]
000a78  e3c00c0f          BIC      r0,r0,#0xf00
000a7c  e5810078          STR      r0,[r1,#0x78]
;;;381        GPIO_OpenBit(POWER_PORT_1, POWER_PIN_1, DIR_OUTPUT, NO_PULL_UP);     
000a80  e3a03000          MOV      r3,#0
000a84  e3a02001          MOV      r2,#1
000a88  e3a01020          MOV      r1,#0x20
000a8c  e3a00040          MOV      r0,#0x40
000a90  ebfffffe          BL       GPIO_OpenBit
;;;382        GPIO_OpenBit(POWER_PORT_2, POWER_PIN_2, DIR_OUTPUT, NO_PULL_UP);  
000a94  e3a03000          MOV      r3,#0
000a98  e3a02001          MOV      r2,#1
000a9c  e3a01004          MOV      r1,#4
000aa0  e3a00040          MOV      r0,#0x40
000aa4  ebfffffe          BL       GPIO_OpenBit
;;;383        setPower(DIST_DEVICE_1, FALSE);
000aa8  e3a01000          MOV      r1,#0
000aac  e1a00001          MOV      r0,r1
000ab0  ebfffffe          BL       setPower
;;;384        setPower(DIST_DEVICE_2, FALSE);
000ab4  e3a01000          MOV      r1,#0
000ab8  e3a00001          MOV      r0,#1
000abc  ebfffffe          BL       setPower
;;;385    
;;;386    
;;;387        //capture ETIMER0 GPB3
;;;388        outpw(REG_CLK_PCLKEN0, inpw(REG_CLK_PCLKEN0) | (1 << 4)); // Enable ETIMER0 engine clock
000ac0  e3a0020b          MOV      r0,#0xb0000000
000ac4  e5900218          LDR      r0,[r0,#0x218]
000ac8  e3800010          ORR      r0,r0,#0x10
000acc  e3a0120b          MOV      r1,#0xb0000000
000ad0  e5810218          STR      r0,[r1,#0x218]
;;;389        outpw(REG_SYS_GPB_MFPL, (inpw(REG_SYS_GPB_MFPL) & ~(0xF << 12)) | (0xf << 12)); // Enable ETIMER0 capture out pin @ GPB3
000ad4  e3a0020b          MOV      r0,#0xb0000000
000ad8  e5900078          LDR      r0,[r0,#0x78]
000adc  e3800a0f          ORR      r0,r0,#0xf000
000ae0  e5810078          STR      r0,[r1,#0x78]
;;;390        ETIMER_Open(0, ETIMER_ONESHOT_MODE, 1); 
000ae4  e3a02001          MOV      r2,#1
000ae8  e3a01000          MOV      r1,#0
000aec  e1a00001          MOV      r0,r1
000af0  ebfffffe          BL       ETIMER_Open
;;;391        ETIMER_Stop(0);
000af4  e3a00000          MOV      r0,#0
000af8  ebfffffe          BL       ETIMER_Stop
;;;392        
;;;393        ETIMER_EnableInt(0);
000afc  e3a00000          MOV      r0,#0
000b00  ebfffffe          BL       ETIMER_EnableInt
;;;394        ETIMER_EnableCaptureInt(0);
000b04  e3a00000          MOV      r0,#0
000b08  ebfffffe          BL       ETIMER_EnableCaptureInt
;;;395        sysInstallISR(HIGH_LEVEL_SENSITIVE | IRQ_LEVEL_1, ETMR0_IRQn, (PVOID)ETMR0_IRQHandler);
000b0c  e59f2120          LDR      r2,|L1.3124|
000b10  e3a0102f          MOV      r1,#0x2f
000b14  e3a00041          MOV      r0,#0x41
000b18  ebfffffe          BL       sysInstallISR
;;;396        sysSetLocalInterrupt(ENABLE_IRQ);
000b1c  e3a0007f          MOV      r0,#0x7f
000b20  ebfffffe          BL       sysSetLocalInterrupt
;;;397        sysEnableInterrupt(ETMR0_IRQn);
000b24  e3a0002f          MOV      r0,#0x2f
000b28  ebfffffe          BL       sysEnableInterrupt
;;;398    
;;;399    
;;;400        //capture ETIMER1 GPB1
;;;401        outpw(REG_CLK_PCLKEN0, inpw(REG_CLK_PCLKEN0) | (1 << 5)); // Enable ETIMER1 engine clock
000b2c  e3a0020b          MOV      r0,#0xb0000000
000b30  e5900218          LDR      r0,[r0,#0x218]
000b34  e3800020          ORR      r0,r0,#0x20
000b38  e3a0120b          MOV      r1,#0xb0000000
000b3c  e5810218          STR      r0,[r1,#0x218]
;;;402        outpw(REG_SYS_GPB_MFPL, (inpw(REG_SYS_GPB_MFPL) & ~(0xF << 4)) | (0xd << 4)); // Enable ETIMER1 capture out pin @ GPB1
000b40  e3a0020b          MOV      r0,#0xb0000000
000b44  e5900078          LDR      r0,[r0,#0x78]
000b48  e3c000f0          BIC      r0,r0,#0xf0
000b4c  e38000d0          ORR      r0,r0,#0xd0
000b50  e5810078          STR      r0,[r1,#0x78]
;;;403        ETIMER_Open(1, ETIMER_ONESHOT_MODE, 1); 
000b54  e3a02001          MOV      r2,#1
000b58  e3a01000          MOV      r1,#0
000b5c  e1a00002          MOV      r0,r2
000b60  ebfffffe          BL       ETIMER_Open
;;;404        ETIMER_Stop(1);
000b64  e3a00001          MOV      r0,#1
000b68  ebfffffe          BL       ETIMER_Stop
;;;405        
;;;406        ETIMER_EnableInt(1);
000b6c  e3a00001          MOV      r0,#1
000b70  ebfffffe          BL       ETIMER_EnableInt
;;;407        ETIMER_EnableCaptureInt(1);
000b74  e3a00001          MOV      r0,#1
000b78  ebfffffe          BL       ETIMER_EnableCaptureInt
;;;408        sysInstallISR(HIGH_LEVEL_SENSITIVE | IRQ_LEVEL_1, ETMR1_IRQn, (PVOID)ETMR1_IRQHandler);
000b7c  e59f20b4          LDR      r2,|L1.3128|
000b80  e3a01030          MOV      r1,#0x30
000b84  e3a00041          MOV      r0,#0x41
000b88  ebfffffe          BL       sysInstallISR
;;;409        sysSetLocalInterrupt(ENABLE_IRQ);
000b8c  e3a0007f          MOV      r0,#0x7f
000b90  ebfffffe          BL       sysSetLocalInterrupt
;;;410        sysEnableInterrupt(ETMR1_IRQn);  
000b94  e3a00030          MOV      r0,#0x30
000b98  ebfffffe          BL       sysEnableInterrupt
;;;411    
;;;412        return TRUE;
000b9c  e3a00001          MOV      r0,#1
;;;413    }
000ba0  e8bd8010          POP      {r4,pc}
;;;414    
                          ENDP

                  SR04TDrvInit PROC
;;;417    /*-----------------------------------------*/
;;;418    BOOL SR04TDrvInit(void)
000ba4  e92d4010          PUSH     {r4,lr}
;;;419    {
;;;420        if(initFlag)
000ba8  e59f008c          LDR      r0,|L1.3132|
000bac  e5d00000          LDRB     r0,[r0,#0]  ; initFlag
000bb0  e3500000          CMP      r0,#0
000bb4  0a000001          BEQ      |L1.3008|
;;;421            return TRUE;
000bb8  e3a00001          MOV      r0,#1
                  |L1.3004|
;;;422        sysprintf("SR04TDrvInit!!\n");
;;;423        
;;;424        if(hwInit() == FALSE)
;;;425        {
;;;426            sysprintf("SR04TDrvInit ERROR (hwInit false)!!\n");
;;;427            return FALSE;
;;;428        }
;;;429        if(swInit() == FALSE)
;;;430        {
;;;431            sysprintf("SR04TDrvInit ERROR (swInit false)!!\n");
;;;432            return FALSE;
;;;433        }    
;;;434        
;;;435        initFlag = TRUE;
;;;436        return TRUE;
;;;437    }
000bbc  e8bd8010          POP      {r4,pc}
                  |L1.3008|
000bc0  e28f0078          ADR      r0,|L1.3136|
000bc4  ebfffffe          BL       sysprintf
000bc8  ebfffffe          BL       hwInit
000bcc  e3500000          CMP      r0,#0                 ;424
000bd0  1a000003          BNE      |L1.3044|
000bd4  e28f0074          ADR      r0,|L1.3152|
000bd8  ebfffffe          BL       sysprintf
000bdc  e3a00000          MOV      r0,#0                 ;427
000be0  eafffff5          B        |L1.3004|
                  |L1.3044|
000be4  ebfffffe          BL       swInit
000be8  e3500000          CMP      r0,#0                 ;429
000bec  1a000003          BNE      |L1.3072|
000bf0  e28f0080          ADR      r0,|L1.3192|
000bf4  ebfffffe          BL       sysprintf
000bf8  e3a00000          MOV      r0,#0                 ;432
000bfc  eaffffee          B        |L1.3004|
                  |L1.3072|
000c00  e3a00001          MOV      r0,#1                 ;435
000c04  e59f1030          LDR      r1,|L1.3132|
000c08  e5c10000          STRB     r0,[r1,#0]            ;435  ; initFlag
000c0c  e1a00000          MOV      r0,r0                 ;436
000c10  eaffffe9          B        |L1.3004|
;;;438    
                          ENDP

                  SR04TMeasureDist PROC
;;;439    BOOL SR04TMeasureDist(uint8_t id, int* detectResult)
000c14  e92d4070          PUSH     {r4-r6,lr}
;;;440    {
000c18  e1a04000          MOV      r4,r0
000c1c  e1a05001          MOV      r5,r1
;;;441        //return rangingTest(&MyDevice[id], detectResult); 
;;;442        return runCapture(id, detectResult);
000c20  e1a01005          MOV      r1,r5
000c24  e1a00004          MOV      r0,r4
000c28  ebfffffe          BL       runCapture
;;;443        //return TRUE;
;;;444    }
000c2c  e8bd8070          POP      {r4-r6,pc}
;;;445    
                          ENDP

                  |L1.3120|
                          DCD      0xb8001508
                  |L1.3124|
                          DCD      ETMR0_IRQHandler
                  |L1.3128|
                          DCD      ETMR1_IRQHandler
                  |L1.3132|
                          DCD      initFlag
                  |L1.3136|
000c40  53523034          DCB      "SR04TDrvInit!!\n",0
000c44  54447276
000c48  496e6974
000c4c  21210a00
                  |L1.3152|
000c50  53523034          DCB      "SR04TDrvInit ERROR (hwInit false)!!\n",0
000c54  54447276
000c58  496e6974
000c5c  20455252
000c60  4f522028
000c64  6877496e
000c68  69742066
000c6c  616c7365
000c70  2921210a
000c74  00      
000c75  00                DCB      0
000c76  00                DCB      0
000c77  00                DCB      0
                  |L1.3192|
000c78  53523034          DCB      "SR04TDrvInit ERROR (swInit false)!!\n",0
000c7c  54447276
000c80  496e6974
000c84  20455252
000c88  4f522028
000c8c  7377496e
000c90  69742066
000c94  616c7365
000c98  2921210a
000c9c  00      
000c9d  00                DCB      0
000c9e  00                DCB      0
000c9f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  initFlag
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  distValue
                          %        8
