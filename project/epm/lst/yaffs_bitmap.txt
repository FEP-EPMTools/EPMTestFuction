; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\yaffs_bitmap.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\yaffs_bitmap.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\yaffs_bitmap.crf ..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_bitmap.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  yaffs_block_bits PROC
;;;25     
;;;26     static __inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;27     {
000004  e1a04000          MOV      r4,r0
000008  e1a05001          MOV      r5,r1
;;;28     	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
00000c  e59400d0          LDR      r0,[r4,#0xd0]
000010  e1500005          CMP      r0,r5
000014  ca000002          BGT      |L1.36|
000018  e59400d4          LDR      r0,[r4,#0xd4]
00001c  e1500005          CMP      r0,r5
000020  aa00000c          BGE      |L1.88|
                  |L1.36|
;;;29     		yaffs_trace(YAFFS_TRACE_ERROR,
000024  e59f01a0          LDR      r0,|L1.460|
000028  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00002c  e3100101          TST      r0,#0x40000000
000030  0a000002          BEQ      |L1.64|
000034  e1a01005          MOV      r1,r5
000038  e28f0e19          ADR      r0,|L1.464|
00003c  ebfffffe          BL       sysprintf
                  |L1.64|
;;;30     			"BlockBits block %d is not valid",
;;;31     			blk);
;;;32     		BUG();
000040  e1a00000          MOV      r0,r0
000044  e3a02020          MOV      r2,#0x20
000048  e28f1f6a          ADR      r1,|L1.504|
00004c  e28f0f77          ADR      r0,|L1.560|
000050  ebfffffe          BL       sysprintf
000054  e1a00000          MOV      r0,r0
                  |L1.88|
;;;33     	}
;;;34     	return dev->chunk_bits +
000058  e59420d0          LDR      r2,[r4,#0xd0]
00005c  e0452002          SUB      r2,r5,r2
000060  e594011c          LDR      r0,[r4,#0x11c]
000064  e5941124          LDR      r1,[r4,#0x124]
000068  e0200291          MLA      r0,r1,r2,r0
;;;35     	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
;;;36     }
00006c  e8bd8070          POP      {r4-r6,pc}
;;;37     
                          ENDP

                  yaffs_verify_chunk_bit_id PROC
;;;38     void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
000070  e92d4070          PUSH     {r4-r6,lr}
;;;39     {
000074  e1a04000          MOV      r4,r0
000078  e1a05001          MOV      r5,r1
00007c  e1a06002          MOV      r6,r2
;;;40     	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
000080  e59400d0          LDR      r0,[r4,#0xd0]
000084  e1500005          CMP      r0,r5
000088  ca000007          BGT      |L1.172|
00008c  e59400d4          LDR      r0,[r4,#0xd4]
000090  e1500005          CMP      r0,r5
000094  ba000004          BLT      |L1.172|
;;;41     	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
000098  e3560000          CMP      r6,#0
00009c  ba000002          BLT      |L1.172|
0000a0  e594000c          LDR      r0,[r4,#0xc]
0000a4  e1500006          CMP      r0,r6
0000a8  ca00000d          BGT      |L1.228|
                  |L1.172|
;;;42     		yaffs_trace(YAFFS_TRACE_ERROR,
0000ac  e59f0118          LDR      r0,|L1.460|
0000b0  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0000b4  e3100101          TST      r0,#0x40000000
0000b8  0a000003          BEQ      |L1.204|
0000bc  e1a02006          MOV      r2,r6
0000c0  e1a01005          MOV      r1,r5
0000c4  e28f0f5f          ADR      r0,|L1.584|
0000c8  ebfffffe          BL       sysprintf
                  |L1.204|
;;;43     			"Chunk Id (%d:%d) invalid",
;;;44     			blk, chunk);
;;;45     		BUG();
0000cc  e1a00000          MOV      r0,r0
0000d0  e3a0202d          MOV      r2,#0x2d
0000d4  e28f1f47          ADR      r1,|L1.504|
0000d8  e28f0e15          ADR      r0,|L1.560|
0000dc  ebfffffe          BL       sysprintf
0000e0  e1a00000          MOV      r0,r0
                  |L1.228|
;;;46     	}
;;;47     }
0000e4  e8bd8070          POP      {r4-r6,pc}
;;;48     
                          ENDP

                  yaffs_clear_chunk_bits PROC
;;;49     void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
0000e8  e92d4070          PUSH     {r4-r6,lr}
;;;50     {
0000ec  e1a04000          MOV      r4,r0
0000f0  e1a05001          MOV      r5,r1
;;;51     	u8 *blk_bits = yaffs_block_bits(dev, blk);
0000f4  e1a01005          MOV      r1,r5
0000f8  e1a00004          MOV      r0,r4
0000fc  ebfffffe          BL       yaffs_block_bits
000100  e1a06000          MOV      r6,r0
;;;52     
;;;53     	memset(blk_bits, 0, dev->chunk_bit_stride);
000104  e1a00006          MOV      r0,r6
000108  e5941124          LDR      r1,[r4,#0x124]
00010c  ebfffffe          BL       __aeabi_memclr
;;;54     }
000110  e8bd8070          POP      {r4-r6,pc}
;;;55     
                          ENDP

                  yaffs_clear_chunk_bit PROC
;;;56     void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
000114  e92d41f0          PUSH     {r4-r8,lr}
;;;57     {
000118  e1a06000          MOV      r6,r0
00011c  e1a07001          MOV      r7,r1
000120  e1a04002          MOV      r4,r2
;;;58     	u8 *blk_bits = yaffs_block_bits(dev, blk);
000124  e1a01007          MOV      r1,r7
000128  e1a00006          MOV      r0,r6
00012c  ebfffffe          BL       yaffs_block_bits
000130  e1a05000          MOV      r5,r0
;;;59     
;;;60     	yaffs_verify_chunk_bit_id(dev, blk, chunk);
000134  e1a02004          MOV      r2,r4
000138  e1a01007          MOV      r1,r7
00013c  e1a00006          MOV      r0,r6
000140  ebfffffe          BL       yaffs_verify_chunk_bit_id
;;;61     	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
000144  e1a01fc4          ASR      r1,r4,#31
000148  e0841ea1          ADD      r1,r4,r1,LSR #29
00014c  e7d511c1          LDRB     r1,[r5,r1,ASR #3]
000150  e2042007          AND      r2,r4,#7
000154  e3a03001          MOV      r3,#1
000158  e1c11213          BIC      r1,r1,r3,LSL r2
00015c  e1a00004          MOV      r0,r4
000160  e1a02fc4          ASR      r2,r4,#31
000164  e0842ea2          ADD      r2,r4,r2,LSR #29
000168  e7c511c2          STRB     r1,[r5,r2,ASR #3]
;;;62     }
00016c  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP

                  yaffs_set_chunk_bit PROC
;;;64     void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
000170  e92d41f0          PUSH     {r4-r8,lr}
;;;65     {
000174  e1a06000          MOV      r6,r0
000178  e1a07001          MOV      r7,r1
00017c  e1a04002          MOV      r4,r2
;;;66     	u8 *blk_bits = yaffs_block_bits(dev, blk);
000180  e1a01007          MOV      r1,r7
000184  e1a00006          MOV      r0,r6
000188  ebfffffe          BL       yaffs_block_bits
00018c  e1a05000          MOV      r5,r0
;;;67     
;;;68     	yaffs_verify_chunk_bit_id(dev, blk, chunk);
000190  e1a02004          MOV      r2,r4
000194  e1a01007          MOV      r1,r7
000198  e1a00006          MOV      r0,r6
00019c  ebfffffe          BL       yaffs_verify_chunk_bit_id
;;;69     	blk_bits[chunk / 8] |= (1 << (chunk & 7));
0001a0  e1a01fc4          ASR      r1,r4,#31
0001a4  e0841ea1          ADD      r1,r4,r1,LSR #29
0001a8  e7d511c1          LDRB     r1,[r5,r1,ASR #3]
0001ac  e2042007          AND      r2,r4,#7
0001b0  e3a03001          MOV      r3,#1
0001b4  e1811213          ORR      r1,r1,r3,LSL r2
0001b8  e1a00004          MOV      r0,r4
0001bc  e1a02fc4          ASR      r2,r4,#31
0001c0  e0842ea2          ADD      r2,r4,r2,LSR #29
0001c4  e7c511c2          STRB     r1,[r5,r2,ASR #3]
;;;70     }
0001c8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.460|
                          DCD      yaffs_trace_mask
                  |L1.464|
0001d0  79616666          DCB      "yaffs: BlockBits block %d is not valid\n",0
0001d4  733a2042
0001d8  6c6f636b
0001dc  42697473
0001e0  20626c6f
0001e4  636b2025
0001e8  64206973
0001ec  206e6f74
0001f0  2076616c
0001f4  69640a00
                  |L1.504|
0001f8  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\yaffs_bit"
0001fc  2e5c636f
000200  6d6d6f6e
000204  5c737263
000208  5c425350
00020c  5c546869
000210  72645061
000214  7274795c
000218  79616666
00021c  73325c79
000220  61666673
000224  5f626974
000228  6d61702e          DCB      "map.c",0
00022c  6300    
00022e  00                DCB      0
00022f  00                DCB      0
                  |L1.560|
000230  552d426f          DCB      "U-Boot BUG at %s:%d!\n",0
000234  6f742042
000238  55472061
00023c  74202573
000240  3a256421
000244  0a00    
000246  00                DCB      0
000247  00                DCB      0
                  |L1.584|
000248  79616666          DCB      "yaffs: Chunk Id (%d:%d) invalid\n",0
00024c  733a2043
000250  68756e6b
000254  20496420
000258  2825643a
00025c  25642920
000260  696e7661
000264  6c69640a
000268  00      
000269  00                DCB      0
00026a  00                DCB      0
00026b  00                DCB      0
                          ENDP

                  yaffs_check_chunk_bit PROC
;;;71     
;;;72     int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
00026c  e92d41f0          PUSH     {r4-r8,lr}
;;;73     {
000270  e1a05000          MOV      r5,r0
000274  e1a06001          MOV      r6,r1
000278  e1a04002          MOV      r4,r2
;;;74     	u8 *blk_bits = yaffs_block_bits(dev, blk);
00027c  e1a01006          MOV      r1,r6
000280  e1a00005          MOV      r0,r5
000284  ebfffffe          BL       yaffs_block_bits
000288  e1a07000          MOV      r7,r0
;;;75     
;;;76     	yaffs_verify_chunk_bit_id(dev, blk, chunk);
00028c  e1a02004          MOV      r2,r4
000290  e1a01006          MOV      r1,r6
000294  e1a00005          MOV      r0,r5
000298  ebfffffe          BL       yaffs_verify_chunk_bit_id
;;;77     	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
00029c  e1a01004          MOV      r1,r4
0002a0  e1a00fc4          ASR      r0,r4,#31
0002a4  e0840ea0          ADD      r0,r4,r0,LSR #29
0002a8  e7d701c0          LDRB     r0,[r7,r0,ASR #3]
0002ac  e2042007          AND      r2,r4,#7
0002b0  e3a03001          MOV      r3,#1
0002b4  e1100213          TST      r0,r3,LSL r2
0002b8  0a000001          BEQ      |L1.708|
0002bc  e3a00001          MOV      r0,#1
                  |L1.704|
;;;78     }
0002c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.708|
0002c4  e3a00000          MOV      r0,#0                 ;77
0002c8  eafffffc          B        |L1.704|
;;;79     
                          ENDP

                  yaffs_still_some_chunks PROC
;;;80     int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
0002cc  e92d41f0          PUSH     {r4-r8,lr}
;;;81     {
0002d0  e1a04000          MOV      r4,r0
0002d4  e1a07001          MOV      r7,r1
;;;82     	u8 *blk_bits = yaffs_block_bits(dev, blk);
0002d8  e1a01007          MOV      r1,r7
0002dc  e1a00004          MOV      r0,r4
0002e0  ebfffffe          BL       yaffs_block_bits
0002e4  e1a05000          MOV      r5,r0
;;;83     	int i;
;;;84     
;;;85     	for (i = 0; i < dev->chunk_bit_stride; i++) {
0002e8  e3a06000          MOV      r6,#0
0002ec  ea000006          B        |L1.780|
                  |L1.752|
;;;86     		if (*blk_bits)
0002f0  e5d50000          LDRB     r0,[r5,#0]
0002f4  e3500000          CMP      r0,#0
0002f8  0a000001          BEQ      |L1.772|
;;;87     			return 1;
0002fc  e3a00001          MOV      r0,#1
                  |L1.768|
;;;88     		blk_bits++;
;;;89     	}
;;;90     	return 0;
;;;91     }
000300  e8bd81f0          POP      {r4-r8,pc}
                  |L1.772|
000304  e2855001          ADD      r5,r5,#1              ;88
000308  e2866001          ADD      r6,r6,#1              ;85
                  |L1.780|
00030c  e5940124          LDR      r0,[r4,#0x124]        ;85
000310  e1500006          CMP      r0,r6                 ;85
000314  cafffff5          BGT      |L1.752|
000318  e3a00000          MOV      r0,#0                 ;90
00031c  eafffff7          B        |L1.768|
;;;92     
                          ENDP

                  yaffs_count_chunk_bits PROC
;;;93     int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
000320  e92d41f0          PUSH     {r4-r8,lr}
;;;94     {
000324  e1a04000          MOV      r4,r0
000328  e1a08001          MOV      r8,r1
;;;95     	u8 *blk_bits = yaffs_block_bits(dev, blk);
00032c  e1a01008          MOV      r1,r8
000330  e1a00004          MOV      r0,r4
000334  ebfffffe          BL       yaffs_block_bits
000338  e1a05000          MOV      r5,r0
;;;96     	int i;
;;;97     	int n = 0;
00033c  e3a07000          MOV      r7,#0
;;;98     
;;;99     	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
000340  e3a06000          MOV      r6,#0
000344  ea00000f          B        |L1.904|
                  |L1.840|
;;;100    		n += hweight8(*blk_bits);
000348  e5d51000          LDRB     r1,[r5,#0]
00034c  e2012055          AND      r2,r1,#0x55
000350  e3a03055          MOV      r3,#0x55
000354  e00330a1          AND      r3,r3,r1,LSR #1
000358  e0820003          ADD      r0,r2,r3
00035c  e2002033          AND      r2,r0,#0x33
000360  e3a03033          MOV      r3,#0x33
000364  e0033120          AND      r3,r3,r0,LSR #2
000368  e0820003          ADD      r0,r2,r3
00036c  e200200f          AND      r2,r0,#0xf
000370  e3a0300f          MOV      r3,#0xf
000374  e0033220          AND      r3,r3,r0,LSR #4
000378  e0822003          ADD      r2,r2,r3
00037c  e0877002          ADD      r7,r7,r2
000380  e2866001          ADD      r6,r6,#1              ;99
000384  e2855001          ADD      r5,r5,#1              ;99
                  |L1.904|
000388  e5940124          LDR      r0,[r4,#0x124]        ;99
00038c  e1500006          CMP      r0,r6                 ;99
000390  caffffec          BGT      |L1.840|
;;;101    
;;;102    	return n;
000394  e1a00007          MOV      r0,r7
;;;103    }
000398  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

