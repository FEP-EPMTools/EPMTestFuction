; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uart.crf ..\..\common\src\BSP\Driver\Source\uart.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _uartRxBufGetNextOne PROC
;;;661    
;;;662    static UINT32 _uartRxBufGetNextOne(INT nNum, UINT32 uPointer)
000000  e1a02000          MOV      r2,r0
;;;663    {
;;;664        if((uPointer + 1) == UARTRXBUFSIZE[nNum])
000004  e59f0e10          LDR      r0,|L1.3612|
000008  e7900102          LDR      r0,[r0,r2,LSL #2]
00000c  e2813001          ADD      r3,r1,#1
000010  e1500003          CMP      r0,r3
000014  1a000001          BNE      |L1.32|
;;;665            return NULL;
000018  e3a00000          MOV      r0,#0
                  |L1.28|
;;;666        else
;;;667            return (uPointer + 1);
;;;668    }
00001c  e12fff1e          BX       lr
                  |L1.32|
000020  e2810001          ADD      r0,r1,#1              ;667
000024  eafffffc          B        |L1.28|
;;;669    
                          ENDP

                  _uartReceiveChars PROC
;;;691    
;;;692    static void _uartReceiveChars(INT nNum)
000028  e92d40f0          PUSH     {r4-r7,lr}
;;;693    {
00002c  e24dd024          SUB      sp,sp,#0x24
000030  e1a05000          MOV      r5,r0
;;;694        //UINT32 volatile uRegLSR, uBuf = 0;
;;;695        UINT32 volatile uRegFSR, uRegALT_CSR, uRegFUN_SEL, uRegFCR, uRegLINSR, uRegISR;
;;;696        UINT32 volatile uBuf = 0;
000034  e3a00000          MOV      r0,#0
000038  e58d0008          STR      r0,[sp,#8]
;;;697    	UINT32 volatile uOffset = nNum * UARTOFFSET;
00003c  e1a00405          LSL      r0,r5,#8
000040  e58d0004          STR      r0,[sp,#4]
;;;698        INT nMaxCount = 256;
000044  e3a07c01          MOV      r7,#0x100
;;;699        UCHAR ucChar;
;;;700    
;;;701        UART_BUFFER_T *dev;
;;;702    
;;;703        dev = (UART_BUFFER_T *) &UART_DEV[nNum];
000048  e0850085          ADD      r0,r5,r5,LSL #1
00004c  e59f1dcc          LDR      r1,|L1.3616|
000050  e0814200          ADD      r4,r1,r0,LSL #4
;;;704    
;;;705        //uRegFSR = inpw(REG_UART0_FSR+(nNum * UARTOFFSET));
;;;706    	uRegFUN_SEL = inpw(REG_UART0_FUN_SEL+uOffset);
000054  e59d0004          LDR      r0,[sp,#4]
000058  e280032e          ADD      r0,r0,#0xb8000000
00005c  e5900030          LDR      r0,[r0,#0x30]
000060  e58d0018          STR      r0,[sp,#0x18]
;;;707    
;;;708        do {
000064  e1a00000          MOV      r0,r0
                  |L1.104|
;;;709    			uRegFSR = inpw(REG_UART0_FSR+uOffset);
000068  e59d0004          LDR      r0,[sp,#4]
00006c  e280032e          ADD      r0,r0,#0xb8000000
000070  e5900018          LDR      r0,[r0,#0x18]
000074  e58d0020          STR      r0,[sp,#0x20]
;;;710    			uRegLINSR = inpw(REG_UART0_LIN_SR+uOffset);
000078  e59d0004          LDR      r0,[sp,#4]
00007c  e280032e          ADD      r0,r0,#0xb8000000
000080  e5900038          LDR      r0,[r0,#0x38]
000084  e58d0010          STR      r0,[sp,#0x10]
;;;711    			uRegISR = inpw(REG_UART0_ISR+uOffset);
000088  e59d0004          LDR      r0,[sp,#4]
00008c  e280032e          ADD      r0,r0,#0xb8000000
000090  e590001c          LDR      r0,[r0,#0x1c]
000094  e58d000c          STR      r0,[sp,#0xc]
;;;712    			ucChar = inpb(REG_UART0_RBR+uOffset);
000098  e59d0004          LDR      r0,[sp,#4]
00009c  e280032e          ADD      r0,r0,#0xb8000000
0000a0  e5d06000          LDRB     r6,[r0,#0]
;;;713    		
;;;714    			if( (uRegFSR & UART_FSR_RS485_ADD_DETF_Msk) && (uRegFUN_SEL == 0x3) )
0000a4  e59d0020          LDR      r0,[sp,#0x20]
0000a8  e3100008          TST      r0,#8
0000ac  0a000023          BEQ      |L1.320|
0000b0  e59d0018          LDR      r0,[sp,#0x18]
0000b4  e3500003          CMP      r0,#3
0000b8  1a000020          BNE      |L1.320|
;;;715    			{		
;;;716    				uRegALT_CSR = inpw(REG_UART0_ALT_CSR+(nNum*UARTOFFSET));
0000bc  e3a0032e          MOV      r0,#0xb8000000
0000c0  e0800405          ADD      r0,r0,r5,LSL #8
0000c4  e590002c          LDR      r0,[r0,#0x2c]
0000c8  e58d001c          STR      r0,[sp,#0x1c]
;;;717    				uRegFCR = inpw(REG_UART0_FCR+(nNum*UARTOFFSET));
0000cc  e3a0032e          MOV      r0,#0xb8000000
0000d0  e0800405          ADD      r0,r0,r5,LSL #8
0000d4  e5900008          LDR      r0,[r0,#8]
0000d8  e58d0014          STR      r0,[sp,#0x14]
;;;718    				if( uRegALT_CSR & UART_ALT_CSR_RS485_NMM_Msk )
0000dc  e59d001c          LDR      r0,[sp,#0x1c]
0000e0  e3100c01          TST      r0,#0x100
0000e4  0a000015          BEQ      |L1.320|
;;;719    				{
;;;720    					if ( ucChar == (uRegALT_CSR >> UART_ALT_CSR_ADDR_MATCH_Pos))
0000e8  e59d001c          LDR      r0,[sp,#0x1c]
0000ec  e1560c20          CMP      r6,r0,LSR #24
0000f0  1a000007          BNE      |L1.276|
;;;721    					{				
;;;722    						uRegFCR &= ~UART_FCR_RX_DIS_Msk;  /* Enable RS485 RX */
0000f4  e59d0014          LDR      r0,[sp,#0x14]
0000f8  e3c00c01          BIC      r0,r0,#0x100
0000fc  e58d0014          STR      r0,[sp,#0x14]
;;;723    						outpw((REG_UART0_FCR+(nNum*UARTOFFSET)), uRegFCR);
000100  e3a0132e          MOV      r1,#0xb8000000
000104  e0811405          ADD      r1,r1,r5,LSL #8
000108  e59d0014          LDR      r0,[sp,#0x14]
00010c  e5810008          STR      r0,[r1,#8]
000110  ea00000a          B        |L1.320|
                  |L1.276|
;;;724    					}
;;;725    					else
;;;726    					{ 	
;;;727    						uRegFCR |= UART_FCR_RX_DIS_Msk;  /* Disable RS485 RX */
000114  e59d0014          LDR      r0,[sp,#0x14]
000118  e3800c01          ORR      r0,r0,#0x100
00011c  e58d0014          STR      r0,[sp,#0x14]
;;;728    						uRegFCR |= UART_FCR_RFR_Msk;  /* Clear data from RX FIFO */
000120  e59d0014          LDR      r0,[sp,#0x14]
000124  e3800002          ORR      r0,r0,#2
000128  e58d0014          STR      r0,[sp,#0x14]
;;;729    						outpw((REG_UART0_FCR+(nNum*UARTOFFSET)), uRegFCR);
00012c  e3a0132e          MOV      r1,#0xb8000000
000130  e0811405          ADD      r1,r1,r5,LSL #8
000134  e59d0014          LDR      r0,[sp,#0x14]
000138  e5810008          STR      r0,[r1,#8]
;;;730    						break;
00013c  ea000066          B        |L1.732|
                  |L1.320|
;;;731    					}
;;;732    				}
;;;733    			}
;;;734    		
;;;735    		
;;;736            uBuf = _uartRxBufGetNextOne(nNum, dev->uUartRxTail);
000140  e594100c          LDR      r1,[r4,#0xc]
000144  e1a00005          MOV      r0,r5
000148  ebfffffe          BL       _uartRxBufGetNextOne
00014c  e58d0008          STR      r0,[sp,#8]
;;;737            if(uBuf == dev->uUartRxHead) { /* Rx buffer full */
000150  e5940008          LDR      r0,[r4,#8]
000154  e59d1008          LDR      r1,[sp,#8]
000158  e1500001          CMP      r0,r1
00015c  1a000002          BNE      |L1.364|
;;;738                //ucChar = inpb(REG_UART0_RBR+(nNum * UARTOFFSET));
;;;739    
;;;740                if (_uart_cHWRXStopped)
000160  e59f0cbc          LDR      r0,|L1.3620|
000164  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cHWRXStopped
;;;741                    U1DEBUG("[%d] buf full!\n", nNum);
;;;742    
;;;743                break;
000168  ea00005b          B        |L1.732|
                  |L1.364|
;;;744            }
;;;745    
;;;746            //ucChar = inpb(REG_UART0_RBR+(nNum * UARTOFFSET));
;;;747    
;;;748            dev->pucUartRxBuf[dev->uUartRxTail] = ucChar;
00016c  e5940014          LDR      r0,[r4,#0x14]
000170  e594100c          LDR      r1,[r4,#0xc]
000174  e7c06001          STRB     r6,[r0,r1]
;;;749    
;;;750            /* Check LSR for BII, FEI, PEI, OEI */
;;;751            dev->pucUARTFlag[dev->uUartRxTail] = 0;
000178  e3a00000          MOV      r0,#0
00017c  e5941020          LDR      r1,[r4,#0x20]
000180  e594200c          LDR      r2,[r4,#0xc]
000184  e7810102          STR      r0,[r1,r2,LSL #2]
;;;752    
;;;753            if(uRegFSR & UART_FSR_BIF_Msk) {
000188  e59d0020          LDR      r0,[sp,#0x20]
00018c  e3100040          TST      r0,#0x40
000190  0a000004          BEQ      |L1.424|
;;;754                dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_BIF_Msk;
000194  e3a00040          MOV      r0,#0x40
000198  e5941020          LDR      r1,[r4,#0x20]
00019c  e594200c          LDR      r2,[r4,#0xc]
0001a0  e7810102          STR      r0,[r1,r2,LSL #2]
0001a4  ea00001e          B        |L1.548|
                  |L1.424|
;;;755                U1DEBUG("BIF!\n");
;;;756            } else if(uRegFSR & UART_FSR_FEF_Msk) {
0001a8  e59d0020          LDR      r0,[sp,#0x20]
0001ac  e3100020          TST      r0,#0x20
0001b0  0a000004          BEQ      |L1.456|
;;;757                dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_FEF_Msk;
0001b4  e3a00020          MOV      r0,#0x20
0001b8  e5941020          LDR      r1,[r4,#0x20]
0001bc  e594200c          LDR      r2,[r4,#0xc]
0001c0  e7810102          STR      r0,[r1,r2,LSL #2]
0001c4  ea000016          B        |L1.548|
                  |L1.456|
;;;758                U1DEBUG("FEF!\n");
;;;759            } else if(uRegFSR & UART_FSR_PEF_Msk) {
0001c8  e59d0020          LDR      r0,[sp,#0x20]
0001cc  e3100010          TST      r0,#0x10
0001d0  0a000004          BEQ      |L1.488|
;;;760                dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_PEF_Msk;
0001d4  e3a00010          MOV      r0,#0x10
0001d8  e5941020          LDR      r1,[r4,#0x20]
0001dc  e594200c          LDR      r2,[r4,#0xc]
0001e0  e7810102          STR      r0,[r1,r2,LSL #2]
0001e4  ea00000e          B        |L1.548|
                  |L1.488|
;;;761                U1DEBUG("PEF!\n");
;;;762            } else if (uRegFSR & UART_FSR_RX_OVER_IF_Msk) {
0001e8  e59d0020          LDR      r0,[sp,#0x20]
0001ec  e3100001          TST      r0,#1
0001f0  0a000004          BEQ      |L1.520|
;;;763    			dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_RX_OVER_IF_Msk;
0001f4  e3a00001          MOV      r0,#1
0001f8  e5941020          LDR      r1,[r4,#0x20]
0001fc  e594200c          LDR      r2,[r4,#0xc]
000200  e7810102          STR      r0,[r1,r2,LSL #2]
000204  ea000006          B        |L1.548|
                  |L1.520|
;;;764                U1DEBUG("OVER_IF!\n");
;;;765    		}else if(uRegFSR & UART_FSR_RS485_ADD_DETF_Msk){
000208  e59d0020          LDR      r0,[sp,#0x20]
00020c  e3100008          TST      r0,#8
000210  0a000003          BEQ      |L1.548|
;;;766    			dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_RS485_ADD_DETF_Msk;
000214  e3a00008          MOV      r0,#8
000218  e5941020          LDR      r1,[r4,#0x20]
00021c  e594200c          LDR      r2,[r4,#0xc]
000220  e7810102          STR      r0,[r1,r2,LSL #2]
                  |L1.548|
;;;767    			U1DEBUG("RS485_ADD_DET_IF!\n");			
;;;768    		}
;;;769    
;;;770    		if(uRegFUN_SEL == 0x1)
000224  e59d0018          LDR      r0,[sp,#0x18]
000228  e3500001          CMP      r0,#1
00022c  1a00000b          BNE      |L1.608|
;;;771    		{
;;;772    			if(uRegISR & UART_ISR_LIN_RX_BREAK_IF_Msk)
000230  e59d000c          LDR      r0,[sp,#0xc]
000234  e3100080          TST      r0,#0x80
000238  0a000008          BEQ      |L1.608|
;;;773    			{
;;;774    				dev->pucLINFlag[dev->uUartRxTail] = uRegLINSR;
00023c  e59d0010          LDR      r0,[sp,#0x10]
000240  e5941024          LDR      r1,[r4,#0x24]
000244  e594200c          LDR      r2,[r4,#0xc]
000248  e7810102          STR      r0,[r1,r2,LSL #2]
;;;775    				
;;;776    				// Clear ISR and LIN Status 
;;;777    				outpw(REG_UART0_ISR, UART_ISR_LIN_RX_BREAK_IF_Msk);
00024c  e3a00080          MOV      r0,#0x80
000250  e3a0132e          MOV      r1,#0xb8000000
000254  e581001c          STR      r0,[r1,#0x1c]
;;;778    				outpw(REG_UART0_LIN_SR, 0x30F);
000258  e59f0bc8          LDR      r0,|L1.3624|
00025c  e5810038          STR      r0,[r1,#0x38]
                  |L1.608|
;;;779    			}
;;;780    		}
;;;781    		
;;;782            dev->uUartRxTail = _uartRxBufGetNextOne(nNum, dev->uUartRxTail);
000260  e594100c          LDR      r1,[r4,#0xc]
000264  e1a00005          MOV      r0,r5
000268  ebfffffe          BL       _uartRxBufGetNextOne
00026c  e584000c          STR      r0,[r4,#0xc]
;;;783            dev->uRecCnt++;
000270  e5940028          LDR      r0,[r4,#0x28]
000274  e2800001          ADD      r0,r0,#1
000278  e5840028          STR      r0,[r4,#0x28]
;;;784    
;;;785            /* overrun error is special case, H/W ignore the character */
;;;786            if(uRegFSR & UART_FSR_RX_OVER_IF_Msk) {
00027c  e59d0020          LDR      r0,[sp,#0x20]
000280  e3100001          TST      r0,#1
000284  0a00000a          BEQ      |L1.692|
;;;787                dev->pucUARTFlag[dev->uUartRxTail] = UART_FSR_RX_OVER_IF_Msk;
000288  e3a00001          MOV      r0,#1
00028c  e5941020          LDR      r1,[r4,#0x20]
000290  e594200c          LDR      r2,[r4,#0xc]
000294  e7810102          STR      r0,[r1,r2,LSL #2]
;;;788                dev->uUartRxTail = _uartRxBufGetNextOne(nNum, dev->uUartRxTail);
000298  e594100c          LDR      r1,[r4,#0xc]
00029c  e1a00005          MOV      r0,r5
0002a0  ebfffffe          BL       _uartRxBufGetNextOne
0002a4  e584000c          STR      r0,[r4,#0xc]
;;;789                dev->uRecCnt++;
0002a8  e5940028          LDR      r0,[r4,#0x28]
0002ac  e2800001          ADD      r0,r0,#1
0002b0  e5840028          STR      r0,[r4,#0x28]
                  |L1.692|
;;;790            }
;;;791    
;;;792            uRegFSR = inpw(REG_UART0_FSR+(nNum * UARTOFFSET));
0002b4  e3a0032e          MOV      r0,#0xb8000000
0002b8  e0800405          ADD      r0,r0,r5,LSL #8
0002bc  e5900018          LDR      r0,[r0,#0x18]
0002c0  e58d0020          STR      r0,[sp,#0x20]
;;;793        } while((!(uRegFSR & UART_FSR_RX_EMPTY_Msk)) && (nMaxCount-- > 0));
0002c4  e59d0020          LDR      r0,[sp,#0x20]
0002c8  e3100901          TST      r0,#0x4000
0002cc  1a000002          BNE      |L1.732|
0002d0  e2570000          SUBS     r0,r7,#0
0002d4  e2477001          SUB      r7,r7,#1
0002d8  caffff62          BGT      |L1.104|
                  |L1.732|
0002dc  e1a00000          MOV      r0,r0                 ;730
;;;794    
;;;795        //add by sam
;;;796        //sysprintf(" !!! _uartReceiveChars : %d\n", nNum);
;;;797        {
;;;798            BaseType_t xHigherPriorityTaskWoken = pdFALSE;
0002e0  e3a00000          MOV      r0,#0
0002e4  e58d0000          STR      r0,[sp,#0]
;;;799            xSemaphoreGiveFromISR( xuartSemaphore[nNum], &xHigherPriorityTaskWoken );
0002e8  e59f1b3c          LDR      r1,|L1.3628|
0002ec  e7910105          LDR      r0,[r1,r5,LSL #2]
0002f0  e1a0100d          MOV      r1,sp
0002f4  ebfffffe          BL       xQueueGiveFromISR
;;;800            portEXIT_SWITCHING_ISR (xHigherPriorityTaskWoken);
0002f8  e59d0000          LDR      r0,[sp,#0]
0002fc  e3500000          CMP      r0,#0
000300  0a000000          BEQ      |L1.776|
000304  ebfffffe          BL       vTaskSwitchContext
                  |L1.776|
;;;801        }
;;;802    
;;;803        
;;;804    }
000308  e28dd024          ADD      sp,sp,#0x24
00030c  e8bd80f0          POP      {r4-r7,pc}
;;;805    
                          ENDP

                  RS485_HANDLE PROC
;;;171    
;;;172    void RS485_HANDLE(INT nNum)  
000310  e92d401c          PUSH     {r2-r4,lr}
;;;173    {
000314  e1a04000          MOV      r4,r0
;;;174    	UINT32 volatile uRegISR, uRegFSR, uRegALT_CSR;
;;;175    
;;;176        uRegISR = inpw(REG_UART0_ISR+(nNum*UARTOFFSET));
000318  e3a0032e          MOV      r0,#0xb8000000
00031c  e0800404          ADD      r0,r0,r4,LSL #8
000320  e590001c          LDR      r0,[r0,#0x1c]
000324  e58d0004          STR      r0,[sp,#4]
;;;177    	uRegFSR = inpw(REG_UART0_FSR+(nNum*UARTOFFSET));
000328  e3a0032e          MOV      r0,#0xb8000000
00032c  e0800404          ADD      r0,r0,r4,LSL #8
000330  e5900018          LDR      r0,[r0,#0x18]
000334  e58d0000          STR      r0,[sp,#0]
;;;178                
;;;179    	if((uRegISR & UART_ISR_RLS_IF_Msk) && (uRegISR & UART_ISR_RDA_IF_Msk))  /* RLS INT & RDA INT */  //For RS485 Detect Address
000338  e59d0004          LDR      r0,[sp,#4]
00033c  e3100004          TST      r0,#4
000340  0a00000c          BEQ      |L1.888|
000344  e59d0004          LDR      r0,[sp,#4]
000348  e3100001          TST      r0,#1
00034c  0a000009          BEQ      |L1.888|
;;;180        {   
;;;181    		if(uRegFSR & UART_FSR_RS485_ADD_DETF_Msk)  /* ADD_IF, RS485 mode */
000350  e59d0000          LDR      r0,[sp,#0]
000354  e3100008          TST      r0,#8
000358  0a00000b          BEQ      |L1.908|
;;;182            {   
;;;183    			_uartReceiveChars(nNum);
00035c  e1a00004          MOV      r0,r4
000360  ebfffffe          BL       _uartReceiveChars
;;;184    			outpw((REG_UART0_FSR+(nNum*UARTOFFSET)), UART_FSR_RS485_ADD_DETF_Msk);  /* clear ADD_IF flag */
000364  e3a00008          MOV      r0,#8
000368  e3a0132e          MOV      r1,#0xb8000000
00036c  e0811404          ADD      r1,r1,r4,LSL #8
000370  e5810018          STR      r0,[r1,#0x18]
000374  ea000004          B        |L1.908|
                  |L1.888|
;;;185            }
;;;186        }
;;;187        else if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Rx Ready or Time-out INT*/   
000378  e59d0004          LDR      r0,[sp,#4]
00037c  e3100011          TST      r0,#0x11
000380  0a000001          BEQ      |L1.908|
;;;188        {
;;;189            /* Handle received data */
;;;190    		_uartReceiveChars(nNum);
000384  e1a00004          MOV      r0,r4
000388  ebfffffe          BL       _uartReceiveChars
                  |L1.908|
;;;191        }
;;;192    
;;;193    	if(uRegISR & UART_ISR_RLS_IF_Msk) {
00038c  e59d0004          LDR      r0,[sp,#4]
000390  e3100004          TST      r0,#4
000394  0a000009          BEQ      |L1.960|
;;;194            uRegFSR = inpw(REG_UART0_FSR+(nNum*UARTOFFSET));
000398  e3a0032e          MOV      r0,#0xb8000000
00039c  e0800404          ADD      r0,r0,r4,LSL #8
0003a0  e5900018          LDR      r0,[r0,#0x18]
0003a4  e58d0000          STR      r0,[sp,#0]
;;;195            if(uRegFSR & UART_FSR_BIF_Msk)
0003a8  e59d0000          LDR      r0,[sp,#0]
0003ac  e3100040          TST      r0,#0x40
0003b0  0a000002          BEQ      |L1.960|
;;;196                _uart_cBIIState_0 = 1;
0003b4  e3a00001          MOV      r0,#1
0003b8  e59f1a70          LDR      r1,|L1.3632|
0003bc  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_0
                  |L1.960|
;;;197        }
;;;198    }
0003c0  e8bd801c          POP      {r2-r4,pc}
;;;199    
                          ENDP

                  _uartDisableInterrupt PROC
;;;678    
;;;679    static void _uartDisableInterrupt(INT nNum, UINT32 uVal)
0003c4  e3a02000          MOV      r2,#0
;;;680    {
;;;681        UINT32 uReg = 0;
;;;682    
;;;683        if(uVal == DISABLEALLIER)
0003c8  e3510000          CMP      r1,#0
0003cc  1a000004          BNE      |L1.996|
;;;684            outpw(REG_UART0_IER+(nNum * UARTOFFSET), 0);
0003d0  e3a03000          MOV      r3,#0
0003d4  e3a0c32e          MOV      r12,#0xb8000000
0003d8  e08cc400          ADD      r12,r12,r0,LSL #8
0003dc  e58c3004          STR      r3,[r12,#4]
0003e0  ea000006          B        |L1.1024|
                  |L1.996|
;;;685        else {
;;;686            uReg = inpw(REG_UART0_IER+(nNum * UARTOFFSET));
0003e4  e3a0332e          MOV      r3,#0xb8000000
0003e8  e0833400          ADD      r3,r3,r0,LSL #8
0003ec  e5932004          LDR      r2,[r3,#4]
;;;687            uReg &= ~uVal;
0003f0  e1c22001          BIC      r2,r2,r1
;;;688            outpw(REG_UART0_IER+(nNum * UARTOFFSET), uReg);
0003f4  e3a0332e          MOV      r3,#0xb8000000
0003f8  e0833400          ADD      r3,r3,r0,LSL #8
0003fc  e5832004          STR      r2,[r3,#4]
                  |L1.1024|
;;;689        }
;;;690    }
000400  e12fff1e          BX       lr
;;;691    
                          ENDP

                  _uartTxBufGetNextOne PROC
;;;653    
;;;654    static UINT32 _uartTxBufGetNextOne(INT nNum, UINT32 uPointer)
000404  e1a02000          MOV      r2,r0
;;;655    {
;;;656        if((uPointer + 1) == UARTTXBUFSIZE[nNum])
000408  e59f0a24          LDR      r0,|L1.3636|
00040c  e7900102          LDR      r0,[r0,r2,LSL #2]
000410  e2813001          ADD      r3,r1,#1
000414  e1500003          CMP      r0,r3
000418  1a000001          BNE      |L1.1060|
;;;657            return NULL;
00041c  e3a00000          MOV      r0,#0
                  |L1.1056|
;;;658        else
;;;659            return (uPointer + 1);
;;;660    }
000420  e12fff1e          BX       lr
                  |L1.1060|
000424  e2810001          ADD      r0,r1,#1              ;659
000428  eafffffc          B        |L1.1056|
;;;661    
                          ENDP

                  _uartTransmitChars PROC
;;;805    
;;;806    static void _uartTransmitChars(INT nNum)
00042c  e92d4038          PUSH     {r3-r5,lr}
;;;807    {
000430  e1a05000          MOV      r5,r0
;;;808        UINT32 volatile i;
;;;809    
;;;810        UART_BUFFER_T *dev;
;;;811    
;;;812        dev = (UART_BUFFER_T *) &UART_DEV[nNum];
000434  e0850085          ADD      r0,r5,r5,LSL #1
000438  e59f19e0          LDR      r1,|L1.3616|
00043c  e0814200          ADD      r4,r1,r0,LSL #4
;;;813    
;;;814        if(dev->uUartTxHead != dev->uUartTxTail) { /* buffer is not empty */
000440  e5940000          LDR      r0,[r4,#0]
000444  e5941004          LDR      r1,[r4,#4]
000448  e1500001          CMP      r0,r1
00044c  0a00001a          BEQ      |L1.1212|
;;;815            for (i=0; i<8; i++) {
000450  e3a00000          MOV      r0,#0
000454  e58d0000          STR      r0,[sp,#0]
000458  ea000013          B        |L1.1196|
                  |L1.1116|
;;;816                outpw(REG_UART0_THR+(nNum * UARTOFFSET), dev->pucUartTxBuf[dev->uUartTxHead]);
00045c  e5940010          LDR      r0,[r4,#0x10]
000460  e5941000          LDR      r1,[r4,#0]
000464  e7d00001          LDRB     r0,[r0,r1]
000468  e3a0132e          MOV      r1,#0xb8000000
00046c  e7810405          STR      r0,[r1,r5,LSL #8]
;;;817                dev->uUartTxHead = _uartTxBufGetNextOne(nNum, dev->uUartTxHead);
000470  e5941000          LDR      r1,[r4,#0]
000474  e1a00005          MOV      r0,r5
000478  ebfffffe          BL       _uartTxBufGetNextOne
00047c  e5840000          STR      r0,[r4,#0]
;;;818    
;;;819                if(dev->uUartTxHead == dev->uUartTxTail) { /* buffer empty */
000480  e5940000          LDR      r0,[r4,#0]
000484  e5941004          LDR      r1,[r4,#4]
000488  e1500001          CMP      r0,r1
00048c  1a000003          BNE      |L1.1184|
;;;820                    _uartDisableInterrupt(nNum, UART_IER_THRE_IEN_Msk);
000490  e3a01002          MOV      r1,#2
000494  e1a00005          MOV      r0,r5
000498  ebfffffe          BL       _uartDisableInterrupt
;;;821                    break;
00049c  ea000005          B        |L1.1208|
                  |L1.1184|
0004a0  e59d0000          LDR      r0,[sp,#0]            ;815
0004a4  e2800001          ADD      r0,r0,#1              ;815
0004a8  e58d0000          STR      r0,[sp,#0]            ;815
                  |L1.1196|
0004ac  e59d0000          LDR      r0,[sp,#0]            ;815
0004b0  e3500008          CMP      r0,#8                 ;815
0004b4  3affffe8          BCC      |L1.1116|
                  |L1.1208|
0004b8  e1a00000          MOV      r0,r0
                  |L1.1212|
;;;822                }
;;;823            }
;;;824        }
;;;825    }
0004bc  e8bd8038          POP      {r3-r5,pc}
;;;826    
                          ENDP

                  uart0ISR PROC
                  |L1.1216|
;;;199    
;;;200    void uart0ISR(void)
0004c0  e92d401c          PUSH     {r2-r4,lr}
;;;201    {
;;;202        UINT32 volatile uRegISR, uRegFSR;
;;;203    
;;;204        uRegISR = inpw(REG_UART0_ISR) & 0x0f;
0004c4  e3a0032e          MOV      r0,#0xb8000000
0004c8  e590001c          LDR      r0,[r0,#0x1c]
0004cc  e200000f          AND      r0,r0,#0xf
0004d0  e58d0004          STR      r0,[sp,#4]
;;;205    
;;;206        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
0004d4  e59d0004          LDR      r0,[sp,#4]
0004d8  e3100002          TST      r0,#2
0004dc  0a000001          BEQ      |L1.1256|
;;;207            _uartTransmitChars(UART0);
0004e0  e3a00000          MOV      r0,#0
0004e4  ebfffffe          BL       _uartTransmitChars
                  |L1.1256|
;;;208    
;;;209        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
0004e8  e59d0004          LDR      r0,[sp,#4]
0004ec  e3100011          TST      r0,#0x11
0004f0  0a000001          BEQ      |L1.1276|
;;;210            _uartReceiveChars(UART0);
0004f4  e3a00000          MOV      r0,#0
0004f8  ebfffffe          BL       _uartReceiveChars
                  |L1.1276|
;;;211    
;;;212        if(uRegISR & UART_ISR_RLS_IF_Msk) {
0004fc  e59d0004          LDR      r0,[sp,#4]
000500  e3100004          TST      r0,#4
000504  0a000008          BEQ      |L1.1324|
;;;213            uRegFSR = inpw(REG_UART0_FSR);
000508  e3a0032e          MOV      r0,#0xb8000000
00050c  e5900018          LDR      r0,[r0,#0x18]
000510  e58d0000          STR      r0,[sp,#0]
;;;214            if(uRegFSR & UART_FSR_BIF_Msk)
000514  e59d0000          LDR      r0,[sp,#0]
000518  e3100040          TST      r0,#0x40
00051c  0a000002          BEQ      |L1.1324|
;;;215                _uart_cBIIState_0 = 1;
000520  e3a00001          MOV      r0,#1
000524  e59f1904          LDR      r1,|L1.3632|
000528  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_0
                  |L1.1324|
;;;216        }
;;;217    
;;;218    }
00052c  e8bd801c          POP      {r2-r4,pc}
;;;219    
                          ENDP

                  _uartEnableInterrupt PROC
;;;669    
;;;670    static void _uartEnableInterrupt(INT nNum, UINT32 uVal)
000530  e3a02000          MOV      r2,#0
;;;671    {
;;;672        UINT32 uReg = 0;
;;;673    
;;;674        uReg = inpw(REG_UART0_IER+(nNum * UARTOFFSET));
000534  e3a0332e          MOV      r3,#0xb8000000
000538  e0833400          ADD      r3,r3,r0,LSL #8
00053c  e5932004          LDR      r2,[r3,#4]
;;;675        uReg |= uVal;
000540  e1822001          ORR      r2,r2,r1
;;;676        outpw(REG_UART0_IER+(nNum * UARTOFFSET), uReg);
000544  e3a0332e          MOV      r3,#0xb8000000
000548  e0833400          ADD      r3,r3,r0,LSL #8
00054c  e5832004          STR      r2,[r3,#4]
;;;677    }
000550  e12fff1e          BX       lr
;;;678    
                          ENDP

                  _uartCheckModemStatus PROC
;;;829    */
;;;830    static void _uartCheckModemStatus(INT nNum)
000554  e92d40f8          PUSH     {r3-r7,lr}
;;;831    {
000558  e1a04000          MOV      r4,r0
;;;832        UINT32 volatile uRegMSR;
;;;833        UINT32 uOffset = nNum * UARTOFFSET;
00055c  e1a06404          LSL      r6,r4,#8
;;;834    
;;;835        UART_BUFFER_T *dev;
;;;836    
;;;837        dev = (UART_BUFFER_T *) &UART_DEV[nNum];
000560  e0840084          ADD      r0,r4,r4,LSL #1
000564  e59f18b4          LDR      r1,|L1.3616|
000568  e0815200          ADD      r5,r1,r0,LSL #4
;;;838    
;;;839        FDEBUG("\n Modem INT\n");
;;;840        uRegMSR = inpw(REG_UART0_MSR + uOffset);
00056c  e286032e          ADD      r0,r6,#0xb8000000
000570  e5900014          LDR      r0,[r0,#0x14]
000574  e58d0000          STR      r0,[sp,#0]
;;;841        if(_uart_cHWTXStopped) {
000578  e59f08b8          LDR      r0,|L1.3640|
00057c  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cHWTXStopped
000580  e3500000          CMP      r0,#0
000584  0a00000d          BEQ      |L1.1472|
;;;842            if(!(uRegMSR & 0x10)) { /* CTS high, external signal is low */
000588  e59d0000          LDR      r0,[sp,#0]
00058c  e3100010          TST      r0,#0x10
000590  1a000013          BNE      |L1.1508|
;;;843                _uart_cHWTXStopped = 0;
000594  e3a00000          MOV      r0,#0
000598  e59f1898          LDR      r1,|L1.3640|
00059c  e5c10000          STRB     r0,[r1,#0]  ; _uart_cHWTXStopped
;;;844                FDEBUG("H/W flow control ...\n");
;;;845    
;;;846                /* 2007.11.12 modify, PT23 HHWu */
;;;847                if(dev->uUartTxHead != dev->uUartTxTail) {  /* buffer is not empty */
0005a0  e5950000          LDR      r0,[r5,#0]
0005a4  e5951004          LDR      r1,[r5,#4]
0005a8  e1500001          CMP      r0,r1
0005ac  0a00000c          BEQ      |L1.1508|
;;;848                    _uartEnableInterrupt(nNum, UART_IER_THRE_IEN_Msk);  /* enable TX empty interrupt */
0005b0  e3a01002          MOV      r1,#2
0005b4  e1a00004          MOV      r0,r4
0005b8  ebfffffe          BL       _uartEnableInterrupt
0005bc  ea000008          B        |L1.1508|
                  |L1.1472|
;;;849                    FDEBUG("buf not empty, TX continued\n");
;;;850                }
;;;851            }
;;;852        } else {
;;;853            if( !(uRegMSR & 0x10) ) { /* CTS low, external signal is high */
0005c0  e59d0000          LDR      r0,[sp,#0]
0005c4  e3100010          TST      r0,#0x10
0005c8  1a000005          BNE      |L1.1508|
;;;854                _uart_cHWTXStopped = 1;
0005cc  e3a00001          MOV      r0,#1
0005d0  e59f1860          LDR      r1,|L1.3640|
0005d4  e5c10000          STRB     r0,[r1,#0]  ; _uart_cHWTXStopped
;;;855                _uartDisableInterrupt(nNum, UART_IER_THRE_IEN_Msk);  /* disable TX empty interrupt */
0005d8  e3a01002          MOV      r1,#2
0005dc  e1a00004          MOV      r0,r4
0005e0  ebfffffe          BL       _uartDisableInterrupt
                  |L1.1508|
;;;856                FDEBUG("H/W flow control, TX stopped\n");
;;;857            }
;;;858        }
;;;859    }
0005e4  e8bd80f8          POP      {r3-r7,pc}
;;;860    
                          ENDP

                  uart1ISR PROC
;;;219    
;;;220    void uart1ISR(void)
0005e8  e92d401f          PUSH     {r0-r4,lr}
;;;221    {
;;;222        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;223    
;;;224        uRegISR = inpw(REG_UART1_ISR) & 0x0f;
0005ec  e3a0032e          MOV      r0,#0xb8000000
0005f0  e590011c          LDR      r0,[r0,#0x11c]
0005f4  e200000f          AND      r0,r0,#0xf
0005f8  e58d000c          STR      r0,[sp,#0xc]
;;;225    	uRegFUN_SEL = inpw(REG_UART1_FUN_SEL);
0005fc  e3a0032e          MOV      r0,#0xb8000000
000600  e5900130          LDR      r0,[r0,#0x130]
000604  e58d0000          STR      r0,[sp,#0]
;;;226    
;;;227        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000608  e59d000c          LDR      r0,[sp,#0xc]
00060c  e3100002          TST      r0,#2
000610  0a000001          BEQ      |L1.1564|
;;;228            _uartTransmitChars(UART1);
000614  e3a00001          MOV      r0,#1
000618  ebfffffe          BL       _uartTransmitChars
                  |L1.1564|
;;;229    
;;;230    	if(uRegFUN_SEL == 0x3)
00061c  e59d0000          LDR      r0,[sp,#0]
000620  e3500003          CMP      r0,#3
000624  1a000002          BNE      |L1.1588|
;;;231    	{
;;;232    		RS485_HANDLE(UART1);
000628  e3a00001          MOV      r0,#1
00062c  ebfffffe          BL       RS485_HANDLE
000630  ea000024          B        |L1.1736|
                  |L1.1588|
;;;233    	}
;;;234    	else
;;;235    	{
;;;236        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000634  e59d000c          LDR      r0,[sp,#0xc]
000638  e3100011          TST      r0,#0x11
00063c  0a000001          BEQ      |L1.1608|
;;;237            _uartReceiveChars(UART1);
000640  e3a00001          MOV      r0,#1
000644  ebfffffe          BL       _uartReceiveChars
                  |L1.1608|
;;;238    
;;;239        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000648  e59d000c          LDR      r0,[sp,#0xc]
00064c  e3100008          TST      r0,#8
000650  0a00000f          BEQ      |L1.1684|
;;;240            if (_uart_cFlowControlMode == 0) {
000654  e59f07e0          LDR      r0,|L1.3644|
000658  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
00065c  e3500000          CMP      r0,#0
000660  1a000009          BNE      |L1.1676|
;;;241                uRegMSR = inpw(REG_UART1_MSR);
000664  e3a0032e          MOV      r0,#0xb8000000
000668  e5900114          LDR      r0,[r0,#0x114]
00066c  e58d0004          STR      r0,[sp,#4]
;;;242    
;;;243                if (uRegMSR & 0x01)
000670  e59d0004          LDR      r0,[sp,#4]
000674  e3100001          TST      r0,#1
000678  0a000005          BEQ      |L1.1684|
;;;244                    _uart_cCTSState1 = 1;
00067c  e3a00001          MOV      r0,#1
000680  e59f17b8          LDR      r1,|L1.3648|
000684  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState1
000688  ea000001          B        |L1.1684|
                  |L1.1676|
;;;245            } else
;;;246                _uartCheckModemStatus(UART1);  /* H/W flow control */
00068c  e3a00001          MOV      r0,#1
000690  ebfffffe          BL       _uartCheckModemStatus
                  |L1.1684|
;;;247        }
;;;248    
;;;249        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000694  e59d000c          LDR      r0,[sp,#0xc]
000698  e3100004          TST      r0,#4
00069c  0a000009          BEQ      |L1.1736|
;;;250            uRegFSR = inpw(REG_UART1_FSR);
0006a0  e3a0032e          MOV      r0,#0xb8000000
0006a4  e5900118          LDR      r0,[r0,#0x118]
0006a8  e58d0008          STR      r0,[sp,#8]
;;;251            U1DEBUG("U1 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;252    
;;;253            if(uRegFSR & UART_FSR_BIF_Msk)
0006ac  e59d0008          LDR      r0,[sp,#8]
0006b0  e3100040          TST      r0,#0x40
0006b4  0a000002          BEQ      |L1.1732|
;;;254                _uart_cBIIState_1 = 1;
0006b8  e3a00001          MOV      r0,#1
0006bc  e59f1780          LDR      r1,|L1.3652|
0006c0  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_1
                  |L1.1732|
;;;255    
;;;256            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
0006c4  e1a00000          MOV      r0,r0
                  |L1.1736|
;;;257                U1DEBUG("U1 OEI!\n");
;;;258        }
;;;259    	}
;;;260    }
0006c8  e8bd801f          POP      {r0-r4,pc}
;;;261    
                          ENDP

                  uart2ISR PROC
;;;262    void uart2ISR(void)
0006cc  e92d401f          PUSH     {r0-r4,lr}
;;;263    {
;;;264        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;265    
;;;266        uRegISR = inpw(REG_UART2_ISR) & 0x0f;
0006d0  e3a0032e          MOV      r0,#0xb8000000
0006d4  e590021c          LDR      r0,[r0,#0x21c]
0006d8  e200000f          AND      r0,r0,#0xf
0006dc  e58d000c          STR      r0,[sp,#0xc]
;;;267    	uRegFUN_SEL = inpw(REG_UART2_FUN_SEL);
0006e0  e3a0032e          MOV      r0,#0xb8000000
0006e4  e5900230          LDR      r0,[r0,#0x230]
0006e8  e58d0000          STR      r0,[sp,#0]
;;;268    
;;;269        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
0006ec  e59d000c          LDR      r0,[sp,#0xc]
0006f0  e3100002          TST      r0,#2
0006f4  0a000001          BEQ      |L1.1792|
;;;270            _uartTransmitChars(UART2);
0006f8  e3a00002          MOV      r0,#2
0006fc  ebfffffe          BL       _uartTransmitChars
                  |L1.1792|
;;;271    
;;;272    	if(uRegFUN_SEL == 0x3)
000700  e59d0000          LDR      r0,[sp,#0]
000704  e3500003          CMP      r0,#3
000708  1a000002          BNE      |L1.1816|
;;;273    	{
;;;274    		RS485_HANDLE(UART2);
00070c  e3a00002          MOV      r0,#2
000710  ebfffffe          BL       RS485_HANDLE
000714  ea000030          B        |L1.2012|
                  |L1.1816|
;;;275    	}
;;;276    	else
;;;277    	{
;;;278        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000718  e59d000c          LDR      r0,[sp,#0xc]
00071c  e3100011          TST      r0,#0x11
000720  0a000001          BEQ      |L1.1836|
;;;279            _uartReceiveChars(UART2);
000724  e3a00002          MOV      r0,#2
000728  ebfffffe          BL       _uartReceiveChars
                  |L1.1836|
;;;280    
;;;281        if(uRegISR & UART_ISR_RLS_IF_Msk) {
00072c  e59d000c          LDR      r0,[sp,#0xc]
000730  e3100004          TST      r0,#4
000734  0a000008          BEQ      |L1.1884|
;;;282            uRegFSR = inpw(REG_UART2_FSR);
000738  e3a0032e          MOV      r0,#0xb8000000
00073c  e5900218          LDR      r0,[r0,#0x218]
000740  e58d0008          STR      r0,[sp,#8]
;;;283            if(uRegFSR & UART_FSR_BIF_Msk)
000744  e59d0008          LDR      r0,[sp,#8]
000748  e3100040          TST      r0,#0x40
00074c  0a000002          BEQ      |L1.1884|
;;;284                _uart_cBIIState_2 = 1;
000750  e3a00001          MOV      r0,#1
000754  e59f16ec          LDR      r1,|L1.3656|
000758  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_2
                  |L1.1884|
;;;285        }
;;;286    
;;;287        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
00075c  e59d000c          LDR      r0,[sp,#0xc]
000760  e3100008          TST      r0,#8
000764  0a00000f          BEQ      |L1.1960|
;;;288            if (_uart_cFlowControlMode == 0) {
000768  e59f06cc          LDR      r0,|L1.3644|
00076c  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000770  e3500000          CMP      r0,#0
000774  1a000009          BNE      |L1.1952|
;;;289                uRegMSR = inpw(REG_UART2_MSR);
000778  e3a0032e          MOV      r0,#0xb8000000
00077c  e5900214          LDR      r0,[r0,#0x214]
000780  e58d0004          STR      r0,[sp,#4]
;;;290    
;;;291                if (uRegMSR & 0x01)
000784  e59d0004          LDR      r0,[sp,#4]
000788  e3100001          TST      r0,#1
00078c  0a000005          BEQ      |L1.1960|
;;;292                    _uart_cCTSState2 = 1;
000790  e3a00001          MOV      r0,#1
000794  e59f16b0          LDR      r1,|L1.3660|
000798  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState2
00079c  ea000001          B        |L1.1960|
                  |L1.1952|
;;;293            } else
;;;294                _uartCheckModemStatus(UART2);  /* H/W flow control */
0007a0  e3a00002          MOV      r0,#2
0007a4  ebfffffe          BL       _uartCheckModemStatus
                  |L1.1960|
;;;295        }
;;;296    
;;;297        if(uRegISR & UART_ISR_RLS_IF_Msk) {
0007a8  e59d000c          LDR      r0,[sp,#0xc]
0007ac  e3100004          TST      r0,#4
0007b0  0a000009          BEQ      |L1.2012|
;;;298            uRegFSR = inpw(REG_UART2_FSR);
0007b4  e3a0032e          MOV      r0,#0xb8000000
0007b8  e5900218          LDR      r0,[r0,#0x218]
0007bc  e58d0008          STR      r0,[sp,#8]
;;;299            U1DEBUG("U2 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;300    
;;;301            if(uRegFSR & UART_FSR_BIF_Msk)
0007c0  e59d0008          LDR      r0,[sp,#8]
0007c4  e3100040          TST      r0,#0x40
0007c8  0a000002          BEQ      |L1.2008|
;;;302                _uart_cBIIState_2 = 1;
0007cc  e3a00001          MOV      r0,#1
0007d0  e59f1670          LDR      r1,|L1.3656|
0007d4  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_2
                  |L1.2008|
;;;303    
;;;304            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
0007d8  e1a00000          MOV      r0,r0
                  |L1.2012|
;;;305                U1DEBUG("U2 OEI!\n");
;;;306        }
;;;307    	}
;;;308    }
0007dc  e8bd801f          POP      {r0-r4,pc}
;;;309    
                          ENDP

                  uart3ISR PROC
                  |L1.2016|
;;;310    void uart3ISR(void)
0007e0  e92d401f          PUSH     {r0-r4,lr}
;;;311    {
;;;312        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;313    
;;;314        uRegISR = inpw(REG_UART3_ISR) & 0x0f;
0007e4  e3a0032e          MOV      r0,#0xb8000000
0007e8  e590031c          LDR      r0,[r0,#0x31c]
0007ec  e200000f          AND      r0,r0,#0xf
0007f0  e58d000c          STR      r0,[sp,#0xc]
;;;315    	uRegFUN_SEL = inpw(REG_UART3_FUN_SEL);
0007f4  e3a0032e          MOV      r0,#0xb8000000
0007f8  e5900330          LDR      r0,[r0,#0x330]
0007fc  e58d0000          STR      r0,[sp,#0]
;;;316    
;;;317        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000800  e59d000c          LDR      r0,[sp,#0xc]
000804  e3100002          TST      r0,#2
000808  0a000001          BEQ      |L1.2068|
;;;318            _uartTransmitChars(UART3);
00080c  e3a00003          MOV      r0,#3
000810  ebfffffe          BL       _uartTransmitChars
                  |L1.2068|
;;;319    
;;;320    	if(uRegFUN_SEL == 0x3)
000814  e59d0000          LDR      r0,[sp,#0]
000818  e3500003          CMP      r0,#3
00081c  1a000002          BNE      |L1.2092|
;;;321    	{
;;;322    		RS485_HANDLE(UART3);
000820  e3a00003          MOV      r0,#3
000824  ebfffffe          BL       RS485_HANDLE
000828  ea000024          B        |L1.2240|
                  |L1.2092|
;;;323    	}
;;;324    	else
;;;325    	{
;;;326        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk))
00082c  e59d000c          LDR      r0,[sp,#0xc]
000830  e3100011          TST      r0,#0x11
000834  0a000001          BEQ      |L1.2112|
;;;327            _uartReceiveChars(UART3);
000838  e3a00003          MOV      r0,#3
00083c  ebfffffe          BL       _uartReceiveChars
                  |L1.2112|
;;;328    
;;;329        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000840  e59d000c          LDR      r0,[sp,#0xc]
000844  e3100008          TST      r0,#8
000848  0a00000f          BEQ      |L1.2188|
;;;330            if (_uart_cFlowControlMode == 0) {
00084c  e59f05e8          LDR      r0,|L1.3644|
000850  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000854  e3500000          CMP      r0,#0
000858  1a000009          BNE      |L1.2180|
;;;331                uRegMSR = inpw(REG_UART3_MSR);
00085c  e3a0032e          MOV      r0,#0xb8000000
000860  e5900314          LDR      r0,[r0,#0x314]
000864  e58d0004          STR      r0,[sp,#4]
;;;332    
;;;333                if (uRegMSR & 0x01)
000868  e59d0004          LDR      r0,[sp,#4]
00086c  e3100001          TST      r0,#1
000870  0a000005          BEQ      |L1.2188|
;;;334                    _uart_cCTSState3 = 1;
000874  e3a00001          MOV      r0,#1
000878  e59f15d0          LDR      r1,|L1.3664|
00087c  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState3
000880  ea000001          B        |L1.2188|
                  |L1.2180|
;;;335            } else
;;;336                _uartCheckModemStatus(UART3);  /* H/W flow control */
000884  e3a00003          MOV      r0,#3
000888  ebfffffe          BL       _uartCheckModemStatus
                  |L1.2188|
;;;337        }
;;;338    
;;;339        if(uRegISR & UART_ISR_RLS_IF_Msk) {
00088c  e59d000c          LDR      r0,[sp,#0xc]
000890  e3100004          TST      r0,#4
000894  0a000009          BEQ      |L1.2240|
;;;340            uRegFSR = inpw(REG_UART3_FSR);
000898  e3a0032e          MOV      r0,#0xb8000000
00089c  e5900318          LDR      r0,[r0,#0x318]
0008a0  e58d0008          STR      r0,[sp,#8]
;;;341            U1DEBUG("U3 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;342    
;;;343            if(uRegFSR & UART_FSR_BIF_Msk)
0008a4  e59d0008          LDR      r0,[sp,#8]
0008a8  e3100040          TST      r0,#0x40
0008ac  0a000002          BEQ      |L1.2236|
;;;344                _uart_cBIIState_3 = 1;
0008b0  e3a00001          MOV      r0,#1
0008b4  e59f1598          LDR      r1,|L1.3668|
0008b8  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_3
                  |L1.2236|
;;;345    
;;;346            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
0008bc  e1a00000          MOV      r0,r0
                  |L1.2240|
;;;347                U1DEBUG("U3 OEI!\n");
;;;348        }
;;;349    	}
;;;350    
;;;351    }
0008c0  e8bd801f          POP      {r0-r4,pc}
;;;352    
                          ENDP

                  uart4ISR PROC
                  |L1.2244|
;;;353    void uart4ISR(void)
0008c4  e92d401f          PUSH     {r0-r4,lr}
;;;354    {
;;;355        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;356    
;;;357        uRegISR = inpw(REG_UART4_ISR) & 0x0f;
0008c8  e59f0588          LDR      r0,|L1.3672|
0008cc  e5900000          LDR      r0,[r0,#0]
0008d0  e200000f          AND      r0,r0,#0xf
0008d4  e58d000c          STR      r0,[sp,#0xc]
;;;358    	uRegFUN_SEL = inpw(REG_UART4_FUN_SEL);
0008d8  e59f057c          LDR      r0,|L1.3676|
0008dc  e5900000          LDR      r0,[r0,#0]
0008e0  e58d0000          STR      r0,[sp,#0]
;;;359    
;;;360        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
0008e4  e59d000c          LDR      r0,[sp,#0xc]
0008e8  e3100002          TST      r0,#2
0008ec  0a000001          BEQ      |L1.2296|
;;;361            _uartTransmitChars(UART4);
0008f0  e3a00004          MOV      r0,#4
0008f4  ebfffffe          BL       _uartTransmitChars
                  |L1.2296|
;;;362    
;;;363    	if(uRegFUN_SEL == 0x3)
0008f8  e59d0000          LDR      r0,[sp,#0]
0008fc  e3500003          CMP      r0,#3
000900  1a000002          BNE      |L1.2320|
;;;364    	{
;;;365    		RS485_HANDLE(UART4);
000904  e3a00004          MOV      r0,#4
000908  ebfffffe          BL       RS485_HANDLE
00090c  ea000024          B        |L1.2468|
                  |L1.2320|
;;;366    	}
;;;367    	else
;;;368    	{
;;;369        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000910  e59d000c          LDR      r0,[sp,#0xc]
000914  e3100011          TST      r0,#0x11
000918  0a000001          BEQ      |L1.2340|
;;;370            _uartReceiveChars(UART4);
00091c  e3a00004          MOV      r0,#4
000920  ebfffffe          BL       _uartReceiveChars
                  |L1.2340|
;;;371    
;;;372        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000924  e59d000c          LDR      r0,[sp,#0xc]
000928  e3100008          TST      r0,#8
00092c  0a00000f          BEQ      |L1.2416|
;;;373            if (_uart_cFlowControlMode == 0) {
000930  e59f0504          LDR      r0,|L1.3644|
000934  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000938  e3500000          CMP      r0,#0
00093c  1a000009          BNE      |L1.2408|
;;;374                uRegMSR = inpw(REG_UART4_MSR);
000940  e59f0518          LDR      r0,|L1.3680|
000944  e5900000          LDR      r0,[r0,#0]
000948  e58d0004          STR      r0,[sp,#4]
;;;375    
;;;376                if (uRegMSR & 0x01)
00094c  e59d0004          LDR      r0,[sp,#4]
000950  e3100001          TST      r0,#1
000954  0a000005          BEQ      |L1.2416|
;;;377                    _uart_cCTSState4 = 1;
000958  e3a00001          MOV      r0,#1
00095c  e59f1500          LDR      r1,|L1.3684|
000960  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState4
000964  ea000001          B        |L1.2416|
                  |L1.2408|
;;;378            } else
;;;379                _uartCheckModemStatus(UART4);  /* H/W flow control */
000968  e3a00004          MOV      r0,#4
00096c  ebfffffe          BL       _uartCheckModemStatus
                  |L1.2416|
;;;380        }
;;;381    
;;;382        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000970  e59d000c          LDR      r0,[sp,#0xc]
000974  e3100004          TST      r0,#4
000978  0a000009          BEQ      |L1.2468|
;;;383            uRegFSR = inpw(REG_UART4_FSR);
00097c  e59f04e4          LDR      r0,|L1.3688|
000980  e5900000          LDR      r0,[r0,#0]
000984  e58d0008          STR      r0,[sp,#8]
;;;384            U1DEBUG("U4 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;385    
;;;386            if(uRegFSR & UART_FSR_BIF_Msk)
000988  e59d0008          LDR      r0,[sp,#8]
00098c  e3100040          TST      r0,#0x40
000990  0a000002          BEQ      |L1.2464|
;;;387                _uart_cBIIState_4 = 1;
000994  e3a00001          MOV      r0,#1
000998  e59f14cc          LDR      r1,|L1.3692|
00099c  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_4
                  |L1.2464|
;;;388    
;;;389            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
0009a0  e1a00000          MOV      r0,r0
                  |L1.2468|
;;;390                U1DEBUG("U4 OEI!\n");
;;;391        }
;;;392    	}
;;;393    
;;;394    }
0009a4  e8bd801f          POP      {r0-r4,pc}
;;;395    
                          ENDP

                  uart5ISR PROC
                  |L1.2472|
;;;396    void uart5ISR(void)
0009a8  e92d401f          PUSH     {r0-r4,lr}
;;;397    {
;;;398        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;399    
;;;400        uRegISR = inpw(REG_UART5_ISR) & 0x0f;
0009ac  e59f04bc          LDR      r0,|L1.3696|
0009b0  e5900000          LDR      r0,[r0,#0]
0009b4  e200000f          AND      r0,r0,#0xf
0009b8  e58d000c          STR      r0,[sp,#0xc]
;;;401    	uRegFUN_SEL = inpw(REG_UART5_FUN_SEL);
0009bc  e59f04b0          LDR      r0,|L1.3700|
0009c0  e5900000          LDR      r0,[r0,#0]
0009c4  e58d0000          STR      r0,[sp,#0]
;;;402    
;;;403        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
0009c8  e59d000c          LDR      r0,[sp,#0xc]
0009cc  e3100002          TST      r0,#2
0009d0  0a000001          BEQ      |L1.2524|
;;;404            _uartTransmitChars(UART5);
0009d4  e3a00005          MOV      r0,#5
0009d8  ebfffffe          BL       _uartTransmitChars
                  |L1.2524|
;;;405    
;;;406    	if(uRegFUN_SEL == 0x3)
0009dc  e59d0000          LDR      r0,[sp,#0]
0009e0  e3500003          CMP      r0,#3
0009e4  1a000002          BNE      |L1.2548|
;;;407    	{
;;;408    		RS485_HANDLE(UART5);
0009e8  e3a00005          MOV      r0,#5
0009ec  ebfffffe          BL       RS485_HANDLE
0009f0  ea000024          B        |L1.2696|
                  |L1.2548|
;;;409    	}
;;;410    	else
;;;411    	{
;;;412        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
0009f4  e59d000c          LDR      r0,[sp,#0xc]
0009f8  e3100011          TST      r0,#0x11
0009fc  0a000001          BEQ      |L1.2568|
;;;413            _uartReceiveChars(UART5);
000a00  e3a00005          MOV      r0,#5
000a04  ebfffffe          BL       _uartReceiveChars
                  |L1.2568|
;;;414    
;;;415        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000a08  e59d000c          LDR      r0,[sp,#0xc]
000a0c  e3100008          TST      r0,#8
000a10  0a00000f          BEQ      |L1.2644|
;;;416            if (_uart_cFlowControlMode == 0) {
000a14  e59f0420          LDR      r0,|L1.3644|
000a18  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000a1c  e3500000          CMP      r0,#0
000a20  1a000009          BNE      |L1.2636|
;;;417                uRegMSR = inpw(REG_UART5_MSR);
000a24  e59f044c          LDR      r0,|L1.3704|
000a28  e5900000          LDR      r0,[r0,#0]
000a2c  e58d0004          STR      r0,[sp,#4]
;;;418    
;;;419                if (uRegMSR & 0x01)
000a30  e59d0004          LDR      r0,[sp,#4]
000a34  e3100001          TST      r0,#1
000a38  0a000005          BEQ      |L1.2644|
;;;420                    _uart_cCTSState5 = 1;
000a3c  e3a00001          MOV      r0,#1
000a40  e59f1434          LDR      r1,|L1.3708|
000a44  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState5
000a48  ea000001          B        |L1.2644|
                  |L1.2636|
;;;421            } else
;;;422                _uartCheckModemStatus(UART5);  /* H/W flow control */
000a4c  e3a00005          MOV      r0,#5
000a50  ebfffffe          BL       _uartCheckModemStatus
                  |L1.2644|
;;;423        }
;;;424    
;;;425        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000a54  e59d000c          LDR      r0,[sp,#0xc]
000a58  e3100004          TST      r0,#4
000a5c  0a000009          BEQ      |L1.2696|
;;;426            uRegFSR = inpw(REG_UART5_FSR);
000a60  e59f0418          LDR      r0,|L1.3712|
000a64  e5900000          LDR      r0,[r0,#0]
000a68  e58d0008          STR      r0,[sp,#8]
;;;427            U1DEBUG("U5 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;428    
;;;429            if(uRegFSR & UART_FSR_BIF_Msk)
000a6c  e59d0008          LDR      r0,[sp,#8]
000a70  e3100040          TST      r0,#0x40
000a74  0a000002          BEQ      |L1.2692|
;;;430                _uart_cBIIState_5 = 1;
000a78  e3a00001          MOV      r0,#1
000a7c  e59f1400          LDR      r1,|L1.3716|
000a80  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_5
                  |L1.2692|
;;;431    
;;;432            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000a84  e1a00000          MOV      r0,r0
                  |L1.2696|
;;;433                U1DEBUG("U5 OEI!\n");
;;;434        }
;;;435    	}
;;;436    
;;;437    }
000a88  e8bd801f          POP      {r0-r4,pc}
;;;438    
                          ENDP

                  uart6ISR PROC
                  |L1.2700|
;;;439    void uart6ISR(void)
000a8c  e92d401f          PUSH     {r0-r4,lr}
;;;440    {
;;;441        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;442    
;;;443        uRegISR = inpw(REG_UART6_ISR) & 0x0f;
000a90  e59f03f0          LDR      r0,|L1.3720|
000a94  e5900000          LDR      r0,[r0,#0]
000a98  e200000f          AND      r0,r0,#0xf
000a9c  e58d000c          STR      r0,[sp,#0xc]
;;;444    	uRegFUN_SEL = inpw(REG_UART6_FUN_SEL);
000aa0  e59f03e4          LDR      r0,|L1.3724|
000aa4  e5900000          LDR      r0,[r0,#0]
000aa8  e58d0000          STR      r0,[sp,#0]
;;;445    
;;;446        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000aac  e59d000c          LDR      r0,[sp,#0xc]
000ab0  e3100002          TST      r0,#2
000ab4  0a000001          BEQ      |L1.2752|
;;;447            _uartTransmitChars(UART6);
000ab8  e3a00006          MOV      r0,#6
000abc  ebfffffe          BL       _uartTransmitChars
                  |L1.2752|
;;;448    
;;;449    	if(uRegFUN_SEL == 0x3)
000ac0  e59d0000          LDR      r0,[sp,#0]
000ac4  e3500003          CMP      r0,#3
000ac8  1a000002          BNE      |L1.2776|
;;;450    	{
;;;451    		RS485_HANDLE(UART6);
000acc  e3a00006          MOV      r0,#6
000ad0  ebfffffe          BL       RS485_HANDLE
000ad4  ea000024          B        |L1.2924|
                  |L1.2776|
;;;452    	}
;;;453    	else
;;;454    	{
;;;455        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000ad8  e59d000c          LDR      r0,[sp,#0xc]
000adc  e3100011          TST      r0,#0x11
000ae0  0a000001          BEQ      |L1.2796|
;;;456            _uartReceiveChars(UART6);
000ae4  e3a00006          MOV      r0,#6
000ae8  ebfffffe          BL       _uartReceiveChars
                  |L1.2796|
;;;457    
;;;458        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000aec  e59d000c          LDR      r0,[sp,#0xc]
000af0  e3100008          TST      r0,#8
000af4  0a00000f          BEQ      |L1.2872|
;;;459            if (_uart_cFlowControlMode == 0) {
000af8  e59f033c          LDR      r0,|L1.3644|
000afc  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000b00  e3500000          CMP      r0,#0
000b04  1a000009          BNE      |L1.2864|
;;;460                uRegMSR = inpw(REG_UART6_MSR);
000b08  e59f0380          LDR      r0,|L1.3728|
000b0c  e5900000          LDR      r0,[r0,#0]
000b10  e58d0004          STR      r0,[sp,#4]
;;;461    
;;;462                if (uRegMSR & 0x01)
000b14  e59d0004          LDR      r0,[sp,#4]
000b18  e3100001          TST      r0,#1
000b1c  0a000005          BEQ      |L1.2872|
;;;463                    _uart_cCTSState6 = 1;
000b20  e3a00001          MOV      r0,#1
000b24  e59f1368          LDR      r1,|L1.3732|
000b28  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState6
000b2c  ea000001          B        |L1.2872|
                  |L1.2864|
;;;464            } else
;;;465                _uartCheckModemStatus(UART6);  /* H/W flow control */
000b30  e3a00006          MOV      r0,#6
000b34  ebfffffe          BL       _uartCheckModemStatus
                  |L1.2872|
;;;466        }
;;;467    
;;;468        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000b38  e59d000c          LDR      r0,[sp,#0xc]
000b3c  e3100004          TST      r0,#4
000b40  0a000009          BEQ      |L1.2924|
;;;469            uRegFSR = inpw(REG_UART6_FSR);
000b44  e59f034c          LDR      r0,|L1.3736|
000b48  e5900000          LDR      r0,[r0,#0]
000b4c  e58d0008          STR      r0,[sp,#8]
;;;470            U1DEBUG("U6 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;471    
;;;472            if(uRegFSR & UART_FSR_BIF_Msk)
000b50  e59d0008          LDR      r0,[sp,#8]
000b54  e3100040          TST      r0,#0x40
000b58  0a000002          BEQ      |L1.2920|
;;;473                _uart_cBIIState_6 = 1;
000b5c  e3a00001          MOV      r0,#1
000b60  e59f1334          LDR      r1,|L1.3740|
000b64  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_6
                  |L1.2920|
;;;474    
;;;475            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000b68  e1a00000          MOV      r0,r0
                  |L1.2924|
;;;476                U1DEBUG("U6 OEI!\n");
;;;477        }
;;;478    	}
;;;479    
;;;480    }
000b6c  e8bd801f          POP      {r0-r4,pc}
;;;481    
                          ENDP

                  uart7ISR PROC
                  |L1.2928|
;;;482    void uart7ISR(void)
000b70  e92d401f          PUSH     {r0-r4,lr}
;;;483    {
;;;484        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;485    
;;;486        uRegISR = inpw(REG_UART7_ISR) & 0x0f;
000b74  e59f0324          LDR      r0,|L1.3744|
000b78  e5900000          LDR      r0,[r0,#0]
000b7c  e200000f          AND      r0,r0,#0xf
000b80  e58d000c          STR      r0,[sp,#0xc]
;;;487    	uRegFUN_SEL = inpw(REG_UART7_FUN_SEL);
000b84  e59f0318          LDR      r0,|L1.3748|
000b88  e5900000          LDR      r0,[r0,#0]
000b8c  e58d0000          STR      r0,[sp,#0]
;;;488    
;;;489        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000b90  e59d000c          LDR      r0,[sp,#0xc]
000b94  e3100002          TST      r0,#2
000b98  0a000001          BEQ      |L1.2980|
;;;490            _uartTransmitChars(UART7);
000b9c  e3a00007          MOV      r0,#7
000ba0  ebfffffe          BL       _uartTransmitChars
                  |L1.2980|
;;;491    
;;;492    	if(uRegFUN_SEL == 0x3)
000ba4  e59d0000          LDR      r0,[sp,#0]
000ba8  e3500003          CMP      r0,#3
000bac  1a000002          BNE      |L1.3004|
;;;493    	{
;;;494    		RS485_HANDLE(UART7);
000bb0  e3a00007          MOV      r0,#7
000bb4  ebfffffe          BL       RS485_HANDLE
000bb8  ea000024          B        |L1.3152|
                  |L1.3004|
;;;495    	}
;;;496    	else
;;;497    	{
;;;498        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000bbc  e59d000c          LDR      r0,[sp,#0xc]
000bc0  e3100011          TST      r0,#0x11
000bc4  0a000001          BEQ      |L1.3024|
;;;499            _uartReceiveChars(UART7);
000bc8  e3a00007          MOV      r0,#7
000bcc  ebfffffe          BL       _uartReceiveChars
                  |L1.3024|
;;;500    
;;;501        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000bd0  e59d000c          LDR      r0,[sp,#0xc]
000bd4  e3100008          TST      r0,#8
000bd8  0a00000f          BEQ      |L1.3100|
;;;502            if (_uart_cFlowControlMode == 0) {
000bdc  e59f0258          LDR      r0,|L1.3644|
000be0  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000be4  e3500000          CMP      r0,#0
000be8  1a000009          BNE      |L1.3092|
;;;503                uRegMSR = inpw(REG_UART7_MSR);
000bec  e59f02b4          LDR      r0,|L1.3752|
000bf0  e5900000          LDR      r0,[r0,#0]
000bf4  e58d0004          STR      r0,[sp,#4]
;;;504    
;;;505                if (uRegMSR & 0x01)
000bf8  e59d0004          LDR      r0,[sp,#4]
000bfc  e3100001          TST      r0,#1
000c00  0a000005          BEQ      |L1.3100|
;;;506                    _uart_cCTSState7 = 1;
000c04  e3a00001          MOV      r0,#1
000c08  e59f129c          LDR      r1,|L1.3756|
000c0c  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState7
000c10  ea000001          B        |L1.3100|
                  |L1.3092|
;;;507            } else
;;;508                _uartCheckModemStatus(UART7);  /* H/W flow control */
000c14  e3a00007          MOV      r0,#7
000c18  ebfffffe          BL       _uartCheckModemStatus
                  |L1.3100|
;;;509        }
;;;510    
;;;511        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000c1c  e59d000c          LDR      r0,[sp,#0xc]
000c20  e3100004          TST      r0,#4
000c24  0a000009          BEQ      |L1.3152|
;;;512            uRegFSR = inpw(REG_UART7_FSR);
000c28  e59f0280          LDR      r0,|L1.3760|
000c2c  e5900000          LDR      r0,[r0,#0]
000c30  e58d0008          STR      r0,[sp,#8]
;;;513            U1DEBUG("U7 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;514    
;;;515            if(uRegFSR & UART_FSR_BIF_Msk)
000c34  e59d0008          LDR      r0,[sp,#8]
000c38  e3100040          TST      r0,#0x40
000c3c  0a000002          BEQ      |L1.3148|
;;;516                _uart_cBIIState_7 = 1;
000c40  e3a00001          MOV      r0,#1
000c44  e59f1268          LDR      r1,|L1.3764|
000c48  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_7
                  |L1.3148|
;;;517    
;;;518            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000c4c  e1a00000          MOV      r0,r0
                  |L1.3152|
;;;519                U1DEBUG("U7 OEI!\n");
;;;520        }
;;;521    	}
;;;522    
;;;523    }
000c50  e8bd801f          POP      {r0-r4,pc}
;;;524    
                          ENDP

                  uart8ISR PROC
;;;525    void uart8ISR(void)
000c54  e92d401f          PUSH     {r0-r4,lr}
;;;526    {
;;;527        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;528    
;;;529        uRegISR = inpw(REG_UART8_ISR) & 0x0f;
000c58  e59f0258          LDR      r0,|L1.3768|
000c5c  e5900000          LDR      r0,[r0,#0]
000c60  e200000f          AND      r0,r0,#0xf
000c64  e58d000c          STR      r0,[sp,#0xc]
;;;530    	uRegFUN_SEL = inpw(REG_UART8_FUN_SEL);
000c68  e59f024c          LDR      r0,|L1.3772|
000c6c  e5900000          LDR      r0,[r0,#0]
000c70  e58d0000          STR      r0,[sp,#0]
;;;531    
;;;532        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000c74  e59d000c          LDR      r0,[sp,#0xc]
000c78  e3100002          TST      r0,#2
000c7c  0a000001          BEQ      |L1.3208|
;;;533            _uartTransmitChars(UART8);
000c80  e3a00008          MOV      r0,#8
000c84  ebfffffe          BL       _uartTransmitChars
                  |L1.3208|
;;;534    
;;;535    	if(uRegFUN_SEL == 0x3)
000c88  e59d0000          LDR      r0,[sp,#0]
000c8c  e3500003          CMP      r0,#3
000c90  1a000002          BNE      |L1.3232|
;;;536    	{
;;;537    		RS485_HANDLE(UART8);
000c94  e3a00008          MOV      r0,#8
000c98  ebfffffe          BL       RS485_HANDLE
000c9c  ea000024          B        |L1.3380|
                  |L1.3232|
;;;538    	}
;;;539    	else
;;;540    	{
;;;541        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000ca0  e59d000c          LDR      r0,[sp,#0xc]
000ca4  e3100011          TST      r0,#0x11
000ca8  0a000001          BEQ      |L1.3252|
;;;542            _uartReceiveChars(UART8);
000cac  e3a00008          MOV      r0,#8
000cb0  ebfffffe          BL       _uartReceiveChars
                  |L1.3252|
;;;543    
;;;544        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000cb4  e59d000c          LDR      r0,[sp,#0xc]
000cb8  e3100008          TST      r0,#8
000cbc  0a00000f          BEQ      |L1.3328|
;;;545            if (_uart_cFlowControlMode == 0) {
000cc0  e59f0174          LDR      r0,|L1.3644|
000cc4  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000cc8  e3500000          CMP      r0,#0
000ccc  1a000009          BNE      |L1.3320|
;;;546                uRegMSR = inpw(REG_UART8_MSR);
000cd0  e59f01e8          LDR      r0,|L1.3776|
000cd4  e5900000          LDR      r0,[r0,#0]
000cd8  e58d0004          STR      r0,[sp,#4]
;;;547    
;;;548                if (uRegMSR & 0x01)
000cdc  e59d0004          LDR      r0,[sp,#4]
000ce0  e3100001          TST      r0,#1
000ce4  0a000005          BEQ      |L1.3328|
;;;549                    _uart_cCTSState8 = 1;
000ce8  e3a00001          MOV      r0,#1
000cec  e59f11d0          LDR      r1,|L1.3780|
000cf0  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState8
000cf4  ea000001          B        |L1.3328|
                  |L1.3320|
;;;550            } else
;;;551                _uartCheckModemStatus(UART8);  /* H/W flow control */
000cf8  e3a00008          MOV      r0,#8
000cfc  ebfffffe          BL       _uartCheckModemStatus
                  |L1.3328|
;;;552        }
;;;553    
;;;554        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000d00  e59d000c          LDR      r0,[sp,#0xc]
000d04  e3100004          TST      r0,#4
000d08  0a000009          BEQ      |L1.3380|
;;;555            uRegFSR = inpw(REG_UART8_FSR);
000d0c  e59f01b4          LDR      r0,|L1.3784|
000d10  e5900000          LDR      r0,[r0,#0]
000d14  e58d0008          STR      r0,[sp,#8]
;;;556            U1DEBUG("U8 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;557    
;;;558            if(uRegFSR & UART_FSR_BIF_Msk)
000d18  e59d0008          LDR      r0,[sp,#8]
000d1c  e3100040          TST      r0,#0x40
000d20  0a000002          BEQ      |L1.3376|
;;;559                _uart_cBIIState_8 = 1;
000d24  e3a00001          MOV      r0,#1
000d28  e59f119c          LDR      r1,|L1.3788|
000d2c  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_8
                  |L1.3376|
;;;560    
;;;561            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000d30  e1a00000          MOV      r0,r0
                  |L1.3380|
;;;562                U1DEBUG("U8 OEI!\n");
;;;563        }
;;;564    	}
;;;565    
;;;566    }
000d34  e8bd801f          POP      {r0-r4,pc}
;;;567    
                          ENDP

                  uart9ISR PROC
;;;568    void uart9ISR(void)
000d38  e92d401f          PUSH     {r0-r4,lr}
;;;569    {
;;;570        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;571    
;;;572        uRegISR = inpw(REG_UART9_ISR) & 0x0f;
000d3c  e59f018c          LDR      r0,|L1.3792|
000d40  e5900000          LDR      r0,[r0,#0]
000d44  e200000f          AND      r0,r0,#0xf
000d48  e58d000c          STR      r0,[sp,#0xc]
;;;573    	uRegFUN_SEL = inpw(REG_UART9_FUN_SEL);
000d4c  e59f0180          LDR      r0,|L1.3796|
000d50  e5900000          LDR      r0,[r0,#0]
000d54  e58d0000          STR      r0,[sp,#0]
;;;574    
;;;575        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000d58  e59d000c          LDR      r0,[sp,#0xc]
000d5c  e3100002          TST      r0,#2
000d60  0a000001          BEQ      |L1.3436|
;;;576            _uartTransmitChars(UART9);
000d64  e3a00009          MOV      r0,#9
000d68  ebfffffe          BL       _uartTransmitChars
                  |L1.3436|
;;;577    
;;;578    	if(uRegFUN_SEL == 0x3)
000d6c  e59d0000          LDR      r0,[sp,#0]
000d70  e3500003          CMP      r0,#3
000d74  1a000002          BNE      |L1.3460|
;;;579    	{
;;;580    		RS485_HANDLE(UART9);
000d78  e3a00009          MOV      r0,#9
000d7c  ebfffffe          BL       RS485_HANDLE
000d80  ea000024          B        |L1.3608|
                  |L1.3460|
;;;581    	}
;;;582    	else
;;;583    	{
;;;584        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk))  /* Received Data Available interrupt */
000d84  e59d000c          LDR      r0,[sp,#0xc]
000d88  e3100011          TST      r0,#0x11
000d8c  0a000001          BEQ      |L1.3480|
;;;585            _uartReceiveChars(UART9);
000d90  e3a00009          MOV      r0,#9
000d94  ebfffffe          BL       _uartReceiveChars
                  |L1.3480|
;;;586    
;;;587        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000d98  e59d000c          LDR      r0,[sp,#0xc]
000d9c  e3100008          TST      r0,#8
000da0  0a00000f          BEQ      |L1.3556|
;;;588            if (_uart_cFlowControlMode == 0) {
000da4  e59f0090          LDR      r0,|L1.3644|
000da8  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000dac  e3500000          CMP      r0,#0
000db0  1a000009          BNE      |L1.3548|
;;;589                uRegMSR = inpw(REG_UART9_MSR);
000db4  e59f011c          LDR      r0,|L1.3800|
000db8  e5900000          LDR      r0,[r0,#0]
000dbc  e58d0004          STR      r0,[sp,#4]
;;;590    
;;;591                if (uRegMSR & 0x01)
000dc0  e59d0004          LDR      r0,[sp,#4]
000dc4  e3100001          TST      r0,#1
000dc8  0a000005          BEQ      |L1.3556|
;;;592                    _uart_cCTSState9 = 1;
000dcc  e3a00001          MOV      r0,#1
000dd0  e59f1104          LDR      r1,|L1.3804|
000dd4  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState9
000dd8  ea000001          B        |L1.3556|
                  |L1.3548|
;;;593            } else
;;;594                _uartCheckModemStatus(UART9);  /* H/W flow control */
000ddc  e3a00009          MOV      r0,#9
000de0  ebfffffe          BL       _uartCheckModemStatus
                  |L1.3556|
;;;595        }
;;;596    
;;;597        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000de4  e59d000c          LDR      r0,[sp,#0xc]
000de8  e3100004          TST      r0,#4
000dec  0a000009          BEQ      |L1.3608|
;;;598            uRegFSR = inpw(REG_UART9_FSR);
000df0  e59f00e8          LDR      r0,|L1.3808|
000df4  e5900000          LDR      r0,[r0,#0]
000df8  e58d0008          STR      r0,[sp,#8]
;;;599            U1DEBUG("U9 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;600    
;;;601            if(uRegFSR & UART_FSR_BIF_Msk)
000dfc  e59d0008          LDR      r0,[sp,#8]
000e00  e3100040          TST      r0,#0x40
000e04  0a000002          BEQ      |L1.3604|
;;;602                _uart_cBIIState_9 = 1;
000e08  e3a00001          MOV      r0,#1
000e0c  e59f10d0          LDR      r1,|L1.3812|
000e10  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_9
                  |L1.3604|
;;;603    
;;;604            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000e14  e1a00000          MOV      r0,r0
                  |L1.3608|
;;;605                U1DEBUG("U9 OEI!\n");
;;;606        }
;;;607    	}
;;;608    
;;;609    }
000e18  e8bd801f          POP      {r0-r4,pc}
                  |L1.3612|
                          DCD      UARTRXBUFSIZE
                  |L1.3616|
                          DCD      UART_DEV
                  |L1.3620|
                          DCD      _uart_cHWRXStopped
                  |L1.3624|
                          DCD      0x0000030f
                  |L1.3628|
                          DCD      xuartSemaphore
                  |L1.3632|
                          DCD      _uart_cBIIState_0
                  |L1.3636|
                          DCD      UARTTXBUFSIZE
                  |L1.3640|
                          DCD      _uart_cHWTXStopped
                  |L1.3644|
                          DCD      _uart_cFlowControlMode
                  |L1.3648|
                          DCD      _uart_cCTSState1
                  |L1.3652|
                          DCD      _uart_cBIIState_1
                  |L1.3656|
                          DCD      _uart_cBIIState_2
                  |L1.3660|
                          DCD      _uart_cCTSState2
                  |L1.3664|
                          DCD      _uart_cCTSState3
                  |L1.3668|
                          DCD      _uart_cBIIState_3
                  |L1.3672|
                          DCD      0xb800041c
                  |L1.3676|
                          DCD      0xb8000430
                  |L1.3680|
                          DCD      0xb8000414
                  |L1.3684|
                          DCD      _uart_cCTSState4
                  |L1.3688|
                          DCD      0xb8000418
                  |L1.3692|
                          DCD      _uart_cBIIState_4
                  |L1.3696|
                          DCD      0xb800051c
                  |L1.3700|
                          DCD      0xb8000530
                  |L1.3704|
                          DCD      0xb8000514
                  |L1.3708|
                          DCD      _uart_cCTSState5
                  |L1.3712|
                          DCD      0xb8000518
                  |L1.3716|
                          DCD      _uart_cBIIState_5
                  |L1.3720|
                          DCD      0xb800061c
                  |L1.3724|
                          DCD      0xb8000630
                  |L1.3728|
                          DCD      0xb8000614
                  |L1.3732|
                          DCD      _uart_cCTSState6
                  |L1.3736|
                          DCD      0xb8000618
                  |L1.3740|
                          DCD      _uart_cBIIState_6
                  |L1.3744|
                          DCD      0xb800071c
                  |L1.3748|
                          DCD      0xb8000730
                  |L1.3752|
                          DCD      0xb8000714
                  |L1.3756|
                          DCD      _uart_cCTSState7
                  |L1.3760|
                          DCD      0xb8000718
                  |L1.3764|
                          DCD      _uart_cBIIState_7
                  |L1.3768|
                          DCD      0xb800081c
                  |L1.3772|
                          DCD      0xb8000830
                  |L1.3776|
                          DCD      0xb8000814
                  |L1.3780|
                          DCD      _uart_cCTSState8
                  |L1.3784|
                          DCD      0xb8000818
                  |L1.3788|
                          DCD      _uart_cBIIState_8
                  |L1.3792|
                          DCD      0xb800091c
                  |L1.3796|
                          DCD      0xb8000930
                  |L1.3800|
                          DCD      0xb8000914
                  |L1.3804|
                          DCD      _uart_cCTSState9
                  |L1.3808|
                          DCD      0xb8000918
                  |L1.3812|
                          DCD      _uart_cBIIState_9
                          ENDP

                  uart10ISR PROC
                  |L1.3816|
;;;610    
;;;611    void uart10ISR(void)
000ee8  e92d401f          PUSH     {r0-r4,lr}
;;;612    {
;;;613        UINT32 volatile uRegISR, uRegFSR, uRegMSR, uRegFUN_SEL;
;;;614    
;;;615        uRegISR = inpw(REG_UARTA_ISR) & 0x0f;
000eec  e59f0dec          LDR      r0,|L1.7392|
000ef0  e5900000          LDR      r0,[r0,#0]
000ef4  e200000f          AND      r0,r0,#0xf
000ef8  e58d000c          STR      r0,[sp,#0xc]
;;;616    	uRegFUN_SEL = inpw(REG_UARTA_FUN_SEL);
000efc  e59f0de0          LDR      r0,|L1.7396|
000f00  e5900000          LDR      r0,[r0,#0]
000f04  e58d0000          STR      r0,[sp,#0]
;;;617    
;;;618        if(uRegISR & UART_ISR_THRE_IF_Msk)  /* TX empty interrupt, check LSR 4 kinds of error further */
000f08  e59d000c          LDR      r0,[sp,#0xc]
000f0c  e3100002          TST      r0,#2
000f10  0a000001          BEQ      |L1.3868|
;;;619            _uartTransmitChars(UARTA);
000f14  e3a0000a          MOV      r0,#0xa
000f18  ebfffffe          BL       _uartTransmitChars
                  |L1.3868|
;;;620    
;;;621    	if(uRegFUN_SEL == 0x3)
000f1c  e59d0000          LDR      r0,[sp,#0]
000f20  e3500003          CMP      r0,#3
000f24  1a000002          BNE      |L1.3892|
;;;622    	{
;;;623    		RS485_HANDLE(UARTA);
000f28  e3a0000a          MOV      r0,#0xa
000f2c  ebfffffe          BL       RS485_HANDLE
000f30  ea000024          B        |L1.4040|
                  |L1.3892|
;;;624    	}
;;;625    	else
;;;626    	{
;;;627        if( uRegISR & (UART_ISR_RDA_IF_Msk | UART_ISR_TOUT_IF_Msk)) /* Received Data Available interrupt */
000f34  e59d000c          LDR      r0,[sp,#0xc]
000f38  e3100011          TST      r0,#0x11
000f3c  0a000001          BEQ      |L1.3912|
;;;628            _uartReceiveChars(UARTA);
000f40  e3a0000a          MOV      r0,#0xa
000f44  ebfffffe          BL       _uartReceiveChars
                  |L1.3912|
;;;629    
;;;630        if(uRegISR & UART_ISR_MODEM_IF_Msk) {
000f48  e59d000c          LDR      r0,[sp,#0xc]
000f4c  e3100008          TST      r0,#8
000f50  0a00000f          BEQ      |L1.3988|
;;;631            if (_uart_cFlowControlMode == 0) {
000f54  e51f0120          LDR      r0,|L1.3644|
000f58  e5d00000          LDRB     r0,[r0,#0]  ; _uart_cFlowControlMode
000f5c  e3500000          CMP      r0,#0
000f60  1a000009          BNE      |L1.3980|
;;;632                uRegMSR = inpw(REG_UARTA_MSR);
000f64  e59f0d7c          LDR      r0,|L1.7400|
000f68  e5900000          LDR      r0,[r0,#0]
000f6c  e58d0004          STR      r0,[sp,#4]
;;;633    
;;;634                if (uRegMSR & 0x01)
000f70  e59d0004          LDR      r0,[sp,#4]
000f74  e3100001          TST      r0,#1
000f78  0a000005          BEQ      |L1.3988|
;;;635                    _uart_cCTSState10 = 1;
000f7c  e3a00001          MOV      r0,#1
000f80  e59f1d64          LDR      r1,|L1.7404|
000f84  e5c10000          STRB     r0,[r1,#0]  ; _uart_cCTSState10
000f88  ea000001          B        |L1.3988|
                  |L1.3980|
;;;636            } else
;;;637                _uartCheckModemStatus(UARTA);  /* H/W flow control */
000f8c  e3a0000a          MOV      r0,#0xa
000f90  ebfffffe          BL       _uartCheckModemStatus
                  |L1.3988|
;;;638        }
;;;639    
;;;640        if(uRegISR & UART_ISR_RLS_IF_Msk) {
000f94  e59d000c          LDR      r0,[sp,#0xc]
000f98  e3100004          TST      r0,#4
000f9c  0a000009          BEQ      |L1.4040|
;;;641            uRegFSR = inpw(REG_UARTA_FSR);
000fa0  e59f0d48          LDR      r0,|L1.7408|
000fa4  e5900000          LDR      r0,[r0,#0]
000fa8  e58d0008          STR      r0,[sp,#8]
;;;642            U1DEBUG("U10 Irpt_RLS [0x%x]!\n", uRegFSR);
;;;643    
;;;644            if(uRegFSR & UART_FSR_BIF_Msk)
000fac  e59d0008          LDR      r0,[sp,#8]
000fb0  e3100040          TST      r0,#0x40
000fb4  0a000002          BEQ      |L1.4036|
;;;645                _uart_cBIIState_10 = 1;
000fb8  e3a00001          MOV      r0,#1
000fbc  e59f1d30          LDR      r1,|L1.7412|
000fc0  e5c10000          STRB     r0,[r1,#0]  ; _uart_cBIIState_10
                  |L1.4036|
;;;646    
;;;647            if (uRegFSR & UART_FSR_RX_OVER_IF_Msk)
000fc4  e1a00000          MOV      r0,r0
                  |L1.4040|
;;;648                U1DEBUG("U10 OEI!\n");
;;;649        }
;;;650    	}
;;;651    
;;;652    }
000fc8  e8bd801f          POP      {r0-r4,pc}
;;;653    
                          ENDP

                  _uartSetBaudRate PROC
;;;860    
;;;861    static INT _uartSetBaudRate(INT nNum, UART_T *val)
000fcc  e92d47f0          PUSH     {r4-r10,lr}
;;;862    {
000fd0  e1a07000          MOV      r7,r0
000fd4  e1a06001          MOV      r6,r1
;;;863        UINT32 u32Reg;
;;;864        UINT32 uOffset = nNum * UARTOFFSET;
000fd8  e1a0a407          LSL      r10,r7,#8
;;;865        UINT32 u32Baud_Div;
;;;866        UINT32 u32Clk = val->uFreq;
000fdc  e5969000          LDR      r9,[r6,#0]
;;;867        UINT32 u32baudrate = val->uBaudRate;
000fe0  e5965004          LDR      r5,[r6,#4]
;;;868    
;;;869        //if (val->uFreq > 200000000)  /* Max frequency 200MHz */
;;;870        //  return -1;
;;;871    
;;;872        u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
000fe4  e08900a5          ADD      r0,r9,r5,LSR #1
000fe8  e1a01005          MOV      r1,r5
000fec  ebfffffe          BL       __aeabi_uidivmod
000ff0  e2408002          SUB      r8,r0,#2
;;;873    
;;;874        if(u32Baud_Div > 0xFFFF)
000ff4  e3580801          CMP      r8,#0x10000
000ff8  3a000005          BCC      |L1.4116|
;;;875            u32Reg = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
000ffc  e0890185          ADD      r0,r9,r5,LSL #3
001000  e1a01005          MOV      r1,r5
001004  ebfffffe          BL       __aeabi_uidivmod
001008  e3a01002          MOV      r1,#2
00100c  e0614220          RSB      r4,r1,r0,LSR #4
001010  ea000000          B        |L1.4120|
                  |L1.4116|
;;;876        else
;;;877            u32Reg = (UART_BAUD_MODE2 | u32Baud_Div);
001014  e3884203          ORR      r4,r8,#0x30000000
                  |L1.4120|
;;;878    
;;;879        outpw(REG_UART0_BAUD + uOffset, u32Reg);
001018  e28a032e          ADD      r0,r10,#0xb8000000
00101c  e5804024          STR      r4,[r0,#0x24]
;;;880    
;;;881        return 0;
001020  e3a00000          MOV      r0,#0
;;;882    }
001024  e8bd87f0          POP      {r4-r10,pc}
;;;883    
                          ENDP

                  _uartInstallISR PROC
;;;884    static void _uartInstallISR(UINT8 ucNum)
001028  e92d4070          PUSH     {r4-r6,lr}
;;;885    {
00102c  e1a04000          MOV      r4,r0
;;;886        UART_BUFFER_T *dev;
;;;887    
;;;888        IRQn_Type IRQ;
;;;889    
;;;890        dev = (UART_BUFFER_T *) &UART_DEV[ucNum];
001030  e0840084          ADD      r0,r4,r4,LSL #1
001034  e51f121c          LDR      r1,|L1.3616|
001038  e0815200          ADD      r5,r1,r0,LSL #4
;;;891    
;;;892        if(ucNum == UART0) {
00103c  e3540000          CMP      r4,#0
001040  1a000006          BNE      |L1.4192|
;;;893            IRQ= UART0_IRQn;
001044  e3a06024          MOV      r6,#0x24
;;;894            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart0ISR);
001048  e24f2eb9          ADR      r2,|L1.1216|
00104c  e1a01006          MOV      r1,r6
001050  e3a00041          MOV      r0,#0x41
001054  ebfffffe          BL       sysInstallISR
001058  e5850018          STR      r0,[r5,#0x18]
00105c  ea000064          B        |L1.4596|
                  |L1.4192|
;;;895        } else if(ucNum == UART1) {
001060  e3540001          CMP      r4,#1
001064  1a000006          BNE      |L1.4228|
;;;896            IRQ= UART1_IRQn;
001068  e3a06025          MOV      r6,#0x25
;;;897            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart1ISR);
00106c  e59f2c84          LDR      r2,|L1.7416|
001070  e1a01006          MOV      r1,r6
001074  e3a00041          MOV      r0,#0x41
001078  ebfffffe          BL       sysInstallISR
00107c  e5850018          STR      r0,[r5,#0x18]
001080  ea00005b          B        |L1.4596|
                  |L1.4228|
;;;898        } else if(ucNum == UART2) {
001084  e3540002          CMP      r4,#2
001088  1a000006          BNE      |L1.4264|
;;;899            IRQ= UART2_IRQn;
00108c  e3a06026          MOV      r6,#0x26
;;;900            #if(1) //octopus reader
;;;901            dev->pvUartVector = sysInstallISR((FIQ_LEVEL_0 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart2ISR);
001090  e59f2c64          LDR      r2,|L1.7420|
001094  e1a01006          MOV      r1,r6
001098  e3a00040          MOV      r0,#0x40
00109c  ebfffffe          BL       sysInstallISR
0010a0  e5850018          STR      r0,[r5,#0x18]
0010a4  ea000052          B        |L1.4596|
                  |L1.4264|
;;;902            #else
;;;903            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart2ISR);
;;;904            #endif
;;;905        } else if(ucNum == UART3) {
0010a8  e3540003          CMP      r4,#3
0010ac  1a00000b          BNE      |L1.4320|
;;;906            IRQ= UART3_IRQn;
0010b0  e3a0602b          MOV      r6,#0x2b
;;;907            //#if(1) //radar
;;;908            dev->pvUartVector = sysInstallISR((FIQ_LEVEL_0 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart3ISR);
0010b4  e59f2c44          LDR      r2,|L1.7424|
0010b8  e1a01006          MOV      r1,r6
0010bc  e3a00040          MOV      r0,#0x40
0010c0  ebfffffe          BL       sysInstallISR
0010c4  e5850018          STR      r0,[r5,#0x18]
;;;909            //#else
;;;910            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart3ISR);
0010c8  e24f2e8f          ADR      r2,|L1.2016|
0010cc  e1a01006          MOV      r1,r6
0010d0  e3a00041          MOV      r0,#0x41
0010d4  ebfffffe          BL       sysInstallISR
0010d8  e5850018          STR      r0,[r5,#0x18]
0010dc  ea000044          B        |L1.4596|
                  |L1.4320|
;;;911           // #endif
;;;912        } else if(ucNum == UART4) {
0010e0  e3540004          CMP      r4,#4
0010e4  1a000006          BNE      |L1.4356|
;;;913            IRQ= UART4_IRQn;
0010e8  e3a06027          MOV      r6,#0x27
;;;914            #if(1)
;;;915            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_2 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart4ISR);
0010ec  e24f2e83          ADR      r2,|L1.2244|
0010f0  e1a01006          MOV      r1,r6
0010f4  e3a00042          MOV      r0,#0x42
0010f8  ebfffffe          BL       sysInstallISR
0010fc  e5850018          STR      r0,[r5,#0x18]
001100  ea00003b          B        |L1.4596|
                  |L1.4356|
;;;916            #else
;;;917            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart4ISR);
;;;918            #endif
;;;919        } else if(ucNum == UART5) {
001104  e3540005          CMP      r4,#5
001108  1a000006          BNE      |L1.4392|
;;;920            IRQ= UART5_IRQn;
00110c  e3a0602c          MOV      r6,#0x2c
;;;921            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart5ISR);
001110  e24f2e77          ADR      r2,|L1.2472|
001114  e1a01006          MOV      r1,r6
001118  e3a00041          MOV      r0,#0x41
00111c  ebfffffe          BL       sysInstallISR
001120  e5850018          STR      r0,[r5,#0x18]
001124  ea000032          B        |L1.4596|
                  |L1.4392|
;;;922        } else if(ucNum == UART6) {
001128  e3540006          CMP      r4,#6
00112c  1a000006          BNE      |L1.4428|
;;;923            IRQ= UART6_IRQn;
001130  e3a06028          MOV      r6,#0x28
;;;924            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart6ISR);
001134  e24f2e6b          ADR      r2,|L1.2700|
001138  e1a01006          MOV      r1,r6
00113c  e3a00041          MOV      r0,#0x41
001140  ebfffffe          BL       sysInstallISR
001144  e5850018          STR      r0,[r5,#0x18]
001148  ea000029          B        |L1.4596|
                  |L1.4428|
;;;925        } else if(ucNum == UART7) {
00114c  e3540007          CMP      r4,#7
001150  1a00000b          BNE      |L1.4484|
;;;926            IRQ= UART7_IRQn;
001154  e3a0602d          MOV      r6,#0x2d
;;;927            //#if(1) // radar
;;;928            dev->pvUartVector = sysInstallISR((FIQ_LEVEL_0 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart7ISR);
001158  e24f2e5f          ADR      r2,|L1.2928|
00115c  e1a01006          MOV      r1,r6
001160  e3a00040          MOV      r0,#0x40
001164  ebfffffe          BL       sysInstallISR
001168  e5850018          STR      r0,[r5,#0x18]
;;;929            //#else
;;;930            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart7ISR);
00116c  e59f2b90          LDR      r2,|L1.7428|
001170  e1a01006          MOV      r1,r6
001174  e3a00041          MOV      r0,#0x41
001178  ebfffffe          BL       sysInstallISR
00117c  e5850018          STR      r0,[r5,#0x18]
001180  ea00001b          B        |L1.4596|
                  |L1.4484|
;;;931            //#endif
;;;932        } else if(ucNum == UART8) {
001184  e3540008          CMP      r4,#8
001188  1a000006          BNE      |L1.4520|
;;;933            IRQ= UART8_IRQn;
00118c  e3a06029          MOV      r6,#0x29
;;;934            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart8ISR);
001190  e59f2b70          LDR      r2,|L1.7432|
001194  e1a01006          MOV      r1,r6
001198  e3a00041          MOV      r0,#0x41
00119c  ebfffffe          BL       sysInstallISR
0011a0  e5850018          STR      r0,[r5,#0x18]
0011a4  ea000012          B        |L1.4596|
                  |L1.4520|
;;;935        } else if(ucNum == UART9) {
0011a8  e3540009          CMP      r4,#9
0011ac  1a000006          BNE      |L1.4556|
;;;936            IRQ= UART9_IRQn;
0011b0  e3a0602e          MOV      r6,#0x2e
;;;937            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart9ISR);
0011b4  e59f2b50          LDR      r2,|L1.7436|
0011b8  e1a01006          MOV      r1,r6
0011bc  e3a00041          MOV      r0,#0x41
0011c0  ebfffffe          BL       sysInstallISR
0011c4  e5850018          STR      r0,[r5,#0x18]
0011c8  ea000009          B        |L1.4596|
                  |L1.4556|
;;;938        } else if(ucNum == UARTA) {
0011cc  e354000a          CMP      r4,#0xa
0011d0  1a000006          BNE      |L1.4592|
;;;939            IRQ= UART10_IRQn;
0011d4  e3a0602a          MOV      r6,#0x2a
;;;940            dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)uart10ISR);
0011d8  e24f2fbe          ADR      r2,|L1.3816|
0011dc  e1a01006          MOV      r1,r6
0011e0  e3a00041          MOV      r0,#0x41
0011e4  ebfffffe          BL       sysInstallISR
0011e8  e5850018          STR      r0,[r5,#0x18]
0011ec  ea000000          B        |L1.4596|
                  |L1.4592|
;;;941        } else {
;;;942            return;
;;;943        }
;;;944    
;;;945        //dev->pvUartVector = sysInstallISR((IRQ_LEVEL_1 | HIGH_LEVEL_SENSITIVE), IRQ, (PVOID)pvNewISR);
;;;946        sysSetLocalInterrupt(ENABLE_IRQ);                            /* enable CPSR I bit */
;;;947        sysEnableInterrupt(IRQ);
;;;948        //DrvUART_EnableInt(TEST_PORT,(DRVUART_RLSINT|DRVUART_THREINT|DRVUART_RDAINT));
;;;949    
;;;950    
;;;951    }
0011f0  e8bd8070          POP      {r4-r6,pc}
                  |L1.4596|
0011f4  e3a0007f          MOV      r0,#0x7f              ;946
0011f8  ebfffffe          BL       sysSetLocalInterrupt
0011fc  e1a00006          MOV      r0,r6                 ;947
001200  ebfffffe          BL       sysEnableInterrupt
001204  e1a00000          MOV      r0,r0
001208  eafffff8          B        |L1.4592|
;;;952    
                          ENDP

                  _uartBUFSpaceAlloc PROC
;;;953    
;;;954    static BOOL _uartBUFSpaceAlloc(INT nNum)
00120c  e92d4070          PUSH     {r4-r6,lr}
;;;955    {
001210  e1a05000          MOV      r5,r0
;;;956        UART_BUFFER_T *dev;
;;;957    
;;;958        dev = (UART_BUFFER_T *) &UART_DEV[nNum];
001214  e0850085          ADD      r0,r5,r5,LSL #1
001218  e51f1400          LDR      r1,|L1.3616|
00121c  e0814200          ADD      r4,r1,r0,LSL #4
;;;959    
;;;960        /* Memory allocate Tx buffer */
;;;961        if(dev->pucUartTxBuf == NULL)
001220  e5940010          LDR      r0,[r4,#0x10]
001224  e3500000          CMP      r0,#0
001228  1a000003          BNE      |L1.4668|
;;;962        {
;;;963            dev->pucUartTxBuf = (PUINT8) malloc(UARTTXBUFSIZE[nNum] * sizeof(UINT8));
00122c  e51f1400          LDR      r1,|L1.3636|
001230  e7910105          LDR      r0,[r1,r5,LSL #2]
001234  ebfffffe          BL       pvPortMalloc
001238  e5840010          STR      r0,[r4,#0x10]
                  |L1.4668|
;;;964        }
;;;965        
;;;966        if(dev->pucUartTxBuf == NULL)
00123c  e5940010          LDR      r0,[r4,#0x10]
001240  e3500000          CMP      r0,#0
001244  1a000001          BNE      |L1.4688|
;;;967            return FALSE;
001248  e3a00000          MOV      r0,#0
                  |L1.4684|
;;;968    
;;;969        /* Memory allocate Rx buffer */
;;;970        if(dev->pucUartRxBuf == NULL)
;;;971        {
;;;972            dev->pucUartRxBuf = (PUINT8) malloc(UARTRXBUFSIZE[nNum] * sizeof(UINT8));
;;;973        }
;;;974        
;;;975        if(dev->pucUartRxBuf == NULL) {
;;;976            free(dev->pucUartTxBuf);
;;;977            return FALSE;
;;;978        }
;;;979    
;;;980        /* Memory allocate Rx character flag */
;;;981        if(dev->pucUARTFlag == NULL)
;;;982        {
;;;983            dev->pucUARTFlag = (PINT) malloc(UARTRXBUFSIZE[nNum] * sizeof(INT));
;;;984        }
;;;985        if(dev->pucUARTFlag == NULL) {
;;;986            free(dev->pucUartTxBuf);
;;;987            free(dev->pucUartRxBuf);
;;;988            return FALSE;
;;;989        }
;;;990    
;;;991        /* initial memory */
;;;992        memset(dev->pucUartTxBuf, 0, UARTTXBUFSIZE[nNum] * sizeof(UINT8));
;;;993        memset(dev->pucUartRxBuf, 0, UARTRXBUFSIZE[nNum] * sizeof(UINT8));
;;;994        memset(dev->pucUARTFlag, 0, UARTRXBUFSIZE[nNum] * sizeof(INT));
;;;995    
;;;996        /* inital struct UART_BUFFER_STRUCT, uUartTxHead, uUartTxTail, uUartRxHead, uUartRxTail */
;;;997        dev->uUartTxHead = dev->uUartTxTail = NULL;
;;;998        dev->uUartRxHead = dev->uUartRxTail = NULL;
;;;999    
;;;1000       return TRUE;
;;;1001   }
00124c  e8bd8070          POP      {r4-r6,pc}
                  |L1.4688|
001250  e5940014          LDR      r0,[r4,#0x14]         ;970
001254  e3500000          CMP      r0,#0                 ;970
001258  1a000003          BNE      |L1.4716|
00125c  e51f1448          LDR      r1,|L1.3612|
001260  e7910105          LDR      r0,[r1,r5,LSL #2]     ;972
001264  ebfffffe          BL       pvPortMalloc
001268  e5840014          STR      r0,[r4,#0x14]         ;972
                  |L1.4716|
00126c  e5940014          LDR      r0,[r4,#0x14]         ;975
001270  e3500000          CMP      r0,#0                 ;975
001274  1a000003          BNE      |L1.4744|
001278  e5940010          LDR      r0,[r4,#0x10]         ;976
00127c  ebfffffe          BL       vPortFree
001280  e3a00000          MOV      r0,#0                 ;977
001284  eafffff0          B        |L1.4684|
                  |L1.4744|
001288  e5940020          LDR      r0,[r4,#0x20]         ;981
00128c  e3500000          CMP      r0,#0                 ;981
001290  1a000004          BNE      |L1.4776|
001294  e51f1480          LDR      r1,|L1.3612|
001298  e7911105          LDR      r1,[r1,r5,LSL #2]     ;983
00129c  e1a00101          LSL      r0,r1,#2              ;983
0012a0  ebfffffe          BL       pvPortMalloc
0012a4  e5840020          STR      r0,[r4,#0x20]         ;983
                  |L1.4776|
0012a8  e5940020          LDR      r0,[r4,#0x20]         ;985
0012ac  e3500000          CMP      r0,#0                 ;985
0012b0  1a000005          BNE      |L1.4812|
0012b4  e5940010          LDR      r0,[r4,#0x10]         ;986
0012b8  ebfffffe          BL       vPortFree
0012bc  e5940014          LDR      r0,[r4,#0x14]         ;987
0012c0  ebfffffe          BL       vPortFree
0012c4  e3a00000          MOV      r0,#0                 ;988
0012c8  eaffffdf          B        |L1.4684|
                  |L1.4812|
0012cc  e51f24a0          LDR      r2,|L1.3636|
0012d0  e7921105          LDR      r1,[r2,r5,LSL #2]     ;992
0012d4  e5940010          LDR      r0,[r4,#0x10]         ;992
0012d8  ebfffffe          BL       __aeabi_memclr
0012dc  e51f24c8          LDR      r2,|L1.3612|
0012e0  e7921105          LDR      r1,[r2,r5,LSL #2]     ;993
0012e4  e5940014          LDR      r0,[r4,#0x14]         ;993
0012e8  ebfffffe          BL       __aeabi_memclr
0012ec  e51f24d8          LDR      r2,|L1.3612|
0012f0  e7922105          LDR      r2,[r2,r5,LSL #2]     ;994
0012f4  e1a01102          LSL      r1,r2,#2              ;994
0012f8  e5940020          LDR      r0,[r4,#0x20]         ;994
0012fc  ebfffffe          BL       __aeabi_memclr4
001300  e3a00000          MOV      r0,#0                 ;997
001304  e5840004          STR      r0,[r4,#4]            ;997
001308  e5840000          STR      r0,[r4,#0]            ;997
00130c  e584000c          STR      r0,[r4,#0xc]          ;998
001310  e5840008          STR      r0,[r4,#8]            ;998
001314  e3a00001          MOV      r0,#1                 ;1000
001318  eaffffcb          B        |L1.4684|
;;;1002   
                          ENDP

                  _uartCheckTxBufSpace PROC
;;;1003   static BOOL _uartCheckTxBufSpace(INT nNum, UINT32 uHead, UINT32 uTail, UINT32 uLen)
00131c  e92d41f0          PUSH     {r4-r8,lr}
;;;1004   {
001320  e1a07000          MOV      r7,r0
001324  e1a04001          MOV      r4,r1
001328  e1a05002          MOV      r5,r2
00132c  e1a06003          MOV      r6,r3
;;;1005       UINT32 uBuf;
;;;1006   
;;;1007       uBuf = _uartTxBufGetNextOne(nNum, uTail);
001330  e1a01005          MOV      r1,r5
001334  e1a00007          MOV      r0,r7
001338  ebfffffe          BL       _uartTxBufGetNextOne
00133c  e1a08000          MOV      r8,r0
;;;1008       if(uBuf == uHead)   /* Tx buffer full */
001340  e1580004          CMP      r8,r4
001344  1a000001          BNE      |L1.4944|
;;;1009           return FALSE;
001348  e3a00000          MOV      r0,#0
                  |L1.4940|
;;;1010   
;;;1011       if(uHead == uTail)  /* Tx buffer empty */
;;;1012           return TRUE;
;;;1013   
;;;1014       if(uTail > uHead) {
;;;1015           if(uLen >= (UARTTXBUFSIZE[nNum]-(uTail-uHead)))  /* 2007.10.29 fix pointer bug, PT23 HHWu */
;;;1016               return FALSE;  /* Tx buffer space isn't enough */
;;;1017           else
;;;1018               return TRUE;
;;;1019       } else {
;;;1020           /* case: uTail < uHead */
;;;1021           if(uLen >= (uHead-uTail))  /* 2007.10.29 fix pointer bug, PT23 HHWu */
;;;1022               return FALSE;  /* Tx buffer space isn't enough */
;;;1023           else
;;;1024               return TRUE;
;;;1025       }
;;;1026   
;;;1027       //return TRUE;
;;;1028   }
00134c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4944|
001350  e1540005          CMP      r4,r5                 ;1011
001354  1a000001          BNE      |L1.4960|
001358  e3a00001          MOV      r0,#1                 ;1012
00135c  eafffffa          B        |L1.4940|
                  |L1.4960|
001360  e1550004          CMP      r5,r4                 ;1014
001364  9a000009          BLS      |L1.5008|
001368  e51f053c          LDR      r0,|L1.3636|
00136c  e7900107          LDR      r0,[r0,r7,LSL #2]     ;1015
001370  e0451004          SUB      r1,r5,r4              ;1015
001374  e0400001          SUB      r0,r0,r1              ;1015
001378  e1500006          CMP      r0,r6                 ;1015
00137c  8a000001          BHI      |L1.5000|
001380  e3a00000          MOV      r0,#0                 ;1016
001384  eafffff0          B        |L1.4940|
                  |L1.5000|
001388  e3a00001          MOV      r0,#1                 ;1018
00138c  eaffffee          B        |L1.4940|
                  |L1.5008|
001390  e0440005          SUB      r0,r4,r5              ;1021
001394  e1500006          CMP      r0,r6                 ;1021
001398  8a000001          BHI      |L1.5028|
00139c  e3a00000          MOV      r0,#0                 ;1022
0013a0  eaffffe9          B        |L1.4940|
                  |L1.5028|
0013a4  e3a00001          MOV      r0,#1                 ;1024
0013a8  eaffffe7          B        |L1.4940|
;;;1029   
                          ENDP

                  _uartReadRxBuf PROC
;;;1030   static INT32 _uartReadRxBuf(INT nNum, PUINT8 pucBuf, UINT32 uLen)
0013ac  e92d47f0          PUSH     {r4-r10,lr}
;;;1031   {
0013b0  e1a08000          MOV      r8,r0
0013b4  e1a07001          MOV      r7,r1
0013b8  e1a05002          MOV      r5,r2
;;;1032       UINT32 i;
;;;1033       UINT32 uOffset = nNum * UARTOFFSET;
0013bc  e1a09408          LSL      r9,r8,#8
;;;1034       UART_BUFFER_T *dev;
;;;1035   
;;;1036       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
0013c0  e0880088          ADD      r0,r8,r8,LSL #1
0013c4  e51f15ac          LDR      r1,|L1.3616|
0013c8  e0814200          ADD      r4,r1,r0,LSL #4
;;;1037   
;;;1038       if(dev->bIsUseUARTRxInt == TRUE) {
0013cc  e5d4001d          LDRB     r0,[r4,#0x1d]
0013d0  e3500001          CMP      r0,#1
0013d4  1a000019          BNE      |L1.5184|
;;;1039   
;;;1040           // disable Rx interrupt ...
;;;1041   
;;;1042           if(dev->uRecCnt == 0)  /* no data in Rx buffer */
0013d8  e5940028          LDR      r0,[r4,#0x28]
0013dc  e3500000          CMP      r0,#0
0013e0  1a000001          BNE      |L1.5100|
;;;1043               return 0;
0013e4  e3a00000          MOV      r0,#0
                  |L1.5096|
;;;1044   
;;;1045           if(uLen > dev->uRecCnt)
;;;1046               uLen = dev->uRecCnt;
;;;1047   
;;;1048           for(i = uLen ; i > 0 ; i--) {
;;;1049               *pucBuf++ = dev->pucUartRxBuf[dev->uUartRxHead];
;;;1050               dev->uUartRxHead = _uartRxBufGetNextOne(nNum, dev->uUartRxHead);
;;;1051           }
;;;1052   
;;;1053           dev->uRecCnt -= uLen;  /* maintain uRecCnt value */
;;;1054       } else { /* pooling mode */
;;;1055           for(i = 0 ; i < uLen; i++) {
;;;1056               while(!(inpw(REG_UART0_FSR+uOffset) & UART_FSR_RX_EMPTY_Msk));
;;;1057               *pucBuf++ = inpb(REG_UART0_RBR+uOffset);
;;;1058           }
;;;1059       }
;;;1060   
;;;1061       return (uLen);
;;;1062   }
0013e8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.5100|
0013ec  e5940028          LDR      r0,[r4,#0x28]         ;1045
0013f0  e1500005          CMP      r0,r5                 ;1045
0013f4  2a000000          BCS      |L1.5116|
0013f8  e5945028          LDR      r5,[r4,#0x28]         ;1046
                  |L1.5116|
0013fc  e1a06005          MOV      r6,r5                 ;1048
001400  ea000008          B        |L1.5160|
                  |L1.5124|
001404  e5940014          LDR      r0,[r4,#0x14]         ;1049
001408  e5941008          LDR      r1,[r4,#8]            ;1049
00140c  e7d00001          LDRB     r0,[r0,r1]            ;1049
001410  e4c70001          STRB     r0,[r7],#1            ;1049
001414  e5941008          LDR      r1,[r4,#8]            ;1050
001418  e1a00008          MOV      r0,r8                 ;1050
00141c  ebfffffe          BL       _uartRxBufGetNextOne
001420  e5840008          STR      r0,[r4,#8]            ;1050
001424  e2466001          SUB      r6,r6,#1              ;1048
                  |L1.5160|
001428  e3560000          CMP      r6,#0                 ;1048
00142c  1afffff4          BNE      |L1.5124|
001430  e5940028          LDR      r0,[r4,#0x28]         ;1053
001434  e0400005          SUB      r0,r0,r5              ;1053
001438  e5840028          STR      r0,[r4,#0x28]         ;1053
00143c  ea00000c          B        |L1.5236|
                  |L1.5184|
001440  e3a06000          MOV      r6,#0                 ;1055
001444  ea000008          B        |L1.5228|
                  |L1.5192|
001448  e1a00000          MOV      r0,r0                 ;1056
                  |L1.5196|
00144c  e289032e          ADD      r0,r9,#0xb8000000     ;1056
001450  e5900018          LDR      r0,[r0,#0x18]         ;1056
001454  e3100901          TST      r0,#0x4000            ;1056
001458  0afffffb          BEQ      |L1.5196|
00145c  e289032e          ADD      r0,r9,#0xb8000000     ;1057
001460  e5d00000          LDRB     r0,[r0,#0]            ;1057
001464  e4c70001          STRB     r0,[r7],#1            ;1057
001468  e2866001          ADD      r6,r6,#1              ;1055
                  |L1.5228|
00146c  e1560005          CMP      r6,r5                 ;1055
001470  3afffff4          BCC      |L1.5192|
                  |L1.5236|
001474  e1a00005          MOV      r0,r5                 ;1061
001478  eaffffda          B        |L1.5096|
;;;1063   
                          ENDP

                  _uartWriteTxBuf PROC
;;;1064   static void _uartWriteTxBuf(INT nNum, PUINT8 pucBuf, UINT32 uLen)
00147c  e92d47f0          PUSH     {r4-r10,lr}
;;;1065   {
001480  e1a06000          MOV      r6,r0
001484  e1a04001          MOV      r4,r1
001488  e1a07002          MOV      r7,r2
;;;1066       UINT32 i;
;;;1067       UINT32 uOffset = nNum * UARTOFFSET;
00148c  e1a09406          LSL      r9,r6,#8
;;;1068       UART_BUFFER_T *dev;
;;;1069   
;;;1070       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
001490  e0860086          ADD      r0,r6,r6,LSL #1
001494  e51f167c          LDR      r1,|L1.3616|
001498  e0815200          ADD      r5,r1,r0,LSL #4
;;;1071   
;;;1072       /* Check interrupt or polling mode first */
;;;1073       if(dev->bIsUseUARTTxInt == TRUE) {
00149c  e5d5001c          LDRB     r0,[r5,#0x1c]
0014a0  e3500001          CMP      r0,#1
0014a4  1a000013          BNE      |L1.5368|
;;;1074           while(uLen--) {
0014a8  ea000007          B        |L1.5324|
                  |L1.5292|
;;;1075               dev->pucUartTxBuf[dev->uUartTxTail] = *pucBuf++;
0014ac  e4d40001          LDRB     r0,[r4],#1
0014b0  e5951010          LDR      r1,[r5,#0x10]
0014b4  e5952004          LDR      r2,[r5,#4]
0014b8  e7c10002          STRB     r0,[r1,r2]
;;;1076               dev->uUartTxTail = _uartTxBufGetNextOne(nNum, dev->uUartTxTail);
0014bc  e5951004          LDR      r1,[r5,#4]
0014c0  e1a00006          MOV      r0,r6
0014c4  ebfffffe          BL       _uartTxBufGetNextOne
0014c8  e5850004          STR      r0,[r5,#4]
                  |L1.5324|
0014cc  e1b00007          MOVS     r0,r7                 ;1074
0014d0  e2477001          SUB      r7,r7,#1              ;1074
0014d4  1afffff4          BNE      |L1.5292|
;;;1077           }
;;;1078   
;;;1079           if (!(inpw(REG_UART0_IER+uOffset) & UART_IER_THRE_IEN_Msk))  /* Enable Tx empty interrupt */
0014d8  e289032e          ADD      r0,r9,#0xb8000000
0014dc  e5900004          LDR      r0,[r0,#4]
0014e0  e3100002          TST      r0,#2
0014e4  1a000010          BNE      |L1.5420|
;;;1080               _uartEnableInterrupt(nNum, UART_IER_THRE_IEN_Msk);
0014e8  e3a01002          MOV      r1,#2
0014ec  e1a00006          MOV      r0,r6
0014f0  ebfffffe          BL       _uartEnableInterrupt
0014f4  ea00000c          B        |L1.5420|
                  |L1.5368|
;;;1081       } else { /* pooling mode */
;;;1082           for(i = 0 ; i < uLen ; i++) {
0014f8  e3a08000          MOV      r8,#0
0014fc  ea000008          B        |L1.5412|
                  |L1.5376|
;;;1083               /* Wait until the transmitter buffer is empty */
;;;1084               while(!(inpw(REG_UART0_FSR+uOffset) & UART_FSR_TE_FLAG_Msk));
001500  e1a00000          MOV      r0,r0
                  |L1.5380|
001504  e289032e          ADD      r0,r9,#0xb8000000
001508  e5900018          LDR      r0,[r0,#0x18]
00150c  e3100201          TST      r0,#0x10000000
001510  0afffffb          BEQ      |L1.5380|
;;;1085               outpw(REG_UART0_THR+uOffset, *pucBuf++);
001514  e4d40001          LDRB     r0,[r4],#1
001518  e289132e          ADD      r1,r9,#0xb8000000
00151c  e5810000          STR      r0,[r1,#0]
001520  e2888001          ADD      r8,r8,#1              ;1082
                  |L1.5412|
001524  e1580007          CMP      r8,r7                 ;1082
001528  3afffff4          BCC      |L1.5376|
                  |L1.5420|
;;;1086           }
;;;1087       }
;;;1088   }
00152c  e8bd87f0          POP      {r4-r10,pc}
;;;1089   
                          ENDP

                  _uartConfigureUART PROC
;;;1090   static INT _uartConfigureUART(PVOID pvParam)
001530  e92d47f0          PUSH     {r4-r10,lr}
;;;1091   {
001534  e1a06000          MOV      r6,r0
;;;1092       INT retval;
;;;1093       BOOL bIsMemoryAllocOk;
;;;1094       UINT32 u32Reg;
;;;1095       UINT32 uOffset;
;;;1096       UINT32 uNum=0;
001538  e3a0a000          MOV      r10,#0
;;;1097   
;;;1098       UART_T *param = (UART_T *) pvParam;
00153c  e1a04006          MOV      r4,r6
;;;1099   
;;;1100       uOffset = param->ucUartNo * UARTOFFSET;
001540  e5d40008          LDRB     r0,[r4,#8]
001544  e1a05400          LSL      r5,r0,#8
;;;1101       uNum = param->ucUartNo;
001548  e5d4a008          LDRB     r10,[r4,#8]
;;;1102   
;;;1103       /* Check UART channel */
;;;1104       if ( uNum > UARTA )
00154c  e35a000a          CMP      r10,#0xa
001550  9a000001          BLS      |L1.5468|
;;;1105           return UART_ERR_CHANNEL_INVALID;
001554  e3e00004          MVN      r0,#4
                  |L1.5464|
;;;1106   
;;;1107       /* Check the supplied parity */
;;;1108       if ( (param->ucParity != PARITY_NONE) &&
;;;1109               (param->ucParity != PARITY_EVEN) &&
;;;1110               (param->ucParity != PARITY_ODD)  &&
;;;1111               (param->ucParity != (PARITY_ODD | PARITY_STICK)) &&
;;;1112               (param->ucParity != (PARITY_EVEN | PARITY_STICK)) )
;;;1113           return UART_ERR_PARITY_INVALID;
;;;1114   
;;;1115       /* Check the supplied number of data bits */
;;;1116       if ( (param->ucDataBits != DATA_BITS_5) &&
;;;1117               (param->ucDataBits != DATA_BITS_6) &&
;;;1118               (param->ucDataBits != DATA_BITS_7) &&
;;;1119               (param->ucDataBits != DATA_BITS_8) )
;;;1120           return UART_ERR_DATA_BITS_INVALID;
;;;1121   
;;;1122       /* Check the supplied number of stop bits */
;;;1123       if ( (param->ucStopBits != STOP_BITS_1) &&
;;;1124               (param->ucStopBits != STOP_BITS_2) )
;;;1125           return UART_ERR_STOP_BITS_INVALID;
;;;1126   
;;;1127       /* Check the supplied number of trigger level bytes */
;;;1128       if ( (param -> ucUartNo == UART1) || (param -> ucUartNo == UART2) || (param -> ucUartNo == UART4) ||
;;;1129               (param -> ucUartNo == UART6) || (param -> ucUartNo == UART8) || (param -> ucUartNo == UARTA)) {
;;;1130           /* UART1,2,4,6,8,A */
;;;1131           if ( (param->ucRxTriggerLevel != UART_FCR_RFITL_1BYTE)   &&
;;;1132                   (param->ucRxTriggerLevel != UART_FCR_RFITL_4BYTES)  &&
;;;1133                   (param->ucRxTriggerLevel != UART_FCR_RFITL_8BYTES)  &&
;;;1134                   (param->ucRxTriggerLevel != UART_FCR_RFITL_14BYTES) &&
;;;1135                   (param->ucRxTriggerLevel != UART_FCR_RFITL_30BYTES) &&
;;;1136                   (param->ucRxTriggerLevel != UART_FCR_RFITL_46BYTES) &&
;;;1137                   (param->ucRxTriggerLevel != UART_FCR_RFITL_62BYTES) )
;;;1138               return UART_ERR_TRIGGERLEVEL_INVALID;
;;;1139       } else {
;;;1140           /* UART0,3,5,7,9 */
;;;1141           if ( (param->ucRxTriggerLevel != UART_FCR_RFITL_1BYTE)  &&
;;;1142                   (param->ucRxTriggerLevel != UART_FCR_RFITL_4BYTES) &&
;;;1143                   (param->ucRxTriggerLevel != UART_FCR_RFITL_8BYTES) &&
;;;1144                   (param->ucRxTriggerLevel != UART_FCR_RFITL_30BYTES) )
;;;1145               return UART_ERR_TRIGGERLEVEL_INVALID;
;;;1146       }
;;;1147   
;;;1148       /* Enable UART clock */
;;;1149       if(param->ucUartNo < ALLCHANNEL) {
;;;1150           outpw(REG_CLK_PCLKEN0, inpw(REG_CLK_PCLKEN0) | (1 << (16+param->ucUartNo)) );
;;;1151       }
;;;1152   
;;;1153       /* Reset TX/RX FIFOs */
;;;1154       u32Reg = inpw(REG_UART0_FCR+uOffset);
;;;1155       outpw(REG_UART0_FCR+uOffset, (u32Reg | (0x03 << 1)) );
;;;1156   
;;;1157       /* Setup baud rate */
;;;1158       retval = _uartSetBaudRate(param->ucUartNo, param);
;;;1159       if (retval < 0)
;;;1160           return UART_ERR_SET_BAUDRATE_FAIL;
;;;1161   
;;;1162       /* Setup parity, data bits, and stop bits */
;;;1163       outpw(REG_UART0_LCR+uOffset, (param->ucParity | param->ucDataBits | param->ucStopBits));
;;;1164   
;;;1165       /* Setup Rx time out value */
;;;1166       outpw(REG_UART0_TOR+uOffset, 0x80+0x20);
;;;1167   
;;;1168       /* Setup FIFO trigger level */
;;;1169       outpw(REG_UART0_FCR+uOffset, param->ucRxTriggerLevel);
;;;1170   
;;;1171       /* only exec once unless call uartClose() */
;;;1172       if(UART_DEV[param->ucUartNo].bIsUARTInitial == FALSE) {
;;;1173           /* Configure GPIO function */
;;;1174           //_uartConfigureGPIO(param->ucUartNo);
;;;1175   
;;;1176           /* Allocate Tx, Rx buffer */
;;;1177           bIsMemoryAllocOk = _uartBUFSpaceAlloc(param->ucUartNo);
;;;1178           if(bIsMemoryAllocOk == FALSE)
;;;1179               return UART_ERR_ALLOC_MEMORY_FAIL;
;;;1180   
;;;1181           /* Hook UART interrupt service routine */
;;;1182           _uartInstallISR(param->ucUartNo);
;;;1183   
;;;1184           /* Enable Rx interrupt */
;;;1185           if(UART_DEV[param->ucUartNo].bIsUseUARTRxInt == TRUE)
;;;1186               _uartEnableInterrupt(param->ucUartNo, UART_IER_RDA_IEN_Msk);
;;;1187   
;;;1188           /* inital struct UART_BUFFER_STRUCT, uRecCnt */
;;;1189           UART_DEV[param->ucUartNo].uRecCnt = 0;
;;;1190       }
;;;1191   
;;;1192       UART_DEV[param->ucUartNo].bIsUARTInitial = TRUE;  /* it's important to set TRUE */
;;;1193       return 0;
;;;1194   }
001558  e8bd87f0          POP      {r4-r10,pc}
                  |L1.5468|
00155c  e5d4000b          LDRB     r0,[r4,#0xb]          ;1108
001560  e3500000          CMP      r0,#0                 ;1108
001564  0a00000d          BEQ      |L1.5536|
001568  e5d4000b          LDRB     r0,[r4,#0xb]          ;1109
00156c  e3500018          CMP      r0,#0x18              ;1109
001570  0a00000a          BEQ      |L1.5536|
001574  e5d4000b          LDRB     r0,[r4,#0xb]          ;1110
001578  e3500008          CMP      r0,#8                 ;1110
00157c  0a000007          BEQ      |L1.5536|
001580  e5d4000b          LDRB     r0,[r4,#0xb]          ;1111
001584  e3500048          CMP      r0,#0x48              ;1111
001588  0a000004          BEQ      |L1.5536|
00158c  e5d4000b          LDRB     r0,[r4,#0xb]          ;1112
001590  e3500058          CMP      r0,#0x58              ;1112
001594  0a000001          BEQ      |L1.5536|
001598  e3e00000          MVN      r0,#0                 ;1113
00159c  eaffffed          B        |L1.5464|
                  |L1.5536|
0015a0  e5d40009          LDRB     r0,[r4,#9]            ;1116
0015a4  e3500000          CMP      r0,#0                 ;1116
0015a8  0a00000a          BEQ      |L1.5592|
0015ac  e5d40009          LDRB     r0,[r4,#9]            ;1117
0015b0  e3500001          CMP      r0,#1                 ;1117
0015b4  0a000007          BEQ      |L1.5592|
0015b8  e5d40009          LDRB     r0,[r4,#9]            ;1118
0015bc  e3500002          CMP      r0,#2                 ;1118
0015c0  0a000004          BEQ      |L1.5592|
0015c4  e5d40009          LDRB     r0,[r4,#9]            ;1119
0015c8  e3500003          CMP      r0,#3                 ;1119
0015cc  0a000001          BEQ      |L1.5592|
0015d0  e3e00001          MVN      r0,#1                 ;1120
0015d4  eaffffdf          B        |L1.5464|
                  |L1.5592|
0015d8  e5d4000a          LDRB     r0,[r4,#0xa]          ;1123
0015dc  e3500000          CMP      r0,#0                 ;1123
0015e0  0a000004          BEQ      |L1.5624|
0015e4  e5d4000a          LDRB     r0,[r4,#0xa]          ;1124
0015e8  e3500004          CMP      r0,#4                 ;1124
0015ec  0a000001          BEQ      |L1.5624|
0015f0  e3e00002          MVN      r0,#2                 ;1125
0015f4  eaffffd7          B        |L1.5464|
                  |L1.5624|
0015f8  e5d40008          LDRB     r0,[r4,#8]            ;1128
0015fc  e3500001          CMP      r0,#1                 ;1128
001600  0a00000e          BEQ      |L1.5696|
001604  e5d40008          LDRB     r0,[r4,#8]            ;1128
001608  e3500002          CMP      r0,#2                 ;1128
00160c  0a00000b          BEQ      |L1.5696|
001610  e5d40008          LDRB     r0,[r4,#8]            ;1128
001614  e3500004          CMP      r0,#4                 ;1128
001618  0a000008          BEQ      |L1.5696|
00161c  e5d40008          LDRB     r0,[r4,#8]            ;1129
001620  e3500006          CMP      r0,#6                 ;1129
001624  0a000005          BEQ      |L1.5696|
001628  e5d40008          LDRB     r0,[r4,#8]            ;1129
00162c  e3500008          CMP      r0,#8                 ;1129
001630  0a000002          BEQ      |L1.5696|
001634  e5d40008          LDRB     r0,[r4,#8]            ;1129
001638  e350000a          CMP      r0,#0xa               ;1129
00163c  1a000016          BNE      |L1.5788|
                  |L1.5696|
001640  e5d4000c          LDRB     r0,[r4,#0xc]          ;1131
001644  e3500000          CMP      r0,#0                 ;1131
001648  0a000021          BEQ      |L1.5844|
00164c  e5d4000c          LDRB     r0,[r4,#0xc]          ;1132
001650  e3500010          CMP      r0,#0x10              ;1132
001654  0a00001e          BEQ      |L1.5844|
001658  e5d4000c          LDRB     r0,[r4,#0xc]          ;1133
00165c  e3500020          CMP      r0,#0x20              ;1133
001660  0a00001b          BEQ      |L1.5844|
001664  e5d4000c          LDRB     r0,[r4,#0xc]          ;1134
001668  e3500030          CMP      r0,#0x30              ;1134
00166c  0a000018          BEQ      |L1.5844|
001670  e5d4000c          LDRB     r0,[r4,#0xc]          ;1135
001674  e3500040          CMP      r0,#0x40              ;1135
001678  0a000015          BEQ      |L1.5844|
00167c  e5d4000c          LDRB     r0,[r4,#0xc]          ;1136
001680  e3500050          CMP      r0,#0x50              ;1136
001684  0a000012          BEQ      |L1.5844|
001688  e5d4000c          LDRB     r0,[r4,#0xc]          ;1137
00168c  e3500060          CMP      r0,#0x60              ;1137
001690  0a00000f          BEQ      |L1.5844|
001694  e3e00003          MVN      r0,#3                 ;1138
001698  eaffffae          B        |L1.5464|
                  |L1.5788|
00169c  e5d4000c          LDRB     r0,[r4,#0xc]          ;1141
0016a0  e3500000          CMP      r0,#0                 ;1141
0016a4  0a00000a          BEQ      |L1.5844|
0016a8  e5d4000c          LDRB     r0,[r4,#0xc]          ;1142
0016ac  e3500010          CMP      r0,#0x10              ;1142
0016b0  0a000007          BEQ      |L1.5844|
0016b4  e5d4000c          LDRB     r0,[r4,#0xc]          ;1143
0016b8  e3500020          CMP      r0,#0x20              ;1143
0016bc  0a000004          BEQ      |L1.5844|
0016c0  e5d4000c          LDRB     r0,[r4,#0xc]          ;1144
0016c4  e3500040          CMP      r0,#0x40              ;1144
0016c8  0a000001          BEQ      |L1.5844|
0016cc  e3e00003          MVN      r0,#3                 ;1145
0016d0  eaffffa0          B        |L1.5464|
                  |L1.5844|
0016d4  e5d40008          LDRB     r0,[r4,#8]            ;1149
0016d8  e350000b          CMP      r0,#0xb               ;1149
0016dc  aa000007          BGE      |L1.5888|
0016e0  e3a0020b          MOV      r0,#0xb0000000        ;1150
0016e4  e5900218          LDR      r0,[r0,#0x218]        ;1150
0016e8  e5d41008          LDRB     r1,[r4,#8]            ;1150
0016ec  e2811010          ADD      r1,r1,#0x10           ;1150
0016f0  e3a02001          MOV      r2,#1                 ;1150
0016f4  e1800112          ORR      r0,r0,r2,LSL r1       ;1150
0016f8  e3a0120b          MOV      r1,#0xb0000000        ;1150
0016fc  e5810218          STR      r0,[r1,#0x218]        ;1150
                  |L1.5888|
001700  e285032e          ADD      r0,r5,#0xb8000000     ;1154
001704  e5909008          LDR      r9,[r0,#8]            ;1154
001708  e3890006          ORR      r0,r9,#6              ;1155
00170c  e285132e          ADD      r1,r5,#0xb8000000     ;1155
001710  e5810008          STR      r0,[r1,#8]            ;1155
001714  e5d40008          LDRB     r0,[r4,#8]            ;1158
001718  e1a01004          MOV      r1,r4                 ;1158
00171c  ebfffffe          BL       _uartSetBaudRate
001720  e1a07000          MOV      r7,r0                 ;1158
001724  e3570000          CMP      r7,#0                 ;1159
001728  aa000001          BGE      |L1.5940|
00172c  e3e0000c          MVN      r0,#0xc               ;1160
001730  eaffff88          B        |L1.5464|
                  |L1.5940|
001734  e5d4000b          LDRB     r0,[r4,#0xb]          ;1163
001738  e5d41009          LDRB     r1,[r4,#9]            ;1163
00173c  e1800001          ORR      r0,r0,r1              ;1163
001740  e5d4100a          LDRB     r1,[r4,#0xa]          ;1163
001744  e1800001          ORR      r0,r0,r1              ;1163
001748  e285132e          ADD      r1,r5,#0xb8000000     ;1163
00174c  e581000c          STR      r0,[r1,#0xc]          ;1163
001750  e3a000a0          MOV      r0,#0xa0              ;1166
001754  e285132e          ADD      r1,r5,#0xb8000000     ;1166
001758  e5810020          STR      r0,[r1,#0x20]         ;1166
00175c  e5d4000c          LDRB     r0,[r4,#0xc]          ;1169
001760  e285132e          ADD      r1,r5,#0xb8000000     ;1169
001764  e5810008          STR      r0,[r1,#8]            ;1169
001768  e5d40008          LDRB     r0,[r4,#8]            ;1172
00176c  e0800080          ADD      r0,r0,r0,LSL #1       ;1172
001770  e51f1958          LDR      r1,|L1.3616|
001774  e0810200          ADD      r0,r1,r0,LSL #4       ;1172
001778  e5d0001e          LDRB     r0,[r0,#0x1e]         ;1172
00177c  e3500000          CMP      r0,#0                 ;1172
001780  1a000018          BNE      |L1.6120|
001784  e5d40008          LDRB     r0,[r4,#8]            ;1177
001788  ebfffffe          BL       _uartBUFSpaceAlloc
00178c  e1a08000          MOV      r8,r0                 ;1177
001790  e3580000          CMP      r8,#0                 ;1178
001794  1a000001          BNE      |L1.6048|
001798  e3e00005          MVN      r0,#5                 ;1179
00179c  eaffff6d          B        |L1.5464|
                  |L1.6048|
0017a0  e5d40008          LDRB     r0,[r4,#8]            ;1182
0017a4  ebfffffe          BL       _uartInstallISR
0017a8  e5d40008          LDRB     r0,[r4,#8]            ;1185
0017ac  e0800080          ADD      r0,r0,r0,LSL #1       ;1185
0017b0  e51f1998          LDR      r1,|L1.3616|
0017b4  e0810200          ADD      r0,r1,r0,LSL #4       ;1185
0017b8  e5d0001d          LDRB     r0,[r0,#0x1d]         ;1185
0017bc  e3500001          CMP      r0,#1                 ;1185
0017c0  1a000002          BNE      |L1.6096|
0017c4  e5d40008          LDRB     r0,[r4,#8]            ;1186
0017c8  e3a01001          MOV      r1,#1                 ;1186
0017cc  ebfffffe          BL       _uartEnableInterrupt
                  |L1.6096|
0017d0  e3a00000          MOV      r0,#0                 ;1189
0017d4  e5d41008          LDRB     r1,[r4,#8]            ;1189
0017d8  e0811081          ADD      r1,r1,r1,LSL #1       ;1189
0017dc  e51f29c4          LDR      r2,|L1.3616|
0017e0  e0821201          ADD      r1,r2,r1,LSL #4       ;1189
0017e4  e5810028          STR      r0,[r1,#0x28]         ;1189
                  |L1.6120|
0017e8  e3a00001          MOV      r0,#1                 ;1192
0017ec  e5d41008          LDRB     r1,[r4,#8]            ;1192
0017f0  e0811081          ADD      r1,r1,r1,LSL #1       ;1192
0017f4  e51f29dc          LDR      r2,|L1.3616|
0017f8  e0821201          ADD      r1,r2,r1,LSL #4       ;1192
0017fc  e5c1001e          STRB     r0,[r1,#0x1e]         ;1192
001800  e3a00000          MOV      r0,#0                 ;1193
001804  eaffff53          B        |L1.5464|
;;;1195   
                          ENDP

                  _uartPerformIrDA PROC
;;;1196   static INT _uartPerformIrDA(INT nNum, UINT32 uCmd, UINT32 uCmd1)  /* UART2 only */
001808  e92d4010          PUSH     {r4,lr}
;;;1197   {
00180c  e1a03000          MOV      r3,r0
001810  e1a0c001          MOV      r12,r1
;;;1198       UINT32 uOffset = nNum * UARTOFFSET;
001814  e1a01403          LSL      r1,r3,#8
;;;1199   
;;;1200       switch(uCmd) {
001818  e35c0000          CMP      r12,#0
00181c  0a000015          BEQ      |L1.6264|
001820  e35c0001          CMP      r12,#1
001824  1a00001b          BNE      |L1.6296|
;;;1201       case ENABLEIrDA:
;;;1202           //_uart_bIsPerformIrDA = TRUE;
;;;1203   
;;;1204           if(uCmd1 == IrDA_TX)
001828  e3520000          CMP      r2,#0
00182c  1a000004          BNE      |L1.6212|
;;;1205               outpw(REG_UART0_IRCR+uOffset, _uart_IrDATxReg);
001830  e59f04d8          LDR      r0,|L1.7440|
001834  e5900000          LDR      r0,[r0,#0]  ; _uart_IrDATxReg
001838  e281432e          ADD      r4,r1,#0xb8000000
00183c  e5840028          STR      r0,[r4,#0x28]
001840  ea000008          B        |L1.6248|
                  |L1.6212|
;;;1206           else if(uCmd1 == IrDA_RX)
001844  e3520001          CMP      r2,#1
001848  1a000004          BNE      |L1.6240|
;;;1207               outpw(REG_UART0_IRCR+uOffset, _uart_IrDARxReg);
00184c  e59f04c0          LDR      r0,|L1.7444|
001850  e5900000          LDR      r0,[r0,#0]  ; _uart_IrDARxReg
001854  e281432e          ADD      r4,r1,#0xb8000000
001858  e5840028          STR      r0,[r4,#0x28]
00185c  ea000001          B        |L1.6248|
                  |L1.6240|
;;;1208           else
;;;1209               return UART_ERR_IrDA_COMMAND_INVALID;
001860  e3e00009          MVN      r0,#9
                  |L1.6244|
;;;1210   
;;;1211           outpw(REG_UART0_FUN_SEL+uOffset, 0x2); // Select IrDA mode
;;;1212   
;;;1213           break;
;;;1214   
;;;1215       case DISABLEIrDA:
;;;1216           //_uart_bIsPerformIrDA = FALSE;
;;;1217           outpw(REG_UART0_IRCR+uOffset, 0x40);  /* Set default value, INV_TX set 0, INV_RX set 1 */
;;;1218           outpw(REG_UART0_FUN_SEL+uOffset, 0x0); // Select UART mode
;;;1219           break;
;;;1220   
;;;1221       default:
;;;1222           return UART_ERR_IrDA_COMMAND_INVALID;
;;;1223       }
;;;1224   
;;;1225       return 0;
;;;1226   }
001864  e8bd8010          POP      {r4,pc}
                  |L1.6248|
001868  e3a00002          MOV      r0,#2                 ;1211
00186c  e281432e          ADD      r4,r1,#0xb8000000     ;1211
001870  e5840030          STR      r0,[r4,#0x30]         ;1211
001874  ea00000a          B        |L1.6308|
                  |L1.6264|
001878  e1a00000          MOV      r0,r0                 ;1215
00187c  e3a00040          MOV      r0,#0x40              ;1217
001880  e281432e          ADD      r4,r1,#0xb8000000     ;1217
001884  e5840028          STR      r0,[r4,#0x28]         ;1217
001888  e3a00000          MOV      r0,#0                 ;1218
00188c  e281432e          ADD      r4,r1,#0xb8000000     ;1218
001890  e5840030          STR      r0,[r4,#0x30]         ;1218
001894  ea000002          B        |L1.6308|
                  |L1.6296|
001898  e1a00000          MOV      r0,r0                 ;1221
00189c  e3e00009          MVN      r0,#9                 ;1222
0018a0  eaffffef          B        |L1.6244|
                  |L1.6308|
0018a4  e1a00000          MOV      r0,r0                 ;1213
0018a8  e3a00000          MOV      r0,#0                 ;1225
0018ac  eaffffec          B        |L1.6244|
;;;1227   
                          ENDP

                  _uartGetRegisterValue PROC
;;;1231   */
;;;1232   static INT _uartGetRegisterValue(INT nNum, PVOID pvReg)
0018b0  e92d41f0          PUSH     {r4-r8,lr}
;;;1233   {
0018b4  e1a08000          MOV      r8,r0
0018b8  e1a04001          MOV      r4,r1
;;;1234       INT nCnt = 0;
0018bc  e3a05000          MOV      r5,#0
;;;1235       UINT32 uOffset = nNum * UARTOFFSET;
0018c0  e1a07408          LSL      r7,r8,#8
;;;1236   
;;;1237       UART_REGISTER_T *reg = (UART_REGISTER_T *) pvReg;
0018c4  e1a06004          MOV      r6,r4
;;;1238   
;;;1239       memset(reg, 0, sizeof(UART_REGISTER_T));
0018c8  e3a01070          MOV      r1,#0x70
0018cc  e1a00006          MOV      r0,r6
0018d0  ebfffffe          BL       __aeabi_memclr4
;;;1240   
;;;1241       /* Read IER */
;;;1242       reg->uUartReg[nCnt][0] = REG_UART0_IER + uOffset;
0018d4  e3e003ee          MVN      r0,#0xb8000003
0018d8  e0470000          SUB      r0,r7,r0
0018dc  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1243       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_IER + uOffset);
0018e0  e287032e          ADD      r0,r7,#0xb8000000
0018e4  e5901004          LDR      r1,[r0,#4]
0018e8  e1a00005          MOV      r0,r5
0018ec  e2855001          ADD      r5,r5,#1
0018f0  e0860180          ADD      r0,r6,r0,LSL #3
0018f4  e5801004          STR      r1,[r0,#4]
;;;1244   
;;;1245       /* Read FCR */
;;;1246       reg->uUartReg[nCnt][0] = REG_UART0_FCR + uOffset;
0018f8  e59f0418          LDR      r0,|L1.7448|
0018fc  e0800007          ADD      r0,r0,r7
001900  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1247       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_FCR + uOffset);
001904  e287032e          ADD      r0,r7,#0xb8000000
001908  e5901008          LDR      r1,[r0,#8]
00190c  e1a00005          MOV      r0,r5
001910  e2855001          ADD      r5,r5,#1
001914  e0860180          ADD      r0,r6,r0,LSL #3
001918  e5801004          STR      r1,[r0,#4]
;;;1248   
;;;1249       /* Read LCR */
;;;1250       reg->uUartReg[nCnt][0] = REG_UART0_LCR + uOffset;
00191c  e59f03f8          LDR      r0,|L1.7452|
001920  e0800007          ADD      r0,r0,r7
001924  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1251       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_LCR + uOffset);
001928  e287032e          ADD      r0,r7,#0xb8000000
00192c  e590100c          LDR      r1,[r0,#0xc]
001930  e1a00005          MOV      r0,r5
001934  e2855001          ADD      r5,r5,#1
001938  e0860180          ADD      r0,r6,r0,LSL #3
00193c  e5801004          STR      r1,[r0,#4]
;;;1252   
;;;1253       /* Read MCR, MSR */
;;;1254       reg->uUartReg[nCnt][0] = REG_UART0_MCR + uOffset;
001940  e59f03d8          LDR      r0,|L1.7456|
001944  e0800007          ADD      r0,r0,r7
001948  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1255       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_MCR + uOffset);
00194c  e287032e          ADD      r0,r7,#0xb8000000
001950  e5901010          LDR      r1,[r0,#0x10]
001954  e1a00005          MOV      r0,r5
001958  e2855001          ADD      r5,r5,#1
00195c  e0860180          ADD      r0,r6,r0,LSL #3
001960  e5801004          STR      r1,[r0,#4]
;;;1256       reg->uUartReg[nCnt][0] = REG_UART0_MSR + uOffset;
001964  e59f03b8          LDR      r0,|L1.7460|
001968  e0800007          ADD      r0,r0,r7
00196c  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1257       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_MSR + uOffset);
001970  e287032e          ADD      r0,r7,#0xb8000000
001974  e5901014          LDR      r1,[r0,#0x14]
001978  e1a00005          MOV      r0,r5
00197c  e2855001          ADD      r5,r5,#1
001980  e0860180          ADD      r0,r6,r0,LSL #3
001984  e5801004          STR      r1,[r0,#4]
;;;1258   
;;;1259       /* Read FSR */
;;;1260       reg->uUartReg[nCnt][0] = REG_UART0_FSR + uOffset;
001988  e59f0398          LDR      r0,|L1.7464|
00198c  e0800007          ADD      r0,r0,r7
001990  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1261       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_FSR + uOffset);
001994  e287032e          ADD      r0,r7,#0xb8000000
001998  e5901018          LDR      r1,[r0,#0x18]
00199c  e1a00005          MOV      r0,r5
0019a0  e2855001          ADD      r5,r5,#1
0019a4  e0860180          ADD      r0,r6,r0,LSL #3
0019a8  e5801004          STR      r1,[r0,#4]
;;;1262   
;;;1263       /* Read ISR */
;;;1264       reg->uUartReg[nCnt][0] = REG_UART0_ISR + uOffset;
0019ac  e59f0378          LDR      r0,|L1.7468|
0019b0  e0800007          ADD      r0,r0,r7
0019b4  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1265       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_ISR + uOffset);
0019b8  e287032e          ADD      r0,r7,#0xb8000000
0019bc  e590101c          LDR      r1,[r0,#0x1c]
0019c0  e1a00005          MOV      r0,r5
0019c4  e2855001          ADD      r5,r5,#1
0019c8  e0860180          ADD      r0,r6,r0,LSL #3
0019cc  e5801004          STR      r1,[r0,#4]
;;;1266   
;;;1267       /* Read TOR */
;;;1268       reg->uUartReg[nCnt][0] = REG_UART0_TOR + uOffset;
0019d0  e59f0358          LDR      r0,|L1.7472|
0019d4  e0800007          ADD      r0,r0,r7
0019d8  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1269       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_TOR + uOffset);
0019dc  e287032e          ADD      r0,r7,#0xb8000000
0019e0  e5901020          LDR      r1,[r0,#0x20]
0019e4  e1a00005          MOV      r0,r5
0019e8  e2855001          ADD      r5,r5,#1
0019ec  e0860180          ADD      r0,r6,r0,LSL #3
0019f0  e5801004          STR      r1,[r0,#4]
;;;1270   
;;;1271       /* Read BAUD */
;;;1272       reg->uUartReg[nCnt][0] = REG_UART0_BAUD + uOffset;
0019f4  e59f0338          LDR      r0,|L1.7476|
0019f8  e0800007          ADD      r0,r0,r7
0019fc  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1273       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_BAUD + uOffset);
001a00  e287032e          ADD      r0,r7,#0xb8000000
001a04  e5901024          LDR      r1,[r0,#0x24]
001a08  e1a00005          MOV      r0,r5
001a0c  e2855001          ADD      r5,r5,#1
001a10  e0860180          ADD      r0,r6,r0,LSL #3
001a14  e5801004          STR      r1,[r0,#4]
;;;1274   
;;;1275       /* Read IRCR */
;;;1276       reg->uUartReg[nCnt][0] = REG_UART0_IRCR + uOffset;
001a18  e59f0318          LDR      r0,|L1.7480|
001a1c  e0800007          ADD      r0,r0,r7
001a20  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1277       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_IRCR + uOffset);
001a24  e287032e          ADD      r0,r7,#0xb8000000
001a28  e5901028          LDR      r1,[r0,#0x28]
001a2c  e1a00005          MOV      r0,r5
001a30  e2855001          ADD      r5,r5,#1
001a34  e0860180          ADD      r0,r6,r0,LSL #3
001a38  e5801004          STR      r1,[r0,#4]
;;;1278   
;;;1279       /* Read ALT_CSR */
;;;1280       reg->uUartReg[nCnt][0] = REG_UART0_ALT_CSR + uOffset;
001a3c  e59f02f8          LDR      r0,|L1.7484|
001a40  e0800007          ADD      r0,r0,r7
001a44  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1281       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_ALT_CSR + uOffset);
001a48  e287032e          ADD      r0,r7,#0xb8000000
001a4c  e590102c          LDR      r1,[r0,#0x2c]
001a50  e1a00005          MOV      r0,r5
001a54  e2855001          ADD      r5,r5,#1
001a58  e0860180          ADD      r0,r6,r0,LSL #3
001a5c  e5801004          STR      r1,[r0,#4]
;;;1282   
;;;1283       /* Read FUN_SEL */
;;;1284       reg->uUartReg[nCnt][0] = REG_UART0_FUN_SEL + uOffset;
001a60  e59f02d8          LDR      r0,|L1.7488|
001a64  e0800007          ADD      r0,r0,r7
001a68  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1285       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_FUN_SEL + uOffset);
001a6c  e287032e          ADD      r0,r7,#0xb8000000
001a70  e5901030          LDR      r1,[r0,#0x30]
001a74  e1a00005          MOV      r0,r5
001a78  e2855001          ADD      r5,r5,#1
001a7c  e0860180          ADD      r0,r6,r0,LSL #3
001a80  e5801004          STR      r1,[r0,#4]
;;;1286   
;;;1287       /* Read LIN_CTL */
;;;1288       reg->uUartReg[nCnt][0] = REG_UART0_LIN_CTL + uOffset;
001a84  e59f02b8          LDR      r0,|L1.7492|
001a88  e0800007          ADD      r0,r0,r7
001a8c  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1289       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_LIN_CTL + uOffset);
001a90  e287032e          ADD      r0,r7,#0xb8000000
001a94  e5901034          LDR      r1,[r0,#0x34]
001a98  e1a00005          MOV      r0,r5
001a9c  e2855001          ADD      r5,r5,#1
001aa0  e0860180          ADD      r0,r6,r0,LSL #3
001aa4  e5801004          STR      r1,[r0,#4]
;;;1290   
;;;1291       /* Read LIN_SR */
;;;1292       reg->uUartReg[nCnt][0] = REG_UART0_LIN_SR + uOffset;
001aa8  e59f0298          LDR      r0,|L1.7496|
001aac  e0800007          ADD      r0,r0,r7
001ab0  e7860185          STR      r0,[r6,r5,LSL #3]
;;;1293       reg->uUartReg[nCnt++][1] = inpw(REG_UART0_LIN_SR + uOffset);
001ab4  e287032e          ADD      r0,r7,#0xb8000000
001ab8  e5901038          LDR      r1,[r0,#0x38]
001abc  e1a00005          MOV      r0,r5
001ac0  e2855001          ADD      r5,r5,#1
001ac4  e0860180          ADD      r0,r6,r0,LSL #3
001ac8  e5801004          STR      r1,[r0,#4]
;;;1294   
;;;1295       return (nCnt);
001acc  e1a00005          MOV      r0,r5
;;;1296   }
001ad0  e8bd81f0          POP      {r4-r8,pc}
;;;1297   
                          ENDP

                  uartInit PROC
;;;1308     */
;;;1309   INT uartInit(void)
001ad4  e3a01000          MOV      r1,#0
;;;1310   {
;;;1311       INT i;
;;;1312   
;;;1313       /* Initial UART_BUFFER_T struct */
;;;1314       for(i = 0; i < UART_NUM ; i++)
001ad8  ea000005          B        |L1.6900|
                  |L1.6876|
;;;1315           UART_DEV[i].bIsUARTInitial = FALSE;
001adc  e3a00000          MOV      r0,#0
001ae0  e0812081          ADD      r2,r1,r1,LSL #1
001ae4  e51f3ccc          LDR      r3,|L1.3616|
001ae8  e0832202          ADD      r2,r3,r2,LSL #4
001aec  e5c2001e          STRB     r0,[r2,#0x1e]
001af0  e2811001          ADD      r1,r1,#1              ;1314
                  |L1.6900|
001af4  e351000b          CMP      r1,#0xb               ;1314
001af8  bafffff7          BLT      |L1.6876|
;;;1316   
;;;1317       for(i = 0; i < UART_NUM ; i++)
001afc  e3a01000          MOV      r1,#0
001b00  ea000005          B        |L1.6940|
                  |L1.6916|
;;;1318           UART_DEV[i].bIsUseUARTTxInt = TRUE;
001b04  e3a00001          MOV      r0,#1
001b08  e0812081          ADD      r2,r1,r1,LSL #1
001b0c  e51f3cf4          LDR      r3,|L1.3616|
001b10  e0832202          ADD      r2,r3,r2,LSL #4
001b14  e5c2001c          STRB     r0,[r2,#0x1c]
001b18  e2811001          ADD      r1,r1,#1              ;1317
                  |L1.6940|
001b1c  e351000b          CMP      r1,#0xb               ;1317
001b20  bafffff7          BLT      |L1.6916|
;;;1319   
;;;1320       for(i = 0; i < UART_NUM ; i++)
001b24  e3a01000          MOV      r1,#0
001b28  ea000005          B        |L1.6980|
                  |L1.6956|
;;;1321           UART_DEV[i].bIsUseUARTRxInt = TRUE;
001b2c  e3a00001          MOV      r0,#1
001b30  e0812081          ADD      r2,r1,r1,LSL #1
001b34  e51f3d1c          LDR      r3,|L1.3616|
001b38  e0832202          ADD      r2,r3,r2,LSL #4
001b3c  e5c2001d          STRB     r0,[r2,#0x1d]
001b40  e2811001          ADD      r1,r1,#1              ;1320
                  |L1.6980|
001b44  e351000b          CMP      r1,#0xb               ;1320
001b48  bafffff7          BLT      |L1.6956|
;;;1322   
;;;1323       for(i = 0; i < UART_NUM ; i++)
001b4c  e3a01000          MOV      r1,#0
001b50  ea000005          B        |L1.7020|
                  |L1.6996|
;;;1324           UART_DEV[i].uRecCnt = 0;
001b54  e3a00000          MOV      r0,#0
001b58  e0812081          ADD      r2,r1,r1,LSL #1
001b5c  e51f3d44          LDR      r3,|L1.3616|
001b60  e0832202          ADD      r2,r3,r2,LSL #4
001b64  e5820028          STR      r0,[r2,#0x28]
001b68  e2811001          ADD      r1,r1,#1              ;1323
                  |L1.7020|
001b6c  e351000b          CMP      r1,#0xb               ;1323
001b70  bafffff7          BLT      |L1.6996|
;;;1325   
;;;1326       return 0;
001b74  e3a00000          MOV      r0,#0
;;;1327   }
001b78  e12fff1e          BX       lr
;;;1328   
                          ENDP

                  uartOpen PROC
;;;1337     */
;;;1338   INT uartOpen(PVOID uart)
001b7c  e92d4070          PUSH     {r4-r6,lr}
;;;1339   {
001b80  e1a06000          MOV      r6,r0
;;;1340       INT nValue = 0;
001b84  e3a05000          MOV      r5,#0
;;;1341       UART_T *dev = (UART_T *) uart;
001b88  e1a04006          MOV      r4,r6
;;;1342   
;;;1343       if((nValue = _uartConfigureUART(uart)) < 0) {
001b8c  e1a00006          MOV      r0,r6
001b90  ebfffffe          BL       _uartConfigureUART
001b94  e2505000          SUBS     r5,r0,#0
001b98  aa00000b          BGE      |L1.7116|
;;;1344           // by sam
;;;1345           sysprintf(" !!! uartOpen error: %d\n", nValue);
001b9c  e1a01005          MOV      r1,r5
001ba0  e28f0f69          ADR      r0,|L1.7500|
001ba4  ebfffffe          BL       sysprintf
;;;1346           
;;;1347           if(nValue != UART_ERR_CHANNEL_INVALID)
001ba8  e3750005          CMN      r5,#5
001bac  0a000004          BEQ      |L1.7108|
;;;1348               UART_DEV[dev->ucUartNo].nErrno = nValue;
001bb0  e5d40008          LDRB     r0,[r4,#8]
001bb4  e0800080          ADD      r0,r0,r0,LSL #1
001bb8  e51f1da0          LDR      r1,|L1.3616|
001bbc  e0810200          ADD      r0,r1,r0,LSL #4
001bc0  e580502c          STR      r5,[r0,#0x2c]
                  |L1.7108|
;;;1349   
;;;1350           return UART_EIO;
001bc4  e59f019c          LDR      r0,|L1.7528|
                  |L1.7112|
;;;1351       } 
;;;1352       else
;;;1353       {
;;;1354           // by sam
;;;1355           if(xuartSemaphore[(uint32_t)dev->ucUartNo] == NULL)
;;;1356               xuartSemaphore[(uint32_t)dev->ucUartNo] = xSemaphoreCreateBinary();
;;;1357   
;;;1358           UART_DEV[dev->ucUartNo].nErrno = 0;
;;;1359       }
;;;1360   
;;;1361       return Successful;
;;;1362   }
001bc8  e8bd8070          POP      {r4-r6,pc}
                  |L1.7116|
001bcc  e5d40008          LDRB     r0,[r4,#8]            ;1355
001bd0  e51f1dac          LDR      r1,|L1.3628|
001bd4  e7910100          LDR      r0,[r1,r0,LSL #2]     ;1355
001bd8  e3500000          CMP      r0,#0                 ;1355
001bdc  1a000006          BNE      |L1.7164|
001be0  e3a02003          MOV      r2,#3                 ;1356
001be4  e3a01000          MOV      r1,#0                 ;1356
001be8  e3a00001          MOV      r0,#1                 ;1356
001bec  ebfffffe          BL       xQueueGenericCreate
001bf0  e5d41008          LDRB     r1,[r4,#8]            ;1356
001bf4  e51f2dd0          LDR      r2,|L1.3628|
001bf8  e7820101          STR      r0,[r2,r1,LSL #2]     ;1356
                  |L1.7164|
001bfc  e3a00000          MOV      r0,#0                 ;1358
001c00  e5d41008          LDRB     r1,[r4,#8]            ;1358
001c04  e0811081          ADD      r1,r1,r1,LSL #1       ;1358
001c08  e51f2df0          LDR      r2,|L1.3616|
001c0c  e0821201          ADD      r1,r2,r1,LSL #4       ;1358
001c10  e581002c          STR      r0,[r1,#0x2c]         ;1358
001c14  e1a00000          MOV      r0,r0                 ;1361
001c18  eaffffea          B        |L1.7112|
;;;1363   
                          ENDP

                  uartWaitReadEvent PROC
;;;1364   //add by sam
;;;1365   BaseType_t uartWaitReadEvent(INT nNum, TickType_t time)
001c1c  e92d4070          PUSH     {r4-r6,lr}
;;;1366   {
001c20  e1a04000          MOV      r4,r0
001c24  e1a05001          MOV      r5,r1
;;;1367       if(xSemaphoreTake(xuartSemaphore[nNum], 0) == pdTRUE)
001c28  e51f1e04          LDR      r1,|L1.3628|
001c2c  e7910104          LDR      r0,[r1,r4,LSL #2]
001c30  e3a03000          MOV      r3,#0
001c34  e1a02003          MOV      r2,r3
001c38  e1a01003          MOV      r1,r3
001c3c  ebfffffe          BL       xQueueGenericReceive
;;;1368       {
;;;1369           
;;;1370       }
;;;1371       else
;;;1372       {//TimeOut;
;;;1373       }
;;;1374   
;;;1375       return xSemaphoreTake(xuartSemaphore[nNum], time);
001c40  e51f1e1c          LDR      r1,|L1.3628|
001c44  e7910104          LDR      r0,[r1,r4,LSL #2]
001c48  e3a03000          MOV      r3,#0
001c4c  e1a02005          MOV      r2,r5
001c50  e1a01003          MOV      r1,r3
001c54  ebfffffe          BL       xQueueGenericReceive
;;;1376   }
001c58  e8bd8070          POP      {r4-r6,pc}
;;;1377   
                          ENDP

                  uartRead PROC
;;;1390     */
;;;1391   INT32 uartRead(INT nNum, PUINT8 pucBuf, UINT32 uLen)
001c5c  e92d41f0          PUSH     {r4-r8,lr}
;;;1392   {
001c60  e1a04000          MOV      r4,r0
001c64  e1a06001          MOV      r6,r1
001c68  e1a05002          MOV      r5,r2
;;;1393       UART_BUFFER_T *dev;
;;;1394       INT32 DataLength;
;;;1395   
;;;1396       //if((nNum < UART0) || (nNum > UART4))
;;;1397       //  return UART_ENODEV;
;;;1398   
;;;1399       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
001c6c  e0840084          ADD      r0,r4,r4,LSL #1
001c70  e51f1e58          LDR      r1,|L1.3616|
001c74  e0817200          ADD      r7,r1,r0,LSL #4
;;;1400   
;;;1401       /* Check UART initial status */
;;;1402       if(dev->bIsUARTInitial == FALSE)
001c78  e5d7001e          LDRB     r0,[r7,#0x1e]
001c7c  e3500000          CMP      r0,#0
001c80  1a000001          BNE      |L1.7308|
;;;1403           return UART_EIO;
001c84  e59f00dc          LDR      r0,|L1.7528|
                  |L1.7304|
;;;1404   
;;;1405       /* Check uLen value */
;;;1406       if((uLen > UARTRXBUFSIZE[nNum]) || (uLen == 0))
;;;1407       {
;;;1408           sysprintf(" !!! uartRead error: uLen = %d, UARTRXBUFSIZE[%d] = %d\n", uLen, nNum, UARTRXBUFSIZE[nNum]);
;;;1409           return UART_EIO;
;;;1410       }
;;;1411   
;;;1412   
;;;1413       DataLength = _uartReadRxBuf(nNum, pucBuf, uLen);
;;;1414       //xSemaphoreGive(xuartSemaphore[nNum]);
;;;1415       return (DataLength);
;;;1416   
;;;1417   }
001c88  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7308|
001c8c  e51f0e78          LDR      r0,|L1.3612|
001c90  e7900104          LDR      r0,[r0,r4,LSL #2]     ;1406
001c94  e1500005          CMP      r0,r5                 ;1406
001c98  3a000001          BCC      |L1.7332|
001c9c  e3550000          CMP      r5,#0                 ;1406
001ca0  1a000007          BNE      |L1.7364|
                  |L1.7332|
001ca4  e51f0e90          LDR      r0,|L1.3612|
001ca8  e7903104          LDR      r3,[r0,r4,LSL #2]     ;1408
001cac  e1a02004          MOV      r2,r4                 ;1408
001cb0  e1a01005          MOV      r1,r5                 ;1408
001cb4  e28f00b0          ADR      r0,|L1.7532|
001cb8  ebfffffe          BL       sysprintf
001cbc  e59f00a4          LDR      r0,|L1.7528|
001cc0  eafffff0          B        |L1.7304|
                  |L1.7364|
001cc4  e1a02005          MOV      r2,r5                 ;1413
001cc8  e1a01006          MOV      r1,r6                 ;1413
001ccc  e1a00004          MOV      r0,r4                 ;1413
001cd0  ebfffffe          BL       _uartReadRxBuf
001cd4  e1a08000          MOV      r8,r0                 ;1413
001cd8  e1a00008          MOV      r0,r8                 ;1415
001cdc  eaffffe9          B        |L1.7304|
                  |L1.7392|
                          DCD      0xb8000a1c
                  |L1.7396|
                          DCD      0xb8000a30
                  |L1.7400|
                          DCD      0xb8000a14
                  |L1.7404|
                          DCD      _uart_cCTSState10
                  |L1.7408|
                          DCD      0xb8000a18
                  |L1.7412|
                          DCD      _uart_cBIIState_10
                  |L1.7416|
                          DCD      uart1ISR
                  |L1.7420|
                          DCD      uart2ISR
                  |L1.7424|
                          DCD      uart3ISR
                  |L1.7428|
                          DCD      uart7ISR
                  |L1.7432|
                          DCD      uart8ISR
                  |L1.7436|
                          DCD      uart9ISR
                  |L1.7440|
                          DCD      _uart_IrDATxReg
                  |L1.7444|
                          DCD      _uart_IrDARxReg
                  |L1.7448|
                          DCD      0xb8000008
                  |L1.7452|
                          DCD      0xb800000c
                  |L1.7456|
                          DCD      0xb8000010
                  |L1.7460|
                          DCD      0xb8000014
                  |L1.7464|
                          DCD      0xb8000018
                  |L1.7468|
                          DCD      0xb800001c
                  |L1.7472|
                          DCD      0xb8000020
                  |L1.7476|
                          DCD      0xb8000024
                  |L1.7480|
                          DCD      0xb8000028
                  |L1.7484|
                          DCD      0xb800002c
                  |L1.7488|
                          DCD      0xb8000030
                  |L1.7492|
                          DCD      0xb8000034
                  |L1.7496|
                          DCD      0xb8000038
                  |L1.7500|
001d4c  20212121          DCB      " !!! uartOpen error: %d\n",0
001d50  20756172
001d54  744f7065
001d58  6e206572
001d5c  726f723a
001d60  2025640a
001d64  00      
001d65  00                DCB      0
001d66  00                DCB      0
001d67  00                DCB      0
                  |L1.7528|
                          DCD      0xffff1703
                  |L1.7532|
001d6c  20212121          DCB      " !!! uartRead error: uLen = %d, UARTRXBUFSIZE[%d] = %d\n"
001d70  20756172
001d74  74526561
001d78  64206572
001d7c  726f723a
001d80  20754c65
001d84  6e203d20
001d88  25642c20
001d8c  55415254
001d90  52584255
001d94  4653495a
001d98  455b2564
001d9c  5d203d20
001da0  25640a  
001da3  00                DCB      0
                          ENDP

                  uartWrite PROC
;;;1431     */
;;;1432   INT32 uartWrite(INT nNum, PUINT8 pucBuf, UINT32 uLen)
001da4  e92d41f0          PUSH     {r4-r8,lr}
;;;1433   {
001da8  e1a07000          MOV      r7,r0
001dac  e1a08001          MOV      r8,r1
001db0  e1a05002          MOV      r5,r2
;;;1434       BOOL bIsTxBufEnough;
;;;1435   
;;;1436       UART_BUFFER_T *dev;
;;;1437   
;;;1438       //if((nNum < UART0) || (nNum > UART4))
;;;1439       //  return UART_ENODEV;
;;;1440   
;;;1441       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
001db4  e0870087          ADD      r0,r7,r7,LSL #1
001db8  e51f1fa0          LDR      r1,|L1.3616|
001dbc  e0814200          ADD      r4,r1,r0,LSL #4
;;;1442       dev->nErrno = 0;
001dc0  e3a00000          MOV      r0,#0
001dc4  e584002c          STR      r0,[r4,#0x2c]
;;;1443   
;;;1444       /* Check UART initial status */
;;;1445       if(dev->bIsUARTInitial == FALSE)
001dc8  e5d4001e          LDRB     r0,[r4,#0x1e]
001dcc  e3500000          CMP      r0,#0
001dd0  1a000001          BNE      |L1.7644|
;;;1446           return UART_EIO;
001dd4  e51f0074          LDR      r0,|L1.7528|
                  |L1.7640|
;;;1447   
;;;1448       /* Check uLen value */
;;;1449       //by sam 2020.10.22
;;;1450       //if((uLen > UARTWRITESIZE) || (uLen == 0))
;;;1451       if(uLen == 0)
;;;1452           return UART_EIO;
;;;1453   
;;;1454       /* Check UART Tx buffer */
;;;1455       if(dev->bIsUseUARTTxInt == TRUE) {
;;;1456           bIsTxBufEnough = _uartCheckTxBufSpace(nNum, dev->uUartTxHead, dev->uUartTxTail, uLen);
;;;1457           if(bIsTxBufEnough == FALSE) {
;;;1458               //sysprintf("Tx buf not enough\n");
;;;1459               dev->nErrno = UART_ERR_TX_BUF_NOT_ENOUGH;
;;;1460               return UART_EIO;
;;;1461           }
;;;1462       }
;;;1463   
;;;1464       /* Move data to UART Tx buffer then transmit */
;;;1465       _uartWriteTxBuf(nNum, pucBuf, uLen);
;;;1466   
;;;1467       return (uLen);
;;;1468   }
001dd8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7644|
001ddc  e3550000          CMP      r5,#0                 ;1451
001de0  1a000001          BNE      |L1.7660|
001de4  e51f0084          LDR      r0,|L1.7528|
001de8  eafffffa          B        |L1.7640|
                  |L1.7660|
001dec  e5d4001c          LDRB     r0,[r4,#0x1c]         ;1455
001df0  e3500001          CMP      r0,#1                 ;1455
001df4  1a00000b          BNE      |L1.7720|
001df8  e5942004          LDR      r2,[r4,#4]            ;1456
001dfc  e5941000          LDR      r1,[r4,#0]            ;1456
001e00  e1a03005          MOV      r3,r5                 ;1456
001e04  e1a00007          MOV      r0,r7                 ;1456
001e08  ebfffffe          BL       _uartCheckTxBufSpace
001e0c  e1a06000          MOV      r6,r0                 ;1456
001e10  e3560000          CMP      r6,#0                 ;1457
001e14  1a000003          BNE      |L1.7720|
001e18  e3e0000a          MVN      r0,#0xa               ;1459
001e1c  e584002c          STR      r0,[r4,#0x2c]         ;1459
001e20  e51f00c0          LDR      r0,|L1.7528|
001e24  eaffffeb          B        |L1.7640|
                  |L1.7720|
001e28  e1a02005          MOV      r2,r5                 ;1465
001e2c  e1a01008          MOV      r1,r8                 ;1465
001e30  e1a00007          MOV      r0,r7                 ;1465
001e34  ebfffffe          BL       _uartWriteTxBuf
001e38  e1a00005          MOV      r0,r5                 ;1467
001e3c  eaffffe5          B        |L1.7640|
;;;1469   
                          ENDP

                  uartIoctl PROC
;;;1485     */
;;;1486   INT uartIoctl(INT nNum, UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
001e40  e92d5ff0          PUSH     {r4-r12,lr}
;;;1487   {
001e44  e1a06000          MOV      r6,r0
001e48  e1a0a001          MOV      r10,r1
001e4c  e1a04002          MOV      r4,r2
001e50  e1a09003          MOV      r9,r3
;;;1488       INT32 retval;
;;;1489       UINT32 uReg;
;;;1490       UINT32 uOffset = nNum * UARTOFFSET;
001e54  e1a05406          LSL      r5,r6,#8
;;;1491   
;;;1492       UART_BUFFER_T *dev;
;;;1493   
;;;1494       if((nNum < UART0) || (nNum > UARTA))
001e58  e3560000          CMP      r6,#0
001e5c  ba000001          BLT      |L1.7784|
001e60  e356000a          CMP      r6,#0xa
001e64  da000001          BLE      |L1.7792|
                  |L1.7784|
;;;1495           return UART_ENODEV;
001e68  e59f0808          LDR      r0,|L1.9848|
                  |L1.7788|
;;;1496   
;;;1497       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
;;;1498   
;;;1499       /* Check UART initial status */
;;;1500       if(dev->bIsUARTInitial == FALSE) {
;;;1501           if((uCmd != UART_IOC_GETERRNO) &&
;;;1502                   (uCmd != UART_IOC_GETUARTREGISTERVALUE))
;;;1503               return UART_EIO;
;;;1504       }
;;;1505   
;;;1506       switch(uCmd) {
;;;1507       case UART_IOC_SETTXMODE:
;;;1508           if(uArg0 == UARTINTMODE)
;;;1509               dev->bIsUseUARTTxInt = TRUE;
;;;1510           else if(uArg0 == UARTPOLLMODE)
;;;1511               dev->bIsUseUARTTxInt = FALSE;
;;;1512           else {
;;;1513               dev->nErrno = UART_ERR_OPERATE_MODE_INVALID;
;;;1514               return UART_EIO;
;;;1515           }
;;;1516   
;;;1517           break;
;;;1518   
;;;1519       case UART_IOC_SETRXMODE:
;;;1520           if(uArg0 == UARTINTMODE) {
;;;1521               dev->bIsUseUARTRxInt = TRUE;
;;;1522               _uartEnableInterrupt(nNum, UART_IER_RDA_IEN_Msk);
;;;1523           } else if(uArg0 == UARTPOLLMODE) {
;;;1524               dev->bIsUseUARTRxInt = FALSE;
;;;1525               _uartDisableInterrupt(nNum, UART_IER_RDA_IEN_Msk);
;;;1526           } else {
;;;1527               dev->nErrno = UART_ERR_OPERATE_MODE_INVALID;
;;;1528               return UART_EIO;
;;;1529           }
;;;1530   
;;;1531           break;
;;;1532   
;;;1533       case UART_IOC_GETRECCHARINFO:  // ..... not test yet
;;;1534           memcpy((PVOID) uArg0, (PVOID) dev, sizeof(struct UART_BUFFER_STRUCT));
;;;1535           break;
;;;1536   
;;;1537       case UART_IOC_SETUARTPARAMETER:  // ..... not test yet
;;;1538           if((retval = _uartConfigureUART((PVOID) uArg0)) < 0) {
;;;1539               dev->nErrno = retval;
;;;1540               return UART_EIO;
;;;1541           }
;;;1542   
;;;1543           break;
;;;1544   
;;;1545       case UART_IOC_PERFORMIrDA:
;;;1546   
;;;1547           if((retval = _uartPerformIrDA(nNum, uArg0, uArg1)) < 0) {
;;;1548               dev->nErrno = retval;
;;;1549               return UART_EIO;
;;;1550           }
;;;1551   
;;;1552           break;
;;;1553   
;;;1554       case UART_IOC_GETUARTREGISTERVALUE:
;;;1555           return (_uartGetRegisterValue(nNum, (PVOID) uArg0));
;;;1556       //break;
;;;1557   
;;;1558       case UART_IOC_GETERRNO:
;;;1559           *(PUINT32)uArg0 = dev->nErrno;
;;;1560           break;
;;;1561   
;;;1562       case UART_IOC_SETMODEMINTERRUPT:
;;;1563   
;;;1564           if(uArg0 == UART_ENABLE_MODEM_INT)
;;;1565               _uartEnableInterrupt(nNum, UART_IER_MODEM_IEN_Msk);
;;;1566           else if(uArg0 == UART_DISABLE_MODEM_INT)
;;;1567               _uartDisableInterrupt(nNum, UART_IER_MODEM_IEN_Msk);
;;;1568           else
;;;1569               return UART_EIO;
;;;1570   
;;;1571           break;
;;;1572   
;;;1573       case UART_IOC_GETCTSSTATE:
;;;1574   
;;;1575           if(nNum == UART1) {
;;;1576               *(PUINT32)uArg0 = _uart_cCTSState1;                        /* CTS state */
;;;1577               _uart_cCTSState1 = 0;
;;;1578           } else if(nNum == UART2) {
;;;1579               *(PUINT32)uArg0 = _uart_cCTSState2;                        /* CTS state */
;;;1580               _uart_cCTSState2 = 0;
;;;1581           } else if(nNum == UART3) {
;;;1582               *(PUINT32)uArg0 = _uart_cCTSState3;                        /* CTS state */
;;;1583               _uart_cCTSState3 = 0;
;;;1584           } else if(nNum == UART4) {
;;;1585               *(PUINT32)uArg0 = _uart_cCTSState4;                        /* CTS state */
;;;1586               _uart_cCTSState4 = 0;
;;;1587           } else if(nNum == UART5) {
;;;1588               *(PUINT32)uArg0 = _uart_cCTSState5;                        /* CTS state */
;;;1589               _uart_cCTSState5 = 0;
;;;1590           } else if(nNum == UART6) {
;;;1591               *(PUINT32)uArg0 = _uart_cCTSState6;                        /* CTS state */
;;;1592               _uart_cCTSState6 = 0;
;;;1593           } else if(nNum == UART7) {
;;;1594               *(PUINT32)uArg0 = _uart_cCTSState7;                        /* CTS state */
;;;1595               _uart_cCTSState7 = 0;
;;;1596           } else if(nNum == UART8) {
;;;1597               *(PUINT32)uArg0 = _uart_cCTSState8;                        /* CTS state */
;;;1598               _uart_cCTSState8 = 0;
;;;1599           } else if(nNum == UART9) {
;;;1600               *(PUINT32)uArg0 = _uart_cCTSState9;                        /* CTS state */
;;;1601               _uart_cCTSState9 = 0;
;;;1602           } else if(nNum == UARTA) {
;;;1603               *(PUINT32)uArg0 = _uart_cCTSState10;                        /* CTS state */
;;;1604               _uart_cCTSState10 = 0;
;;;1605           }
;;;1606   
;;;1607           *(PUINT32)uArg1 = (inpw(REG_UART0_MSR+uOffset) & (1 << 4)) >> 4;  /* get CTS# value */
;;;1608   
;;;1609           break;
;;;1610   
;;;1611       case UART_IOC_SETRTSSIGNAL:
;;;1612   
;;;1613           if(uArg0 == UART_RTS_HIGH)      /* set RTS signal high */
;;;1614               outpw(REG_UART0_MCR+uOffset, inpw(REG_UART0_MCR+uOffset) & ~0x02);
;;;1615           else if(uArg0 == UART_RTS_LOW)  /* set RTS signal low  */
;;;1616               outpw(REG_UART0_MCR+uOffset, inpw(REG_UART0_MCR+uOffset) | 0x02);
;;;1617           else
;;;1618               return UART_EIO;
;;;1619   
;;;1620           break;
;;;1621   
;;;1622       case UART_IOC_SETINTERRUPT:
;;;1623           if(uArg0 == 1)       /* enable interrupt  */
;;;1624               _uartEnableInterrupt(nNum, uArg1);
;;;1625           else if(uArg0 == 0)  /* disable interrupt */
;;;1626               _uartDisableInterrupt(nNum, uArg1);
;;;1627           else
;;;1628               return UART_EIO;
;;;1629   
;;;1630           break;
;;;1631   
;;;1632       case UART_IOC_SETBREAKCONTROL:
;;;1633           uReg = inpw(REG_UART0_LCR + uOffset);
;;;1634           if(uArg0 == 1) {     /* set break contorl bit  */
;;;1635               uReg |= UART_LCR_BCB_Msk;
;;;1636               outpw(REG_UART0_LCR + uOffset, uReg);
;;;1637           } else if(uArg0 == 0) { /* clear break contorl bit */
;;;1638               uReg &= ~UART_LCR_BCB_Msk;
;;;1639               outpw(REG_UART0_LCR + uOffset, uReg);
;;;1640           } else
;;;1641               return UART_EIO;
;;;1642   
;;;1643           break;
;;;1644   
;;;1645       case UART_IOC_GETBIISTATE:
;;;1646           switch(nNum) {
;;;1647           case UART0:
;;;1648               *(PUINT32)uArg0 = _uart_cBIIState_0;
;;;1649               break;
;;;1650           case UART1:
;;;1651               *(PUINT32)uArg0 = _uart_cBIIState_1;
;;;1652               break;
;;;1653           case UART2:
;;;1654               *(PUINT32)uArg0 = _uart_cBIIState_2;
;;;1655               break;
;;;1656           case UART3:
;;;1657               *(PUINT32)uArg0 = _uart_cBIIState_3;
;;;1658               break;
;;;1659           case UART4:
;;;1660               *(PUINT32)uArg0 = _uart_cBIIState_4;
;;;1661               break;
;;;1662           case UART5:
;;;1663               *(PUINT32)uArg0 = _uart_cBIIState_5;
;;;1664               break;
;;;1665           case UART6:
;;;1666               *(PUINT32)uArg0 = _uart_cBIIState_6;
;;;1667               break;
;;;1668           case UART7:
;;;1669               *(PUINT32)uArg0 = _uart_cBIIState_7;
;;;1670               break;
;;;1671           case UART8:
;;;1672               *(PUINT32)uArg0 = _uart_cBIIState_8;
;;;1673               break;
;;;1674           case UART9:
;;;1675               *(PUINT32)uArg0 = _uart_cBIIState_9;
;;;1676               break;
;;;1677           case UARTA:
;;;1678               *(PUINT32)uArg0 = _uart_cBIIState_10;
;;;1679               break;
;;;1680   
;;;1681           default:
;;;1682               break;
;;;1683           }
;;;1684           break;
;;;1685   
;;;1686       /* H/W S/W flow control function */
;;;1687       case UART_IOC_ENABLEHWFLOWCONTROL:
;;;1688   
;;;1689           /* H/W & S/W are alterntive */
;;;1690           if(_uart_cFlowControlMode == SWFLOWCONTROL)
;;;1691               return UART_EIO;
;;;1692   
;;;1693           _uart_cFlowControlMode = HWFLOWCONTROL;
;;;1694   
;;;1695           /* Implement H/W flow control on TX & RX interrupt mode. */
;;;1696           //dev->bIsUseUARTTxInt = TRUE;
;;;1697           //dev->bIsUseUARTRxInt = TRUE;
;;;1698           _uartEnableInterrupt(nNum, UART_IER_RDA_IEN_Msk);
;;;1699   
;;;1700           /*
;;;1701               Set up RTS mechanism.
;;;1702               In uartReceiveChars(), if uRecCnt >= _uart_nMaxRxBuf then set RTS high to stop RX.
;;;1703               In uartReadRxBuf(), if uRecCnt <= _uart_nMinRxBuf then set RTS low to re-start RX.
;;;1704           */
;;;1705           //_uart_nMaxRxBuf = (UARTRXBUFSIZE[nNum] * 3) / 4;
;;;1706           //_uart_nMinRxBuf = UARTRXBUFSIZE[nNum] / 2;
;;;1707           //FDEBUG("max[%d] min[%d]\n", _uart_nMaxRxBuf, _uart_nMinRxBuf);
;;;1708   
;;;1709           /* Set RTS high level trigger */
;;;1710           outpw(REG_UART0_MCR+uOffset, (inpw(REG_UART0_MCR+uOffset) | UART_RTS_IS_HIGH_LEV_TRG) );
;;;1711           /* Set RTS high level trigger */
;;;1712           outpw(REG_UART0_MSR+uOffset, (inpw(REG_UART0_MSR+uOffset) | UART_CTS_IS_HIGH_LEV_TRG) );
;;;1713   
;;;1714           /* Set Auto CTS/RTS */
;;;1715           outpw(REG_UART0_IER+uOffset, inpw(REG_UART0_IER+uOffset) | (0x3 << 12));
;;;1716   
;;;1717           /* Enable MODEM status interrupt */
;;;1718           //_uartEnableInterrupt(nNum, UART_IER_MODEM_IEN_Msk);
;;;1719   
;;;1720           /*
;;;1721               Maintain H/W flow control flag by read Modem Status Register.
;;;1722               If CTS high, stop TX.
;;;1723               If CTS low, start TX.
;;;1724           */
;;;1725           //if( inpw(REG_UART0_MSR+uOffset) & 0x10 )  /* CTS external signal is low  */
;;;1726           //  _uart_cHWTXStopped = 0;       /* TX started                  */
;;;1727           //else                              /* CTS external signal is high */
;;;1728           //  _uart_cHWTXStopped = 1;       /* TX stopped                  */
;;;1729   
;;;1730           /* Set RTS as logic 0, RX re-start */
;;;1731           //outpb(REG_UART0_MCR+uOffset, inpb(REG_UART0_MCR+uOffset) | 0x02);  /* set RTS signal low  */
;;;1732           //_uart_cHWRXStopped = 0;  // RX started
;;;1733           break;
;;;1734   
;;;1735       case UART_IOC_DISABLEHWFLOWCONTROL:
;;;1736   
;;;1737           /* Disable MODEM status interrupt */
;;;1738           _uartDisableInterrupt(nNum, UART_IER_MODEM_IEN_Msk);
;;;1739           _uart_cFlowControlMode = 0;
;;;1740           _uart_cHWTXStopped = 0;
;;;1741           _uart_cHWRXStopped = 0;
;;;1742           break;
;;;1743   
;;;1744       case UART_IOC_FLUSH_TX_BUFFER:
;;;1745           dev->uUartTxTail = 0;
;;;1746           dev->uUartTxHead = 0;
;;;1747           break;
;;;1748   
;;;1749       case UART_IOC_FLUSH_RX_BUFFER:
;;;1750           dev->uUartRxTail = 0;
;;;1751           dev->uUartRxHead = 0;
;;;1752           dev->uRecCnt = 0;
;;;1753           break;
;;;1754   
;;;1755   	case UART_IOC_SET_RS485_MODE:
;;;1756   		outpw((REG_UART0_FUN_SEL+uOffset), 0x3);
;;;1757   		outpw((REG_UART0_MCR+uOffset), 0x0);
;;;1758   		outpw((REG_UART0_LCR+uOffset), (UART_LCR_SPE_Msk | UART_LCR_EPE_Msk | UART_LCR_PBE_Msk | (0x3 << UART_LCR_WLS_Pos)));
;;;1759   		outpw((REG_UART0_ALT_CSR+uOffset), uArg0|(uArg1 << UART_ALT_CSR_ADDR_MATCH_Pos));
;;;1760   		break;
;;;1761   
;;;1762   	case UART_IOC_SEND_RS485_ADDRESS:
;;;1763   		
;;;1764   		while(!((inpw(REG_UART0_FSR + uOffset)) & UART_FSR_TE_FLAG_Msk));
;;;1765   		uReg = inpw(REG_UART0_LCR + uOffset);
;;;1766   		outpw((REG_UART0_LCR+uOffset), (UART_LCR_SPE_Msk | UART_LCR_PBE_Msk | (0x3 << UART_LCR_WLS_Pos)));
;;;1767   		outpw((REG_UART0_THR+uOffset), uArg0);
;;;1768   		while(!((inpw(REG_UART0_FSR + uOffset)) & UART_FSR_TE_FLAG_Msk));
;;;1769   	
;;;1770   		outpw((REG_UART0_LCR+uOffset), uReg);
;;;1771   	
;;;1772   		break;
;;;1773   	
;;;1774   	case UART_IOC_SET_RS485_RXOFF:
;;;1775   		uReg = inpw(REG_UART0_FCR + uOffset);
;;;1776   		if(uArg0 == 1)
;;;1777   			uReg |= UART_FCR_RX_DIS_Msk;
;;;1778   		else
;;;1779   			uReg &= ~UART_FCR_RX_DIS_Msk;
;;;1780   
;;;1781   		outpw((REG_UART0_FCR + uOffset), uReg);
;;;1782   		
;;;1783   		break;
;;;1784   	
;;;1785   	case UART_IOC_SET_ALTCTL_REG:
;;;1786   		
;;;1787   		outpw((REG_UART0_ALT_CSR + uOffset), uArg0);
;;;1788   	
;;;1789   		break;
;;;1790   	
;;;1791   	case UART_IOC_GET_ALTCTL_REG:
;;;1792   		
;;;1793   		*(PUINT32)uArg0 = inpw(REG_UART0_ALT_CSR + uOffset);
;;;1794   	
;;;1795   		break;
;;;1796   	
;;;1797   	case UART_IOC_SET_LIN_MODE:
;;;1798   	
;;;1799   		outpw((REG_UART0_FUN_SEL+uOffset), 0x1); // Select LIN function
;;;1800   	
;;;1801   		/* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;1802   		uReg = inpw(REG_UART0_ALT_CSR + uOffset);
;;;1803   		uReg &= ~(UART_ALT_CSR_LIN_TX_EN_Msk | UART_ALT_CSR_LIN_RX_EN_Msk | UART_ALT_CSR_UA_LIN_BKFL_Msk);
;;;1804   		uReg |= (uArg0 | (uArg1 << UART_ALT_CSR_UA_LIN_BKFL_Pos));
;;;1805   		outpw((REG_UART0_ALT_CSR + uOffset), uReg);
;;;1806   		
;;;1807   		break;
;;;1808   	
;;;1809       default:
;;;1810           return UART_ENOTTY;
;;;1811       }
;;;1812   
;;;1813       return Successful;
;;;1814   }
001e6c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.7792|
001e70  e0860086          ADD      r0,r6,r6,LSL #1       ;1497
001e74  e59f1800          LDR      r1,|L1.9852|
001e78  e0817200          ADD      r7,r1,r0,LSL #4       ;1497
001e7c  e5d7001e          LDRB     r0,[r7,#0x1e]         ;1500
001e80  e3500000          CMP      r0,#0                 ;1500
001e84  1a000005          BNE      |L1.7840|
001e88  e35a0008          CMP      r10,#8                ;1501
001e8c  0a000003          BEQ      |L1.7840|
001e90  e35a0007          CMP      r10,#7                ;1502
001e94  0a000001          BEQ      |L1.7840|
001e98  e51f0138          LDR      r0,|L1.7528|
001e9c  eafffff2          B        |L1.7788|
                  |L1.7840|
001ea0  e35a0020          CMP      r10,#0x20             ;1506
001ea4  308ff10a          ADDCC    pc,pc,r10,LSL #2      ;1506
001ea8  ea0001cf          B        |L1.9708|
001eac  ea0001ce          B        |L1.9708|
001eb0  ea00001d          B        |L1.7980|
001eb4  ea00002c          B        |L1.8044|
001eb8  ea000041          B        |L1.8132|
001ebc  ea000046          B        |L1.8156|
001ec0  ea0001c9          B        |L1.9708|
001ec4  ea00004d          B        |L1.8192|
001ec8  ea000057          B        |L1.8236|
001ecc  ea00005b          B        |L1.8256|
001ed0  ea0001c5          B        |L1.9708|
001ed4  ea0001c4          B        |L1.9708|
001ed8  ea0001c3          B        |L1.9708|
001edc  ea0000df          B        |L1.8800|
001ee0  ea0000ee          B        |L1.8864|
001ee4  ea0000ff          B        |L1.8936|
001ee8  ea000068          B        |L1.8336|
001eec  ea0000c7          B        |L1.8720|
001ef0  ea000056          B        |L1.8272|
001ef4  ea000145          B        |L1.9232|
001ef8  ea000161          B        |L1.9348|
001efc  ea0001ba          B        |L1.9708|
001f00  ea0001b9          B        |L1.9708|
001f04  ea0001b8          B        |L1.9708|
001f08  ea0001b7          B        |L1.9708|
001f0c  ea000168          B        |L1.9396|
001f10  ea00016c          B        |L1.9416|
001f14  ea000171          B        |L1.9440|
001f18  ea00017e          B        |L1.9496|
001f1c  ea000192          B        |L1.9580|
001f20  ea00019c          B        |L1.9624|
001f24  ea00019f          B        |L1.9640|
001f28  ea0001a3          B        |L1.9660|
                  |L1.7980|
001f2c  e1a00000          MOV      r0,r0                 ;1507
001f30  e3540001          CMP      r4,#1                 ;1508
001f34  1a000002          BNE      |L1.8004|
001f38  e3a00001          MOV      r0,#1                 ;1509
001f3c  e5c7001c          STRB     r0,[r7,#0x1c]         ;1509
001f40  ea000008          B        |L1.8040|
                  |L1.8004|
001f44  e3540000          CMP      r4,#0                 ;1510
001f48  1a000002          BNE      |L1.8024|
001f4c  e3a00000          MOV      r0,#0                 ;1511
001f50  e5c7001c          STRB     r0,[r7,#0x1c]         ;1511
001f54  ea000003          B        |L1.8040|
                  |L1.8024|
001f58  e3e0000b          MVN      r0,#0xb               ;1513
001f5c  e587002c          STR      r0,[r7,#0x2c]         ;1513
001f60  e51f0200          LDR      r0,|L1.7528|
001f64  eaffffc0          B        |L1.7788|
                  |L1.8040|
001f68  ea0001a2          B        |L1.9720|
                  |L1.8044|
001f6c  e1a00000          MOV      r0,r0                 ;1519
001f70  e3540001          CMP      r4,#1                 ;1520
001f74  1a000005          BNE      |L1.8080|
001f78  e3a00001          MOV      r0,#1                 ;1521
001f7c  e5c7001d          STRB     r0,[r7,#0x1d]         ;1521
001f80  e3a01001          MOV      r1,#1                 ;1522
001f84  e1a00006          MOV      r0,r6                 ;1522
001f88  ebfffffe          BL       _uartEnableInterrupt
001f8c  ea00000b          B        |L1.8128|
                  |L1.8080|
001f90  e3540000          CMP      r4,#0                 ;1523
001f94  1a000005          BNE      |L1.8112|
001f98  e3a00000          MOV      r0,#0                 ;1524
001f9c  e5c7001d          STRB     r0,[r7,#0x1d]         ;1524
001fa0  e3a01001          MOV      r1,#1                 ;1525
001fa4  e1a00006          MOV      r0,r6                 ;1525
001fa8  ebfffffe          BL       _uartDisableInterrupt
001fac  ea000003          B        |L1.8128|
                  |L1.8112|
001fb0  e3e0000b          MVN      r0,#0xb               ;1527
001fb4  e587002c          STR      r0,[r7,#0x2c]         ;1527
001fb8  e51f0258          LDR      r0,|L1.7528|
001fbc  eaffffaa          B        |L1.7788|
                  |L1.8128|
001fc0  ea00018c          B        |L1.9720|
                  |L1.8132|
001fc4  e1a00000          MOV      r0,r0                 ;1533
001fc8  e3a02030          MOV      r2,#0x30              ;1534
001fcc  e1a01007          MOV      r1,r7                 ;1534
001fd0  e1a00004          MOV      r0,r4                 ;1534
001fd4  ebfffffe          BL       __aeabi_memcpy
001fd8  ea000186          B        |L1.9720|
                  |L1.8156|
001fdc  e1a00000          MOV      r0,r0                 ;1537
001fe0  e1a00004          MOV      r0,r4                 ;1538
001fe4  ebfffffe          BL       _uartConfigureUART
001fe8  e250b000          SUBS     r11,r0,#0             ;1538
001fec  aa000002          BGE      |L1.8188|
001ff0  e587b02c          STR      r11,[r7,#0x2c]        ;1539
001ff4  e51f0294          LDR      r0,|L1.7528|
001ff8  eaffff9b          B        |L1.7788|
                  |L1.8188|
001ffc  ea00017d          B        |L1.9720|
                  |L1.8192|
002000  e1a00000          MOV      r0,r0                 ;1545
002004  e1a02009          MOV      r2,r9                 ;1547
002008  e1a01004          MOV      r1,r4                 ;1547
00200c  e1a00006          MOV      r0,r6                 ;1547
002010  ebfffffe          BL       _uartPerformIrDA
002014  e250b000          SUBS     r11,r0,#0             ;1547
002018  aa000002          BGE      |L1.8232|
00201c  e587b02c          STR      r11,[r7,#0x2c]        ;1548
002020  e51f02c0          LDR      r0,|L1.7528|
002024  eaffff90          B        |L1.7788|
                  |L1.8232|
002028  ea000172          B        |L1.9720|
                  |L1.8236|
00202c  e1a00000          MOV      r0,r0                 ;1554
002030  e1a01004          MOV      r1,r4                 ;1555
002034  e1a00006          MOV      r0,r6                 ;1555
002038  ebfffffe          BL       _uartGetRegisterValue
00203c  eaffff8a          B        |L1.7788|
                  |L1.8256|
002040  e1a00000          MOV      r0,r0                 ;1558
002044  e597002c          LDR      r0,[r7,#0x2c]         ;1559
002048  e5840000          STR      r0,[r4,#0]            ;1559
00204c  ea000169          B        |L1.9720|
                  |L1.8272|
002050  e1a00000          MOV      r0,r0                 ;1562
002054  e3540000          CMP      r4,#0                 ;1564
002058  1a000003          BNE      |L1.8300|
00205c  e3a01008          MOV      r1,#8                 ;1565
002060  e1a00006          MOV      r0,r6                 ;1565
002064  ebfffffe          BL       _uartEnableInterrupt
002068  ea000007          B        |L1.8332|
                  |L1.8300|
00206c  e3540001          CMP      r4,#1                 ;1566
002070  1a000003          BNE      |L1.8324|
002074  e3a01008          MOV      r1,#8                 ;1567
002078  e1a00006          MOV      r0,r6                 ;1567
00207c  ebfffffe          BL       _uartDisableInterrupt
002080  ea000001          B        |L1.8332|
                  |L1.8324|
002084  e51f0324          LDR      r0,|L1.7528|
002088  eaffff77          B        |L1.7788|
                  |L1.8332|
00208c  ea000159          B        |L1.9720|
                  |L1.8336|
002090  e1a00000          MOV      r0,r0                 ;1573
002094  e3560001          CMP      r6,#1                 ;1575
002098  1a000006          BNE      |L1.8376|
00209c  e59f05dc          LDR      r0,|L1.9856|
0020a0  e5d00000          LDRB     r0,[r0,#0]            ;1576  ; _uart_cCTSState1
0020a4  e5840000          STR      r0,[r4,#0]            ;1576
0020a8  e3a00000          MOV      r0,#0                 ;1577
0020ac  e59f15cc          LDR      r1,|L1.9856|
0020b0  e5c10000          STRB     r0,[r1,#0]            ;1577  ; _uart_cCTSState1
0020b4  ea00004f          B        |L1.8696|
                  |L1.8376|
0020b8  e3560002          CMP      r6,#2                 ;1578
0020bc  1a000006          BNE      |L1.8412|
0020c0  e59f05bc          LDR      r0,|L1.9860|
0020c4  e5d00000          LDRB     r0,[r0,#0]            ;1579  ; _uart_cCTSState2
0020c8  e5840000          STR      r0,[r4,#0]            ;1579
0020cc  e3a00000          MOV      r0,#0                 ;1580
0020d0  e59f15ac          LDR      r1,|L1.9860|
0020d4  e5c10000          STRB     r0,[r1,#0]            ;1580  ; _uart_cCTSState2
0020d8  ea000046          B        |L1.8696|
                  |L1.8412|
0020dc  e3560003          CMP      r6,#3                 ;1581
0020e0  1a000006          BNE      |L1.8448|
0020e4  e59f059c          LDR      r0,|L1.9864|
0020e8  e5d00000          LDRB     r0,[r0,#0]            ;1582  ; _uart_cCTSState3
0020ec  e5840000          STR      r0,[r4,#0]            ;1582
0020f0  e3a00000          MOV      r0,#0                 ;1583
0020f4  e59f158c          LDR      r1,|L1.9864|
0020f8  e5c10000          STRB     r0,[r1,#0]            ;1583  ; _uart_cCTSState3
0020fc  ea00003d          B        |L1.8696|
                  |L1.8448|
002100  e3560004          CMP      r6,#4                 ;1584
002104  1a000006          BNE      |L1.8484|
002108  e59f057c          LDR      r0,|L1.9868|
00210c  e5d00000          LDRB     r0,[r0,#0]            ;1585  ; _uart_cCTSState4
002110  e5840000          STR      r0,[r4,#0]            ;1585
002114  e3a00000          MOV      r0,#0                 ;1586
002118  e59f156c          LDR      r1,|L1.9868|
00211c  e5c10000          STRB     r0,[r1,#0]            ;1586  ; _uart_cCTSState4
002120  ea000034          B        |L1.8696|
                  |L1.8484|
002124  e3560005          CMP      r6,#5                 ;1587
002128  1a000006          BNE      |L1.8520|
00212c  e59f055c          LDR      r0,|L1.9872|
002130  e5d00000          LDRB     r0,[r0,#0]            ;1588  ; _uart_cCTSState5
002134  e5840000          STR      r0,[r4,#0]            ;1588
002138  e3a00000          MOV      r0,#0                 ;1589
00213c  e59f154c          LDR      r1,|L1.9872|
002140  e5c10000          STRB     r0,[r1,#0]            ;1589  ; _uart_cCTSState5
002144  ea00002b          B        |L1.8696|
                  |L1.8520|
002148  e3560006          CMP      r6,#6                 ;1590
00214c  1a000006          BNE      |L1.8556|
002150  e59f053c          LDR      r0,|L1.9876|
002154  e5d00000          LDRB     r0,[r0,#0]            ;1591  ; _uart_cCTSState6
002158  e5840000          STR      r0,[r4,#0]            ;1591
00215c  e3a00000          MOV      r0,#0                 ;1592
002160  e59f152c          LDR      r1,|L1.9876|
002164  e5c10000          STRB     r0,[r1,#0]            ;1592  ; _uart_cCTSState6
002168  ea000022          B        |L1.8696|
                  |L1.8556|
00216c  e3560007          CMP      r6,#7                 ;1593
002170  1a000006          BNE      |L1.8592|
002174  e59f051c          LDR      r0,|L1.9880|
002178  e5d00000          LDRB     r0,[r0,#0]            ;1594  ; _uart_cCTSState7
00217c  e5840000          STR      r0,[r4,#0]            ;1594
002180  e3a00000          MOV      r0,#0                 ;1595
002184  e59f150c          LDR      r1,|L1.9880|
002188  e5c10000          STRB     r0,[r1,#0]            ;1595  ; _uart_cCTSState7
00218c  ea000019          B        |L1.8696|
                  |L1.8592|
002190  e3560008          CMP      r6,#8                 ;1596
002194  1a000006          BNE      |L1.8628|
002198  e59f04fc          LDR      r0,|L1.9884|
00219c  e5d00000          LDRB     r0,[r0,#0]            ;1597  ; _uart_cCTSState8
0021a0  e5840000          STR      r0,[r4,#0]            ;1597
0021a4  e3a00000          MOV      r0,#0                 ;1598
0021a8  e59f14ec          LDR      r1,|L1.9884|
0021ac  e5c10000          STRB     r0,[r1,#0]            ;1598  ; _uart_cCTSState8
0021b0  ea000010          B        |L1.8696|
                  |L1.8628|
0021b4  e3560009          CMP      r6,#9                 ;1599
0021b8  1a000006          BNE      |L1.8664|
0021bc  e59f04dc          LDR      r0,|L1.9888|
0021c0  e5d00000          LDRB     r0,[r0,#0]            ;1600  ; _uart_cCTSState9
0021c4  e5840000          STR      r0,[r4,#0]            ;1600
0021c8  e3a00000          MOV      r0,#0                 ;1601
0021cc  e59f14cc          LDR      r1,|L1.9888|
0021d0  e5c10000          STRB     r0,[r1,#0]            ;1601  ; _uart_cCTSState9
0021d4  ea000007          B        |L1.8696|
                  |L1.8664|
0021d8  e356000a          CMP      r6,#0xa               ;1602
0021dc  1a000005          BNE      |L1.8696|
0021e0  e51f04fc          LDR      r0,|L1.7404|
0021e4  e5d00000          LDRB     r0,[r0,#0]            ;1603  ; _uart_cCTSState10
0021e8  e5840000          STR      r0,[r4,#0]            ;1603
0021ec  e3a00000          MOV      r0,#0                 ;1604
0021f0  e51f150c          LDR      r1,|L1.7404|
0021f4  e5c10000          STRB     r0,[r1,#0]            ;1604  ; _uart_cCTSState10
                  |L1.8696|
0021f8  e285032e          ADD      r0,r5,#0xb8000000     ;1607
0021fc  e5900014          LDR      r0,[r0,#0x14]         ;1607
002200  e2000010          AND      r0,r0,#0x10           ;1607
002204  e1a00220          LSR      r0,r0,#4              ;1607
002208  e5890000          STR      r0,[r9,#0]            ;1607
00220c  ea0000f9          B        |L1.9720|
                  |L1.8720|
002210  e1a00000          MOV      r0,r0                 ;1611
002214  e3540001          CMP      r4,#1                 ;1613
002218  1a000005          BNE      |L1.8756|
00221c  e285032e          ADD      r0,r5,#0xb8000000     ;1614
002220  e5900010          LDR      r0,[r0,#0x10]         ;1614
002224  e3c00002          BIC      r0,r0,#2              ;1614
002228  e285132e          ADD      r1,r5,#0xb8000000     ;1614
00222c  e5810010          STR      r0,[r1,#0x10]         ;1614
002230  ea000009          B        |L1.8796|
                  |L1.8756|
002234  e3540000          CMP      r4,#0                 ;1615
002238  1a000005          BNE      |L1.8788|
00223c  e285032e          ADD      r0,r5,#0xb8000000     ;1616
002240  e5900010          LDR      r0,[r0,#0x10]         ;1616
002244  e3800002          ORR      r0,r0,#2              ;1616
002248  e285132e          ADD      r1,r5,#0xb8000000     ;1616
00224c  e5810010          STR      r0,[r1,#0x10]         ;1616
002250  ea000001          B        |L1.8796|
                  |L1.8788|
002254  e51f04f4          LDR      r0,|L1.7528|
002258  eaffff03          B        |L1.7788|
                  |L1.8796|
00225c  ea0000e5          B        |L1.9720|
                  |L1.8800|
002260  e1a00000          MOV      r0,r0                 ;1622
002264  e3540001          CMP      r4,#1                 ;1623
002268  1a000003          BNE      |L1.8828|
00226c  e1a01009          MOV      r1,r9                 ;1624
002270  e1a00006          MOV      r0,r6                 ;1624
002274  ebfffffe          BL       _uartEnableInterrupt
002278  ea000007          B        |L1.8860|
                  |L1.8828|
00227c  e3540000          CMP      r4,#0                 ;1625
002280  1a000003          BNE      |L1.8852|
002284  e1a01009          MOV      r1,r9                 ;1626
002288  e1a00006          MOV      r0,r6                 ;1626
00228c  ebfffffe          BL       _uartDisableInterrupt
002290  ea000001          B        |L1.8860|
                  |L1.8852|
002294  e51f0534          LDR      r0,|L1.7528|
002298  eafffef3          B        |L1.7788|
                  |L1.8860|
00229c  ea0000d5          B        |L1.9720|
                  |L1.8864|
0022a0  e1a00000          MOV      r0,r0                 ;1632
0022a4  e285032e          ADD      r0,r5,#0xb8000000     ;1633
0022a8  e590800c          LDR      r8,[r0,#0xc]          ;1633
0022ac  e3540001          CMP      r4,#1                 ;1634
0022b0  1a000003          BNE      |L1.8900|
0022b4  e3888040          ORR      r8,r8,#0x40           ;1635
0022b8  e285032e          ADD      r0,r5,#0xb8000000     ;1636
0022bc  e580800c          STR      r8,[r0,#0xc]          ;1636
0022c0  ea000007          B        |L1.8932|
                  |L1.8900|
0022c4  e3540000          CMP      r4,#0                 ;1637
0022c8  1a000003          BNE      |L1.8924|
0022cc  e3c88040          BIC      r8,r8,#0x40           ;1638
0022d0  e285032e          ADD      r0,r5,#0xb8000000     ;1639
0022d4  e580800c          STR      r8,[r0,#0xc]          ;1639
0022d8  ea000001          B        |L1.8932|
                  |L1.8924|
0022dc  e51f057c          LDR      r0,|L1.7528|
0022e0  eafffee1          B        |L1.7788|
                  |L1.8932|
0022e4  ea0000c3          B        |L1.9720|
                  |L1.8936|
0022e8  e1a00000          MOV      r0,r0                 ;1645
0022ec  e356000b          CMP      r6,#0xb               ;1646
0022f0  308ff106          ADDCC    pc,pc,r6,LSL #2       ;1646
0022f4  ea000041          B        |L1.9216|
0022f8  ea000009          B        |L1.8996|
0022fc  ea00000d          B        |L1.9016|
002300  ea000011          B        |L1.9036|
002304  ea000015          B        |L1.9056|
002308  ea000019          B        |L1.9076|
00230c  ea00001d          B        |L1.9096|
002310  ea000021          B        |L1.9116|
002314  ea000025          B        |L1.9136|
002318  ea000029          B        |L1.9156|
00231c  ea00002d          B        |L1.9176|
002320  ea000031          B        |L1.9196|
                  |L1.8996|
002324  e1a00000          MOV      r0,r0                 ;1647
002328  e59f0374          LDR      r0,|L1.9892|
00232c  e5d00000          LDRB     r0,[r0,#0]            ;1648  ; _uart_cBIIState_0
002330  e5840000          STR      r0,[r4,#0]            ;1648
002334  ea000033          B        |L1.9224|
                  |L1.9016|
002338  e1a00000          MOV      r0,r0                 ;1650
00233c  e59f0364          LDR      r0,|L1.9896|
002340  e5d00000          LDRB     r0,[r0,#0]            ;1651  ; _uart_cBIIState_1
002344  e5840000          STR      r0,[r4,#0]            ;1651
002348  ea00002e          B        |L1.9224|
                  |L1.9036|
00234c  e1a00000          MOV      r0,r0                 ;1653
002350  e59f0354          LDR      r0,|L1.9900|
002354  e5d00000          LDRB     r0,[r0,#0]            ;1654  ; _uart_cBIIState_2
002358  e5840000          STR      r0,[r4,#0]            ;1654
00235c  ea000029          B        |L1.9224|
                  |L1.9056|
002360  e1a00000          MOV      r0,r0                 ;1656
002364  e59f0344          LDR      r0,|L1.9904|
002368  e5d00000          LDRB     r0,[r0,#0]            ;1657  ; _uart_cBIIState_3
00236c  e5840000          STR      r0,[r4,#0]            ;1657
002370  ea000024          B        |L1.9224|
                  |L1.9076|
002374  e1a00000          MOV      r0,r0                 ;1659
002378  e59f0334          LDR      r0,|L1.9908|
00237c  e5d00000          LDRB     r0,[r0,#0]            ;1660  ; _uart_cBIIState_4
002380  e5840000          STR      r0,[r4,#0]            ;1660
002384  ea00001f          B        |L1.9224|
                  |L1.9096|
002388  e1a00000          MOV      r0,r0                 ;1662
00238c  e59f0324          LDR      r0,|L1.9912|
002390  e5d00000          LDRB     r0,[r0,#0]            ;1663  ; _uart_cBIIState_5
002394  e5840000          STR      r0,[r4,#0]            ;1663
002398  ea00001a          B        |L1.9224|
                  |L1.9116|
00239c  e1a00000          MOV      r0,r0                 ;1665
0023a0  e59f0314          LDR      r0,|L1.9916|
0023a4  e5d00000          LDRB     r0,[r0,#0]            ;1666  ; _uart_cBIIState_6
0023a8  e5840000          STR      r0,[r4,#0]            ;1666
0023ac  ea000015          B        |L1.9224|
                  |L1.9136|
0023b0  e1a00000          MOV      r0,r0                 ;1668
0023b4  e59f0304          LDR      r0,|L1.9920|
0023b8  e5d00000          LDRB     r0,[r0,#0]            ;1669  ; _uart_cBIIState_7
0023bc  e5840000          STR      r0,[r4,#0]            ;1669
0023c0  ea000010          B        |L1.9224|
                  |L1.9156|
0023c4  e1a00000          MOV      r0,r0                 ;1671
0023c8  e59f02f4          LDR      r0,|L1.9924|
0023cc  e5d00000          LDRB     r0,[r0,#0]            ;1672  ; _uart_cBIIState_8
0023d0  e5840000          STR      r0,[r4,#0]            ;1672
0023d4  ea00000b          B        |L1.9224|
                  |L1.9176|
0023d8  e1a00000          MOV      r0,r0                 ;1674
0023dc  e59f02e4          LDR      r0,|L1.9928|
0023e0  e5d00000          LDRB     r0,[r0,#0]            ;1675  ; _uart_cBIIState_9
0023e4  e5840000          STR      r0,[r4,#0]            ;1675
0023e8  ea000006          B        |L1.9224|
                  |L1.9196|
0023ec  e1a00000          MOV      r0,r0                 ;1677
0023f0  e51f0704          LDR      r0,|L1.7412|
0023f4  e5d00000          LDRB     r0,[r0,#0]            ;1678  ; _uart_cBIIState_10
0023f8  e5840000          STR      r0,[r4,#0]            ;1678
0023fc  ea000001          B        |L1.9224|
                  |L1.9216|
002400  e1a00000          MOV      r0,r0                 ;1681
002404  e1a00000          MOV      r0,r0                 ;1682
                  |L1.9224|
002408  e1a00000          MOV      r0,r0                 ;1649
00240c  ea000079          B        |L1.9720|
                  |L1.9232|
002410  e1a00000          MOV      r0,r0                 ;1687
002414  e59f02b0          LDR      r0,|L1.9932|
002418  e5d00000          LDRB     r0,[r0,#0]            ;1690  ; _uart_cFlowControlMode
00241c  e3500002          CMP      r0,#2                 ;1690
002420  1a000001          BNE      |L1.9260|
002424  e51f06c4          LDR      r0,|L1.7528|
002428  eafffe8f          B        |L1.7788|
                  |L1.9260|
00242c  e3a00001          MOV      r0,#1                 ;1693
002430  e59f1294          LDR      r1,|L1.9932|
002434  e5c10000          STRB     r0,[r1,#0]            ;1693  ; _uart_cFlowControlMode
002438  e3a01001          MOV      r1,#1                 ;1698
00243c  e1a00006          MOV      r0,r6                 ;1698
002440  ebfffffe          BL       _uartEnableInterrupt
002444  e285032e          ADD      r0,r5,#0xb8000000     ;1710
002448  e5900010          LDR      r0,[r0,#0x10]         ;1710
00244c  e3800c02          ORR      r0,r0,#0x200          ;1710
002450  e285132e          ADD      r1,r5,#0xb8000000     ;1710
002454  e5810010          STR      r0,[r1,#0x10]         ;1710
002458  e285032e          ADD      r0,r5,#0xb8000000     ;1712
00245c  e5900014          LDR      r0,[r0,#0x14]         ;1712
002460  e3800c01          ORR      r0,r0,#0x100          ;1712
002464  e285132e          ADD      r1,r5,#0xb8000000     ;1712
002468  e5810014          STR      r0,[r1,#0x14]         ;1712
00246c  e285032e          ADD      r0,r5,#0xb8000000     ;1715
002470  e5900004          LDR      r0,[r0,#4]            ;1715
002474  e3800a03          ORR      r0,r0,#0x3000         ;1715
002478  e285132e          ADD      r1,r5,#0xb8000000     ;1715
00247c  e5810004          STR      r0,[r1,#4]            ;1715
002480  ea00005c          B        |L1.9720|
                  |L1.9348|
002484  e1a00000          MOV      r0,r0                 ;1735
002488  e3a01008          MOV      r1,#8                 ;1738
00248c  e1a00006          MOV      r0,r6                 ;1738
002490  ebfffffe          BL       _uartDisableInterrupt
002494  e3a00000          MOV      r0,#0                 ;1739
002498  e59f122c          LDR      r1,|L1.9932|
00249c  e5c10000          STRB     r0,[r1,#0]            ;1739  ; _uart_cFlowControlMode
0024a0  e59f1228          LDR      r1,|L1.9936|
0024a4  e5c10000          STRB     r0,[r1,#0]            ;1740  ; _uart_cHWTXStopped
0024a8  e59f1224          LDR      r1,|L1.9940|
0024ac  e5c10000          STRB     r0,[r1,#0]            ;1741  ; _uart_cHWRXStopped
0024b0  ea000050          B        |L1.9720|
                  |L1.9396|
0024b4  e1a00000          MOV      r0,r0                 ;1744
0024b8  e3a00000          MOV      r0,#0                 ;1745
0024bc  e5870004          STR      r0,[r7,#4]            ;1745
0024c0  e5870000          STR      r0,[r7,#0]            ;1746
0024c4  ea00004b          B        |L1.9720|
                  |L1.9416|
0024c8  e1a00000          MOV      r0,r0                 ;1749
0024cc  e3a00000          MOV      r0,#0                 ;1750
0024d0  e587000c          STR      r0,[r7,#0xc]          ;1750
0024d4  e5870008          STR      r0,[r7,#8]            ;1751
0024d8  e5870028          STR      r0,[r7,#0x28]         ;1752
0024dc  ea000045          B        |L1.9720|
                  |L1.9440|
0024e0  e1a00000          MOV      r0,r0                 ;1755
0024e4  e3a00003          MOV      r0,#3                 ;1756
0024e8  e285132e          ADD      r1,r5,#0xb8000000     ;1756
0024ec  e5810030          STR      r0,[r1,#0x30]         ;1756
0024f0  e3a00000          MOV      r0,#0                 ;1757
0024f4  e285132e          ADD      r1,r5,#0xb8000000     ;1757
0024f8  e5810010          STR      r0,[r1,#0x10]         ;1757
0024fc  e3a0003b          MOV      r0,#0x3b              ;1758
002500  e285132e          ADD      r1,r5,#0xb8000000     ;1758
002504  e581000c          STR      r0,[r1,#0xc]          ;1758
002508  e1840c09          ORR      r0,r4,r9,LSL #24      ;1759
00250c  e285132e          ADD      r1,r5,#0xb8000000     ;1759
002510  e581002c          STR      r0,[r1,#0x2c]         ;1759
002514  ea000037          B        |L1.9720|
                  |L1.9496|
002518  e1a00000          MOV      r0,r0                 ;1762
00251c  e1a00000          MOV      r0,r0                 ;1764
                  |L1.9504|
002520  e285032e          ADD      r0,r5,#0xb8000000     ;1764
002524  e5900018          LDR      r0,[r0,#0x18]         ;1764
002528  e3100201          TST      r0,#0x10000000        ;1764
00252c  0afffffb          BEQ      |L1.9504|
002530  e285032e          ADD      r0,r5,#0xb8000000     ;1765
002534  e590800c          LDR      r8,[r0,#0xc]          ;1765
002538  e3a0002b          MOV      r0,#0x2b              ;1766
00253c  e285132e          ADD      r1,r5,#0xb8000000     ;1766
002540  e581000c          STR      r0,[r1,#0xc]          ;1766
002544  e285032e          ADD      r0,r5,#0xb8000000     ;1767
002548  e5804000          STR      r4,[r0,#0]            ;1767
00254c  e1a00000          MOV      r0,r0                 ;1768
                  |L1.9552|
002550  e285032e          ADD      r0,r5,#0xb8000000     ;1768
002554  e5900018          LDR      r0,[r0,#0x18]         ;1768
002558  e3100201          TST      r0,#0x10000000        ;1768
00255c  0afffffb          BEQ      |L1.9552|
002560  e285032e          ADD      r0,r5,#0xb8000000     ;1770
002564  e580800c          STR      r8,[r0,#0xc]          ;1770
002568  ea000022          B        |L1.9720|
                  |L1.9580|
00256c  e1a00000          MOV      r0,r0                 ;1774
002570  e285032e          ADD      r0,r5,#0xb8000000     ;1775
002574  e5908008          LDR      r8,[r0,#8]            ;1775
002578  e3540001          CMP      r4,#1                 ;1776
00257c  1a000001          BNE      |L1.9608|
002580  e3888c01          ORR      r8,r8,#0x100          ;1777
002584  ea000000          B        |L1.9612|
                  |L1.9608|
002588  e3c88c01          BIC      r8,r8,#0x100          ;1779
                  |L1.9612|
00258c  e285032e          ADD      r0,r5,#0xb8000000     ;1781
002590  e5808008          STR      r8,[r0,#8]            ;1781
002594  ea000017          B        |L1.9720|
                  |L1.9624|
002598  e1a00000          MOV      r0,r0                 ;1785
00259c  e285032e          ADD      r0,r5,#0xb8000000     ;1787
0025a0  e580402c          STR      r4,[r0,#0x2c]         ;1787
0025a4  ea000013          B        |L1.9720|
                  |L1.9640|
0025a8  e1a00000          MOV      r0,r0                 ;1791
0025ac  e285032e          ADD      r0,r5,#0xb8000000     ;1793
0025b0  e590002c          LDR      r0,[r0,#0x2c]         ;1793
0025b4  e5840000          STR      r0,[r4,#0]            ;1793
0025b8  ea00000e          B        |L1.9720|
                  |L1.9660|
0025bc  e1a00000          MOV      r0,r0                 ;1797
0025c0  e3a00001          MOV      r0,#1                 ;1799
0025c4  e285132e          ADD      r1,r5,#0xb8000000     ;1799
0025c8  e5810030          STR      r0,[r1,#0x30]         ;1799
0025cc  e285032e          ADD      r0,r5,#0xb8000000     ;1802
0025d0  e590802c          LDR      r8,[r0,#0x2c]         ;1802
0025d4  e3c880cf          BIC      r8,r8,#0xcf           ;1803
0025d8  e1840009          ORR      r0,r4,r9              ;1804
0025dc  e1888000          ORR      r8,r8,r0              ;1804
0025e0  e285032e          ADD      r0,r5,#0xb8000000     ;1805
0025e4  e580802c          STR      r8,[r0,#0x2c]         ;1805
0025e8  ea000002          B        |L1.9720|
                  |L1.9708|
0025ec  e1a00000          MOV      r0,r0                 ;1809
0025f0  e59f00e0          LDR      r0,|L1.9944|
0025f4  eafffe1c          B        |L1.7788|
                  |L1.9720|
0025f8  e1a00000          MOV      r0,r0                 ;1517
0025fc  e3a00000          MOV      r0,#0                 ;1813
002600  eafffe19          B        |L1.7788|
;;;1815   
                          ENDP

                  uartRelease PROC
;;;1825     */
;;;1826   INT32 uartRelease(INT nNum)
002604  e92d4070          PUSH     {r4-r6,lr}
;;;1827   {
002608  e1a05000          MOV      r5,r0
;;;1828       UART_BUFFER_T *dev;
;;;1829   
;;;1830       if((nNum < UART0) || (nNum > UARTA))
00260c  e3550000          CMP      r5,#0
002610  ba000001          BLT      |L1.9756|
002614  e355000a          CMP      r5,#0xa
002618  da000001          BLE      |L1.9764|
                  |L1.9756|
;;;1831           return UART_ENODEV;
00261c  e59f0054          LDR      r0,|L1.9848|
                  |L1.9760|
;;;1832   
;;;1833       dev = (UART_BUFFER_T *) &UART_DEV[nNum];
;;;1834   
;;;1835       /* Check UART initial status */
;;;1836       if(dev->bIsUARTInitial == FALSE)
;;;1837           return UART_EIO;
;;;1838   
;;;1839       /* Disable all interrupt of the specific UART */
;;;1840       _uartDisableInterrupt(nNum, DISABLEALLIER);
;;;1841   
;;;1842       /* Free memory */
;;;1843       free(dev->pucUartTxBuf);
;;;1844       free(dev->pucUartRxBuf);
;;;1845       free(dev->pucUARTFlag);
;;;1846   
;;;1847       /* Initial parameter */
;;;1848       dev->bIsUARTInitial = FALSE;  /* it's important */
;;;1849   
;;;1850       return Successful;
;;;1851   }
002620  e8bd8070          POP      {r4-r6,pc}
                  |L1.9764|
002624  e0850085          ADD      r0,r5,r5,LSL #1       ;1833
002628  e59f104c          LDR      r1,|L1.9852|
00262c  e0814200          ADD      r4,r1,r0,LSL #4       ;1833
002630  e5d4001e          LDRB     r0,[r4,#0x1e]         ;1836
002634  e3500000          CMP      r0,#0                 ;1836
002638  1a000001          BNE      |L1.9796|
00263c  e51f08dc          LDR      r0,|L1.7528|
002640  eafffff6          B        |L1.9760|
                  |L1.9796|
002644  e3a01000          MOV      r1,#0                 ;1840
002648  e1a00005          MOV      r0,r5                 ;1840
00264c  ebfffffe          BL       _uartDisableInterrupt
002650  e5940010          LDR      r0,[r4,#0x10]         ;1843
002654  ebfffffe          BL       vPortFree
002658  e5940014          LDR      r0,[r4,#0x14]         ;1844
00265c  ebfffffe          BL       vPortFree
002660  e5940020          LDR      r0,[r4,#0x20]         ;1845
002664  ebfffffe          BL       vPortFree
002668  e3a00000          MOV      r0,#0                 ;1848
00266c  e5c4001e          STRB     r0,[r4,#0x1e]         ;1848
002670  e1a00000          MOV      r0,r0                 ;1850
002674  eaffffe9          B        |L1.9760|
;;;1852   
                          ENDP

                  |L1.9848|
                          DCD      0xffff1702
                  |L1.9852|
                          DCD      UART_DEV
                  |L1.9856|
                          DCD      _uart_cCTSState1
                  |L1.9860|
                          DCD      _uart_cCTSState2
                  |L1.9864|
                          DCD      _uart_cCTSState3
                  |L1.9868|
                          DCD      _uart_cCTSState4
                  |L1.9872|
                          DCD      _uart_cCTSState5
                  |L1.9876|
                          DCD      _uart_cCTSState6
                  |L1.9880|
                          DCD      _uart_cCTSState7
                  |L1.9884|
                          DCD      _uart_cCTSState8
                  |L1.9888|
                          DCD      _uart_cCTSState9
                  |L1.9892|
                          DCD      _uart_cBIIState_0
                  |L1.9896|
                          DCD      _uart_cBIIState_1
                  |L1.9900|
                          DCD      _uart_cBIIState_2
                  |L1.9904|
                          DCD      _uart_cBIIState_3
                  |L1.9908|
                          DCD      _uart_cBIIState_4
                  |L1.9912|
                          DCD      _uart_cBIIState_5
                  |L1.9916|
                          DCD      _uart_cBIIState_6
                  |L1.9920|
                          DCD      _uart_cBIIState_7
                  |L1.9924|
                          DCD      _uart_cBIIState_8
                  |L1.9928|
                          DCD      _uart_cBIIState_9
                  |L1.9932|
                          DCD      _uart_cFlowControlMode
                  |L1.9936|
                          DCD      _uart_cHWTXStopped
                  |L1.9940|
                          DCD      _uart_cHWRXStopped
                  |L1.9944|
                          DCD      0xffff1701

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xuartSemaphore
                          %        44
                  UART_DEV
                          %        528

                          AREA ||.data||, DATA, ALIGN=2

                  UARTTXBUFSIZE
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00000040
                  UARTRXBUFSIZE
                          DCD      0x00000400
                          DCD      0x00000040
                          DCD      0x00004000
                          DCD      0x00020000
                          DCD      0x00020000
                          DCD      0x00000040
                          DCD      0x00000040
                          DCD      0x00020000
                          DCD      0x00000400
                          DCD      0x00000040
                          DCD      0x00004000
                  _uart_IrDATxReg
                          DCD      0x00000042
                  _uart_IrDARxReg
                          DCD      0x00000040
                  _uart_cDSRState0
000060  00                DCB      0x00
                  _uart_cDSRState1
000061  00                DCB      0x00
                  _uart_cDSRState2
000062  00                DCB      0x00
                  _uart_cDSRState3
000063  00                DCB      0x00
                  _uart_cDSRState4
000064  00                DCB      0x00
                  _uart_cDSRState5
000065  00                DCB      0x00
                  _uart_cDSRState6
000066  00                DCB      0x00
                  _uart_cDSRState7
000067  00                DCB      0x00
                  _uart_cDSRState8
000068  00                DCB      0x00
                  _uart_cDSRState9
000069  00                DCB      0x00
                  _uart_cDSRState10
00006a  00                DCB      0x00
                  _uart_cBIIState_0
00006b  00                DCB      0x00
                  _uart_cBIIState_1
00006c  00                DCB      0x00
                  _uart_cBIIState_2
00006d  00                DCB      0x00
                  _uart_cBIIState_3
00006e  00                DCB      0x00
                  _uart_cBIIState_4
00006f  00                DCB      0x00
                  _uart_cBIIState_5
000070  00                DCB      0x00
                  _uart_cBIIState_6
000071  00                DCB      0x00
                  _uart_cBIIState_7
000072  00                DCB      0x00
                  _uart_cBIIState_8
000073  00                DCB      0x00
                  _uart_cBIIState_9
000074  00                DCB      0x00
                  _uart_cBIIState_10
000075  00                DCB      0x00
                  _uart_cCTSState0
000076  00                DCB      0x00
                  _uart_cCTSState1
000077  00                DCB      0x00
                  _uart_cCTSState2
000078  00                DCB      0x00
                  _uart_cCTSState3
000079  00                DCB      0x00
                  _uart_cCTSState4
00007a  00                DCB      0x00
                  _uart_cCTSState5
00007b  00                DCB      0x00
                  _uart_cCTSState6
00007c  00                DCB      0x00
                  _uart_cCTSState7
00007d  00                DCB      0x00
                  _uart_cCTSState8
00007e  00                DCB      0x00
                  _uart_cCTSState9
00007f  00                DCB      0x00
                  _uart_cCTSState10
000080  00                DCB      0x00
                  _uart_cFlowControlMode
000081  00                DCB      0x00
                  _uart_cHWTXStopped
000082  00                DCB      0x00
                  _uart_cHWRXStopped
000083  00                DCB      0x00
                  _uart_cSWTXStopped
000084  00                DCB      0x00
                  _uart_cSWRXStopped
000085  00                DCB      0x00
