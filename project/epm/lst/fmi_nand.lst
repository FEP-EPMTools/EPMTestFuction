L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c"
N/**************************************************************************//**
N * @file     fmi_nand.c
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 15/05/28 5:17p $
N * @brief    NUC970 FMI NAND driver source file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c" 2
N#include "nand.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\nand.h" 1
N/*
N * (C) Copyright 2005
N * 2N Telekomunikace, a.s. <www.2n.cz>
N * Ladislav Michl <michl@2n.cz>
N *
N * See file CREDITS for list of people who contributed to this
N * project.
N *
N * This program is free software; you can redistribute it and/or
N * modify it under the terms of the GNU General Public License
N * version 2 as published by the Free Software Foundation.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
N * MA 02111-1307 USA
N */
N
N#ifndef _NAND_H_
N#define _NAND_H_
N
N#include <config.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\config.h" 1
N/*
N * Copyright 2009 Freescale Semiconductor, Inc.
N *
N * This program is free software; you can redistribute it and/or
N * modify it under the terms of the GNU General Public License as
N * published by the Free Software Foundation; either version 2 of
N * the License, or (at your option) any later version.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
N * MA 02111-1307 USA
N *
N */
N
N#ifndef _ASM_CONFIG_H_
N#define _ASM_CONFIG_H_
N
N#define CONFIG_LMB
N#define CONFIG_SYS_BOOT_RAMDISK_HIGH
N#endif
L 28 "..\..\common\src\BSP\ThirdParty\yaffs2\include\nand.h" 2
N
N/*
N * All boards using a given driver must convert to self-init
N * at the same time, so do it here.  When all drivers are
N * converted, this will go away.
N */
N#if defined(CONFIG_NAND_FSL_ELBC) || defined(CONFIG_NAND_ATMEL)
X#if 0L || 0L
S#define CONFIG_SYS_NAND_SELF_INIT
N#endif
N
Nextern void nand_init(void);
N
N#include "linux\mtd.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 1
N/*
N * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
N *
N * Released under GPL
N */
N
N#ifndef __MTD_MTD_H__
N#define __MTD_MTD_H__
N
N#include "linux\types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 1
N#ifndef _LINUX_TYPES_H
N#define _LINUX_TYPES_H
N
N#ifdef	__KERNEL__
S#include <linux/config.h>
N#endif
N
N#include "linux\posix_types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 1
N#ifndef _LINUX_POSIX_TYPES_H
N#define _LINUX_POSIX_TYPES_H
N
N#include <linux/stddef.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/stddef.h" 1
N#ifndef _LINUX_STDDEF_H
N#define _LINUX_STDDEF_H
N
N#undef NULL
N#if defined(__cplusplus)
X#if 0L
S#define NULL 0
N#else
N#define NULL ((void *)0)
N#endif
N
N#ifndef _SIZE_T
N#include "linux\types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 1
N#ifndef _LINUX_TYPES_H
S#define _LINUX_TYPES_H
S
S#ifdef	__KERNEL__
S#include <linux/config.h>
S#endif
S
S#include "linux\posix_types.h"
S#include "asm\types.h"
S//#include "stdbool.h"
S
S#ifndef __KERNEL_STRICT_NAMES
S
Stypedef __kernel_fd_set		fd_set;
Stypedef __kernel_dev_t		dev_t;
Stypedef __kernel_ino_t		ino_t;
Stypedef __kernel_mode_t		mode_t;
Stypedef __kernel_nlink_t	nlink_t;
Stypedef __kernel_off_t		off_t;
Stypedef __kernel_pid_t		pid_t;
Stypedef __kernel_daddr_t	daddr_t;
Stypedef __kernel_key_t		key_t;
Stypedef __kernel_suseconds_t	suseconds_t;
S
S#ifdef __KERNEL__
Stypedef __kernel_uid32_t	uid_t;
Stypedef __kernel_gid32_t	gid_t;
Stypedef __kernel_uid16_t        uid16_t;
Stypedef __kernel_gid16_t        gid16_t;
S
S#ifdef CONFIG_UID16
S/* This is defined by include/asm-{arch}/posix_types.h */
Stypedef __kernel_old_uid_t	old_uid_t;
Stypedef __kernel_old_gid_t	old_gid_t;
S#endif /* CONFIG_UID16 */
S
S/* libc5 includes this file to define uid_t, thus uid_t can never change
S * when it is included by non-kernel code
S */
S#else
Stypedef __kernel_uid_t		uid_t;
Stypedef __kernel_gid_t		gid_t;
S#endif /* __KERNEL__ */
S
S#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
Stypedef __kernel_loff_t		loff_t;
S#endif
Stypedef long long		loff_t;
S
S/*
S * The following typedefs are also protected by individual ifdefs for
S * historical reasons:
S */
S#ifndef _SIZE_T
S#define _SIZE_T
Stypedef __kernel_size_t		size_t;
S#endif
S
S#ifndef _SSIZE_T
S#define _SSIZE_T
Stypedef __kernel_ssize_t	ssize_t;
S#endif
S
S#ifndef _PTRDIFF_T
S#define _PTRDIFF_T
Stypedef __kernel_ptrdiff_t	ptrdiff_t;
S#endif
S
S#ifndef _TIME_T
S#define _TIME_T
Stypedef __kernel_time_t		time_t;
S#endif
S
S#ifndef _CLOCK_T
S#define _CLOCK_T
Stypedef __kernel_clock_t	clock_t;
S#endif
S
S#ifndef _CADDR_T
S#define _CADDR_T
Stypedef __kernel_caddr_t	caddr_t;
S#endif
S
S/* bsd */
Stypedef unsigned char		u_char;
Stypedef unsigned short		u_short;
Stypedef unsigned int		u_int;
Stypedef unsigned long		u_long;
S
S/* sysv */
Stypedef unsigned char		unchar;
Stypedef unsigned short		ushort;
Stypedef unsigned int		uint;
Stypedef unsigned long		ulong;
S
S#ifndef __BIT_TYPES_DEFINED__
S#define __BIT_TYPES_DEFINED__
S
Stypedef		__u8		u_int8_t;
S// typedef		__s8		int8_t;
Stypedef		__u16		u_int16_t;
S// typedef		__s16		int16_t;
Stypedef		__u32		u_int32_t;
S// typedef		__s32		int32_t;
S
S#endif /* !(__BIT_TYPES_DEFINED__) */
S
S// typedef		__u8		uint8_t;
S// typedef		__u16		uint16_t;
S// typedef		__u32		uint32_t;
S
S// #if defined(__GNUC__) && !defined(__STRICT_ANSI__)
Stypedef		__u64		uint64_t;
Stypedef		__u64		u_int64_t;
Stypedef		__s64		int64_t;
S// #endif
S
S#endif /* __KERNEL_STRICT_NAMES */
S
S/*
S * Below are truly Linux-specific types that should never collide with
S * any application/library that wants linux/types.h.
S */
S#ifdef __CHECKER__
S#define __bitwise__ __attribute__((bitwise))
S#else
S#define __bitwise__
S#endif
S#ifdef __CHECK_ENDIAN__
S#define __bitwise __bitwise__
S#else
S#define __bitwise
S#endif
S
Stypedef __u16 __bitwise __le16;
Stypedef __u16 __bitwise __be16;
Stypedef __u32 __bitwise __le32;
Stypedef __u32 __bitwise __be32;
S// #if defined(__GNUC__)
Stypedef __u64 __bitwise __le64;
Stypedef __u64 __bitwise __be64;
S// #endif
Stypedef __u16 __bitwise __sum16;
Stypedef __u32 __bitwise __wsum;
S
S
Stypedef unsigned __bitwise__	gfp_t;
S
Sstruct ustat {
S	__kernel_daddr_t	f_tfree;
S	__kernel_ino_t		f_tinode;
S	char			f_fname[6];
S	char			f_fpack[6];
S};
S
N#endif /* _LINUX_TYPES_H */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/stddef.h" 2
N#endif
N
N#ifndef __CHECKER__
N#undef offsetof
N#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
N#endif
N
N#endif
L 5 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 2
N
N/*
N * This allows for 1024 file descriptors: if NR_OPEN is ever grown
N * beyond that you'll have to change this too. But 1024 fd's seem to be
N * enough even for such "real" unices like OSF/1, so hopefully this is
N * one limit that doesn't have to be changed [again].
N *
N * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
N * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
N * place for them. Solved by having dummy defines in <sys/time.h>.
N */
N
N/*
N * Those macros may have been defined in <gnu/types.h>. But we always
N * use the ones here.
N */
N#undef __NFDBITS
N#define __NFDBITS	(8 * sizeof(unsigned long))
N
N#undef __FD_SETSIZE
N#define __FD_SETSIZE	1024
N
N#undef __FDSET_LONGS
N#define __FDSET_LONGS	(__FD_SETSIZE/__NFDBITS)
N
N#undef __FDELT
N#define	__FDELT(d)	((d) / __NFDBITS)
N
N#undef __FDMASK
N#define	__FDMASK(d)	(1UL << ((d) % __NFDBITS))
N
Ntypedef struct {
N	unsigned long fds_bits [__FDSET_LONGS];
X	unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
N} __kernel_fd_set;
N
N/* Type of a signal handler.  */
Ntypedef void (*__kernel_sighandler_t)(int);
N
N/* Type of a SYSV IPC key.  */
Ntypedef int __kernel_key_t;
N
N#include <asm/posix_types.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm/posix_types.h" 1
N/*
N *  linux/include/asm-arm/posix_types.h
N *
N *  Copyright (C) 1996-1998 Russell King.
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N *  Changelog:
N *   27-06-1996	RMK	Created
N */
N#ifndef __ARCH_ARM_POSIX_TYPES_H
N#define __ARCH_ARM_POSIX_TYPES_H
N
N/*
N * This file is generally used by user-level software, so you need to
N * be a little careful about namespace pollution etc.  Also, we cannot
N * assume GCC is being used.
N */
N
Ntypedef unsigned short		__kernel_dev_t;
Ntypedef unsigned long		__kernel_ino_t;
Ntypedef unsigned short		__kernel_mode_t;
Ntypedef unsigned short		__kernel_nlink_t;
Ntypedef long			__kernel_off_t;
Ntypedef int			__kernel_pid_t;
Ntypedef unsigned short		__kernel_ipc_pid_t;
Ntypedef unsigned short		__kernel_uid_t;
Ntypedef unsigned short		__kernel_gid_t;
Ntypedef unsigned int		__kernel_size_t;
Ntypedef int			__kernel_ssize_t;
Ntypedef int			__kernel_ptrdiff_t;
Ntypedef long			__kernel_time_t;
Ntypedef long			__kernel_suseconds_t;
Ntypedef long			__kernel_clock_t;
Ntypedef int			__kernel_daddr_t;
Ntypedef char *			__kernel_caddr_t;
Ntypedef unsigned short		__kernel_uid16_t;
Ntypedef unsigned short		__kernel_gid16_t;
Ntypedef unsigned int		__kernel_uid32_t;
Ntypedef unsigned int		__kernel_gid32_t;
N
Ntypedef unsigned short		__kernel_old_uid_t;
Ntypedef unsigned short		__kernel_old_gid_t;
N
N#ifdef __GNUC__
Stypedef long long		__kernel_loff_t;
N#endif
N
Ntypedef struct {
N#if defined(__KERNEL__) || defined(__USE_ALL)
X#if 0L || 0L
S	int	val[2];
N#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
N	int	__val[2];
N#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
N} __kernel_fsid_t;
N
N#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
X#if 0L || !0L || (__GLIBC__ < 2)
N
N#undef	__FD_SET
N#define __FD_SET(fd, fdsetp) \
N		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
X#define __FD_SET(fd, fdsetp) 		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
N
N#undef	__FD_CLR
N#define __FD_CLR(fd, fdsetp) \
N		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
X#define __FD_CLR(fd, fdsetp) 		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
N
N#undef	__FD_ISSET
N#define __FD_ISSET(fd, fdsetp) \
N		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
X#define __FD_ISSET(fd, fdsetp) 		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
N
N#undef	__FD_ZERO
N#define __FD_ZERO(fdsetp) \
N		(memset (fdsetp, 0, sizeof (*(fd_set *)fdsetp)))
X#define __FD_ZERO(fdsetp) 		(memset (fdsetp, 0, sizeof (*(fd_set *)fdsetp)))
N
N#endif
N
N#endif
L 47 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 2
N
N#endif /* _LINUX_POSIX_TYPES_H */
L 9 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 2
N#include "asm\types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm\types.h" 1
N#ifndef __ASM_ARM_TYPES_H
N#define __ASM_ARM_TYPES_H
N
Ntypedef unsigned short umode_t;
N
N/*
N * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
N * header files exported to user space
N */
N
Ntypedef char __s8;
Ntypedef unsigned char __u8;
N
Ntypedef short __s16;
Ntypedef unsigned short __u16;
N
Ntypedef int __s32;
Ntypedef unsigned int __u32;
N
Ntypedef long long __s64;
Ntypedef unsigned long long __u64;
N
N#if defined(__GNUC__)
X#if 0L
S__extension__ typedef __signed__ long long __s64;
S__extension__ typedef unsigned long long __u64;
N#endif
N
N/*
N * These aren't exported outside the kernel to avoid name space clashes
N */
N// #ifdef __KERNEL__
N
Ntypedef signed char s8;
Ntypedef unsigned char u8;
N
Ntypedef signed short s16;
Ntypedef unsigned short u16;
N
Ntypedef signed int s32;
Ntypedef unsigned int u32;
N
Ntypedef signed long long s64;
Ntypedef unsigned long long u64;
N
N#define BITS_PER_LONG 32
N
N/* Dma addresses are 32-bits wide.  */
N
Ntypedef u32 dma_addr_t;
N
Ntypedef unsigned long phys_addr_t;
Ntypedef unsigned long phys_size_t;
N
N// #endif /* __KERNEL__ */
N
N#endif
L 10 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 2
N//#include "stdbool.h"
N
N#ifndef __KERNEL_STRICT_NAMES
N
Ntypedef __kernel_fd_set		fd_set;
Ntypedef __kernel_dev_t		dev_t;
Ntypedef __kernel_ino_t		ino_t;
Ntypedef __kernel_mode_t		mode_t;
Ntypedef __kernel_nlink_t	nlink_t;
Ntypedef __kernel_off_t		off_t;
Ntypedef __kernel_pid_t		pid_t;
Ntypedef __kernel_daddr_t	daddr_t;
Ntypedef __kernel_key_t		key_t;
Ntypedef __kernel_suseconds_t	suseconds_t;
N
N#ifdef __KERNEL__
Stypedef __kernel_uid32_t	uid_t;
Stypedef __kernel_gid32_t	gid_t;
Stypedef __kernel_uid16_t        uid16_t;
Stypedef __kernel_gid16_t        gid16_t;
S
S#ifdef CONFIG_UID16
S/* This is defined by include/asm-{arch}/posix_types.h */
Stypedef __kernel_old_uid_t	old_uid_t;
Stypedef __kernel_old_gid_t	old_gid_t;
S#endif /* CONFIG_UID16 */
S
S/* libc5 includes this file to define uid_t, thus uid_t can never change
S * when it is included by non-kernel code
S */
N#else
Ntypedef __kernel_uid_t		uid_t;
Ntypedef __kernel_gid_t		gid_t;
N#endif /* __KERNEL__ */
N
N#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
X#if 0L && !0L
Stypedef __kernel_loff_t		loff_t;
N#endif
Ntypedef long long		loff_t;
N
N/*
N * The following typedefs are also protected by individual ifdefs for
N * historical reasons:
N */
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef __kernel_size_t		size_t;
N#endif
N
N#ifndef _SSIZE_T
N#define _SSIZE_T
Ntypedef __kernel_ssize_t	ssize_t;
N#endif
N
N#ifndef _PTRDIFF_T
N#define _PTRDIFF_T
Ntypedef __kernel_ptrdiff_t	ptrdiff_t;
N#endif
N
N#ifndef _TIME_T
N#define _TIME_T
Ntypedef __kernel_time_t		time_t;
N#endif
N
N#ifndef _CLOCK_T
N#define _CLOCK_T
Ntypedef __kernel_clock_t	clock_t;
N#endif
N
N#ifndef _CADDR_T
N#define _CADDR_T
Ntypedef __kernel_caddr_t	caddr_t;
N#endif
N
N/* bsd */
Ntypedef unsigned char		u_char;
Ntypedef unsigned short		u_short;
Ntypedef unsigned int		u_int;
Ntypedef unsigned long		u_long;
N
N/* sysv */
Ntypedef unsigned char		unchar;
Ntypedef unsigned short		ushort;
Ntypedef unsigned int		uint;
Ntypedef unsigned long		ulong;
N
N#ifndef __BIT_TYPES_DEFINED__
N#define __BIT_TYPES_DEFINED__
N
Ntypedef		__u8		u_int8_t;
N// typedef		__s8		int8_t;
Ntypedef		__u16		u_int16_t;
N// typedef		__s16		int16_t;
Ntypedef		__u32		u_int32_t;
N// typedef		__s32		int32_t;
N
N#endif /* !(__BIT_TYPES_DEFINED__) */
N
N// typedef		__u8		uint8_t;
N// typedef		__u16		uint16_t;
N// typedef		__u32		uint32_t;
N
N// #if defined(__GNUC__) && !defined(__STRICT_ANSI__)
Ntypedef		__u64		uint64_t;
Ntypedef		__u64		u_int64_t;
Ntypedef		__s64		int64_t;
N// #endif
N
N#endif /* __KERNEL_STRICT_NAMES */
N
N/*
N * Below are truly Linux-specific types that should never collide with
N * any application/library that wants linux/types.h.
N */
N#ifdef __CHECKER__
S#define __bitwise__ __attribute__((bitwise))
N#else
N#define __bitwise__
N#endif
N#ifdef __CHECK_ENDIAN__
S#define __bitwise __bitwise__
N#else
N#define __bitwise
N#endif
N
Ntypedef __u16 __bitwise __le16;
Xtypedef __u16  __le16;
Ntypedef __u16 __bitwise __be16;
Xtypedef __u16  __be16;
Ntypedef __u32 __bitwise __le32;
Xtypedef __u32  __le32;
Ntypedef __u32 __bitwise __be32;
Xtypedef __u32  __be32;
N// #if defined(__GNUC__)
Ntypedef __u64 __bitwise __le64;
Xtypedef __u64  __le64;
Ntypedef __u64 __bitwise __be64;
Xtypedef __u64  __be64;
N// #endif
Ntypedef __u16 __bitwise __sum16;
Xtypedef __u16  __sum16;
Ntypedef __u32 __bitwise __wsum;
Xtypedef __u32  __wsum;
N
N
Ntypedef unsigned __bitwise__	gfp_t;
Xtypedef unsigned 	gfp_t;
N
Nstruct ustat {
N	__kernel_daddr_t	f_tfree;
N	__kernel_ino_t		f_tinode;
N	char			f_fname[6];
N	char			f_fpack[6];
N};
N
N#endif /* _LINUX_TYPES_H */
L 11 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 2
N#include "div64.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\div64.h" 1
N#ifndef _ASM_GENERIC_DIV64_H
N#define _ASM_GENERIC_DIV64_H
N/*
N * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
N * Based on former asm-ppc/div64.h and asm-m68knommu/div64.h
N *
N * The semantics of do_div() are:
N *
N * uint32_t do_div(uint64_t *n, uint32_t base)
N * {
N *	uint32_t remainder = *n % base;
N *	*n = *n / base;
N *	return remainder;
N * }
N *
N * NOTE: macro parameter n is evaluated multiple times,
N *       beware of side effects!
N */
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 20 "..\..\common\src\BSP\ThirdParty\yaffs2\include\div64.h" 2
N#include "linux\types.h"
N
Nextern uint32_t __div64_32(uint64_t *dividend, uint32_t divisor);
N
N/* The unnecessary pointer compare is there
N * to check for type safety (n must be 64bit)
N */
N#define do_div(n,base) (n = n/base)
N
N#if 0
S#define do_div(n,base) ({   \
S	uint32_t __base = (base);   \
S	uint32_t __rem; \
S	(void)(((typeof((n)) *)0) == ((uint64_t *)0));  \
S	if (((n) >> 32) == 0) { \
S		__rem = (uint32_t)(n) % __base; \
S		(n) = (uint32_t)(n) / __base;   \
S	} else  \
S		__rem = __div64_32(&(n), __base);   \
S	__rem;  \
S})
X#define do_div(n,base) ({   	uint32_t __base = (base);   	uint32_t __rem; 	(void)(((typeof((n)) *)0) == ((uint64_t *)0));  	if (((n) >> 32) == 0) { 		__rem = (uint32_t)(n) % __base; 		(n) = (uint32_t)(n) / __base;   	} else  		__rem = __div64_32(&(n), __base);   	__rem;  })
S
S/* Wrapper for do_div(). Doesn't modify dividend and returns
S * the result, not reminder.
S */
Sstatic __inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
S{
S	uint64_t __res = dividend;
S	do_div(__res, divisor);
S	return(__res);
S}
N#endif
N#endif /* _ASM_GENERIC_DIV64_H */
L 12 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 2
N#include "linux\mtd-abi.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd-abi.h" 1
N/*
N * $Id: mtd-abi.h,v 1.13 2005/11/07 11:14:56 gleixner Exp $
N *
N * Portions of MTD ABI definition which are shared by kernel and user space
N */
N
N#ifndef __MTD_ABI_H__
N#define __MTD_ABI_H__
N
N#include <stdint.h>
N
N#include <linux/compiler.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/compiler.h" 1
N#ifndef __LINUX_COMPILER_H
N#define __LINUX_COMPILER_H
N
N#ifndef __ASSEMBLY__
N
N#ifdef __CHECKER__
S# define __user		__attribute__((noderef, address_space(1)))
S# define __kernel	/* default address space */
S# define __safe		__attribute__((safe))
S# define __force	__attribute__((force))
S# define __nocast	__attribute__((nocast))
S# define __iomem	__attribute__((noderef, address_space(2)))
S# define __acquires(x)	__attribute__((context(x,0,1)))
S# define __releases(x)	__attribute__((context(x,1,0)))
S# define __acquire(x)	__context__(x,1)
S# define __release(x)	__context__(x,-1)
S# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
Sextern void __chk_user_ptr(const volatile void __user *);
Sextern void __chk_io_ptr(const volatile void __iomem *);
N#else
N# define __user
N# define __kernel
N# define __safe
N# define __force
N# define __nocast
N# define __iomem
N# define __chk_user_ptr(x) (void)0
N# define __chk_io_ptr(x) (void)0
N# define __builtin_warning(x, y...) (1)
N# define __acquires(x)
N# define __releases(x)
N# define __acquire(x) (void)0
N# define __release(x) (void)0
N# define __cond_lock(x,c) (c)
N#endif
N
N#ifdef __KERNEL__
S
S#ifdef __GNUC__
S#include <linux/compiler-gcc.h>
S#endif
S
S#define notrace __attribute__((no_instrument_function))
S
S/* Intel compiler defines __GNUC__. So we will overwrite implementations
S * coming from above header files here
S */
S#ifdef __INTEL_COMPILER
S# include <linux/compiler-intel.h>
S#endif
S
S/*
S * Generic compiler-dependent macros required for kernel
S * build go below this comment. Actual compiler/compiler version
S * specific implementations come from the above header files
S */
S
Sstruct ftrace_branch_data {
S	const char *func;
S	const char *file;
S	unsigned line;
S	union {
S		struct {
S			unsigned long correct;
S			unsigned long incorrect;
S		};
S		struct {
S			unsigned long miss;
S			unsigned long hit;
S		};
S		unsigned long miss_hit[2];
S	};
S};
S
S/*
S * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
S * to disable branch tracing on a per file basis.
S */
S#if defined(CONFIG_TRACE_BRANCH_PROFILING) \
S    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)
X#if defined(CONFIG_TRACE_BRANCH_PROFILING)     && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)
Svoid ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
S
S#define likely_notrace(x)	__builtin_expect(!!(x), 1)
S#define unlikely_notrace(x)	__builtin_expect(!!(x), 0)
S
S#define __branch_check__(x, expect) ({					\
S			int ______r;					\
S			static struct ftrace_branch_data		\
S				__attribute__((__aligned__(4)))		\
S				__attribute__((section("_ftrace_annotated_branch"))) \
S				______f = {				\
S				.func = __func__,			\
S				.file = __FILE__,			\
S				.line = __LINE__,			\
S			};						\
S			______r = likely_notrace(x);			\
S			ftrace_likely_update(&______f, ______r, expect); \
S			______r;					\
S		})
X#define __branch_check__(x, expect) ({								int ______r;								static struct ftrace_branch_data						__attribute__((__aligned__(4)))						__attribute__((section("_ftrace_annotated_branch"))) 				______f = {								.func = __func__,							.file = __FILE__,							.line = __LINE__,						};									______r = likely_notrace(x);						ftrace_likely_update(&______f, ______r, expect); 			______r;							})
S
S/*
S * Using __builtin_constant_p(x) to ignore cases where the return
S * value is always the same.  This idea is taken from a similar patch
S * written by Daniel Walker.
S */
S# ifndef likely
S#  define likely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 1))
S# endif
S# ifndef unlikely
S#  define unlikely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 0))
S# endif
S
S#ifdef CONFIG_PROFILE_ALL_BRANCHES
S/*
S * "Define 'is'", Bill Clinton
S * "Define 'if'", Steven Rostedt
S */
S#define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
S#define __trace_if(cond) \
S	if (__builtin_constant_p((cond)) ? !!(cond) :			\
S	({								\
S		int ______r;						\
S		static struct ftrace_branch_data			\
S			__attribute__((__aligned__(4)))			\
S			__attribute__((section("_ftrace_branch")))	\
S			______f = {					\
S				.func = __func__,			\
S				.file = __FILE__,			\
S				.line = __LINE__,			\
S			};						\
S		______r = !!(cond);					\
S		______f.miss_hit[______r]++;					\
S		______r;						\
S	}))
X#define __trace_if(cond) 	if (__builtin_constant_p((cond)) ? !!(cond) :				({										int ______r;								static struct ftrace_branch_data						__attribute__((__aligned__(4)))						__attribute__((section("_ftrace_branch")))				______f = {									.func = __func__,							.file = __FILE__,							.line = __LINE__,						};								______r = !!(cond);							______f.miss_hit[______r]++;							______r;							}))
S#endif /* CONFIG_PROFILE_ALL_BRANCHES */
S
S#else
S# define likely(x)	__builtin_expect(!!(x), 1)
S# define unlikely(x)	__builtin_expect(!!(x), 0)
S#endif
S
S/* Optimization barrier */
S#ifndef barrier
S# define barrier() __memory_barrier()
S#endif
S
S/* Unreachable code */
S#ifndef unreachable
S# define unreachable() do { } while (1)
S#endif
S
S#ifndef RELOC_HIDE
S# define RELOC_HIDE(ptr, off)					\
S  ({ unsigned long __ptr;					\
S     __ptr = (unsigned long) (ptr);				\
S    (typeof(ptr)) (__ptr + (off)); })
X# define RELOC_HIDE(ptr, off)					  ({ unsigned long __ptr;					     __ptr = (unsigned long) (ptr);				    (typeof(ptr)) (__ptr + (off)); })
S#endif
S
N#endif /* __KERNEL__ */
N
N#endif /* __ASSEMBLY__ */
N
N#ifdef __KERNEL__
S/*
S * Allow us to mark functions as 'deprecated' and have gcc emit a nice
S * warning for each use, in hopes of speeding the functions removal.
S * Usage is:
S * 		int __deprecated foo(void)
S */
S#ifndef __deprecated
S# define __deprecated		/* unimplemented */
S#endif
S
S#ifdef MODULE
S#define __deprecated_for_modules __deprecated
S#else
S#define __deprecated_for_modules
S#endif
S
S#ifndef __must_check
S#define __must_check
S#endif
S
S#ifndef CONFIG_ENABLE_MUST_CHECK
S#undef __must_check
S#define __must_check
S#endif
S#ifndef CONFIG_ENABLE_WARN_DEPRECATED
S#undef __deprecated
S#undef __deprecated_for_modules
S#define __deprecated
S#define __deprecated_for_modules
S#endif
S
S/*
S * Allow us to avoid 'defined but not used' warnings on functions and data,
S * as well as force them to be emitted to the assembly file.
S *
S * As of gcc 3.4, static functions that are not marked with attribute((used))
S * may be elided from the assembly file.  As of gcc 3.4, static data not so
S * marked will not be elided, but this may change in a future gcc version.
S *
S * NOTE: Because distributions shipped with a backported unit-at-a-time
S * compiler in gcc 3.3, we must define __used to be __attribute__((used))
S * for gcc >=3.3 instead of 3.4.
S *
S * In prior versions of gcc, such functions and data would be emitted, but
S * would be warned about except with attribute((unused)).
S *
S * Mark functions that are referenced only in inline assembly as __used so
S * the code is emitted even though it appears to be unreferenced.
S */
S#ifndef __used
S# define __used			/* unimplemented */
S#endif
S
S#ifndef __maybe_unused
S# define __maybe_unused		/* unimplemented */
S#endif
S
S#ifndef __always_unused
S# define __always_unused	/* unimplemented */
S#endif
S
S#ifndef noinline
S#define noinline
S#endif
S
S/*
S * Rather then using noinline to prevent stack consumption, use
S * noinline_for_stack instead.  For documentaiton reasons.
S */
S#define noinline_for_stack noinline
S
S#ifndef __always_inline
S#define __always_inline inline
S#endif
S
N#endif /* __KERNEL__ */
N
N/*
N * From the GCC manual:
N *
N * Many functions do not examine any values except their arguments,
N * and have no effects except the return value.  Basically this is
N * just slightly more strict class than the `pure' attribute above,
N * since function is not allowed to read global memory.
N *
N * Note that a function that has pointer arguments and examines the
N * data pointed to must _not_ be declared `const'.  Likewise, a
N * function that calls a non-`const' function usually must not be
N * `const'.  It does not make sense for a `const' function to return
N * `void'.
N */
N#ifndef __attribute_const__
N# define __attribute_const__	/* unimplemented */
N#endif
N
N/*
N * Tell gcc if a function is cold. The compiler will assume any path
N * directly leading to the call is unlikely.
N */
N
N#ifndef __cold
N#define __cold
N#endif
N
N/* Simple shorthand for a section definition */
N#ifndef __section
N# define __section(S) __attribute__ ((__section__(#S)))
N#endif
N
N/* Are two types/vars the same type (ignoring qualifiers)? */
N#ifndef __same_type
N# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
N#endif
N
N/* Compile time object size, -1 for unknown */
N#ifndef __compiletime_object_size
N# define __compiletime_object_size(obj) -1
N#endif
N#ifndef __compiletime_warning
N# define __compiletime_warning(message)
N#endif
N#ifndef __compiletime_error
N# define __compiletime_error(message)
N#endif
N
N/*
N * Prevent the compiler from merging or refetching accesses.  The compiler
N * is also forbidden from reordering successive instances of ACCESS_ONCE(),
N * but only when the compiler is aware of some particular ordering.  One way
N * to make the compiler aware of ordering is to put the two invocations of
N * ACCESS_ONCE() in different C statements.
N *
N * This macro does absolutely -nothing- to prevent the CPU from reordering,
N * merging, or refetching absolutely anything at any time.  Its main intended
N * use is to mediate communication between process-level code and irq/NMI
N * handlers, all running on the same CPU.
N */
N#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
N
N#endif /* __LINUX_COMPILER_H */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd-abi.h" 2
N
Nstruct erase_info_user {
N	uint32_t start;
N	uint32_t length;
N};
N
Nstruct mtd_oob_buf {
N	uint32_t start;
N	uint32_t length;
N	unsigned char __user *ptr;
X	unsigned char  *ptr;
N};
N
N#define MTD_ABSENT		0
N#define MTD_RAM			1
N#define MTD_ROM			2
N#define MTD_NORFLASH		3
N#define MTD_NANDFLASH		4
N#define MTD_DATAFLASH		6
N#define MTD_UBIVOLUME		7
N
N#define MTD_WRITEABLE		0x400	/* Device is writeable */
N#define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
N#define MTD_NO_ERASE		0x1000	/* No erase necessary */
N#define MTD_STUPID_LOCK		0x2000	/* Always locked after reset */
N
N/* Some common devices / combinations of capabilities */
N#define MTD_CAP_ROM		0
N#define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
N#define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
N#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
N
N/* ECC byte placement */
N#define MTD_NANDECC_OFF		0	/* Switch off ECC (Not recommended) */
N#define MTD_NANDECC_PLACE	1	/* Use the given placement in the structure (YAFFS1 legacy mode) */
N#define MTD_NANDECC_AUTOPLACE	2	/* Use the default placement scheme */
N#define MTD_NANDECC_PLACEONLY	3	/* Use the given placement in the structure (Do not store ecc result on read) */
N#define MTD_NANDECC_AUTOPL_USR	4	/* Use the given autoplacement scheme rather than using the default */
N
N/* OTP mode selection */
N#define MTD_OTP_OFF		0
N#define MTD_OTP_FACTORY		1
N#define MTD_OTP_USER		2
N
Nstruct mtd_info_user {
N	uint8_t type;
N	uint32_t flags;
N	uint32_t size;			/* Total size of the MTD */
N	uint32_t erasesize;
N	uint32_t writesize;
N	uint32_t oobsize;		/* Amount of OOB data per block (e.g. 16) */
N	/* The below two fields are obsolete and broken, do not use them
N	 * (TODO: remove at some point) */
N	uint32_t ecctype;
N	uint32_t eccsize;
N};
N
Nstruct region_info_user {
N	uint32_t offset;		/* At which this region starts,
N					 * from the beginning of the MTD */
N	uint32_t erasesize;		/* For this region */
N	uint32_t numblocks;		/* Number of blocks in this region */
N	uint32_t regionindex;
N};
N
Nstruct otp_info {
N	uint32_t start;
N	uint32_t length;
N	uint32_t locked;
N};
N
N#define MEMGETINFO		_IOR('M', 1, struct mtd_info_user)
N#define MEMERASE		_IOW('M', 2, struct erase_info_user)
N#define MEMWRITEOOB		_IOWR('M', 3, struct mtd_oob_buf)
N#define MEMREADOOB		_IOWR('M', 4, struct mtd_oob_buf)
N#define MEMLOCK			_IOW('M', 5, struct erase_info_user)
N#define MEMUNLOCK		_IOW('M', 6, struct erase_info_user)
N#define MEMGETREGIONCOUNT	_IOR('M', 7, int)
N#define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
N#define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
N#define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
N#define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
N#define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
N#define OTPSELECT		_IOR('M', 13, int)
N#define OTPGETREGIONCOUNT	_IOW('M', 14, int)
N#define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
N#define OTPLOCK			_IOR('M', 16, struct otp_info)
N#define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
N#define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
N#define MTDFILEMODE		_IO('M', 19)
N
N/*
N * Obsolete legacy interface. Keep it in order not to break userspace
N * interfaces
N */
Nstruct nand_oobinfo {
N	uint32_t useecc;
N	uint32_t eccbytes;
N	uint32_t oobfree[8][2];
N	uint32_t eccpos[48];
N};
N
Nstruct nand_oobfree {
N	uint32_t offset;
N	uint32_t length;
N};
N
N#define MTD_MAX_OOBFREE_ENTRIES	8
N/*
N * ECC layout control structure. Exported to userspace for
N * diagnosis and to allow creation of raw images
N */
Nstruct nand_ecclayout {
N	uint32_t eccbytes;
N	uint32_t eccpos[128];
N	uint32_t oobavail;
N	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
X	struct nand_oobfree oobfree[8];
N};
N
N/**
N * struct mtd_ecc_stats - error correction stats
N *
N * @corrected:	number of corrected bits
N * @failed:	number of uncorrectable errors
N * @badblocks:	number of bad blocks in this partition
N * @bbtblocks:	number of blocks reserved for bad block tables
N */
Nstruct mtd_ecc_stats {
N	uint32_t corrected;
N	uint32_t failed;
N	uint32_t badblocks;
N	uint32_t bbtblocks;
N};
N
N/*
N * Read/write file modes for access to MTD
N */
Nenum mtd_file_modes {
N	MTD_MODE_NORMAL = MTD_OTP_OFF,
X	MTD_MODE_NORMAL = 0,
N	MTD_MODE_OTP_FACTORY = MTD_OTP_FACTORY,
X	MTD_MODE_OTP_FACTORY = 1,
N	MTD_MODE_OTP_USER = MTD_OTP_USER,
X	MTD_MODE_OTP_USER = 2,
N	MTD_MODE_RAW,
N};
N
N#endif /* __MTD_ABI_H__ */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 2
N
N#define MTD_CHAR_MAJOR 90
N#define MTD_BLOCK_MAJOR 31
N#define MAX_MTD_DEVICES 32
N
N#define MTD_ERASE_PENDING	0x01
N#define MTD_ERASING		0x02
N#define MTD_ERASE_SUSPEND	0x04
N#define MTD_ERASE_DONE          0x08
N#define MTD_ERASE_FAILED        0x10
N
N#define MTD_FAIL_ADDR_UNKNOWN	-1LL
N
N/*
N * Enumeration for NAND/OneNAND flash chip state
N */
Nenum {
N	FL_READY,
N	FL_READING,
N	FL_WRITING,
N	FL_ERASING,
N	FL_SYNCING,
N	FL_CACHEDPRG,
N	FL_RESETING,
N	FL_UNLOCKING,
N	FL_LOCKING,
N	FL_PM_SUSPENDED,
N};
N
N/* If the erase fails, fail_addr might indicate exactly which block failed.  If
N   fail_addr = MTD_FAIL_ADDR_UNKNOWN, the failure was not at the device level or was not
N   specific to any particular block. */
Nstruct erase_info {
N	struct mtd_info *mtd;
N	uint64_t addr;
N	uint64_t len;
N	uint64_t fail_addr;
N	u_long time;
N	u_long retries;
N	u_int dev;
N	u_int cell;
N	void (*callback) (struct erase_info *self);
N	u_long priv;
N	u_char state;
N	struct erase_info *next;
N	int scrub;
N};
N
Nstruct mtd_erase_region_info {
N	uint64_t offset;			/* At which this region starts, from the beginning of the MTD */
N	u_int32_t erasesize;		/* For this region */
N	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
N	unsigned long *lockmap;		/* If keeping bitmap of locks */
N};
N
N/*
N * oob operation modes
N *
N * MTD_OOB_PLACE:	oob data are placed at the given offset
N * MTD_OOB_AUTO:	oob data are automatically placed at the free areas
N *			which are defined by the ecclayout
N * MTD_OOB_RAW:		mode to read raw data+oob in one chunk. The oob data
N *			is inserted into the data. Thats a raw image of the
N *			flash contents.
N */
Ntypedef enum {
N	MTD_OOB_PLACE,
N	MTD_OOB_AUTO,
N	MTD_OOB_RAW,
N} mtd_oob_mode_t;
N
N/**
N * struct mtd_oob_ops - oob operation operands
N * @mode:	operation mode
N *
N * @len:	number of data bytes to write/read
N *
N * @retlen:	number of data bytes written/read
N *
N * @ooblen:	number of oob bytes to write/read
N * @oobretlen:	number of oob bytes written/read
N * @ooboffs:	offset of oob data in the oob area (only relevant when
N *		mode = MTD_OOB_PLACE)
N * @datbuf:	data buffer - if NULL only oob data are read/written
N * @oobbuf:	oob data buffer
N *
N * Note, it is allowed to read more then one OOB area at one go, but not write.
N * The interface assumes that the OOB write requests program only one page's
N * OOB area.
N */
Nstruct mtd_oob_ops {
N	mtd_oob_mode_t	mode;
N	size_t		len;
N	size_t		retlen;
N	size_t		ooblen;
N	size_t		oobretlen;
N	uint32_t	ooboffs;
N	uint8_t		*datbuf;
N	uint8_t		*oobbuf;
N};
N
Nstruct mtd_info {
N	u_char type;
N	u_int32_t flags;
N	uint64_t size;	 /* Total size of the MTD */
N
N	/* "Major" erase size for the device. Naïve users may take this
N	 * to be the only erase size available, or may use the more detailed
N	 * information below if they desire
N	 */
N	u_int32_t erasesize;
N	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
N	 * though individual bits can be cleared), in case of NAND flash it is
N	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
N	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
N	 * Any driver registering a struct mtd_info must ensure a writesize of
N	 * 1 or larger.
N	 */
N	u_int32_t writesize;
N
N	u_int32_t oobsize;   /* Amount of OOB data per block (e.g. 16) */
N	u_int32_t oobavail;  /* Available OOB bytes per block */
N
N	/* Kernel-only stuff starts here. */
N	const char *name;
N	int index;
N
N	/* ecc layout structure pointer - read only ! */
N	struct nand_ecclayout *ecclayout;
N
N	/* Data for variable erase regions. If numeraseregions is zero,
N	 * it means that the whole device has erasesize as given above.
N	 */
N	int numeraseregions;
N	struct mtd_erase_region_info *eraseregions;
N
N	/*
N	 * Erase is an asynchronous operation.  Device drivers are supposed
N	 * to call instr->callback() whenever the operation completes, even
N	 * if it completes with a failure.
N	 * Callers are supposed to pass a callback function and wait for it
N	 * to be called before writing to the block.
N	 */
N	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
N
N	/* This stuff for eXecute-In-Place */
N	/* phys is optional and may be set to NULL */
N	int (*point) (struct mtd_info *mtd, loff_t from, size_t len,
N			size_t *retlen, void **virt, phys_addr_t *phys);
N
N	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
N	void (*unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
N
N
N	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
N
N	/* In blackbox flight recorder like scenarios we want to make successful
N	   writes in interrupt context. panic_write() is only intended to be
N	   called when its known the kernel is about to panic and we need the
N	   write to succeed. Since the kernel is not going to be running for much
N	   longer, this function can break locks and delay to ensure the write
N	   succeeds (but not sleep). */
N
N	int (*panic_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
N
N	int (*read_oob) (struct mtd_info *mtd, loff_t from,
N			 struct mtd_oob_ops *ops);
N	int (*write_oob) (struct mtd_info *mtd, loff_t to,
N			 struct mtd_oob_ops *ops);
N
N	/*
N	 * Methods to access the protection register area, present in some
N	 * flash devices. The user data is one time programmable but the
N	 * factory data is read only.
N	 */
N	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
N	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
N	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);
N
N	/* Sync */
N	void (*sync) (struct mtd_info *mtd);
N
N	/* Chip-supported device locking */
N	int (*lock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);
N	int (*unlock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);
N
N	/* Bad block management functions */
N	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
N	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
N
N	/* ECC status information */
N	struct mtd_ecc_stats ecc_stats;
N	/* Subpage shift (NAND) */
N	int subpage_sft;
N
N	void *priv;
N
N	struct module *owner;
N	int usecount;
N
N	/* If the driver is something smart, like UBI, it may need to maintain
N	 * its own reference counting. The below functions are only for driver.
N	 * The driver may register its callbacks. These callbacks are not
N	 * supposed to be called by MTD users */
N	int (*get_device) (struct mtd_info *mtd);
N	void (*put_device) (struct mtd_info *mtd);
N	u_char rw_oob;
N	u_char skipfirstblk;
N};
N
Nstatic __inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
N{
N	do_div(sz, mtd->erasesize);
X	(sz = sz/mtd->erasesize);
N	return sz;
N}
N
Nstatic __inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
N{
N	return do_div(sz, mtd->erasesize);
X	return (sz = sz/mtd->erasesize);
N}
N
N	/* Kernel-side ioctl definitions */
N
Nextern int add_mtd_device(struct mtd_info *mtd);
Nextern int del_mtd_device (struct mtd_info *mtd);
N
Nextern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
Nextern struct mtd_info *get_mtd_device_nm(const char *name);
N
Nextern void put_mtd_device(struct mtd_info *mtd);
Nextern void mtd_get_len_incl_bad(struct mtd_info *mtd, uint64_t offset,
N				 const uint64_t length, uint64_t *len_incl_bad,
N				 int *truncated);
N
Nvoid mtd_erase_callback(struct erase_info *instr);
N
N/*
N * Debugging macro and defines
N */
N#define MTD_DEBUG_LEVEL0	(0)	/* Quiet   */
N#define MTD_DEBUG_LEVEL1	(1)	/* Audible */
N#define MTD_DEBUG_LEVEL2	(2)	/* Loud    */
N#define MTD_DEBUG_LEVEL3	(3)	/* Noisy   */
N
N#ifdef CONFIG_MTD_DEBUG
S#define MTDDEBUG(n, args...)				\
S	do {						\
S		if (n <= CONFIG_MTD_DEBUG_VERBOSE)	\
S			sysprintf(KERN_INFO args);		\
S	} while(0)
X#define MTDDEBUG(n, args...)					do {								if (n <= CONFIG_MTD_DEBUG_VERBOSE)				sysprintf(KERN_INFO args);			} while(0)
N#else /* CONFIG_MTD_DEBUG */
N#define MTDDEBUG(n, args...)				\
N	do {						\
N		if (0)					\
N			sysprintf(args);		\
N	} while(0)
X#define MTDDEBUG(n, args...)					do {								if (0)								sysprintf(args);			} while(0)
N#endif /* CONFIG_MTD_DEBUG */
N
N#endif /* __MTD_MTD_H__ */
L 41 "..\..\common\src\BSP\ThirdParty\yaffs2\include\nand.h" 2
N#include "linux\nand.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 1
N/*
N *  linux/include/linux/mtd/nand.h
N *
N *  Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org>
N *                        Steven J. Hill <sjhill@realitydiluted.com>
N *		          Thomas Gleixner <tglx@linutronix.de>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N * Info:
N *	Contains standard defines and IDs for NAND flash devices
N *
N * Changelog:
N *	See git changelog.
N */
N#ifndef __LINUX_MTD_NAND_H
N#define __LINUX_MTD_NAND_H
N
N#include "config.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\config.h" 1
N#ifndef _LINUX_CONFIG_H
N#define _LINUX_CONFIG_H
N
N/* #include <linux/autoconf.h> */
N
N#endif
L 22 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 2
N
N#include "linux\mtd.h"
N#include "linux\bbm.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\bbm.h" 1
N/*
N *  linux/include/linux/mtd/bbm.h
N *
N *  NAND family Bad Block Management (BBM) header file
N *    - Bad Block Table (BBT) implementation
N *
N *  Copyright (c) 2005-2007 Samsung Electronics
N *  Kyungmin Park <kyungmin.park@samsung.com>
N *
N *  Copyright (c) 2000-2005
N *  Thomas Gleixner <tglx@linuxtronix.de>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License as published by
N * the Free Software Foundation; either version 2 of the License, or
N * (at your option) any later version.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
N *
N */
N#ifndef __LINUX_MTD_BBM_H
N#define __LINUX_MTD_BBM_H
N
N/* The maximum number of NAND chips in an array */
N#ifndef CONFIG_SYS_NAND_MAX_CHIPS
N#define CONFIG_SYS_NAND_MAX_CHIPS	1
N#endif
N
N/**
N * struct nand_bbt_descr - bad block table descriptor
N * @param options	options for this descriptor
N * @param pages		the page(s) where we find the bbt, used with
N *			option BBT_ABSPAGE when bbt is searched,
N *			then we store the found bbts pages here.
N *			Its an array and supports up to 8 chips now
N * @param offs		offset of the pattern in the oob area of the page
N * @param veroffs	offset of the bbt version counter in the oob are of the page
N * @param version	version read from the bbt page during scan
N * @param len		length of the pattern, if 0 no pattern check is performed
N * @param maxblocks	maximum number of blocks to search for a bbt. This number of
N *			blocks is reserved at the end of the device
N *			where the tables are written.
N * @param reserved_block_code	if non-0, this pattern denotes a reserved
N *			(rather than bad) block in the stored bbt
N * @param pattern	pattern to identify bad block table or factory marked
N *			good / bad blocks, can be NULL, if len = 0
N *
N * Descriptor for the bad block table marker and the descriptor for the
N * pattern which identifies good and bad blocks. The assumption is made
N * that the pattern and the version count are always located in the oob area
N * of the first block.
N */
Nstruct nand_bbt_descr {
N	int options;
N	int pages[CONFIG_SYS_NAND_MAX_CHIPS];
X	int pages[1];
N	int offs;
N	int veroffs;
N	uint8_t version[CONFIG_SYS_NAND_MAX_CHIPS];
X	uint8_t version[1];
N	int len;
N	int maxblocks;
N	int reserved_block_code;
N	uint8_t *pattern;
N};
N
N/* Options for the bad block table descriptors */
N
N/* The number of bits used per block in the bbt on the device */
N#define NAND_BBT_NRBITS_MSK	0x0000000F
N#define NAND_BBT_1BIT		0x00000001
N#define NAND_BBT_2BIT		0x00000002
N#define NAND_BBT_4BIT		0x00000004
N#define NAND_BBT_8BIT		0x00000008
N/* The bad block table is in the last good block of the device */
N#define NAND_BBT_LASTBLOCK	0x00000010
N/* The bbt is at the given page, else we must scan for the bbt */
N#define NAND_BBT_ABSPAGE	0x00000020
N/* The bbt is at the given page, else we must scan for the bbt */
N#define NAND_BBT_SEARCH		0x00000040
N/* bbt is stored per chip on multichip devices */
N#define NAND_BBT_PERCHIP	0x00000080
N/* bbt has a version counter at offset veroffs */
N#define NAND_BBT_VERSION	0x00000100
N/* Create a bbt if none exists */
N#define NAND_BBT_CREATE		0x00000200
N/* Search good / bad pattern through all pages of a block */
N#define NAND_BBT_SCANALLPAGES	0x00000400
N/* Scan block empty during good / bad block scan */
N#define NAND_BBT_SCANEMPTY	0x00000800
N/* Write bbt if neccecary */
N#define NAND_BBT_WRITE		0x00001000
N/* Read and write back block contents when writing bbt */
N#define NAND_BBT_SAVECONTENT	0x00002000
N/* Search good / bad pattern on the first and the second page */
N#define NAND_BBT_SCAN2NDPAGE	0x00004000
N/* Search good / bad pattern on the last page of the eraseblock */
N#define NAND_BBT_SCANLASTPAGE	0x00008000
N/* Chip stores bad block marker on BOTH 1st and 6th bytes of OOB */
N#define NAND_BBT_SCANBYTE1AND6 0x00100000
N/* The nand_bbt_descr was created dynamicaly and must be freed */
N#define NAND_BBT_DYNAMICSTRUCT 0x00200000
N/* The bad block table does not OOB for marker */
N#define NAND_BBT_NO_OOB		0x00400000
N
N/* The maximum number of blocks to scan for a bbt */
N#define NAND_BBT_SCAN_MAXBLOCKS	4
N
N/*
N * Constants for oob configuration
N */
N#define ONENAND_BADBLOCK_POS	0
N
N/*
N * Bad block scanning errors
N */
N#define ONENAND_BBT_READ_ERROR          1
N#define ONENAND_BBT_READ_ECC_ERROR      2
N#define ONENAND_BBT_READ_FATAL_ERROR    4
N
N/**
N * struct bbt_info - [GENERIC] Bad Block Table data structure
N * @param bbt_erase_shift	[INTERN] number of address bits in a bbt entry
N * @param badblockpos		[INTERN] position of the bad block marker in the oob area
N * @param bbt			[INTERN] bad block table pointer
N * @param badblock_pattern	[REPLACEABLE] bad block scan pattern used for initial bad block scan
N * @param priv			[OPTIONAL] pointer to private bbm date
N */
Nstruct bbm_info {
N	int bbt_erase_shift;
N	int badblockpos;
N	int options;
N
N	uint8_t *bbt;
N
N	int (*isbad_bbt) (struct mtd_info * mtd, loff_t ofs, int allowbbt);
N
N	/* TODO Add more NAND specific fileds */
N	struct nand_bbt_descr *badblock_pattern;
N
N	void *priv;
N};
N
N/* OneNAND BBT interface */
Nextern int onenand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
Nextern int onenand_default_bbt (struct mtd_info *mtd);
N
N#endif				/* __LINUX_MTD_BBM_H */
L 25 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 2
N
N
Nstruct mtd_info;
Nstruct nand_flash_dev;
N/* Scan and identify a NAND device */
Nextern int nand_scan (struct mtd_info *mtd, int max_chips);
N/* Separate phases of nand_scan(), allowing board driver to intervene
N * and override command or ECC setup according to flash type */
Nextern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
N			   const struct nand_flash_dev *table);
Nextern int nand_scan_tail(struct mtd_info *mtd);
N
N/* Free resources held by the NAND device */
Nextern void nand_release(struct mtd_info *mtd);
N
N/* Internal helper for board drivers which need to override command function */
Nextern void nand_wait_ready(struct mtd_info *mtd);
N
N/*
N * This constant declares the max. oobsize / page, which
N * is supported now. If you add a chip with bigger oobsize/page
N * adjust this accordingly.
N */
N#define NAND_MAX_OOBSIZE	576
N#define NAND_MAX_PAGESIZE	8192
N
N/*
N * Constants for hardware specific CLE/ALE/NCE function
N *
N * These are bits which can be or'ed to set/clear multiple
N * bits in one go.
N */
N/* Select the chip by setting nCE to low */
N#define NAND_NCE		0x01
N/* Select the command latch by setting CLE to high */
N#define NAND_CLE		0x02
N/* Select the address latch by setting ALE to high */
N#define NAND_ALE		0x04
N
N#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
N#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
N#define NAND_CTRL_CHANGE	0x80
N
N/*
N * Standard NAND flash commands
N */
N#define NAND_CMD_READ0		0
N#define NAND_CMD_READ1		1
N#define NAND_CMD_RNDOUT		5
N#define NAND_CMD_PAGEPROG	0x10
N#define NAND_CMD_READOOB	0x50
N#define NAND_CMD_ERASE1		0x60
N#define NAND_CMD_STATUS		0x70
N#define NAND_CMD_STATUS_MULTI	0x71
N#define NAND_CMD_SEQIN		0x80
N#define NAND_CMD_RNDIN		0x85
N#define NAND_CMD_READID		0x90
N#define NAND_CMD_ERASE2		0xd0
N#define NAND_CMD_PARAM		0xec
N#define NAND_CMD_RESET		0xff
N
N#define NAND_CMD_LOCK		0x2a
N#define NAND_CMD_LOCK_TIGHT	0x2c
N#define NAND_CMD_UNLOCK1	0x23
N#define NAND_CMD_UNLOCK2	0x24
N#define NAND_CMD_LOCK_STATUS	0x7a
N
N/* Extended commands for large page devices */
N#define NAND_CMD_READSTART	0x30
N#define NAND_CMD_RNDOUTSTART	0xE0
N#define NAND_CMD_CACHEDPROG	0x15
N
N/* Extended commands for AG-AND device */
N/*
N * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
N *       there is no way to distinguish that from NAND_CMD_READ0
N *       until the remaining sequence of commands has been completed
N *       so add a high order bit and mask it off in the command.
N */
N#define NAND_CMD_DEPLETE1	0x100
N#define NAND_CMD_DEPLETE2	0x38
N#define NAND_CMD_STATUS_MULTI	0x71
N#define NAND_CMD_STATUS_ERROR	0x72
N/* multi-bank error status (banks 0-3) */
N#define NAND_CMD_STATUS_ERROR0	0x73
N#define NAND_CMD_STATUS_ERROR1	0x74
N#define NAND_CMD_STATUS_ERROR2	0x75
N#define NAND_CMD_STATUS_ERROR3	0x76
N#define NAND_CMD_STATUS_RESET	0x7f
N#define NAND_CMD_STATUS_CLEAR	0xff
N
N#define NAND_CMD_NONE		-1
N
N/* Status bits */
N#define NAND_STATUS_FAIL	0x01
N#define NAND_STATUS_FAIL_N1	0x02
N#define NAND_STATUS_TRUE_READY	0x20
N#define NAND_STATUS_READY	0x40
N#define NAND_STATUS_WP		0x80
N
N/*
N * Constants for ECC_MODES
N */
Ntypedef enum {
N	NAND_ECC_NONE,
N	NAND_ECC_SOFT,
N	NAND_ECC_HW,
N	NAND_ECC_HW_SYNDROME,
N	NAND_ECC_HW_OOB_FIRST,
N	NAND_ECC_SOFT_BCH,
N} nand_ecc_modes_t;
N
N/*
N * Constants for Hardware ECC
N */
N/* Reset Hardware ECC for read */
N#define NAND_ECC_READ		0
N/* Reset Hardware ECC for write */
N#define NAND_ECC_WRITE		1
N/* Enable Hardware ECC before syndrom is read back from flash */
N#define NAND_ECC_READSYN	2
N
N/* Bit mask for flags passed to do_nand_read_ecc */
N#define NAND_GET_DEVICE		0x80
N
N
N/*
N * Option constants for bizarre disfunctionality and real
N * features.
N */
N/* Chip can not auto increment pages */
N#define NAND_NO_AUTOINCR	0x00000001
N/* Buswitdh is 16 bit */
N#define NAND_BUSWIDTH_16	0x00000002
N/* Device supports partial programming without padding */
N#define NAND_NO_PADDING		0x00000004
N/* Chip has cache program function */
N#define NAND_CACHEPRG		0x00000008
N/* Chip has copy back function */
N#define NAND_COPYBACK		0x00000010
N/*
N * AND Chip which has 4 banks and a confusing page / block
N * assignment. See Renesas datasheet for further information.
N */
N#define NAND_IS_AND		0x00000020
N/*
N * Chip has a array of 4 pages which can be read without
N * additional ready /busy waits.
N */
N#define NAND_4PAGE_ARRAY	0x00000040
N/*
N * Chip requires that BBT is periodically rewritten to prevent
N * bits from adjacent blocks from 'leaking' in altering data.
N * This happens with the Renesas AG-AND chips, possibly others.
N */
N#define BBT_AUTO_REFRESH	0x00000080
N/*
N * Chip does not require ready check on read. true
N * for all large page devices, as they do not support
N * autoincrement.
N */
N#define NAND_NO_READRDY		0x00000100
N/* Chip does not allow subpage writes */
N#define NAND_NO_SUBPAGE_WRITE	0x00000200
N
N/* Device is one of 'new' xD cards that expose fake nand command set */
N#define NAND_BROKEN_XD		0x00000400
N
N/* Device behaves just like nand, but is readonly */
N#define NAND_ROM		0x00000800
N
N/* Device supports subpage reads */
N#define NAND_SUBPAGE_READ       0x00001000
N
N/* Options valid for Samsung large page devices */
N#define NAND_SAMSUNG_LP_OPTIONS \
N	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
X#define NAND_SAMSUNG_LP_OPTIONS 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
N
N/* Macros to identify the above */
N#define NAND_CANAUTOINCR(chip) (!(chip->options & NAND_NO_AUTOINCR))
N#define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
N#define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
N#define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
N#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
N
N/* Non chip related options */
N/*
N * Use a flash based bad block table. OOB identifier is saved in OOB area.
N * This option is passed to the default bad block table function.
N */
N#define NAND_USE_FLASH_BBT	0x00010000
N/* This option skips the bbt scan during initialization. */
N#define NAND_SKIP_BBTSCAN	0x00020000
N/*
N * This option is defined if the board driver allocates its own buffers
N * (e.g. because it needs them DMA-coherent).
N */
N#define NAND_OWN_BUFFERS	0x00040000
N/* Chip may not exist, so silence any errors in scan */
N#define NAND_SCAN_SILENT_NODEV	0x00080000
N/*
N * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
N * the OOB area.
N */
N#define NAND_USE_FLASH_BBT_NO_OOB	0x00800000
N/* Create an empty BBT with no vendor information if the BBT is available */
N#define NAND_CREATE_EMPTY_BBT		0x01000000
N
N/* Options set by nand scan */
N/* bbt has already been read */
N#define NAND_BBT_SCANNED	0x40000000
N/* Nand scan has allocated controller struct */
N#define NAND_CONTROLLER_ALLOC	0x80000000
N
N/* Cell info constants */
N#define NAND_CI_CHIPNR_MSK	0x03
N#define NAND_CI_CELLTYPE_MSK	0x0C
N
N/* Keep gcc happy */
Nstruct nand_chip;
N
Nstruct nand_onfi_params {
N	/* rev info and features block */
N	/* 'O' 'N' 'F' 'I'  */
N	u8 sig[4];
N	__le16 revision;
N	__le16 features;
N	__le16 opt_cmd;
N	u8 reserved[22];
N
N	/* manufacturer information block */
N	char manufacturer[12];
N	char model[20];
N	u8 jedec_id;
N	__le16 date_code;
N	u8 reserved2[13];
N
N	/* memory organization block */
N	__le32 byte_per_page;
N	__le16 spare_bytes_per_page;
N	__le32 data_bytes_per_ppage;
N	__le16 spare_bytes_per_ppage;
N	__le32 pages_per_block;
N	__le32 blocks_per_lun;
N	u8 lun_count;
N	u8 addr_cycles;
N	u8 bits_per_cell;
N	__le16 bb_per_lun;
N	__le16 block_endurance;
N	u8 guaranteed_good_blocks;
N	__le16 guaranteed_block_endurance;
N	u8 programs_per_page;
N	u8 ppage_attr;
N	u8 ecc_bits;
N	u8 interleaved_bits;
N	u8 interleaved_ops;
N	u8 reserved3[13];
N
N	/* electrical parameter block */
N	u8 io_pin_capacitance_max;
N	__le16 async_timing_mode;
N	__le16 program_cache_timing_mode;
N	__le16 t_prog;
N	__le16 t_bers;
N	__le16 t_r;
N	__le16 t_ccs;
N	__le16 src_sync_timing_mode;
N	__le16 src_ssync_features;
N	__le16 clk_pin_capacitance_typ;
N	__le16 io_pin_capacitance_typ;
N	__le16 input_pin_capacitance_typ;
N	u8 input_pin_capacitance_max;
N	u8 driver_strenght_support;
N	__le16 t_int_r;
N	__le16 t_ald;
N	u8 reserved4[7];
N
N	/* vendor */
N	u8 reserved5[90];
N
N	__le16 crc;
N} __attribute__((packed));
N
N#define ONFI_CRC_BASE	0x4F4E
N
N/**
N * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
N * @lock:               protection lock
N * @active:		the mtd device which holds the controller currently
N * @wq:			wait queue to sleep on if a NAND operation is in
N *			progress used instead of the per chip wait queue
N *			when a hw controller is available.
N */
Nstruct nand_hw_control {
N/* XXX U-BOOT XXX */
N#if 0
S	spinlock_t	 lock;
S	wait_queue_head_t wq;
N#endif
N	struct nand_chip *active;
N};
N
N/**
N * struct nand_ecc_ctrl - Control structure for ecc
N * @mode:	ecc mode
N * @steps:	number of ecc steps per page
N * @size:	data bytes per ecc step
N * @bytes:	ecc bytes per step
N * @total:	total number of ecc bytes per page
N * @prepad:	padding information for syndrome based ecc generators
N * @postpad:	padding information for syndrome based ecc generators
N * @layout:	ECC layout control struct pointer
N * @priv:	pointer to private ecc control data
N * @hwctl:	function to control hardware ecc generator. Must only
N *		be provided if an hardware ECC is available
N * @calculate:	function for ecc calculation or readback from ecc hardware
N * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
N * @read_page_raw:	function to read a raw page without ECC
N * @write_page_raw:	function to write a raw page without ECC
N * @read_page:	function to read a page according to the ecc generator
N *		requirements.
N * @read_subpage:	function to read parts of the page covered by ECC.
N * @write_page:	function to write a page according to the ecc generator
N *		requirements.
N * @read_oob:	function to read chip OOB data
N * @write_oob:	function to write chip OOB data
N */
Nstruct nand_ecc_ctrl {
N	nand_ecc_modes_t mode;
N	int steps;
N	int size;
N	int bytes;
N	int total;
N	int prepad;
N	int postpad;
N	struct nand_ecclayout	*layout;
N	void *priv;
N	void (*hwctl)(struct mtd_info *mtd, int mode);
N	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
N			uint8_t *ecc_code);
N	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
N			uint8_t *calc_ecc);
N	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint8_t *buf, int page);
N	void (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf);
N	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint8_t *buf, int page);
N	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint32_t offs, uint32_t len, uint8_t *buf);
N	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf);
N	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
N			int sndcmd);
N	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
N			int page);
N};
N
N/**
N * struct nand_buffers - buffer structure for read/write
N * @ecccalc:	buffer for calculated ecc
N * @ecccode:	buffer for ecc read from flash
N * @databuf:	buffer for data - dynamically sized
N *
N * Do not change the order of buffers. databuf and oobrbuf must be in
N * consecutive order.
N */
Nstruct nand_buffers {
Nuint8_t ecccalc[NAND_MAX_OOBSIZE];
Xuint8_t ecccalc[576];
Nuint8_t ecccode[NAND_MAX_OOBSIZE];
Xuint8_t ecccode[576];
Nuint8_t databuf[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
Xuint8_t databuf[8192 + 576];
N};
N
N/**
N * struct nand_chip - NAND Private Flash Chip Data
N * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
N *			flash device
N * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
N *			flash device.
N * @read_byte:		[REPLACEABLE] read one byte from the chip
N * @read_word:		[REPLACEABLE] read one word from the chip
N * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
N * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
N * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip
N *			data.
N * @select_chip:	[REPLACEABLE] select chip nr
N * @block_bad:		[REPLACEABLE] check, if the block is bad
N * @block_markbad:	[REPLACEABLE] mark the block bad
N * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
N *			ALE/CLE/nCE. Also used to write command and address
N * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting
N *			mtd->oobsize, mtd->writesize and so on.
N *			@id_data contains the 8 bytes values of NAND_CMD_READID.
N *			Return with the bus width.
N * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing
N *			device ready/busy line. If set to NULL no access to
N *			ready/busy is available and the ready/busy information
N *			is read from the chip status register.
N * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
N *			commands to the chip.
N * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
N *			ready.
N * @ecc:		[BOARDSPECIFIC] ecc control ctructure
N * @buffers:		buffer structure for read/write
N * @hwcontrol:		platform-specific hardware control structure
N * @ops:		oob operation operands
N * @erase_cmd:		[INTERN] erase command write function, selectable due
N *			to AND support.
N * @scan_bbt:		[REPLACEABLE] function to scan bad block table
N * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
N *			data from array to read regs (tR).
N * @state:		[INTERN] the current state of the NAND device
N * @oob_poi:		poison value buffer
N * @page_shift:		[INTERN] number of address bits in a page (column
N *			address bits).
N * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
N * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
N * @chip_shift:		[INTERN] number of address bits in one chip
N * @options:		[BOARDSPECIFIC] various chip options. They can partly
N *			be set to inform nand_scan about special functionality.
N *			See the defines for further explanation.
N * @badblockpos:	[INTERN] position of the bad block marker in the oob
N *			area.
N * @badblockbits:	[INTERN] number of bits to left-shift the bad block
N *			number
N * @cellinfo:		[INTERN] MLC/multichip data from chip ident
N * @numchips:		[INTERN] number of physical chips
N * @chipsize:		[INTERN] the size of one chip for multichip arrays
N * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
N * @pagebuf:		[INTERN] holds the pagenumber which is currently in
N *			data_buf.
N * @subpagesize:	[INTERN] holds the subpagesize
N * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
N *			non 0 if ONFI supported.
N * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
N *			supported, 0 otherwise.
N * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
N * @bbt:		[INTERN] bad block table pointer
N * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
N *			lookup.
N * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
N * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
N *			bad block scan.
N * @controller:		[REPLACEABLE] a pointer to a hardware controller
N *			structure which is shared among multiple independend
N *			devices.
N * @priv:		[OPTIONAL] pointer to private chip date
N * @errstat:		[OPTIONAL] hardware specific function to perform
N *			additional error status checks (determine if errors are
N *			correctable).
N * @write_page:		[REPLACEABLE] High-level page write function
N */
N
Nstruct nand_chip {
N	void __iomem *IO_ADDR_R;
X	void  *IO_ADDR_R;
N	void __iomem *IO_ADDR_W;
X	void  *IO_ADDR_W;
N
N	uint8_t (*read_byte)(struct mtd_info *mtd);
N	u16 (*read_word)(struct mtd_info *mtd);
N	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
N	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
N	int (*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
N	void (*select_chip)(struct mtd_info *mtd, int chip);
N	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
N	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
N	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
N	int (*init_size)(struct mtd_info *mtd, struct nand_chip *this,
N			u8 *id_data);
N	int (*dev_ready)(struct mtd_info *mtd);
N	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
N			int page_addr);
N	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
N	void (*erase_cmd)(struct mtd_info *mtd, int page);
N	int (*scan_bbt)(struct mtd_info *mtd);
N	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
N			int status, int page);
N	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf, int page, int cached, int raw);
N
N	int chip_delay;
N	unsigned int options;
N
N	int page_shift;
N	int phys_erase_shift;
N	int bbt_erase_shift;
N	int chip_shift;
N	int numchips;
N	uint64_t chipsize;
N	int pagemask;
N	int pagebuf;
N	int subpagesize;
N	uint8_t cellinfo;
N	int badblockpos;
N	int badblockbits;
N
N	int onfi_version;
N#ifdef CONFIG_SYS_NAND_ONFI_DETECTION
S	struct nand_onfi_params onfi_params;
N#endif
N
N	int state;
N
N	uint8_t *oob_poi;
N	struct nand_hw_control *controller;
N	struct nand_ecclayout *ecclayout;
N
N	struct nand_ecc_ctrl ecc;
N	struct nand_buffers *buffers;
N	struct nand_hw_control hwcontrol;
N
N	struct mtd_oob_ops ops;
N
N	uint8_t *bbt;
N	struct nand_bbt_descr *bbt_td;
N	struct nand_bbt_descr *bbt_md;
N
N	struct nand_bbt_descr *badblock_pattern;
N
N	void *priv;
N};
N
N/*
N * NAND Flash Manufacturer ID Codes
N */
N#define NAND_MFR_TOSHIBA	0x98
N#define NAND_MFR_SAMSUNG	0xec
N#define NAND_MFR_FUJITSU	0x04
N#define NAND_MFR_NATIONAL	0x8f
N#define NAND_MFR_RENESAS	0x07
N#define NAND_MFR_STMICRO	0x20
N#define NAND_MFR_HYNIX		0xad
N#define NAND_MFR_MICRON		0x2c
N#define NAND_MFR_AMD		0x01
N
N/**
N * struct nand_flash_dev - NAND Flash Device ID Structure
N * @name:	Identify the device type
N * @id:		device ID code
N * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
N *		If the pagesize is 0, then the real pagesize
N *		and the eraseize are determined from the
N *		extended id bytes in the chip
N * @erasesize:	Size of an erase block in the flash device.
N * @chipsize:	Total chipsize in Mega Bytes
N * @options:	Bitfield to store chip relevant options
N */
Nstruct nand_flash_dev {
N	char *name;
N	int id;
N	unsigned long pagesize;
N	unsigned long chipsize;
N	unsigned long erasesize;
N	unsigned long options;
N};
N
N/**
N * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
N * @name:	Manufacturer name
N * @id:		manufacturer ID code of device.
N*/
Nstruct nand_manufacturers {
N	int id;
N	char *name;
N};
N
Nextern const struct nand_flash_dev nand_flash_ids[];
Nextern const struct nand_manufacturers nand_manuf_ids[];
N
Nextern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
Nextern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
Nextern int nand_default_bbt(struct mtd_info *mtd);
Nextern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
Nextern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
N			   int allowbbt);
Nextern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
N			size_t *retlen, uint8_t *buf);
N
N/*
N* Constants for oob configuration
N*/
N#define NAND_SMALL_BADBLOCK_POS		5
N#define NAND_LARGE_BADBLOCK_POS		0
N
N/**
N * struct platform_nand_chip - chip level device structure
N * @nr_chips:		max. number of chips to scan for
N * @chip_offset:	chip number offset
N * @nr_partitions:	number of partitions pointed to by partitions (or zero)
N * @partitions:		mtd partition list
N * @chip_delay:		R/B delay value in us
N * @options:		Option flags, e.g. 16bit buswidth
N * @ecclayout:		ecc layout info structure
N * @part_probe_types:	NULL-terminated array of probe types
N * @priv:		hardware controller specific settings
N */
Nstruct platform_nand_chip {
N	int nr_chips;
N	int chip_offset;
N	int nr_partitions;
N	struct mtd_partition *partitions;
N	struct nand_ecclayout *ecclayout;
N	int chip_delay;
N	unsigned int options;
N	const char **part_probe_types;
N	void *priv;
N};
N
N/* Keep gcc happy */
Nstruct platform_device;
N
N/**
N * struct platform_nand_ctrl - controller level device structure
N * @hwcontrol:		platform specific hardware control structure
N * @dev_ready:		platform specific function to read ready/busy pin
N * @select_chip:	platform specific chip select function
N * @cmd_ctrl:		platform specific function for controlling
N *			ALE/CLE/nCE. Also used to write command and address
N * @priv:		private data to transport driver specific settings
N *
N * All fields are optional and depend on the hardware driver requirements
N */
Nstruct platform_nand_ctrl {
N	void (*hwcontrol)(struct mtd_info *mtd, int cmd);
N	int (*dev_ready)(struct mtd_info *mtd);
N	void (*select_chip)(struct mtd_info *mtd, int chip);
N	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
N	void *priv;
N};
N
N/**
N * struct platform_nand_data - container structure for platform-specific data
N * @chip:		chip level chip structure
N * @ctrl:		controller level device structure
N */
Nstruct platform_nand_data {
N	struct platform_nand_chip chip;
N	struct platform_nand_ctrl ctrl;
N};
N
N/* Some helpers to access the data structures */
Nstatic __inline
Nstruct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
N{
N	struct nand_chip *chip = mtd->priv;
N
N	return chip->priv;
N}
N
N/* Standard NAND functions from nand_base.c */
Nvoid nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len);
Nvoid nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len);
Nvoid nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len);
Nvoid nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len);
Nuint8_t nand_read_byte(struct mtd_info *mtd);
N
N#endif /* __LINUX_MTD_NAND_H */
L 42 "..\..\common\src\BSP\ThirdParty\yaffs2\include\nand.h" 2
N
N#ifdef CONFIG_SYS_NAND_SELF_INIT
Svoid board_nand_init(void);
Sint nand_register(int devnum);
N#else
Nextern int board_nand_init(struct nand_chip *nand);
N#endif
N
Ntypedef struct mtd_info nand_info_t;
N
Nextern int nand_curr_device;
Nextern nand_info_t nand_info[];
N
Nstatic __inline int nand_read(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
N{
N	return info->read(info, ofs, *len, (size_t *)len, buf);
N}
N
Nstatic __inline int nand_write(nand_info_t *info, loff_t ofs, size_t *len, u_char *buf)
N{
N	return info->write(info, ofs, *len, (size_t *)len, buf);
N}
N
Nstatic __inline int nand_block_isbad(nand_info_t *info, loff_t ofs)
N{
N	return info->block_isbad(info, ofs);
N}
N
Nstatic __inline int nand_erase(nand_info_t *info, loff_t off, size_t size)
N{
N	struct erase_info instr;
N
N	instr.mtd = info;
N	instr.addr = off;
N	instr.len = size;
N	instr.callback = 0;
N
N	return info->erase(info, &instr);
N}
N
N
N/*****************************************************************************
N * declarations from nand_util.c
N ****************************************************************************/
N
Nstruct nand_write_options {
N	u_char *buffer;		/* memory block containing image to write */
N	ulong length;		/* number of bytes to write */
N	ulong offset;		/* start address in NAND */
N	int quiet;		/* don't display progress messages */
N	int autoplace;		/* if true use auto oob layout */
N	int forcejffs2;		/* force jffs2 oob layout */
N	int forceyaffs;		/* force yaffs oob layout */
N	int noecc;		/* write without ecc */
N	int writeoob;		/* image contains oob data */
N	int pad;		/* pad to page size */
N	int blockalign;		/* 1|2|4 set multiple of eraseblocks
N				 * to align to */
N};
N
Ntypedef struct nand_write_options nand_write_options_t;
Ntypedef struct mtd_oob_ops mtd_oob_ops_t;
N
Nstruct nand_read_options {
N	u_char *buffer;		/* memory block in which read image is written*/
N	ulong length;		/* number of bytes to read */
N	ulong offset;		/* start address in NAND */
N	int quiet;		/* don't display progress messages */
N	int readoob;		/* put oob data in image */
N};
N
Ntypedef struct nand_read_options nand_read_options_t;
N
Nstruct nand_erase_options {
N	loff_t length;		/* number of bytes to erase */
N	loff_t offset;		/* first address in NAND to erase */
N	int quiet;		/* don't display progress messages */
N	int jffs2;		/* if true: format for jffs2 usage
N				 * (write appropriate cleanmarker blocks) */
N	int scrub;		/* if true, really clean NAND by erasing
N				 * bad blocks (UNSAFE) */
N
N	/* Don't include skipped bad blocks in size to be erased */
N	int spread;
N};
N
Ntypedef struct nand_erase_options nand_erase_options_t;
N
Nint nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
N		       u_char *buffer);
N
N#define WITH_YAFFS_OOB	(1 << 0) /* whether write with yaffs format. This flag
N				  * is a 'mode' meaning it cannot be mixed with
N				  * other flags */
N#define WITH_DROP_FFS	(1 << 1) /* drop trailing all-0xff pages */
N
Nint nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
N			u_char *buffer, int flags);
Nint nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts);
Nint nand_torture(nand_info_t *nand, loff_t offset);
N
N#define NAND_LOCK_STATUS_TIGHT	0x01
N#define NAND_LOCK_STATUS_UNLOCK 0x04
N
Nint nand_lock(nand_info_t *meminfo, int tight);
Nint nand_unlock(nand_info_t *meminfo, loff_t start, size_t length,
N	int allexcept);
Nint nand_get_lock_status(nand_info_t *meminfo, loff_t offset);
N
Nint nand_spl_load_image(uint32_t offs, unsigned int size, void *dst);
Nvoid nand_deselect(void);
N
N#ifdef CONFIG_SYS_NAND_SELECT_DEVICE
Svoid board_nand_select_device(struct nand_chip *nand, int chip);
N#endif
N
N__attribute__((noreturn)) void nand_boot(void);
N
N#endif
N
N#ifdef CONFIG_ENV_OFFSET_OOB
S#define ENV_OOB_MARKER 0x30425645 /*"EVB0" in little-endian -- offset is stored
S				    as block number*/
S#define ENV_OOB_MARKER_OLD 0x30564e45 /*"ENV0" in little-endian -- offset is
S					stored as byte number */
S#define ENV_OFFSET_SIZE 8
Sint get_nand_env_oob(nand_info_t *nand, unsigned long *result);
N#endif
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c" 2
N#include "nuc970.h"
L 1 "..\..\common\src\BSP\Driver\Include\nuc970.h" 1
N/**************************************************************************//**
N * @file     nuc970.h
N * @version  V1.00
N * $Revision: 30 $
N * $Date: 15/06/12 2:51p $
N * @brief    NUC970 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro NUC970 MCU.
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro NUC970 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of NUC970 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N   */
N/**
N  * \page pg1 Revision History
N  *
N  * <b>Revision 1.00.000</b>
N  * \li Added 2D, CAN, CAP, JPEG, KPI, LCD, NAND, RTC, SC, SCUART drivers and sample codes
N  * \li Added USBH UAC class support
N  * \li Fixed compilation warnings
N  *
N  * <b>Revision 0.09.000</b>
N  * \li Preliminary release.
N*/
N#ifndef __NUC970_H__
N#define __NUC970_H__
N
N#include <stdint.h>
N
N/** @addtogroup NUC970_PERIPHERAL_MEM_MAP NUC970 Peripheral Memory Base
N  Memory Mapped Structure for NUC970 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N#define    CRPT_BA   0xB000F000  /*!< Crypto Engine Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    KPI_BA    0xB8008000  /*!< Keypad Interface Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N#define    MTP_BA    0xB800C000  /*!< MTP Control */
N
N/*@}*/ /* end of group NUC970_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup NUC970_Peripherals NUC970 Control Register
N  NUC970 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N/*---------------------- Cryptographic Accelerator -------------------------*/
N/**
N    @addtogroup CRYPTO Cryptographic Accelerator(CRYPTO)
N    Memory Mapped Structure for Cryptographic Accelerator registers
N@{ */
N
N/* Crypto Control Registers */
N#define     CRPT_INTEN          (CRPT_BA+0x000)  /*!< Crypto Interrupt Enable Control Register      */
N#define     CRPT_INTSTS         (CRPT_BA+0x004)  /*!< Crypto Interrupt Flag                         */
N
N/* PRNG Registers */
N#define     CRPT_PRNG_CTL       (CRPT_BA+0x008)  /*!< PRNG Control Register                         */
N#define     CRPT_PRNG_SEED      (CRPT_BA+0x00C)  /*!< Seed for PRNG                                 */
N#define     CRPT_PRNG_KEY0      (CRPT_BA+0x010)  /*!< PRNG Generated Key 0                          */
N#define     CRPT_PRNG_KEY1      (CRPT_BA+0x014)  /*!< PRNG Generated Key 1                          */
N#define     CRPT_PRNG_KEY2      (CRPT_BA+0x018)  /*!< PRNG Generated Key 2                          */
N#define     CRPT_PRNG_KEY3      (CRPT_BA+0x01C)  /*!< PRNG Generated Key 3                          */
N#define     CRPT_PRNG_KEY4      (CRPT_BA+0x020)  /*!< PRNG Generated Key 4                          */
N#define     CRPT_PRNG_KEY5      (CRPT_BA+0x024)  /*!< PRNG Generated Key 5                          */
N#define     CRPT_PRNG_KEY6      (CRPT_BA+0x028)  /*!< PRNG Generated Key 6                          */
N#define     CRPT_PRNG_KEY7      (CRPT_BA+0x02C)  /*!< PRNG Generated Key 7                          */
N
N/* AES/TDES feedback Registers */
N#define     CRPT_AES_FDBCK0     (CRPT_BA+0x050)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK1     (CRPT_BA+0x054)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK2     (CRPT_BA+0x058)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK3     (CRPT_BA+0x05C)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_TDES_FDBCKH    (CRPT_BA+0x060)  /*!< TDES/DES Engine Output Feedback High Word Data after Cryptographic Operation  */
N#define     CRPT_TDES_FDBCKL    (CRPT_BA+0x064)  /*!< TDES/DES Engine Output Feedback Low Word Data after Cryptographic Operation   */
N
N/* AES Control Registers */
N#define     CRPT_AES_CTL        (CRPT_BA+0x100)   /*!< AES Control Register                               */
N#define     CRPT_AES_STS        (CRPT_BA+0x104)   /*!< AES Engine Flag                                    */
N#define     CRPT_AES_DATIN      (CRPT_BA+0x108)   /*!< AES Engine Data Input Port Register                */
N#define     CRPT_AES_DATOUT     (CRPT_BA+0x10C)   /*!< AES Engine Data Output Port Register               */
N#define     CRPT_AES0_KEY0      (CRPT_BA+0x110)   /*!< AES Key Word 0 Register for Channel 0              */
N#define     CRPT_AES0_KEY1      (CRPT_BA+0x114)   /*!< AES Key Word 1 Register for Channel 0              */
N#define     CRPT_AES0_KEY2      (CRPT_BA+0x118)   /*!< AES Key Word 2 Register for Channel 0              */
N#define     CRPT_AES0_KEY3      (CRPT_BA+0x11C)   /*!< AES Key Word 3 Register for Channel 0              */
N#define     CRPT_AES0_KEY4      (CRPT_BA+0x120)   /*!< AES Key Word 4 Register for Channel 0              */
N#define     CRPT_AES0_KEY5      (CRPT_BA+0x124)   /*!< AES Key Word 5 Register for Channel 0              */
N#define     CRPT_AES0_KEY6      (CRPT_BA+0x128)   /*!< AES Key Word 6 Register for Channel 0              */
N#define     CRPT_AES0_KEY7      (CRPT_BA+0x12C)   /*!< AES Key Word 7 Register for Channel 0              */
N#define     CRPT_AES0_IV0       (CRPT_BA+0x130)   /*!< AES Initial Vector Word 0 Register for Channel 0   */
N#define     CRPT_AES0_IV1       (CRPT_BA+0x134)   /*!< AES Initial Vector Word 1 Register for Channel 0   */
N#define     CRPT_AES0_IV2       (CRPT_BA+0x138)   /*!< AES Initial Vector Word 2 Register for Channel 0   */
N#define     CRPT_AES0_IV3       (CRPT_BA+0x13C)   /*!< AES Initial Vector Word 3 Register for Channel 0   */
N#define     CRPT_AES0_SADDR     (CRPT_BA+0x140)   /*!< AES DMA Source Address Register for Channel 0      */
N#define     CRPT_AES0_DADDR     (CRPT_BA+0x144)   /*!< AES DMA Destination Address Register for Channel 0 */
N#define     CRPT_AES0_CNT       (CRPT_BA+0x148)   /*!< AES Byte Count Register for Channel 0              */
N#define     CRPT_AES1_KEY0      (CRPT_BA+0x14C)   /*!< AES Key Word 0 Register for Channel 1              */
N#define     CRPT_AES1_KEY1      (CRPT_BA+0x150)   /*!< AES Key Word 1 Register for Channel 1              */
N#define     CRPT_AES1_KEY2      (CRPT_BA+0x154)   /*!< AES Key Word 2 Register for Channel 1              */
N#define     CRPT_AES1_KEY3      (CRPT_BA+0x158)   /*!< AES Key Word 3 Register for Channel 1              */
N#define     CRPT_AES1_KEY4      (CRPT_BA+0x15C)   /*!< AES Key Word 4 Register for Channel 1              */
N#define     CRPT_AES1_KEY5      (CRPT_BA+0x160)   /*!< AES Key Word 5 Register for Channel 1              */
N#define     CRPT_AES1_KEY6      (CRPT_BA+0x164)   /*!< AES Key Word 6 Register for Channel 1              */
N#define     CRPT_AES1_KEY7      (CRPT_BA+0x168)   /*!< AES Key Word 7 Register for Channel 1              */
N#define     CRPT_AES1_IV0       (CRPT_BA+0x16C)   /*!< AES Initial Vector Word 0 Register for Channel 1   */
N#define     CRPT_AES1_IV1       (CRPT_BA+0x170)   /*!< AES Initial Vector Word 1 Register for Channel 1   */
N#define     CRPT_AES1_IV2       (CRPT_BA+0x174)   /*!< AES Initial Vector Word 2 Register for Channel 1   */
N#define     CRPT_AES1_IV3       (CRPT_BA+0x178)   /*!< AES Initial Vector Word 3 Register for Channel 1   */
N#define     CRPT_AES1_SADDR     (CRPT_BA+0x17C)   /*!< AES DMA Source Address Register for Channel 1      */
N#define     CRPT_AES1_DADDR     (CRPT_BA+0x180)   /*!< AES DMA Destination Address Register for Channel 1 */
N#define     CRPT_AES1_CNT       (CRPT_BA+0x184)   /*!< AES Byte Count Register for Channel 1              */
N#define     CRPT_AES2_KEY0      (CRPT_BA+0x188)   /*!< AES Key Word 0 Register for Channel 2              */
N#define     CRPT_AES2_KEY1      (CRPT_BA+0x18C)   /*!< AES Key Word 1 Register for Channel 2              */
N#define     CRPT_AES2_KEY2      (CRPT_BA+0x190)   /*!< AES Key Word 2 Register for Channel 2              */
N#define     CRPT_AES2_KEY3      (CRPT_BA+0x194)   /*!< AES Key Word 3 Register for Channel 2              */
N#define     CRPT_AES2_KEY4      (CRPT_BA+0x198)   /*!< AES Key Word 4 Register for Channel 2              */
N#define     CRPT_AES2_KEY5      (CRPT_BA+0x19C)   /*!< AES Key Word 5 Register for Channel 2              */
N#define     CRPT_AES2_KEY6      (CRPT_BA+0x1A0)   /*!< AES Key Word 6 Register for Channel 2              */
N#define     CRPT_AES2_KEY7      (CRPT_BA+0x1A4)   /*!< AES Key Word 7 Register for Channel 2              */
N#define     CRPT_AES2_IV0       (CRPT_BA+0x1A8)   /*!< AES Initial Vector Word 0 Register for Channel 2   */
N#define     CRPT_AES2_IV1       (CRPT_BA+0x1AC)   /*!< AES Initial Vector Word 1 Register for Channel 2   */
N#define     CRPT_AES2_IV2       (CRPT_BA+0x1B0)   /*!< AES Initial Vector Word 2 Register for Channel 2   */
N#define     CRPT_AES2_IV3       (CRPT_BA+0x1B4)   /*!< AES Initial Vector Word 3 Register for Channel 2   */
N#define     CRPT_AES2_SADDR     (CRPT_BA+0x1B8)   /*!< AES DMA Source Address Register for Channel 2      */
N#define     CRPT_AES2_DADDR     (CRPT_BA+0x1BC)   /*!< AES DMA Destination Address Register for Channel 2 */
N#define     CRPT_AES2_CNT       (CRPT_BA+0x1C0)   /*!< AES Byte Count Register for Channel 2              */
N#define     CRPT_AES3_KEY0      (CRPT_BA+0x1C4)   /*!< AES Key Word 0 Register for Channel 3              */
N#define     CRPT_AES3_KEY1      (CRPT_BA+0x1C8)   /*!< AES Key Word 1 Register for Channel 3              */
N#define     CRPT_AES3_KEY2      (CRPT_BA+0x1CC)   /*!< AES Key Word 2 Register for Channel 3              */
N#define     CRPT_AES3_KEY3      (CRPT_BA+0x1D0)   /*!< AES Key Word 3 Register for Channel 3              */
N#define     CRPT_AES3_KEY4      (CRPT_BA+0x1D4)   /*!< AES Key Word 4 Register for Channel 3              */
N#define     CRPT_AES3_KEY5      (CRPT_BA+0x1D8)   /*!< AES Key Word 5 Register for Channel 3              */
N#define     CRPT_AES3_KEY6      (CRPT_BA+0x1DC)   /*!< AES Key Word 6 Register for Channel 3              */
N#define     CRPT_AES3_KEY7      (CRPT_BA+0x1E0)   /*!< AES Key Word 7 Register for Channel 3              */
N#define     CRPT_AES3_IV0       (CRPT_BA+0x1E4)   /*!< AES Initial Vector Word 0 Register for Channel 3   */
N#define     CRPT_AES3_IV1       (CRPT_BA+0x1E8)   /*!< AES Initial Vector Word 1 Register for Channel 3   */
N#define     CRPT_AES3_IV2       (CRPT_BA+0x1EC)   /*!< AES Initial Vector Word 2 Register for Channel 3   */
N#define     CRPT_AES3_IV3       (CRPT_BA+0x1F0)   /*!< AES Initial Vector Word 3 Register for Channel 3   */
N#define     CRPT_AES3_SADDR     (CRPT_BA+0x1F4)   /*!< AES DMA Source Address Register for Channel 3      */
N#define     CRPT_AES3_DADDR     (CRPT_BA+0x1F8)   /*!< AES DMA Destination Address Register for Channel 3 */
N#define     CRPT_AES3_CNT       (CRPT_BA+0x1FC)   /*!< AES Byte Count Register for Channel 3              */
N
N/* DES/TDES Control Registers */
N#define     CRPT_TDES_CTL       (CRPT_BA+0x200)   /*!< TDES/DES Control Register                          */
N#define     CRPT_TDES_STS       (CRPT_BA+0x204)   /*!< TDES/DES Engine Flag                               */
N#define     CRPT_TDES0_KEY1H    (CRPT_BA+0x208)   /*!< TDES/DES Key 1 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY1L    (CRPT_BA+0x20C)   /*!< TDES/DES Key 1 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY2H    (CRPT_BA+0x210)   /*!< TDES/DES Key 2 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY2L    (CRPT_BA+0x214)   /*!< TDES/DES Key 2 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY3H    (CRPT_BA+0x218)   /*!< TDES/DES Key 3 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY3L    (CRPT_BA+0x21C)   /*!< TDES/DES Key 3 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_IVH      (CRPT_BA+0x220)   /*!< TDES/DES Initial Vector High Word Register for Channel 0 */
N#define     CRPT_TDES0_IVL      (CRPT_BA+0x224)   /*!< TDES/DES Initial Vector Low Word Register for Channel 0  */
N#define     CRPT_TDES0_SADDR    (CRPT_BA+0x228)   /*!< TDES/DES DMA Source Address Register for Channel 0       */
N#define     CRPT_TDES0_DADDR    (CRPT_BA+0x22C)   /*!< TDES/DES DMA Destination Address Register for Channel 0  */
N#define     CRPT_TDES0_CNT      (CRPT_BA+0x230)   /*!< TDES/DES Byte Count Register for Channel 0         */
N#define     CRPT_TDES_DATIN     (CRPT_BA+0x234)   /*!< TDES/DES Engine Input data Word Register           */
N#define     CRPT_TDES_DATOUT    (CRPT_BA+0x238)   /*!< TDES/DES Engine Output data Word Register          */
N#define     CRPT_TDES1_KEY1H    (CRPT_BA+0x248)   /*!< TDES/DES Key 1 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY1L    (CRPT_BA+0x24C)   /*!< TDES/DES Key 1 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY2H    (CRPT_BA+0x250)   /*!< TDES/DES Key 2 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY2L    (CRPT_BA+0x254)   /*!< TDES/DES Key 2 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY3H    (CRPT_BA+0x258)   /*!< TDES/DES Key 3 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY3L    (CRPT_BA+0x25C)   /*!< TDES/DES Key 3 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_IVH      (CRPT_BA+0x260)   /*!< TDES/DES Initial Vector High Word Register for Channel 1 */
N#define     CRPT_TDES1_IVL      (CRPT_BA+0x264)   /*!< TDES/DES Initial Vector Low Word Register for Channel 1  */
N#define     CRPT_TDES1_SADDR    (CRPT_BA+0x268)   /*!< TDES/DES DMA Source Address Register for Channel 1       */
N#define     CRPT_TDES1_DADDR    (CRPT_BA+0x26C)   /*!< TDES/DES DMA Destination Address Register for Channel 1  */
N#define     CRPT_TDES1_CNT      (CRPT_BA+0x270)   /*!< TDES/DES Byte Count Register for Channel 1         */
N#define     CRPT_TDES2_KEY1H    (CRPT_BA+0x288)   /*!< TDES/DES Key 1 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY1L    (CRPT_BA+0x28C)   /*!< TDES/DES Key 1 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY2H    (CRPT_BA+0x290)   /*!< TDES/DES Key 2 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY2L    (CRPT_BA+0x294)   /*!< TDES/DES Key 2 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY3H    (CRPT_BA+0x298)   /*!< TDES/DES Key 3 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY3L    (CRPT_BA+0x29C)   /*!< TDES/DES Key 3 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_IVH      (CRPT_BA+0x2A0)   /*!< TDES/DES Initial Vector High Word Register for Channel 2 */
N#define     CRPT_TDES2_IVL      (CRPT_BA+0x2A4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 2  */
N#define     CRPT_TDES2_SADDR    (CRPT_BA+0x2A8)   /*!< TDES/DES DMA Source Address Register for Channel 2       */
N#define     CRPT_TDES2_DADDR    (CRPT_BA+0x2AC)   /*!< TDES/DES DMA Destination Address Register for Channel 2  */
N#define     CRPT_TDES2_CNT      (CRPT_BA+0x2B0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N#define     CRPT_TDES3_KEY1H    (CRPT_BA+0x2C8)   /*!< TDES/DES Key 1 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY1L    (CRPT_BA+0x2CC)   /*!< TDES/DES Key 1 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY2H    (CRPT_BA+0x2D0)   /*!< TDES/DES Key 2 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY2L    (CRPT_BA+0x2D4)   /*!< TDES/DES Key 2 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY3H    (CRPT_BA+0x2D8)   /*!< TDES/DES Key 3 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY3L    (CRPT_BA+0x2DC)   /*!< TDES/DES Key 3 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_IVH      (CRPT_BA+0x2E0)   /*!< TDES/DES Initial Vector High Word Register for Channel 3 */
N#define     CRPT_TDES3_IVL      (CRPT_BA+0x2E4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 3  */
N#define     CRPT_TDES3_SADDR    (CRPT_BA+0x2E8)   /*!< TDES/DES DMA Source Address Register for Channel 3       */
N#define     CRPT_TDES3_DADDR    (CRPT_BA+0x2EC)   /*!< TDES/DES DMA Destination Address Register for Channel 3  */
N#define     CRPT_TDES3_CNT      (CRPT_BA+0x2F0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N
N/* SHA/HMAC Control Registers */
N#define     CRPT_HMAC_CTL       (CRPT_BA+0x300)   /*!< SHA/HMAC Control Register                          */
N#define     CRPT_HMAC_STS       (CRPT_BA+0x304)   /*!< SHA/HMAC Status Flag                               */
N#define     CRPT_HMAC_DGST0     (CRPT_BA+0x308)   /*!< SHA/HMAC Digest Message 0                          */
N#define     CRPT_HMAC_DGST1     (CRPT_BA+0x30C)   /*!< SHA/HMAC Digest Message 1                          */
N#define     CRPT_HMAC_DGST2     (CRPT_BA+0x310)   /*!< SHA/HMAC Digest Message 2                          */
N#define     CRPT_HMAC_DGST3     (CRPT_BA+0x314)   /*!< SHA/HMAC Digest Message 3                          */
N#define     CRPT_HMAC_DGST4     (CRPT_BA+0x318)   /*!< SHA/HMAC Digest Message 4                          */
N#define     CRPT_HMAC_DGST5     (CRPT_BA+0x31C)   /*!< SHA/HMAC Digest Message 5                          */
N#define     CRPT_HMAC_DGST6     (CRPT_BA+0x320)   /*!< SHA/HMAC Digest Message 6                          */
N#define     CRPT_HMAC_DGST7     (CRPT_BA+0x324)   /*!< SHA/HMAC Digest Message 7                          */
N#define     CRPT_HMAC_DGST8     (CRPT_BA+0x328)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST9     (CRPT_BA+0x32C)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST10    (CRPT_BA+0x330)   /*!< SHA/HMAC Digest Message 10                         */
N#define     CRPT_HMAC_DGST11    (CRPT_BA+0x334)   /*!< SHA/HMAC Digest Message 11                         */
N#define     CRPT_HMAC_DGST12    (CRPT_BA+0x338)   /*!< SHA/HMAC Digest Message 12                         */
N#define     CRPT_HMAC_DGST13    (CRPT_BA+0x33C)   /*!< SHA/HMAC Digest Message 13                         */
N#define     CRPT_HMAC_DGST14    (CRPT_BA+0x340)   /*!< SHA/HMAC Digest Message 14                         */
N#define     CRPT_HMAC_DGST15    (CRPT_BA+0x344)   /*!< SHA/HMAC Digest Message 15                         */
N#define     CRPT_HMAC_KEYCNT    (CRPT_BA+0x348)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_SADDR     (CRPT_BA+0x34C)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_DMACNT    (CRPT_BA+0x350)   /*!< SHA/HMAC Byte Count Register                       */
N#define     CRPT_HMAC_DATIN     (CRPT_BA+0x354)   /*!< SHA/HMAC Engine Non-DMA Mode Data Input Port Register  */
N
N/**@}*/ /* end of Cryptographic Accelerator register group */
N
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Keypad Interface -------------------------*/
N/**
N    @addtogroup KPI Keypad Interface(KPI)
N    Memory Mapped Structure for KPI Controller
N@{ */
N
N#define     REG_KPI_CONF    (KPI_BA+0x00)  /*!< Keypad controller configuration Register */
N#define     REG_KPI_3KCONF  (KPI_BA+0x04)  /*!< Keypad controller 3-keys configuration register */
N#define     REG_KPI_STATUS  (KPI_BA+0x08)  /*!< Keypad status register */
N#define     REG_KPI_RSTC    (KPI_BA+0x0C)  /*!< Keypad  Reset Period Controller register */
N#define     REG_KPI_KEST        (KPI_BA+0x10)  /*!< Keypad Key State Indicator */
N#define     REG_KPI_KPE         (KPI_BA+0x18)  /*!< Press Key Event Indicator */
N#define     REG_KPI_KRE         (KPI_BA+0x20)  /*!< Release Key Event Indicator */
N#define     REG_KPI_PRESCALDIV  (KPI_BA+0x28)  /*!< Pre-Scale Divider */
N
N/**@}*/ /* end of KPI register group */
N
N
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- Multi-Time Programmable Controller --------------------*/
N/**
N    @addtogroup MTP Multi-Time Programmable Controller (MTP)
N    Memory Mapped Structure for MTP Controller
N@{ */
N
N#define     MTP_KEYEN           (MTP_BA+0x000)   /*!< MTP Key Enable Register                       */
N#define     MTP_USERDATA        (MTP_BA+0x00C)   /*!< MTP User Defined Data Register                */
N#define     MTP_KEY0            (MTP_BA+0x010)   /*!< MTP KEY 0 Register                            */
N#define     MTP_KEY1            (MTP_BA+0x014)   /*!< MTP KEY 1 Register                            */
N#define     MTP_KEY2            (MTP_BA+0x018)   /*!< MTP KEY 2 Register                            */
N#define     MTP_KEY3            (MTP_BA+0x01C)   /*!< MTP KEY 3 Register                            */
N#define     MTP_KEY4            (MTP_BA+0x020)   /*!< MTP KEY 4 Register                            */
N#define     MTP_KEY5            (MTP_BA+0x024)   /*!< MTP KEY 5 Register                            */
N#define     MTP_KEY6            (MTP_BA+0x028)   /*!< MTP KEY 6 Register                            */
N#define     MTP_KEY7            (MTP_BA+0x02C)   /*!< MTP KEY 7 Register                            */
N#define     MTP_PCYCLE          (MTP_BA+0x030)   /*!< MTP Program Cycle Program Count Register      */
N#define     MTP_CTL             (MTP_BA+0x034)   /*!< MTP Control Register                          */
N#define     MTP_PSTART          (MTP_BA+0x038)   /*!< MTP Program Start Registe                     */
N#define     MTP_STATUS          (MTP_BA+0x040)   /*!< MTP Status Registe                            */
N#define     MTP_REGLCTL         (MTP_BA+0x050)   /*!< MTP Register Write-Protection Control Register*/
N
N/**@}*/ /* end of MTP register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group NUC970_Peripherals */
N
N
N/** @addtogroup NUC970_IO_ROUTINE NUC970 I/O Routines
N  The Declaration of NUC970 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group NUC970_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup NUC970_legacy_Constants NUC970 Legacy Constants
N  NUC970 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define SPECIAL        (2)
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __NUC970_H__ */
N
N/*@}*/ /* end of group NUC970_legacy_Constants */
L 14 "..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c" 2
N#include "sys.h"
L 1 "..\..\common\src\BSP\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @version  V1.00
N* $Revision: 6 $
N* $Date: 15/06/12 9:25a $
N* @brief    NUC970 SYS driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  NUC970 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    CRPT_IRQn               = 35,      /*!< Cryptographic Accelerator Interrupt        */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N    KPI_IRQn                = 61,      /*!< KPI Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N/* Define constants for use external IO in service parameters.  */
N#define EXT0            0
N#define EXT1            1
N#define EXT2            2
N#define EXT3            3
N#define EXT4            4
N
N#define SIZE_256K       4
N#define SIZE_512K       5
N#define SIZE_1M         6
N#define SIZE_2M         7
N#define SIZE_4M         8
N#define SIZE_8M         9
N#define SIZE_16M        10
N#define SIZE_32M        11
N
N#define BUS_DISABLE     12
N#define BUS_BIT_8       13
N#define BUS_BIT_16      14
N#define BUS_BIT_32      15
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    setPrintfFlag(BOOL flag);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    terninalPrintf(PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
N/* Define system library External IO functions */
NINT32   sysSetExternalIO(INT extNo, UINT32 extBaseAddr, UINT32 extSize, INT extBusWidth); /*!< set External IO \hideinitializer */
NINT32   sysSetExternalIOTiming1(INT extNo, INT tACC, INT tACS); /*!< set External IO timing1 \hideinitializer */
NINT32   sysSetExternalIOTiming2(INT extNo, INT tCOH, INT tCOS); /*!< set External IO timing2 \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_SYS_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
L 15 "..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c" 2
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_FMI_NAND_Driver FMI NAND Driver
N  @{
N*/
N
N
N/** @addtogroup NUC970_FMI_NAND_EXPORTED_FUNCTIONS FMI NAND Exported Functions
N  @{
N*/
N/// @cond HIDDEN_SYMBOLS
N
N
Nextern void sysPutString(char *string);
Nextern void sysprintf(char* pcStr,...);
N
N#define NAND_EN     0x08
N#define READYBUSY   (0x01 << 18)
N#define ENDADDR     (0x80000000)
N
N/*-----------------------------------------------------------------------------
N * Define some constants for BCH
N *---------------------------------------------------------------------------*/
N// define the total padding bytes for 512/1024 data segment
N#define BCH_PADDING_LEN_512     32
N#define BCH_PADDING_LEN_1024    64
N// define the BCH parity code lenght for 512 bytes data pattern
N#define BCH_PARITY_LEN_T4  8
N#define BCH_PARITY_LEN_T8  15
N#define BCH_PARITY_LEN_T12 23
N#define BCH_PARITY_LEN_T15 29
N// define the BCH parity code lenght for 1024 bytes data pattern
N#define BCH_PARITY_LEN_T24 45
N
N
N#define BCH_T15   0x00400000
N#define BCH_T12   0x00200000
N#define BCH_T8    0x00100000
N#define BCH_T4    0x00080000
N#define BCH_T24   0x00040000
N
N
Nstruct nuc970_nand_info {
N    struct nand_hw_control  controller;
N    struct mtd_info         mtd;
N    struct nand_chip        chip;
N    int                     eBCHAlgo;
N    int                     m_i32SMRASize;
N};
Nstruct nuc970_nand_info g_nuc970_nand;
Nstruct nuc970_nand_info *nuc970_nand;
N
Nstatic struct nand_ecclayout nuc970_nand_oob;
N
Nstatic const int g_i32BCHAlgoIdx[5] = { BCH_T4, BCH_T8, BCH_T12, BCH_T15, BCH_T24 };
Xstatic const int g_i32BCHAlgoIdx[5] = { 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00040000 };
Nstatic const int g_i32ParityNum[4][5] = {
N    { 8,    15,     23,     29,     -1  },  // For 512
N    { 32,   60,     92,     116,    90  },  // For 2K
N    { 64,   120,    184,    232,    180 },  // For 4K
N    { 128,  240,    368,    464,    360 },  // For 8K
N};
N
Nvoid udelay(unsigned int tick)
N{
N    int volatile start;
N    start = sysGetTicks(TIMER0);
X    start = sysGetTicks(0);
N    while(1)
N        if ((sysGetTicks(TIMER0) - start) > tick)
X        if ((sysGetTicks(0) - start) > tick)
N            break;
N}
N
Nunsigned int get_timer(unsigned int tick)
N{
N    return (sysGetTicks(TIMER0) - tick);
X    return (sysGetTicks(0) - tick);
N}
N
Nstatic void nuc970_layout_oob_table ( struct nand_ecclayout* pNandOOBTbl, int oobsize , int eccbytes )
N{
N    pNandOOBTbl->eccbytes = eccbytes;
N
N    pNandOOBTbl->oobavail = oobsize - 4 - eccbytes ;
N
N    pNandOOBTbl->oobfree[0].offset = 4;  // Bad block marker size
N
N    pNandOOBTbl->oobfree[0].length = oobsize - eccbytes - pNandOOBTbl->oobfree[0].offset ;
N}
N
N
Nstatic void nuc970_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
N{
N    struct nand_chip *chip = mtd->priv;
N
N    if (ctrl & NAND_CTRL_CHANGE) {
X    if (ctrl & 0x80) {
N        ulong IO_ADDR_W = (ulong)REG_NANDDATA;
X        ulong IO_ADDR_W = (ulong)(0xB000D000+0x8B8);
N
N        if ((ctrl & NAND_CLE))
X        if ((ctrl & 0x02))
N            IO_ADDR_W = REG_NANDCMD;
X            IO_ADDR_W = (0xB000D000+0x8B0);
N        if ((ctrl & NAND_ALE))
X        if ((ctrl & 0x04))
N            IO_ADDR_W = REG_NANDADDR;
X            IO_ADDR_W = (0xB000D000+0x8B4);
N
N        chip->IO_ADDR_W = (void *)IO_ADDR_W;
N    }
N
N    if (cmd != NAND_CMD_NONE)
X    if (cmd != -1)
N        outpb(chip->IO_ADDR_W, cmd);
X        *((volatile unsigned char *)(chip->IO_ADDR_W)) = cmd;
N}
N
N
N/* select chip */
Nstatic void nuc970_nand_select_chip(struct mtd_info *mtd, int chip)
N{
N    outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x06000000))|0x04000000;
N}
N
N
Nstatic int nuc970_dev_ready(struct mtd_info *mtd)
N{
N    return ((inpw(REG_NANDINTSTS) & READYBUSY) ? 1 : 0);
X    return (((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & (0x01 << 18)) ? 1 : 0);
N}
N
N
Nstatic void nuc970_nand_command(struct mtd_info *mtd, unsigned int command, int column, int page_addr)
N{
N    register struct nand_chip *chip = mtd->priv;
N    int volatile i;
N
N    if (command == NAND_CMD_READOOB) {
X    if (command == 0x50) {
N        column += mtd->writesize;
N        command = NAND_CMD_READ0;
X        command = 0;
N    }
N
N    outpw(REG_NANDCMD, command & 0xff);
X    *((volatile unsigned int *)((0xB000D000+0x8B0))) = command & 0xff;
N
N    if (column != -1 || page_addr != -1) {
N        if (column != -1) {
N            outpw(REG_NANDADDR, column&0xff);
X            *((volatile unsigned int *)((0xB000D000+0x8B4))) = column&0xff;
N            if ( page_addr != -1 )
N                outpw(REG_NANDADDR, column >> 8);
X                *((volatile unsigned int *)((0xB000D000+0x8B4))) = column >> 8;
N            else
N                outpw(REG_NANDADDR, (column >> 8) | ENDADDR);
X                *((volatile unsigned int *)((0xB000D000+0x8B4))) = (column >> 8) | (0x80000000);
N        }
N
N        if (page_addr != -1) {
N            outpw(REG_NANDADDR, page_addr&0xFF);
X            *((volatile unsigned int *)((0xB000D000+0x8B4))) = page_addr&0xFF;
N
N            if ( chip->chipsize > (128 << 20) ) {
N                outpw(REG_NANDADDR, (page_addr >> 8)&0xFF);
X                *((volatile unsigned int *)((0xB000D000+0x8B4))) = (page_addr >> 8)&0xFF;
N                outpw(REG_NANDADDR, ((page_addr >> 16)&0xFF)|ENDADDR);
X                *((volatile unsigned int *)((0xB000D000+0x8B4))) = ((page_addr >> 16)&0xFF)|(0x80000000);
N            } else {
N                outpw(REG_NANDADDR, ((page_addr >> 8)&0xFF)|ENDADDR);
X                *((volatile unsigned int *)((0xB000D000+0x8B4))) = ((page_addr >> 8)&0xFF)|(0x80000000);
N            }
N        }
N    }
N
N    switch (command) {
N    case NAND_CMD_CACHEDPROG:
X    case 0x15:
N    case NAND_CMD_PAGEPROG:
X    case 0x10:
N    case NAND_CMD_ERASE1:
X    case 0x60:
N    case NAND_CMD_ERASE2:
X    case 0xd0:
N    case NAND_CMD_SEQIN:
X    case 0x80:
N    case NAND_CMD_RNDIN:
X    case 0x85:
N    case NAND_CMD_STATUS:
X    case 0x70:
N        return;
N
N    case NAND_CMD_RESET:
X    case 0xff:
N        if (chip->dev_ready)
N            break;
N
N        if ( chip->chip_delay )
N            for (i=0; i<chip->chip_delay; i++);
N
N        outpw(REG_NANDCMD, NAND_CMD_STATUS);
X        *((volatile unsigned int *)((0xB000D000+0x8B0))) = 0x70;
N        outpw(REG_NANDCMD, command);
X        *((volatile unsigned int *)((0xB000D000+0x8B0))) = command;
N
N        while (!(inpw(REG_NANDINTSTS) & READYBUSY));
X        while (!((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & (0x01 << 18)));
N        return;
N
N    case NAND_CMD_RNDOUT:
X    case 5:
N        outpw(REG_NANDCMD, NAND_CMD_RNDOUTSTART);
X        *((volatile unsigned int *)((0xB000D000+0x8B0))) = 0xE0;
N        for (i=0; i<10; i++);
N        return;
N
N    case NAND_CMD_READ0:
X    case 0:
N        outpw(REG_NANDCMD, NAND_CMD_READSTART);
X        *((volatile unsigned int *)((0xB000D000+0x8B0))) = 0x30;
N        break;
N    default:
N        if (!chip->dev_ready) {
N            if ( chip->chip_delay )
N                for (i=0; i<chip->chip_delay; i++);
N            return;
N        }
N    }
N
N    while (!(inpw(REG_NANDINTSTS) & READYBUSY)) ;
X    while (!((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & (0x01 << 18))) ;
N
N}
N
N/*
N * nuc970_nand_read_byte - read a byte from NAND controller into buffer
N * @mtd: MTD device structure
N */
Nstatic unsigned char nuc970_nand_read_byte(struct mtd_info *mtd)
N{
N    return ((unsigned char)inpw(REG_NANDDATA));
X    return ((unsigned char)(*((volatile unsigned int *)((0xB000D000+0x8B8)))));
N}
N
N/*
N * nuc970_nand_write_buf - write data from buffer into NAND controller
N * @mtd: MTD device structure
N * @buf: virtual address in RAM of source
N * @len: number of data bytes to be transferred
N */
N
Nstatic void nuc970_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
N{
N    int i;
N
N    for (i = 0; i < len; i++)
N        outpw(REG_NANDDATA, buf[i]);
X        *((volatile unsigned int *)((0xB000D000+0x8B8))) = buf[i];
N}
N
N/*
N * nuc970_nand_read_buf - read data from NAND controller into buffer
N * @mtd: MTD device structure
N * @buf: virtual address in RAM of source
N * @len: number of data bytes to be transferred
N */
Nstatic void nuc970_nand_read_buf(struct mtd_info *mtd, unsigned char *buf, int len)
N{
N    int i;
N
N    for (i = 0; i < len; i++)
N        buf[i] = (unsigned char)inpw(REG_NANDDATA);
X        buf[i] = (unsigned char)(*((volatile unsigned int *)((0xB000D000+0x8B8))));
N}
N
N
N/*
N * Enable HW ECC : unused on most chips
N */
Nvoid nuc970_nand_enable_hwecc(struct mtd_info *mtd, int mode)
N{
N}
N
N/*
N * Calculate HW ECC
N * function called after a write
N * mtd:        MTD block structure
N * dat:        raw data (unused)
N * ecc_code:   buffer for ECC
N */
Nstatic int nuc970_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
N{
N    return 0;
N}
N
N/*
N * HW ECC Correction
N * function called after a read
N * mtd:        MTD block structure
N * dat:        raw data read from the chip
N * read_ecc:   ECC from the chip (unused)
N * isnull:     unused
N */
Nstatic int nuc970_nand_correct_data(struct mtd_info *mtd, u_char *dat,
N                     u_char *read_ecc, u_char *calc_ecc)
N{
N    return 0;
N}
N
N
N/*-----------------------------------------------------------------------------
N * Correct data by BCH alrogithm.
N *      Support 8K page size NAND and BCH T4/8/12/15/24.
N *---------------------------------------------------------------------------*/
Nvoid fmiSM_CorrectData_BCH(u8 ucFieidIndex, u8 ucErrorCnt, u8* pDAddr)
N{
N    u32 uaData[24], uaAddr[24];
N    u32 uaErrorData[4];
N    u8  ii, jj;
N    u32 uPageSize;
N    u32 field_len, padding_len, parity_len;
N    u32 total_field_num;
N    u8  *smra_index;
N
N    //--- assign some parameters for different BCH and page size
N    switch (inpw(REG_NANDCTL) & 0x007C0000)
X    switch ((*((volatile unsigned int *)((0xB000D000+0x8A0)))) & 0x007C0000)
N    {
N        case BCH_T24:
X        case 0x00040000:
N            field_len   = 1024;
N            padding_len = BCH_PADDING_LEN_1024;
X            padding_len = 64;
N            parity_len  = BCH_PARITY_LEN_T24;
X            parity_len  = 45;
N            break;
N        case BCH_T15:
X        case 0x00400000:
N            field_len   = 512;
N            padding_len = BCH_PADDING_LEN_512;
X            padding_len = 32;
N            parity_len  = BCH_PARITY_LEN_T15;
X            parity_len  = 29;
N            break;
N        case BCH_T12:
X        case 0x00200000:
N            field_len   = 512;
N            padding_len = BCH_PADDING_LEN_512;
X            padding_len = 32;
N            parity_len  = BCH_PARITY_LEN_T12;
X            parity_len  = 23;
N            break;
N        case BCH_T8:
X        case 0x00100000:
N            field_len   = 512;
N            padding_len = BCH_PADDING_LEN_512;
X            padding_len = 32;
N            parity_len  = BCH_PARITY_LEN_T8;
X            parity_len  = 15;
N            break;
N        case BCH_T4:
X        case 0x00080000:
N            field_len   = 512;
N            padding_len = BCH_PADDING_LEN_512;
X            padding_len = 32;
N            parity_len  = BCH_PARITY_LEN_T4;
X            parity_len  = 8;
N            break;
N        default:
N            return;
N    }
N
N    uPageSize = inpw(REG_NANDCTL) & 0x00030000;
X    uPageSize = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) & 0x00030000;
N    switch (uPageSize)
N    {
N        case 0x30000: total_field_num = 8192 / field_len; break;
N        case 0x20000: total_field_num = 4096 / field_len; break;
N        case 0x10000: total_field_num = 2048 / field_len; break;
N        case 0x00000: total_field_num =  512 / field_len; break;
N        default:
N            return;
N    }
N
N    //--- got valid BCH_ECC_DATAx and parse them to uaData[]
N    // got the valid register number of BCH_ECC_DATAx since one register include 4 error bytes
N    jj = ucErrorCnt/4;
N    jj ++;
N    if (jj > 6)
N        jj = 6;     // there are 6 BCH_ECC_DATAx registers to support BCH T24
N
N    for(ii=0; ii<jj; ii++)
N    {
N        uaErrorData[ii] = inpw(REG_NANDECCED0 + ii*4);
X        uaErrorData[ii] = (*((volatile unsigned int *)((0xB000D000+0x960) + ii*4)));
N    }
N
N    for(ii=0; ii<jj; ii++)
N    {
N        uaData[ii*4+0] = uaErrorData[ii] & 0xff;
N        uaData[ii*4+1] = (uaErrorData[ii]>>8) & 0xff;
N        uaData[ii*4+2] = (uaErrorData[ii]>>16) & 0xff;
N        uaData[ii*4+3] = (uaErrorData[ii]>>24) & 0xff;
N    }
N
N    //--- got valid REG_BCH_ECC_ADDRx and parse them to uaAddr[]
N    // got the valid register number of REG_BCH_ECC_ADDRx since one register include 2 error addresses
N    jj = ucErrorCnt/2;
N    jj ++;
N    if (jj > 12)
N        jj = 12;    // there are 12 REG_BCH_ECC_ADDRx registers to support BCH T24
N
N    for(ii=0; ii<jj; ii++)
N    {
N        uaAddr[ii*2+0] = inpw(REG_NANDECCEA0 + ii*4) & 0x07ff;   // 11 bits for error address
X        uaAddr[ii*2+0] = (*((volatile unsigned int *)((0xB000D000+0x900) + ii*4))) & 0x07ff;   
N        uaAddr[ii*2+1] = (inpw(REG_NANDECCEA0 + ii*4)>>16) & 0x07ff;
X        uaAddr[ii*2+1] = ((*((volatile unsigned int *)((0xB000D000+0x900) + ii*4)))>>16) & 0x07ff;
N    }
N
N    //--- pointer to begin address of field that with data error
N    pDAddr += (ucFieidIndex-1) * field_len;
N
N    //--- correct each error bytes
N    for(ii=0; ii<ucErrorCnt; ii++)
N    {
N        // for wrong data in field
N        if (uaAddr[ii] < field_len)
N        {
N            *(pDAddr+uaAddr[ii]) ^= uaData[ii];
N        }
N        // for wrong first-3-bytes in redundancy area
N        else if (uaAddr[ii] < (field_len+3))
N        {
N            uaAddr[ii] -= field_len;
N            uaAddr[ii] += (parity_len*(ucFieidIndex-1));    // field offset
N            *((u8 *)REG_NANDRA0 + uaAddr[ii]) ^= uaData[ii];
X            *((u8 *)(0xB000D000+0xA00) + uaAddr[ii]) ^= uaData[ii];
N        }
N        // for wrong parity code in redundancy area
N        else
N        {
N            // BCH_ERR_ADDRx = [data in field] + [3 bytes] + [xx] + [parity code]
N            //                                   |<--     padding bytes      -->|
N            // The BCH_ERR_ADDRx for last parity code always = field size + padding size.
N            // So, the first parity code = field size + padding size - parity code length.
N            // For example, for BCH T12, the first parity code = 512 + 32 - 23 = 521.
N            // That is, error byte address offset within field is
N            uaAddr[ii] = uaAddr[ii] - (field_len + padding_len - parity_len);
N
N            // smra_index point to the first parity code of first field in register SMRA0~n
N            smra_index = (u8 *)
N                         (REG_NANDRA0 + (inpw(REG_NANDRACTL) & 0x1ff) - // bottom of all parity code -
X                         ((0xB000D000+0xA00) + ((*((volatile unsigned int *)((0xB000D000+0x8BC)))) & 0x1ff) - 
N                          (parity_len * total_field_num)                             // byte count of all parity code
N                         );
N
N            // final address = first parity code of first field +
N            //                 offset of fields +
N            //                 offset within field
N            *((u8 *)smra_index + (parity_len * (ucFieidIndex-1)) + uaAddr[ii]) ^= uaData[ii];
N        }
N    }   // end of for (ii<ucErrorCnt)
N}
N
Nint fmiSMCorrectData (struct mtd_info *mtd, unsigned long uDAddr )
N{
N    int uStatus, ii, jj, i32FieldNum=0;
N    volatile int uErrorCnt = 0;
N
N    if ( inpw ( REG_NANDINTSTS ) & 0x4 )
X    if ( (*((volatile unsigned int *)((0xB000D000+0x8AC)))) & 0x4 )
N    {
N        if ( ( inpw(REG_NANDCTL) & 0x7C0000) == BCH_T24 )
X        if ( ( (*((volatile unsigned int *)((0xB000D000+0x8A0)))) & 0x7C0000) == 0x00040000 )
N            i32FieldNum = mtd->writesize / 1024;    // Block=1024 for BCH
N        else
N            i32FieldNum = mtd->writesize / 512;
N
N        if ( i32FieldNum < 4 )
N            i32FieldNum  = 1;
N        else
N            i32FieldNum /= 4;
N
N        for ( jj=0; jj<i32FieldNum; jj++ )
N        {
N            uStatus = inpw ( REG_NANDECCES0+jj*4 );
X            uStatus = (*((volatile unsigned int *)((0xB000D000+0x8D0)+jj*4)));
N            if ( !uStatus )
N                continue;
N
N            for ( ii=1; ii<5; ii++ )
N            {
N                if ( !(uStatus & 0x03) ) { // No error
N
N                    uStatus >>= 8;
N                    continue;
N
N                } else if ( (uStatus & 0x03)==0x01 ) { // Correctable error
N
N                    uErrorCnt = (uStatus >> 2) & 0x1F;
N                    fmiSM_CorrectData_BCH(jj*4+ii, uErrorCnt, (u8 *)uDAddr);
N
N                    break;
N                } else // uncorrectable error or ECC error
N                {
N                    return -1;
N                }
N            }
N        } //jj
N    }
N    return uErrorCnt;
N}
N
N
Nstatic __inline int _nuc970_nand_dma_transfer(struct mtd_info *mtd, const u_char *addr, unsigned int len, int is_write)
N{
N    struct nuc970_nand_info *nand = nuc970_nand;
N
N    // For save, wait DMAC to ready
N    while ( inpw(REG_FMI_DMACTL) & 0x200 );
X    while ( (*((volatile unsigned int *)((0xB000D000+0x400)))) & 0x200 );
N
N    // Reinitial dmac
N    // DMAC enable
N    outpw(REG_FMI_DMACTL, inpw(REG_FMI_DMACTL) | 0x3);
X    *((volatile unsigned int *)((0xB000D000+0x400))) = (*((volatile unsigned int *)((0xB000D000+0x400)))) | 0x3;
N    while (inpw(REG_FMI_DMACTL) & 0x2);
X    while ((*((volatile unsigned int *)((0xB000D000+0x400)))) & 0x2);
N
N    // Clear DMA finished flag
N    outpw(REG_NANDINTSTS, inpw(REG_NANDINTSTS) | 0x1);
X    *((volatile unsigned int *)((0xB000D000+0x8AC))) = (*((volatile unsigned int *)((0xB000D000+0x8AC)))) | 0x1;
N
N    // Disable Interrupt
N    outpw(REG_NANDINTEN, inpw(REG_NANDINTEN) & ~(0x1));
X    *((volatile unsigned int *)((0xB000D000+0x8A8))) = (*((volatile unsigned int *)((0xB000D000+0x8A8)))) & ~(0x1);
N
N    // Fill dma_addr
N    outpw(REG_FMI_DMASA, (unsigned long)addr);
X    *((volatile unsigned int *)((0xB000D000+0x408))) = (unsigned long)addr;
N
N    // Enable target abort interrupt generation during DMA transfer.
N    outpw(REG_FMI_DMAINTEN, 0x1);
X    *((volatile unsigned int *)((0xB000D000+0x410))) = 0x1;
N
N    // Clear Ready/Busy 0 Rising edge detect flag
N    outpw(REG_NANDINTSTS, 0x400);
X    *((volatile unsigned int *)((0xB000D000+0x8AC))) = 0x400;
N
N    // Set which BCH algorithm
N    if ( nand->eBCHAlgo >= 0 ) {
N        // Set BCH algorithm
N        outpw(REG_NANDCTL, (inpw(REG_NANDCTL) & (~0x7C0000)) | g_i32BCHAlgoIdx[nand->eBCHAlgo]);
X        *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0)))) & (~0x7C0000)) | g_i32BCHAlgoIdx[nand->eBCHAlgo];
N        // Enable H/W ECC, ECC parity check enable bit during read page
N        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x00800080);
X        *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x00800080;
N    } else  {
N        // Disable H/W ECC / ECC parity check enable bit during read page
N        outpw(REG_NANDCTL, inpw(REG_NANDCTL) & (~0x00800080));
X        *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) & (~0x00800080);
N    }
N
N    outpw(REG_NANDRACTL, nand->m_i32SMRASize);
X    *((volatile unsigned int *)((0xB000D000+0x8BC))) = nand->m_i32SMRASize;
N
N    outpw(REG_NANDINTEN, inpw(REG_NANDINTEN) & (~0x4));
X    *((volatile unsigned int *)((0xB000D000+0x8A8))) = (*((volatile unsigned int *)((0xB000D000+0x8A8)))) & (~0x4);
N
N    outpw(REG_NANDINTSTS, 0x4);
X    *((volatile unsigned int *)((0xB000D000+0x8AC))) = 0x4;
N
N    // Enable SM_CS0
N    outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x06000000))|0x04000000;
N    /* setup and start DMA using dma_addr */
N
N    if ( is_write ) {
N        register char *ptr= (char *)REG_NANDRA0;
X        register char *ptr= (char *)(0xB000D000+0xA00);
N        // To mark this page as dirty.
N        if ( ptr[3] == 0xFF )
N            ptr[3] = 0;
N        if ( ptr[2] == 0xFF )
N            ptr[2] = 0;
N
N        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x4);
X        *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x4;
N        while ( !(inpw(REG_NANDINTSTS) & 0x1) );
X        while ( !((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & 0x1) );
N
N    } else {
N        // Blocking for reading
N        // Enable DMA Read
N
N        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x2);
X        *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x2;
N
N        if (inpw(REG_NANDCTL) & 0x80) {
X        if ((*((volatile unsigned int *)((0xB000D000+0x8A0)))) & 0x80) {
N            do {
N                int stat=0;
N                if ( (stat=fmiSMCorrectData ( mtd,  (unsigned long)addr)) < 0 )
N                {
N                    mtd->ecc_stats.failed++;
N                    outpw(REG_NANDINTSTS, 0x4);
X                    *((volatile unsigned int *)((0xB000D000+0x8AC))) = 0x4;
N                    outpw(REG_FMI_DMACTL, 0x3);          // reset DMAC
X                    *((volatile unsigned int *)((0xB000D000+0x400))) = 0x3;          
N                    outpw(REG_NANDCTL, inpw(REG_NANDCTL)|0x1);
X                    *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0))))|0x1;
N                    break;
N                }
N                else if ( stat > 0 ) {
N                    //mtd->ecc_stats.corrected += stat; //Occure: MLC UBIFS mount error
N                    outpw(REG_NANDINTSTS, 0x4);
X                    *((volatile unsigned int *)((0xB000D000+0x8AC))) = 0x4;
N                }
N
N            } while (!(inpw(REG_NANDINTSTS) & 0x1) || (inpw(REG_NANDINTSTS) & 0x4));
X            } while (!((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & 0x1) || ((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & 0x4));
N        } else
N            while (!(inpw(REG_NANDINTSTS) & 0x1));
X            while (!((*((volatile unsigned int *)((0xB000D000+0x8AC)))) & 0x1));
N    }
N
N    // Clear DMA finished flag
N    outpw(REG_NANDINTSTS, inpw(REG_NANDINTSTS) | 0x1);
X    *((volatile unsigned int *)((0xB000D000+0x8AC))) = (*((volatile unsigned int *)((0xB000D000+0x8AC)))) | 0x1;
N
N    return 0;
N}
N
N
N/**
N * nand_write_page_hwecc - [REPLACABLE] hardware ecc based page write function
N * @mtd:        mtd info structure
N * @chip:       nand chip info structure
N * @buf:        data buffer
N */
Nstatic void nuc970_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
N{
N    uint8_t *ecc_calc = chip->buffers->ecccalc;
N    uint32_t hweccbytes=chip->ecc.layout->eccbytes;
N    register char * ptr=(char *)REG_NANDRA0;
X    register char * ptr=(char *)(0xB000D000+0xA00);
N
N    //debug("nuc970_nand_write_page_hwecc\n");
N    memset ( (void*)ptr, 0xFF, mtd->oobsize );
N    memcpy ( (void*)ptr, (void*)chip->oob_poi,  mtd->oobsize - chip->ecc.total );
N
N    _nuc970_nand_dma_transfer( mtd, buf, mtd->writesize , 0x1);
N
N    // Copy parity code in SMRA to calc
N    memcpy ( (void*)ecc_calc,  (void*)( REG_NANDRA0 + ( mtd->oobsize - chip->ecc.total ) ), chip->ecc.total );
X    memcpy ( (void*)ecc_calc,  (void*)( (0xB000D000+0xA00) + ( mtd->oobsize - chip->ecc.total ) ), chip->ecc.total );
N
N    // Copy parity code in calc to oob_poi
N    memcpy ( (void*)(chip->oob_poi+hweccbytes), (void*)ecc_calc, chip->ecc.total);
N}
N
N/**
N * nuc970_nand_read_page_hwecc_oob_first - hardware ecc based page write function
N * @mtd:        mtd info structure
N * @chip:       nand chip info structure
N * @buf:        buffer to store read data
N * @page:       page number to read
N */
Nstatic int nuc970_nand_read_page_hwecc_oob_first(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int page)
N{
N    int eccsize = chip->ecc.size;
N    uint8_t *p = buf;
N    char * ptr= (char *)REG_NANDRA0;
X    char * ptr= (char *)(0xB000D000+0xA00);
N    int volatile i;
N
N    //debug("nuc970_nand_read_page_hwecc_oob_first\n");
N    /* At first, read the OOB area  */
N    nuc970_nand_command(mtd, NAND_CMD_READOOB, 0, page);
X    nuc970_nand_command(mtd, 0x50, 0, page);
N    nuc970_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);
N
N    // Second, copy OOB data to SMRA for page read
N    memcpy ( (void*)ptr, (void*)chip->oob_poi, mtd->oobsize );
N
N    // Third, read data from nand
N    nuc970_nand_command(mtd, NAND_CMD_READ0, 0, page);
X    nuc970_nand_command(mtd, 0, 0, page);
N    _nuc970_nand_dma_transfer(mtd, p, eccsize, 0x0);
N
N    // Fouth, restore OOB data from SMRA
N    memcpy ( (void*)chip->oob_poi, (void*)ptr, mtd->oobsize );
N
N    return 0;
N}
N
N/**
N * nuc970_nand_read_oob_hwecc - [REPLACABLE] the most common OOB data read function
N * @mtd:        mtd info structure
N * @chip:       nand chip info structure
N * @page:       page number to read
N * @sndcmd:     flag whether to issue read command or not
N */
Nstatic int nuc970_nand_read_oob_hwecc(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
N{
N    char * ptr=(char *)REG_NANDRA0;
X    char * ptr=(char *)(0xB000D000+0xA00);
N
N    /* At first, read the OOB area  */
N    if ( sndcmd ) {
N        nuc970_nand_command(mtd, NAND_CMD_READOOB, 0, page);
X        nuc970_nand_command(mtd, 0x50, 0, page);
N        sndcmd = 0;
N    }
N
N    nuc970_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);
N
N    // Second, copy OOB data to SMRA for page read
N    memcpy ( (void*)ptr, (void*)chip->oob_poi, mtd->oobsize );
N
N    return sndcmd;
N}
N
N
N
Nint board_nand_init(struct nand_chip *nand)
N{
N    struct mtd_info *mtd;
N
N    nuc970_nand = &g_nuc970_nand;
N    memset((void*)nuc970_nand,0,sizeof(struct nuc970_nand_info));
N	
N    if (!nuc970_nand)
N        return -1;
N
N    mtd=&nuc970_nand->mtd;
N    nuc970_nand->chip.controller = &nuc970_nand->controller;
N
N    /* initialize nand_chip data structure */
N    nand->IO_ADDR_R = (void *)REG_NANDDATA;
X    nand->IO_ADDR_R = (void *)(0xB000D000+0x8B8);
N    nand->IO_ADDR_W = (void *)REG_NANDDATA;
X    nand->IO_ADDR_W = (void *)(0xB000D000+0x8B8);
N
N    /* read_buf and write_buf are default */
N    /* read_byte and write_byte are default */
N    /* hwcontrol always must be implemented */
N    nand->cmd_ctrl = nuc970_hwcontrol;
N    nand->cmdfunc = nuc970_nand_command;
N    nand->dev_ready = nuc970_dev_ready;
N    nand->select_chip = nuc970_nand_select_chip;
N
N    nand->read_byte = nuc970_nand_read_byte;
N    nand->write_buf = nuc970_nand_write_buf;
N    nand->read_buf = nuc970_nand_read_buf;
N    nand->chip_delay = 50;
N
N    nand->controller = &nuc970_nand->controller;
N
N    nand->ecc.mode      = NAND_ECC_HW_OOB_FIRST;
N    nand->ecc.hwctl     = nuc970_nand_enable_hwecc;
N    nand->ecc.calculate = nuc970_nand_calculate_ecc;
N    nand->ecc.correct   = nuc970_nand_correct_data;
N    nand->ecc.write_page= nuc970_nand_write_page_hwecc;
N    nand->ecc.read_page = nuc970_nand_read_page_hwecc_oob_first;
N    nand->ecc.read_oob  = nuc970_nand_read_oob_hwecc;
N    nand->ecc.layout    = &nuc970_nand_oob;
N
N    mtd->priv = nand;
N
N    /* initial NAND controller */
N    outpw(REG_CLK_HCLKEN, (inpw(REG_CLK_HCLKEN) | 0x300000));
X    *((volatile unsigned int *)((0xB0000200+0x10))) = ((*((volatile unsigned int *)((0xB0000200+0x10)))) | 0x300000);
N
N    /* select NAND function pins */
N    if (inpw(REG_SYS_PWRON) & 0x08000000)
X    if ((*((volatile unsigned int *)((0xB0000000+0x004)))) & 0x08000000)
N    {
N        /* Set GPI1~15 for NAND */
N        outpw(REG_SYS_GPI_MFPL, 0x55555550);
X        *((volatile unsigned int *)((0xB0000000+0x0B0))) = 0x55555550;
N        outpw(REG_SYS_GPI_MFPH, 0x55555555);
X        *((volatile unsigned int *)((0xB0000000+0x0B4))) = 0x55555555;
N    }
N    else
N    {
N        /* Set GPC0~14 for NAND */
N        outpw(REG_SYS_GPC_MFPL, 0x55555555);
X        *((volatile unsigned int *)((0xB0000000+0x080))) = 0x55555555;
N        outpw(REG_SYS_GPC_MFPH, 0x05555555);
X        *((volatile unsigned int *)((0xB0000000+0x084))) = 0x05555555;
N    }
N
N    // Enable SM_EN
N    outpw(REG_FMI_CTL, NAND_EN);
X    *((volatile unsigned int *)((0xB000D000+0x800))) = 0x08;
N    outpw(REG_NANDTMCTL, 0x20305);
X    *((volatile unsigned int *)((0xB000D000+0x8A4))) = 0x20305;
N
N    // Enable SM_CS0
N    outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x06000000))|0x04000000;
N    outpw(REG_NANDECTL, 0x1); /* un-lock write protect */
X    *((volatile unsigned int *)((0xB000D000+0x8C0))) = 0x1;  
N
N    // NAND Reset
N    outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x1);    // software reset
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x1;    
N    while (inpw(REG_NANDCTL) & 0x1);
X    while ((*((volatile unsigned int *)((0xB000D000+0x8A0)))) & 0x1);
N
N    /* Detect NAND chips */
N    /* first scan to find the device and get the page size */
N    if (nand_scan_ident(&(nuc970_nand->mtd), 1, NULL)) {
X    if (nand_scan_ident(&(nuc970_nand->mtd), 1, ((void *)0))) {
N        sysprintf("NAND Flash not found !\n");
N        return -1;
N    }
N
N    //Set PSize bits of SMCSR register to select NAND card page size
N    switch (mtd->writesize) {
N        case 2048:
N            outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x10000);
X            *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x30000)) + 0x10000;
N            nuc970_nand->eBCHAlgo = 0; /* T4 */
N            nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[1][nuc970_nand->eBCHAlgo] );
N            break;
N
N        case 4096:
N            outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x20000);
X            *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x30000)) + 0x20000;
N            nuc970_nand->eBCHAlgo = 1; /* T8 */
N            nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[2][nuc970_nand->eBCHAlgo] );
N            break;
N
N        case 8192:
N            outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x30000);
X            *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0))))&(~0x30000)) + 0x30000;
N            nuc970_nand->eBCHAlgo = 2; /* T12 */
N            nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[3][nuc970_nand->eBCHAlgo] );
N            break;
N
N        /* Not support now. */
N        case 512:
N
N        default:
N            sysprintf("NUC970 NAND CONTROLLER IS NOT SUPPORT THE PAGE SIZE. (%d, %d)\n", mtd->writesize, mtd->oobsize );
N    }
N
N    nuc970_nand->m_i32SMRASize  = mtd->oobsize;
N    nand->ecc.bytes = nuc970_nand_oob.eccbytes;
N    nand->ecc.size  = mtd->writesize;
N
N    nand->options = 0;
N
N    // Redundant area size
N    outpw(REG_NANDRACTL, nuc970_nand->m_i32SMRASize);
X    *((volatile unsigned int *)((0xB000D000+0x8BC))) = nuc970_nand->m_i32SMRASize;
N
N    // Protect redundant 3 bytes
N    // because we need to implement write_oob function to partial data to oob available area.
N    // Please note we skip 4 bytes
N    outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x100);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x100;
N
N    // To read/write the ECC parity codes automatically from/to NAND Flash after data area field written.
N    outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x10);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x10;
N    // Set BCH algorithm
N    outpw(REG_NANDCTL, (inpw(REG_NANDCTL) & (~0x007C0000)) | g_i32BCHAlgoIdx[nuc970_nand->eBCHAlgo]);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = ((*((volatile unsigned int *)((0xB000D000+0x8A0)))) & (~0x007C0000)) | g_i32BCHAlgoIdx[nuc970_nand->eBCHAlgo];
N    // Enable H/W ECC, ECC parity check enable bit during read page
N    outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x00800080);
X    *((volatile unsigned int *)((0xB000D000+0x8A0))) = (*((volatile unsigned int *)((0xB000D000+0x8A0)))) | 0x00800080;
N
N    return 0;
N}
N
N/// @endcond HIDDEN_SYMBOLS
N
N
N/*@}*/ /* end of group NUC970_FMI_NAND_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_FMI_NAND_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
N
N
