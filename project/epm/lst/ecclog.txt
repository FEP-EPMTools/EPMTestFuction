; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\ecclog.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ecclog.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\ecclog.crf src\syshal\cardlog\ecclog.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  uint8ToUint32 PROC
;;;67     static uint32_t Spid, NewSpID, NewLocationID; 
;;;68     static uint32_t uint8ToUint32(uint8_t* data, uint8_t dataLen)
000000  e92d4010          PUSH     {r4,lr}
;;;69     {
000004  e1a02000          MOV      r2,r0
;;;70         uint32_t reVal = 0;
000008  e3a03000          MOV      r3,#0
;;;71         if(dataLen > sizeof(uint32_t))
00000c  e3510004          CMP      r1,#4
000010  9a000001          BLS      |L1.28|
;;;72             return 0;
000014  e3a00000          MOV      r0,#0
                  |L1.24|
;;;73         for(int i = 0; i < dataLen; i++)
;;;74         {
;;;75             reVal = reVal | ((uint32_t)(data[i])<<(8*i));
;;;76         }
;;;77         return reVal;
;;;78     }
000018  e8bd8010          POP      {r4,pc}
                  |L1.28|
00001c  e3a00000          MOV      r0,#0                 ;73
000020  ea000003          B        |L1.52|
                  |L1.36|
000024  e7d2c000          LDRB     r12,[r2,r0]           ;75
000028  e1a04180          LSL      r4,r0,#3              ;75
00002c  e183341c          ORR      r3,r3,r12,LSL r4      ;75
000030  e2800001          ADD      r0,r0,#1              ;73
                  |L1.52|
000034  e1500001          CMP      r0,r1                 ;73
000038  bafffff9          BLT      |L1.36|
00003c  e1a00003          MOV      r0,r3                 ;77
000040  eafffff4          B        |L1.24|
;;;79     #if(0)
                          ENDP

                  uint32ToUint8 PROC
;;;91     #endif
;;;92     static uint8_t uint32ToUint8(uint32_t src, uint8_t* data, uint8_t dataLen)
000044  e1a03000          MOV      r3,r0
;;;93     {
;;;94         if(dataLen > sizeof(uint32_t))
000048  e3520004          CMP      r2,#4
00004c  9a000001          BLS      |L1.88|
;;;95             return 0;
000050  e3a00000          MOV      r0,#0
                  |L1.84|
;;;96         //sysprintf(" --- ecclog (uint32ToUint8): %d (len = %d)\r\n", src, dataLen);
;;;97         for(int i = 0; i < dataLen; i++)
;;;98         {
;;;99             data[i] = (src>>(8*i))&0xff;
;;;100        }
;;;101        return dataLen;
;;;102    }
000054  e12fff1e          BX       lr
                  |L1.88|
000058  e3a00000          MOV      r0,#0                 ;97
00005c  ea000003          B        |L1.112|
                  |L1.96|
000060  e1a0c180          LSL      r12,r0,#3             ;99
000064  e1a0cc33          LSR      r12,r3,r12            ;99
000068  e7c1c000          STRB     r12,[r1,r0]           ;99
00006c  e2800001          ADD      r0,r0,#1              ;97
                  |L1.112|
000070  e1500002          CMP      r0,r2                 ;97
000074  bafffff9          BLT      |L1.96|
000078  e1a00002          MOV      r0,r2                 ;101
00007c  eafffff4          B        |L1.84|
;;;103    static uint8_t getMoneyToUint8(uint32_t src, uint8_t* data, uint8_t dataLen)
                          ENDP

                  getMoneyToUint8 PROC
000080  e92d4070          PUSH     {r4-r6,lr}
;;;104    {
000084  e1a04000          MOV      r4,r0
000088  e1a05001          MOV      r5,r1
00008c  e1a06002          MOV      r6,r2
;;;105        return uint32ToUint8(src, data, dataLen);
000090  e1a02006          MOV      r2,r6
000094  e1a01005          MOV      r1,r5
000098  e1a00004          MOV      r0,r4
00009c  ebfffffe          BL       uint32ToUint8
;;;106    }
0000a0  e8bd8070          POP      {r4-r6,pc}
;;;107    
                          ENDP

                  getECCLogUTCTimeStr PROC
;;;108    static char* getECCLogUTCTimeStr(uint32_t utcTime)
0000a4  e92d4010          PUSH     {r4,lr}
;;;109    {
0000a8  e24dd040          SUB      sp,sp,#0x40
0000ac  e1a04000          MOV      r4,r0
;;;110        RTC_TIME_DATA_T time;
;;;111        Time2RTC(utcTime, &time);  
0000b0  e28d1010          ADD      r1,sp,#0x10
0000b4  e1a00004          MOV      r0,r4
0000b8  ebfffffe          BL       Time2RTC
;;;112        sprintf(currentDateTimeStr, "%04d%02d%02d%02d%02d%02d", time.u32Year, time.u32cMonth, time.u32cDay, time.u32cHour, time.u32cMinute, time.u32cSecond);
0000bc  e28d3014          ADD      r3,sp,#0x14
0000c0  e893000b          LDM      r3,{r0,r1,r3}
0000c4  e59d2024          LDR      r2,[sp,#0x24]
0000c8  e58d000c          STR      r0,[sp,#0xc]
0000cc  e58d1008          STR      r1,[sp,#8]
0000d0  e1cd20f0          STRD     r2,r3,[sp,#0]
0000d4  e28f1d05          ADR      r1,|L1.540|
0000d8  e59f0158          LDR      r0,|L1.568|
0000dc  e59d202c          LDR      r2,[sp,#0x2c]
0000e0  e59d3028          LDR      r3,[sp,#0x28]
0000e4  ebfffffe          BL       __2sprintf
;;;113        //sysprintf("getECCCmdUTCTimeStr :[%d, %X][%s]\r\n", utcTime, utcTime, tmp);  
;;;114        return currentDateTimeStr;
0000e8  e59f0148          LDR      r0,|L1.568|
0000ec  e28dd040          ADD      sp,sp,#0x40
;;;115    }
0000f0  e8bd8010          POP      {r4,pc}
;;;116    
                          ENDP

                  getECCLogTimeData PROC
;;;117    static void getECCLogTimeData(uint32_t time, ECCLogDataTime* eccLogDataTime)
0000f4  e1a02000          MOV      r2,r0
;;;118    {
;;;119        //sysprintf("getECCLogTimeData :[%d, %X]\r\n", time, time);  
;;;120        for(int i = 0; i < sizeof(ECCLogDataTime); i++)
0000f8  e3a00000          MOV      r0,#0
0000fc  ea000003          B        |L1.272|
                  |L1.256|
;;;121        {
;;;122            eccLogDataTime->value[i] = (time>>(8*i))&0xff;
000100  e1a03180          LSL      r3,r0,#3
000104  e1a03332          LSR      r3,r2,r3
000108  e7c13000          STRB     r3,[r1,r0]
00010c  e2800001          ADD      r0,r0,#1              ;120
                  |L1.272|
000110  e3500004          CMP      r0,#4                 ;120
000114  3afffff9          BCC      |L1.256|
;;;123        }
;;;124    }
000118  e12fff1e          BX       lr
;;;125    
                          ENDP

                  getExtension PROC
;;;126    char *getExtension(char *fileName)
00011c  e92d4070          PUSH     {r4-r6,lr}
;;;127    {
000120  e1a04000          MOV      r4,r0
;;;128        int len = strlen(fileName);
000124  e1a00004          MOV      r0,r4
000128  ebfffffe          BL       strlen
00012c  e1a06000          MOV      r6,r0
;;;129        int i = len;
000130  e1a05006          MOV      r5,r6
;;;130        while( fileName[i]!='.' && i>0 )
000134  ea000000          B        |L1.316|
                  |L1.312|
;;;131        { 
;;;132            i--; 
000138  e2455001          SUB      r5,r5,#1
                  |L1.316|
00013c  e7d40005          LDRB     r0,[r4,r5]            ;130
000140  e350002e          CMP      r0,#0x2e              ;130
000144  0a000001          BEQ      |L1.336|
000148  e3550000          CMP      r5,#0                 ;130
00014c  cafffff9          BGT      |L1.312|
                  |L1.336|
;;;133        }
;;;134    
;;;135        if(fileName[i]=='.')
000150  e7d40005          LDRB     r0,[r4,r5]
000154  e350002e          CMP      r0,#0x2e
000158  1a000002          BNE      |L1.360|
;;;136        {
;;;137            return &fileName[i+1];
00015c  e2850001          ADD      r0,r5,#1
000160  e0800004          ADD      r0,r0,r4
                  |L1.356|
;;;138        }
;;;139        else
;;;140        {
;;;141            return &fileName[len];
;;;142        }
;;;143    }
000164  e8bd8070          POP      {r4-r6,pc}
                  |L1.360|
000168  e0840006          ADD      r0,r4,r6              ;141
00016c  eafffffc          B        |L1.356|
;;;144    /*-----------------------------------------*/
                          ENDP

                  ECCDeductLogContainInit PROC
;;;146    /*-----------------------------------------*/
;;;147    BOOL ECCDeductLogContainInit(ECCDeductLogBody* body, uint32_t deductValue, uint32_t AgentNo, uint32_t utcTime, BOOL cardAutoloadAvailable, ECCCmdDCAReadResponseSuccessData* DCAReadData, int DCAReadDataLen, ECCCmdEDCADeductResponseData* EDCADeductData, int EDCADeductDataLen)
000170  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000174  e1a08000          MOV      r8,r0
000178  e28d701c          ADD      r7,sp,#0x1c
00017c  e89700f0          LDM      r7,{r4-r7}
000180  e59dc018          LDR      r12,[sp,#0x18]
;;;149        #if(1)
;;;150        return TRUE;
000184  e3a00001          MOV      r0,#1
;;;151        #else
;;;152        uint32_t i;
;;;153        uint8_t* prData; 
;;;154        uint32_t prDataLen;
;;;155        ECCDeductLogBody* pECCDeductLogBody = body;
;;;156        #if(!ECC_LOG_USE_NEW_FILE_NAME)
;;;157        uint32_t SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW;
;;;158        #endif
;;;159        uint8_t PVN = DCAReadData->PurseVersionNumber;
;;;160        sysprintf("\r\n====  ECCDeductLogContainInit(%s), cardAutoloadAvailable:%d ====\r\n", GetMeterData()->epmIdStr, cardAutoloadAvailable);
;;;161        sysprintf("sizeof(ECCDeductLogBody) = %d\r\n", sizeof(ECCDeductLogBody));
;;;162    
;;;163        if(sizeof(ECCDeductLogBody) != TOTAL_ECC_DEDUCT_LOG_BODY_SIZE)
;;;164        {
;;;165            sysprintf("ECCDeductLogContainInit ERROR: sizeof(ECCDeductLogBody) != TOTAL_ECC_DEDUCT_LOG_BODY_SIZE [%d, %d]\r\n", sizeof(ECCDeductLogBody), TOTAL_ECC_DEDUCT_LOG_BODY_SIZE);
;;;166            return FALSE;
;;;167        }
;;;168        memset(pECCDeductLogBody, 0x00, sizeof(ECCDeductLogBody));
;;;169        //DPTITraceNo++;
;;;170        // ********   Header   ********
;;;171        pECCDeductLogBody->Header.PurseVerNo = DCAReadData->PurseVersionNumber;         //1 PURSE_VER_NO 卡片版本 Unsigned 1 代碼參照 8.1 來源: 設備
;;;172        pECCDeductLogBody->Header.CardTxnTypeID = EDCADeductData->MsgType;              //2 CARD_TXN_TYPE_ID 交易類別 Unsigned 1 代碼參照 8.2 來源: 設備
;;;173        
;;;174        pECCDeductLogBody->Header.CardTxnSubTypeID = DCAReadData->PersonalProfile;      //3 CARD_TXN_SUBTYPE_ID 交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照 8.3 //交易次類別 (MsgType = 0x01 時，SubType = Personal Profile)
;;;175        pECCDeductLogBody->Header.DevID[0] = DCAReadData->DeviceID[2];                  //4 DEV_ID 設備編號 Unsigned 3 SP_ID(1 Byte):如 122 即為 0x7A
;;;176        pECCDeductLogBody->Header.DevID[1] = DCAReadData->DeviceID[0];                                                    //DEV_TYPE(4 Bits): 3：BV 如 BV 即為 0x3□
;;;177        pECCDeductLogBody->Header.DevID[2] = DCAReadData->DeviceID[1];                                                    //DEV_ID_NO(12 Bites): 如 1234 即為 0x□4 0xD2
;;;178                                                                                                                        //組合 HEX: 0x7A 0x34 0xD2
;;;179                                                                                                                        //倒數2 Bytes LSB FIRST: 0x7A 0xD2 0x34
;;;180                                                                                                                        //來源: Mifare Sam 卡
;;;181        pECCDeductLogBody->Header.SpID = DCAReadData->ServiceProviderID;                //5 SP_ID 業者代碼 Unsigned 1  如 122 即為 0x7A 來源: 設備
;;;182        Spid = uint8ToUint32((uint8_t*)&(pECCDeductLogBody->Header.SpID), sizeof(pECCDeductLogBody->Header.SpID));
;;;183        sysprintf("ECCDeductLogContainInit Spid = %d\r\n", Spid);
;;;184    
;;;185        memcpy(&(pECCDeductLogBody->Header.TxnTimeStamp), &(EDCADeductData->TXNDateTime), sizeof(pECCDeductLogBody->Header.TxnTimeStamp));  //[以 EDCADeductBytes 的為準] //6 TXN_TIMESTAMP 交易時間 UnixTime 4 來源: 設備
;;;186        memcpy(pECCDeductLogBody->Header.CardPhysicalID, DCAReadData->CardPhysicalID, sizeof(pECCDeductLogBody->Header.CardPhysicalID));    //7 CARD_PHYSICAL_ID 卡片晶片號碼 Unsigned 7 來源: 設備
;;;187        pECCDeductLogBody->Header.IssuerID = DCAReadData->IssuerCode;                   //8 ISSUER_ID 發卡單位 Unsigned 1   PVN <> 0 時: 來源: Cpu 卡
;;;188                                                                                                                          //PVN = 0 時: 2 (0x02)：悠遊卡公司
;;;189                                                                                                                                        //66 (0x42)：基隆交通卡
;;;190                                                                                                                                        //來源: 設備
;;;191        pECCDeductLogBody->Header.CardTxnSeqNo = EDCADeductData->TSQN[0];               //只有一個byte   //9 CARD_TXN_SEQ_NO 交易後序號 Unsigned 1 來源: 卡片
;;;192        getMoneyToUint8(deductValue, pECCDeductLogBody->Header.TxnAMT, sizeof(pECCDeductLogBody->Header.TxnAMT));   //10 TXN_AMT 交易金額 Signed 3 來源: 設備
;;;193        memcpy(pECCDeductLogBody->Header.ElectronicValue, EDCADeductData->PurseBalance, sizeof(pECCDeductLogBody->Header.ElectronicValue)); //11 ELECTRONIC_VALUE 交易後卡片金額 Signed 3 來源: 卡片
;;;194        pECCDeductLogBody->Header.SVCELocID = DCAReadData->LocationID;                      //12 SVCE_LOC_ID 場站代碼 Unsigned 1 來源: 設備
;;;195        pECCDeductLogBody->Header.CardPhysicalIDLen = DCAReadData->CardPhysicalIDLength;    //13 CARD_PHYSICAL_ID_LEN 晶片號碼長度 Unsigned 1 如 4 bytes 即為 0x04
;;;196                                                                                                        //如 7 bytes 即為 0x07
;;;197                                                                                                        //來源: 卡片
;;;198        memcpy(pECCDeductLogBody->Header.NewCardTxnSeqNo, EDCADeductData->TSQN, sizeof(pECCDeductLogBody->Header.NewCardTxnSeqNo));     //14 NEW_CARD_TXN_SEQ_NO 新交易後序號 Unsigned 3 來源: 卡片
;;;199        memcpy(pECCDeductLogBody->Header.NewDevID, DCAReadData->NewDeviceID, sizeof(pECCDeductLogBody->Header.NewDevID));               //15 NEW_DEV_ID 新設備編號 Unsigned 6           NEW_SP_ID(3 Bytes): 如 122 即為0x00 0x00 0x7A
;;;200                                                                                                    //NEW_DEV_TYPE(1 Byte): 3：BV 如 3 即為 0x03
;;;201                                                                                                    //4096(含)之後開始編碼
;;;202                                                                                                    //NEW_DEV_ID_NO (2 Bytes): 如 4096 即為 0x10 0x00
;;;203                                                                                                    //組合 HEX: 0x00 0x00 0x7A 0x03 0x10 0x00
;;;204                                                                                                    //以 LSB FIRST 傳送: 0x00 0x10 0x03 0x7A 0x00 0x00
;;;205                                                                                                    //來源: Cpu Sam 卡
;;;206                                                                                                    //二代卡設備未修改，以 SIS2 傳送時: 固定填 6 Bytes 0x00
;;;207        memcpy(pECCDeductLogBody->Header.NewSpID, DCAReadData->NewServiceProviderID, sizeof(pECCDeductLogBody->Header.NewSpID));    //16 NEW_SP_ID 新業者代碼 Unsigned 3 NEW_SP_ID(3 Bytes): 如 122 即為 0x00 0x00 0x7A
;;;208        NewSpID = uint8ToUint32((uint8_t*)&(pECCDeductLogBody->Header.NewSpID), sizeof(pECCDeductLogBody->Header.NewSpID));                              //以 LSB FIRST 傳送: 0x7A 0x00 0x00
;;;209        sysprintf("ECCDeductLogContainInit NewSpID = %d\r\n", NewSpID);                                                                         //來源: 設備
;;;210                                                                                                                                        
;;;211        memcpy(pECCDeductLogBody->Header.NewSVCELocID, DCAReadData->NewLocationID, sizeof(pECCDeductLogBody->Header.NewSVCELocID));     //17 NEW_SVCE_LOC_ID 新場站代碼 Unsigned 2 NEW_SVCE_LOC_ID(2 Bytes): 如 1 即為 0x00 0x01
;;;212        NewLocationID = uint8ToUint32((uint8_t*)&(pECCDeductLogBody->Header.NewSVCELocID), sizeof(pECCDeductLogBody->Header.NewSVCELocID));                  //以 LSB FIRST 傳送: 0x01 0x00
;;;213        sysprintf("ECCDeductLogContainInit NewLocationID = %d\r\n", NewLocationID);                                                             //來源: 設備                         
;;;214                                                                                        
;;;215        pECCDeductLogBody->Header.NewCardTxnSubTypeID = 0x00;        //18 NEW_CARD_TXN_SUBTYPE_ID 新交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照 8.3
;;;216        pECCDeductLogBody->Header.NewPersonalProfile = DCAReadData->PersonalProfile;         //19 NEW_PERSONAL_PROFILE 新身份別 Unsigned 1 0x00: 一般
;;;217                                                                                                //0x01: 敬老 1
;;;218                                                                                                //0x02: 敬老 2
;;;219                                                                                                //0x03: 愛心
;;;220                                                                                                //0x04: 陪伴
;;;221                                                                                                //0x05: 學生
;;;222                                                                                                //0x08: 優待
;;;223                                                                                                //來源: 卡片
;;;224        pECCDeductLogBody->Header.TxnPersonalProfile = 0x00;         //20 TXN_PERSONAL_PROFILE 交易身份別 Unsigned 1 實際交易的身份別，如卡片身份別為學生，但部份業者未給予優待，以一般卡扣款，則此欄位填入一般
;;;225                                                                                                //0x00: 一般
;;;226                                                                                                //0x01: 敬老 1
;;;227                                                                                                //0x02: 敬老 2
;;;228                                                                                                //0x03: 愛心
;;;229                                                                                                //0x04: 陪伴
;;;230                                                                                                //0x05: 學生
;;;231                                                                                                //0x08: 優待
;;;232                                                                                                //來源: 設備
;;;233        pECCDeductLogBody->Header.ACQID = 0x02;                      //21 ACQ_ID 收單單位 Unsigned 1   2 (0x02)：悠遊卡公司
;;;234                                                                                    //66 (0x42)：基隆交通卡
;;;235                                                                                    //來源: 設備
;;;236        memcpy(pECCDeductLogBody->Header.CardPurseID, &(DCAReadData->PID), sizeof(pECCDeductLogBody->Header.CardPurseID)); //22 CARD_PURSE_ID 錢包編號(外觀號碼) Pack 8      PVN <> 0 時:
;;;237                                                                                                                                                                                //如卡號 1234567890123456
;;;238                                                                                                                                                                                //即為 0x12 0x34 0x56 0x78 0x90 0x12 0x34 0x56
;;;239                                                                                                                                                                                //編碼參照 8.5
;;;240                                                                                                                                                                                //來源: Cpu 卡
;;;241                                                                                                                                                                            //PVN = 0 時:
;;;242                                                                                                                                                                                //固定填 8 Bytes 0x00
;;;243    
;;;244        if (PVN == 0x00)                                                 //23 CARD_CTC_SEQ_NO 卡片處理序號 Unsigned Msb 3   PVN <> 0 時: 如 1 即為 0x00 0x00 0x01  
;;;245        {                                                                                                                   //以 MSB FIRST 傳送:  0x00 0x00 0x01                
;;;246            memset(pECCDeductLogBody->Header.CardCTCSeqNo, 0x00, sizeof(pECCDeductLogBody->Header.CardCTCSeqNo));           //來源: Cpu 卡                                      
;;;247        }                                                                                                                   //PVN = 0 時: 固定填 3 Bytes 0x00                          
;;;248        else
;;;249        {
;;;250            memcpy(pECCDeductLogBody->Header.CardCTCSeqNo, EDCADeductData->CTC, sizeof(pECCDeductLogBody->Header.CardCTCSeqNo));
;;;251        }
;;;252        
;;;253                  
;;;254        pECCDeductLogBody->Header.AreaCode = DCAReadData->AreaCode;          //24 AREA_CODE 區碼 Unsigned 1 來源: 卡片
;;;255        
;;;256        if (PVN == 0x00)                                                     //25 SUB_AREA_CODE 附屬區碼 Unsigned 2    PVN <> 0 時: 依 3 碼郵遞區號  來源: Cpu 卡     
;;;257        {                                                                                                              //PVN = 0 時: 固定填 2 Bytes 0x00              
;;;258            memset(pECCDeductLogBody->Header.SubAreaCode, 0x00, sizeof(pECCDeductLogBody->Header.SubAreaCode)); 
;;;259        }                                                                                                       
;;;260        else
;;;261        {
;;;262            memcpy(pECCDeductLogBody->Header.SubAreaCode, DCAReadData->SubAreaCode, sizeof(pECCDeductLogBody->Header.SubAreaCode));
;;;263        }
;;;264    
;;;265        //26 SEQ_NO_BEF_TXN 交易前序號 Unsigned 3  來源: 卡片  二代卡設備未修改，以 SIS2 傳送時: 固定填 3 Bytes 0x00    
;;;266        //27 EV_BEF_TXN 交易前卡片金額 Signed 3 來源: 卡片                                                               
;;;267        if (cardAutoloadAvailable)
;;;268        {//抓扣款後自動加值的
;;;269             //交易前序號
;;;270             memcpy(pECCDeductLogBody->Header.SeqNoBefTxn, EDCADeductData->AutoLoadTSQN, sizeof(pECCDeductLogBody->Header.SeqNoBefTxn));
;;;271    
;;;272            //交易前卡片金額
;;;273            memcpy(pECCDeductLogBody->Header.EVBdfTxn, EDCADeductData->AutoLoadPurseBalance, sizeof(pECCDeductLogBody->Header.EVBdfTxn));
;;;274        }
;;;275        else
;;;276        {//抓讀卡的
;;;277            //交易前序號
;;;278            memcpy(pECCDeductLogBody->Header.SeqNoBefTxn, DCAReadData->TXNSNBeforeTXN, sizeof(pECCDeductLogBody->Header.SeqNoBefTxn));
;;;279    
;;;280            //交易前卡片金額
;;;281            memcpy(pECCDeductLogBody->Header.EVBdfTxn, DCAReadData->PurseBalanceBeforeTXN, sizeof(pECCDeductLogBody->Header.EVBdfTxn));
;;;282        }
;;;283        #if(1)
;;;284        prData = (uint8_t*)&(pECCDeductLogBody->Header);
;;;285        prDataLen = sizeof(pECCDeductLogBody->Header);
;;;286        sysprintf("--- pECCDeductLogBody->Header:  len = %d --->\r\n", prDataLen);
;;;287        for(i = 0; i<prDataLen; i++)
;;;288        {
;;;289            //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;290            sysprintf("0x%02x, ", prData[i]);
;;;291            if(i%10 == 9)
;;;292                sysprintf("\r\n");
;;;293    
;;;294        }
;;;295        sysprintf("\r\n<--- pECCDeductLogBody->Header ---\r\n");
;;;296        #endif
;;;297        // ********   Data   ********
;;;298        //2018.08.14  --> C. 【XFER_CODE】轉乘代碼：CPU_L2卡應填 06，卻填 00。    
;;;299        sysprintf("\r\n====  ECCDeductLogContainInit: TransferGroupCode = 0x%02x, NewTransferGroupCode = 0x%02x, 0x%02x ====\r\n", 
;;;300                            EDCADeductData->TransferGroupCode, EDCADeductData->NewTransferGroupCode[0], EDCADeductData->NewTransferGroupCode[1]);    
;;;301        if (PVN != 0x00) //CPU_L2卡應填 06, 根據 NewTransferGroupCode[2] 來判斷 因為這時候都是 00
;;;302        {
;;;303            uint8_t prevTransferGroupCode = 0x00;
;;;304            if(EDCADeductData->NewTransferGroupCode[0] > 0xF)
;;;305            {
;;;306                prevTransferGroupCode = prevTransferGroupCode | 0xF0;
;;;307            }
;;;308            else
;;;309            {
;;;310                prevTransferGroupCode = prevTransferGroupCode | ((EDCADeductData->NewTransferGroupCode[0] & 0x0F) << 4);
;;;311            }   
;;;312    
;;;313            if(EDCADeductData->NewTransferGroupCode[1] > 0xF)
;;;314            {
;;;315                prevTransferGroupCode = prevTransferGroupCode | 0x0F;
;;;316            }
;;;317            else
;;;318            {
;;;319                prevTransferGroupCode = prevTransferGroupCode | (EDCADeductData->NewTransferGroupCode[1] & 0x0F);
;;;320            }
;;;321    
;;;322            pECCDeductLogBody->XferCODE = prevTransferGroupCode;            //4 XFER_CODE 轉乘代碼 Byte 1 bit7..4: 上筆轉乘代碼
;;;323                                                                                //bit3..0: 本次轉乘代碼
;;;324                                                                                //如捷運轉公車: 0x12
;;;325                                                                                //來源: 設備
;;;326                                                                                //預設填 0x00
;;;327               
;;;328    
;;;329        }
;;;330        else
;;;331        {
;;;332            pECCDeductLogBody->XferCODE = EDCADeductData->TransferGroupCode; //4 XFER_CODE 轉乘代碼 Byte 1 bit7..4: 上筆轉乘代碼
;;;333                                                                                //bit3..0: 本次轉乘代碼
;;;334                                                                                //如捷運轉公車: 0x12
;;;335                                                                                //來源: 設備
;;;336                                                                                //預設填 0x00
;;;337        }
;;;338        sysprintf("\r\n====  ECCDeductLogContainInit: XferCODE = 0x%02x ====\r\n", pECCDeductLogBody->XferCODE);
;;;339        memcpy(pECCDeductLogBody->NewXferCODE, EDCADeductData->NewTransferGroupCode, sizeof(pECCDeductLogBody->NewXferCODE));//5 NEW_XFER_CODE 新轉乘代碼 Byte 2
;;;340                                                                                                                                //Byte1: 上筆轉乘代碼
;;;341                                                                                                                                //Byte2: 本次轉乘代碼
;;;342                                                                                                                                //如捷運轉公車: 0x01 0x02
;;;343                                                                                                                                //來源: 設備
;;;344                                                                                                                                //預設填 2 Bytes 0x00
;;;345        getMoneyToUint8(deductValue, pECCDeductLogBody->OriAMT, sizeof(pECCDeductLogBody->OriAMT));   //6 ORI_AMT 原價(未打折) Unsigned 3
;;;346                                                                                                                        //計算參照 8.8
;;;347                                                                                                                        //來源: 設備
;;;348        
;;;349        pECCDeductLogBody->DisRate = 0x64;          //7 DIS_RATE 費率 Unsigned 1  如 85 折，DIS_RATE=85 即為 0x55
;;;350                                                        //如未打折，DIS_RATE=100 即為 0x64
;;;351                                                        //計算參照 8.8
;;;352                                                        //來源: 設備
;;;353        getMoneyToUint8(deductValue, pECCDeductLogBody->TicketAMT, sizeof(pECCDeductLogBody->TicketAMT)); //index 14   //8 TICKET_AMT 票價(打折後) Unsigned 3
;;;354                                                                                                                //計算參照 8.8
;;;355                                                                                                                //來源: 設備
;;;356        memcpy(pECCDeductLogBody->LoyaltyCounter, DCAReadData->LoyaltyCounter, sizeof(pECCDeductLogBody->LoyaltyCounter));//17 LOYALTY_COUNTER 累積忠誠點 Unsigned 2
;;;357                                                                                                                                //來源: 設備
;;;358                                                                                                                                //預設填 2 Bytes 0x00
;;;359    //#warning different from leon sample
;;;360        //2018.08.14  --> D. 【AGENT_NO】操作員代碼：應與加值LOG欄位相同。
;;;361        uint32ToUint8(AgentNo, pECCDeductLogBody->AgentNo, sizeof(pECCDeductLogBody->AgentNo));//18 AGENT_NO 操作員代碼 Unsigned 2
;;;362                                                                                                            //如 Ascii 字元'1234'即為 0x31 0x32 0x33 0x34
;;;363                                                                                                            //轉 10 進制數值 1234 即為 0x04 0xD2
;;;364                                                                                                            //以 LSB FIRST 傳送: 0xD2 0x04
;;;365                                                                                                            //來源: 設備
;;;366                                                                                                            //此欄位 10 進制數值應與 PPR_Reset/PPR_Reset_Online 一致
;;;367                                                                                                            //預設填 2 Bytes 0x00
;;;368        if (PVN != 0x00) 
;;;369        {
;;;370            memset(pECCDeductLogBody->CarPlateNo, 0x20, sizeof(pECCDeductLogBody->CarPlateNo));     //20 CAR_PLATE_NO 車牌號碼 Ascii 10 來源: 設備
;;;371            
;;;372            //2018.08.14 -->  F. 【RFU1-XFER_PRE_SEQ_NO】轉乘上筆交易序號：應填轉乘上筆交易序號，卻填 0。
;;;373            pECCDeductLogBody->RFU1XferPreSeqNo[0] = DCAReadData->TSQNofURT[2];
;;;374            pECCDeductLogBody->RFU1XferPreSeqNo[1] = DCAReadData->TSQNofURT[1];
;;;375            pECCDeductLogBody->RFU1XferPreSeqNo[2] = DCAReadData->TSQNofURT[0];
;;;376            //2018.08.14 --> G.【RFU1-CARD_TYPE】票別：應填票卡卡種，卻填 0。
;;;377            pECCDeductLogBody->RFU1CardType = DCAReadData->CardType;
;;;378            //2018.08.14 --> H.【RFU1-XFER_PRE_TIMESTAMP】上筆交易時間：應填轉乘上筆交易時間，卻都填 1970/1/1 00:00:00。
;;;379            //memcpy(pECCDeductLogBody->RFU1XferPreTimeStamp, DCAReadData->TXNDateTimeofURT, sizeof(pECCDeductLogBody->RFU1XferPreTimeStamp));
;;;380            pECCDeductLogBody->RFU1XferPreTimeStamp[0] = DCAReadData->TXNDateTimeofURT[3];
;;;381            pECCDeductLogBody->RFU1XferPreTimeStamp[1] = DCAReadData->TXNDateTimeofURT[2];
;;;382            pECCDeductLogBody->RFU1XferPreTimeStamp[2] = DCAReadData->TXNDateTimeofURT[1];
;;;383            pECCDeductLogBody->RFU1XferPreTimeStamp[3] = DCAReadData->TXNDateTimeofURT[0];
;;;384    
;;;385            
;;;386            
;;;387            //2018.08.14  --> I.【RFU1_VER】欄位版本：應填 01，卻填 00。
;;;388            pECCDeductLogBody->RFU1Ver = 0x01;                //23 RFU1_VER 欄位版本(共用) Unsigned 1
;;;389                                                                    //PVN <> 0 時:
;;;390                                                                        //固定填 0x00
;;;391                                                                    //PVN = 0 時:
;;;392                                                                        //固定填 0x00
;;;393            
;;;394            //2018.08.14 --> J.【RFU2-SUB_LOC_ID】附屬場站代碼：應填 50，卻填 00
;;;395            //memcpy(pECCDeductLogBody->RFU2SubLocId, DCAReadData->NewLocationID, sizeof(pECCDeductLogBody->RFU2SubLocId));
;;;396            sysprintf("\r\n====  ECCDeductLogContainInit: (1) RFU2SubLocId = [0x%02x, 0x%02x], LocationID = 0x%02x, NewLocationID = [0x%02x, 0x%02x] ====\r\n", 
;;;397                        pECCDeductLogBody->RFU2SubLocId[0], pECCDeductLogBody->RFU2SubLocId[1], DCAReadData->LocationID, DCAReadData->NewLocationID[0], DCAReadData->NewLocationID[1]);
;;;398            //pECCDeductLogBody->RFU2SubLocId[0] = DCAReadData->NewLocationID[1];
;;;399            //pECCDeductLogBody->RFU2SubLocId[1] = DCAReadData->NewLocationID[0];
;;;400            pECCDeductLogBody->RFU2SubLocId[0] = 0x0;
;;;401            pECCDeductLogBody->RFU2SubLocId[1] = DCAReadData->LocationID;
;;;402            
;;;403            sysprintf("\r\n====  ECCDeductLogContainInit: (2) RFU2SubLocId = [0x%02x, 0x%02x], LocationID = 0x%02x, NewLocationID = [0x%02x, 0x%02x] ====\r\n", 
;;;404                        pECCDeductLogBody->RFU2SubLocId[0], pECCDeductLogBody->RFU2SubLocId[1], DCAReadData->LocationID, DCAReadData->NewLocationID[0], DCAReadData->NewLocationID[1]);
;;;405          
;;;406            //2018.08.14  --> K.【RFU2_VER】欄位版本：應填 01，卻填 00。
;;;407            pECCDeductLogBody->RFU2Ver = 0x01;                 //25 RFU2_VER 欄位版本(業者) Unsigned 1
;;;408                                                                    //PVN <> 0 時:
;;;409                                                                        //定義參照 8.11
;;;410                                                                        //未定義: 固定填 0x00
;;;411                                                                    //PVN = 0 時:
;;;412                                                                        //固定填 0x00
;;;413            
;;;414            
;;;415            pECCDeductLogBody->TM = EDCADeductData->TM;     //26 TM(TXN Mode) 交易模式 Byte 1
;;;416                                                                //PVN <> 0 時: 來源: 設備
;;;417                                                                //PVN = 0 時: 固定填 0x00
;;;418            pECCDeductLogBody->TQ = EDCADeductData->TQ;     //27 TQ(TXN Qualifier) 交易屬性 Byte 1
;;;419                                                                //PVN <> 0 時: 來源: 設備
;;;420                                                                //PVN = 0 時: 固定填 0x00
;;;421            pECCDeductLogBody->SignKeyVer = EDCADeductData->SignatureKeyKVN;             //28 SIGN_KEYVER SIGNATURE KEY 版本 Byte 1
;;;422                                                                                                //PVN <> 0 時:
;;;423                                                                                                    //來源: Cpu 卡
;;;424                                                                                                //PVN = 0 時:
;;;425                                                                                                    //固定填 0x00
;;;426            memcpy(pECCDeductLogBody->SignValue, EDCADeductData->SIGN, sizeof(pECCDeductLogBody->SignValue)); //29 SIGN_VALUE SIGNATURE 值 Byte 16
;;;427                                                                                                                    //PVN <> 0 時:
;;;428                                                                                                                        //來源: Cpu 卡
;;;429                                                                                                                    //PVN = 0 時:
;;;430                                                                                                                        //固定填 16 Bytes 0x00
;;;431        }
;;;432        else//if (PVN != 0x00) 
;;;433        {//0x00：Mifare／Level1；
;;;434            //2018.08.14  --> E. 【CAR_PLATE_NO】汽車車牌號碼：應填20202020202020202020，M卡與 L1卡卻填00000000000000000000。
;;;435            memset(pECCDeductLogBody->CarPlateNo, 0x20, sizeof(pECCDeductLogBody->CarPlateNo));     //20 CAR_PLATE_NO 車牌號碼 Ascii 10 來源: 設備
;;;436            
;;;437            //2018.08.14 -->  F. 【RFU1-XFER_PRE_SEQ_NO】轉乘上筆交易序號：應填轉乘上筆交易序號，卻填 0。
;;;438            pECCDeductLogBody->RFU1XferPreSeqNo[0] = DCAReadData->TSQNofURT[2];
;;;439            pECCDeductLogBody->RFU1XferPreSeqNo[1] = DCAReadData->TSQNofURT[1];
;;;440            pECCDeductLogBody->RFU1XferPreSeqNo[2] = DCAReadData->TSQNofURT[0];
;;;441            //2018.08.14 --> G.【RFU1-CARD_TYPE】票別：應填票卡卡種，卻填 0。
;;;442            pECCDeductLogBody->RFU1CardType = DCAReadData->CardType;
;;;443            //2018.08.14 --> H.【RFU1-XFER_PRE_TIMESTAMP】上筆交易時間：應填轉乘上筆交易時間，卻都填 1970/1/1 00:00:00。
;;;444            //memcpy(pECCDeductLogBody->RFU1XferPreTimeStamp, DCAReadData->TXNDateTimeofURT, sizeof(pECCDeductLogBody->RFU1XferPreTimeStamp));
;;;445            pECCDeductLogBody->RFU1XferPreTimeStamp[0] = DCAReadData->TXNDateTimeofURT[3];
;;;446            pECCDeductLogBody->RFU1XferPreTimeStamp[1] = DCAReadData->TXNDateTimeofURT[2];
;;;447            pECCDeductLogBody->RFU1XferPreTimeStamp[2] = DCAReadData->TXNDateTimeofURT[1];
;;;448            pECCDeductLogBody->RFU1XferPreTimeStamp[3] = DCAReadData->TXNDateTimeofURT[0];
;;;449            
;;;450            
;;;451            //2018.08.14  --> I.【RFU1_VER】欄位版本：應填 01，卻填 00。
;;;452            pECCDeductLogBody->RFU1Ver = 0x01;                //23 RFU1_VER 欄位版本(共用) Unsigned 1
;;;453                                                                    //PVN <> 0 時:
;;;454                                                                        //固定填 0x00
;;;455                                                                    //PVN = 0 時:
;;;456                                                                        //固定填 0x00
;;;457            
;;;458            //2018.08.14 --> J.【RFU2-SUB_LOC_ID】附屬場站代碼：應填 50，卻填 00
;;;459            //memcpy(pECCDeductLogBody->RFU2SubLocId, DCAReadData->NewLocationID, sizeof(pECCDeductLogBody->RFU2SubLocId));
;;;460            sysprintf("\r\n====  ECCDeductLogContainInit: (1) RFU2SubLocId = [0x%02x, 0x%02x], LocationID = 0x%02x, NewLocationID = [0x%02x, 0x%02x] ====\r\n", 
;;;461                        pECCDeductLogBody->RFU2SubLocId[0], pECCDeductLogBody->RFU2SubLocId[1], DCAReadData->LocationID, DCAReadData->NewLocationID[0], DCAReadData->NewLocationID[1]);
;;;462            //pECCDeductLogBody->RFU2SubLocId[0] = DCAReadData->NewLocationID[1];
;;;463            //pECCDeductLogBody->RFU2SubLocId[1] = DCAReadData->NewLocationID[0];
;;;464            pECCDeductLogBody->RFU2SubLocId[0] = 0x0;
;;;465            pECCDeductLogBody->RFU2SubLocId[1] = DCAReadData->LocationID;
;;;466            
;;;467            sysprintf("\r\n====  ECCDeductLogContainInit: (2) RFU2SubLocId = [0x%02x, 0x%02x], LocationID = 0x%02x, NewLocationID = [0x%02x, 0x%02x] ====\r\n", 
;;;468                        pECCDeductLogBody->RFU2SubLocId[0], pECCDeductLogBody->RFU2SubLocId[1], DCAReadData->LocationID, DCAReadData->NewLocationID[0], DCAReadData->NewLocationID[1]);
;;;469          
;;;470            //2018.08.14  --> K.【RFU2_VER】欄位版本：應填 01，卻填 00。
;;;471            pECCDeductLogBody->RFU2Ver = 0x01;                 //25 RFU2_VER 欄位版本(業者) Unsigned 1
;;;472                                                                    //PVN <> 0 時:
;;;473                                                                        //定義參照 8.11
;;;474                                                                        //未定義: 固定填 0x00
;;;475                                                                    //PVN = 0 時:
;;;476                                                                        //固定填 0x00
;;;477        }
;;;478    
;;;479        #if(1)
;;;480        prData = (uint8_t*)pECCDeductLogBody; 
;;;481        prData = prData + sizeof(ECCLogHeader);
;;;482        prDataLen = sizeof(ECCDeductLogBody) - sizeof(ECCLogHeader) - sizeof(ECCLogTail);
;;;483        sysprintf("--- pECCDeductLogBody:  len = %d --->\r\n", prDataLen);
;;;484        for(i = 0; i<prDataLen; i++)
;;;485        {
;;;486            //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;487            sysprintf("0x%02x, ", prData[i]);
;;;488            if(i%10 == 9)
;;;489                sysprintf("\r\n");
;;;490    
;;;491        }
;;;492        sysprintf("\r\n<--- pECCDeductLogBody ---\r\n");
;;;493        #endif
;;;494        // ********   Tail   ********
;;;495        #warning need check here
;;;496        if (PVN == 0x00) 
;;;497        {
;;;498             memcpy(&(pECCDeductLogBody->Tail.MACKeySet), EDCADeductData->MAC, 10); //MAC 10 bytes        
;;;499        }
;;;500        else
;;;501        {
;;;502            //pECCDeductLogBody->Tail.MACKeySet = 0x00;          //1 MACKeySet 0x00 Byte 1 固定填 0x00
;;;503            //pECCDeductLogBody->Tail.MAC3DESKey = 0x01;         //2 MAC3DESKey 0x01 Byte 1 固定填 0x01
;;;504            //uint8_t         MACValue[4];                //3 MACValue 交易驗証碼 Unsigned 4
;;;505                                                                //PVN <> 0 時: 固定填 4 Bytes 0x00
;;;506                                                                //PVN = 0 時: 來源:設備
;;;507            //uint8_t         MACMFRC[4];                 //4 MACMFRC 讀卡機編號 Unsigned 4
;;;508                                                                //PVN <> 0 時: 固定填 4 Bytes 0x00
;;;509                                                                //PVN = 0 時: 來源:設備
;;;510        }
;;;511        pECCDeductLogBody->Tail.MAC3DESKey = 0x01;         //2 MAC3DESKey 0x01 Byte 1 固定填 0x01
;;;512    
;;;513        if (PVN != 0x00) 
;;;514        {
;;;515            memcpy(pECCDeductLogBody->Tail.SAMID, EDCADeductData->SID, sizeof(pECCDeductLogBody->Tail.SAMID)); //5 SAM_ID SAM ID Pack 8
;;;516                                                            //PVN <> 0 時: 來源: Cpu Sam 卡
;;;517                                                            //PVN = 0 時: 來源:設備
;;;518        }
;;;519        if (PVN != 0x00) 
;;;520        {
;;;521            pECCDeductLogBody->Tail.HashType = EDCADeductData->HashType;  //6 HASH_TYPE HASH_TYPE Unsigned 1
;;;522                                                            //PVN <> 0 時: 代碼參照 8.4 來源: 設備
;;;523                                                            //PVN = 0 時: 固定填 0x00
;;;524        }
;;;525        else
;;;526        {
;;;527            pECCDeductLogBody->Tail.HashType = 0x00;
;;;528        }
;;;529    
;;;530        if (PVN != 0x00) 
;;;531        {
;;;532            pECCDeductLogBody->Tail.HostAdminKeyVer = EDCADeductData->HostAdminKeyKVN;            //7 HOST_ADMIN_KEYVER HOST ADMIN KEY 版本 Byte 1
;;;533                                                            //PVN <> 0 時: MAC 用哪個版本 KEY 去押的  來源: Cpu Sam 卡
;;;534                                                            //PVN = 0 時: 固定填 0x00
;;;535        }
;;;536        else
;;;537        {
;;;538            pECCDeductLogBody->Tail.HostAdminKeyVer = 0x00;
;;;539        }   
;;;540        if (PVN != 0x00) 
;;;541        {
;;;542            memcpy(pECCDeductLogBody->Tail.CpuMACValue, EDCADeductData->MAC, sizeof(pECCDeductLogBody->Tail.CpuMACValue)); //8 CPU_MAC_VALUE MAC 值 Byte 16                        
;;;543                                                            //PVN <> 0 時: 來源: Cpu Sam 卡計算
;;;544                                                            //PVN = 0 時: 固定填 16 Bytes 0x00
;;;545        }
;;;546        else
;;;547        {
;;;548            memset(pECCDeductLogBody->Tail.CpuMACValue, 0x00, sizeof(pECCDeductLogBody->Tail.CpuMACValue));
;;;549        }
;;;550        #if(1)
;;;551        prData = (uint8_t*)&(pECCDeductLogBody->Tail);
;;;552        prDataLen = sizeof(pECCDeductLogBody->Tail);
;;;553        sysprintf("--- pECCDeductLogBody->Tail:  len = %d --->\r\n", prDataLen);
;;;554        for(i = 0; i<prDataLen; i++)
;;;555        {
;;;556            //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;557            sysprintf("0x%02x, ", prData[i]);
;;;558            if(i%10 == 9)
;;;559                sysprintf("\r\n");
;;;560    
;;;561        }
;;;562        sysprintf("\r\n<--- pECCDeductLogBody->Tail ---\r\n");
;;;563        #endif
;;;564        
;;;565    #if(ECC_LOG_USE_NEW_FILE_NAME)
;;;566        //咪表ID_訂單號_時間(yyyyMMddHHmmss)_001U.ECC
;;;567        sprintf(currentECCDeductLogFileName, "%s_%s_%s_001U.ECC", GetMeterData()->epmIdStr, GetMeterData()->bookingId, getECCLogUTCTimeStr(utcTime));
;;;568    #else
;;;569        SP_ID_INT = DCAReadData->ServiceProviderID;
;;;570        SP_ID_INT_NEW = uint8ToUint32(DCAReadData->NewServiceProviderID, sizeof(DCAReadData->NewServiceProviderID));
;;;571        LOCATION_ID_INT_NEW = uint8ToUint32(DCAReadData->NewLocationID, sizeof(DCAReadData->NewLocationID));
;;;572        sprintf(currentECCDeductLogFileName, "00220.%03d_%08d_%05d_00000.%s_001U.ECC", SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW, getECCLogUTCTimeStr(utcTime));
;;;573    #endif
;;;574    
;;;575        //sysprintf("\r\n====  ECCLogInit Body:[%s]\r\n", pECCDeductLogBody);    
;;;576        return TRUE;
;;;577        #endif
;;;578    }
000188  e8bd81f0          POP      {r4-r8,pc}
;;;579    /*
                          ENDP

                  ECCDeductLogGetFileName PROC
;;;585    */
;;;586    char* ECCDeductLogGetFileName(void)
00018c  e59f00a8          LDR      r0,|L1.572|
;;;587    {
;;;588        return currentECCDeductLogFileName;
;;;589    }
000190  e12fff1e          BX       lr
;;;590    
                          ENDP

                  ECCReSendLogContainInit PROC
;;;591    BOOL ECCReSendLogContainInit(ECCReSendLogBody* body, uint32_t deductValue, uint32_t AgentNo, uint32_t utcTime, BOOL cardAutoloadAvailable, ECCCmdDCAReadResponseSuccessData* DCAReadData, int DCAReadDataLen, ECCCmdEDCADeductResponseData* EDCADeductData, int EDCADeductDataLen)
000194  e92d41f0          PUSH     {r4-r8,lr}
;;;592    {
000198  e1a08000          MOV      r8,r0
00019c  e28d701c          ADD      r7,sp,#0x1c
0001a0  e89700f0          LDM      r7,{r4-r7}
0001a4  e59dc018          LDR      r12,[sp,#0x18]
;;;593        #if(1)
;;;594        return TRUE;
0001a8  e3a00001          MOV      r0,#1
;;;595        #else
;;;596        uint32_t i;
;;;597        uint8_t* prData; 
;;;598        uint32_t prDataLen;
;;;599        ECCReSendLogBody* pECCReSendLogBody = body;
;;;600        uint8_t PVN;// = DCAReadData->PurseVersionNumber;
;;;601        #if(!ECC_LOG_USE_NEW_FILE_NAME)
;;;602        uint32_t SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW;
;;;603        #endif
;;;604    
;;;605        LastCreditTXNLogData* pLastCreditTXNLogData = &(DCAReadData->LastCreditTXNLog);
;;;606        sysprintf("\r\n====  ECCReSendLogContainInit(%s) ====\r\n", GetMeterData()->epmIdStr);
;;;607        sysprintf("sizeof(ECCReSendLogBody) = %d\r\n", sizeof(ECCReSendLogBody));
;;;608    
;;;609        if(sizeof(ECCReSendLogBody) != TOTAL_ECC_RESEND_LOG_BODY_SIZE)
;;;610        {
;;;611            sysprintf("ECCReSendLogContainInit ERROR: sizeof(ECCReSendLogBody) != TOTAL_ECC_RESEND_LOG_BODY_SIZE [%d, %d]\r\n", sizeof(ECCReSendLogBody), TOTAL_ECC_RESEND_LOG_BODY_SIZE);
;;;612            return FALSE;
;;;613        }
;;;614        memset(pECCReSendLogBody, 0x00, sizeof(ECCReSendLogBody));
;;;615        PVN = pLastCreditTXNLogData->PurseVersionNumber;
;;;616        pECCReSendLogBody->PurseVerNo = pLastCreditTXNLogData->PurseVersionNumber;      //1 PURSE_VER_NO 卡片版本 Unsigned 1 代碼參照 8.1 來源: 設備
;;;617        pECCReSendLogBody->CardTxnTypeID = 0x0C;                    //(固定填 0x0C)     //2 CARD_TXN_TYPE_ID 交易類別 Unsigned 1 代碼參照 8.2 來源: 設備
;;;618        pECCReSendLogBody->CardTxnSubTypeID = pLastCreditTXNLogData->SubType;           //3 CARD_TXN_SUBTYPE_ID 交易次類別(卡片) Unsigned 1 依現況設備邏輯填入 代碼參照 8.3
;;;619        if (PVN == 0x02)
;;;620        {
;;;621            memcpy(pECCReSendLogBody->CardDevID, pLastCreditTXNLogData->DeviceID, sizeof(pECCReSendLogBody->CardDevID));        //4 CARD_DEV_ID 設備編號(卡片) Unsigned 6   PVN=2，同 NEW_DEV_ID 如:
;;;622        }                                                                                           //NEW_SP_ID=49(0x31)
;;;623        else                                                                                            //NEW_DEV_TYPE=12(0x0C)
;;;624        {                                                                                            //NEW_DEV_ID_NO=99(0x63)
;;;625            pECCReSendLogBody->CardDevID[0] = pLastCreditTXNLogData->DeviceID[2];                        //組合 HEX: 00-00-31-0C-00-63
;;;626            pECCReSendLogBody->CardDevID[1] = pLastCreditTXNLogData->DeviceID[0];                        //以 LSB FIRST 傳送: 63-00-0C-31-00-00
;;;627            pECCReSendLogBody->CardDevID[2] = pLastCreditTXNLogData->DeviceID[1];                    //PVN<>2，同 DEV_ID，右補 3 Bytes 0x00
;;;628            pECCReSendLogBody->CardDevID[3] = pLastCreditTXNLogData->DeviceID[3];                        //同上例，組合 HEX: 31-C0-63
;;;629            pECCReSendLogBody->CardDevID[4] = pLastCreditTXNLogData->DeviceID[4];                        //倒數2 Bytes LSB FIRST: 31-63-C0
;;;630            pECCReSendLogBody->CardDevID[5] = pLastCreditTXNLogData->DeviceID[5];                        //右補 3 Bytes 0x00: 31-63-C0-00-00-00
;;;631        }                                                                                          //範例參照 8.6
;;;632                                                                                                    //來源: 卡片
;;;633        memcpy(pECCReSendLogBody->CardSpID, pLastCreditTXNLogData->ServiceProviderID, sizeof(pECCReSendLogBody->CardSpID));  //5 CARD_SP_ID 業者代碼(卡片) Unsigned 3 PVN=2，同 NEW_SP_ID
;;;634                                                                                                                            //PVN<>2，同 SP_ID
;;;635                                                                                                                            //來源: 卡片
;;;636        memcpy(&(pECCReSendLogBody->TxnTimeStamp), &(pLastCreditTXNLogData->TXNDateTime), sizeof(pECCReSendLogBody->TxnTimeStamp));  //6 TXN_TIMESTAMP 交易時間(卡片) UnixTime 4 來源: 卡片
;;;637        memcpy(pECCReSendLogBody->CardPhysicalID, DCAReadData->CardPhysicalID, sizeof(pECCReSendLogBody->CardPhysicalID));  //7 CARD_PHYSICAL_ID 卡片晶片號碼 Unsigned 7 來源: 卡片
;;;638        pECCReSendLogBody->IssuerID = DCAReadData->IssuerCode;               //8 ISSUER_ID 發卡單位 Unsigned 1     PVN <> 0 時: 來源: Cpu 卡
;;;639                                                                                        //PVN = 0 時:
;;;640                                                                                            //2 (0x02)：悠遊卡公司
;;;641                                                                                            //66 (0x42)：基隆交通卡
;;;642                                                                                            //來源: 設備
;;;643        memcpy(pECCReSendLogBody->CardTxnSwqNo, pLastCreditTXNLogData->TSQN, sizeof(pECCReSendLogBody->CardTxnSwqNo));//9 CARD_TXN_SEQ_NO 交易後序號(卡片) Unsigned 3 來源: 卡片
;;;644        memcpy(pECCReSendLogBody->TxnAMT, pLastCreditTXNLogData->TXNAMT, sizeof(pECCReSendLogBody->TxnAMT));           //10 TXN_AMT 交易金額(卡片) Signed 3 來源: 卡片
;;;645        memcpy(pECCReSendLogBody->ElectronicValue, pLastCreditTXNLogData->EV, sizeof(pECCReSendLogBody->ElectronicValue));    //11 ELECTRONIC_VALUE 交易後卡片金額(卡片) Signed 3 來源: 卡片
;;;646        memcpy(pECCReSendLogBody->CardSvceLocID, pLastCreditTXNLogData->LocationID, sizeof(pECCReSendLogBody->CardSvceLocID));       //12 CARD_SVCE_LOC_ID 場站代碼(卡片) Unsigned 2
;;;647                                                                                                                                            //PVN=2，NEW_SVCE_LOC_ID
;;;648                                                                                                                                            //PVN<>2，SVCE_LOC_ID
;;;649                                                                                                                                            //來源: 卡片
;;;650        pECCReSendLogBody->CardPhysicalIDLen = DCAReadData->CardPhysicalIDLength;      //13 CARD_PHYSICAL_ID_LEN 晶片號碼長度 Unsigned 1
;;;651                                                                                                        //如 4 bytes 即為 0x04
;;;652                                                                                                        //如 7 bytes 即為 0x07
;;;653                                                                                                        //來源: 卡片
;;;654        pECCReSendLogBody->NewPersonalProfile = DCAReadData->PersonalProfile;     //14 NEW_PERSONAL_PROFILE 新身份別 Unsigned 1
;;;655                                                                                                        //0x00: 一般
;;;656                                                                                                        //0x01: 敬老 1
;;;657                                                                                                        //0x02: 敬老 2
;;;658                                                                                                        //0x03: 愛心
;;;659                                                                                                        //0x04: 陪伴
;;;660                                                                                                        //0x05: 學生
;;;661                                                                                                        //0x08: 優待
;;;662                                                                                                        //來源: 卡片
;;;663        memcpy(pECCReSendLogBody->CardPurseID, &(DCAReadData->PID), sizeof(pECCReSendLogBody->CardPurseID)); //15 CARD_PURSE_ID 錢包編號(外觀號碼) Pack 8
;;;664                                                                                        //PVN <> 0 時:
;;;665                                                                                            //如卡號 1234567890123456
;;;666                                                                                            //即為 0x12 0x34 0x56 0x78 0x90 0x12 0x34 0x56
;;;667                                                                                            //代碼參照 8.5
;;;668                                                                                            //來源: Cpu 卡
;;;669                                                                                        //PVN = 0 時:
;;;670                                                                                            //固定填 8 Bytes 0x00
;;;671        pECCReSendLogBody->BankCode = DCAReadData->BankCode; //16 BANK_CODE 銀行代碼 Unsigned 1    PVN <> 0 時:
;;;672                                                                //固定填 0x00
;;;673                                                                //PVN = 0 時:
;;;674                                                                //來源: 卡片
;;;675        memcpy(pECCReSendLogBody->LoyaltyCounter, DCAReadData->LoyaltyCounter, sizeof(pECCReSendLogBody->LoyaltyCounter));      //17 LOYALTY_COUNTER 累積忠誠點 Unsigned 2 來源: 設備
;;;676        pECCReSendLogBody->ResendDevID[0] = DCAReadData->DeviceID[2];         //18 RESEND_DEV_ID 重送設備編號 Unsigned 3 
;;;677        pECCReSendLogBody->ResendDevID[1] = DCAReadData->DeviceID[0];           //SP_ID(1 Byte): 如 122 即為 0x7A
;;;678        pECCReSendLogBody->ResendDevID[2] = DCAReadData->DeviceID[1];           //DEV_TYPE(4 Bits):  3：BV 如 BV 即為 0x30
;;;679                                                                                //DEV_ID_NO(12 Bites): 如 1234 即為 0x04 0xD2
;;;680                                                                                //組合 HEX: 0x7A 0x34 0xD2
;;;681                                                                                //倒數2 Bytes LSB FIRST:  0x7A 0xD2 0x34
;;;682                                                                                //範例參照 8.6
;;;683                                                                                //來源: Mifare Sam 卡
;;;684        pECCReSendLogBody->ResendSpID = DCAReadData->ServiceProviderID;             //19 RESEND_SP_ID 重送業者代碼 Unsigned 1  如 122 即為 0x7A  來源: 設備
;;;685        pECCReSendLogBody->ResendLocID = DCAReadData->LocationID;            //20 RESEND_LOC_ID 重送場站代碼 Unsigned 1 來源: 設備
;;;686        memcpy(pECCReSendLogBody->ResendNewDevID, DCAReadData->NewDeviceID, sizeof(pECCReSendLogBody->ResendNewDevID));         //21 RESEND_NEW_DEV_ID 重送新設備編號 Unsigned 6 
;;;687                                                                //NEW_SP_ID(3 Bytes): 122 即為 0x00 0x00 0x7A
;;;688                                                                //NEW_DEV_TYPE(1 Byte): 3：BV  如 3 即為 0x03
;;;689                                                                    //4096(含)之後開始編碼
;;;690                                                                //NEW_DEV_ID_NO (2 Bytes): 如 4096 即為 0x10 0x00
;;;691                                                                //組合 HEX: 0x00 0x00 0x7A 0x03 0x10 0x00
;;;692                                                                //以 LSB FIRST 傳送: 0x00 0x10 0x03 0x7A 0x00 0x00
;;;693                                                                //範例參照 8.6
;;;694                                                                //來源: Cpu Sam 卡
;;;695        memcpy(pECCReSendLogBody->ResendNewSpID, DCAReadData->NewServiceProviderID, sizeof(pECCReSendLogBody->ResendNewSpID));  //22 RESEND_NEW_SP_ID 重送新業者代碼 Unsigned 3
;;;696                                                                //NEW_SP_ID(3 Bytes): 如 122 即為 0x00 0x00 0x7A
;;;697                                                                //以 LSB FIRST 傳送: 0x7A 0x00 0x00
;;;698                                                                //來源: 設備
;;;699        memcpy(pECCReSendLogBody->ResendNewLocID, DCAReadData->NewLocationID, sizeof(pECCReSendLogBody->ResendNewLocID));       //23 RESEND_NEW_LOC_ID 重送新場站代碼 Unsigned 2
;;;700                                                                //NEW_SVCE_LOC_ID (2 Bytes): 如 1 即為 0x00 0x01
;;;701                                                                //以 LSB FIRST 傳送: 0x01 0x00
;;;702                                                                //來源: 設備
;;;703        
;;;704       
;;;705        
;;;706    #if(ECC_LOG_USE_NEW_FILE_NAME)
;;;707        //咪表ID_訂單號_時間(yyyyMMddHHmmss)_001U.ECC
;;;708        sprintf(currentECCReSendLogFileName, "%s_%s_%s_012U.ECC", GetMeterData()->epmIdStr, GetMeterData()->bookingId, getECCLogUTCTimeStr(utcTime));
;;;709    #else
;;;710        SP_ID_INT = DCAReadData->ServiceProviderID;
;;;711        SP_ID_INT_NEW = uint8ToUint32(DCAReadData->NewServiceProviderID, sizeof(DCAReadData->NewServiceProviderID));
;;;712        LOCATION_ID_INT_NEW = uint8ToUint32(DCAReadData->NewLocationID, sizeof(DCAReadData->NewLocationID));
;;;713        sprintf(currentECCReSendLogFileName, "00220.%03d_%08d_%05d_00000.%s_012U.ECC", SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW, getECCLogUTCTimeStr(utcTime));
;;;714    #endif    
;;;715        #if(1)
;;;716        prData = (uint8_t*)&(pECCReSendLogBody);
;;;717        prDataLen = sizeof(ECCReSendLogBody);
;;;718        sysprintf("--- pECCReSendLogBody:  len = %d --->\r\n", prDataLen);
;;;719        for(i = 0; i<prDataLen; i++)
;;;720        {
;;;721            //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;722            sysprintf("0x%02x, ", prData[i]);
;;;723            if(i%10 == 9)
;;;724                sysprintf("\r\n");
;;;725    
;;;726        }
;;;727        sysprintf("\r\n<--- pECCReSendLogBody ---\r\n");
;;;728        #endif
;;;729        return TRUE;
;;;730        #endif
;;;731    }
0001ac  e8bd81f0          POP      {r4-r8,pc}
;;;732    char* ECCReSendLogGetFileName(void)
                          ENDP

                  ECCReSendLogGetFileName PROC
0001b0  e59f0088          LDR      r0,|L1.576|
;;;733    {
;;;734        return currentECCReSendLogFileName;
;;;735    }
0001b4  e12fff1e          BX       lr
;;;736    BOOL ECCLockCardLogContainInit(ECCLockCardLogBody* body, uint32_t lockType, uint8_t newSpID, uint8_t svceLocID, char* blkFileName, 
                          ENDP

                  ECCLockCardLogContainInit PROC
0001b8  e92d40f0          PUSH     {r4-r7,lr}
;;;737                                        uint32_t utcTime, uint8_t* DCAReadData, ECCCmdLockCardResponseData* LockCardResponseData)
;;;738    {
0001bc  e1a07000          MOV      r7,r0
0001c0  e28d6018          ADD      r6,sp,#0x18
0001c4  e8960070          LDM      r6,{r4-r6}
0001c8  e59dc014          LDR      r12,[sp,#0x14]
;;;739            #if(1)
;;;740        return TRUE;
0001cc  e3a00001          MOV      r0,#1
;;;741        #else
;;;742        uint32_t i;
;;;743        uint8_t* prData; 
;;;744        uint32_t prDataLen;
;;;745        int targetblkFileNameLen;
;;;746        ECCCmdLockCardResponseData* TargetLockCardResponseData;
;;;747        
;;;748        char* blkFileNameExtension = getExtension(blkFileName);
;;;749        uint8_t PVN;
;;;750        LastCreditTXNLogData AddValueBytes;
;;;751    
;;;752        // --> 只有以下狀況 <--
;;;753        //0x9000                                >>> "鎖卡成功" 
;;;754        //==> USE readSuccessData:              [the sam as DCAReadData]
;;;755        //==> USE TargetLockCardResponseData:   [the sam as LockCardResponseData]
;;;756        ECCCmdDCAReadResponseSuccessData*    readSuccessData = (ECCCmdDCAReadResponseSuccessData*)DCAReadData;
;;;757    
;;;758        //0x640E(餘額異常) or 0x6418(通路限制)  >>> "讀卡失敗"      ... 0x6418(通路限制) 目前沒用到
;;;759        //==> USE readError1Data:                   [the sam as DCAReadData]
;;;760        //=??=> USE TargetLockCardResponseData:     [the sam as LockCardResponseData]
;;;761        ECCCmdDCAReadResponseError1Data*    readError1Data = (ECCCmdDCAReadResponseError1Data*)DCAReadData; 
;;;762    
;;;763        //0x6103(CPD檢查異常)                   >>> "讀卡失敗"  
;;;764        //==> USE TargetLockCardResponseData:   [cthe sam as DCAReadData]  --> 跟 LockCard response (0x9000) structure 相同 
;;;765    
;;;766    
;;;767        ECCLockCardLogBody* pECCLockCardLogBody = body;
;;;768        sysprintf("\r\n====  ECCLockCardLogContainInit (blkFileName = [%s](%d), Extension = [%s])====\r\n", 
;;;769                                                                                blkFileName, strlen(blkFileName), blkFileNameExtension);
;;;770        sysprintf("sizeof(ECCLockCardLogBody) = %d\r\n", sizeof(ECCLockCardLogBody));
;;;771    
;;;772        if(sizeof(ECCLockCardLogBody) != TOTAL_ECC_LOCK_CARD_LOG_BODY_SIZE)
;;;773        {
;;;774            sysprintf("ECCLockCardLogContainInit ERROR: sizeof(ECCLockCardLogBody) != TOTAL_ECC_BLK_FEEDBACK_LOG_BODY_SIZE [%d, %d]\r\n", sizeof(ECCLockCardLogBody), TOTAL_ECC_BLK_FEEDBACK_LOG_BODY_SIZE);
;;;775            return FALSE;
;;;776        }
;;;777        memset(pECCLockCardLogBody, 0x00, sizeof(ECCLockCardLogBody));
;;;778        
;;;779        //*** body ***//
;;;780        if(lockType == ECC_CMD_READ_ERROR_2_ID_1)// 0x6103 (CPD檢查異常) --> (//跟 LockCard response (0x9000) structure 相同)
;;;781        {
;;;782            //memcpy(DCAReadData, &TargetLockCardResponseData, sizeof(ECCCmdLockCardResponseData));
;;;783            TargetLockCardResponseData = (ECCCmdLockCardResponseData*)DCAReadData;
;;;784        }
;;;785        else
;;;786        {
;;;787            //memcpy(LockCardResponseData, &TargetLockCardResponseData, sizeof(ECCCmdLockCardResponseData));
;;;788            TargetLockCardResponseData = (ECCCmdLockCardResponseData*)LockCardResponseData;
;;;789        }
;;;790    
;;;791        PVN = readSuccessData->PurseVersionNumber;
;;;792    
;;;793        //2018.08.14  --> //A.【PURSE_VER_NO】卡片版本：CPU_L1卡應填 01，卻填 00。
;;;794        //1 PURSE_VER_NO 卡片版本 Unsigned 1 代碼參照 8.1 來源: 設備
;;;795        //票卡版號    0x00：Mifare／Level1；
;;;796        //            0x02：Level2
;;;797        //EDCA READ 無法分辨
;;;798        //pECCLockCardLogBody->PurseVerNo = readSuccessData->PurseVersionNumber; 
;;;799        pECCLockCardLogBody->PurseVerNo = LockCardResponseData->PurseVersionNumber;     
;;;800    
;;;801        //2 CARD_TXN_TYPE_ID 交易類別 Unsigned 1 代碼參照 8.2 來源: 設備
;;;802        pECCLockCardLogBody->CardTxnTypeID = 0x22;  //(固定填0x22)          
;;;803        
;;;804        //3 CARD_TXN_SUBTYPE_ID 交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照8.3
;;;805        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)      
;;;806        {
;;;807            pECCLockCardLogBody->CardTxnSubTypeID = readError1Data->PersonalProfile;       
;;;808        }
;;;809        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;810        {
;;;811            pECCLockCardLogBody->CardTxnSubTypeID = TargetLockCardResponseData->PersonalProfile; 
;;;812        }
;;;813        
;;;814        //4 DEV_ID 設備編號 Unsigned 3
;;;815        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)  
;;;816        {                                                                   
;;;817            pECCLockCardLogBody->DevID[0] = readError1Data->DeviceID[2];    
;;;818            pECCLockCardLogBody->DevID[1] = readError1Data->DeviceID[0];     
;;;819            pECCLockCardLogBody->DevID[2] = readError1Data->DeviceID[1];    
;;;820        }                                                                   
;;;821        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗"   
;;;822        {                                                                                                                                     
;;;823            pECCLockCardLogBody->DevID[0] = TargetLockCardResponseData->DeviceID[2];;
;;;824            pECCLockCardLogBody->DevID[1] = TargetLockCardResponseData->DeviceID[0];;
;;;825            pECCLockCardLogBody->DevID[2] = TargetLockCardResponseData->DeviceID[1];;
;;;826        }   
;;;827        
;;;828        //5 SP_ID 業者代碼 Unsigned 1 如 122 即為 0x7A 來源: 設備
;;;829        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)   
;;;830        {
;;;831            pECCLockCardLogBody->SpID = readError1Data->ServiceProviderID;
;;;832        }
;;;833        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;834        {
;;;835            pECCLockCardLogBody->SpID = TargetLockCardResponseData->ServiceProviderID;
;;;836        }
;;;837    
;;;838        //6 TXN_TIMESTAMP 交易時間 UnixTime 4 來源: 設備
;;;839        getECCLogTimeData(utcTime, &(pECCLockCardLogBody->TxnTimeStamp));  
;;;840    
;;;841        //7 CARD_PHYSICAL_ID 卡片晶片號碼 Unsigned 7 來源: 設備
;;;842        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)       
;;;843        {
;;;844            memcpy(pECCLockCardLogBody->CardPhysicalID, readError1Data->CardPhysicalID, sizeof(pECCLockCardLogBody->CardPhysicalID)); 
;;;845        }
;;;846        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;847        {
;;;848            memcpy(pECCLockCardLogBody->CardPhysicalID, TargetLockCardResponseData->CardPhysicalID, sizeof(pECCLockCardLogBody->CardPhysicalID));
;;;849        }   
;;;850        
;;;851        //8 ISSUER_ID 發卡單位 Unsigned 1 PVN <> 0 時:
;;;852        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)   
;;;853        {                                                                                                
;;;854            pECCLockCardLogBody->IIssuerID = readError1Data->IssuerCode;                                 
;;;855        }                                                                                                
;;;856        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) >>> "讀卡失敗"                                   
;;;857        {                                                                                                
;;;858            pECCLockCardLogBody->IIssuerID = TargetLockCardResponseData->IssuerCode;
;;;859        }
;;;860    
;;;861        //9 SVCE_LOC_ID 場站代碼 Unsigned 1 來源: 設備
;;;862        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)                   
;;;863        {
;;;864            pECCLockCardLogBody->SvceLocID = readError1Data->LocationID;  
;;;865        }
;;;866        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;867        {
;;;868            pECCLockCardLogBody->SvceLocID = TargetLockCardResponseData->LocationID;
;;;869        }
;;;870    
;;;871        //10 CARD_PHYSICAL_ID_LEN 晶片號碼長度 Unsigned 1
;;;872        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)     
;;;873        {                                                                              
;;;874            pECCLockCardLogBody->CardPhysicalIDLen = readError1Data->CardPhysicalIDLength;           
;;;875        }                                                                           
;;;876        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) >>> "讀卡失敗"              
;;;877        {                                                                           
;;;878            pECCLockCardLogBody->CardPhysicalIDLen = TargetLockCardResponseData->CardPhysicalIDLength;
;;;879        }                                                                           
;;;880    
;;;881        //11 NEW_DEV_ID 新設備編號 Unsigned 6 
;;;882        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)       
;;;883        {
;;;884            memcpy(pECCLockCardLogBody->NewDevID, readError1Data->NewDeviceID, sizeof(pECCLockCardLogBody->NewDevID)); 
;;;885        }
;;;886        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;887        {
;;;888            memcpy(pECCLockCardLogBody->NewDevID, TargetLockCardResponseData->NewDeviceID, sizeof(pECCLockCardLogBody->NewDevID));
;;;889        }  
;;;890                                                                   
;;;891        //12 NEW_SP_ID 新業者代碼 Unsigned 3 
;;;892        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)       
;;;893        {
;;;894            memcpy(pECCLockCardLogBody->NewSpID, readError1Data->NewServiceProviderID, sizeof(pECCLockCardLogBody->NewSpID)); 
;;;895        }
;;;896        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;897        {
;;;898            memcpy(pECCLockCardLogBody->NewSpID, TargetLockCardResponseData->NewServiceProviderID, sizeof(pECCLockCardLogBody->NewSpID));
;;;899        }  
;;;900                                                                   
;;;901        //13 NEW_SVCE_LOC_ID 新場站代碼 Unsigned 2 
;;;902        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)       
;;;903        {
;;;904            memcpy(pECCLockCardLogBody->NewSvceLocID, readError1Data->NewLocationID, sizeof(pECCLockCardLogBody->NewSvceLocID)); 
;;;905        }
;;;906        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;907        {
;;;908            memcpy(pECCLockCardLogBody->NewSvceLocID, TargetLockCardResponseData->NewLocationID, sizeof(pECCLockCardLogBody->NewSvceLocID));
;;;909        }  
;;;910                                                                       
;;;911        //14 NEW_CARD_TXN_SUBTYPE_ID 新交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照 8.3
;;;912        pECCLockCardLogBody->NewCardTxnSubTypeID = 0x00;  
;;;913    
;;;914        //15 NEW_PERSONAL_PROFILE 新身份別 Unsigned 1
;;;915        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)     
;;;916        {                                                                              
;;;917            pECCLockCardLogBody->NewPersonalProfile = readError1Data->PersonalProfile;           
;;;918        }                                                                           
;;;919        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗"               
;;;920        {                                                                           
;;;921            pECCLockCardLogBody->NewPersonalProfile = TargetLockCardResponseData->PersonalProfile;
;;;922        }   
;;;923                                                                       
;;;924        //16 CARD_PURSE_ID 錢包編號(外觀號碼) Pack 8
;;;925        if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E (餘額異常)       
;;;926        {
;;;927            memcpy(pECCLockCardLogBody->CardPurseID, &(readError1Data->PID), sizeof(pECCLockCardLogBody->CardPurseID)); 
;;;928        }
;;;929        else //0x9000 >>> "鎖卡成功" or 0x6103(CPD檢查異常) 0x6418(通路限制) >>> "讀卡失敗" 
;;;930        {
;;;931            memcpy(pECCLockCardLogBody->CardPurseID, &(TargetLockCardResponseData->PID), sizeof(pECCLockCardLogBody->CardPurseID));
;;;932        }  
;;;933                                                         
;;;934        #warning  0x640E (餘額異常) 沒有  pECCLockCardLogBody                                                              
;;;935        //17 CARD_CTC_SEQ_NO 卡片處理序號 Unsigned Msb 3
;;;936        if (lockType == ECC_CMD_READ_ERROR_2_ID_1)//0x6103(CPD檢查異常)       
;;;937        {
;;;938            memcpy(pECCLockCardLogBody->CardCTCSeqNo, TargetLockCardResponseData->CTC, sizeof(pECCLockCardLogBody->CardCTCSeqNo)); 
;;;939        }
;;;940        else //0x9000 >>> "鎖卡成功" or  ????0x640E (餘額異常)???  0x6418(通路限制) >>> "讀卡失敗"
;;;941        {
;;;942            memset(pECCLockCardLogBody->CardCTCSeqNo, 0x00, sizeof(pECCLockCardLogBody->CardCTCSeqNo));
;;;943        }  
;;;944                                                                        
;;;945        //18 CARD_BLOCKING_REASON 卡片鎖卡原因 Unsigned 1 代碼參照 8.9 來源: 設備
;;;946        if (lockType == ECC_CMD_READ_SUCCESS_ID)//0x9000 鎖卡成功
;;;947        {
;;;948            pECCLockCardLogBody->CardBlockingReason = 0x01;
;;;949        }
;;;950        else if (lockType == ECC_CMD_READ_ERROR_2_ID_1)//0x6103(CPD檢查異常)
;;;951        {
;;;952            pECCLockCardLogBody->CardBlockingReason = 0x02;
;;;953        }
;;;954        else if (lockType == ECC_CMD_READ_ERROR_1_ID_1)//0x640E(餘額異常)
;;;955        {
;;;956            pECCLockCardLogBody->CardBlockingReason = 0x0E;
;;;957        }
;;;958        else if (lockType == 0x610F)
;;;959        {
;;;960            pECCLockCardLogBody->CardBlockingReason = 0x0F;
;;;961        }
;;;962        else if (lockType == ECC_CMD_READ_ERROR_1_ID_2)//0x6418(通路限制)
;;;963        {
;;;964            pECCLockCardLogBody->CardBlockingReason = 0x18;
;;;965        }
;;;966    
;;;967        //2018.08.14  --> B.【BLOCKING_FILE】鎖卡名單檔名：離線黑名單鎖卡應填 黑名單檔名，卻空白。
;;;968        //19 BLOCKING_FILE 鎖卡名單檔名 Ascii 20 
;;;969        //#if(1)//CardBlockingReason = 0x01 改成跟 CardBlockingReason = 0x02 相同 (ie 後面都是空白)
;;;970        if (lockType == ECC_CMD_READ_SUCCESS_ID)//0x9000 鎖卡成功
;;;971        {
;;;972            memset(pECCLockCardLogBody->BlockingFile, ' ', sizeof(pECCLockCardLogBody->BlockingFile));
;;;973            if(strlen(blkFileName) > sizeof(pECCLockCardLogBody->BlockingFile))
;;;974            {
;;;975                targetblkFileNameLen = sizeof(pECCLockCardLogBody->BlockingFile);
;;;976            }
;;;977            else
;;;978            {
;;;979                targetblkFileNameLen = strlen(blkFileName);
;;;980            }
;;;981            memcpy(pECCLockCardLogBody->BlockingFile, blkFileName, targetblkFileNameLen);
;;;982        }
;;;983        else 
;;;984        //#endif
;;;985        {
;;;986            memset(pECCLockCardLogBody->BlockingFile, 0x20, sizeof(pECCLockCardLogBody->BlockingFile));
;;;987        }  
;;;988        //2018.08.14  --> C.【BLOCKING_ID_FLAG】鎖卡卡號ID旗標：離線黑名單鎖卡應填 M，卻空白。                                                                    
;;;989        //20 BLOCKING_ID_FLAG 鎖卡卡號 ID 旗標 Ascii 1
;;;990        //#if(1)//CardBlockingReason = 0x01 改成跟 CardBlockingReason = 0x02 相同 (ie 後面都是空白)
;;;991        if (lockType == ECC_CMD_READ_SUCCESS_ID)//0x9000 鎖卡成功
;;;992        {
;;;993            pECCLockCardLogBody->BlockingIDFlag = 0x00;
;;;994            if ( (strcmp(blkFileNameExtension, "BIG") == 0) || (strcmp(blkFileNameExtension, "SML") == 0) )
;;;995            {
;;;996                if (PVN == 0x00)
;;;997                {
;;;998                    pECCLockCardLogBody->BlockingIDFlag = 0x4D;
;;;999                }
;;;1000               else
;;;1001               {
;;;1002                   pECCLockCardLogBody->BlockingIDFlag = 0x50;
;;;1003               }
;;;1004           }
;;;1005           else
;;;1006           {
;;;1007               pECCLockCardLogBody->BlockingIDFlag = 0x4D;
;;;1008           }
;;;1009       }
;;;1010       else
;;;1011       //#endif
;;;1012       {
;;;1013           pECCLockCardLogBody->BlockingIDFlag = 0x20;
;;;1014       }
;;;1015                                                                      
;;;1016       //21 DEV_INFO 設備資訊 Ascii 20 BV、Tobu ：車號
;;;1017       memset(pECCLockCardLogBody->DevInfo, 0x20, sizeof(pECCLockCardLogBody->DevInfo)); 
;;;1018                                                                   
;;;1019       //22 ELECTRONIC_VALUE 交易後卡片金額 Signed 3 來源: 卡片 --> (Purse Balance - 640E 與 6418 才有的)
;;;1020       if ( (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1021               (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1022       {
;;;1023           memcpy(pECCLockCardLogBody->ElectronicValue, readError1Data->PurseBalance, sizeof(pECCLockCardLogBody->ElectronicValue)); 
;;;1024       }
;;;1025   
;;;1026       //23 NEW_CARD_TXN_SEQ_NO 新交易後序號 Unsigned 3 來源: 卡片 --> (TXN SN - 640E 與 6418 才有的)
;;;1027       if ( (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1028                   (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1029       {
;;;1030           memcpy(pECCLockCardLogBody->NewCardTxnSeqNo, readError1Data->TTXNSN, sizeof(pECCLockCardLogBody->NewCardTxnSeqNo)); 
;;;1031       }
;;;1032       //加值紀錄 (PPR_EDCARead 9000 與 640E 與 6418 才有的)
;;;1033       // === 2017/06/01 START ===
;;;1034       #if(0)//CardBlockingReason = 0x01 改成跟 CardBlockingReason = 0x02 相同 (ie 後面都是空白)
;;;1035       if (lockType == ECC_CMD_READ_SUCCESS_ID)//0x9000 鎖卡成功
;;;1036       {
;;;1037           memcpy(&AddValueBytes, &(readSuccessData->LastCreditTXNLog), sizeof(AddValueBytes));
;;;1038       }
;;;1039       else 
;;;1040       #endif
;;;1041       if ( (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1042                           (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1043       {
;;;1044           //Array.Copy(EDCAReadBytes, 65, AddValueBytes, 0, 33);
;;;1045           memcpy(&AddValueBytes, &(readError1Data->LastCreditTXNLog), sizeof(AddValueBytes));
;;;1046       }
;;;1047       // === 2017/06/01 E N D ===
;;;1048       #if(0)//CardBlockingReason = 0x01 改成跟 CardBlockingReason = 0x02 相同 (ie 後面都是空白)
;;;1049       if ( (lockType == ECC_CMD_READ_SUCCESS_ID /*0x9000 鎖卡成功*/) ||
;;;1050                           (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1051                           (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1052       #else
;;;1053       if ( /*(lockType == ECC_CMD_READ_SUCCESS_ID 0x9000 鎖卡成功) ||*/
;;;1054                           (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1055                           (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1056       #endif
;;;1057       {
;;;1058           uint8_t ADD_PVN = AddValueBytes.PurseVersionNumber;
;;;1059   
;;;1060           //24 CRELOG_TXN_SEQ_NO 票卡最末筆加值記錄  1.交易後序號 Unsigned 3 來源: 卡片
;;;1061           memcpy(pECCLockCardLogBody->CreLogTxnSeqNo, AddValueBytes.TSQN, sizeof(pECCLockCardLogBody->CreLogTxnSeqNo)); 
;;;1062        
;;;1063   
;;;1064           //25 CRELOG_TXN_TIMESTAMP 票卡最末筆加值記錄  2.交易時間 UnixTime 4 來源: 卡片
;;;1065           memcpy(&(pECCLockCardLogBody->CreLogTxnTimeStamp), &(AddValueBytes.TXNDateTime), sizeof(pECCLockCardLogBody->CreLogTxnTimeStamp)); 
;;;1066   
;;;1067           //26 CRELOG_TXN_SUBTYPE_ID 票卡最末筆加值記錄  3.交易次類別 Unsigned 1 來源: 卡片
;;;1068           pECCLockCardLogBody->CreLogTxnSubTypeID = AddValueBytes.SubType; 
;;;1069   
;;;1070           //27 CRELOG_TXN_AMT 票卡最末筆加 Signed 3 來源: 卡片值記錄  4.交易金額
;;;1071           memcpy(pECCLockCardLogBody->CreLogTxnAMT, AddValueBytes.TXNAMT, sizeof(pECCLockCardLogBody->CreLogTxnAMT)); 
;;;1072   
;;;1073           //28 CRELOG_EV 票卡最末筆加值記錄  5.交易後卡片金額   Signed 3 來源: 卡片
;;;1074           memcpy(pECCLockCardLogBody->CreLogEV, AddValueBytes.EV, sizeof(pECCLockCardLogBody->CreLogEV)); 
;;;1075   
;;;1076           //29 CRELOG_DEV_ID 票卡最末筆加值記錄  6.設備編號 Unsigned 6 
;;;1077           if(ADD_PVN == 0x02)
;;;1078           {
;;;1079               memcpy(pECCLockCardLogBody->CreLogDevID, AddValueBytes.DeviceID, sizeof(pECCLockCardLogBody->CreLogDevID)); 
;;;1080           }
;;;1081           else
;;;1082           {
;;;1083               pECCLockCardLogBody->CreLogDevID[0] = AddValueBytes.DeviceID[2];
;;;1084               pECCLockCardLogBody->CreLogDevID[1] = AddValueBytes.DeviceID[0];
;;;1085               pECCLockCardLogBody->CreLogDevID[2] = AddValueBytes.DeviceID[1];
;;;1086               pECCLockCardLogBody->CreLogDevID[3] = AddValueBytes.DeviceID[3];
;;;1087               pECCLockCardLogBody->CreLogDevID[4] = AddValueBytes.DeviceID[4];
;;;1088               pECCLockCardLogBody->CreLogDevID[5] = AddValueBytes.DeviceID[5];
;;;1089           }
;;;1090       }
;;;1091   
;;;1092       if ( (lockType == ECC_CMD_READ_ERROR_1_ID_1 /*0x640E(餘額異常)*/) || 
;;;1093                           (lockType == ECC_CMD_READ_ERROR_1_ID_2 /*0x6418(通路限制)*/) )
;;;1094       { 
;;;1095           //30 ANOTHER_EV 票卡另一個錢包餘額 Signed 3 來源: 卡片
;;;1096           memcpy(pECCLockCardLogBody->AnotherEV, readError1Data->AnotherEV, sizeof(pECCLockCardLogBody->AnotherEV));                                                         
;;;1097   
;;;1098           //31 MIFARE_SET_PARA 票卡地區認證 旗標 Byte 1 後台 UNPACK 文字格式 CHAR(2) 來源: 卡片
;;;1099           pECCLockCardLogBody->MifareSetPara =  readError1Data->MifareSettingParameter;
;;;1100   
;;;1101           //32 CPU_SET_PARA 票卡是否限制 通路使用旗標 Byte 1 後台 UNPACK 文字格式 CHAR(2) 來源: 卡片
;;;1102           pECCLockCardLogBody->CpuSetPara =  readError1Data->CPUSettingParameter;
;;;1103       }
;;;1104   
;;;1105       //33 RFU 保留欄位 Byte 16 後台 UNPACK 文字格式 CHAR(32) 固定填 16 Bytes 0x00
;;;1106       memset(pECCLockCardLogBody->RFU, 0x00, sizeof(pECCLockCardLogBody->RFU));     //RFU(Reserved For Use) 11 TM 保留，補 0x00，11bytes
;;;1107       
;;;1108       ////////////////
;;;1109   #if(ECC_LOG_USE_NEW_FILE_NAME)
;;;1110       //咪表ID_訂單號_時間(yyyyMMddHHmmss)_001U.ECC
;;;1111       sprintf(currentECCLockCardLogFileName, "%s_%s_%s_034U.ECC", GetMeterData()->epmIdStr, GetMeterData()->bookingId, getECCLogUTCTimeStr(utcTime));
;;;1112   #else    
;;;1113       sprintf(currentECCLockCardLogFileName, "00220.%03d_%08d_%05d_00000.%s_034U.ECC", newSpID, newSpID, svceLocID, getECCLogUTCTimeStr(utcTime));
;;;1114   #endif
;;;1115       
;;;1116       #if(1)
;;;1117       prData = (uint8_t*)&(pECCLockCardLogBody);
;;;1118       prDataLen = sizeof(ECCLockCardLogBody);
;;;1119       sysprintf("--- pECCLockCardLogBody:  len = %d --->\r\n", prDataLen);
;;;1120       for(i = 0; i<prDataLen; i++)
;;;1121       {
;;;1122           //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;1123           sysprintf("0x%02x, ", prData[i]);
;;;1124           if(i%10 == 9)
;;;1125               sysprintf("\r\n");
;;;1126   
;;;1127       }
;;;1128       sysprintf("\r\n<--- pECCLockCardLogBody ---\r\n");
;;;1129       #endif
;;;1130       return TRUE;
;;;1131       #endif
;;;1132   }
0001d0  e8bd80f0          POP      {r4-r7,pc}
;;;1133   char* ECCLockCardLogGetFileName(void)
                          ENDP

                  ECCLockCardLogGetFileName PROC
0001d4  e59f0068          LDR      r0,|L1.580|
;;;1134   {
;;;1135       return currentECCLockCardLogFileName;
;;;1136   }
0001d8  e12fff1e          BX       lr
;;;1137   BOOL ECCBlkFeedbackLogContainInit(ECCBlkFeedbackLogBody* body, uint8_t newSpID, uint8_t svceLocID, char* blkFileName, uint32_t utcTime)
                          ENDP

                  ECCBlkFeedbackLogContainInit PROC
0001dc  e92d4010          PUSH     {r4,lr}
;;;1138   {
0001e0  e1a04000          MOV      r4,r0
0001e4  e59dc008          LDR      r12,[sp,#8]
;;;1139       #if(1)
;;;1140       return TRUE;
0001e8  e3a00001          MOV      r0,#1
;;;1141       #else
;;;1142       uint32_t i;
;;;1143       uint8_t* prData; 
;;;1144       uint32_t prDataLen;
;;;1145       int targetblkFileNameLen;
;;;1146       ECCBlkFeedbackLogBody* pECCBlkFeedbackLogBody = body;
;;;1147       sysprintf("\r\n====  ECCBlkFeedbackLogContainInit (blkFileName = [%s](%d))====\r\n", blkFileName, strlen(blkFileName));
;;;1148       sysprintf("sizeof(ECCBlkFeedbackLogBody) = %d\r\n", sizeof(ECCBlkFeedbackLogBody));
;;;1149   
;;;1150       if(sizeof(ECCBlkFeedbackLogBody) != TOTAL_ECC_BLK_FEEDBACK_LOG_BODY_SIZE)
;;;1151       {
;;;1152           sysprintf("ECCDeductLogContainInit ERROR: sizeof(ECCBlkFeedbackLogBody) != TOTAL_ECC_BLK_FEEDBACK_LOG_BODY_SIZE [%d, %d]\r\n", sizeof(ECCBlkFeedbackLogBody), TOTAL_ECC_BLK_FEEDBACK_LOG_BODY_SIZE);
;;;1153           return FALSE;
;;;1154       }
;;;1155       memset(pECCBlkFeedbackLogBody, 0x00, sizeof(ECCBlkFeedbackLogBody));
;;;1156       //*** header tail ***//
;;;1157       uint8_t fileHead_01[] = { 0x48, 0x45, 0x41, 0x44, 0x30, 0x30, 0x36, 0x31, 0x44, 0x41, 0x54, 0x41 };
;;;1158       uint8_t fileTail_01[] = { 0x54, 0x41, 0x49, 0x4C,
;;;1159                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;;;1160                                 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31,
;;;1161                                 0x45, 0x4E, 0x44 };
;;;1162       memcpy(pECCBlkFeedbackLogBody->header, fileHead_01, sizeof(pECCBlkFeedbackLogBody->header));
;;;1163       memcpy(pECCBlkFeedbackLogBody->tail, fileTail_01, sizeof(pECCBlkFeedbackLogBody->tail));
;;;1164       //*** body ***//
;;;1165       pECCBlkFeedbackLogBody->CardTxnTypeId = 0x34;          //1 CARD_TXN_TYPE_ID 交易類別 Unsigned 1 代碼參照 8.2 來源: 設備
;;;1166       pECCBlkFeedbackLogBody->DevID[0] = newSpID; //2 DEV_ID 設備編號 Unsigned 3 SP_ID(1 Byte): 如 122 即為 0x7A
;;;1167       pECCBlkFeedbackLogBody->DevID[1] = 0x6B;                                //DEV_TYPE(4 Bits): 如 3 即為 0x3□
;;;1168       pECCBlkFeedbackLogBody->DevID[2] = 0x30;                                //DEV_ID_NO(12 Bites): 如 100 即為 0x□0 0x64
;;;1169                                                                                   //組合 HEX: 0x7A 0x30 0x64
;;;1170                                                                                   //倒數2 Bytes LSB FIRST: 0x7A 0x64 0x30
;;;1171                                                                                   //來源: Mifare Sam 卡
;;;1172       pECCBlkFeedbackLogBody->SpID = newSpID;               //3 SP_ID 業者代碼 Unsigned 1 SP_ID(1 Byte): 如 122 即為 0x7A 來源: 設備
;;;1173       pECCBlkFeedbackLogBody->SvceLocID = svceLocID;              //4 SVCE_LOC_ID 場站代碼 Unsigned 1 來源: 設備
;;;1174       pECCBlkFeedbackLogBody->NewDevID[0] = pECCBlkFeedbackLogBody->DevID[0];            //5 NEW_DEV_ID 新設備編號 新增 Unsigned 6 NEW_SP_ID(3 Bytes): 如 122 即為 0x00 0x00 0x7A
;;;1175       pECCBlkFeedbackLogBody->NewDevID[1] = 0x6B;                                                //NEW_DEV_TYPE(1 Byte): 3：BV 如 3 即為 0x03
;;;1176       pECCBlkFeedbackLogBody->NewDevID[2] = 0x30;                                                //4096(含)之後開始編碼
;;;1177       pECCBlkFeedbackLogBody->NewDevID[3] = 0x00;                                                //NEW_DEV_ID_NO(2 Bytes): 如 4096 即為 0x10 0x00
;;;1178       pECCBlkFeedbackLogBody->NewDevID[4] = 0x00;                                                //組合 HEX: 0x00 0x00 0x7A 0x03 0x10 0x00
;;;1179       pECCBlkFeedbackLogBody->NewDevID[5] = 0x00;                                                //以 LSB FIRST 傳送: 0x00 0x10 0x03 0x7A 0x00 0x00
;;;1180                                                                                           //來源: Cpu Sam 卡
;;;1181                                                                                           //二代卡設備未修改，以 SIS2 傳送時: 固定填 6 Bytes 0x00
;;;1182       pECCBlkFeedbackLogBody->NewSpID[0] = pECCBlkFeedbackLogBody->DevID[0];   //6 NEW_SP_ID 新業者代碼 新增 Unsigned 3 NEW_SP_ID(3 Bytes): 如 122 即為 0x00 0x00 0x7A
;;;1183       pECCBlkFeedbackLogBody->NewSpID[1] = 0x00;                                       //以 LSB FIRST 傳送: 0x7A 0x00 0x00
;;;1184       pECCBlkFeedbackLogBody->NewSpID[2] = 0x00;                                       //來源: 設備
;;;1185       pECCBlkFeedbackLogBody->NewSvceLocID[0] = pECCBlkFeedbackLogBody->SvceLocID;        //7 NEW_SVCE_LOC_ID 新場站代碼 新增 Unsigned 2 NEW_SVCE_LOC_ID(2 Bytes): 如 1 即為 0x00 0x01
;;;1186       pECCBlkFeedbackLogBody->NewSvceLocID[1] = 0x00;                                                                    //以 LSB FIRST 傳送: 0x01 0x00
;;;1187                                                                                           //來源: 設備
;;;1188       memset(pECCBlkFeedbackLogBody->BlockingFile, ' ', sizeof(pECCBlkFeedbackLogBody->BlockingFile)); //8 BLOCKING_FILE 鎖卡名單檔名 新增 Ascii 20 左靠右補空白，如'BLC00001.BIGΔΔΔΔΔΔΔΔ'   來源: 設備
;;;1189       if(strlen(blkFileName) > sizeof(pECCBlkFeedbackLogBody->BlockingFile))
;;;1190       {
;;;1191           targetblkFileNameLen = sizeof(pECCBlkFeedbackLogBody->BlockingFile);
;;;1192       }
;;;1193       else
;;;1194       {
;;;1195           targetblkFileNameLen = strlen(blkFileName);
;;;1196       }
;;;1197       memcpy(pECCBlkFeedbackLogBody->BlockingFile, blkFileName, targetblkFileNameLen);
;;;1198   
;;;1199       getECCLogTimeData(utcTime, &(pECCBlkFeedbackLogBody->ReceiveDateTime));     //9 RECEIVE_DATETIME  收到鎖卡檔時間 新增 UnixTime 4 來源: 設備
;;;1200   
;;;1201       memset(pECCBlkFeedbackLogBody->DevInfo, ' ', sizeof(pECCBlkFeedbackLogBody->DevInfo));   //10 DEV_INFO 設備資訊 新增 Ascii 20  BV、Tobu ：車號
;;;1202                                                                                       //路邊計時器：車位號碼
;;;1203                                                                                       //xAVM ：機號
;;;1204                                                                                       //Dongle ：店號
;;;1205                                                                                       //其他設備：無
;;;1206                                                                                       //左靠右補空白，如
;;;1207                                                                                       //'123-ABΔΔΔΔΔΔΔΔΔΔΔΔΔΔ'
;;;1208                                                                                       //來源: 設備
;;;1209   #if(ECC_LOG_USE_NEW_FILE_NAME)
;;;1210       //咪表ID_訂單號_時間(yyyyMMddHHmmss)_001U.ECC
;;;1211       sprintf(currentECCFeedbackLogFileName, "%s_%s_%s_052U.ECC", GetMeterData()->epmIdStr, GetMeterData()->bookingId, getECCLogUTCTimeStr(utcTime));
;;;1212   #else 
;;;1213       sprintf(currentECCFeedbackLogFileName, "00220.%03d_%08d_%05d_00000.%s_052U.ECC", newSpID, newSpID, svceLocID, getECCLogUTCTimeStr(utcTime));
;;;1214   #endif
;;;1215       
;;;1216       #if(1)
;;;1217       prData = (uint8_t*)&(pECCBlkFeedbackLogBody);
;;;1218       prDataLen = sizeof(ECCBlkFeedbackLogBody);
;;;1219       sysprintf("--- pECCBlkFeedbackLogBody:  len = %d --->\r\n", prDataLen);
;;;1220       for(i = 0; i<prDataLen; i++)
;;;1221       {
;;;1222           //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;1223           sysprintf("0x%02x, ", prData[i]);
;;;1224           if(i%10 == 9)
;;;1225               sysprintf("\r\n");
;;;1226   
;;;1227       }
;;;1228       sysprintf("\r\n<--- pECCBlkFeedbackLogBody ---\r\n");
;;;1229       #endif
;;;1230       return TRUE;
;;;1231       #endif
;;;1232   }
0001ec  e8bd8010          POP      {r4,pc}
;;;1233   
                          ENDP

                  ECCBlkFeedbackLogGetFileName PROC
;;;1234   
;;;1235   char* ECCBlkFeedbackLogGetFileName(void)
0001f0  e59f0050          LDR      r0,|L1.584|
;;;1236   {
;;;1237       return currentECCFeedbackLogFileName;
;;;1238   }
0001f4  e12fff1e          BX       lr
;;;1239   
                          ENDP

                  ECCAutoLoadLogContainInit PROC
;;;1240   BOOL ECCAutoLoadLogContainInit(ECCAutoLoadLogBody* body, uint32_t AgentNo, ECCCmdDCAReadResponseSuccessData* DCAReadData, int DCAReadDataLen, ECCCmdEDCADeductResponseData* EDCADeductData, int EDCADeductDataLen, uint8_t newSpID, uint32_t utcTime)
0001f8  e92d40f0          PUSH     {r4-r7,lr}
;;;1241   {
0001fc  e1a07000          MOV      r7,r0
000200  e28d6018          ADD      r6,sp,#0x18
000204  e8960070          LDM      r6,{r4-r6}
000208  e59dc014          LDR      r12,[sp,#0x14]
;;;1242       #if(1)
;;;1243       return TRUE;
00020c  e3a00001          MOV      r0,#1
;;;1244       #else
;;;1245       uint32_t i;
;;;1246       uint8_t* prData; 
;;;1247       uint32_t prDataLen;
;;;1248       #if(!ECC_LOG_USE_NEW_FILE_NAME)
;;;1249       uint32_t SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW;
;;;1250       #endif
;;;1251       ECCAutoLoadLogBody* pECCAutoLoadLogBody = body;
;;;1252       uint8_t PVN = DCAReadData->PurseVersionNumber;
;;;1253       sysprintf("\r\n====  ECCAutoLoadLogContainInit ====\r\n");
;;;1254       sysprintf("sizeof(ECCAutoLoadLogBody) = %d\r\n", sizeof(ECCAutoLoadLogBody));
;;;1255   
;;;1256       if(sizeof(ECCAutoLoadLogBody) != TOTAL_ECC_AUTO_LOAD_LOG_BODY_SIZE)
;;;1257       {
;;;1258           sysprintf("ECCAutoLoadLogContainInit ERROR: sizeof(ECCAutoLoadLogBody) != TOTAL_ECC_AUTO_LOAD_LOG_BODY_SIZE [%d, %d]\r\n", sizeof(ECCBlkFeedbackLogBody), TOTAL_ECC_AUTO_LOAD_LOG_BODY_SIZE);
;;;1259           return FALSE;
;;;1260       }
;;;1261       memset(pECCAutoLoadLogBody, 0x00, sizeof(ECCAutoLoadLogBody));
;;;1262       
;;;1263       // ********   Header   ********
;;;1264       //pECCAutoLoadLogBody->Header;
;;;1265       
;;;1266       pECCAutoLoadLogBody->Header.PurseVerNo = DCAReadData->PurseVersionNumber;                 //1 PURSE_VER_NO 卡片版本 Unsigned 1 代碼參照 8.1 來源: 設備
;;;1267       pECCAutoLoadLogBody->Header.CardTxnTypeID = 0x02;//EDCADeductData->MsgType;              //2 CARD_TXN_TYPE_ID 交易類別 Unsigned 1 代碼參照 8.2 來源: 設備
;;;1268       pECCAutoLoadLogBody->Header.CardTxnSubTypeID = 0x40;//DCAReadData->PersonalProfile;      ////交易次類別 (MsgType = 0x01 時，SubType = Personal Profile)     //3 CARD_TXN_SUBTYPE_ID 交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照 8.3
;;;1269       pECCAutoLoadLogBody->Header.DevID[0] = DCAReadData->DeviceID[2];                  //4 DEV_ID 設備編號 Unsigned 3 SP_ID(1 Byte):如 122 即為 0x7A
;;;1270       pECCAutoLoadLogBody->Header.DevID[1] = DCAReadData->DeviceID[0];                                                    //DEV_TYPE(4 Bits): 3：BV 如 BV 即為 0x3□
;;;1271       pECCAutoLoadLogBody->Header.DevID[2] = DCAReadData->DeviceID[1];                                                    //DEV_ID_NO(12 Bites): 如 1234 即為 0x□4 0xD2
;;;1272                                                                                                                           //組合 HEX: 0x7A 0x34 0xD2
;;;1273                                                                                                                           //倒數2 Bytes LSB FIRST: 0x7A 0xD2 0x34
;;;1274                                                                                                                           //來源: Mifare Sam 卡
;;;1275       pECCAutoLoadLogBody->Header.SpID = DCAReadData->ServiceProviderID;                       //5 SP_ID 業者代碼 Unsigned 1  如 122 即為 0x7A 來源: 設備
;;;1276       memcpy(&(pECCAutoLoadLogBody->Header.TxnTimeStamp), &(EDCADeductData->AutoLoadTXNDateTime), sizeof(pECCAutoLoadLogBody->Header.TxnTimeStamp));     //6 TXN_TIMESTAMP 交易時間 UnixTime 4 來源: 設備
;;;1277       memcpy(pECCAutoLoadLogBody->Header.CardPhysicalID, DCAReadData->CardPhysicalID, sizeof(pECCAutoLoadLogBody->Header.CardPhysicalID));   //7 CARD_PHYSICAL_ID 卡片晶片號碼 Unsigned 7 來源: 設備
;;;1278       pECCAutoLoadLogBody->Header.IssuerID = DCAReadData->IssuerCode;              //8 ISSUER_ID 發卡單位 Unsigned 1   PVN <> 0 時: 來源: Cpu 卡
;;;1279                                                                                     //PVN = 0 時: 2 (0x02)：悠遊卡公司
;;;1280                                                                                                   //66 (0x42)：基隆交通卡
;;;1281                                                                                                   //來源: 設備
;;;1282       pECCAutoLoadLogBody->Header.CardTxnSeqNo = EDCADeductData->AutoLoadTSQN[0];          //9 CARD_TXN_SEQ_NO 交易後序號 Unsigned 1 來源: 卡片
;;;1283       memcpy(pECCAutoLoadLogBody->Header.TxnAMT, EDCADeductData->AutoLoadTXNAMT, sizeof(pECCAutoLoadLogBody->Header.TxnAMT));    //10 TXN_AMT 交易金額 Signed 3 來源: 設備
;;;1284       memcpy(pECCAutoLoadLogBody->Header.ElectronicValue, EDCADeductData->AutoLoadPurseBalance, sizeof(pECCAutoLoadLogBody->Header.ElectronicValue));    //11 ELECTRONIC_VALUE 交易後卡片金額 Signed 3 來源: 卡片
;;;1285       pECCAutoLoadLogBody->Header.SVCELocID = DCAReadData->LocationID;                  //12 SVCE_LOC_ID 場站代碼 Unsigned 1 來源: 設備
;;;1286       pECCAutoLoadLogBody->Header.CardPhysicalIDLen = DCAReadData->CardPhysicalIDLength;          //13 CARD_PHYSICAL_ID_LEN 晶片號碼長度 Unsigned 1 如 4 bytes 即為 0x04
;;;1287                                                                                                       //如 7 bytes 即為 0x07
;;;1288                                                                                                       //來源: 卡片
;;;1289       memcpy(pECCAutoLoadLogBody->Header.NewCardTxnSeqNo, EDCADeductData->AutoLoadTSQN, sizeof(pECCAutoLoadLogBody->Header.NewCardTxnSeqNo));   //14 NEW_CARD_TXN_SEQ_NO 新交易後序號 Unsigned 3 來源: 卡片
;;;1290       memcpy(pECCAutoLoadLogBody->Header.NewDevID, DCAReadData->NewDeviceID, sizeof(pECCAutoLoadLogBody->Header.NewDevID));               //15 NEW_DEV_ID 新設備編號 Unsigned 6           NEW_SP_ID(3 Bytes): 如 122 即為0x00 0x00 0x7A
;;;1291                                                                                                   //NEW_DEV_TYPE(1 Byte): 3：BV 如 3 即為 0x03
;;;1292                                                                                                   //4096(含)之後開始編碼
;;;1293                                                                                                   //NEW_DEV_ID_NO (2 Bytes): 如 4096 即為 0x10 0x00
;;;1294                                                                                                   //組合 HEX: 0x00 0x00 0x7A 0x03 0x10 0x00
;;;1295                                                                                                   //以 LSB FIRST 傳送: 0x00 0x10 0x03 0x7A 0x00 0x00
;;;1296                                                                                                   //來源: Cpu Sam 卡
;;;1297                                                                                                   //二代卡設備未修改，以 SIS2 傳送時: 固定填 6 Bytes 0x00
;;;1298       memcpy(pECCAutoLoadLogBody->Header.NewSpID, DCAReadData->NewServiceProviderID, sizeof(pECCAutoLoadLogBody->Header.NewSpID));   //16 NEW_SP_ID 新業者代碼 Unsigned 3 NEW_SP_ID(3 Bytes): 如 122 即為 0x00 0x00 0x7A
;;;1299                                                                                                                                           //以 LSB FIRST 傳送: 0x7A 0x00 0x00
;;;1300                                                                                                                                           //來源: 設備
;;;1301       memcpy(pECCAutoLoadLogBody->Header.NewSVCELocID, DCAReadData->NewLocationID, sizeof(pECCAutoLoadLogBody->Header.NewSVCELocID));   //17 NEW_SVCE_LOC_ID 新場站代碼 Unsigned 2 NEW_SVCE_LOC_ID(2 Bytes): 如 1 即為 0x00 0x01
;;;1302                                                                                                                                               //以 LSB FIRST 傳送: 0x01 0x00
;;;1303                                                                                                                                               //來源: 設備
;;;1304       pECCAutoLoadLogBody->Header.NewCardTxnSubTypeID = 0x40;//0x00;  ////扣款填=0x00, AutoLoad=0x40(自動加值)      //18 NEW_CARD_TXN_SUBTYPE_ID 新交易次類別 Unsigned 1 依現況設備邏輯填入 代碼參照 8.3
;;;1305       pECCAutoLoadLogBody->Header.NewPersonalProfile = DCAReadData->PersonalProfile;         //19 NEW_PERSONAL_PROFILE 新身份別 Unsigned 1 0x00: 一般
;;;1306                                                                                                       //0x01: 敬老 1
;;;1307                                                                                                       //0x02: 敬老 2
;;;1308                                                                                                       //0x03: 愛心
;;;1309                                                                                                       //0x04: 陪伴
;;;1310                                                                                                       //0x05: 學生
;;;1311                                                                                                       //0x08: 優待
;;;1312                                                                                                       //來源: 卡片
;;;1313       pECCAutoLoadLogBody->Header.TxnPersonalProfile = 0x00;         //20 TXN_PERSONAL_PROFILE 交易身份別 Unsigned 1 實際交易的身份別，如卡片身份別為學生，但部份業者未給予優待，以一般卡扣款，則此欄位填入一般
;;;1314                                                                       //0x00: 一般
;;;1315                                                                       //0x01: 敬老 1
;;;1316                                                                       //0x02: 敬老 2
;;;1317                                                                       //0x03: 愛心
;;;1318                                                                       //0x04: 陪伴
;;;1319                                                                       //0x05: 學生
;;;1320                                                                       //0x08: 優待
;;;1321                                                                       //來源: 設備
;;;1322       pECCAutoLoadLogBody->Header.ACQID = 0x02;                      //21 ACQ_ID 收單單位 Unsigned 1   2 (0x02)：悠遊卡公司
;;;1323                                                                                   //66 (0x42)：基隆交通卡
;;;1324                                                                                   //來源: 設備
;;;1325       memcpy(pECCAutoLoadLogBody->Header.CardPurseID, &(DCAReadData->PID), sizeof(pECCAutoLoadLogBody->Header.CardPurseID));    //22 CARD_PURSE_ID 錢包編號(外觀號碼) Pack 8      PVN <> 0 時:
;;;1326                                                                                                       //如卡號 1234567890123456
;;;1327                                                                                                       //即為 0x12 0x34 0x56 0x78 0x90 0x12 0x34 0x56
;;;1328                                                                                                       //編碼參照 8.5
;;;1329                                                                                                       //來源: Cpu 卡
;;;1330                                                                                                   //PVN = 0 時:
;;;1331                                                                                                       //固定填 8 Bytes 0x00
;;;1332       if (PVN == 0x00)                                                //23 CARD_CTC_SEQ_NO 卡片處理序號 Unsigned Msb 3   PVN <> 0 時: 如 1 即為 0x00 0x00 0x01
;;;1333       {                           
;;;1334           memset(pECCAutoLoadLogBody->Header.CardCTCSeqNo, 0x00, sizeof(pECCAutoLoadLogBody->Header.CardCTCSeqNo)); //以 MSB FIRST 傳送:  0x00 0x00 0x01
;;;1335       }                                                                                                                       //來源: Cpu 卡
;;;1336       else                                                                                                                    //PVN = 0 時: 固定填 3 Bytes 0x00
;;;1337       {
;;;1338           memcpy(pECCAutoLoadLogBody->Header.CardCTCSeqNo, EDCADeductData->AutoLoadCTC, sizeof(pECCAutoLoadLogBody->Header.CardCTCSeqNo));
;;;1339       }
;;;1340       pECCAutoLoadLogBody->Header.AreaCode = DCAReadData->AreaCode;                   //24 AREA_CODE 區碼 Unsigned 1 來源: 卡片
;;;1341       if (PVN == 0x00)                                                                //25 SUB_AREA_CODE 附屬區碼 Unsigned 2    PVN <> 0 時: 依 3 碼郵遞區號  來源: Cpu 卡
;;;1342       {                                                                                    //PVN = 0 時: 固定填 2 Bytes 0x00
;;;1343           memset(pECCAutoLoadLogBody->Header.SubAreaCode, 0x00, sizeof(pECCAutoLoadLogBody->Header.SubAreaCode));
;;;1344       }
;;;1345       else
;;;1346       {
;;;1347           memcpy(pECCAutoLoadLogBody->Header.SubAreaCode, DCAReadData->SubAreaCode, sizeof(pECCAutoLoadLogBody->Header.SubAreaCode));
;;;1348       }
;;;1349       memcpy(pECCAutoLoadLogBody->Header.SeqNoBefTxn, DCAReadData->TXNSNBeforeTXN, sizeof(pECCAutoLoadLogBody->Header.SeqNoBefTxn));   //26 SEQ_NO_BEF_TXN 交易前序號 Unsigned 3  來源: 卡片  二代卡設備未修改，以 SIS2 傳送時: 固定填 3 Bytes 0x00
;;;1350       memcpy(pECCAutoLoadLogBody->Header.EVBdfTxn, DCAReadData->PurseBalanceBeforeTXN, sizeof(pECCAutoLoadLogBody->Header.EVBdfTxn));         //27 EV_BEF_TXN 交易前卡片金額 Signed 3 來源: 卡片
;;;1351       #if(1)
;;;1352       prData = (uint8_t*)&(pECCAutoLoadLogBody->Header);
;;;1353       prDataLen = sizeof(pECCAutoLoadLogBody->Header);
;;;1354       sysprintf("--- pECCAutoLoadLogBody->Header:  len = %d --->\r\n", prDataLen);
;;;1355       for(i = 0; i<prDataLen; i++)
;;;1356       {
;;;1357           //sysprintf(" [%03d] : 0x%02x \r\n", i, receiveData[5+i]);
;;;1358           sysprintf("0x%02x, ", prData[i]);
;;;1359           if(i%10 == 9)
;;;1360               sysprintf("\r\n");
;;;1361   
;;;1362       }
;;;1363       sysprintf("\r\n<--- pECCAutoLoadLogBody->Header ---\r\n");
;;;1364       #endif
;;;1365       
;;;1366       // ********   Data   ********
;;;1367   
;;;1368       if (PVN == 0x00)     //1 LOYALTY_COUNTER 累積忠誠點 Unsigned 2 PVN <> 0 時: 固定填 0x00
;;;1369       {                                                                                    //PVN = 0 時:
;;;1370           memcpy(pECCAutoLoadLogBody->LoyaltyCounter, DCAReadData->LoyaltyCounter, sizeof(pECCAutoLoadLogBody->LoyaltyCounter));                                                     //來源: 卡片
;;;1371       }
;;;1372       //2018.08.14  -->A.【AGENT_NO】操作員代碼：應與扣款LOG欄位相同。    
;;;1373       //pECCAutoLoadLogBody->AgentNo[0] = 0x00;             //2 AGENT_NO 操作員代碼 Unsigned 2 如 Ascii 字元'1234'即為 0x31 0x32 0x33 0x34 轉 10 進制數值 1234 即為 0x04 0xD2
;;;1374       //pECCAutoLoadLogBody->AgentNo[1] = 0x01;                                                        //以 LSB FIRST 傳送:0xD2 0x04
;;;1375       uint32ToUint8(AgentNo, pECCAutoLoadLogBody->AgentNo, sizeof(pECCAutoLoadLogBody->AgentNo));                                                        //來源: 設備
;;;1376                                                               //此欄位 10 進制數值應與PPR_Reset/PPR_Reset_Online 一致
;;;1377       pECCAutoLoadLogBody->BankCode = DCAReadData->BankCode;               //3 BANK_CODE 銀行代碼 Unsigned 1 PVN <> 0 時: 固定填 0x00
;;;1378                                                               //PVN = 0 時:
;;;1379                                                               //來源: 卡片
;;;1380       if (PVN != 0x00)     //4 LOC_PROVIDER 設備服務提供者 Unsigned 3 PVN <> 0 時: 同 NEW_SP_ID(3 Bytes): 如 131071 即為 0x01 0xFF 0xFF
;;;1381       {                                                        //以 LSB FIRST 傳送: 0xFF 0xFF 0x01
;;;1382           memcpy(pECCAutoLoadLogBody->LocProvider, DCAReadData->NewServiceProviderID, sizeof(pECCAutoLoadLogBody->LocProvider));                                                     //來源: 設備
;;;1383       }                                                        //PVN = 0 時: 同 SP_ID(1 Bytes): 如 2 即為 0x02
;;;1384       else                                                        //補足 3 Bytes 為 0x00 0x00 0x02
;;;1385       {                                                        //以 LSB FIRST 傳送:0x02 0x00 0x00
;;;1386           pECCAutoLoadLogBody->LocProvider[0] = newSpID;                                                    //來源: 設備
;;;1387           pECCAutoLoadLogBody->LocProvider[1] = 0x00;  
;;;1388           pECCAutoLoadLogBody->LocProvider[2] = 0x00;  
;;;1389       }
;;;1390       
;;;1391       memset(pECCAutoLoadLogBody->MachineID, 0x20, sizeof(pECCAutoLoadLogBody->MachineID));  //5 MACHINE_ID 機器編號 Ascii 20 SP_ID(2 Bytes): '49' AVM='0',VAVM='1'(1 Byte) 流水編號(3 Bytes): '050’ 左靠右補空白，如 '490050ΔΔΔΔΔΔΔΔΔΔΔΔΔΔ' 來源: 設備
;;;1392       //2018.08.14  -->B.【MACHINE_ID】機器編號：應填  2020202020202020202020202020202020202020 ，卻填 7C20202020202020202020202020202020202020。
;;;1393       //diff with leon sample code
;;;1394       //pECCAutoLoadLogBody->MachineID[0] = newSpID;
;;;1395   
;;;1396       #warning need check here
;;;1397       memset(pECCAutoLoadLogBody->CMID, ' ', sizeof(pECCAutoLoadLogBody->CMID));             //6 CM_ID 鈔箱編號 Ascii 20 MACHINE_ID(6 Bytes) '-' 卸鈔日 yyyymmdd(8 Bytes)'-' 卸鈔序號(4 Bytes) 左靠右補空白，如'490050-20100101-1ΔΔΔ' 來源: 設備
;;;1398       memset(pECCAutoLoadLogBody->RFU1, 0x0, sizeof(pECCAutoLoadLogBody->RFU1));             //7 RFU1 保留欄位(共用) Byte 16 PVN <> 0 時: 固定填 16 Bytes 0x00
;;;1399                                                                                                       //PVN = 0 時: 固定填 16 Bytes 0x00
;;;1400       pECCAutoLoadLogBody->RFU1Ver = 0x00;                //8 RFU1_VER 欄位版本(共用) Unsigned 1 PVN <> 0 時:固定填 0x00
;;;1401                                                                                       //PVN = 0 時: 固定填 0x00
;;;1402       //2018.08.14  -->C.【RFU2】保留欄位：前面2個Byte應填 0050，卻填0000。
;;;1403       memset(pECCAutoLoadLogBody->RFU2, 0x0, sizeof(pECCAutoLoadLogBody->RFU2));     //9 RFU2 保留欄位(業者) Byte 16 PVN <> 0 時: 固定填 16 Bytes 0x00
;;;1404                                                                                   //PVN = 0 時: 固定填 16 Bytes 0x00
;;;1405       pECCAutoLoadLogBody->RFU2[0] = 0x00;//SVCE_LOC_ID;
;;;1406       pECCAutoLoadLogBody->RFU2[1] = SVCE_LOC_ID ;
;;;1407       
;;;1408       
;;;1409       //2018.08.14  -->D.【RFU2_VER】欄位版本：應填 01，卻填 00。
;;;1410       pECCAutoLoadLogBody->RFU2Ver = 0x01;                  //10 RFU2_VER 欄位版本(業者) Unsigned 1 PVN <> 0 時: 固定填 0x00
;;;1411                                                                                           //PVN = 0 時: 固定填 0x00
;;;1412       if (PVN != 0x00)
;;;1413       {
;;;1414           pECCAutoLoadLogBody->TXNMode = EDCADeductData->AutoLoadTM;      //11 TM(TXN Mode) 交易模式 Byte 1 PVN <> 0 時:來源: 設備
;;;1415                                                                                                       //PVN = 0 時: 固定填 0x00
;;;1416           pECCAutoLoadLogBody->TXNQualifier = EDCADeductData->AutoLoadTQ; //12 TQ(TXN Qualifier) 交易屬性 Byte 1 PVN <> 0 時: 來源: 設備
;;;1417                                                                                               //PVN = 0 時: 固定填 0x00
;;;1418           pECCAutoLoadLogBody->SignKeyVer = EDCADeductData->SignatureKeyKVN;;             //13 SIGN_KEYVER SIGNATURE KEY 版本 Byte 1 PVN <> 0 時: 來源: Cpu 卡
;;;1419                                                                                           //PVN = 0 時: 固定填 0x00
;;;1420           memcpy(pECCAutoLoadLogBody->SignValue, EDCADeductData->AutoLoadSIGN, sizeof(pECCAutoLoadLogBody->SignValue));   //14 SIGN_VALUE SIGNATURE 值 Byte 16 PVN <> 0 時: 來源: Cpu 卡
;;;1421                                                                           //PVN = 0 時: 固定填 16 Bytes 0x00
;;;1422       }
;;;1423       // ********   Tail   ********
;;;1424       if (PVN == 0x00)
;;;1425       {
;;;1426           memcpy(&(pECCAutoLoadLogBody->Tail.MACKeySet), EDCADeductData->AutoLoadMAC, 10); //MAC 10 bytes   //1 MACKeySet 0x00 Byte 1 固定填 0x00
;;;1427       }
;;;1428       else
;;;1429       {
;;;1430           //uint8_t         MACKeySet;                  //1 MACKeySet 0x00 Byte 1 固定填 0x00
;;;1431           //uint8_t         MAC3DESKey;                 //2 MAC3DESKey 0x01 Byte 1 固定填 0x01
;;;1432           //uint8_t         MACValue[4];                //3 MACValue 交易驗証碼 Unsigned 4
;;;1433                                                               //PVN <> 0 時: 固定填 4 Bytes 0x00
;;;1434                                                               //PVN = 0 時: 來源:設備
;;;1435           //uint8_t         MACMFRC[4];                 //4 MACMFRC 讀卡機編號 Unsigned 4
;;;1436                                                               //PVN <> 0 時: 固定填 4 Bytes 0x00
;;;1437                                                               //PVN = 0 時: 來源:設備
;;;1438       }
;;;1439       pECCAutoLoadLogBody->Tail.MAC3DESKey = 0x01;         //2 MAC3DESKey 0x01 Byte 1 固定填 0x01
;;;1440       
;;;1441       #warning two case are the same
;;;1442       if (PVN == 0x00)
;;;1443       {// PPR_RESET 舊SAM Info，PPR_RESET_OFFLINE 的舊SAM ID 為 0x00， 所以用新SAM ID
;;;1444           memcpy(pECCAutoLoadLogBody->Tail.SAMID, EDCADeductData->SID, sizeof(pECCAutoLoadLogBody->Tail.SAMID));  //5 SAM_ID SAM ID Pack 8
;;;1445                                                           //PVN <> 0 時: 來源: Cpu Sam 卡
;;;1446                                                           //PVN = 0 時: 來源:設備
;;;1447       }
;;;1448       else
;;;1449       {// PPR_RESET 新SAM Info
;;;1450           memcpy(pECCAutoLoadLogBody->Tail.SAMID, EDCADeductData->SID, sizeof(pECCAutoLoadLogBody->Tail.SAMID)); 
;;;1451       }
;;;1452       
;;;1453       if (PVN != 0x00)
;;;1454       {
;;;1455           pECCAutoLoadLogBody->Tail.HashType = EDCADeductData->HashType;                   //6 HASH_TYPE HASH_TYPE Unsigned 1
;;;1456                                                           //PVN <> 0 時: 代碼參照 8.4 來源: 設備
;;;1457                                                           //PVN = 0 時: 固定填 0x00
;;;1458       }
;;;1459       if (PVN != 0x00)
;;;1460       {
;;;1461           pECCAutoLoadLogBody->Tail.HostAdminKeyVer = EDCADeductData->HostAdminKeyKVN;            //7 HOST_ADMIN_KEYVER HOST ADMIN KEY 版本 Byte 1
;;;1462                                                           //PVN <> 0 時: MAC 用哪個版本 KEY 去押的  來源: Cpu Sam 卡
;;;1463                                                           //PVN = 0 時: 固定填 0x00
;;;1464       }
;;;1465       if (PVN != 0x00)
;;;1466       {
;;;1467           memcpy(pECCAutoLoadLogBody->Tail.CpuMACValue, EDCADeductData->AutoLoadMAC, sizeof(pECCAutoLoadLogBody->Tail.CpuMACValue));    //8 CPU_MAC_VALUE MAC 值 Byte 16
;;;1468                                                           //PVN <> 0 時: 來源: Cpu Sam 卡計算
;;;1469                                                           //PVN = 0 時: 固定填 16 Bytes 0x00
;;;1470       }
;;;1471       
;;;1472       
;;;1473       
;;;1474   #if(ECC_LOG_USE_NEW_FILE_NAME)
;;;1475       //咪表ID_訂單號_時間(yyyyMMddHHmmss)_001U.ECC
;;;1476       sprintf(currentECCAutoLoadLogFileName, "%s_%s_%s_002U.ECC", GetMeterData()->epmIdStr, GetMeterData()->bookingId, getECCLogUTCTimeStr(utcTime));
;;;1477   #else 
;;;1478       SP_ID_INT = DCAReadData->ServiceProviderID;
;;;1479       SP_ID_INT_NEW = uint8ToUint32(DCAReadData->NewServiceProviderID, sizeof(DCAReadData->NewServiceProviderID));
;;;1480       LOCATION_ID_INT_NEW = uint8ToUint32(DCAReadData->NewLocationID, sizeof(DCAReadData->NewLocationID));
;;;1481       sprintf(currentECCAutoLoadLogFileName, "00220.%03d_%08d_%05d_00000.%s_002U.ECC", SP_ID_INT, SP_ID_INT_NEW, LOCATION_ID_INT_NEW, getECCLogUTCTimeStr(utcTime));
;;;1482   #endif
;;;1483       return TRUE;
;;;1484       #endif
;;;1485   }
000210  e8bd80f0          POP      {r4-r7,pc}
;;;1486   char* ECCAutoLoadLogGetFileName(void)
                          ENDP

                  ECCAutoLoadLogGetFileName PROC
000214  e59f0030          LDR      r0,|L1.588|
;;;1487   {
;;;1488       return currentECCAutoLoadLogFileName;
;;;1489   }
000218  e12fff1e          BX       lr
;;;1490   /*** * Copyright (C) 2016 Far Easy Pass LTD. All rights reserved. ***/
                          ENDP

                  |L1.540|
00021c  25303464          DCB      "%04d%02d%02d%02d%02d%02d",0
000220  25303264
000224  25303264
000228  25303264
00022c  25303264
000230  25303264
000234  00      
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0
                  |L1.568|
                          DCD      currentDateTimeStr
                  |L1.572|
                          DCD      currentECCDeductLogFileName
                  |L1.576|
                          DCD      currentECCReSendLogFileName
                  |L1.580|
                          DCD      currentECCLockCardLogFileName
                  |L1.584|
                          DCD      currentECCFeedbackLogFileName
                  |L1.588|
                          DCD      currentECCAutoLoadLogFileName

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  currentECCDeductLogFileName
                          %        255
                  currentECCReSendLogFileName
                          %        255
                  currentECCLockCardLogFileName
                          %        255
                  currentECCFeedbackLogFileName
                          %        255
                  currentECCAutoLoadLogFileName
                          %        255
                  currentDateTimeStr
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  Spid
                          DCD      0x00000000
                  NewSpID
                          DCD      0x00000000
                  NewLocationID
                          DCD      0x00000000
