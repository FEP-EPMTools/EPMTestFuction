; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\sddrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\sddrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\sddrv.crf src\UserDrv\sddrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SDH_IRQHandler PROC
                  |L1.0|
;;;44     
;;;45     void SDH_IRQHandler(void)
000000  e92d400c          PUSH     {r2,r3,lr}
;;;46     {
;;;47         unsigned int volatile isr;
;;;48         //sysprintf("SDH_IRQHandler...\r\n");
;;;49         // FMI data abort interrupt
;;;50         if (inpw(REG_SDH_GINTSTS) & SDH_GINTSTS_DTAIF_Msk) {
000004  e59f0340          LDR      r0,|L1.844|
000008  e5900000          LDR      r0,[r0,#0]
00000c  e3100001          TST      r0,#1
000010  0a000007          BEQ      |L1.52|
;;;51             /* ResetAllEngine() */
;;;52             outpw(REG_SDH_GCTL, inpw(REG_SDH_GCTL) | SDH_GCTL_GCTLRST_Msk);
000014  e59f0334          LDR      r0,|L1.848|
000018  e5900000          LDR      r0,[r0,#0]
00001c  e3800001          ORR      r0,r0,#1
000020  e59f1328          LDR      r1,|L1.848|
000024  e5810000          STR      r0,[r1,#0]
;;;53             outpw(REG_SDH_GINTSTS, SDH_GINTSTS_DTAIF_Msk);
000028  e3a00001          MOV      r0,#1
00002c  e1811180          ORR      r1,r1,r0,LSL #3
000030  e5810000          STR      r0,[r1,#0]
                  |L1.52|
;;;54         }
;;;55     
;;;56         //----- SD interrupt status
;;;57         isr = inpw(REG_SDH_INTSTS);
000034  e59f0318          LDR      r0,|L1.852|
000038  e5900000          LDR      r0,[r0,#0]
00003c  e58d0004          STR      r0,[sp,#4]
;;;58         if (isr & SDH_INTSTS_BLKDIF_Msk) {      // block down
000040  e59d0004          LDR      r0,[sp,#4]
000044  e3100001          TST      r0,#1
000048  0a000004          BEQ      |L1.96|
;;;59             _sd_SDDataReady = TRUE;
00004c  e3a00001          MOV      r0,#1
000050  e59f1300          LDR      r1,|L1.856|
000054  e5c10000          STRB     r0,[r1,#0]  ; _sd_SDDataReady
;;;60             outpw(REG_SDH_INTSTS, SDH_INTSTS_BLKDIF_Msk);
000058  e59f12f4          LDR      r1,|L1.852|
00005c  e5810000          STR      r0,[r1,#0]
                  |L1.96|
;;;61         }
;;;62     
;;;63         if (isr & SDH_INTSTS_CDIF0_Msk) { // port 0 card detect
000060  e59d0004          LDR      r0,[sp,#4]
000064  e3100c01          TST      r0,#0x100
000068  0a00000e          BEQ      |L1.168|
;;;64             //----- SD interrupt status
;;;65             // it is work to delay 50 times for SD_CLK = 200KHz
;;;66             {
;;;67                 volatile int i;         // delay 30 fail, 50 OK
;;;68                 for (i=0; i<0x500; i++);   // delay to make sure got updated value from REG_SDISR.
00006c  e3a00000          MOV      r0,#0
000070  e58d0000          STR      r0,[sp,#0]
000074  ea000002          B        |L1.132|
                  |L1.120|
000078  e59d0000          LDR      r0,[sp,#0]
00007c  e2800001          ADD      r0,r0,#1
000080  e58d0000          STR      r0,[sp,#0]
                  |L1.132|
000084  e59d0000          LDR      r0,[sp,#0]
000088  e3500c05          CMP      r0,#0x500
00008c  bafffff9          BLT      |L1.120|
;;;69                 isr = inpw(REG_SDH_INTSTS);
000090  e59f02bc          LDR      r0,|L1.852|
000094  e5900000          LDR      r0,[r0,#0]
000098  e58d0004          STR      r0,[sp,#4]
;;;70             }
;;;71     #if(0)
;;;72     #ifdef _USE_DAT3_DETECT_
;;;73             //#error
;;;74             if (!(isr & SDH_INTSTS_CDSTS0_Msk)) {
;;;75                 SD0.IsCardInsert = FALSE;
;;;76                 sysprintf("\nCard Remove!\n");
;;;77                 SD_Close_Disk(0);
;;;78             } else {
;;;79                 SD_Open_Disk(SD_PORT0 | CardDetect_From_DAT3);
;;;80             }
;;;81     #else
;;;82             if (isr & SDH_INTSTS_CDSTS0_Msk) {
;;;83                 SD0.IsCardInsert = FALSE;   // SDISR_CD_Card = 1 means card remove for GPIO mode
;;;84                 sysprintf("\nCard Remove!\n");
;;;85                 SD_Close_Disk(0);
;;;86             } else {
;;;87                 SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
;;;88             }
;;;89     #endif
;;;90     #endif
;;;91             outpw(REG_SDH_INTSTS, SDH_INTSTS_CDIF0_Msk);
00009c  e3a00c01          MOV      r0,#0x100
0000a0  e59f12ac          LDR      r1,|L1.852|
0000a4  e5810000          STR      r0,[r1,#0]
                  |L1.168|
;;;92         }
;;;93     
;;;94         if (isr & SDH_INTSTS_CDIF1_Msk) { // port 1 card detect
0000a8  e59d0004          LDR      r0,[sp,#4]
0000ac  e3100c02          TST      r0,#0x200
0000b0  0a00000e          BEQ      |L1.240|
;;;95             //----- SD interrupt status
;;;96             // it is work to delay 50 times for SD_CLK = 200KHz
;;;97             {
;;;98                 volatile int i;         // delay 30 fail, 50 OK
;;;99                 for (i=0; i<0x500; i++);   // delay to make sure got updated value from REG_SDISR.
0000b4  e3a00000          MOV      r0,#0
0000b8  e58d0000          STR      r0,[sp,#0]
0000bc  ea000002          B        |L1.204|
                  |L1.192|
0000c0  e59d0000          LDR      r0,[sp,#0]
0000c4  e2800001          ADD      r0,r0,#1
0000c8  e58d0000          STR      r0,[sp,#0]
                  |L1.204|
0000cc  e59d0000          LDR      r0,[sp,#0]
0000d0  e3500c05          CMP      r0,#0x500
0000d4  bafffff9          BLT      |L1.192|
;;;100                isr = inpw(REG_SDH_INTSTS);
0000d8  e59f0274          LDR      r0,|L1.852|
0000dc  e5900000          LDR      r0,[r0,#0]
0000e0  e58d0004          STR      r0,[sp,#4]
;;;101            }
;;;102    #if(0)
;;;103    #ifdef _USE_DAT3_DETECT_
;;;104            if (!(isr & SDH_INTSTS_CDSTS1_Msk)) {
;;;105                SD0.IsCardInsert = FALSE;
;;;106                sysprintf("\nCard Remove!\n");
;;;107                SD_Close_Disk(1);
;;;108            } else {
;;;109                SD_Open_Disk(SD_PORT1 | CardDetect_From_DAT3);
;;;110            }
;;;111    #else
;;;112            if (isr & SDH_INTSTS_CDSTS1_Msk) {
;;;113                SD0.IsCardInsert = FALSE;   // SDISR_CD_Card = 1 means card remove for GPIO mode
;;;114                sysprintf("\nCard Remove!\n");
;;;115                SD_Close_Disk(1);
;;;116            } else {
;;;117                SD_Open_Disk(SD_PORT1 | CardDetect_From_GPIO);
;;;118            }
;;;119    #endif
;;;120    #endif
;;;121    
;;;122            outpw(REG_SDH_INTSTS, SDH_INTSTS_CDIF1_Msk);
0000e4  e3a00c02          MOV      r0,#0x200
0000e8  e59f1264          LDR      r1,|L1.852|
0000ec  e5810000          STR      r0,[r1,#0]
                  |L1.240|
;;;123        }
;;;124    
;;;125        // CRC error interrupt
;;;126        if (isr & SDH_INTSTS_CRCIF_Msk) {
0000f0  e59d0004          LDR      r0,[sp,#4]
0000f4  e3100002          TST      r0,#2
0000f8  0a000009          BEQ      |L1.292|
;;;127            if (!(isr & SDH_INTSTS_CRC16_Msk)) {
0000fc  e59d0004          LDR      r0,[sp,#4]
000100  e3100008          TST      r0,#8
000104  0a000003          BEQ      |L1.280|
;;;128                //syssysprintf("***** ISR sdioIntHandler(): CRC_16 error !\n");
;;;129                // handle CRC error
;;;130            } else if (!(isr & SDH_INTSTS_CRC7_Msk)) {
000108  e59d0004          LDR      r0,[sp,#4]
00010c  e3100004          TST      r0,#4
000110  1a000000          BNE      |L1.280|
;;;131                extern unsigned int _sd_uR3_CMD;
;;;132                if (! _sd_uR3_CMD) {
000114  e1a00000          MOV      r0,r0
                  |L1.280|
;;;133                    //syssysprintf("***** ISR sdioIntHandler(): CRC_7 error !\n");
;;;134                    // handle CRC error
;;;135                }
;;;136            }
;;;137            outpw(REG_SDH_INTSTS, SDH_INTSTS_CRCIF_Msk);      // clear interrupt flag
000118  e3a00002          MOV      r0,#2
00011c  e59f1230          LDR      r1,|L1.852|
000120  e5810000          STR      r0,[r1,#0]
                  |L1.292|
;;;138        }
;;;139    }
000124  e8bd800c          POP      {r2,r3,pc}
;;;140    
                          ENDP

                  get_fattime PROC
;;;141    unsigned long get_fattime (void)
000128  e3a00000          MOV      r0,#0
;;;142    {
;;;143        unsigned long tmr;
;;;144    
;;;145        tmr=0x00000;
;;;146    
;;;147        return tmr;
;;;148    }
00012c  e12fff1e          BX       lr
;;;149    
                          ENDP

                  SYS_Init PROC
;;;150    static void SYS_Init(void)
000130  e92d4010          PUSH     {r4,lr}
;;;151    {
;;;152        /* enable SDH */
;;;153        outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | 0x40000000);
000134  e3a0020b          MOV      r0,#0xb0000000
000138  e5900210          LDR      r0,[r0,#0x210]
00013c  e3800101          ORR      r0,r0,#0x40000000
000140  e3a0120b          MOV      r1,#0xb0000000
000144  e5810210          STR      r0,[r1,#0x210]
;;;154    
;;;155        /* select multi-function-pin */
;;;156    
;;;157        /* SD Port 0 -> PD0~6 */
;;;158        outpw(REG_SYS_GPD_MFPL, 0x6666666);
000148  e59f020c          LDR      r0,|L1.860|
00014c  e5810088          STR      r0,[r1,#0x88]
;;;159        
;;;160        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000150  e3a0020b          MOV      r0,#0xb0000000
000154  e5900218          LDR      r0,[r0,#0x218]
000158  e3800008          ORR      r0,r0,#8
00015c  e5810218          STR      r0,[r1,#0x218]
;;;161        //GPD7 Power pin
;;;162        outpw(REG_SYS_GPD_MFPL,(inpw(REG_SYS_GPD_MFPL) & ~(0xFu<<28)) | (0x0u<<28));
000160  e3a0020b          MOV      r0,#0xb0000000
000164  e5900088          LDR      r0,[r0,#0x88]
000168  e3c0020f          BIC      r0,r0,#0xf0000000
00016c  e5810088          STR      r0,[r1,#0x88]
;;;163        GPIO_OpenBit(GPIOD, BIT7, DIR_OUTPUT, NO_PULL_UP); 
000170  e3a03000          MOV      r3,#0
000174  e3a02001          MOV      r2,#1
000178  e3a01080          MOV      r1,#0x80
00017c  e3a000c0          MOV      r0,#0xc0
000180  ebfffffe          BL       GPIO_OpenBit
;;;164    #if(0)    
;;;165        GPIO_SetBit(GPIOD, BIT7);  //power down  
;;;166    #else    
;;;167        GPIO_ClrBit(GPIOD, BIT7); //power up  
000184  e3a01080          MOV      r1,#0x80
000188  e3a000c0          MOV      r0,#0xc0
00018c  ebfffffe          BL       GPIO_ClrBit
;;;168    #endif    
;;;169    
;;;170    }
000190  e8bd8010          POP      {r4,pc}
;;;171    /*
                          ENDP

                  SdDrvInit PROC
;;;192    
;;;193    BOOL SdDrvInit(void)
000194  e92d4010          PUSH     {r4,lr}
;;;194    {
;;;195        sysprintf("SdDrvInit...\r\n");
000198  e28f0d07          ADR      r0,|L1.864|
00019c  ebfffffe          BL       sysprintf
;;;196        SYS_Init();
0001a0  ebfffffe          BL       SYS_Init
;;;197        sysInstallISR(HIGH_LEVEL_SENSITIVE|IRQ_LEVEL_1, SDH_IRQn, (PVOID)SDH_IRQHandler);
0001a4  e24f2f6b          ADR      r2,|L1.0|
0001a8  e3a0101b          MOV      r1,#0x1b
0001ac  e3a00041          MOV      r0,#0x41
0001b0  ebfffffe          BL       sysInstallISR
;;;198        /* enable CPSR I bit */
;;;199        sysSetLocalInterrupt(ENABLE_IRQ);
0001b4  e3a0007f          MOV      r0,#0x7f
0001b8  ebfffffe          BL       sysSetLocalInterrupt
;;;200        sysEnableInterrupt(SDH_IRQn);
0001bc  e3a0001b          MOV      r0,#0x1b
0001c0  ebfffffe          BL       sysEnableInterrupt
;;;201        SD_SetReferenceClock(300000);
0001c4  e59f01a4          LDR      r0,|L1.880|
0001c8  ebfffffe          BL       SD_SetReferenceClock
;;;202        SD_Open(SD_PORT0 | CardDetect_From_GPIO);
0001cc  e59f01a0          LDR      r0,|L1.884|
0001d0  ebfffffe          BL       SD_Open
;;;203        if (SD_Probe((SD_PORT0 | CardDetect_From_GPIO) & 0x00ff) != TRUE) 
0001d4  e3a00001          MOV      r0,#1
0001d8  ebfffffe          BL       SD_Probe
0001dc  e3500001          CMP      r0,#1
0001e0  0a000003          BEQ      |L1.500|
;;;204        {
;;;205            sysprintf("SD0 initial fail!!\n");
0001e4  e28f0f63          ADR      r0,|L1.888|
0001e8  ebfffffe          BL       sysprintf
;;;206            return FALSE;
0001ec  e3a00000          MOV      r0,#0
                  |L1.496|
;;;207        }
;;;208    
;;;209        sysprintf("SdDrvInit...OK\r\n");
;;;210        return TRUE; 
;;;211    }
0001f0  e8bd8010          POP      {r4,pc}
                  |L1.500|
0001f4  e28f0e19          ADR      r0,|L1.908|
0001f8  ebfffffe          BL       sysprintf
0001fc  e3a00001          MOV      r0,#1                 ;210
000200  eafffffa          B        |L1.496|
;;;212    
                          ENDP

                  SDDrvInitialize PROC
;;;213    BOOL SDDrvInitialize(uint8_t pdrv)
000204  e1a01000          MOV      r1,r0
;;;214    {
;;;215        if (SD_GET_CARD_CAPACITY(SD_PORT0) == 0)
000208  e59f0190          LDR      r0,|L1.928|
00020c  e5900010          LDR      r0,[r0,#0x10]  ; SD0
000210  e3500000          CMP      r0,#0
000214  1a000001          BNE      |L1.544|
;;;216            return FALSE;
000218  e3a00000          MOV      r0,#0
                  |L1.540|
;;;217        return TRUE;
;;;218    }
00021c  e12fff1e          BX       lr
                  |L1.544|
000220  e3a00001          MOV      r0,#1                 ;217
000224  eafffffc          B        |L1.540|
;;;219    BOOL SDDrvStatus(uint8_t pdrv)
                          ENDP

                  SDDrvStatus PROC
000228  e1a01000          MOV      r1,r0
;;;220    {
;;;221        if (SD_GET_CARD_CAPACITY(SD_PORT0) == 0)
00022c  e59f016c          LDR      r0,|L1.928|
000230  e5900010          LDR      r0,[r0,#0x10]  ; SD0
000234  e3500000          CMP      r0,#0
000238  1a000001          BNE      |L1.580|
;;;222            return FALSE;
00023c  e3a00000          MOV      r0,#0
                  |L1.576|
;;;223        return TRUE;
;;;224        
;;;225    }
000240  e12fff1e          BX       lr
                  |L1.580|
000244  e3a00001          MOV      r0,#1                 ;223
000248  eafffffc          B        |L1.576|
;;;226    BOOL SDDrvRead(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count)
                          ENDP

                  SDDrvRead PROC
00024c  e92d41f0          PUSH     {r4-r8,lr}
;;;227    {
000250  e1a07000          MOV      r7,r0
000254  e1a04001          MOV      r4,r1
000258  e1a05002          MOV      r5,r2
00025c  e1a06003          MOV      r6,r3
;;;228         outpw(REG_SDH_GCTL, SDH_GCTL_SDEN_Msk);
000260  e3a00002          MOV      r0,#2
000264  e59f10e4          LDR      r1,|L1.848|
000268  e5810000          STR      r0,[r1,#0]
;;;229         if((DRESULT) SD_Read(SD_PORT0, buff, sector, count) == RES_OK)
00026c  e1a03006          MOV      r3,r6
000270  e1a02005          MOV      r2,r5
000274  e1a01004          MOV      r1,r4
000278  e3a00001          MOV      r0,#1
00027c  ebfffffe          BL       SD_Read
000280  e31000ff          TST      r0,#0xff
000284  1a000001          BNE      |L1.656|
;;;230         {
;;;231             return TRUE;
000288  e3a00001          MOV      r0,#1
                  |L1.652|
;;;232         }
;;;233         return FALSE;
;;;234    }
00028c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.656|
000290  e3a00000          MOV      r0,#0                 ;233
000294  eafffffc          B        |L1.652|
;;;235    BOOL SDDrvWrite(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count)
                          ENDP

                  SDDrvWrite PROC
000298  e92d41f0          PUSH     {r4-r8,lr}
;;;236    {    
00029c  e1a07000          MOV      r7,r0
0002a0  e1a04001          MOV      r4,r1
0002a4  e1a05002          MOV      r5,r2
0002a8  e1a06003          MOV      r6,r3
;;;237        outpw(REG_SDH_GCTL, SDH_GCTL_SDEN_Msk);
0002ac  e3a00002          MOV      r0,#2
0002b0  e59f1098          LDR      r1,|L1.848|
0002b4  e5810000          STR      r0,[r1,#0]
;;;238        if((DRESULT) SD_Write(SD_PORT0, buff, sector, count) == RES_OK)
0002b8  e1a03006          MOV      r3,r6
0002bc  e1a02005          MOV      r2,r5
0002c0  e1a01004          MOV      r1,r4
0002c4  e3a00001          MOV      r0,#1
0002c8  ebfffffe          BL       SD_Write
0002cc  e31000ff          TST      r0,#0xff
0002d0  1a000001          BNE      |L1.732|
;;;239        {
;;;240            return TRUE;
0002d4  e3a00001          MOV      r0,#1
                  |L1.728|
;;;241        }
;;;242        return FALSE;
;;;243    }
0002d8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.732|
0002dc  e3a00000          MOV      r0,#0                 ;242
0002e0  eafffffc          B        |L1.728|
;;;244    BOOL SDDrvIoctl(uint8_t pdrv, uint8_t cmd, void *buff )
                          ENDP

                  SDDrvIoctl PROC
0002e4  e1a03000          MOV      r3,r0
;;;245    {
;;;246        BOOL res = TRUE;
0002e8  e3a00001          MOV      r0,#1
;;;247        switch(cmd) 
0002ec  e3510000          CMP      r1,#0
0002f0  0a000004          BEQ      |L1.776|
0002f4  e3510001          CMP      r1,#1
0002f8  0a000004          BEQ      |L1.784|
0002fc  e3510002          CMP      r1,#2
000300  1a00000c          BNE      |L1.824|
000304  ea000006          B        |L1.804|
                  |L1.776|
;;;248        {
;;;249            case CTRL_SYNC:
000308  e1a00000          MOV      r0,r0
;;;250                break;
00030c  ea00000c          B        |L1.836|
                  |L1.784|
;;;251            case GET_SECTOR_COUNT:
000310  e1a00000          MOV      r0,r0
;;;252                *(DWORD*)buff = SD0.totalSectorN;
000314  e59fc084          LDR      r12,|L1.928|
000318  e59cc00c          LDR      r12,[r12,#0xc]  ; SD0
00031c  e582c000          STR      r12,[r2,#0]
;;;253                break;
000320  ea000007          B        |L1.836|
                  |L1.804|
;;;254            case GET_SECTOR_SIZE:
000324  e1a00000          MOV      r0,r0
;;;255                *(WORD*)buff = SD0.sectorSize;
000328  e59fc070          LDR      r12,|L1.928|
00032c  e1dcc1b4          LDRH     r12,[r12,#0x14]  ; SD0
000330  e1c2c0b0          STRH     r12,[r2,#0]
;;;256                break;
000334  ea000002          B        |L1.836|
                  |L1.824|
;;;257    
;;;258            default:
000338  e1a00000          MOV      r0,r0
;;;259                res = FALSE;
00033c  e3a00000          MOV      r0,#0
;;;260                break;
000340  e1a00000          MOV      r0,r0
                  |L1.836|
000344  e1a00000          MOV      r0,r0                 ;250
;;;261        }
;;;262        return res;
;;;263    }
000348  e12fff1e          BX       lr
;;;264    
                          ENDP

                  |L1.844|
                          DCD      0xb000c808
                  |L1.848|
                          DCD      0xb000c800
                  |L1.852|
                          DCD      0xb000c82c
                  |L1.856|
                          DCD      _sd_SDDataReady
                  |L1.860|
                          DCD      0x06666666
                  |L1.864|
000360  53644472          DCB      "SdDrvInit...\r\n",0
000364  76496e69
000368  742e2e2e
00036c  0d0a00  
00036f  00                DCB      0
                  |L1.880|
                          DCD      0x000493e0
                  |L1.884|
                          DCD      0x00000101
                  |L1.888|
000378  53443020          DCB      "SD0 initial fail!!\n",0
00037c  696e6974
000380  69616c20
000384  6661696c
000388  21210a00
                  |L1.908|
00038c  53644472          DCB      "SdDrvInit...OK\r\n",0
000390  76496e69
000394  742e2e2e
000398  4f4b0d0a
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L1.928|
                          DCD      ||SD0||
