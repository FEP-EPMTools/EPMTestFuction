; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\radarlib.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\radarlib.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\radarlib.crf src\userdrv\radarlib.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_f
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_fp_dec
                  average PROC
;;;50     
;;;51     static float average(const float* values, const int32_t start, const int32_t end) 
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;52     {
000004  e1a07000          MOV      r7,r0
000008  e1a04001          MOV      r4,r1
00000c  e1a05002          MOV      r5,r2
;;;53         int32_t idx;
;;;54     
;;;55         float sum = 0.0f;
000010  e3a08000          MOV      r8,#0
;;;56         for (idx = start; idx < end; ++idx) {
000014  e1a06004          MOV      r6,r4
000018  ea000004          B        |L1.48|
                  |L1.28|
;;;57             sum += values[idx];
00001c  e7971106          LDR      r1,[r7,r6,LSL #2]
000020  e1a00008          MOV      r0,r8
000024  ebfffffe          BL       __aeabi_fadd
000028  e1a08000          MOV      r8,r0
00002c  e2866001          ADD      r6,r6,#1              ;56
                  |L1.48|
000030  e1560005          CMP      r6,r5                 ;56
000034  bafffff8          BLT      |L1.28|
;;;58         }
;;;59         return sum / (end - start);
000038  e0450004          SUB      r0,r5,r4
00003c  ebfffffe          BL       __aeabi_i2f
000040  e1a09000          MOV      r9,r0
000044  e1a01009          MOV      r1,r9
000048  e1a00008          MOV      r0,r8
00004c  ebfffffe          BL       __aeabi_fdiv
;;;60     }
000050  e8bd87f0          POP      {r4-r10,pc}
;;;61     
                          ENDP

                  stddev PROC
;;;62     static float stddev(const float* values, const int32_t start, const int32_t end) 
000054  e92d4ff0          PUSH     {r4-r11,lr}
;;;63     {
000058  e24dd014          SUB      sp,sp,#0x14
00005c  e1a09000          MOV      r9,r0
000060  e1a05001          MOV      r5,r1
000064  e1a06002          MOV      r6,r2
;;;64         int32_t idx;
;;;65         float dev = 0.0f;
000068  e3a0a000          MOV      r10,#0
;;;66         float avg = average(values, start, end);
00006c  e1a02006          MOV      r2,r6
000070  e1a01005          MOV      r1,r5
000074  e1a00009          MOV      r0,r9
000078  ebfffffe          BL       average
00007c  e58d0010          STR      r0,[sp,#0x10]
;;;67         if (avg == 0.0f) {
000080  e3a01000          MOV      r1,#0
000084  e59d0010          LDR      r0,[sp,#0x10]
000088  ebfffffe          BL       __aeabi_cfcmpeq
00008c  1a000002          BNE      |L1.156|
;;;68             return 0.0f;
000090  e3a00000          MOV      r0,#0
                  |L1.148|
000094  e28dd014          ADD      sp,sp,#0x14
;;;69         }
;;;70     
;;;71         for (idx = start; idx < end; ++idx) {
;;;72             float d = values[idx] - avg;
;;;73             dev += (d * d);
;;;74         }
;;;75         //return sqrt(dev / (float)(end - start - 1));
;;;76         return sqrt(dev / (end - start - 1));
;;;77     }
000098  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.156|
00009c  e1a04005          MOV      r4,r5                 ;71
0000a0  ea00000b          B        |L1.212|
                  |L1.164|
0000a4  e7990104          LDR      r0,[r9,r4,LSL #2]     ;72
0000a8  e59d1010          LDR      r1,[sp,#0x10]         ;72
0000ac  ebfffffe          BL       __aeabi_fsub
0000b0  e1a07000          MOV      r7,r0                 ;72
0000b4  e1a01007          MOV      r1,r7                 ;73
0000b8  e1a00007          MOV      r0,r7                 ;73
0000bc  ebfffffe          BL       __aeabi_fmul
0000c0  e1a08000          MOV      r8,r0                 ;73
0000c4  e1a0100a          MOV      r1,r10                ;73
0000c8  ebfffffe          BL       __aeabi_fadd
0000cc  e1a0a000          MOV      r10,r0                ;73
0000d0  e2844001          ADD      r4,r4,#1              ;71
                  |L1.212|
0000d4  e1540006          CMP      r4,r6                 ;71
0000d8  bafffff1          BLT      |L1.164|
0000dc  e0461005          SUB      r1,r6,r5              ;76
0000e0  e2410001          SUB      r0,r1,#1              ;76
0000e4  ebfffffe          BL       __aeabi_i2f
0000e8  e58d0004          STR      r0,[sp,#4]            ;76
0000ec  e1a01000          MOV      r1,r0                 ;76
0000f0  e1a0000a          MOV      r0,r10                ;76
0000f4  ebfffffe          BL       __aeabi_fdiv
0000f8  e1a0b000          MOV      r11,r0                ;76
0000fc  ebfffffe          BL       __aeabi_f2d
000100  e1cd00f8          STRD     r0,r1,[sp,#8]         ;76
000104  ebfffffe          BL       sqrt
000108  e1a07000          MOV      r7,r0                 ;76
00010c  ebfffffe          BL       __aeabi_d2f
000110  eaffffdf          B        |L1.148|
;;;78     
                          ENDP

                  calculateFeature PROC
;;;79     static void calculateFeature(const pm_packet* packet, pm_feature* feature) 
000114  e92d41f0          PUSH     {r4-r8,lr}
;;;80     {
000118  e1a05000          MOV      r5,r0
00011c  e1a06001          MOV      r6,r1
;;;81         feature->peakIndex = packet->peakIndex - RSTART;
000120  e5d50013          LDRB     r0,[r5,#0x13]
000124  e5d51012          LDRB     r1,[r5,#0x12]
000128  e1810400          ORR      r0,r1,r0,LSL #8
00012c  e59f1440          LDR      r1,|L1.1396|
000130  e1d110b0          LDRH     r1,[r1,#0]  ; rangeStart
000134  e0400001          SUB      r0,r0,r1
000138  e1a00800          LSL      r0,r0,#16
00013c  e1a00820          LSR      r0,r0,#16
000140  e5c60000          STRB     r0,[r6,#0]
000144  e1a00420          LSR      r0,r0,#8
000148  e5c60001          STRB     r0,[r6,#1]
;;;82         for (int i = RSTART; i <= REND; ++i) {
00014c  e59f0420          LDR      r0,|L1.1396|
000150  e1d040b0          LDRH     r4,[r0,#0]  ; rangeStart
000154  ea00000b          B        |L1.392|
                  |L1.344|
;;;83             feature->numbers[i - RSTART] = packet->rangeProfile[i];        
000158  e2851034          ADD      r1,r5,#0x34
00015c  e0810104          ADD      r0,r1,r4,LSL #2
000160  ebfffffe          BL       __aeabi_uread4
000164  e1a07000          MOV      r7,r0
000168  e59f0404          LDR      r0,|L1.1396|
00016c  e1d000b0          LDRH     r0,[r0,#0]  ; rangeStart
000170  e0440000          SUB      r0,r4,r0
000174  e2862002          ADD      r2,r6,#2
000178  e0821100          ADD      r1,r2,r0,LSL #2
00017c  e1a00007          MOV      r0,r7
000180  ebfffffe          BL       __aeabi_uwrite4
000184  e2844001          ADD      r4,r4,#1              ;82
                  |L1.392|
000188  e59f03e8          LDR      r0,|L1.1400|
00018c  e1d000b0          LDRH     r0,[r0,#0]            ;82  ; rangeEnd
000190  e1540000          CMP      r4,r0                 ;82
000194  daffffef          BLE      |L1.344|
;;;84         }
;;;85     }
000198  e8bd81f0          POP      {r4-r8,pc}
;;;86     
                          ENDP

                  validateFeatureSet PROC
;;;87     static int32_t validateFeatureSet(const pm_threshold* threshold, pm_feature* feature, float unstableThreshold, int hlen, int radarIndex) 
00019c  e92d4ff0          PUSH     {r4-r11,lr}
;;;88     {
0001a0  e24dd054          SUB      sp,sp,#0x54
0001a4  e1a08000          MOV      r8,r0
0001a8  e1a09001          MOV      r9,r1
0001ac  e1a0a002          MOV      r10,r2
0001b0  e1a07003          MOV      r7,r3
0001b4  e59d6078          LDR      r6,[sp,#0x78]
;;;89         int i, idx;
;;;90         float mx;
;;;91         float dev;
;;;92         float values[HLEN];
;;;93     
;;;94         #define CHECKDEV(name) \
;;;95             for (idx = 0; idx < hlen; ++idx) { values[idx] = featuresLocal[radarIndex][idx].name; } \
;;;96             dev = stddev(values, 0, hlen) / mx; \
;;;97             if (dev > feature->unstableValue) { feature->unstableValue = dev; } \
;;;98             if (dev > unstableThreshold) { \
;;;99                 if (DEBUG_UNSTABLE) { \
;;;100                    sprintf(logBuffer[0], " INFORMATION[2_1][RADAR:%d] ==> max dev = %d = %f > %f... \r\n", radarIndex, i, dev, unstableThreshold); \
;;;101                    printf(logBuffer[0]);\
;;;102                    if(dumpStatus[radarIndex] == TRUE)\
;;;103                    {\
;;;104                        sprintf(printBuffer, "\r\n[%d]:max dev = %d = %f > %f... \r\n\r\n", radarIndex, i, dev, unstableThreshold);\
;;;105                    }\
;;;106                    for (idx = 0; idx < hlen; ++idx) { sprintf(printBuffer, "%f ", values[idx]); printf(printBuffer); } printf("\n");\
;;;107                } \
;;;108                return -1; \
;;;109            }
;;;110        
;;;111    #if LOOKUP_PEAK_INDEX
;;;112        idx = 0;
;;;113        mx = featuresLocal[radarIndex][hlen - 1].numbers[0];
;;;114        for (i = 1; i <= (REND - RSTART); ++i) {
;;;115            if (featuresLocal[hlen - 1].numbers[i] > mx) {
;;;116                mx = featuresLocal[hlen - 1].numbers[i];
;;;117                idx = i;
;;;118            }
;;;119        }
;;;120    #else
;;;121        idx = featuresLocal[radarIndex][hlen - 1].peakIndex;
0001b8  e0860086          ADD      r0,r6,r6,LSL #1
0001bc  e0800406          ADD      r0,r0,r6,LSL #8
0001c0  e59f13b4          LDR      r1,|L1.1404|
0001c4  e0810100          ADD      r0,r1,r0,LSL #2
0001c8  e2471001          SUB      r1,r7,#1
0001cc  e0812081          ADD      r2,r1,r1,LSL #1
0001d0  e0821401          ADD      r1,r2,r1,LSL #8
0001d4  e0811000          ADD      r1,r1,r0
0001d8  e5d10001          LDRB     r0,[r1,#1]
0001dc  e5d11000          LDRB     r1,[r1,#0]
0001e0  e1814400          ORR      r4,r1,r0,LSL #8
;;;122    #endif
;;;123    
;;;124        
;;;125        
;;;126        for (i = 0; i < hlen; ++i) {
0001e4  e3a05000          MOV      r5,#0
0001e8  ea00000c          B        |L1.544|
                  |L1.492|
;;;127            values[i] = featuresLocal[radarIndex][i].numbers[idx];
0001ec  e0861086          ADD      r1,r6,r6,LSL #1
0001f0  e0811406          ADD      r1,r1,r6,LSL #8
0001f4  e59f2380          LDR      r2,|L1.1404|
0001f8  e0821101          ADD      r1,r2,r1,LSL #2
0001fc  e0852085          ADD      r2,r5,r5,LSL #1
000200  e0822405          ADD      r2,r2,r5,LSL #8
000204  e0811002          ADD      r1,r1,r2
000208  e2811002          ADD      r1,r1,#2
00020c  e0810104          ADD      r0,r1,r4,LSL #2
000210  ebfffffe          BL       __aeabi_uread4
000214  e28d1040          ADD      r1,sp,#0x40
000218  e7810105          STR      r0,[r1,r5,LSL #2]
00021c  e2855001          ADD      r5,r5,#1              ;126
                  |L1.544|
000220  e1550007          CMP      r5,r7                 ;126
000224  bafffff0          BLT      |L1.492|
;;;128        }
;;;129        mx = average(values, 0, hlen);
000228  e1a02007          MOV      r2,r7
00022c  e3a01000          MOV      r1,#0
000230  e28d0040          ADD      r0,sp,#0x40
000234  ebfffffe          BL       average
000238  e58d0050          STR      r0,[sp,#0x50]
;;;130        
;;;131        sprintf(logBuffer[1], " INFORMATION[1][RADAR:%d]  =A=> mx = [%d] %f(%f) v.s. threshold->unstable = %f(%f)... \r\n", radarIndex, idx, mx, sqrt(mx), threshold->unstable, sqrt(threshold->unstable));
00023c  e5980004          LDR      r0,[r8,#4]
000240  ebfffffe          BL       __aeabi_f2d
000244  e1cd01f8          STRD     r0,r1,[sp,#0x18]
000248  ebfffffe          BL       sqrt
00024c  e1cd03f8          STRD     r0,r1,[sp,#0x38]
000250  e5980004          LDR      r0,[r8,#4]
000254  ebfffffe          BL       __aeabi_f2d
000258  e1cd03f0          STRD     r0,r1,[sp,#0x30]
00025c  e59d0050          LDR      r0,[sp,#0x50]
000260  ebfffffe          BL       __aeabi_f2d
000264  e1cd01f8          STRD     r0,r1,[sp,#0x18]
000268  ebfffffe          BL       sqrt
00026c  e1cd02f8          STRD     r0,r1,[sp,#0x28]
000270  e59d0050          LDR      r0,[sp,#0x50]
000274  ebfffffe          BL       __aeabi_f2d
000278  e1cd02f0          STRD     r0,r1,[sp,#0x20]
00027c  e1cd03d8          LDRD     r0,r1,[sp,#0x38]
000280  e1cd01f8          STRD     r0,r1,[sp,#0x18]
000284  e1cd03d0          LDRD     r0,r1,[sp,#0x30]
000288  e1cd01f0          STRD     r0,r1,[sp,#0x10]
00028c  e1cd02d8          LDRD     r0,r1,[sp,#0x28]
000290  e1cd00f8          STRD     r0,r1,[sp,#8]
000294  e1cd02d0          LDRD     r0,r1,[sp,#0x20]
000298  e1a03004          MOV      r3,r4
00029c  e1a02006          MOV      r2,r6
0002a0  e1cd00f0          STRD     r0,r1,[sp,#0]
0002a4  e59f12d4          LDR      r1,|L1.1408|
0002a8  e59f02d4          LDR      r0,|L1.1412|
0002ac  ebfffffe          BL       __2sprintf
;;;132        printf(logBuffer[1]); 
0002b0  e59f02cc          LDR      r0,|L1.1412|
0002b4  ebfffffe          BL       sysprintf
;;;133        if(dumpStatus[radarIndex] == TRUE)
0002b8  e59f02c8          LDR      r0,|L1.1416|
0002bc  e7d00006          LDRB     r0,[r0,r6]
0002c0  e3500001          CMP      r0,#1
0002c4  1a000011          BNE      |L1.784|
;;;134        {
;;;135            sprintf(printBuffer, "\r\n[%d] => [%f] v.s. [%f]... \r\n", radarIndex, sqrt(mx), sqrt(threshold->unstable));
0002c8  e5980004          LDR      r0,[r8,#4]
0002cc  ebfffffe          BL       __aeabi_f2d
0002d0  e1cd02f8          STRD     r0,r1,[sp,#0x28]
0002d4  ebfffffe          BL       sqrt
0002d8  e1cd03f8          STRD     r0,r1,[sp,#0x38]
0002dc  e59d0050          LDR      r0,[sp,#0x50]
0002e0  ebfffffe          BL       __aeabi_f2d
0002e4  e1cd02f8          STRD     r0,r1,[sp,#0x28]
0002e8  ebfffffe          BL       sqrt
0002ec  e1cd03f0          STRD     r0,r1,[sp,#0x30]
0002f0  e1cd03d8          LDRD     r0,r1,[sp,#0x38]
0002f4  e1cd00f8          STRD     r0,r1,[sp,#8]
0002f8  e1cd03d0          LDRD     r0,r1,[sp,#0x30]
0002fc  e1a02006          MOV      r2,r6
000300  e1cd00f0          STRD     r0,r1,[sp,#0]
000304  e28f1d0a          ADR      r1,|L1.1420|
000308  e59f029c          LDR      r0,|L1.1452|
00030c  ebfffffe          BL       __2sprintf
                  |L1.784|
;;;136        }
;;;137        
;;;138        if (mx <= threshold->unstable) {
000310  e5981004          LDR      r1,[r8,#4]
000314  e59d0050          LDR      r0,[sp,#0x50]
000318  ebfffffe          BL       __aeabi_cfcmple
00031c  8a000002          BHI      |L1.812|
;;;139            //printf("\r\n validateFeatureSet (mx <= threshold->unstable) return \r\n");
;;;140            return 0;
000320  e3a00000          MOV      r0,#0
                  |L1.804|
000324  e28dd054          ADD      sp,sp,#0x54
;;;141        }
;;;142    
;;;143        for (i = RSTART; i <= REND; ++i) {
;;;144            CHECKDEV(numbers[i - RSTART]);
;;;145        } 
;;;146        
;;;147        sprintf(logBuffer[2], " INFORMATION[2_2][RADAR:%d] ==> max dev = %f v.s. %f... \r\n", radarIndex, feature->unstableValue, unstableThreshold);
;;;148        printf(logBuffer[2]); 
;;;149        if(dumpStatus[radarIndex] == TRUE)
;;;150        {
;;;151            sprintf(printBuffer, "[%d]:max dev = %f v.s. %f... \r\n\r\n", radarIndex, feature->unstableValue, unstableThreshold);
;;;152        }
;;;153        //printf("max dev = %f v.s. %f\n", feature->unstableValue, unstableThreshold);
;;;154        //printf("=============  validateFeatureSet exit ================");
;;;155        return 0;    
;;;156    }
000328  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.812|
00032c  e59f0240          LDR      r0,|L1.1396|
000330  e1d050b0          LDRH     r5,[r0,#0]            ;143  ; rangeStart
000334  ea000062          B        |L1.1220|
                  |L1.824|
000338  e3a04000          MOV      r4,#0                 ;144
00033c  ea00000f          B        |L1.896|
                  |L1.832|
000340  e0861086          ADD      r1,r6,r6,LSL #1       ;144
000344  e0811406          ADD      r1,r1,r6,LSL #8       ;144
000348  e59f222c          LDR      r2,|L1.1404|
00034c  e0821101          ADD      r1,r2,r1,LSL #2       ;144
000350  e0842084          ADD      r2,r4,r4,LSL #1       ;144
000354  e0822404          ADD      r2,r2,r4,LSL #8       ;144
000358  e0811002          ADD      r1,r1,r2              ;144
00035c  e2811002          ADD      r1,r1,#2              ;144
000360  e59f220c          LDR      r2,|L1.1396|
000364  e1d220b0          LDRH     r2,[r2,#0]            ;144  ; rangeStart
000368  e0452002          SUB      r2,r5,r2              ;144
00036c  e0810102          ADD      r0,r1,r2,LSL #2       ;144
000370  ebfffffe          BL       __aeabi_uread4
000374  e28d1040          ADD      r1,sp,#0x40           ;144
000378  e7810104          STR      r0,[r1,r4,LSL #2]     ;144
00037c  e2844001          ADD      r4,r4,#1              ;144
                  |L1.896|
000380  e1540007          CMP      r4,r7                 ;144
000384  baffffed          BLT      |L1.832|
000388  e1a02007          MOV      r2,r7                 ;144
00038c  e3a01000          MOV      r1,#0                 ;144
000390  e28d0040          ADD      r0,sp,#0x40           ;144
000394  ebfffffe          BL       stddev
000398  e58d003c          STR      r0,[sp,#0x3c]         ;144
00039c  e59d1050          LDR      r1,[sp,#0x50]         ;144
0003a0  ebfffffe          BL       __aeabi_fdiv
0003a4  e1a0b000          MOV      r11,r0                ;144
0003a8  e28900f2          ADD      r0,r9,#0xf2           ;144
0003ac  ebfffffe          BL       __aeabi_uread4
0003b0  e58d003c          STR      r0,[sp,#0x3c]         ;144
0003b4  e1a01000          MOV      r1,r0                 ;144
0003b8  e1a0000b          MOV      r0,r11                ;144
0003bc  ebfffffe          BL       __aeabi_cfrcmple
0003c0  2a000002          BCS      |L1.976|
0003c4  e28910f2          ADD      r1,r9,#0xf2           ;144
0003c8  e1a0000b          MOV      r0,r11                ;144
0003cc  ebfffffe          BL       __aeabi_uwrite4
                  |L1.976|
0003d0  e1a0100a          MOV      r1,r10                ;144
0003d4  e1a0000b          MOV      r0,r11                ;144
0003d8  ebfffffe          BL       __aeabi_cfrcmple
0003dc  2a000037          BCS      |L1.1216|
0003e0  e1a0000a          MOV      r0,r10                ;144
0003e4  ebfffffe          BL       __aeabi_f2d
0003e8  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;144
0003ec  e1a0000b          MOV      r0,r11                ;144
0003f0  ebfffffe          BL       __aeabi_f2d
0003f4  e1cd03f0          STRD     r0,r1,[sp,#0x30]      ;144
0003f8  e1cd03d8          LDRD     r0,r1,[sp,#0x38]      ;144
0003fc  e1cd00f8          STRD     r0,r1,[sp,#8]         ;144
000400  e1cd03d0          LDRD     r0,r1,[sp,#0x30]      ;144
000404  e1a03005          MOV      r3,r5                 ;144
000408  e1a02006          MOV      r2,r6                 ;144
00040c  e1cd00f0          STRD     r0,r1,[sp,#0]         ;144
000410  e28f1f66          ADR      r1,|L1.1456|
000414  e59f01d4          LDR      r0,|L1.1520|
000418  ebfffffe          BL       __2sprintf
00041c  e59f01cc          LDR      r0,|L1.1520|
000420  ebfffffe          BL       sysprintf
000424  e59f015c          LDR      r0,|L1.1416|
000428  e7d00006          LDRB     r0,[r0,r6]            ;144
00042c  e3500001          CMP      r0,#1                 ;144
000430  1a00000e          BNE      |L1.1136|
000434  e1a0000a          MOV      r0,r10                ;144
000438  ebfffffe          BL       __aeabi_f2d
00043c  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;144
000440  e1a0000b          MOV      r0,r11                ;144
000444  ebfffffe          BL       __aeabi_f2d
000448  e1cd03f0          STRD     r0,r1,[sp,#0x30]      ;144
00044c  e1cd03d8          LDRD     r0,r1,[sp,#0x38]      ;144
000450  e1cd00f8          STRD     r0,r1,[sp,#8]         ;144
000454  e1cd03d0          LDRD     r0,r1,[sp,#0x30]      ;144
000458  e1a03005          MOV      r3,r5                 ;144
00045c  e1a02006          MOV      r2,r6                 ;144
000460  e1cd00f0          STRD     r0,r1,[sp,#0]         ;144
000464  e28f1f62          ADR      r1,|L1.1524|
000468  e59f013c          LDR      r0,|L1.1452|
00046c  ebfffffe          BL       __2sprintf
                  |L1.1136|
000470  e3a04000          MOV      r4,#0                 ;144
000474  ea00000b          B        |L1.1192|
                  |L1.1144|
000478  e28d1040          ADD      r1,sp,#0x40           ;144
00047c  e7910104          LDR      r0,[r1,r4,LSL #2]     ;144
000480  ebfffffe          BL       __aeabi_f2d
000484  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;144
000488  e1a02000          MOV      r2,r0                 ;144
00048c  e1a03001          MOV      r3,r1                 ;144
000490  e28f1f61          ADR      r1,|L1.1564|
000494  e59f0110          LDR      r0,|L1.1452|
000498  ebfffffe          BL       __2sprintf
00049c  e59f0108          LDR      r0,|L1.1452|
0004a0  ebfffffe          BL       sysprintf
0004a4  e2844001          ADD      r4,r4,#1              ;144
                  |L1.1192|
0004a8  e1540007          CMP      r4,r7                 ;144
0004ac  bafffff1          BLT      |L1.1144|
0004b0  e28f0e16          ADR      r0,|L1.1560|
0004b4  ebfffffe          BL       sysprintf
0004b8  e3e00000          MVN      r0,#0                 ;144
0004bc  eaffff98          B        |L1.804|
                  |L1.1216|
0004c0  e2855001          ADD      r5,r5,#1              ;143
                  |L1.1220|
0004c4  e59f00ac          LDR      r0,|L1.1400|
0004c8  e1d000b0          LDRH     r0,[r0,#0]            ;143  ; rangeEnd
0004cc  e1550000          CMP      r5,r0                 ;143
0004d0  daffff98          BLE      |L1.824|
0004d4  e1a0000a          MOV      r0,r10                ;147
0004d8  ebfffffe          BL       __aeabi_f2d
0004dc  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;147
0004e0  e28900f2          ADD      r0,r9,#0xf2           ;147
0004e4  ebfffffe          BL       __aeabi_uread4
0004e8  e58d002c          STR      r0,[sp,#0x2c]         ;147
0004ec  ebfffffe          BL       __aeabi_f2d
0004f0  e1cd03f0          STRD     r0,r1,[sp,#0x30]      ;147
0004f4  e1cd03d8          LDRD     r0,r1,[sp,#0x38]      ;147
0004f8  e1cd00f8          STRD     r0,r1,[sp,#8]         ;147
0004fc  e1cd03d0          LDRD     r0,r1,[sp,#0x30]      ;147
000500  e1a02006          MOV      r2,r6                 ;147
000504  e1cd00f0          STRD     r0,r1,[sp,#0]         ;147
000508  e28f1e11          ADR      r1,|L1.1568|
00050c  e59f0148          LDR      r0,|L1.1628|
000510  ebfffffe          BL       __2sprintf
000514  e59f0140          LDR      r0,|L1.1628|
000518  ebfffffe          BL       sysprintf
00051c  e59f0064          LDR      r0,|L1.1416|
000520  e7d00006          LDRB     r0,[r0,r6]            ;149
000524  e3500001          CMP      r0,#1                 ;149
000528  1a00000f          BNE      |L1.1388|
00052c  e1a0000a          MOV      r0,r10                ;151
000530  ebfffffe          BL       __aeabi_f2d
000534  e1cd03f8          STRD     r0,r1,[sp,#0x38]      ;151
000538  e28900f2          ADD      r0,r9,#0xf2           ;151
00053c  ebfffffe          BL       __aeabi_uread4
000540  e58d002c          STR      r0,[sp,#0x2c]         ;151
000544  ebfffffe          BL       __aeabi_f2d
000548  e1cd03f0          STRD     r0,r1,[sp,#0x30]      ;151
00054c  e1cd03d8          LDRD     r0,r1,[sp,#0x38]      ;151
000550  e1cd00f8          STRD     r0,r1,[sp,#8]         ;151
000554  e1cd03d0          LDRD     r0,r1,[sp,#0x30]      ;151
000558  e1a02006          MOV      r2,r6                 ;151
00055c  e1cd00f0          STRD     r0,r1,[sp,#0]         ;151
000560  e28f10f8          ADR      r1,|L1.1632|
000564  e59f0040          LDR      r0,|L1.1452|
000568  ebfffffe          BL       __2sprintf
                  |L1.1388|
00056c  e3a00000          MOV      r0,#0                 ;155
000570  eaffff6b          B        |L1.804|
                  |L1.1396|
                          DCD      rangeStart
                  |L1.1400|
                          DCD      rangeEnd
                  |L1.1404|
                          DCD      featuresLocal
                  |L1.1408|
                          DCD      ||.constdata||
                  |L1.1412|
                          DCD      logBuffer+0x200
                  |L1.1416|
                          DCD      dumpStatus
                  |L1.1420|
00058c  0d0a5b25          DCB      "\r\n[%d] => [%f] v.s. [%f]... \r\n",0
000590  645d203d
000594  3e205b25
000598  665d2076
00059c  2e732e20
0005a0  5b25665d
0005a4  2e2e2e20
0005a8  0d0a00  
0005ab  00                DCB      0
                  |L1.1452|
                          DCD      printBuffer
                  |L1.1456|
0005b0  20494e46          DCB      " INFORMATION[2_1][RADAR:%d] ==> max dev = %d = %f > %f."
0005b4  4f524d41
0005b8  54494f4e
0005bc  5b325f31
0005c0  5d5b5241
0005c4  4441523a
0005c8  25645d20
0005cc  3d3d3e20
0005d0  6d617820
0005d4  64657620
0005d8  3d202564
0005dc  203d2025
0005e0  66203e20
0005e4  25662e  
0005e7  2e2e200d          DCB      ".. \r\n",0
0005eb  0a00    
0005ed  00                DCB      0
0005ee  00                DCB      0
0005ef  00                DCB      0
                  |L1.1520|
                          DCD      logBuffer
                  |L1.1524|
0005f4  0d0a5b25          DCB      "\r\n[%d]:max dev = %d = %f > %f... \r\n\r"
0005f8  645d3a6d
0005fc  61782064
000600  6576203d
000604  20256420
000608  3d202566
00060c  203e2025
000610  662e2e2e
000614  200d0a0d
                  |L1.1560|
000618  0a00              DCB      "\n",0
00061a  00                DCB      0
00061b  00                DCB      0
                  |L1.1564|
00061c  25662000          DCB      "%f ",0
                  |L1.1568|
000620  20494e46          DCB      " INFORMATION[2_2][RADAR:%d] ==> max dev = %f v.s. %f..."
000624  4f524d41
000628  54494f4e
00062c  5b325f32
000630  5d5b5241
000634  4441523a
000638  25645d20
00063c  3d3d3e20
000640  6d617820
000644  64657620
000648  3d202566
00064c  20762e73
000650  2e202566
000654  2e2e2e  
000657  200d0a00          DCB      " \r\n",0
00065b  00                DCB      0
                  |L1.1628|
                          DCD      logBuffer+0x400
                  |L1.1632|
000660  5b25645d          DCB      "[%d]:max dev = %f v.s. %f... \r\n\r\n",0
000664  3a6d6178
000668  20646576
00066c  203d2025
000670  6620762e
000674  732e2025
000678  662e2e2e
00067c  200d0a0d
000680  0a00    
000682  00                DCB      0
000683  00                DCB      0
                          ENDP

                  queuePacket PROC
;;;157    
;;;158    static pm_queue_status queuePacket(const pm_packet* packet, const pm_threshold* threshold, pm_feature* feature, float unstableThreshold, int hlen, int radarIndex) 
000684  e92d43f8          PUSH     {r3-r9,lr}
;;;159    {
000688  e1a04000          MOV      r4,r0
00068c  e1a06001          MOV      r6,r1
000690  e1a05002          MOV      r5,r2
000694  e1a07003          MOV      r7,r3
000698  e1cd82d0          LDRD     r8,r9,[sp,#0x20]
;;;160        //add by sam 
;;;161        RSTART = packet->rangeStart;
00069c  e5d40015          LDRB     r0,[r4,#0x15]
0006a0  e5d41014          LDRB     r1,[r4,#0x14]
0006a4  e1810400          ORR      r0,r1,r0,LSL #8
0006a8  e51f113c          LDR      r1,|L1.1396|
0006ac  e1c100b0          STRH     r0,[r1,#0]  ; rangeStart
;;;162        REND = packet->rangeEnd;   
0006b0  e5d40017          LDRB     r0,[r4,#0x17]
0006b4  e5d41016          LDRB     r1,[r4,#0x16]
0006b8  e1810400          ORR      r0,r1,r0,LSL #8
0006bc  e51f114c          LDR      r1,|L1.1400|
0006c0  e1c100b0          STRH     r0,[r1,#0]  ; rangeEnd
;;;163        
;;;164        if ((packet->rangeStart - packet->rangeEnd) > (REND_2 - RSTART_2)) {
0006c4  e5d40015          LDRB     r0,[r4,#0x15]
0006c8  e5d41014          LDRB     r1,[r4,#0x14]
0006cc  e1810400          ORR      r0,r1,r0,LSL #8
0006d0  e5d41017          LDRB     r1,[r4,#0x17]
0006d4  e5d42016          LDRB     r2,[r4,#0x16]
0006d8  e1821401          ORR      r1,r2,r1,LSL #8
0006dc  e0400001          SUB      r0,r0,r1
0006e0  e350003b          CMP      r0,#0x3b
0006e4  da00000c          BLE      |L1.1820|
;;;165            printf("\r\n queuePacket PACKET_RANGE_MISMATCH (packet->rangeStart - packet->rangeEnd) > (REND_2 - RSTART_2) (%d, %d, %d, %d) return \r\n", packet->rangeStart, packet->rangeEnd, REND_2, RSTART_2);
0006e8  e3a00005          MOV      r0,#5
0006ec  e58d0000          STR      r0,[sp,#0]
0006f0  e5d40017          LDRB     r0,[r4,#0x17]
0006f4  e5d43016          LDRB     r3,[r4,#0x16]
0006f8  e1832400          ORR      r2,r3,r0,LSL #8
0006fc  e5d40015          LDRB     r0,[r4,#0x15]
000700  e5d43014          LDRB     r3,[r4,#0x14]
000704  e1831400          ORR      r1,r3,r0,LSL #8
000708  e3a03040          MOV      r3,#0x40
00070c  e59f07e8          LDR      r0,|L1.3836|
000710  ebfffffe          BL       sysprintf
;;;166            return PACKET_RANGE_MISMATCH;
000714  e3e00001          MVN      r0,#1
                  |L1.1816|
;;;167        }
;;;168        ////
;;;169        //if (packet->rangeStart != RSTART || packet->rangeEnd != REND) {
;;;170        //    printf("\r\n queuePacket PACKET_RANGE_MISMATCH (packet->rangeStart < RSTART_2 || packet->rangeEnd > REND_2) return \r\n");
;;;171        //    return PACKET_RANGE_MISMATCH;
;;;172        //}
;;;173        packetCount += 1;
;;;174        calculateFeature(packet, &featuresLocal[radarIndex][fidx++]);
;;;175        if (fidx < hlen) {
;;;176            return NEED_MORE_PACKETS;
;;;177        }
;;;178        fidx = 0;
;;;179        memset(feature, 0, sizeof(pm_feature));
;;;180        if (validateFeatureSet(threshold, feature, unstableThreshold, hlen, radarIndex) != 0) {
;;;181            return UNSTABLE_READINGS;
;;;182        }
;;;183        return QUEUE_READY;
;;;184    }
000718  e8bd83f8          POP      {r3-r9,pc}
                  |L1.1820|
00071c  e59f07dc          LDR      r0,|L1.3840|
000720  e5900000          LDR      r0,[r0,#0]            ;173  ; packetCount
000724  e2800001          ADD      r0,r0,#1              ;173
000728  e59f17d0          LDR      r1,|L1.3840|
00072c  e5810000          STR      r0,[r1,#0]            ;173  ; packetCount
000730  e0890089          ADD      r0,r9,r9,LSL #1       ;174
000734  e0800409          ADD      r0,r0,r9,LSL #8       ;174
000738  e51f21c4          LDR      r2,|L1.1404|
00073c  e0820100          ADD      r0,r2,r0,LSL #2       ;174
000740  e59f27bc          LDR      r2,|L1.3844|
000744  e5922000          LDR      r2,[r2,#0]            ;174  ; fidx
000748  e59f37b4          LDR      r3,|L1.3844|
00074c  e5933000          LDR      r3,[r3,#0]            ;174  ; fidx
000750  e2833001          ADD      r3,r3,#1              ;174
000754  e59fc7a8          LDR      r12,|L1.3844|
000758  e58c3000          STR      r3,[r12,#0]           ;174  ; fidx
00075c  e0823082          ADD      r3,r2,r2,LSL #1       ;174
000760  e0832402          ADD      r2,r3,r2,LSL #8       ;174
000764  e0801002          ADD      r1,r0,r2              ;174
000768  e1a00004          MOV      r0,r4                 ;174
00076c  ebfffffe          BL       calculateFeature
000770  e59f078c          LDR      r0,|L1.3844|
000774  e5900000          LDR      r0,[r0,#0]            ;175  ; fidx
000778  e1500008          CMP      r0,r8                 ;175
00077c  aa000001          BGE      |L1.1928|
000780  e3a00000          MOV      r0,#0                 ;176
000784  eaffffe3          B        |L1.1816|
                  |L1.1928|
000788  e3a00000          MOV      r0,#0                 ;178
00078c  e59f1770          LDR      r1,|L1.3844|
000790  e5810000          STR      r0,[r1,#0]            ;178  ; fidx
000794  e59f176c          LDR      r1,|L1.3848|
000798  e1a00005          MOV      r0,r5                 ;179
00079c  ebfffffe          BL       __aeabi_memclr
0007a0  e1a03008          MOV      r3,r8                 ;180
0007a4  e1a02007          MOV      r2,r7                 ;180
0007a8  e1a01005          MOV      r1,r5                 ;180
0007ac  e1a00006          MOV      r0,r6                 ;180
0007b0  e58d9000          STR      r9,[sp,#0]            ;180
0007b4  ebfffffe          BL       validateFeatureSet
0007b8  e3500000          CMP      r0,#0                 ;180
0007bc  0a000001          BEQ      |L1.1992|
0007c0  e3e00000          MVN      r0,#0                 ;181
0007c4  eaffffd3          B        |L1.1816|
                  |L1.1992|
0007c8  e3a00001          MOV      r0,#1                 ;183
0007cc  eaffffd1          B        |L1.1816|
;;;185    
                          ENDP

                  compareFloat PROC
;;;186    static int compareFloat(const void * a, const void * b) {
0007d0  e92d4070          PUSH     {r4-r6,lr}
0007d4  e1a04000          MOV      r4,r0
0007d8  e1a05001          MOV      r5,r1
;;;187        return (*(float*)a - *(float*)b);
0007dc  e5951000          LDR      r1,[r5,#0]
0007e0  e5940000          LDR      r0,[r4,#0]
0007e4  ebfffffe          BL       __aeabi_fsub
0007e8  e1a06000          MOV      r6,r0
0007ec  ebfffffe          BL       __aeabi_f2iz
;;;188    }
0007f0  e8bd8070          POP      {r4-r6,pc}
;;;189    
                          ENDP

                  aggregateFeatureSet PROC
;;;190    static void aggregateFeatureSet(pm_feature* score, int hlen, int radarIndex)
0007f4  e92d47ff          PUSH     {r0-r10,lr}
;;;191    {
0007f8  e1a07000          MOV      r7,r0
0007fc  e1a04001          MOV      r4,r1
000800  e1a08002          MOV      r8,r2
;;;192        int i, idx;
;;;193        float values[HLEN];
;;;194    
;;;195        #define SORT_START      ((AVG_BY_SORT) ? hlen / 4     : 0)
;;;196        #define SORT_END        ((AVG_BY_SORT) ? hlen / 4 * 3 : hlen)
;;;197    
;;;198        #define AVG(name) \
;;;199            for (idx = 0; idx < hlen; ++idx) { \
;;;200                if (DEBUG_FEATURE) { printf("%f ", featuresLocal[radarIndex][idx].name); } \
;;;201                values[idx] = featuresLocal[radarIndex][idx].name; \
;;;202            } \
;;;203            if (AVG_BY_SORT) { \
;;;204                qsort(values, hlen, sizeof(values), compareFloat); \
;;;205            } \
;;;206            score->name = average(values, SORT_START, SORT_END);
;;;207            // printf("avg(%f)\n", score->name);
;;;208    
;;;209        score->peakIndex = featuresLocal[radarIndex][hlen - 1].peakIndex;
000804  e0880088          ADD      r0,r8,r8,LSL #1
000808  e0800408          ADD      r0,r0,r8,LSL #8
00080c  e51f1298          LDR      r1,|L1.1404|
000810  e0810100          ADD      r0,r1,r0,LSL #2
000814  e2441001          SUB      r1,r4,#1
000818  e0812081          ADD      r2,r1,r1,LSL #1
00081c  e0821401          ADD      r1,r2,r1,LSL #8
000820  e0800001          ADD      r0,r0,r1
000824  e5d01001          LDRB     r1,[r0,#1]
000828  e5d00000          LDRB     r0,[r0,#0]
00082c  e1800401          ORR      r0,r0,r1,LSL #8
000830  e5c70000          STRB     r0,[r7,#0]
000834  e1a00420          LSR      r0,r0,#8
000838  e5c70001          STRB     r0,[r7,#1]
;;;210        for (i = RSTART; i <= REND; ++i) {
00083c  e51f02d0          LDR      r0,|L1.1396|
000840  e1d050b0          LDRH     r5,[r0,#0]  ; rangeStart
000844  ea00001f          B        |L1.2248|
                  |L1.2120|
;;;211            AVG(numbers[i - RSTART]);
000848  e3a06000          MOV      r6,#0
00084c  ea00000e          B        |L1.2188|
                  |L1.2128|
000850  e0881088          ADD      r1,r8,r8,LSL #1
000854  e0811408          ADD      r1,r1,r8,LSL #8
000858  e51f22e4          LDR      r2,|L1.1404|
00085c  e0821101          ADD      r1,r2,r1,LSL #2
000860  e0862086          ADD      r2,r6,r6,LSL #1
000864  e0822406          ADD      r2,r2,r6,LSL #8
000868  e0811002          ADD      r1,r1,r2
00086c  e2811002          ADD      r1,r1,#2
000870  e51f2304          LDR      r2,|L1.1396|
000874  e1d220b0          LDRH     r2,[r2,#0]  ; rangeStart
000878  e0452002          SUB      r2,r5,r2
00087c  e0810102          ADD      r0,r1,r2,LSL #2
000880  ebfffffe          BL       __aeabi_uread4
000884  e78d0106          STR      r0,[sp,r6,LSL #2]
000888  e2866001          ADD      r6,r6,#1
                  |L1.2188|
00088c  e1560004          CMP      r6,r4
000890  baffffee          BLT      |L1.2128|
000894  e1a02004          MOV      r2,r4
000898  e3a01000          MOV      r1,#0
00089c  e1a0000d          MOV      r0,sp
0008a0  ebfffffe          BL       average
0008a4  e1a09000          MOV      r9,r0
0008a8  e51f033c          LDR      r0,|L1.1396|
0008ac  e1d000b0          LDRH     r0,[r0,#0]  ; rangeStart
0008b0  e0450000          SUB      r0,r5,r0
0008b4  e2872002          ADD      r2,r7,#2
0008b8  e0821100          ADD      r1,r2,r0,LSL #2
0008bc  e1a00009          MOV      r0,r9
0008c0  ebfffffe          BL       __aeabi_uwrite4
0008c4  e2855001          ADD      r5,r5,#1              ;210
                  |L1.2248|
0008c8  e51f0358          LDR      r0,|L1.1400|
0008cc  e1d000b0          LDRH     r0,[r0,#0]            ;210  ; rangeEnd
0008d0  e1550000          CMP      r5,r0                 ;210
0008d4  daffffdb          BLE      |L1.2120|
;;;212        }
;;;213    }
0008d8  e8bd87ff          POP      {r0-r10,pc}
;;;214    
                          ENDP

                  findPeakPower PROC
;;;215    static float findPeakPower(const float* values, const int32_t len, const int32_t sidelobeCount)
0008dc  e92d5ff0          PUSH     {r4-r12,lr}
;;;216    {
0008e0  e1a05000          MOV      r5,r0
0008e4  e1a07001          MOV      r7,r1
0008e8  e1a08002          MOV      r8,r2
;;;217        int i, cnt;
;;;218        int mi = 0;
0008ec  e3a06000          MOV      r6,#0
;;;219        float mv = values[0];
0008f0  e595a000          LDR      r10,[r5,#0]
;;;220        for (i = 1; i < len; ++i) {
0008f4  e3a04001          MOV      r4,#1
0008f8  ea000007          B        |L1.2332|
                  |L1.2300|
;;;221            const float v = values[i];
0008fc  e795b104          LDR      r11,[r5,r4,LSL #2]
;;;222            if (v > mv) {
000900  e1a0100a          MOV      r1,r10
000904  e1a0000b          MOV      r0,r11
000908  ebfffffe          BL       __aeabi_cfrcmple
00090c  2a000001          BCS      |L1.2328|
;;;223                mi = i;
000910  e1a06004          MOV      r6,r4
;;;224                mv = v;
000914  e1a0a00b          MOV      r10,r11
                  |L1.2328|
000918  e2844001          ADD      r4,r4,#1              ;220
                  |L1.2332|
00091c  e1540007          CMP      r4,r7                 ;220
000920  bafffff5          BLT      |L1.2300|
;;;225            }
;;;226        }
;;;227    
;;;228        cnt = 0;
000924  e3a09000          MOV      r9,#0
;;;229        mv = 0;
000928  e3a0a000          MOV      r10,#0
;;;230        for (i = (mi - sidelobeCount); i <= (mi + sidelobeCount); ++i) {
00092c  e0464008          SUB      r4,r6,r8
000930  ea00000c          B        |L1.2408|
                  |L1.2356|
;;;231            if (mi < 0) { continue; }
000934  e3560000          CMP      r6,#0
000938  aa000000          BGE      |L1.2368|
00093c  ea000008          B        |L1.2404|
                  |L1.2368|
;;;232            if (mi >= len) { continue; }
000940  e1560007          CMP      r6,r7
000944  ba000000          BLT      |L1.2380|
000948  ea000005          B        |L1.2404|
                  |L1.2380|
;;;233            cnt += 1;
00094c  e2899001          ADD      r9,r9,#1
;;;234            mv += values[i];
000950  e7951104          LDR      r1,[r5,r4,LSL #2]
000954  e1a0000a          MOV      r0,r10
000958  ebfffffe          BL       __aeabi_fadd
00095c  e1a0a000          MOV      r10,r0
000960  e1a00000          MOV      r0,r0                 ;231
                  |L1.2404|
000964  e2844001          ADD      r4,r4,#1              ;230
                  |L1.2408|
000968  e0860008          ADD      r0,r6,r8              ;230
00096c  e1500004          CMP      r0,r4                 ;230
000970  aaffffef          BGE      |L1.2356|
;;;235        }
;;;236        return mv / cnt;
000974  e1a00009          MOV      r0,r9
000978  ebfffffe          BL       __aeabi_i2f
00097c  e1a0b000          MOV      r11,r0
000980  e1a0100b          MOV      r1,r11
000984  e1a0000a          MOV      r0,r10
000988  ebfffffe          BL       __aeabi_fdiv
;;;237    }
00098c  e8bd9ff0          POP      {r4-r12,pc}
;;;238    
                          ENDP

                  updateAdaptiveThreshold PROC
;;;239    static float updateAdaptiveThreshold(const pm_adaptive_threshold* threshold, const float* values, const int32_t len, const int32_t sidelobeCount)
000990  e92d4ffe          PUSH     {r1-r11,lr}
;;;240    {
000994  e1a04000          MOV      r4,r0
000998  e1a05001          MOV      r5,r1
00099c  e1a06002          MOV      r6,r2
0009a0  e1a07003          MOV      r7,r3
;;;241        float th = 0;
0009a4  e3a08000          MOV      r8,#0
;;;242        switch (threshold->mode) {
0009a8  e5d40000          LDRB     r0,[r4,#0]
0009ac  e3500000          CMP      r0,#0
0009b0  0a000002          BEQ      |L1.2496|
0009b4  e3500001          CMP      r0,#1
0009b8  1a00000d          BNE      |L1.2548|
0009bc  ea000002          B        |L1.2508|
                  |L1.2496|
;;;243            case THRESHOLD_BY_VALUE: {
0009c0  e1a00000          MOV      r0,r0
;;;244                th = threshold->baseValue;
0009c4  e5948014          LDR      r8,[r4,#0x14]
;;;245            } break;
0009c8  ea000009          B        |L1.2548|
                  |L1.2508|
;;;246            case THRESHOLD_BY_RATIO: {
0009cc  e1a00000          MOV      r0,r0
;;;247                th = threshold->baseValue * findPeakPower(values, len, sidelobeCount);
0009d0  e1a02007          MOV      r2,r7
0009d4  e1a01006          MOV      r1,r6
0009d8  e1a00005          MOV      r0,r5
0009dc  ebfffffe          BL       findPeakPower
0009e0  e1a09000          MOV      r9,r0
0009e4  e5941014          LDR      r1,[r4,#0x14]
0009e8  ebfffffe          BL       __aeabi_fmul
0009ec  e1a08000          MOV      r8,r0
;;;248            } break;
0009f0  e1a00000          MOV      r0,r0
                  |L1.2548|
0009f4  e1a00000          MOV      r0,r0                 ;245
;;;249        }
;;;250    
;;;251        if (threshold->ground != 0 && th > threshold->ground) {
0009f8  e3a01000          MOV      r1,#0
0009fc  e5940004          LDR      r0,[r4,#4]
000a00  ebfffffe          BL       __aeabi_cfcmpeq
000a04  0a00001c          BEQ      |L1.2684|
000a08  e1a00008          MOV      r0,r8
000a0c  e5941004          LDR      r1,[r4,#4]
000a10  ebfffffe          BL       __aeabi_cfrcmple
000a14  2a000018          BCS      |L1.2684|
;;;252            const float r = th / threshold->ground;
000a18  e1a00008          MOV      r0,r8
000a1c  e5941004          LDR      r1,[r4,#4]
000a20  ebfffffe          BL       __aeabi_fdiv
000a24  e58d0008          STR      r0,[sp,#8]
;;;253            th *= ((threshold->a * r * r) + (threshold->b * r) + threshold->c);
000a28  e594000c          LDR      r0,[r4,#0xc]
000a2c  e59d1008          LDR      r1,[sp,#8]
000a30  ebfffffe          BL       __aeabi_fmul
000a34  e58d0004          STR      r0,[sp,#4]
000a38  e5940008          LDR      r0,[r4,#8]
000a3c  e59d1008          LDR      r1,[sp,#8]
000a40  ebfffffe          BL       __aeabi_fmul
000a44  e58d0000          STR      r0,[sp,#0]
000a48  e59d1008          LDR      r1,[sp,#8]
000a4c  ebfffffe          BL       __aeabi_fmul
000a50  e1a0b000          MOV      r11,r0
000a54  e59d1004          LDR      r1,[sp,#4]
000a58  ebfffffe          BL       __aeabi_fadd
000a5c  e1a0a000          MOV      r10,r0
000a60  e5941010          LDR      r1,[r4,#0x10]
000a64  ebfffffe          BL       __aeabi_fadd
000a68  e1a09000          MOV      r9,r0
000a6c  e1a01008          MOV      r1,r8
000a70  ebfffffe          BL       __aeabi_fmul
000a74  e1a08000          MOV      r8,r0
;;;254        }
000a78  e1a00000          MOV      r0,r0
                  |L1.2684|
;;;255        return th;
000a7c  e1a00008          MOV      r0,r8
;;;256    }
000a80  e8bd8ffe          POP      {r1-r11,pc}
;;;257    
                          ENDP

                  pushPacket PROC
;;;258    pm_state pushPacket(const pm_packet* packet, const pm_threshold* threshold, pm_feature* feature, float unstableThreshold, int hlen, int radarIndex) 
000a84  e92d4fff          PUSH     {r0-r11,lr}
;;;259    {
000a88  e24dd00c          SUB      sp,sp,#0xc
000a8c  e1a0a000          MOV      r10,r0
000a90  e1a05001          MOV      r5,r1
000a94  e1a04002          MOV      r4,r2
000a98  e1cd84d0          LDRD     r8,r9,[sp,#0x40]
;;;260        int i;
;;;261    
;;;262        const pm_queue_status r = queuePacket(packet, threshold, feature, unstableThreshold, hlen, radarIndex);
000a9c  e1cd80f0          STRD     r8,r9,[sp,#0]
000aa0  e1a02004          MOV      r2,r4
000aa4  e1a01005          MOV      r1,r5
000aa8  e1a0000a          MOV      r0,r10
000aac  e59d3018          LDR      r3,[sp,#0x18]
000ab0  ebfffffe          BL       queuePacket
000ab4  e1a07000          MOV      r7,r0
;;;263        if (r == NEED_MORE_PACKETS) {
000ab8  e3570000          CMP      r7,#0
000abc  1a000002          BNE      |L1.2764|
;;;264            //printf("need more packets (%d)\n", packetCount);
;;;265            return RADAR_LIB_NOT_READY;
000ac0  e3e00000          MVN      r0,#0
                  |L1.2756|
000ac4  e28dd01c          ADD      sp,sp,#0x1c
;;;266        }
;;;267        if (r == PACKET_RANGE_MISMATCH) {
;;;268            //printf("\nI: range mismatch - START(%d|%d) END(%d|%d)\n", packet->rangeStart, RSTART, packet->rangeEnd, REND);
;;;269            return RADAR_LIB_ERROR;
;;;270        }
;;;271        if (r == UNSTABLE_READINGS) {
;;;272            //printf("\nI: unstable readings, let's retry [%d]\n", packetCount);        
;;;273            return RADAR_LIB_UNSTABLE;
;;;274        }
;;;275    
;;;276        aggregateFeatureSet(feature, hlen, radarIndex);
;;;277        feature->cutoffValue = updateAdaptiveThreshold(
;;;278            &threshold->cutoff, 
;;;279            feature->numbers,
;;;280            REND - RSTART + 1,
;;;281            threshold->sidelobeCount
;;;282        );
;;;283    
;;;284        feature->cutoffCount = 0;
;;;285        feature->powerCount = 0;
;;;286        for (i = 0; i < (REND - RSTART + 1); ++i) {
;;;287            if (feature->numbers[i] >= feature->cutoffValue) {
;;;288                feature->powerCount += 1;
;;;289            }
;;;290            else {
;;;291                feature->cutoffCount += 1;
;;;292            }
;;;293        }
;;;294    
;;;295        if (feature->powerCount < threshold->powerCount) {
;;;296            return RADAR_LIB_VACUUM;
;;;297        }
;;;298        return RADAR_LIB_OCCUPIED;
;;;299    }
000ac8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2764|
000acc  e3770002          CMN      r7,#2                 ;267
000ad0  1a000001          BNE      |L1.2780|
000ad4  e3e00001          MVN      r0,#1                 ;269
000ad8  eafffff9          B        |L1.2756|
                  |L1.2780|
000adc  e3770001          CMN      r7,#1                 ;271
000ae0  1a000001          BNE      |L1.2796|
000ae4  e3a00000          MOV      r0,#0                 ;273
000ae8  eafffff5          B        |L1.2756|
                  |L1.2796|
000aec  e1a02009          MOV      r2,r9                 ;276
000af0  e1a01008          MOV      r1,r8                 ;276
000af4  e1a00004          MOV      r0,r4                 ;276
000af8  ebfffffe          BL       aggregateFeatureSet
000afc  e51f058c          LDR      r0,|L1.1400|
000b00  e5953000          LDR      r3,[r5,#0]            ;277
000b04  e1d000b0          LDRH     r0,[r0,#0]            ;277  ; rangeEnd
000b08  e51f159c          LDR      r1,|L1.1396|
000b0c  e1d110b0          LDRH     r1,[r1,#0]            ;277  ; rangeStart
000b10  e0400001          SUB      r0,r0,r1              ;277
000b14  e2802001          ADD      r2,r0,#1              ;277
000b18  e2841002          ADD      r1,r4,#2              ;277
000b1c  e2850008          ADD      r0,r5,#8              ;277
000b20  ebfffffe          BL       updateAdaptiveThreshold
000b24  e1a0b000          MOV      r11,r0                ;277
000b28  e28410f6          ADD      r1,r4,#0xf6           ;277
000b2c  ebfffffe          BL       __aeabi_uwrite4
000b30  e28410fa          ADD      r1,r4,#0xfa           ;284
000b34  e3a00000          MOV      r0,#0                 ;284
000b38  ebfffffe          BL       __aeabi_uwrite4
000b3c  e28410fe          ADD      r1,r4,#0xfe           ;285
000b40  e3a00000          MOV      r0,#0                 ;285
000b44  ebfffffe          BL       __aeabi_uwrite4
000b48  e3a06000          MOV      r6,#0                 ;286
000b4c  ea000017          B        |L1.2992|
                  |L1.2896|
000b50  e28400f6          ADD      r0,r4,#0xf6           ;287
000b54  ebfffffe          BL       __aeabi_uread4
000b58  e1a0b000          MOV      r11,r0                ;287
000b5c  e2841002          ADD      r1,r4,#2              ;287
000b60  e0810106          ADD      r0,r1,r6,LSL #2       ;287
000b64  ebfffffe          BL       __aeabi_uread4
000b68  e1a0100b          MOV      r1,r11                ;287
000b6c  e58d0008          STR      r0,[sp,#8]            ;287
000b70  ebfffffe          BL       __aeabi_cfrcmple
000b74  8a000006          BHI      |L1.2964|
000b78  e28400fe          ADD      r0,r4,#0xfe           ;288
000b7c  ebfffffe          BL       __aeabi_uread4
000b80  e280b001          ADD      r11,r0,#1             ;288
000b84  e28410fe          ADD      r1,r4,#0xfe           ;288
000b88  e1a0000b          MOV      r0,r11                ;288
000b8c  ebfffffe          BL       __aeabi_uwrite4
000b90  ea000005          B        |L1.2988|
                  |L1.2964|
000b94  e28400fa          ADD      r0,r4,#0xfa           ;291
000b98  ebfffffe          BL       __aeabi_uread4
000b9c  e280b001          ADD      r11,r0,#1             ;291
000ba0  e28410fa          ADD      r1,r4,#0xfa           ;291
000ba4  e1a0000b          MOV      r0,r11                ;291
000ba8  ebfffffe          BL       __aeabi_uwrite4
                  |L1.2988|
000bac  e2866001          ADD      r6,r6,#1              ;286
                  |L1.2992|
000bb0  e51f0640          LDR      r0,|L1.1400|
000bb4  e1d000b0          LDRH     r0,[r0,#0]            ;286  ; rangeEnd
000bb8  e51f164c          LDR      r1,|L1.1396|
000bbc  e1d110b0          LDRH     r1,[r1,#0]            ;286  ; rangeStart
000bc0  e0400001          SUB      r0,r0,r1              ;286
000bc4  e2800001          ADD      r0,r0,#1              ;286
000bc8  e1500006          CMP      r0,r6                 ;286
000bcc  caffffdf          BGT      |L1.2896|
000bd0  e28400fe          ADD      r0,r4,#0xfe           ;295
000bd4  ebfffffe          BL       __aeabi_uread4
000bd8  e5951020          LDR      r1,[r5,#0x20]         ;295
000bdc  e1500001          CMP      r0,r1                 ;295
000be0  aa000001          BGE      |L1.3052|
000be4  e3a00002          MOV      r0,#2                 ;296
000be8  eaffffb5          B        |L1.2756|
                  |L1.3052|
000bec  e3a00001          MOV      r0,#1                 ;298
000bf0  eaffffb3          B        |L1.2756|
;;;300    
                          ENDP

                  initThresholds PROC
;;;301    
;;;302    static void initThresholds()
000bf4  e3a00000          MOV      r0,#0
;;;303    {
;;;304        for(int i = 0; i<2; i++)
000bf8  ea000020          B        |L1.3200|
                  |L1.3068|
;;;305        {
;;;306            globalThreshold[i].sidelobeCount = 0;
000bfc  e3a01000          MOV      r1,#0
000c00  e0802180          ADD      r2,r0,r0,LSL #3
000c04  e59f3300          LDR      r3,|L1.3852|
000c08  e7831102          STR      r1,[r3,r2,LSL #2]
;;;307            globalThreshold[i].powerCount = 1;                   
000c0c  e3a01001          MOV      r1,#1
000c10  e0802180          ADD      r2,r0,r0,LSL #3
000c14  e0832102          ADD      r2,r3,r2,LSL #2
000c18  e5821020          STR      r1,[r2,#0x20]
;;;308            globalThreshold[i].unstable = 20000.0f * 20000.0f;         
000c1c  e59f12ec          LDR      r1,|L1.3856|
000c20  e0802180          ADD      r2,r0,r0,LSL #3
000c24  e0832102          ADD      r2,r3,r2,LSL #2
000c28  e5821004          STR      r1,[r2,#4]
;;;309            globalThreshold[i].cutoff.mode = THRESHOLD_BY_VALUE; // threshold by absolute value
000c2c  e3a01000          MOV      r1,#0
000c30  e0802180          ADD      r2,r0,r0,LSL #3
000c34  e0832102          ADD      r2,r3,r2,LSL #2
000c38  e5c21008          STRB     r1,[r2,#8]
;;;310            globalThreshold[i].cutoff.ground = 0.0;              // disable adaptive threshold
000c3c  e0802180          ADD      r2,r0,r0,LSL #3
000c40  e0832102          ADD      r2,r3,r2,LSL #2
000c44  e582100c          STR      r1,[r2,#0xc]
;;;311            globalThreshold[i].cutoff.a = 0.0;                   // disable adaptive threshold
000c48  e0802180          ADD      r2,r0,r0,LSL #3
000c4c  e0832102          ADD      r2,r3,r2,LSL #2
000c50  e5821010          STR      r1,[r2,#0x10]
;;;312            globalThreshold[i].cutoff.b = 0.0;                   // disable adaptive threshold
000c54  e0802180          ADD      r2,r0,r0,LSL #3
000c58  e0832102          ADD      r2,r3,r2,LSL #2
000c5c  e5821014          STR      r1,[r2,#0x14]
;;;313            globalThreshold[i].cutoff.c = 0.0;                   // disable adaptive threshold
000c60  e0802180          ADD      r2,r0,r0,LSL #3
000c64  e0832102          ADD      r2,r3,r2,LSL #2
000c68  e5821018          STR      r1,[r2,#0x18]
;;;314            globalThreshold[i].cutoff.baseValue = 20000.0f * 20000.0f;
000c6c  e59f129c          LDR      r1,|L1.3856|
000c70  e0802180          ADD      r2,r0,r0,LSL #3
000c74  e0832102          ADD      r2,r3,r2,LSL #2
000c78  e582101c          STR      r1,[r2,#0x1c]
000c7c  e2800001          ADD      r0,r0,#1              ;304
                  |L1.3200|
000c80  e3500002          CMP      r0,#2                 ;304
000c84  baffffdc          BLT      |L1.3068|
;;;315        }
;;;316    }
000c88  e12fff1e          BX       lr
;;;317    /*-----------------------------------------*/
                          ENDP

                  RadarInitThresholds PROC
;;;320    
;;;321    void RadarInitThresholds(void)
000c8c  e92d4010          PUSH     {r4,lr}
;;;322    {
;;;323        initThresholds();
000c90  ebfffffe          BL       initThresholds
;;;324    }
000c94  e8bd8010          POP      {r4,pc}
;;;325    
                          ENDP

                  RadarPushPacket PROC
;;;326    int RadarPushPacket(char*debugStr, int radarIndex, const pm_packet* packet, pm_feature* feature, int hlen)
000c98  e92d43f0          PUSH     {r4-r9,lr}
;;;327    {
000c9c  e24dd014          SUB      sp,sp,#0x14
000ca0  e1a09000          MOV      r9,r0
000ca4  e1a05001          MOV      r5,r1
000ca8  e1a06002          MOV      r6,r2
000cac  e1a07003          MOV      r7,r3
000cb0  e59d8030          LDR      r8,[sp,#0x30]
;;;328        uint8_t* pTargetPacket = (uint8_t*)packet;
000cb4  e1a04006          MOV      r4,r6
;;;329        
;;;330        //sysprintf("--- RadarPushPacket[%d]: hlen = %d ----\r\n", radarIndex, hlen);
;;;331        
;;;332        if((pTargetPacket[0] == 0x88) && 
000cb8  e5d40000          LDRB     r0,[r4,#0]
000cbc  e3500088          CMP      r0,#0x88
000cc0  1a000014          BNE      |L1.3352|
;;;333                (pTargetPacket[1] == 0x77) && 
000cc4  e5d40001          LDRB     r0,[r4,#1]
000cc8  e3500077          CMP      r0,#0x77
000ccc  1a000011          BNE      |L1.3352|
;;;334                (pTargetPacket[2] == 0x66) && 
000cd0  e5d40002          LDRB     r0,[r4,#2]
000cd4  e3500066          CMP      r0,#0x66
000cd8  1a00000e          BNE      |L1.3352|
;;;335                (pTargetPacket[3] == 0x55) && 
000cdc  e5d40003          LDRB     r0,[r4,#3]
000ce0  e3500055          CMP      r0,#0x55
000ce4  1a00000b          BNE      |L1.3352|
;;;336                (pTargetPacket[4] == 0x44) && 
000ce8  e5d40004          LDRB     r0,[r4,#4]
000cec  e3500044          CMP      r0,#0x44
000cf0  1a000008          BNE      |L1.3352|
;;;337                (pTargetPacket[5] == 0x33) && 
000cf4  e5d40005          LDRB     r0,[r4,#5]
000cf8  e3500033          CMP      r0,#0x33
000cfc  1a000005          BNE      |L1.3352|
;;;338                (pTargetPacket[6] == 0x22) && 
000d00  e5d40006          LDRB     r0,[r4,#6]
000d04  e3500022          CMP      r0,#0x22
000d08  1a000002          BNE      |L1.3352|
;;;339                (pTargetPacket[7] == 0x30))
000d0c  e5d40007          LDRB     r0,[r4,#7]
000d10  e3500030          CMP      r0,#0x30
000d14  0a000013          BEQ      |L1.3432|
                  |L1.3352|
;;;340        {
;;;341        }
;;;342        else
;;;343        {
;;;344            sysprintf("--- RadarPushPacket Header error ----\r\n");
000d18  e28f0f7d          ADR      r0,|L1.3860|
000d1c  ebfffffe          BL       sysprintf
;;;345            sysprintf("RadarPushPacket (header: 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X  tail:0x%02X, 0x%02X)\n\r", 
000d20  e5d40935          LDRB     r0,[r4,#0x935]
000d24  e5d41934          LDRB     r1,[r4,#0x934]
000d28  e5d42005          LDRB     r2,[r4,#5]
000d2c  e5d43004          LDRB     r3,[r4,#4]
000d30  e58d0010          STR      r0,[sp,#0x10]
000d34  e58d100c          STR      r1,[sp,#0xc]
000d38  e58d2008          STR      r2,[sp,#8]
000d3c  e58d3004          STR      r3,[sp,#4]
000d40  e5d40003          LDRB     r0,[r4,#3]
000d44  e58d0000          STR      r0,[sp,#0]
000d48  e5d43002          LDRB     r3,[r4,#2]
000d4c  e5d42001          LDRB     r2,[r4,#1]
000d50  e5d41000          LDRB     r1,[r4,#0]
000d54  e59f01e0          LDR      r0,|L1.3900|
000d58  ebfffffe          BL       sysprintf
;;;346                        pTargetPacket[0], pTargetPacket[1], pTargetPacket[2], pTargetPacket[3], pTargetPacket[4], pTargetPacket[5],
;;;347                        pTargetPacket[sizeof(pm_packet)-2], pTargetPacket[sizeof(pm_packet)-1]);
;;;348            return RADAR_LIB_PACKET_ERROR;
000d5c  e3e00002          MVN      r0,#2
                  |L1.3424|
000d60  e28dd014          ADD      sp,sp,#0x14
;;;349        }
;;;350        
;;;351        if((pTargetPacket[sizeof(pm_packet)-2] == 0x55) && 
;;;352                (pTargetPacket[sizeof(pm_packet)-1] == 0xAA))
;;;353        {
;;;354        }
;;;355        else
;;;356        {
;;;357            sysprintf("--- RadarPushPacket Tail error ----\r\n");
;;;358            sysprintf("RadarPushPacket (header: 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X  tail:0x%02X, 0x%02X)\n\r", 
;;;359                        pTargetPacket[0], pTargetPacket[1], pTargetPacket[2], pTargetPacket[3], pTargetPacket[4], pTargetPacket[5],
;;;360                        pTargetPacket[sizeof(pm_packet)-2], pTargetPacket[sizeof(pm_packet)-1]);
;;;361            return RADAR_LIB_PACKET_ERROR;
;;;362        }
;;;363        
;;;364        return pushPacket(packet, &globalThreshold[radarIndex], feature, globalUnstableThreshold[radarIndex], hlen, radarIndex);     
;;;365    }
000d64  e8bd83f0          POP      {r4-r9,pc}
                  |L1.3432|
000d68  e5d40934          LDRB     r0,[r4,#0x934]        ;351
000d6c  e3500055          CMP      r0,#0x55              ;351
000d70  1a000002          BNE      |L1.3456|
000d74  e5d40935          LDRB     r0,[r4,#0x935]        ;352
000d78  e35000aa          CMP      r0,#0xaa              ;352
000d7c  0a000012          BEQ      |L1.3532|
                  |L1.3456|
000d80  e28f0f6e          ADR      r0,|L1.3904|
000d84  ebfffffe          BL       sysprintf
000d88  e5d42935          LDRB     r2,[r4,#0x935]        ;358
000d8c  e5d40934          LDRB     r0,[r4,#0x934]        ;358
000d90  e5d41005          LDRB     r1,[r4,#5]            ;358
000d94  e5d43004          LDRB     r3,[r4,#4]            ;358
000d98  e58d000c          STR      r0,[sp,#0xc]          ;358
000d9c  e58d2010          STR      r2,[sp,#0x10]         ;358
000da0  e58d1008          STR      r1,[sp,#8]            ;358
000da4  e58d3004          STR      r3,[sp,#4]            ;358
000da8  e5d40003          LDRB     r0,[r4,#3]            ;358
000dac  e58d0000          STR      r0,[sp,#0]            ;358
000db0  e5d43002          LDRB     r3,[r4,#2]            ;358
000db4  e5d42001          LDRB     r2,[r4,#1]            ;358
000db8  e5d41000          LDRB     r1,[r4,#0]            ;358
000dbc  e59f0178          LDR      r0,|L1.3900|
000dc0  ebfffffe          BL       sysprintf
000dc4  e3e00002          MVN      r0,#2                 ;361
000dc8  eaffffe4          B        |L1.3424|
                  |L1.3532|
000dcc  e59f0194          LDR      r0,|L1.3944|
000dd0  e58d5004          STR      r5,[sp,#4]            ;364
000dd4  e58d8000          STR      r8,[sp,#0]            ;364
000dd8  e7903105          LDR      r3,[r0,r5,LSL #2]     ;364
000ddc  e0850185          ADD      r0,r5,r5,LSL #3       ;364
000de0  e59f2124          LDR      r2,|L1.3852|
000de4  e0821100          ADD      r1,r2,r0,LSL #2       ;364
000de8  e1a02007          MOV      r2,r7                 ;364
000dec  e1a00006          MOV      r0,r6                 ;364
000df0  ebfffffe          BL       pushPacket
000df4  eaffffd9          B        |L1.3424|
;;;366    
                          ENDP

                  RadarSetUnstableThresholds PROC
;;;367    void RadarSetUnstableThresholds(int radarIndex, float value)
000df8  e92d41fc          PUSH     {r2-r8,lr}
;;;368    {
000dfc  e1a04000          MOV      r4,r0
000e00  e1a05001          MOV      r5,r1
;;;369        sprintf(printBuffer, "*** RadarSetUnstableThresholds[%d] : %f\n", radarIndex, value);
000e04  e1a00005          MOV      r0,r5
000e08  ebfffffe          BL       __aeabi_f2d
000e0c  e1a02004          MOV      r2,r4
000e10  e1cd00f0          STRD     r0,r1,[sp,#0]
000e14  e28f1e15          ADR      r1,|L1.3948|
000e18  e51f0874          LDR      r0,|L1.1452|
000e1c  ebfffffe          BL       __2sprintf
;;;370        printf(printBuffer); 
000e20  e51f087c          LDR      r0,|L1.1452|
000e24  ebfffffe          BL       sysprintf
;;;371        globalUnstableThreshold[radarIndex] = value;
000e28  e59f0138          LDR      r0,|L1.3944|
000e2c  e7805104          STR      r5,[r0,r4,LSL #2]
;;;372    }
000e30  e8bd81fc          POP      {r2-r8,pc}
;;;373    
                          ENDP

                  RadarSetUnstableThresholds2 PROC
;;;374    void RadarSetUnstableThresholds2(int radarIndex, float value, float value2)
000e34  e92d47ff          PUSH     {r0-r10,lr}
;;;375    {
000e38  e1a04000          MOV      r4,r0
000e3c  e1a0a001          MOV      r10,r1
000e40  e1a09002          MOV      r9,r2
;;;376        sprintf(printBuffer, "*** RadarSetUnstableThresholds2[%d] : %f * %f\n", radarIndex, value, value2);
000e44  e1a00009          MOV      r0,r9
000e48  ebfffffe          BL       __aeabi_f2d
000e4c  e1a05000          MOV      r5,r0
000e50  e1a06001          MOV      r6,r1
000e54  e1a0000a          MOV      r0,r10
000e58  ebfffffe          BL       __aeabi_f2d
000e5c  e1a02004          MOV      r2,r4
000e60  e88d0063          STM      sp,{r0,r1,r5,r6}
000e64  e28f1f4b          ADR      r1,|L1.3992|
000e68  e51f08c4          LDR      r0,|L1.1452|
000e6c  ebfffffe          BL       __2sprintf
;;;377        printf(printBuffer); 
000e70  e51f08cc          LDR      r0,|L1.1452|
000e74  ebfffffe          BL       sysprintf
;;;378        globalThreshold[radarIndex].unstable = value * value2; 
000e78  e1a01009          MOV      r1,r9
000e7c  e1a0000a          MOV      r0,r10
000e80  ebfffffe          BL       __aeabi_fmul
000e84  e0841184          ADD      r1,r4,r4,LSL #3
000e88  e59f207c          LDR      r2,|L1.3852|
000e8c  e0821101          ADD      r1,r2,r1,LSL #2
000e90  e5810004          STR      r0,[r1,#4]
;;;379    }
000e94  e8bd87ff          POP      {r0-r10,pc}
;;;380    
                          ENDP

                  RadarSetCutOffBaseValue PROC
;;;381    void RadarSetCutOffBaseValue(int radarIndex, float value, float value2)
000e98  e92d47ff          PUSH     {r0-r10,lr}
;;;382    {
000e9c  e1a04000          MOV      r4,r0
000ea0  e1a0a001          MOV      r10,r1
000ea4  e1a09002          MOV      r9,r2
;;;383        sprintf(printBuffer, "*** RadarSetCutOffBaseValue[%d] : %f * %f\n", radarIndex, value, value2);
000ea8  e1a00009          MOV      r0,r9
000eac  ebfffffe          BL       __aeabi_f2d
000eb0  e1a05000          MOV      r5,r0
000eb4  e1a06001          MOV      r6,r1
000eb8  e1a0000a          MOV      r0,r10
000ebc  ebfffffe          BL       __aeabi_f2d
000ec0  e1a02004          MOV      r2,r4
000ec4  e88d0063          STM      sp,{r0,r1,r5,r6}
000ec8  e28f10f8          ADR      r1,|L1.4040|
000ecc  e51f0928          LDR      r0,|L1.1452|
000ed0  ebfffffe          BL       __2sprintf
;;;384        printf(printBuffer); 
000ed4  e51f0930          LDR      r0,|L1.1452|
000ed8  ebfffffe          BL       sysprintf
;;;385        globalThreshold[radarIndex].cutoff.baseValue = value * value2; 
000edc  e1a01009          MOV      r1,r9
000ee0  e1a0000a          MOV      r0,r10
000ee4  ebfffffe          BL       __aeabi_fmul
000ee8  e0841184          ADD      r1,r4,r4,LSL #3
000eec  e59f2018          LDR      r2,|L1.3852|
000ef0  e0821101          ADD      r1,r2,r1,LSL #2
000ef4  e581001c          STR      r0,[r1,#0x1c]
;;;386    }
000ef8  e8bd87ff          POP      {r0-r10,pc}
                  |L1.3836|
                          DCD      ||.constdata||+0x5c
                  |L1.3840|
                          DCD      packetCount
                  |L1.3844|
                          DCD      fidx
                  |L1.3848|
                          DCD      0x00000103
                  |L1.3852|
                          DCD      globalThreshold
                  |L1.3856|
                          DCD      0x4dbebc20
                  |L1.3860|
000f14  2d2d2d20          DCB      "--- RadarPushPacket Header error ----\r\n",0
000f18  52616461
000f1c  72507573
000f20  68506163
000f24  6b657420
000f28  48656164
000f2c  65722065
000f30  72726f72
000f34  202d2d2d
000f38  2d0d0a00
                  |L1.3900|
                          DCD      ||.constdata||+0xdc
                  |L1.3904|
000f40  2d2d2d20          DCB      "--- RadarPushPacket Tail error ----\r\n",0
000f44  52616461
000f48  72507573
000f4c  68506163
000f50  6b657420
000f54  5461696c
000f58  20657272
000f5c  6f72202d
000f60  2d2d2d0d
000f64  0a00    
000f66  00                DCB      0
000f67  00                DCB      0
                  |L1.3944|
                          DCD      globalUnstableThreshold
                  |L1.3948|
000f6c  2a2a2a20          DCB      "*** RadarSetUnstableThresholds[%d] : %f\n"
000f70  52616461
000f74  72536574
000f78  556e7374
000f7c  61626c65
000f80  54687265
000f84  73686f6c
000f88  64735b25
000f8c  645d203a
000f90  2025660a
                  |L1.3988|
000f94  00                DCB      0
000f95  00                DCB      0
000f96  00                DCB      0
000f97  00                DCB      0
                  |L1.3992|
000f98  2a2a2a20          DCB      "*** RadarSetUnstableThresholds2[%d] : %f * %f\n",0
000f9c  52616461
000fa0  72536574
000fa4  556e7374
000fa8  61626c65
000fac  54687265
000fb0  73686f6c
000fb4  6473325b
000fb8  25645d20
000fbc  3a202566
000fc0  202a2025
000fc4  660a00  
000fc7  00                DCB      0
                  |L1.4040|
000fc8  2a2a2a20          DCB      "*** RadarSetCutOffBaseValue[%d] : %f * %f\n",0
000fcc  52616461
000fd0  72536574
000fd4  4375744f
000fd8  66664261
000fdc  73655661
000fe0  6c75655b
000fe4  25645d20
000fe8  3a202566
000fec  202a2025
000ff0  660a00  
000ff3  00                DCB      0
                          ENDP

                  RadarCleanLogBuff PROC
;;;387    
;;;388    void RadarCleanLogBuff(void)
000ff4  e92d4010          PUSH     {r4,lr}
;;;389    {
;;;390        for(int i = 0; i<3; i++)
000ff8  e3a04000          MOV      r4,#0
000ffc  ea000004          B        |L1.4116|
                  |L1.4096|
;;;391        {
;;;392            sprintf(logBuffer[i], ""); 
001000  e51f1a18          LDR      r1,|L1.1520|
001004  e0810484          ADD      r0,r1,r4,LSL #9
001008  e24f107c          ADR      r1,|L1.3988|
00100c  ebfffffe          BL       __2sprintf
001010  e2844001          ADD      r4,r4,#1              ;390
                  |L1.4116|
001014  e3540003          CMP      r4,#3                 ;390
001018  bafffff8          BLT      |L1.4096|
;;;393        } 
;;;394    }
00101c  e8bd8010          POP      {r4,pc}
;;;395    void RadarSaveLogBuff(void)
                          ENDP

                  RadarSaveLogBuff PROC
001020  e92d4010          PUSH     {r4,lr}
;;;396    {
;;;397        for(int i = 0; i<3; i++)
001024  e3a04000          MOV      r4,#0
001028  ea00000d          B        |L1.4196|
                  |L1.4140|
;;;398        {
;;;399            if(logBuffer[i] != NULL)
00102c  e51f0a44          LDR      r0,|L1.1520|
001030  e0900484          ADDS     r0,r0,r4,LSL #9
001034  0a000009          BEQ      |L1.4192|
;;;400            {
;;;401                if(strlen(logBuffer[i]) > 0)
001038  e51f1a50          LDR      r1,|L1.1520|
00103c  e0810484          ADD      r0,r1,r4,LSL #9
001040  ebfffffe          BL       strlen
001044  e3500000          CMP      r0,#0
001048  0a000004          BEQ      |L1.4192|
;;;402                    LoglibPrintfEx(LOG_TYPE_WARNING, logBuffer[i], FALSE);
00104c  e51f0a64          LDR      r0,|L1.1520|
001050  e0801484          ADD      r1,r0,r4,LSL #9
001054  e3a02000          MOV      r2,#0
001058  e3a00001          MOV      r0,#1
00105c  ebfffffe          BL       LoglibPrintfEx
                  |L1.4192|
001060  e2844001          ADD      r4,r4,#1              ;397
                  |L1.4196|
001064  e3540003          CMP      r4,#3                 ;397
001068  baffffef          BLT      |L1.4140|
;;;403            }
;;;404        }        
;;;405    }
00106c  e8bd8010          POP      {r4,pc}
;;;406    void RadarSetOutPutStatus(int radarindex, BOOL flag)
                          ENDP

                  RadarSetOutPutStatus PROC
001070  e51f2af0          LDR      r2,|L1.1416|
;;;407    {
;;;408        dumpStatus[radarindex] = flag;
001074  e7c21000          STRB     r1,[r2,r0]
;;;409    }
001078  e12fff1e          BX       lr
;;;410    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=10

                  printBuffer
                          %        512
                  logBuffer
                          %        1536
                  featuresLocal
                          %        2072
                  globalThreshold
                          %        72

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  20494e46          DCB      0x20,0x49,0x4e,0x46
000004  4f524d41          DCB      0x4f,0x52,0x4d,0x41
000008  54494f4e          DCB      0x54,0x49,0x4f,0x4e
00000c  5b315d5b          DCB      0x5b,0x31,0x5d,0x5b
000010  52414441          DCB      0x52,0x41,0x44,0x41
000014  523a2564          DCB      0x52,0x3a,0x25,0x64
000018  5d20203d          DCB      0x5d,0x20,0x20,0x3d
00001c  413d3e20          DCB      0x41,0x3d,0x3e,0x20
000020  6d78203d          DCB      0x6d,0x78,0x20,0x3d
000024  205b2564          DCB      0x20,0x5b,0x25,0x64
000028  5d202566          DCB      0x5d,0x20,0x25,0x66
00002c  28256629          DCB      0x28,0x25,0x66,0x29
000030  20762e73          DCB      0x20,0x76,0x2e,0x73
000034  2e207468          DCB      0x2e,0x20,0x74,0x68
000038  72657368          DCB      0x72,0x65,0x73,0x68
00003c  6f6c642d          DCB      0x6f,0x6c,0x64,0x2d
000040  3e756e73          DCB      0x3e,0x75,0x6e,0x73
000044  7461626c          DCB      0x74,0x61,0x62,0x6c
000048  65203d20          DCB      0x65,0x20,0x3d,0x20
00004c  25662825          DCB      0x25,0x66,0x28,0x25
000050  66292e2e          DCB      0x66,0x29,0x2e,0x2e
000054  2e200d0a          DCB      0x2e,0x20,0x0d,0x0a
000058  00000000          DCB      0x00,0x00,0x00,0x00
00005c  0d0a2071          DCB      0x0d,0x0a,0x20,0x71
000060  75657565          DCB      0x75,0x65,0x75,0x65
000064  5061636b          DCB      0x50,0x61,0x63,0x6b
000068  65742050          DCB      0x65,0x74,0x20,0x50
00006c  41434b45          DCB      0x41,0x43,0x4b,0x45
000070  545f5241          DCB      0x54,0x5f,0x52,0x41
000074  4e47455f          DCB      0x4e,0x47,0x45,0x5f
000078  4d49534d          DCB      0x4d,0x49,0x53,0x4d
00007c  41544348          DCB      0x41,0x54,0x43,0x48
000080  20287061          DCB      0x20,0x28,0x70,0x61
000084  636b6574          DCB      0x63,0x6b,0x65,0x74
000088  2d3e7261          DCB      0x2d,0x3e,0x72,0x61
00008c  6e676553          DCB      0x6e,0x67,0x65,0x53
000090  74617274          DCB      0x74,0x61,0x72,0x74
000094  202d2070          DCB      0x20,0x2d,0x20,0x70
000098  61636b65          DCB      0x61,0x63,0x6b,0x65
00009c  742d3e72          DCB      0x74,0x2d,0x3e,0x72
0000a0  616e6765          DCB      0x61,0x6e,0x67,0x65
0000a4  456e6429          DCB      0x45,0x6e,0x64,0x29
0000a8  203e2028          DCB      0x20,0x3e,0x20,0x28
0000ac  52454e44          DCB      0x52,0x45,0x4e,0x44
0000b0  5f32202d          DCB      0x5f,0x32,0x20,0x2d
0000b4  20525354          DCB      0x20,0x52,0x53,0x54
0000b8  4152545f          DCB      0x41,0x52,0x54,0x5f
0000bc  32292028          DCB      0x32,0x29,0x20,0x28
0000c0  25642c20          DCB      0x25,0x64,0x2c,0x20
0000c4  25642c20          DCB      0x25,0x64,0x2c,0x20
0000c8  25642c20          DCB      0x25,0x64,0x2c,0x20
0000cc  25642920          DCB      0x25,0x64,0x29,0x20
0000d0  72657475          DCB      0x72,0x65,0x74,0x75
0000d4  726e200d          DCB      0x72,0x6e,0x20,0x0d
0000d8  0a000000          DCB      0x0a,0x00,0x00,0x00
0000dc  52616461          DCB      0x52,0x61,0x64,0x61
0000e0  72507573          DCB      0x72,0x50,0x75,0x73
0000e4  68506163          DCB      0x68,0x50,0x61,0x63
0000e8  6b657420          DCB      0x6b,0x65,0x74,0x20
0000ec  28686561          DCB      0x28,0x68,0x65,0x61
0000f0  6465723a          DCB      0x64,0x65,0x72,0x3a
0000f4  20307825          DCB      0x20,0x30,0x78,0x25
0000f8  3032582c          DCB      0x30,0x32,0x58,0x2c
0000fc  20307825          DCB      0x20,0x30,0x78,0x25
000100  3032582c          DCB      0x30,0x32,0x58,0x2c
000104  20307825          DCB      0x20,0x30,0x78,0x25
000108  3032582c          DCB      0x30,0x32,0x58,0x2c
00010c  20307825          DCB      0x20,0x30,0x78,0x25
000110  3032582c          DCB      0x30,0x32,0x58,0x2c
000114  20307825          DCB      0x20,0x30,0x78,0x25
000118  3032582c          DCB      0x30,0x32,0x58,0x2c
00011c  20307825          DCB      0x20,0x30,0x78,0x25
000120  30325820          DCB      0x30,0x32,0x58,0x20
000124  20746169          DCB      0x20,0x74,0x61,0x69
000128  6c3a3078          DCB      0x6c,0x3a,0x30,0x78
00012c  25303258          DCB      0x25,0x30,0x32,0x58
000130  2c203078          DCB      0x2c,0x20,0x30,0x78
000134  25303258          DCB      0x25,0x30,0x32,0x58
000138  290a0d00          DCB      0x29,0x0a,0x0d,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  globalUnstableThreshold
000000  3e3851ec          DCFS     0x3e3851ec ; 0.18000000715255737
000004  3e3851ec          DCFS     0x3e3851ec ; 0.18000000715255737
                  packetCount
                          DCD      0x00000000
                  fidx
                          DCD      0x00000000
                  dumpStatus
000010  0000              DCB      0x00,0x00
                  rangeStart
000012  0000              DCB      0x00,0x00
                  rangeEnd
000014  0000              DCB      0x00,0x00
