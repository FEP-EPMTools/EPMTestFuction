; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\cjson.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\cjson.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\cjson.crf src\SysHal\json\cJSON.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_e
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  cJSON_GetErrorPtr PROC
;;;49     
;;;50     const char *cJSON_GetErrorPtr(void)
000000  e59f06c8          LDR      r0,|L1.1744|
;;;51     {
;;;52         return (const char*) global_ep;
000004  e5900000          LDR      r0,[r0,#0]  ; global_ep
;;;53     }
000008  e12fff1e          BX       lr
;;;54     
                          ENDP

                  cJSON_Version PROC
;;;59     
;;;60     extern const char* cJSON_Version(void)
00000c  e59f06c0          LDR      r0,|L1.1748|
;;;61     {
;;;62         static char version[15];
;;;63         //sprintf(version, "%d.%d.%d", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
;;;64     
;;;65         return version;
;;;66     }
000010  e12fff1e          BX       lr
;;;67     
                          ENDP

                  cJSON_strcasecmp PROC
;;;68     /* case insensitive strcmp */
;;;69     static int cJSON_strcasecmp(const unsigned char *s1, const unsigned char *s2)
000014  e92d4070          PUSH     {r4-r6,lr}
;;;70     {
000018  e1a04000          MOV      r4,r0
00001c  e1a05001          MOV      r5,r1
;;;71         if (!s1)
000020  e3540000          CMP      r4,#0
000024  1a000005          BNE      |L1.64|
;;;72         {
;;;73             return (s1 == s2) ? 0 : 1; /* both NULL? */
000028  e1540005          CMP      r4,r5
00002c  0a000001          BEQ      |L1.56|
000030  e3a00001          MOV      r0,#1
                  |L1.52|
;;;74         }
;;;75         if (!s2)
;;;76         {
;;;77             return 1;
;;;78         }
;;;79         for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)
;;;80         {
;;;81             if (*s1 == '\0')
;;;82             {
;;;83                 return 0;
;;;84             }
;;;85         }
;;;86     
;;;87         return tolower(*s1) - tolower(*s2);
;;;88     }
000034  e8bd8070          POP      {r4-r6,pc}
                  |L1.56|
000038  e3a00000          MOV      r0,#0                 ;73
00003c  eafffffc          B        |L1.52|
                  |L1.64|
000040  e3550000          CMP      r5,#0                 ;75
000044  1a000001          BNE      |L1.80|
000048  e3a00001          MOV      r0,#1                 ;77
00004c  eafffff8          B        |L1.52|
                  |L1.80|
000050  ea000006          B        |L1.112|
                  |L1.84|
000054  e5d40000          LDRB     r0,[r4,#0]            ;81
000058  e3500000          CMP      r0,#0                 ;81
00005c  1a000001          BNE      |L1.104|
000060  e3a00000          MOV      r0,#0                 ;83
000064  eafffff2          B        |L1.52|
                  |L1.104|
000068  e2844001          ADD      r4,r4,#1              ;79
00006c  e2855001          ADD      r5,r5,#1              ;79
                  |L1.112|
000070  e5d40000          LDRB     r0,[r4,#0]            ;79
000074  ebfffffe          BL       tolower
000078  e1a06000          MOV      r6,r0                 ;79
00007c  e5d50000          LDRB     r0,[r5,#0]            ;79
000080  ebfffffe          BL       tolower
000084  e1560000          CMP      r6,r0                 ;79
000088  0afffff1          BEQ      |L1.84|
00008c  e5d40000          LDRB     r0,[r4,#0]            ;87
000090  ebfffffe          BL       tolower
000094  e1a06000          MOV      r6,r0                 ;87
000098  e5d50000          LDRB     r0,[r5,#0]            ;87
00009c  ebfffffe          BL       tolower
0000a0  e0460000          SUB      r0,r6,r0              ;87
0000a4  eaffffe2          B        |L1.52|
;;;89     #if(1)
                          ENDP

                  cJSON_strdup PROC
;;;108    
;;;109    static unsigned char* cJSON_strdup(const unsigned char* str)
0000a8  e92d4070          PUSH     {r4-r6,lr}
;;;110    {
0000ac  e1a04000          MOV      r4,r0
;;;111        size_t len = 0;
0000b0  e3a05000          MOV      r5,#0
;;;112        unsigned char *copy = NULL;
0000b4  e3a06000          MOV      r6,#0
;;;113    
;;;114        if (str == NULL)
0000b8  e3540000          CMP      r4,#0
0000bc  1a000001          BNE      |L1.200|
;;;115        {
;;;116            return NULL;
0000c0  e3a00000          MOV      r0,#0
                  |L1.196|
;;;117        }
;;;118    
;;;119        len = strlen((const char*)str) + 1;
;;;120        if (!(copy = (unsigned char*)cJSON_malloc(len)))
;;;121        {
;;;122            return NULL;
;;;123        }
;;;124        memcpy(copy, str, len);
;;;125    
;;;126        return copy;
;;;127    }
0000c4  e8bd8070          POP      {r4-r6,pc}
                  |L1.200|
0000c8  e1a00004          MOV      r0,r4                 ;119
0000cc  ebfffffe          BL       strlen
0000d0  e2805001          ADD      r5,r0,#1              ;119
0000d4  e1a00005          MOV      r0,r5                 ;120
0000d8  e59f15f8          LDR      r1,|L1.1752|
0000dc  e5911000          LDR      r1,[r1,#0]            ;120  ; cJSON_malloc
0000e0  e12fff31          BLX      r1                    ;120
0000e4  e1b06000          MOVS     r6,r0                 ;120
0000e8  1a000001          BNE      |L1.244|
0000ec  e3a00000          MOV      r0,#0                 ;122
0000f0  eafffff3          B        |L1.196|
                  |L1.244|
0000f4  e1a02005          MOV      r2,r5                 ;124
0000f8  e1a01004          MOV      r1,r4                 ;124
0000fc  e1a00006          MOV      r0,r6                 ;124
000100  ebfffffe          BL       __aeabi_memcpy
000104  e1a00006          MOV      r0,r6                 ;126
000108  eaffffed          B        |L1.196|
;;;128    #if(0)
                          ENDP

                  cJSON_New_Item PROC
;;;143    /* Internal constructor. */
;;;144    static cJSON *cJSON_New_Item(void)
00010c  e92d4010          PUSH     {r4,lr}
;;;145    {
;;;146        cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
000110  e3a00028          MOV      r0,#0x28
000114  e59f15bc          LDR      r1,|L1.1752|
000118  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
00011c  e12fff31          BLX      r1
000120  e1a04000          MOV      r4,r0
;;;147        if (node)
000124  e3540000          CMP      r4,#0
000128  0a000002          BEQ      |L1.312|
;;;148        {
;;;149            memset(node, '\0', sizeof(cJSON));
00012c  e3a01028          MOV      r1,#0x28
000130  e1a00004          MOV      r0,r4
000134  ebfffffe          BL       __aeabi_memclr4
                  |L1.312|
;;;150        }
;;;151    
;;;152        return node;
000138  e1a00004          MOV      r0,r4
;;;153    }
00013c  e8bd8010          POP      {r4,pc}
;;;154    
                          ENDP

                  cJSON_Delete PROC
;;;155    /* Delete a cJSON structure. */
;;;156    void cJSON_Delete(cJSON *c)
000140  e92d4070          PUSH     {r4-r6,lr}
;;;157    {
000144  e1a04000          MOV      r4,r0
;;;158        cJSON *next = NULL;
000148  e3a05000          MOV      r5,#0
;;;159        while (c)
00014c  ea000021          B        |L1.472|
                  |L1.336|
;;;160        {
;;;161            next = c->next;
000150  e5945000          LDR      r5,[r4,#0]
;;;162            if (!(c->type & cJSON_IsReference) && c->child)
000154  e1d400bc          LDRH     r0,[r4,#0xc]
000158  e3100c01          TST      r0,#0x100
00015c  1a000004          BNE      |L1.372|
000160  e5940008          LDR      r0,[r4,#8]
000164  e3500000          CMP      r0,#0
000168  0a000001          BEQ      |L1.372|
;;;163            {
;;;164                cJSON_Delete(c->child);
00016c  e5940008          LDR      r0,[r4,#8]
000170  ebfffffe          BL       cJSON_Delete
                  |L1.372|
;;;165            }
;;;166            if (!(c->type & cJSON_IsReference) && c->valuestring)
000174  e1d400bc          LDRH     r0,[r4,#0xc]
000178  e3100c01          TST      r0,#0x100
00017c  1a000006          BNE      |L1.412|
000180  e5940010          LDR      r0,[r4,#0x10]
000184  e3500000          CMP      r0,#0
000188  0a000003          BEQ      |L1.412|
;;;167            {
;;;168                cJSON_free(c->valuestring);
00018c  e59f1548          LDR      r1,|L1.1756|
000190  e5940010          LDR      r0,[r4,#0x10]
000194  e5911000          LDR      r1,[r1,#0]  ; cJSON_free
000198  e12fff31          BLX      r1
                  |L1.412|
;;;169            }
;;;170            if (!(c->type & cJSON_StringIsConst) && c->string)
00019c  e1d400bc          LDRH     r0,[r4,#0xc]
0001a0  e3100c02          TST      r0,#0x200
0001a4  1a000006          BNE      |L1.452|
0001a8  e5940020          LDR      r0,[r4,#0x20]
0001ac  e3500000          CMP      r0,#0
0001b0  0a000003          BEQ      |L1.452|
;;;171            {
;;;172                cJSON_free(c->string);
0001b4  e59f1520          LDR      r1,|L1.1756|
0001b8  e5940020          LDR      r0,[r4,#0x20]
0001bc  e5911000          LDR      r1,[r1,#0]  ; cJSON_free
0001c0  e12fff31          BLX      r1
                  |L1.452|
;;;173            }
;;;174            cJSON_free(c);
0001c4  e1a00004          MOV      r0,r4
0001c8  e59f150c          LDR      r1,|L1.1756|
0001cc  e5911000          LDR      r1,[r1,#0]  ; cJSON_free
0001d0  e12fff31          BLX      r1
;;;175            c = next;
0001d4  e1a04005          MOV      r4,r5
                  |L1.472|
0001d8  e3540000          CMP      r4,#0                 ;159
0001dc  1affffdb          BNE      |L1.336|
;;;176        }
;;;177    }
0001e0  e8bd8070          POP      {r4-r6,pc}
;;;178    
                          ENDP

                  parse_number PROC
;;;179    /* Parse the input text to generate a number, and populate the result into item. */
;;;180    static const unsigned char *parse_number(cJSON * const item, const unsigned char * const input)
0001e4  e92d40f8          PUSH     {r3-r7,lr}
;;;181    {
0001e8  e1a06000          MOV      r6,r0
0001ec  e1a07001          MOV      r7,r1
;;;182        double number = 0;
0001f0  e1a00000          MOV      r0,r0
;;;183        unsigned char *after_end = NULL;
0001f4  e3a00000          MOV      r0,#0
0001f8  e58d0000          STR      r0,[sp,#0]
;;;184    
;;;185        if (input == NULL)
0001fc  e3570000          CMP      r7,#0
000200  1a000000          BNE      |L1.520|
                  |L1.516|
;;;186        {
;;;187            return NULL;
;;;188        }
;;;189        //if(strlen(input)>10)
;;;190        //{
;;;191        //    sysprintf(" >> parse_number:[%s]\n", input);
;;;192        //}
;;;193        number = strtod((const char*)input, (char**)&after_end);
;;;194        if (input == after_end)
;;;195        {
;;;196            return NULL; /* parse_error */
;;;197        }
;;;198    
;;;199        item->valuedouble = number;
;;;200    
;;;201        /* use saturation in case of overflow */
;;;202        if (number >= INT_MAX)
;;;203        {
;;;204            item->valueint = INT_MAX;
;;;205        }
;;;206        else if (number <= INT_MIN)
;;;207        {
;;;208            item->valueint = INT_MIN;
;;;209        }
;;;210        else
;;;211        {
;;;212            item->valueint = (int)number;
;;;213        }
;;;214    
;;;215        item->type = cJSON_Number;
;;;216    
;;;217        return after_end;
;;;218    }
000204  e8bd80f8          POP      {r3-r7,pc}
                  |L1.520|
000208  e1a0100d          MOV      r1,sp                 ;193
00020c  e1a00007          MOV      r0,r7                 ;193
000210  ebfffffe          BL       strtod
000214  e1a04000          MOV      r4,r0                 ;193
000218  e1a05001          MOV      r5,r1                 ;193
00021c  e59d0000          LDR      r0,[sp,#0]            ;194
000220  e1570000          CMP      r7,r0                 ;194
000224  1a000001          BNE      |L1.560|
000228  e3a00000          MOV      r0,#0                 ;196
00022c  eafffff4          B        |L1.516|
                  |L1.560|
000230  e1c641f8          STRD     r4,r5,[r6,#0x18]      ;199
000234  e59f24a4          LDR      r2,|L1.1760|
000238  e59f34a4          LDR      r3,|L1.1764|
00023c  e1a00004          MOV      r0,r4                 ;202
000240  e1a01005          MOV      r1,r5                 ;202
000244  ebfffffe          BL       __aeabi_cdrcmple
000248  8a000002          BHI      |L1.600|
00024c  e3e00102          MVN      r0,#0x80000000        ;204
000250  e5860014          STR      r0,[r6,#0x14]         ;204
000254  ea00000c          B        |L1.652|
                  |L1.600|
000258  e3a02000          MOV      r2,#0                 ;204
00025c  e59f3484          LDR      r3,|L1.1768|
000260  e1a00004          MOV      r0,r4                 ;206
000264  e1a01005          MOV      r1,r5                 ;206
000268  ebfffffe          BL       __aeabi_cdcmple
00026c  8a000002          BHI      |L1.636|
000270  e3a00102          MOV      r0,#0x80000000        ;208
000274  e5860014          STR      r0,[r6,#0x14]         ;208
000278  ea000003          B        |L1.652|
                  |L1.636|
00027c  e1a00004          MOV      r0,r4                 ;212
000280  e1a01005          MOV      r1,r5                 ;212
000284  ebfffffe          BL       __aeabi_d2iz
000288  e5860014          STR      r0,[r6,#0x14]         ;212
                  |L1.652|
00028c  e3a00008          MOV      r0,#8                 ;215
000290  e586000c          STR      r0,[r6,#0xc]          ;215
000294  e59d0000          LDR      r0,[sp,#0]            ;217
000298  eaffffd9          B        |L1.516|
;;;219    
                          ENDP

                  cJSON_SetNumberHelper PROC
;;;220    /* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
;;;221    double cJSON_SetNumberHelper(cJSON *object, double number)
00029c  e92d4070          PUSH     {r4-r6,lr}
;;;222    {
0002a0  e1a06000          MOV      r6,r0
0002a4  e1a04002          MOV      r4,r2
0002a8  e1a05003          MOV      r5,r3
0002ac  e59f242c          LDR      r2,|L1.1760|
0002b0  e59f342c          LDR      r3,|L1.1764|
;;;223        if (number >= INT_MAX)
0002b4  e1a00004          MOV      r0,r4
0002b8  e1a01005          MOV      r1,r5
0002bc  ebfffffe          BL       __aeabi_cdrcmple
0002c0  8a000002          BHI      |L1.720|
;;;224        {
;;;225            object->valueint = INT_MAX;
0002c4  e3e00102          MVN      r0,#0x80000000
0002c8  e5860014          STR      r0,[r6,#0x14]
0002cc  ea00000a          B        |L1.764|
                  |L1.720|
0002d0  e3a02000          MOV      r2,#0
0002d4  e59f340c          LDR      r3,|L1.1768|
;;;226        }
;;;227        else if (number <= INT_MIN)
0002d8  e1a00004          MOV      r0,r4
0002dc  e1a01005          MOV      r1,r5
0002e0  ebfffffe          BL       __aeabi_cdcmple
0002e4  8a000002          BHI      |L1.756|
;;;228        {
;;;229            object->valueint = INT_MIN;
0002e8  e3a00102          MOV      r0,#0x80000000
0002ec  e5860014          STR      r0,[r6,#0x14]
0002f0  ea000001          B        |L1.764|
                  |L1.756|
;;;230        }
;;;231        else
;;;232        {
;;;233            object->valueint = cJSON_Number;
0002f4  e3a00008          MOV      r0,#8
0002f8  e5860014          STR      r0,[r6,#0x14]
                  |L1.764|
;;;234        }
;;;235    
;;;236        return object->valuedouble = number;
0002fc  e1a00004          MOV      r0,r4
000300  e1a01005          MOV      r1,r5
000304  e1c641f8          STRD     r4,r5,[r6,#0x18]
;;;237    }
000308  e8bd8070          POP      {r4-r6,pc}
;;;238    
                          ENDP

                  ensure PROC
;;;247    /* realloc printbuffer if necessary to have at least "needed" bytes more */
;;;248    static unsigned char* ensure(printbuffer *p, size_t needed)
00030c  e92d41f0          PUSH     {r4-r8,lr}
;;;249    {
000310  e1a04000          MOV      r4,r0
000314  e1a05001          MOV      r5,r1
;;;250        unsigned char *newbuffer = NULL;
000318  e3a06000          MOV      r6,#0
;;;251        size_t newsize = 0;
00031c  e3a07000          MOV      r7,#0
;;;252    
;;;253        if (needed > INT_MAX)
000320  e3750106          CMN      r5,#0x80000001
000324  9a000001          BLS      |L1.816|
;;;254        {
;;;255            /* sizes bigger than INT_MAX are currently not supported */
;;;256            return NULL;
000328  e3a00000          MOV      r0,#0
                  |L1.812|
;;;257        }
;;;258    
;;;259        if (!p || !p->buffer)
;;;260        {
;;;261            return NULL;
;;;262        }
;;;263        needed += p->offset;
;;;264        if (needed <= p->length)
;;;265        {
;;;266            return p->buffer + p->offset;
;;;267        }
;;;268    
;;;269        if (p->noalloc) {
;;;270            return NULL;
;;;271        }
;;;272    
;;;273        /* calculate new buffer size */
;;;274        newsize = needed * 2;
;;;275        if (newsize > INT_MAX)
;;;276        {
;;;277            /* overflow of int, use INT_MAX if possible */
;;;278            if (needed <= INT_MAX)
;;;279            {
;;;280                newsize = INT_MAX;
;;;281            }
;;;282            else
;;;283            {
;;;284                return NULL;
;;;285            }
;;;286        }
;;;287    
;;;288        newbuffer = (unsigned char*)cJSON_malloc(newsize);
;;;289        if (!newbuffer)
;;;290        {
;;;291            cJSON_free(p->buffer);
;;;292            p->length = 0;
;;;293            p->buffer = NULL;
;;;294    
;;;295            return NULL;
;;;296        }
;;;297        if (newbuffer)
;;;298        {
;;;299            memcpy(newbuffer, p->buffer, p->length);
;;;300        }
;;;301        cJSON_free(p->buffer);
;;;302        p->length = newsize;
;;;303        p->buffer = newbuffer;
;;;304    
;;;305        return newbuffer + p->offset;
;;;306    }
00032c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.816|
000330  e3540000          CMP      r4,#0                 ;259
000334  0a000002          BEQ      |L1.836|
000338  e5940000          LDR      r0,[r4,#0]            ;259
00033c  e3500000          CMP      r0,#0                 ;259
000340  1a000001          BNE      |L1.844|
                  |L1.836|
000344  e3a00000          MOV      r0,#0                 ;261
000348  eafffff7          B        |L1.812|
                  |L1.844|
00034c  e5940008          LDR      r0,[r4,#8]            ;263
000350  e0855000          ADD      r5,r5,r0              ;263
000354  e5940004          LDR      r0,[r4,#4]            ;264
000358  e1500005          CMP      r0,r5                 ;264
00035c  3a000003          BCC      |L1.880|
000360  e5940000          LDR      r0,[r4,#0]            ;266
000364  e5941008          LDR      r1,[r4,#8]            ;266
000368  e0800001          ADD      r0,r0,r1              ;266
00036c  eaffffee          B        |L1.812|
                  |L1.880|
000370  e594000c          LDR      r0,[r4,#0xc]          ;269
000374  e3500000          CMP      r0,#0                 ;269
000378  0a000001          BEQ      |L1.900|
00037c  e3a00000          MOV      r0,#0                 ;270
000380  eaffffe9          B        |L1.812|
                  |L1.900|
000384  e1a07085          LSL      r7,r5,#1              ;274
000388  e3770106          CMN      r7,#0x80000001        ;275
00038c  9a000005          BLS      |L1.936|
000390  e3750106          CMN      r5,#0x80000001        ;278
000394  8a000001          BHI      |L1.928|
000398  e3e07102          MVN      r7,#0x80000000        ;280
00039c  ea000001          B        |L1.936|
                  |L1.928|
0003a0  e3a00000          MOV      r0,#0                 ;284
0003a4  eaffffe0          B        |L1.812|
                  |L1.936|
0003a8  e1a00007          MOV      r0,r7                 ;288
0003ac  e59f1324          LDR      r1,|L1.1752|
0003b0  e5911000          LDR      r1,[r1,#0]            ;288  ; cJSON_malloc
0003b4  e12fff31          BLX      r1                    ;288
0003b8  e1a06000          MOV      r6,r0                 ;288
0003bc  e3560000          CMP      r6,#0                 ;289
0003c0  1a000007          BNE      |L1.996|
0003c4  e59f1310          LDR      r1,|L1.1756|
0003c8  e5940000          LDR      r0,[r4,#0]            ;291
0003cc  e5911000          LDR      r1,[r1,#0]            ;291  ; cJSON_free
0003d0  e12fff31          BLX      r1                    ;291
0003d4  e3a00000          MOV      r0,#0                 ;292
0003d8  e5840004          STR      r0,[r4,#4]            ;292
0003dc  e5840000          STR      r0,[r4,#0]            ;293
0003e0  eaffffd1          B        |L1.812|
                  |L1.996|
0003e4  e3560000          CMP      r6,#0                 ;297
0003e8  0a000002          BEQ      |L1.1016|
0003ec  e1a00006          MOV      r0,r6                 ;299
0003f0  e8940006          LDM      r4,{r1,r2}            ;299
0003f4  ebfffffe          BL       __aeabi_memcpy
                  |L1.1016|
0003f8  e59f12dc          LDR      r1,|L1.1756|
0003fc  e5940000          LDR      r0,[r4,#0]            ;301
000400  e5911000          LDR      r1,[r1,#0]            ;301  ; cJSON_free
000404  e12fff31          BLX      r1                    ;301
000408  e5847004          STR      r7,[r4,#4]            ;302
00040c  e5846000          STR      r6,[r4,#0]            ;303
000410  e5940008          LDR      r0,[r4,#8]            ;305
000414  e0800006          ADD      r0,r0,r6              ;305
000418  eaffffc3          B        |L1.812|
;;;307    
                          ENDP

                  update PROC
;;;308    /* calculate the new length of the string in a printbuffer */
;;;309    static size_t update(const printbuffer *p)
00041c  e92d4070          PUSH     {r4-r6,lr}
;;;310    {
000420  e1a04000          MOV      r4,r0
;;;311        const unsigned char *str = NULL;
000424  e3a05000          MOV      r5,#0
;;;312        if (!p || !p->buffer)
000428  e3540000          CMP      r4,#0
00042c  0a000002          BEQ      |L1.1084|
000430  e5940000          LDR      r0,[r4,#0]
000434  e3500000          CMP      r0,#0
000438  1a000001          BNE      |L1.1092|
                  |L1.1084|
;;;313        {
;;;314            return 0;
00043c  e3a00000          MOV      r0,#0
                  |L1.1088|
;;;315        }
;;;316        str = p->buffer + p->offset;
;;;317    
;;;318        return p->offset + strlen((const char*)str);
;;;319    }
000440  e8bd8070          POP      {r4-r6,pc}
                  |L1.1092|
000444  e5940000          LDR      r0,[r4,#0]            ;316
000448  e5941008          LDR      r1,[r4,#8]            ;316
00044c  e0805001          ADD      r5,r0,r1              ;316
000450  e1a00005          MOV      r0,r5                 ;318
000454  ebfffffe          BL       strlen
000458  e5941008          LDR      r1,[r4,#8]            ;318
00045c  e0800001          ADD      r0,r0,r1              ;318
000460  eafffff6          B        |L1.1088|
;;;320    
                          ENDP

                  print_number PROC
;;;321    /* Render the number nicely from the given item into a string. */
;;;322    static unsigned char *print_number(const cJSON *item, printbuffer *p)
000464  e92d47fc          PUSH     {r2-r10,lr}
;;;323    {
000468  e1a0a000          MOV      r10,r0
00046c  e1a06001          MOV      r6,r1
;;;324        unsigned char *str = NULL;
000470  e3a09000          MOV      r9,#0
;;;325        double d = item->valuedouble;
000474  e1ca41d8          LDRD     r4,r5,[r10,#0x18]
000478  e3a02000          MOV      r2,#0
00047c  e1a03002          MOV      r3,r2
;;;326        /* special case for 0. */
;;;327        if (d == 0)
000480  e1a00004          MOV      r0,r4
000484  e1a01005          MOV      r1,r5
000488  ebfffffe          BL       __aeabi_cdcmpeq
00048c  1a000013          BNE      |L1.1248|
;;;328        {
;;;329            if (p)
000490  e3560000          CMP      r6,#0
000494  0a000004          BEQ      |L1.1196|
;;;330            {
;;;331                str = ensure(p, 2);
000498  e3a01002          MOV      r1,#2
00049c  e1a00006          MOV      r0,r6
0004a0  ebfffffe          BL       ensure
0004a4  e1a09000          MOV      r9,r0
0004a8  ea000004          B        |L1.1216|
                  |L1.1196|
;;;332            }
;;;333            else
;;;334            {
;;;335                str = (unsigned char*)cJSON_malloc(2);
0004ac  e3a00002          MOV      r0,#2
0004b0  e59f1220          LDR      r1,|L1.1752|
0004b4  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
0004b8  e12fff31          BLX      r1
0004bc  e1a09000          MOV      r9,r0
                  |L1.1216|
;;;336            }
;;;337            if (str)
0004c0  e3590000          CMP      r9,#0
0004c4  0a00007f          BEQ      |L1.1736|
;;;338            {
;;;339                strcpy((char*)str,"0");
0004c8  e28f0f87          ADR      r0,|L1.1772|
0004cc  e5d01000          LDRB     r1,[r0,#0]
0004d0  e5c91000          STRB     r1,[r9,#0]
0004d4  e5d00001          LDRB     r0,[r0,#1]
0004d8  e5c90001          STRB     r0,[r9,#1]
0004dc  ea000079          B        |L1.1736|
                  |L1.1248|
;;;340            }
;;;341        }
;;;342        /* value is an int */
;;;343        else if ((fabs(((double)item->valueint) - d) <= DBL_EPSILON) && (d <= INT_MAX) && (d >= INT_MIN))
0004e0  e59a0014          LDR      r0,[r10,#0x14]
0004e4  ebfffffe          BL       __aeabi_i2d
0004e8  e1a07000          MOV      r7,r0
0004ec  e1a02004          MOV      r2,r4
0004f0  e1a03005          MOV      r3,r5
0004f4  ebfffffe          BL       __aeabi_dsub
0004f8  e3c11102          BIC      r1,r1,#0x80000000
0004fc  e3a02000          MOV      r2,#0
000500  e1cd00f0          STRD     r0,r1,[sp,#0]
000504  e59f31e4          LDR      r3,|L1.1776|
000508  ebfffffe          BL       __aeabi_cdcmple
00050c  8a00001e          BHI      |L1.1420|
000510  e59f21c8          LDR      r2,|L1.1760|
000514  e59f31c8          LDR      r3,|L1.1764|
000518  e1a00004          MOV      r0,r4
00051c  e1a01005          MOV      r1,r5
000520  ebfffffe          BL       __aeabi_cdcmple
000524  8a000018          BHI      |L1.1420|
000528  e3a02000          MOV      r2,#0
00052c  e59f31b4          LDR      r3,|L1.1768|
000530  e1a00004          MOV      r0,r4
000534  e1a01005          MOV      r1,r5
000538  ebfffffe          BL       __aeabi_cdrcmple
00053c  8a000012          BHI      |L1.1420|
;;;344        {
;;;345            if (p)
000540  e3560000          CMP      r6,#0
000544  0a000004          BEQ      |L1.1372|
;;;346            {
;;;347                str = ensure(p, 21);
000548  e3a01015          MOV      r1,#0x15
00054c  e1a00006          MOV      r0,r6
000550  ebfffffe          BL       ensure
000554  e1a09000          MOV      r9,r0
000558  ea000004          B        |L1.1392|
                  |L1.1372|
;;;348            }
;;;349            else
;;;350            {
;;;351                /* 2^64+1 can be represented in 21 chars. */
;;;352                str = (unsigned char*)cJSON_malloc(21);
00055c  e3a00015          MOV      r0,#0x15
000560  e59f1170          LDR      r1,|L1.1752|
000564  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
000568  e12fff31          BLX      r1
00056c  e1a09000          MOV      r9,r0
                  |L1.1392|
;;;353            }
;;;354            if (str)
000570  e3590000          CMP      r9,#0
000574  0a000053          BEQ      |L1.1736|
;;;355            {
;;;356                sprintf((char*)str, "%d", item->valueint);
000578  e28f1f5d          ADR      r1,|L1.1780|
00057c  e1a00009          MOV      r0,r9
000580  e59a2014          LDR      r2,[r10,#0x14]
000584  ebfffffe          BL       __2sprintf
000588  ea00004e          B        |L1.1736|
                  |L1.1420|
;;;357            }
;;;358        }
;;;359        /* value is a floating point number */
;;;360        else
;;;361        {
;;;362            if (p)
00058c  e3560000          CMP      r6,#0
000590  0a000004          BEQ      |L1.1448|
;;;363            {
;;;364                /* This is a nice tradeoff. */
;;;365                str = ensure(p, 64);
000594  e3a01040          MOV      r1,#0x40
000598  e1a00006          MOV      r0,r6
00059c  ebfffffe          BL       ensure
0005a0  e1a09000          MOV      r9,r0
0005a4  ea000004          B        |L1.1468|
                  |L1.1448|
;;;366            }
;;;367            else
;;;368            {
;;;369                /* This is a nice tradeoff. */
;;;370                str = (unsigned char*)cJSON_malloc(64);
0005a8  e3a00040          MOV      r0,#0x40
0005ac  e59f1124          LDR      r1,|L1.1752|
0005b0  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
0005b4  e12fff31          BLX      r1
0005b8  e1a09000          MOV      r9,r0
                  |L1.1468|
;;;371            }
;;;372            if (str)
0005bc  e3590000          CMP      r9,#0
0005c0  0a000040          BEQ      |L1.1736|
0005c4  e3a02000          MOV      r2,#0
0005c8  e1a03002          MOV      r3,r2
;;;373            {
;;;374                /* This checks for NaN and Infinity */
;;;375                if ((d * 0) != 0)
0005cc  e1a00004          MOV      r0,r4
0005d0  e1a01005          MOV      r1,r5
0005d4  ebfffffe          BL       __aeabi_dmul
0005d8  e1a07000          MOV      r7,r0
0005dc  e3a02000          MOV      r2,#0
0005e0  e1a03002          MOV      r3,r2
0005e4  ebfffffe          BL       __aeabi_cdcmpeq
0005e8  0a000003          BEQ      |L1.1532|
;;;376                {
;;;377                    sprintf((char*)str, "null");
0005ec  e28f1f41          ADR      r1,|L1.1784|
0005f0  e1a00009          MOV      r0,r9
0005f4  ebfffffe          BL       __2sprintf
0005f8  ea000032          B        |L1.1736|
                  |L1.1532|
;;;378                }
;;;379                else if ((fabs(floor(d) - d) <= DBL_EPSILON) && (fabs(d) < 1.0e60))
0005fc  e1a00004          MOV      r0,r4
000600  e1a01005          MOV      r1,r5
000604  ebfffffe          BL       floor
000608  e1a07000          MOV      r7,r0
00060c  e1a02004          MOV      r2,r4
000610  e1a03005          MOV      r3,r5
000614  ebfffffe          BL       __aeabi_dsub
000618  e3c11102          BIC      r1,r1,#0x80000000
00061c  e3a02000          MOV      r2,#0
000620  e1cd00f0          STRD     r0,r1,[sp,#0]
000624  e59f30c4          LDR      r3,|L1.1776|
000628  ebfffffe          BL       __aeabi_cdcmple
00062c  8a00000c          BHI      |L1.1636|
000630  e3c51102          BIC      r1,r5,#0x80000000
000634  e1a07004          MOV      r7,r4
000638  e59f20c0          LDR      r2,|L1.1792|
00063c  e59f30c0          LDR      r3,|L1.1796|
000640  e1a00007          MOV      r0,r7
000644  ebfffffe          BL       __aeabi_cdcmple
000648  2a000005          BCS      |L1.1636|
;;;380                {
;;;381                    sprintf((char*)str, "%.0f", d);
00064c  e1a02004          MOV      r2,r4
000650  e1a03005          MOV      r3,r5
000654  e28f10ac          ADR      r1,|L1.1800|
000658  e1a00009          MOV      r0,r9
00065c  ebfffffe          BL       __2sprintf
000660  ea000018          B        |L1.1736|
                  |L1.1636|
000664  e3c51102          BIC      r1,r5,#0x80000000
;;;382                }
;;;383                else if ((fabs(d) < 1.0e-6) || (fabs(d) > 1.0e9))
000668  e1a07004          MOV      r7,r4
00066c  e59f209c          LDR      r2,|L1.1808|
000670  e59f309c          LDR      r3,|L1.1812|
000674  e1a00007          MOV      r0,r7
000678  ebfffffe          BL       __aeabi_cdcmple
00067c  3a000006          BCC      |L1.1692|
000680  e3c51102          BIC      r1,r5,#0x80000000
000684  e1a07004          MOV      r7,r4
000688  e3a02000          MOV      r2,#0
00068c  e59f3084          LDR      r3,|L1.1816|
000690  e1a00007          MOV      r0,r7
000694  ebfffffe          BL       __aeabi_cdrcmple
000698  2a000005          BCS      |L1.1716|
                  |L1.1692|
;;;384                {
;;;385                    sprintf((char*)str, "%e", d);
00069c  e1a02004          MOV      r2,r4
0006a0  e1a03005          MOV      r3,r5
0006a4  e28f1070          ADR      r1,|L1.1820|
0006a8  e1a00009          MOV      r0,r9
0006ac  ebfffffe          BL       __2sprintf
0006b0  ea000004          B        |L1.1736|
                  |L1.1716|
;;;386                }
;;;387                else
;;;388                {
;;;389                    sprintf((char*)str, "%f", d);
0006b4  e1a02004          MOV      r2,r4
0006b8  e1a03005          MOV      r3,r5
0006bc  e28f105c          ADR      r1,|L1.1824|
0006c0  e1a00009          MOV      r0,r9
0006c4  ebfffffe          BL       __2sprintf
                  |L1.1736|
;;;390                }
;;;391            }
;;;392        }
;;;393        return str;
0006c8  e1a00009          MOV      r0,r9
;;;394    }
0006cc  e8bd87fc          POP      {r2-r10,pc}
                  |L1.1744|
                          DCD      global_ep
                  |L1.1748|
                          DCD      version
                  |L1.1752|
                          DCD      cJSON_malloc
                  |L1.1756|
                          DCD      cJSON_free
                  |L1.1760|
                          DCD      0xffc00000
                  |L1.1764|
                          DCD      0x41dfffff
                  |L1.1768|
                          DCD      0xc1e00000
                  |L1.1772|
0006ec  3000              DCB      "0",0
0006ee  00                DCB      0
0006ef  00                DCB      0
                  |L1.1776|
                          DCD      0x3cb00000
                  |L1.1780|
0006f4  256400            DCB      "%d",0
0006f7  00                DCB      0
                  |L1.1784|
0006f8  6e756c6c          DCB      "null",0
0006fc  00      
0006fd  00                DCB      0
0006fe  00                DCB      0
0006ff  00                DCB      0
                  |L1.1792|
                          DCD      0xe4c2f344
                  |L1.1796|
                          DCD      0x4c63e9e4
                  |L1.1800|
000708  252e3066          DCB      "%.0f",0
00070c  00      
00070d  00                DCB      0
00070e  00                DCB      0
00070f  00                DCB      0
                  |L1.1808|
                          DCD      0xa0b5ed8d
                  |L1.1812|
                          DCD      0x3eb0c6f7
                  |L1.1816|
                          DCD      0x41cdcd65
                  |L1.1820|
00071c  256500            DCB      "%e",0
00071f  00                DCB      0
                  |L1.1824|
000720  256600            DCB      "%f",0
000723  00                DCB      0
                          ENDP

                  parse_hex4 PROC
;;;396    /* parse 4 digit hexadecimal number */
;;;397    static unsigned parse_hex4(const unsigned char * const input)
000724  e1a02000          MOV      r2,r0
;;;398    {
;;;399        unsigned int h = 0;
000728  e3a03000          MOV      r3,#0
;;;400        size_t i = 0;
00072c  e3a01000          MOV      r1,#0
;;;401    
;;;402        for (i = 0; i < 4; i++)
000730  e1a00000          MOV      r0,r0
000734  ea000023          B        |L1.1992|
                  |L1.1848|
;;;403        {
;;;404            /* parse digit */
;;;405            if ((input[i] >= '0') && (input[i] <= '9'))
000738  e7d20001          LDRB     r0,[r2,r1]
00073c  e3500030          CMP      r0,#0x30
000740  ba000006          BLT      |L1.1888|
000744  e7d20001          LDRB     r0,[r2,r1]
000748  e3500039          CMP      r0,#0x39
00074c  ca000003          BGT      |L1.1888|
;;;406            {
;;;407                h += (unsigned int) input[i] - '0';
000750  e7d20001          LDRB     r0,[r2,r1]
000754  e2400030          SUB      r0,r0,#0x30
000758  e0833000          ADD      r3,r3,r0
00075c  ea000015          B        |L1.1976|
                  |L1.1888|
;;;408            }
;;;409            else if ((input[i] >= 'A') && (input[i] <= 'F'))
000760  e7d20001          LDRB     r0,[r2,r1]
000764  e3500041          CMP      r0,#0x41
000768  ba000006          BLT      |L1.1928|
00076c  e7d20001          LDRB     r0,[r2,r1]
000770  e3500046          CMP      r0,#0x46
000774  ca000003          BGT      |L1.1928|
;;;410            {
;;;411                h += (unsigned int) 10 + input[i] - 'A';
000778  e7d20001          LDRB     r0,[r2,r1]
00077c  e2400037          SUB      r0,r0,#0x37
000780  e0833000          ADD      r3,r3,r0
000784  ea00000b          B        |L1.1976|
                  |L1.1928|
;;;412            }
;;;413            else if ((input[i] >= 'a') && (input[i] <= 'f'))
000788  e7d20001          LDRB     r0,[r2,r1]
00078c  e3500061          CMP      r0,#0x61
000790  ba000006          BLT      |L1.1968|
000794  e7d20001          LDRB     r0,[r2,r1]
000798  e3500066          CMP      r0,#0x66
00079c  ca000003          BGT      |L1.1968|
;;;414            {
;;;415                h += (unsigned int) 10 + input[i] - 'a';
0007a0  e7d20001          LDRB     r0,[r2,r1]
0007a4  e2400057          SUB      r0,r0,#0x57
0007a8  e0833000          ADD      r3,r3,r0
0007ac  ea000001          B        |L1.1976|
                  |L1.1968|
;;;416            }
;;;417            else /* invalid */
;;;418            {
;;;419                return 0;
0007b0  e3a00000          MOV      r0,#0
                  |L1.1972|
;;;420            }
;;;421    
;;;422            if (i < 3)
;;;423            {
;;;424                /* shift left to make place for the next nibble */
;;;425                h = h << 4;
;;;426            }
;;;427        }
;;;428    
;;;429        return h;
;;;430    }
0007b4  e12fff1e          BX       lr
                  |L1.1976|
0007b8  e3510003          CMP      r1,#3                 ;422
0007bc  2a000000          BCS      |L1.1988|
0007c0  e1a03203          LSL      r3,r3,#4              ;425
                  |L1.1988|
0007c4  e2811001          ADD      r1,r1,#1              ;402
                  |L1.1992|
0007c8  e3510004          CMP      r1,#4                 ;402
0007cc  3affffd9          BCC      |L1.1848|
0007d0  e1a00003          MOV      r0,r3                 ;429
0007d4  eafffff6          B        |L1.1972|
;;;431    
                          ENDP

                  utf16_literal_to_utf8 PROC
;;;433     * A literal can be one or two sequences of the form \uXXXX */
;;;434    static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer, const unsigned char **error_pointer)
0007d8  e92d4fff          PUSH     {r0-r11,lr}
;;;435    {
0007dc  e24dd00c          SUB      sp,sp,#0xc
0007e0  e1a09000          MOV      r9,r0
0007e4  e1a07002          MOV      r7,r2
0007e8  e1a06003          MOV      r6,r3
;;;436        /* first bytes of UTF8 encoding for a given length in bytes */
;;;437        static const unsigned char firstByteMark[5] =
;;;438        {
;;;439            0x00, /* should never happen */
;;;440            0x00, /* 0xxxxxxx */
;;;441            0xC0, /* 110xxxxx */
;;;442            0xE0, /* 1110xxxx */
;;;443            0xF0 /* 11110xxx */
;;;444        };
;;;445    
;;;446        long unsigned int codepoint = 0;
0007ec  e3a04000          MOV      r4,#0
;;;447        unsigned int first_code = 0;
0007f0  e3a08000          MOV      r8,#0
;;;448        const unsigned char *first_sequence = input_pointer;
0007f4  e1a05009          MOV      r5,r9
;;;449        unsigned char utf8_length = 0;
0007f8  e3a0b000          MOV      r11,#0
;;;450        unsigned char sequence_length = 0;
0007fc  e3a00000          MOV      r0,#0
000800  e58d0008          STR      r0,[sp,#8]
;;;451    
;;;452        /* get the first utf16 sequence */
;;;453        first_code = parse_hex4(first_sequence + 2);
000804  e2850002          ADD      r0,r5,#2
000808  ebfffffe          BL       parse_hex4
00080c  e1a08000          MOV      r8,r0
;;;454        if ((input_end - first_sequence) < 6)
000810  e59d0010          LDR      r0,[sp,#0x10]
000814  e0400005          SUB      r0,r0,r5
000818  e3500006          CMP      r0,#6
00081c  aa000001          BGE      |L1.2088|
;;;455        {
;;;456            /* input ends unexpectedly */
;;;457            *error_pointer = first_sequence;
000820  e5865000          STR      r5,[r6,#0]
;;;458            goto fail;
000824  ea000070          B        |L1.2540|
                  |L1.2088|
;;;459        }
;;;460    
;;;461        /* check that the code is valid */
;;;462        if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)) || (first_code == 0))
000828  e3580b37          CMP      r8,#0xdc00
00082c  3a000001          BCC      |L1.2104|
000830  e3580a0e          CMP      r8,#0xe000
000834  3a000001          BCC      |L1.2112|
                  |L1.2104|
000838  e3580000          CMP      r8,#0
00083c  1a000001          BNE      |L1.2120|
                  |L1.2112|
;;;463        {
;;;464            *error_pointer = first_sequence;
000840  e5865000          STR      r5,[r6,#0]
;;;465            goto fail;
000844  ea000068          B        |L1.2540|
                  |L1.2120|
;;;466        }
;;;467    
;;;468        /* UTF16 surrogate pair */
;;;469        if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
000848  e3580b36          CMP      r8,#0xd800
00084c  3a000027          BCC      |L1.2288|
000850  e3580b37          CMP      r8,#0xdc00
000854  2a000025          BCS      |L1.2288|
;;;470        {
;;;471            const unsigned char *second_sequence = first_sequence + 6;
000858  e285a006          ADD      r10,r5,#6
;;;472            unsigned int second_code = 0;
00085c  e3a00000          MOV      r0,#0
000860  e58d0004          STR      r0,[sp,#4]
;;;473            sequence_length = 12; /* \uXXXX\uXXXX */
000864  e3a0000c          MOV      r0,#0xc
000868  e58d0008          STR      r0,[sp,#8]
;;;474    
;;;475            if ((input_end - second_sequence) < 6)
00086c  e59d0010          LDR      r0,[sp,#0x10]
000870  e040000a          SUB      r0,r0,r10
000874  e3500006          CMP      r0,#6
000878  aa000001          BGE      |L1.2180|
;;;476            {
;;;477                /* input ends unexpectedly */
;;;478                *error_pointer = first_sequence;
00087c  e5865000          STR      r5,[r6,#0]
;;;479                goto fail;
000880  ea000059          B        |L1.2540|
                  |L1.2180|
;;;480            }
;;;481    
;;;482            if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
000884  e5da0000          LDRB     r0,[r10,#0]
000888  e350005c          CMP      r0,#0x5c
00088c  1a000002          BNE      |L1.2204|
000890  e5da0001          LDRB     r0,[r10,#1]
000894  e3500075          CMP      r0,#0x75
000898  0a000001          BEQ      |L1.2212|
                  |L1.2204|
;;;483            {
;;;484                /* missing second half of the surrogate pair */
;;;485                *error_pointer = first_sequence;
00089c  e5865000          STR      r5,[r6,#0]
;;;486                goto fail;
0008a0  ea000051          B        |L1.2540|
                  |L1.2212|
;;;487            }
;;;488    
;;;489            /* get the second utf16 sequence */
;;;490            second_code = parse_hex4(second_sequence + 2);
0008a4  e28a0002          ADD      r0,r10,#2
0008a8  ebfffffe          BL       parse_hex4
0008ac  e58d0004          STR      r0,[sp,#4]
;;;491            /* check that the code is valid */
;;;492            if ((second_code < 0xDC00) || (second_code > 0xDFFF))
0008b0  e59d0004          LDR      r0,[sp,#4]
0008b4  e3500b37          CMP      r0,#0xdc00
0008b8  3a000002          BCC      |L1.2248|
0008bc  e59d0004          LDR      r0,[sp,#4]
0008c0  e3500a0e          CMP      r0,#0xe000
0008c4  3a000001          BCC      |L1.2256|
                  |L1.2248|
;;;493            {
;;;494                /* invalid second half of the surrogate pair */
;;;495                *error_pointer = first_sequence;
0008c8  e5865000          STR      r5,[r6,#0]
;;;496                goto fail;
0008cc  ea000046          B        |L1.2540|
                  |L1.2256|
;;;497            }
;;;498    
;;;499    
;;;500            /* calculate the unicode codepoint from the surrogate pair */
;;;501            codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
0008d0  e59d0004          LDR      r0,[sp,#4]
0008d4  e1a00b00          LSL      r0,r0,#22
0008d8  e1a00b20          LSR      r0,r0,#22
0008dc  e1a01b08          LSL      r1,r8,#22
0008e0  e1a01b21          LSR      r1,r1,#22
0008e4  e1800501          ORR      r0,r0,r1,LSL #10
0008e8  e2804801          ADD      r4,r0,#0x10000
;;;502        }
0008ec  ea000002          B        |L1.2300|
                  |L1.2288|
;;;503        else
;;;504        {
;;;505            sequence_length = 6; /* \uXXXX */
0008f0  e3a00006          MOV      r0,#6
0008f4  e58d0008          STR      r0,[sp,#8]
;;;506            codepoint = first_code;
0008f8  e1a04008          MOV      r4,r8
                  |L1.2300|
;;;507        }
;;;508    
;;;509        /* encode as UTF-8
;;;510         * takes at maximum 4 bytes to encode:
;;;511         * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
;;;512        if (codepoint < 0x80)
0008fc  e3540080          CMP      r4,#0x80
000900  2a000001          BCS      |L1.2316|
;;;513        {
;;;514            /* normal ascii, encoding 0xxxxxxx */
;;;515            utf8_length = 1;
000904  e3a0b001          MOV      r11,#1
000908  ea00000d          B        |L1.2372|
                  |L1.2316|
;;;516        }
;;;517        else if (codepoint < 0x800)
00090c  e3540b02          CMP      r4,#0x800
000910  2a000001          BCS      |L1.2332|
;;;518        {
;;;519            /* two bytes, encoding 110xxxxx 10xxxxxx */
;;;520            utf8_length = 2;
000914  e3a0b002          MOV      r11,#2
000918  ea000009          B        |L1.2372|
                  |L1.2332|
;;;521        }
;;;522        else if (codepoint < 0x10000)
00091c  e3540801          CMP      r4,#0x10000
000920  2a000001          BCS      |L1.2348|
;;;523        {
;;;524            /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
;;;525            utf8_length = 3;
000924  e3a0b003          MOV      r11,#3
000928  ea000005          B        |L1.2372|
                  |L1.2348|
;;;526        }
;;;527        else if (codepoint <= 0x10FFFF)
00092c  e3540811          CMP      r4,#0x110000
000930  2a000001          BCS      |L1.2364|
;;;528        {
;;;529            /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
;;;530            utf8_length = 4;
000934  e3a0b004          MOV      r11,#4
000938  ea000001          B        |L1.2372|
                  |L1.2364|
;;;531        }
;;;532        else
;;;533        {
;;;534            /* invalid unicode codepoint */
;;;535            *error_pointer = first_sequence;
00093c  e5865000          STR      r5,[r6,#0]
;;;536            goto fail;
000940  ea000029          B        |L1.2540|
                  |L1.2372|
;;;537        }
;;;538    
;;;539        /* encode as utf8 */
;;;540        switch (utf8_length)
000944  e35b0001          CMP      r11,#1
000948  0a000017          BEQ      |L1.2476|
00094c  e35b0002          CMP      r11,#2
000950  0a00000f          BEQ      |L1.2452|
000954  e35b0003          CMP      r11,#3
000958  0a000007          BEQ      |L1.2428|
00095c  e35b0004          CMP      r11,#4
000960  1a000017          BNE      |L1.2500|
;;;541        {
;;;542            case 4:
;;;543                /* 10xxxxxx */
;;;544                (*output_pointer)[3] = (unsigned char)((codepoint | 0x80) & 0xBF);
000964  e20400bf          AND      r0,r4,#0xbf
000968  e3800080          ORR      r0,r0,#0x80
00096c  e5971000          LDR      r1,[r7,#0]
000970  e5c10003          STRB     r0,[r1,#3]
;;;545                codepoint >>= 6;
000974  e1a04324          LSR      r4,r4,#6
;;;546            case 3:
000978  e1a00000          MOV      r0,r0
                  |L1.2428|
;;;547                /* 10xxxxxx */
;;;548                (*output_pointer)[2] = (unsigned char)((codepoint | 0x80) & 0xBF);
00097c  e20400bf          AND      r0,r4,#0xbf
000980  e3800080          ORR      r0,r0,#0x80
000984  e5971000          LDR      r1,[r7,#0]
000988  e5c10002          STRB     r0,[r1,#2]
;;;549                codepoint >>= 6;
00098c  e1a04324          LSR      r4,r4,#6
;;;550            case 2:
000990  e1a00000          MOV      r0,r0
                  |L1.2452|
;;;551                (*output_pointer)[1] = (unsigned char)((codepoint | 0x80) & 0xBF);
000994  e20400bf          AND      r0,r4,#0xbf
000998  e3800080          ORR      r0,r0,#0x80
00099c  e5971000          LDR      r1,[r7,#0]
0009a0  e5c10001          STRB     r0,[r1,#1]
;;;552                codepoint >>= 6;
0009a4  e1a04324          LSR      r4,r4,#6
;;;553            case 1:
0009a8  e1a00000          MOV      r0,r0
                  |L1.2476|
;;;554                /* depending on the length in bytes this determines the
;;;555                   encoding of the first UTF8 byte */
;;;556                (*output_pointer)[0] = (unsigned char)((codepoint | firstByteMark[utf8_length]) & 0xFF);
0009ac  e59f0604          LDR      r0,|L1.4024|
0009b0  e7d0000b          LDRB     r0,[r0,r11]
0009b4  e1800004          ORR      r0,r0,r4
0009b8  e5971000          LDR      r1,[r7,#0]
0009bc  e5c10000          STRB     r0,[r1,#0]
;;;557                break;
0009c0  ea000002          B        |L1.2512|
                  |L1.2500|
;;;558            default:
0009c4  e1a00000          MOV      r0,r0
;;;559                *error_pointer = first_sequence;
0009c8  e5865000          STR      r5,[r6,#0]
;;;560                goto fail;
0009cc  ea000006          B        |L1.2540|
                  |L1.2512|
0009d0  e1a00000          MOV      r0,r0                 ;557
;;;561        }
;;;562        *output_pointer += utf8_length;
0009d4  e5970000          LDR      r0,[r7,#0]
0009d8  e080000b          ADD      r0,r0,r11
0009dc  e5870000          STR      r0,[r7,#0]
;;;563    
;;;564        return sequence_length;
0009e0  e59d0008          LDR      r0,[sp,#8]
                  |L1.2532|
0009e4  e28dd01c          ADD      sp,sp,#0x1c
;;;565    
;;;566    fail:
;;;567        return 0;
;;;568    }
0009e8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2540|
0009ec  e1a00000          MOV      r0,r0                 ;566
0009f0  e3a00000          MOV      r0,#0                 ;567
0009f4  eafffffa          B        |L1.2532|
;;;569    
                          ENDP

                  parse_string PROC
;;;570    /* Parse the input text into an unescaped cinput, and populate item. */
;;;571    static const unsigned char *parse_string(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer)
0009f8  e92d4ff8          PUSH     {r3-r11,lr}
;;;572    {
0009fc  e1a09000          MOV      r9,r0
000a00  e1a06001          MOV      r6,r1
000a04  e1a08002          MOV      r8,r2
;;;573        const unsigned char *input_pointer = input + 1;
000a08  e2865001          ADD      r5,r6,#1
;;;574        const unsigned char *input_end = input + 1;
000a0c  e2864001          ADD      r4,r6,#1
;;;575        unsigned char *output_pointer = NULL;
000a10  e3a00000          MOV      r0,#0
000a14  e58d0000          STR      r0,[sp,#0]
;;;576        unsigned char *output = NULL;
000a18  e3a07000          MOV      r7,#0
;;;577    
;;;578        /* not a string */
;;;579        if (*input != '\"')
000a1c  e5d60000          LDRB     r0,[r6,#0]
000a20  e3500022          CMP      r0,#0x22
000a24  0a000001          BEQ      |L1.2608|
;;;580        {
;;;581            *error_pointer = input;
000a28  e5886000          STR      r6,[r8,#0]
;;;582            goto fail;
000a2c  ea000090          B        |L1.3188|
                  |L1.2608|
;;;583        }
;;;584    
;;;585        {
;;;586            /* calculate approximate size of the output (overestimate) */
;;;587            size_t allocation_length = 0;
000a30  e3a0b000          MOV      r11,#0
;;;588            size_t skipped_bytes = 0;
000a34  e3a0a000          MOV      r10,#0
;;;589            while ((*input_end != '\"') && (*input_end != '\0'))
000a38  ea000009          B        |L1.2660|
                  |L1.2620|
;;;590            {
;;;591                /* is escape sequence */
;;;592                if (input_end[0] == '\\')
000a3c  e5d40000          LDRB     r0,[r4,#0]
000a40  e350005c          CMP      r0,#0x5c
000a44  1a000005          BNE      |L1.2656|
;;;593                {
;;;594                    if (input_end[1] == '\0')
000a48  e5d40001          LDRB     r0,[r4,#1]
000a4c  e3500000          CMP      r0,#0
000a50  1a000000          BNE      |L1.2648|
;;;595                    {
;;;596                        /* prevent buffer overflow when last input character is a backslash */
;;;597                        goto fail;
000a54  ea000086          B        |L1.3188|
                  |L1.2648|
;;;598                    }
;;;599                    skipped_bytes++;
000a58  e28aa001          ADD      r10,r10,#1
;;;600                    input_end++;
000a5c  e2844001          ADD      r4,r4,#1
                  |L1.2656|
;;;601                }
;;;602                input_end++;
000a60  e2844001          ADD      r4,r4,#1
                  |L1.2660|
000a64  e5d40000          LDRB     r0,[r4,#0]            ;589
000a68  e3500022          CMP      r0,#0x22              ;589
000a6c  0a000002          BEQ      |L1.2684|
000a70  e5d40000          LDRB     r0,[r4,#0]            ;589
000a74  e3500000          CMP      r0,#0                 ;589
000a78  1affffef          BNE      |L1.2620|
                  |L1.2684|
;;;603            }
;;;604            if (*input_end == '\0')
000a7c  e5d40000          LDRB     r0,[r4,#0]
000a80  e3500000          CMP      r0,#0
000a84  1a000000          BNE      |L1.2700|
;;;605            {
;;;606                goto fail; /* string ended unexpectedly */
000a88  ea000079          B        |L1.3188|
                  |L1.2700|
;;;607            }
;;;608    
;;;609            /* This is at most how much we need for the output */
;;;610            allocation_length = (size_t) (input_end - input) - skipped_bytes;
000a8c  e0440006          SUB      r0,r4,r6
000a90  e040b00a          SUB      r11,r0,r10
;;;611            output = (unsigned char*)cJSON_malloc(allocation_length + sizeof('\0'));
000a94  e28b0004          ADD      r0,r11,#4
000a98  e51f13c8          LDR      r1,|L1.1752|
000a9c  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
000aa0  e12fff31          BLX      r1
000aa4  e1a07000          MOV      r7,r0
;;;612            if (output == NULL)
000aa8  e3570000          CMP      r7,#0
000aac  1a000000          BNE      |L1.2740|
;;;613            {
;;;614                goto fail; /* allocation failure */
000ab0  ea00006f          B        |L1.3188|
                  |L1.2740|
;;;615            }
;;;616        }
;;;617    
;;;618        output_pointer = output;
000ab4  e58d7000          STR      r7,[sp,#0]
;;;619        /* loop through the string literal */
;;;620        while (input_pointer < input_end)
000ab8  ea000063          B        |L1.3148|
                  |L1.2748|
;;;621        {
;;;622            if (*input_pointer != '\\')
000abc  e5d50000          LDRB     r0,[r5,#0]
000ac0  e350005c          CMP      r0,#0x5c
000ac4  0a000006          BEQ      |L1.2788|
;;;623            {
;;;624                *output_pointer++ = *input_pointer++;
000ac8  e4d50001          LDRB     r0,[r5],#1
000acc  e59d1000          LDR      r1,[sp,#0]
000ad0  e5c10000          STRB     r0,[r1,#0]
000ad4  e59d0000          LDR      r0,[sp,#0]
000ad8  e2800001          ADD      r0,r0,#1
000adc  e58d0000          STR      r0,[sp,#0]
000ae0  ea000059          B        |L1.3148|
                  |L1.2788|
;;;625            }
;;;626            /* escape sequence */
;;;627            else
;;;628            {
;;;629                unsigned char sequence_length = 2;
000ae4  e3a0a002          MOV      r10,#2
;;;630                switch (input_pointer[1])
000ae8  e5d50001          LDRB     r0,[r5,#1]
000aec  e3500066          CMP      r0,#0x66
000af0  0a00001a          BEQ      |L1.2912|
000af4  ca000008          BGT      |L1.2844|
000af8  e3500022          CMP      r0,#0x22
000afc  0a000037          BEQ      |L1.3040|
000b00  e350002f          CMP      r0,#0x2f
000b04  0a000038          BEQ      |L1.3052|
000b08  e350005c          CMP      r0,#0x5c
000b0c  0a000035          BEQ      |L1.3048|
000b10  e3500062          CMP      r0,#0x62
000b14  1a000046          BNE      |L1.3124|
000b18  ea000008          B        |L1.2880|
                  |L1.2844|
000b1c  e350006e          CMP      r0,#0x6e
000b20  0a000016          BEQ      |L1.2944|
000b24  e3500072          CMP      r0,#0x72
000b28  0a00001c          BEQ      |L1.2976|
000b2c  e3500074          CMP      r0,#0x74
000b30  0a000022          BEQ      |L1.3008|
000b34  e3500075          CMP      r0,#0x75
000b38  1a00003d          BNE      |L1.3124|
000b3c  ea000031          B        |L1.3080|
                  |L1.2880|
;;;631                {
;;;632                    case 'b':
000b40  e1a00000          MOV      r0,r0
;;;633                        *output_pointer++ = '\b';
000b44  e3a00008          MOV      r0,#8
000b48  e59d1000          LDR      r1,[sp,#0]
000b4c  e5c10000          STRB     r0,[r1,#0]
000b50  e59d0000          LDR      r0,[sp,#0]
000b54  e2800001          ADD      r0,r0,#1
000b58  e58d0000          STR      r0,[sp,#0]
;;;634                        break;
000b5c  ea000037          B        |L1.3136|
                  |L1.2912|
;;;635                    case 'f':
000b60  e1a00000          MOV      r0,r0
;;;636                        *output_pointer++ = '\f';
000b64  e3a0000c          MOV      r0,#0xc
000b68  e59d1000          LDR      r1,[sp,#0]
000b6c  e5c10000          STRB     r0,[r1,#0]
000b70  e59d0000          LDR      r0,[sp,#0]
000b74  e2800001          ADD      r0,r0,#1
000b78  e58d0000          STR      r0,[sp,#0]
;;;637                        break;
000b7c  ea00002f          B        |L1.3136|
                  |L1.2944|
;;;638                    case 'n':
000b80  e1a00000          MOV      r0,r0
;;;639                        *output_pointer++ = '\n';
000b84  e3a0000a          MOV      r0,#0xa
000b88  e59d1000          LDR      r1,[sp,#0]
000b8c  e5c10000          STRB     r0,[r1,#0]
000b90  e59d0000          LDR      r0,[sp,#0]
000b94  e2800001          ADD      r0,r0,#1
000b98  e58d0000          STR      r0,[sp,#0]
;;;640                        break;
000b9c  ea000027          B        |L1.3136|
                  |L1.2976|
;;;641                    case 'r':
000ba0  e1a00000          MOV      r0,r0
;;;642                        *output_pointer++ = '\r';
000ba4  e3a0000d          MOV      r0,#0xd
000ba8  e59d1000          LDR      r1,[sp,#0]
000bac  e5c10000          STRB     r0,[r1,#0]
000bb0  e59d0000          LDR      r0,[sp,#0]
000bb4  e2800001          ADD      r0,r0,#1
000bb8  e58d0000          STR      r0,[sp,#0]
;;;643                        break;
000bbc  ea00001f          B        |L1.3136|
                  |L1.3008|
;;;644                    case 't':
000bc0  e1a00000          MOV      r0,r0
;;;645                        *output_pointer++ = '\t';
000bc4  e3a00009          MOV      r0,#9
000bc8  e59d1000          LDR      r1,[sp,#0]
000bcc  e5c10000          STRB     r0,[r1,#0]
000bd0  e59d0000          LDR      r0,[sp,#0]
000bd4  e2800001          ADD      r0,r0,#1
000bd8  e58d0000          STR      r0,[sp,#0]
;;;646                        break;
000bdc  ea000017          B        |L1.3136|
                  |L1.3040|
;;;647                    case '\"':
000be0  e1a00000          MOV      r0,r0
;;;648                    case '\\':
000be4  e1a00000          MOV      r0,r0
                  |L1.3048|
;;;649                    case '/':
000be8  e1a00000          MOV      r0,r0
                  |L1.3052|
;;;650                        *output_pointer++ = input_pointer[1];
000bec  e5d50001          LDRB     r0,[r5,#1]
000bf0  e59d1000          LDR      r1,[sp,#0]
000bf4  e5c10000          STRB     r0,[r1,#0]
000bf8  e59d0000          LDR      r0,[sp,#0]
000bfc  e2800001          ADD      r0,r0,#1
000c00  e58d0000          STR      r0,[sp,#0]
;;;651                        break;
000c04  ea00000d          B        |L1.3136|
                  |L1.3080|
;;;652    
;;;653                    /* UTF-16 literal */
;;;654                    case 'u':
000c08  e1a00000          MOV      r0,r0
;;;655                        sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer, error_pointer);
000c0c  e1a03008          MOV      r3,r8
000c10  e1a0200d          MOV      r2,sp
000c14  e1a01004          MOV      r1,r4
000c18  e1a00005          MOV      r0,r5
000c1c  ebfffffe          BL       utf16_literal_to_utf8
000c20  e1a0a000          MOV      r10,r0
;;;656                        if (sequence_length == 0)
000c24  e35a0000          CMP      r10,#0
000c28  1a000000          BNE      |L1.3120|
;;;657                        {
;;;658                            /* failed to convert UTF16-literal to UTF-8 */
;;;659                            goto fail;
000c2c  ea000010          B        |L1.3188|
                  |L1.3120|
;;;660                        }
;;;661                        break;
000c30  ea000002          B        |L1.3136|
                  |L1.3124|
;;;662    
;;;663                    default:
000c34  e1a00000          MOV      r0,r0
;;;664                        *error_pointer = input_pointer;
000c38  e5885000          STR      r5,[r8,#0]
;;;665                        goto fail;
000c3c  ea00000c          B        |L1.3188|
                  |L1.3136|
000c40  e1a00000          MOV      r0,r0                 ;634
;;;666                }
;;;667                input_pointer += sequence_length;
000c44  e085500a          ADD      r5,r5,r10
;;;668            }
000c48  e1a00000          MOV      r0,r0
                  |L1.3148|
000c4c  e1550004          CMP      r5,r4                 ;620
000c50  3affff99          BCC      |L1.2748|
;;;669        }
;;;670    
;;;671        /* zero terminate the output */
;;;672        *output_pointer = '\0';
000c54  e3a00000          MOV      r0,#0
000c58  e59d1000          LDR      r1,[sp,#0]
000c5c  e5c10000          STRB     r0,[r1,#0]
;;;673    
;;;674        item->type = cJSON_String;
000c60  e3a00010          MOV      r0,#0x10
000c64  e589000c          STR      r0,[r9,#0xc]
;;;675        item->valuestring = (char*)output;
000c68  e5897010          STR      r7,[r9,#0x10]
;;;676    
;;;677        return input_end + 1;
000c6c  e2840001          ADD      r0,r4,#1
                  |L1.3184|
;;;678    
;;;679    fail:
;;;680        if (output != NULL)
;;;681        {
;;;682            cJSON_free(output);
;;;683        }
;;;684    
;;;685        return NULL;
;;;686    }
000c70  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.3188|
000c74  e1a00000          MOV      r0,r0                 ;679
000c78  e3570000          CMP      r7,#0                 ;680
000c7c  0a000003          BEQ      |L1.3216|
000c80  e1a00007          MOV      r0,r7                 ;682
000c84  e51f15b0          LDR      r1,|L1.1756|
000c88  e5911000          LDR      r1,[r1,#0]            ;682  ; cJSON_free
000c8c  e12fff31          BLX      r1                    ;682
                  |L1.3216|
000c90  e3a00000          MOV      r0,#0                 ;685
000c94  eafffff5          B        |L1.3184|
;;;687    
                          ENDP

                  print_string_ptr PROC
;;;688    /* Render the cstring provided to an escaped version that can be printed. */
;;;689    static unsigned char *print_string_ptr(const unsigned char *str, printbuffer *p)
000c98  e92d5ff0          PUSH     {r4-r12,lr}
;;;690    {
000c9c  e1a08000          MOV      r8,r0
000ca0  e1a09001          MOV      r9,r1
;;;691        const unsigned char *ptr = NULL;
000ca4  e3a05000          MOV      r5,#0
;;;692        unsigned char *ptr2 = NULL;
000ca8  e3a04000          MOV      r4,#0
;;;693        unsigned char *out = NULL;
000cac  e3a06000          MOV      r6,#0
;;;694        size_t len = 0;
000cb0  e3a07000          MOV      r7,#0
;;;695        cjbool flag = false;
000cb4  e3a0b000          MOV      r11,#0
;;;696        unsigned char token = '\0';
000cb8  e3a0a000          MOV      r10,#0
;;;697    
;;;698        /* empty string */
;;;699        if (!str)
000cbc  e3580000          CMP      r8,#0
000cc0  1a000014          BNE      |L1.3352|
;;;700        {
;;;701            if (p)
000cc4  e3590000          CMP      r9,#0
000cc8  0a000004          BEQ      |L1.3296|
;;;702            {
;;;703                out = ensure(p, 3);
000ccc  e3a01003          MOV      r1,#3
000cd0  e1a00009          MOV      r0,r9
000cd4  ebfffffe          BL       ensure
000cd8  e1a06000          MOV      r6,r0
000cdc  ea000004          B        |L1.3316|
                  |L1.3296|
;;;704            }
;;;705            else
;;;706            {
;;;707                out = (unsigned char*)cJSON_malloc(3);
000ce0  e3a00003          MOV      r0,#3
000ce4  e51f1614          LDR      r1,|L1.1752|
000ce8  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
000cec  e12fff31          BLX      r1
000cf0  e1a06000          MOV      r6,r0
                  |L1.3316|
;;;708            }
;;;709            if (!out)
000cf4  e3560000          CMP      r6,#0
000cf8  1a000001          BNE      |L1.3332|
;;;710            {
;;;711                return NULL;
000cfc  e3a00000          MOV      r0,#0
                  |L1.3328|
;;;712            }
;;;713            strcpy((char*)out, "\"\"");
;;;714    
;;;715            return out;
;;;716        }
;;;717    
;;;718        /* set "flag" to 1 if something needs to be escaped */
;;;719        for (ptr = str; *ptr; ptr++)
;;;720        {
;;;721            flag |= (((*ptr > 0) && (*ptr < 32)) /* unprintable characters */
;;;722                    || (*ptr == '\"') /* double quote */
;;;723                    || (*ptr == '\\')) /* backslash */
;;;724                ? 1
;;;725                : 0;
;;;726        }
;;;727        /* no characters have to be escaped */
;;;728        if (!flag)
;;;729        {
;;;730            len = (size_t)(ptr - str);
;;;731            if (p)
;;;732            {
;;;733                out = ensure(p, len + 3);
;;;734            }
;;;735            else
;;;736            {
;;;737                out = (unsigned char*)cJSON_malloc(len + 3);
;;;738            }
;;;739            if (!out)
;;;740            {
;;;741                return NULL;
;;;742            }
;;;743    
;;;744            ptr2 = out;
;;;745            *ptr2++ = '\"';
;;;746            strcpy((char*)ptr2, (const char*)str);
;;;747            ptr2[len] = '\"';
;;;748            ptr2[len + 1] = '\0';
;;;749    
;;;750            return out;
;;;751        }
;;;752    
;;;753        ptr = str;
;;;754        /* calculate additional space that is needed for escaping */
;;;755        while ((token = *ptr))
;;;756        {
;;;757            ++len;
;;;758            if (strchr("\"\\\b\f\n\r\t", token))
;;;759            {
;;;760                len++; /* +1 for the backslash */
;;;761            }
;;;762            else if (token < 32)
;;;763            {
;;;764                len += 5; /* +5 for \uXXXX */
;;;765            }
;;;766            ptr++;
;;;767        }
;;;768    
;;;769        if (p)
;;;770        {
;;;771            out = ensure(p, len + 3);
;;;772        }
;;;773        else
;;;774        {
;;;775            out = (unsigned char*)cJSON_malloc(len + 3);
;;;776        }
;;;777        if (!out)
;;;778        {
;;;779            return NULL;
;;;780        }
;;;781    
;;;782        ptr2 = out;
;;;783        ptr = str;
;;;784        *ptr2++ = '\"';
;;;785        /* copy the string */
;;;786        while (*ptr)
;;;787        {
;;;788            if ((*ptr > 31) && (*ptr != '\"') && (*ptr != '\\'))
;;;789            {
;;;790                /* normal character, copy */
;;;791                *ptr2++ = *ptr++;
;;;792            }
;;;793            else
;;;794            {
;;;795                /* character needs to be escaped */
;;;796                *ptr2++ = '\\';
;;;797                switch (token = *ptr++)
;;;798                {
;;;799                    case '\\':
;;;800                        *ptr2++ = '\\';
;;;801                        break;
;;;802                    case '\"':
;;;803                        *ptr2++ = '\"';
;;;804                        break;
;;;805                    case '\b':
;;;806                        *ptr2++ = 'b';
;;;807                        break;
;;;808                    case '\f':
;;;809                        *ptr2++ = 'f';
;;;810                        break;
;;;811                    case '\n':
;;;812                        *ptr2++ = 'n';
;;;813                        break;
;;;814                    case '\r':
;;;815                        *ptr2++ = 'r';
;;;816                        break;
;;;817                    case '\t':
;;;818                        *ptr2++ = 't';
;;;819                        break;
;;;820                    default:
;;;821                        /* escape and print as unicode codepoint */
;;;822                        sprintf((char*)ptr2, "u%04x", token);
;;;823                        ptr2 += 5;
;;;824                        break;
;;;825                }
;;;826            }
;;;827        }
;;;828        *ptr2++ = '\"';
;;;829        *ptr2++ = '\0';
;;;830    
;;;831        return out;
;;;832    }
000d00  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.3332|
000d04  e28f1e2b          ADR      r1,|L1.4028|
000d08  e1a00006          MOV      r0,r6                 ;713
000d0c  ebfffffe          BL       strcpy
000d10  e1a00006          MOV      r0,r6                 ;715
000d14  eafffff9          B        |L1.3328|
                  |L1.3352|
000d18  e1a05008          MOV      r5,r8                 ;719
000d1c  ea000010          B        |L1.3428|
                  |L1.3360|
000d20  e5d50000          LDRB     r0,[r5,#0]            ;721
000d24  e3500000          CMP      r0,#0                 ;721
000d28  da000002          BLE      |L1.3384|
000d2c  e5d50000          LDRB     r0,[r5,#0]            ;721
000d30  e3500020          CMP      r0,#0x20              ;721
000d34  ba000005          BLT      |L1.3408|
                  |L1.3384|
000d38  e5d50000          LDRB     r0,[r5,#0]            ;722
000d3c  e3500022          CMP      r0,#0x22              ;722
000d40  0a000002          BEQ      |L1.3408|
000d44  e5d50000          LDRB     r0,[r5,#0]            ;723
000d48  e350005c          CMP      r0,#0x5c              ;723
000d4c  1a000001          BNE      |L1.3416|
                  |L1.3408|
000d50  e3a00001          MOV      r0,#1                 ;724
000d54  ea000000          B        |L1.3420|
                  |L1.3416|
000d58  e3a00000          MOV      r0,#0                 ;725
                  |L1.3420|
000d5c  e18bb000          ORR      r11,r11,r0            ;725
000d60  e2855001          ADD      r5,r5,#1              ;719
                  |L1.3428|
000d64  e5d50000          LDRB     r0,[r5,#0]            ;719
000d68  e3500000          CMP      r0,#0                 ;719
000d6c  1affffeb          BNE      |L1.3360|
000d70  e35b0000          CMP      r11,#0                ;728
000d74  1a00001d          BNE      |L1.3568|
000d78  e0457008          SUB      r7,r5,r8              ;730
000d7c  e3590000          CMP      r9,#0                 ;731
000d80  0a000004          BEQ      |L1.3480|
000d84  e2871003          ADD      r1,r7,#3              ;733
000d88  e1a00009          MOV      r0,r9                 ;733
000d8c  ebfffffe          BL       ensure
000d90  e1a06000          MOV      r6,r0                 ;733
000d94  ea000004          B        |L1.3500|
                  |L1.3480|
000d98  e2870003          ADD      r0,r7,#3              ;737
000d9c  e51f16cc          LDR      r1,|L1.1752|
000da0  e5911000          LDR      r1,[r1,#0]            ;737  ; cJSON_malloc
000da4  e12fff31          BLX      r1                    ;737
000da8  e1a06000          MOV      r6,r0                 ;737
                  |L1.3500|
000dac  e3560000          CMP      r6,#0                 ;739
000db0  1a000001          BNE      |L1.3516|
000db4  e3a00000          MOV      r0,#0                 ;741
000db8  eaffffd0          B        |L1.3328|
                  |L1.3516|
000dbc  e1a04006          MOV      r4,r6                 ;744
000dc0  e3a00022          MOV      r0,#0x22              ;745
000dc4  e4c40001          STRB     r0,[r4],#1            ;745
000dc8  e1a01008          MOV      r1,r8                 ;746
000dcc  e1a00004          MOV      r0,r4                 ;746
000dd0  ebfffffe          BL       strcpy
000dd4  e3a00022          MOV      r0,#0x22              ;747
000dd8  e7c40007          STRB     r0,[r4,r7]            ;747
000ddc  e3a00000          MOV      r0,#0                 ;748
000de0  e2871001          ADD      r1,r7,#1              ;748
000de4  e7c40001          STRB     r0,[r4,r1]            ;748
000de8  e1a00006          MOV      r0,r6                 ;750
000dec  eaffffc3          B        |L1.3328|
                  |L1.3568|
000df0  e1a05008          MOV      r5,r8                 ;753
000df4  ea00000b          B        |L1.3624|
                  |L1.3576|
000df8  e2877001          ADD      r7,r7,#1              ;757
000dfc  e1a0100a          MOV      r1,r10                ;758
000e00  e28f0f6e          ADR      r0,|L1.4032|
000e04  ebfffffe          BL       strchr
000e08  e3500000          CMP      r0,#0                 ;758
000e0c  0a000001          BEQ      |L1.3608|
000e10  e2877001          ADD      r7,r7,#1              ;760
000e14  ea000002          B        |L1.3620|
                  |L1.3608|
000e18  e35a0020          CMP      r10,#0x20             ;762
000e1c  aa000000          BGE      |L1.3620|
000e20  e2877005          ADD      r7,r7,#5              ;764
                  |L1.3620|
000e24  e2855001          ADD      r5,r5,#1              ;766
                  |L1.3624|
000e28  e5d50000          LDRB     r0,[r5,#0]            ;755
000e2c  e1b0a000          MOVS     r10,r0                ;755
000e30  1afffff0          BNE      |L1.3576|
000e34  e3590000          CMP      r9,#0                 ;769
000e38  0a000004          BEQ      |L1.3664|
000e3c  e2871003          ADD      r1,r7,#3              ;771
000e40  e1a00009          MOV      r0,r9                 ;771
000e44  ebfffffe          BL       ensure
000e48  e1a06000          MOV      r6,r0                 ;771
000e4c  ea000004          B        |L1.3684|
                  |L1.3664|
000e50  e2870003          ADD      r0,r7,#3              ;775
000e54  e51f1784          LDR      r1,|L1.1752|
000e58  e5911000          LDR      r1,[r1,#0]            ;775  ; cJSON_malloc
000e5c  e12fff31          BLX      r1                    ;775
000e60  e1a06000          MOV      r6,r0                 ;775
                  |L1.3684|
000e64  e3560000          CMP      r6,#0                 ;777
000e68  1a000001          BNE      |L1.3700|
000e6c  e3a00000          MOV      r0,#0                 ;779
000e70  eaffffa2          B        |L1.3328|
                  |L1.3700|
000e74  e1a04006          MOV      r4,r6                 ;782
000e78  e1a05008          MOV      r5,r8                 ;783
000e7c  e3a00022          MOV      r0,#0x22              ;784
000e80  e4c40001          STRB     r0,[r4],#1            ;784
000e84  ea000042          B        |L1.3988|
                  |L1.3720|
000e88  e5d50000          LDRB     r0,[r5,#0]            ;788
000e8c  e350001f          CMP      r0,#0x1f              ;788
000e90  da000008          BLE      |L1.3768|
000e94  e5d50000          LDRB     r0,[r5,#0]            ;788
000e98  e3500022          CMP      r0,#0x22              ;788
000e9c  0a000005          BEQ      |L1.3768|
000ea0  e5d50000          LDRB     r0,[r5,#0]            ;788
000ea4  e350005c          CMP      r0,#0x5c              ;788
000ea8  0a000002          BEQ      |L1.3768|
000eac  e4d50001          LDRB     r0,[r5],#1            ;791
000eb0  e4c40001          STRB     r0,[r4],#1            ;791
000eb4  ea000036          B        |L1.3988|
                  |L1.3768|
000eb8  e3a0005c          MOV      r0,#0x5c              ;796
000ebc  e4c40001          STRB     r0,[r4],#1            ;796
000ec0  e4d50001          LDRB     r0,[r5],#1            ;797
000ec4  e1a0a000          MOV      r10,r0                ;797
000ec8  e350000c          CMP      r0,#0xc               ;797
000ecc  0a000018          BEQ      |L1.3892|
000ed0  ca000006          BGT      |L1.3824|
000ed4  e3500008          CMP      r0,#8                 ;797
000ed8  0a000011          BEQ      |L1.3876|
000edc  e3500009          CMP      r0,#9                 ;797
000ee0  0a00001f          BEQ      |L1.3940|
000ee4  e350000a          CMP      r0,#0xa               ;797
000ee8  1a000021          BNE      |L1.3956|
000eec  ea000014          B        |L1.3908|
                  |L1.3824|
000ef0  e350000d          CMP      r0,#0xd               ;797
000ef4  0a000016          BEQ      |L1.3924|
000ef8  e3500022          CMP      r0,#0x22              ;797
000efc  0a000004          BEQ      |L1.3860|
000f00  e350005c          CMP      r0,#0x5c              ;797
000f04  1a00001a          BNE      |L1.3956|
000f08  e3a0005c          MOV      r0,#0x5c              ;800
000f0c  e4c40001          STRB     r0,[r4],#1            ;800
000f10  ea00001e          B        |L1.3984|
                  |L1.3860|
000f14  e1a00000          MOV      r0,r0                 ;802
000f18  e3a00022          MOV      r0,#0x22              ;803
000f1c  e4c40001          STRB     r0,[r4],#1            ;803
000f20  ea00001a          B        |L1.3984|
                  |L1.3876|
000f24  e1a00000          MOV      r0,r0                 ;805
000f28  e3a00062          MOV      r0,#0x62              ;806
000f2c  e4c40001          STRB     r0,[r4],#1            ;806
000f30  ea000016          B        |L1.3984|
                  |L1.3892|
000f34  e1a00000          MOV      r0,r0                 ;808
000f38  e3a00066          MOV      r0,#0x66              ;809
000f3c  e4c40001          STRB     r0,[r4],#1            ;809
000f40  ea000012          B        |L1.3984|
                  |L1.3908|
000f44  e1a00000          MOV      r0,r0                 ;811
000f48  e3a0006e          MOV      r0,#0x6e              ;812
000f4c  e4c40001          STRB     r0,[r4],#1            ;812
000f50  ea00000e          B        |L1.3984|
                  |L1.3924|
000f54  e1a00000          MOV      r0,r0                 ;814
000f58  e3a00072          MOV      r0,#0x72              ;815
000f5c  e4c40001          STRB     r0,[r4],#1            ;815
000f60  ea00000a          B        |L1.3984|
                  |L1.3940|
000f64  e1a00000          MOV      r0,r0                 ;817
000f68  e3a00074          MOV      r0,#0x74              ;818
000f6c  e4c40001          STRB     r0,[r4],#1            ;818
000f70  ea000006          B        |L1.3984|
                  |L1.3956|
000f74  e1a00000          MOV      r0,r0                 ;820
000f78  e1a0200a          MOV      r2,r10                ;822
000f7c  e28f1044          ADR      r1,|L1.4040|
000f80  e1a00004          MOV      r0,r4                 ;822
000f84  ebfffffe          BL       __2sprintf
000f88  e2844005          ADD      r4,r4,#5              ;823
000f8c  e1a00000          MOV      r0,r0                 ;824
                  |L1.3984|
000f90  e1a00000          MOV      r0,r0                 ;801
                  |L1.3988|
000f94  e5d50000          LDRB     r0,[r5,#0]            ;786
000f98  e3500000          CMP      r0,#0                 ;786
000f9c  1affffb9          BNE      |L1.3720|
000fa0  e3a00022          MOV      r0,#0x22              ;828
000fa4  e4c40001          STRB     r0,[r4],#1            ;828
000fa8  e3a00000          MOV      r0,#0                 ;829
000fac  e4c40001          STRB     r0,[r4],#1            ;829
000fb0  e1a00006          MOV      r0,r6                 ;831
000fb4  eaffff51          B        |L1.3328|
                  |L1.4024|
                          DCD      firstByteMark
                  |L1.4028|
000fbc  222200            DCB      """""",0
000fbf  00                DCB      0
                  |L1.4032|
000fc0  225c080c          DCB      """\\\b\f\n\r\t",0
000fc4  0a0d0900
                  |L1.4040|
000fc8  75253034          DCB      "u%04x",0
000fcc  7800    
000fce  00                DCB      0
000fcf  00                DCB      0
                          ENDP

                  print_string PROC
;;;834    /* Invoke print_string_ptr (which is useful) on an item. */
;;;835    static unsigned char *print_string(const cJSON *item, printbuffer *p)
000fd0  e92d4070          PUSH     {r4-r6,lr}
;;;836    {
000fd4  e1a04000          MOV      r4,r0
000fd8  e1a05001          MOV      r5,r1
;;;837        return print_string_ptr((unsigned char*)item->valuestring, p);
000fdc  e1a01005          MOV      r1,r5
000fe0  e5940010          LDR      r0,[r4,#0x10]
000fe4  ebfffffe          BL       print_string_ptr
;;;838    }
000fe8  e8bd8070          POP      {r4-r6,pc}
;;;839    
                          ENDP

                  skip PROC
;;;848    /* Utility to jump whitespace and cr/lf */
;;;849    static const unsigned char *skip(const unsigned char *in)
000fec  ea000000          B        |L1.4084|
                  |L1.4080|
;;;850    {
;;;851        while (in && *in && (*in <= 32))
;;;852        {
;;;853            in++;
000ff0  e2800001          ADD      r0,r0,#1
                  |L1.4084|
000ff4  e3500000          CMP      r0,#0                 ;851
000ff8  0a000005          BEQ      |L1.4116|
000ffc  e5d01000          LDRB     r1,[r0,#0]            ;851
001000  e3510000          CMP      r1,#0                 ;851
001004  0a000002          BEQ      |L1.4116|
001008  e5d01000          LDRB     r1,[r0,#0]            ;851
00100c  e3510020          CMP      r1,#0x20              ;851
001010  dafffff6          BLE      |L1.4080|
                  |L1.4116|
;;;854        }
;;;855    
;;;856        return in;
;;;857    }
001014  e12fff1e          BX       lr
;;;858    
                          ENDP

                  parse_object PROC
;;;1368   /* Build an object from the text. */
;;;1369   static const unsigned char *parse_object(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer)
001018  e92d47f0          PUSH     {r4-r10,lr}
;;;1370   {
00101c  e1a09000          MOV      r9,r0
001020  e1a04001          MOV      r4,r1
001024  e1a07002          MOV      r7,r2
;;;1371       cJSON *head = NULL; /* linked list head */
001028  e3a08000          MOV      r8,#0
;;;1372       cJSON *current_item = NULL;
00102c  e3a05000          MOV      r5,#0
;;;1373   
;;;1374       if (*input != '{')
001030  e5d40000          LDRB     r0,[r4,#0]
001034  e350007b          CMP      r0,#0x7b
001038  0a000001          BEQ      |L1.4164|
;;;1375       {
;;;1376           *error_pointer = input;
00103c  e5874000          STR      r4,[r7,#0]
;;;1377           goto fail; /* not an object */
001040  ea000048          B        |L1.4456|
                  |L1.4164|
;;;1378       }
;;;1379   
;;;1380       input = skip(input + 1); /* skip whitespace */
001044  e2840001          ADD      r0,r4,#1
001048  ebfffffe          BL       skip
00104c  e1a04000          MOV      r4,r0
;;;1381       if (*input == '}')
001050  e5d40000          LDRB     r0,[r4,#0]
001054  e350007d          CMP      r0,#0x7d
001058  1a000000          BNE      |L1.4192|
;;;1382       {
;;;1383           goto success; /* empty object */
00105c  ea00003c          B        |L1.4436|
                  |L1.4192|
;;;1384       }
;;;1385   
;;;1386       /* step back to character in front of the first element */
;;;1387       input--;
001060  e2444001          SUB      r4,r4,#1
;;;1388       /* loop through the comma separated array elements */
;;;1389       do
001064  e1a00000          MOV      r0,r0
                  |L1.4200|
;;;1390       {
;;;1391           /* allocate next item */
;;;1392           cJSON *new_item = cJSON_New_Item();
001068  ebfffffe          BL       cJSON_New_Item
00106c  e1a06000          MOV      r6,r0
;;;1393           if (new_item == NULL)
001070  e3560000          CMP      r6,#0
001074  1a000000          BNE      |L1.4220|
;;;1394           {
;;;1395               goto fail; /* allocation failure */
001078  ea00003a          B        |L1.4456|
                  |L1.4220|
;;;1396           }
;;;1397   
;;;1398           /* attach next item to list */
;;;1399           if (head == NULL)
00107c  e3580000          CMP      r8,#0
001080  1a000002          BNE      |L1.4240|
;;;1400           {
;;;1401               /* start the linked list */
;;;1402               current_item = head = new_item;
001084  e1a08006          MOV      r8,r6
001088  e1a05006          MOV      r5,r6
00108c  ea000002          B        |L1.4252|
                  |L1.4240|
;;;1403           }
;;;1404           else
;;;1405           {
;;;1406               /* add to the end and advance */
;;;1407               current_item->next = new_item;
001090  e5856000          STR      r6,[r5,#0]
;;;1408               new_item->prev = current_item;
001094  e5865004          STR      r5,[r6,#4]
;;;1409               current_item = new_item;
001098  e1a05006          MOV      r5,r6
                  |L1.4252|
;;;1410           }
;;;1411   
;;;1412           /* parse the name of the child */
;;;1413           input = skip(input + 1); /* skip whitespaces before name */
00109c  e2840001          ADD      r0,r4,#1
0010a0  ebfffffe          BL       skip
0010a4  e1a04000          MOV      r4,r0
;;;1414           input = parse_string(current_item, input, error_pointer);
0010a8  e1a02007          MOV      r2,r7
0010ac  e1a01004          MOV      r1,r4
0010b0  e1a00005          MOV      r0,r5
0010b4  ebfffffe          BL       parse_string
0010b8  e1a04000          MOV      r4,r0
;;;1415           input = skip(input); /* skip whitespaces after name */
0010bc  e1a00004          MOV      r0,r4
0010c0  ebfffffe          BL       skip
0010c4  e1a04000          MOV      r4,r0
;;;1416           if (input == NULL)
0010c8  e3540000          CMP      r4,#0
0010cc  1a000000          BNE      |L1.4308|
;;;1417           {
;;;1418               goto fail; /* faile to parse name */
0010d0  ea000024          B        |L1.4456|
                  |L1.4308|
;;;1419           }
;;;1420   
;;;1421           /* swap valuestring and string, because we parsed the name */
;;;1422           current_item->string = current_item->valuestring;
0010d4  e5950010          LDR      r0,[r5,#0x10]
0010d8  e5850020          STR      r0,[r5,#0x20]
;;;1423           current_item->valuestring = NULL;
0010dc  e3a00000          MOV      r0,#0
0010e0  e5850010          STR      r0,[r5,#0x10]
;;;1424   
;;;1425           if (*input != ':')
0010e4  e5d40000          LDRB     r0,[r4,#0]
0010e8  e350003a          CMP      r0,#0x3a
0010ec  0a000001          BEQ      |L1.4344|
;;;1426           {
;;;1427               *error_pointer = input;
0010f0  e5874000          STR      r4,[r7,#0]
;;;1428               goto fail; /* invalid object */
0010f4  ea00001b          B        |L1.4456|
                  |L1.4344|
;;;1429           }
;;;1430   
;;;1431           /* parse the value */
;;;1432           input = skip(input + 1); /* skip whitespaces before value */
0010f8  e2840001          ADD      r0,r4,#1
0010fc  ebfffffe          BL       skip
001100  e1a04000          MOV      r4,r0
;;;1433           input = parse_value(current_item, input, error_pointer);
001104  e1a02007          MOV      r2,r7
001108  e1a01004          MOV      r1,r4
00110c  e1a00005          MOV      r0,r5
001110  ebfffffe          BL       parse_value
001114  e1a04000          MOV      r4,r0
;;;1434           input = skip(input); /* skip whitespaces after the value */
001118  e1a00004          MOV      r0,r4
00111c  ebfffffe          BL       skip
001120  e1a04000          MOV      r4,r0
;;;1435           if (input == NULL)
001124  e3540000          CMP      r4,#0
001128  1a000000          BNE      |L1.4400|
;;;1436           {
;;;1437               goto fail; /* failed to parse value */
00112c  ea00000d          B        |L1.4456|
                  |L1.4400|
;;;1438           }
;;;1439       }
;;;1440       while (*input == ',');
001130  e5d40000          LDRB     r0,[r4,#0]
001134  e350002c          CMP      r0,#0x2c
001138  0affffca          BEQ      |L1.4200|
;;;1441   
;;;1442       if (*input != '}')
00113c  e5d40000          LDRB     r0,[r4,#0]
001140  e350007d          CMP      r0,#0x7d
001144  0a000001          BEQ      |L1.4432|
;;;1443       {
;;;1444           *error_pointer = input;
001148  e5874000          STR      r4,[r7,#0]
;;;1445           goto fail; /* expected end of object */
00114c  ea000005          B        |L1.4456|
                  |L1.4432|
;;;1446       }
;;;1447   
;;;1448   success:
001150  e1a00000          MOV      r0,r0
                  |L1.4436|
;;;1449       item->type = cJSON_Object;
001154  e3a00040          MOV      r0,#0x40
001158  e589000c          STR      r0,[r9,#0xc]
;;;1450       item->child = head;
00115c  e5898008          STR      r8,[r9,#8]
;;;1451   
;;;1452       return input + 1;
001160  e2840001          ADD      r0,r4,#1
                  |L1.4452|
;;;1453   
;;;1454   fail:
;;;1455       if (head != NULL)
;;;1456       {
;;;1457           cJSON_Delete(head);
;;;1458       }
;;;1459   
;;;1460       return NULL;
;;;1461   }
001164  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4456|
001168  e1a00000          MOV      r0,r0                 ;1454
00116c  e3580000          CMP      r8,#0                 ;1455
001170  0a000001          BEQ      |L1.4476|
001174  e1a00008          MOV      r0,r8                 ;1457
001178  ebfffffe          BL       cJSON_Delete
                  |L1.4476|
00117c  e3a00000          MOV      r0,#0                 ;1460
001180  eafffff7          B        |L1.4452|
;;;1462   
                          ENDP

                  parse_array PROC
;;;1121   /* Build an array from input text. */
;;;1122   static const unsigned char *parse_array(cJSON * const item, const unsigned char *input, const unsigned char ** const error_pointer)
001184  e92d47f0          PUSH     {r4-r10,lr}
;;;1123   {
001188  e1a07000          MOV      r7,r0
00118c  e1a04001          MOV      r4,r1
001190  e1a08002          MOV      r8,r2
;;;1124       cJSON *head = NULL; /* head of the linked list */
001194  e3a06000          MOV      r6,#0
;;;1125       cJSON *current_item = NULL;
001198  e3a09000          MOV      r9,#0
;;;1126   
;;;1127       if (*input != '[')
00119c  e5d40000          LDRB     r0,[r4,#0]
0011a0  e350005b          CMP      r0,#0x5b
0011a4  0a000001          BEQ      |L1.4528|
;;;1128       {
;;;1129           /* not an array */
;;;1130           *error_pointer = input;
0011a8  e5884000          STR      r4,[r8,#0]
;;;1131           goto fail;
0011ac  ea000031          B        |L1.4728|
                  |L1.4528|
;;;1132       }
;;;1133   
;;;1134       input = skip(input + 1); /* skip whitespace */
0011b0  e2840001          ADD      r0,r4,#1
0011b4  ebfffffe          BL       skip
0011b8  e1a04000          MOV      r4,r0
;;;1135       if (*input == ']')
0011bc  e5d40000          LDRB     r0,[r4,#0]
0011c0  e350005d          CMP      r0,#0x5d
0011c4  1a000000          BNE      |L1.4556|
;;;1136       {
;;;1137           /* empty array */
;;;1138           goto success;
0011c8  ea000025          B        |L1.4708|
                  |L1.4556|
;;;1139       }
;;;1140   
;;;1141       /* step back to character in front of the first element */
;;;1142       input--;
0011cc  e2444001          SUB      r4,r4,#1
;;;1143       /* loop through the comma separated array elements */
;;;1144       do
0011d0  e1a00000          MOV      r0,r0
                  |L1.4564|
;;;1145       {
;;;1146           /* allocate next item */
;;;1147           cJSON *new_item = cJSON_New_Item();
0011d4  ebfffffe          BL       cJSON_New_Item
0011d8  e1a05000          MOV      r5,r0
;;;1148           if (new_item == NULL)
0011dc  e3550000          CMP      r5,#0
0011e0  1a000000          BNE      |L1.4584|
;;;1149           {
;;;1150               goto fail; /* allocation failure */
0011e4  ea000023          B        |L1.4728|
                  |L1.4584|
;;;1151           }
;;;1152   
;;;1153           /* attach next item to list */
;;;1154           if (head == NULL)
0011e8  e3560000          CMP      r6,#0
0011ec  1a000002          BNE      |L1.4604|
;;;1155           {
;;;1156               /* start the linked list */
;;;1157               current_item = head = new_item;
0011f0  e1a06005          MOV      r6,r5
0011f4  e1a09005          MOV      r9,r5
0011f8  ea000002          B        |L1.4616|
                  |L1.4604|
;;;1158           }
;;;1159           else
;;;1160           {
;;;1161               /* add to the end and advance */
;;;1162               current_item->next = new_item;
0011fc  e5895000          STR      r5,[r9,#0]
;;;1163               new_item->prev = current_item;
001200  e5859004          STR      r9,[r5,#4]
;;;1164               current_item = new_item;
001204  e1a09005          MOV      r9,r5
                  |L1.4616|
;;;1165           }
;;;1166   
;;;1167           /* parse next value */
;;;1168           input = skip(input + 1); /* skip whitespace before value */
001208  e2840001          ADD      r0,r4,#1
00120c  ebfffffe          BL       skip
001210  e1a04000          MOV      r4,r0
;;;1169           input = parse_value(current_item, input, error_pointer);
001214  e1a02008          MOV      r2,r8
001218  e1a01004          MOV      r1,r4
00121c  e1a00009          MOV      r0,r9
001220  ebfffffe          BL       parse_value
001224  e1a04000          MOV      r4,r0
;;;1170           input = skip(input); /* skip whitespace after value */
001228  e1a00004          MOV      r0,r4
00122c  ebfffffe          BL       skip
001230  e1a04000          MOV      r4,r0
;;;1171           if (input == NULL)
001234  e3540000          CMP      r4,#0
001238  1a000000          BNE      |L1.4672|
;;;1172           {
;;;1173               goto fail; /* failed to parse value */
00123c  ea00000d          B        |L1.4728|
                  |L1.4672|
;;;1174           }
;;;1175       }
;;;1176       while (*input == ',');
001240  e5d40000          LDRB     r0,[r4,#0]
001244  e350002c          CMP      r0,#0x2c
001248  0affffe1          BEQ      |L1.4564|
;;;1177   
;;;1178       if (*input != ']')
00124c  e5d40000          LDRB     r0,[r4,#0]
001250  e350005d          CMP      r0,#0x5d
001254  0a000001          BEQ      |L1.4704|
;;;1179       {
;;;1180           *error_pointer = input;
001258  e5884000          STR      r4,[r8,#0]
;;;1181           goto fail; /* expected end of array */
00125c  ea000005          B        |L1.4728|
                  |L1.4704|
;;;1182       }
;;;1183   
;;;1184   success:
001260  e1a00000          MOV      r0,r0
                  |L1.4708|
;;;1185       item->type = cJSON_Array;
001264  e3a00020          MOV      r0,#0x20
001268  e587000c          STR      r0,[r7,#0xc]
;;;1186       item->child = head;
00126c  e5876008          STR      r6,[r7,#8]
;;;1187   
;;;1188       return input + 1;
001270  e2840001          ADD      r0,r4,#1
                  |L1.4724|
;;;1189   
;;;1190   fail:
;;;1191       if (head != NULL)
;;;1192       {
;;;1193           cJSON_Delete(head);
;;;1194       }
;;;1195   
;;;1196       return NULL;
;;;1197   }
001274  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4728|
001278  e1a00000          MOV      r0,r0                 ;1190
00127c  e3560000          CMP      r6,#0                 ;1191
001280  0a000001          BEQ      |L1.4748|
001284  e1a00006          MOV      r0,r6                 ;1193
001288  ebfffffe          BL       cJSON_Delete
                  |L1.4748|
00128c  e3a00000          MOV      r0,#0                 ;1196
001290  eafffff7          B        |L1.4724|
;;;1198   
                          ENDP

                  parse_value PROC
;;;958    /* Parser core - when encountering text, process appropriately. */
;;;959    static const unsigned  char *parse_value(cJSON * const item, const unsigned char * const input, const unsigned char ** const error_pointer)
001294  e92d4070          PUSH     {r4-r6,lr}
;;;960    {
001298  e1a05000          MOV      r5,r0
00129c  e1a04001          MOV      r4,r1
0012a0  e1a06002          MOV      r6,r2
;;;961        if (input == NULL)
0012a4  e3540000          CMP      r4,#0
0012a8  1a000001          BNE      |L1.4788|
;;;962        {
;;;963            return NULL; /* no input */
0012ac  e3a00000          MOV      r0,#0
                  |L1.4784|
;;;964        }
;;;965    
;;;966        /* parse the different types of values */
;;;967        /* null */
;;;968        if (!strncmp((const char*)input, "null", 4))
;;;969        {
;;;970            item->type = cJSON_NULL;
;;;971            return input + 4;
;;;972        }
;;;973        /* false */
;;;974        if (!strncmp((const char*)input, "false", 5))
;;;975        {
;;;976            item->type = cJSON_False;
;;;977            return input + 5;
;;;978        }
;;;979        /* true */
;;;980        if (!strncmp((const char*)input, "true", 4))
;;;981        {
;;;982            item->type = cJSON_True;
;;;983            item->valueint = 1;
;;;984            return input + 4;
;;;985        }
;;;986        /* string */
;;;987        if (*input == '\"')
;;;988        {
;;;989            return parse_string(item, input, error_pointer);
;;;990        }
;;;991        /* number */
;;;992        if ((*input == '-') || ((*input >= '0') && (*input <= '9')))
;;;993        {
;;;994            return parse_number(item, input);
;;;995        }
;;;996        /* array */
;;;997        if (*input == '[')
;;;998        {
;;;999            return parse_array(item, input, error_pointer);
;;;1000       }
;;;1001       /* object */
;;;1002       if (*input == '{')
;;;1003       {
;;;1004           return parse_object(item, input, error_pointer);
;;;1005       }
;;;1006   
;;;1007       /* failure. */
;;;1008       *error_pointer = input;
;;;1009       return NULL;
;;;1010   }
0012b0  e8bd8070          POP      {r4-r6,pc}
                  |L1.4788|
0012b4  e3a02004          MOV      r2,#4                 ;968
0012b8  e59f11f8          LDR      r1,|L1.5304|
0012bc  e1a00004          MOV      r0,r4                 ;968
0012c0  ebfffffe          BL       strncmp
0012c4  e3500000          CMP      r0,#0                 ;968
0012c8  1a000003          BNE      |L1.4828|
0012cc  e3a00004          MOV      r0,#4                 ;970
0012d0  e585000c          STR      r0,[r5,#0xc]          ;970
0012d4  e2840004          ADD      r0,r4,#4              ;971
0012d8  eafffff4          B        |L1.4784|
                  |L1.4828|
0012dc  e3a02005          MOV      r2,#5                 ;974
0012e0  e28f1f75          ADR      r1,|L1.5308|
0012e4  e1a00004          MOV      r0,r4                 ;974
0012e8  ebfffffe          BL       strncmp
0012ec  e3500000          CMP      r0,#0                 ;974
0012f0  1a000003          BNE      |L1.4868|
0012f4  e3a00001          MOV      r0,#1                 ;976
0012f8  e585000c          STR      r0,[r5,#0xc]          ;976
0012fc  e2840005          ADD      r0,r4,#5              ;977
001300  eaffffea          B        |L1.4784|
                  |L1.4868|
001304  e3a02004          MOV      r2,#4                 ;980
001308  e28f1f6d          ADR      r1,|L1.5316|
00130c  e1a00004          MOV      r0,r4                 ;980
001310  ebfffffe          BL       strncmp
001314  e3500000          CMP      r0,#0                 ;980
001318  1a000005          BNE      |L1.4916|
00131c  e3a00002          MOV      r0,#2                 ;982
001320  e585000c          STR      r0,[r5,#0xc]          ;982
001324  e3a00001          MOV      r0,#1                 ;983
001328  e5850014          STR      r0,[r5,#0x14]         ;983
00132c  e2840004          ADD      r0,r4,#4              ;984
001330  eaffffde          B        |L1.4784|
                  |L1.4916|
001334  e5d40000          LDRB     r0,[r4,#0]            ;987
001338  e3500022          CMP      r0,#0x22              ;987
00133c  1a000004          BNE      |L1.4948|
001340  e1a02006          MOV      r2,r6                 ;989
001344  e1a01004          MOV      r1,r4                 ;989
001348  e1a00005          MOV      r0,r5                 ;989
00134c  ebfffffe          BL       parse_string
001350  eaffffd6          B        |L1.4784|
                  |L1.4948|
001354  e5d40000          LDRB     r0,[r4,#0]            ;992
001358  e350002d          CMP      r0,#0x2d              ;992
00135c  0a000005          BEQ      |L1.4984|
001360  e5d40000          LDRB     r0,[r4,#0]            ;992
001364  e3500030          CMP      r0,#0x30              ;992
001368  ba000006          BLT      |L1.5000|
00136c  e5d40000          LDRB     r0,[r4,#0]            ;992
001370  e3500039          CMP      r0,#0x39              ;992
001374  ca000003          BGT      |L1.5000|
                  |L1.4984|
001378  e1a01004          MOV      r1,r4                 ;994
00137c  e1a00005          MOV      r0,r5                 ;994
001380  ebfffffe          BL       parse_number
001384  eaffffc9          B        |L1.4784|
                  |L1.5000|
001388  e5d40000          LDRB     r0,[r4,#0]            ;997
00138c  e350005b          CMP      r0,#0x5b              ;997
001390  1a000004          BNE      |L1.5032|
001394  e1a02006          MOV      r2,r6                 ;999
001398  e1a01004          MOV      r1,r4                 ;999
00139c  e1a00005          MOV      r0,r5                 ;999
0013a0  ebfffffe          BL       parse_array
0013a4  eaffffc1          B        |L1.4784|
                  |L1.5032|
0013a8  e5d40000          LDRB     r0,[r4,#0]            ;1002
0013ac  e350007b          CMP      r0,#0x7b              ;1002
0013b0  1a000004          BNE      |L1.5064|
0013b4  e1a02006          MOV      r2,r6                 ;1004
0013b8  e1a01004          MOV      r1,r4                 ;1004
0013bc  e1a00005          MOV      r0,r5                 ;1004
0013c0  ebfffffe          BL       parse_object
0013c4  eaffffb9          B        |L1.4784|
                  |L1.5064|
0013c8  e5864000          STR      r4,[r6,#0]            ;1008
0013cc  e3a00000          MOV      r0,#0                 ;1009
0013d0  eaffffb6          B        |L1.4784|
;;;1011   
                          ENDP

                  cJSON_ParseWithOpts PROC
;;;859    /* Parse an object - create a new root, and populate. */
;;;860    cJSON *cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cjbool require_null_terminated)
0013d4  e92d47f0          PUSH     {r4-r10,lr}
;;;861    {
0013d8  e1a09000          MOV      r9,r0
0013dc  e1a05001          MOV      r5,r1
0013e0  e1a08002          MOV      r8,r2
;;;862        const unsigned char *end = NULL;
0013e4  e3a04000          MOV      r4,#0
;;;863        /* use global error pointer if no specific one was given */
;;;864        const unsigned char **ep = return_parse_end ? (const unsigned char**)return_parse_end : &global_ep;
0013e8  e3550000          CMP      r5,#0
0013ec  0a000001          BEQ      |L1.5112|
0013f0  e1a00005          MOV      r0,r5
0013f4  ea000000          B        |L1.5116|
                  |L1.5112|
0013f8  e51f0d30          LDR      r0,|L1.1744|
                  |L1.5116|
0013fc  e1a06000          MOV      r6,r0
;;;865        cJSON *c = cJSON_New_Item();
001400  ebfffffe          BL       cJSON_New_Item
001404  e1a07000          MOV      r7,r0
;;;866        *ep = NULL;
001408  e3a00000          MOV      r0,#0
00140c  e5860000          STR      r0,[r6,#0]
;;;867        if (!c) /* memory fail */
001410  e3570000          CMP      r7,#0
001414  1a000000          BNE      |L1.5148|
                  |L1.5144|
;;;868        {
;;;869            return NULL;
;;;870        }
;;;871    
;;;872        end = parse_value(c, skip((const unsigned char*)value), ep);
;;;873        if (!end)
;;;874        {
;;;875            /* parse failure. ep is set. */
;;;876            cJSON_Delete(c);
;;;877            return NULL;
;;;878        }
;;;879    
;;;880        /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
;;;881        if (require_null_terminated)
;;;882        {
;;;883            end = skip(end);
;;;884            if (*end)
;;;885            {
;;;886                cJSON_Delete(c);
;;;887                *ep = end;
;;;888                return NULL;
;;;889            }
;;;890        }
;;;891        if (return_parse_end)
;;;892        {
;;;893            *return_parse_end = (const char*)end;
;;;894        }
;;;895    
;;;896        return c;
;;;897    }
001418  e8bd87f0          POP      {r4-r10,pc}
                  |L1.5148|
00141c  e1a00009          MOV      r0,r9                 ;872
001420  ebfffffe          BL       skip
001424  e1a0a000          MOV      r10,r0                ;872
001428  e1a02006          MOV      r2,r6                 ;872
00142c  e1a0100a          MOV      r1,r10                ;872
001430  e1a00007          MOV      r0,r7                 ;872
001434  ebfffffe          BL       parse_value
001438  e1a04000          MOV      r4,r0                 ;872
00143c  e3540000          CMP      r4,#0                 ;873
001440  1a000003          BNE      |L1.5204|
001444  e1a00007          MOV      r0,r7                 ;876
001448  ebfffffe          BL       cJSON_Delete
00144c  e3a00000          MOV      r0,#0                 ;877
001450  eafffff0          B        |L1.5144|
                  |L1.5204|
001454  e3580000          CMP      r8,#0                 ;881
001458  0a00000a          BEQ      |L1.5256|
00145c  e1a00004          MOV      r0,r4                 ;883
001460  ebfffffe          BL       skip
001464  e1a04000          MOV      r4,r0                 ;883
001468  e5d40000          LDRB     r0,[r4,#0]            ;884
00146c  e3500000          CMP      r0,#0                 ;884
001470  0a000004          BEQ      |L1.5256|
001474  e1a00007          MOV      r0,r7                 ;886
001478  ebfffffe          BL       cJSON_Delete
00147c  e5864000          STR      r4,[r6,#0]            ;887
001480  e3a00000          MOV      r0,#0                 ;888
001484  eaffffe3          B        |L1.5144|
                  |L1.5256|
001488  e3550000          CMP      r5,#0                 ;891
00148c  0a000000          BEQ      |L1.5268|
001490  e5854000          STR      r4,[r5,#0]            ;893
                  |L1.5268|
001494  e1a00007          MOV      r0,r7                 ;896
001498  eaffffde          B        |L1.5144|
;;;898    
                          ENDP

                  cJSON_Parse PROC
;;;899    /* Default options for cJSON_Parse */
;;;900    cJSON *cJSON_Parse(const char *value)
00149c  e92d4010          PUSH     {r4,lr}
;;;901    {
0014a0  e1a04000          MOV      r4,r0
;;;902        return cJSON_ParseWithOpts(value, 0, 0);
0014a4  e3a02000          MOV      r2,#0
0014a8  e1a01002          MOV      r1,r2
0014ac  e1a00004          MOV      r0,r4
0014b0  ebfffffe          BL       cJSON_ParseWithOpts
;;;903    }
0014b4  e8bd8010          POP      {r4,pc}
                  |L1.5304|
                          DCD      ||.text||+0x6f8
                  |L1.5308|
0014bc  66616c73          DCB      "false",0
0014c0  6500    
0014c2  00                DCB      0
0014c3  00                DCB      0
                  |L1.5316|
0014c4  74727565          DCB      "true",0
0014c8  00      
0014c9  00                DCB      0
0014ca  00                DCB      0
0014cb  00                DCB      0
                          ENDP

                  print_object PROC
;;;1463   /* Render an object to text. */
;;;1464   static unsigned char *print_object(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)
0014cc  e92d4fff          PUSH     {r0-r11,lr}
;;;1465   {
0014d0  e24dd024          SUB      sp,sp,#0x24
0014d4  e1a08001          MOV      r8,r1
0014d8  e1a06002          MOV      r6,r2
0014dc  e1a07003          MOV      r7,r3
;;;1466       unsigned char **entries = NULL;
0014e0  e3a00000          MOV      r0,#0
0014e4  e58d0020          STR      r0,[sp,#0x20]
;;;1467       unsigned char **names = NULL;
0014e8  e58d001c          STR      r0,[sp,#0x1c]
;;;1468       unsigned char *out = NULL;
0014ec  e58d0018          STR      r0,[sp,#0x18]
;;;1469       unsigned char *ptr = NULL;
0014f0  e3a04000          MOV      r4,#0
;;;1470       unsigned char *ret = NULL;
0014f4  e58d0014          STR      r0,[sp,#0x14]
;;;1471       unsigned char *str = NULL;
0014f8  e58d0010          STR      r0,[sp,#0x10]
;;;1472       size_t len = 7;
0014fc  e3a0a007          MOV      r10,#7
;;;1473       size_t i = 0;
001500  e3a05000          MOV      r5,#0
;;;1474       size_t j = 0;
001504  e58d000c          STR      r0,[sp,#0xc]
;;;1475       cJSON *child = item->child;
001508  e59d0024          LDR      r0,[sp,#0x24]
00150c  e5909008          LDR      r9,[r0,#8]
;;;1476       size_t numentries = 0;
001510  e3a00000          MOV      r0,#0
001514  e58d0008          STR      r0,[sp,#8]
;;;1477       cjbool fail = false;
001518  e58d0004          STR      r0,[sp,#4]
;;;1478       size_t tmplen = 0;
00151c  e58d0000          STR      r0,[sp,#0]
;;;1479   
;;;1480       /* Count the number of entries. */
;;;1481       while (child)
001520  ea000003          B        |L1.5428|
                  |L1.5412|
;;;1482       {
;;;1483           numentries++;
001524  e59d0008          LDR      r0,[sp,#8]
001528  e2800001          ADD      r0,r0,#1
00152c  e58d0008          STR      r0,[sp,#8]
;;;1484           child = child->next;
001530  e5999000          LDR      r9,[r9,#0]
                  |L1.5428|
001534  e3590000          CMP      r9,#0                 ;1481
001538  1afffff9          BNE      |L1.5412|
;;;1485       }
;;;1486   
;;;1487       /* Explicitly handle empty object case */
;;;1488       if (!numentries)
00153c  e59d0008          LDR      r0,[sp,#8]
001540  e3500000          CMP      r0,#0
001544  1a00002f          BNE      |L1.5640|
;;;1489       {
;;;1490           if (p)
001548  e3570000          CMP      r7,#0
00154c  0a000009          BEQ      |L1.5496|
;;;1491           {
;;;1492               out = ensure(p, fmt ? depth + 4 : 3);
001550  e3560000          CMP      r6,#0
001554  0a000001          BEQ      |L1.5472|
001558  e2880004          ADD      r0,r8,#4
00155c  ea000000          B        |L1.5476|
                  |L1.5472|
001560  e3a00003          MOV      r0,#3
                  |L1.5476|
001564  e1a01000          MOV      r1,r0
001568  e1a00007          MOV      r0,r7
00156c  ebfffffe          BL       ensure
001570  e58d0018          STR      r0,[sp,#0x18]
001574  ea000009          B        |L1.5536|
                  |L1.5496|
;;;1493           }
;;;1494           else
;;;1495           {
;;;1496               out = (unsigned char*)cJSON_malloc(fmt ? depth + 4 : 3);
001578  e3560000          CMP      r6,#0
00157c  0a000001          BEQ      |L1.5512|
001580  e2881004          ADD      r1,r8,#4
001584  ea000000          B        |L1.5516|
                  |L1.5512|
001588  e3a01003          MOV      r1,#3
                  |L1.5516|
00158c  e1a00001          MOV      r0,r1
001590  e51f1ec0          LDR      r1,|L1.1752|
001594  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
001598  e12fff31          BLX      r1
00159c  e58d0018          STR      r0,[sp,#0x18]
                  |L1.5536|
;;;1497           }
;;;1498           if (!out)
0015a0  e59d0018          LDR      r0,[sp,#0x18]
0015a4  e3500000          CMP      r0,#0
0015a8  1a000002          BNE      |L1.5560|
;;;1499           {
;;;1500               return NULL;
0015ac  e3a00000          MOV      r0,#0
                  |L1.5552|
0015b0  e28dd034          ADD      sp,sp,#0x34
;;;1501           }
;;;1502           ptr = out;
;;;1503           *ptr++ = '{';
;;;1504           if (fmt) {
;;;1505               *ptr++ = '\n';
;;;1506               for (i = 0; i < depth; i++)
;;;1507               {
;;;1508                   *ptr++ = '\t';
;;;1509               }
;;;1510           }
;;;1511           *ptr++ = '}';
;;;1512           *ptr++ = '\0';
;;;1513   
;;;1514           return out;
;;;1515       }
;;;1516   
;;;1517       if (p)
;;;1518       {
;;;1519           /* Compose the output: */
;;;1520           i = p->offset;
;;;1521           len = fmt ? 2 : 1; /* fmt: {\n */
;;;1522           ptr = ensure(p, len + 1);
;;;1523           if (!ptr)
;;;1524           {
;;;1525               return NULL;
;;;1526           }
;;;1527   
;;;1528           *ptr++ = '{';
;;;1529           if (fmt)
;;;1530           {
;;;1531               *ptr++ = '\n';
;;;1532           }
;;;1533           *ptr = '\0';
;;;1534           p->offset += len;
;;;1535   
;;;1536           child = item->child;
;;;1537           depth++;
;;;1538           while (child)
;;;1539           {
;;;1540               if (fmt)
;;;1541               {
;;;1542                   ptr = ensure(p, depth);
;;;1543                   if (!ptr)
;;;1544                   {
;;;1545                       return NULL;
;;;1546                   }
;;;1547                   for (j = 0; j < depth; j++)
;;;1548                   {
;;;1549                       *ptr++ = '\t';
;;;1550                   }
;;;1551                   p->offset += depth;
;;;1552               }
;;;1553   
;;;1554               /* print key */
;;;1555               if (!print_string_ptr((unsigned char*)child->string, p))
;;;1556               {
;;;1557                   return NULL;
;;;1558               }
;;;1559               p->offset = update(p);
;;;1560   
;;;1561               len = fmt ? 2 : 1;
;;;1562               ptr = ensure(p, len);
;;;1563               if (!ptr)
;;;1564               {
;;;1565                   return NULL;
;;;1566               }
;;;1567               *ptr++ = ':';
;;;1568               if (fmt)
;;;1569               {
;;;1570                   *ptr++ = '\t';
;;;1571               }
;;;1572               p->offset+=len;
;;;1573   
;;;1574               /* print value */
;;;1575               if (!print_value(child, depth, fmt, p))
;;;1576               {
;;;1577                   return NULL;
;;;1578               };
;;;1579               p->offset = update(p);
;;;1580   
;;;1581               /* print comma if not last */
;;;1582               len = (size_t) (fmt ? 1 : 0) + (child->next ? 1 : 0);
;;;1583               ptr = ensure(p, len + 1);
;;;1584               if (!ptr)
;;;1585               {
;;;1586                   return NULL;
;;;1587               }
;;;1588               if (child->next)
;;;1589               {
;;;1590                   *ptr++ = ',';
;;;1591               }
;;;1592   
;;;1593               if (fmt)
;;;1594               {
;;;1595                   *ptr++ = '\n';
;;;1596               }
;;;1597               *ptr = '\0';
;;;1598               p->offset += len;
;;;1599   
;;;1600               child = child->next;
;;;1601           }
;;;1602   
;;;1603           ptr = ensure(p, fmt ? (depth + 1) : 2);
;;;1604           if (!ptr)
;;;1605           {
;;;1606               return NULL;
;;;1607           }
;;;1608           if (fmt)
;;;1609           {
;;;1610               for (i = 0; i < (depth - 1); i++)
;;;1611               {
;;;1612                   *ptr++ = '\t';
;;;1613               }
;;;1614           }
;;;1615           *ptr++ = '}';
;;;1616           *ptr = '\0';
;;;1617           out = (p->buffer) + i;
;;;1618       }
;;;1619       else
;;;1620       {
;;;1621           /* Allocate space for the names and the objects */
;;;1622           entries = (unsigned char**)cJSON_malloc(numentries * sizeof(unsigned char*));
;;;1623           if (!entries)
;;;1624           {
;;;1625               return NULL;
;;;1626           }
;;;1627           names = (unsigned char**)cJSON_malloc(numentries * sizeof(unsigned char*));
;;;1628           if (!names)
;;;1629           {
;;;1630               cJSON_free(entries);
;;;1631               return NULL;
;;;1632           }
;;;1633           memset(entries, '\0', sizeof(unsigned char*) * numentries);
;;;1634           memset(names, '\0', sizeof(unsigned char*) * numentries);
;;;1635   
;;;1636           /* Collect all the results into our arrays: */
;;;1637           child = item->child;
;;;1638           depth++;
;;;1639           if (fmt)
;;;1640           {
;;;1641               len += depth;
;;;1642           }
;;;1643           while (child && !fail)
;;;1644           {
;;;1645               names[i] = str = print_string_ptr((unsigned char*)child->string, 0); /* print key */
;;;1646               entries[i++] = ret = print_value(child, depth, fmt, 0);
;;;1647               if (str && ret)
;;;1648               {
;;;1649                   len += strlen((char*)ret) + strlen((char*)str) + 2 + (fmt ? 2 + depth : 0);
;;;1650               }
;;;1651               else
;;;1652               {
;;;1653                   fail = true;
;;;1654               }
;;;1655               child = child->next;
;;;1656           }
;;;1657   
;;;1658           /* Try to allocate the output string */
;;;1659           if (!fail)
;;;1660           {
;;;1661               out = (unsigned char*)cJSON_malloc(len);
;;;1662           }
;;;1663           if (!out)
;;;1664           {
;;;1665               fail = true;
;;;1666           }
;;;1667   
;;;1668           /* Handle failure */
;;;1669           if (fail)
;;;1670           {
;;;1671               /* vPortFree all the printed keys and values */
;;;1672               for (i = 0; i < numentries; i++)
;;;1673               {
;;;1674                   if (names[i])
;;;1675                   {
;;;1676                       cJSON_free(names[i]);
;;;1677                   }
;;;1678                   if (entries[i])
;;;1679                   {
;;;1680                       cJSON_free(entries[i]);
;;;1681                   }
;;;1682               }
;;;1683               cJSON_free(names);
;;;1684               cJSON_free(entries);
;;;1685               return NULL;
;;;1686           }
;;;1687   
;;;1688           /* Compose the output: */
;;;1689           *out = '{';
;;;1690           ptr = out + 1;
;;;1691           if (fmt)
;;;1692           {
;;;1693               *ptr++ = '\n';
;;;1694           }
;;;1695           *ptr = '\0';
;;;1696           for (i = 0; i < numentries; i++)
;;;1697           {
;;;1698               if (fmt)
;;;1699               {
;;;1700                   for (j = 0; j < depth; j++)
;;;1701                   {
;;;1702                       *ptr++='\t';
;;;1703                   }
;;;1704               }
;;;1705               tmplen = strlen((char*)names[i]);
;;;1706               memcpy(ptr, names[i], tmplen);
;;;1707               ptr += tmplen;
;;;1708               *ptr++ = ':';
;;;1709               if (fmt)
;;;1710               {
;;;1711                   *ptr++ = '\t';
;;;1712               }
;;;1713               strcpy((char*)ptr, (char*)entries[i]);
;;;1714               ptr += strlen((char*)entries[i]);
;;;1715               if (i != (numentries - 1))
;;;1716               {
;;;1717                   *ptr++ = ',';
;;;1718               }
;;;1719               if (fmt)
;;;1720               {
;;;1721                   *ptr++ = '\n';
;;;1722               }
;;;1723               *ptr = '\0';
;;;1724               cJSON_free(names[i]);
;;;1725               cJSON_free(entries[i]);
;;;1726           }
;;;1727   
;;;1728           cJSON_free(names);
;;;1729           cJSON_free(entries);
;;;1730           if (fmt)
;;;1731           {
;;;1732               for (i = 0; i < (depth - 1); i++)
;;;1733               {
;;;1734                   *ptr++ = '\t';
;;;1735               }
;;;1736           }
;;;1737           *ptr++ = '}';
;;;1738           *ptr++ = '\0';
;;;1739       }
;;;1740   
;;;1741       return out;
;;;1742   }
0015b4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5560|
0015b8  e59d4018          LDR      r4,[sp,#0x18]         ;1502
0015bc  e3a0007b          MOV      r0,#0x7b              ;1503
0015c0  e4c40001          STRB     r0,[r4],#1            ;1503
0015c4  e3560000          CMP      r6,#0                 ;1504
0015c8  0a000008          BEQ      |L1.5616|
0015cc  e3a0000a          MOV      r0,#0xa               ;1505
0015d0  e4c40001          STRB     r0,[r4],#1            ;1505
0015d4  e3a05000          MOV      r5,#0                 ;1506
0015d8  ea000002          B        |L1.5608|
                  |L1.5596|
0015dc  e3a00009          MOV      r0,#9                 ;1508
0015e0  e4c40001          STRB     r0,[r4],#1            ;1508
0015e4  e2855001          ADD      r5,r5,#1              ;1506
                  |L1.5608|
0015e8  e1550008          CMP      r5,r8                 ;1506
0015ec  3afffffa          BCC      |L1.5596|
                  |L1.5616|
0015f0  e3a0007d          MOV      r0,#0x7d              ;1511
0015f4  e4c40001          STRB     r0,[r4],#1            ;1511
0015f8  e3a00000          MOV      r0,#0                 ;1512
0015fc  e4c40001          STRB     r0,[r4],#1            ;1512
001600  e59d0018          LDR      r0,[sp,#0x18]         ;1514
001604  eaffffe9          B        |L1.5552|
                  |L1.5640|
001608  e3570000          CMP      r7,#0                 ;1517
00160c  0a0000a6          BEQ      |L1.6316|
001610  e5975008          LDR      r5,[r7,#8]            ;1520
001614  e3560000          CMP      r6,#0                 ;1521
001618  0a000001          BEQ      |L1.5668|
00161c  e3a00002          MOV      r0,#2                 ;1521
001620  ea000000          B        |L1.5672|
                  |L1.5668|
001624  e3a00001          MOV      r0,#1                 ;1521
                  |L1.5672|
001628  e1a0a000          MOV      r10,r0                ;1521
00162c  e28a1001          ADD      r1,r10,#1             ;1522
001630  e1a00007          MOV      r0,r7                 ;1522
001634  ebfffffe          BL       ensure
001638  e1a04000          MOV      r4,r0                 ;1522
00163c  e3540000          CMP      r4,#0                 ;1523
001640  1a000001          BNE      |L1.5708|
001644  e3a00000          MOV      r0,#0                 ;1525
001648  eaffffd8          B        |L1.5552|
                  |L1.5708|
00164c  e3a0007b          MOV      r0,#0x7b              ;1528
001650  e4c40001          STRB     r0,[r4],#1            ;1528
001654  e3560000          CMP      r6,#0                 ;1529
001658  0a000001          BEQ      |L1.5732|
00165c  e3a0000a          MOV      r0,#0xa               ;1531
001660  e4c40001          STRB     r0,[r4],#1            ;1531
                  |L1.5732|
001664  e3a00000          MOV      r0,#0                 ;1533
001668  e5c40000          STRB     r0,[r4,#0]            ;1533
00166c  e5970008          LDR      r0,[r7,#8]            ;1534
001670  e080000a          ADD      r0,r0,r10             ;1534
001674  e5870008          STR      r0,[r7,#8]            ;1534
001678  e59d0024          LDR      r0,[sp,#0x24]         ;1536
00167c  e5909008          LDR      r9,[r0,#8]            ;1536
001680  e2888001          ADD      r8,r8,#1              ;1537
001684  ea000067          B        |L1.6184|
                  |L1.5768|
001688  e3560000          CMP      r6,#0                 ;1540
00168c  0a000015          BEQ      |L1.5864|
001690  e1a01008          MOV      r1,r8                 ;1542
001694  e1a00007          MOV      r0,r7                 ;1542
001698  ebfffffe          BL       ensure
00169c  e1a04000          MOV      r4,r0                 ;1542
0016a0  e3540000          CMP      r4,#0                 ;1543
0016a4  1a000001          BNE      |L1.5808|
0016a8  e3a00000          MOV      r0,#0                 ;1545
0016ac  eaffffbf          B        |L1.5552|
                  |L1.5808|
0016b0  e3a00000          MOV      r0,#0                 ;1547
0016b4  e58d000c          STR      r0,[sp,#0xc]          ;1547
0016b8  ea000004          B        |L1.5840|
                  |L1.5820|
0016bc  e3a00009          MOV      r0,#9                 ;1549
0016c0  e4c40001          STRB     r0,[r4],#1            ;1549
0016c4  e59d000c          LDR      r0,[sp,#0xc]          ;1547
0016c8  e2800001          ADD      r0,r0,#1              ;1547
0016cc  e58d000c          STR      r0,[sp,#0xc]          ;1547
                  |L1.5840|
0016d0  e59d000c          LDR      r0,[sp,#0xc]          ;1547
0016d4  e1500008          CMP      r0,r8                 ;1547
0016d8  3afffff7          BCC      |L1.5820|
0016dc  e5970008          LDR      r0,[r7,#8]            ;1551
0016e0  e0800008          ADD      r0,r0,r8              ;1551
0016e4  e5870008          STR      r0,[r7,#8]            ;1551
                  |L1.5864|
0016e8  e1a01007          MOV      r1,r7                 ;1555
0016ec  e5990020          LDR      r0,[r9,#0x20]         ;1555
0016f0  ebfffffe          BL       print_string_ptr
0016f4  e3500000          CMP      r0,#0                 ;1555
0016f8  1a000001          BNE      |L1.5892|
0016fc  e3a00000          MOV      r0,#0                 ;1557
001700  eaffffaa          B        |L1.5552|
                  |L1.5892|
001704  e1a00007          MOV      r0,r7                 ;1559
001708  ebfffffe          BL       update
00170c  e5870008          STR      r0,[r7,#8]            ;1559
001710  e3560000          CMP      r6,#0                 ;1561
001714  0a000001          BEQ      |L1.5920|
001718  e3a00002          MOV      r0,#2                 ;1561
00171c  ea000000          B        |L1.5924|
                  |L1.5920|
001720  e3a00001          MOV      r0,#1                 ;1561
                  |L1.5924|
001724  e1a0a000          MOV      r10,r0                ;1561
001728  e1a0100a          MOV      r1,r10                ;1562
00172c  e1a00007          MOV      r0,r7                 ;1562
001730  ebfffffe          BL       ensure
001734  e1a04000          MOV      r4,r0                 ;1562
001738  e3540000          CMP      r4,#0                 ;1563
00173c  1a000001          BNE      |L1.5960|
001740  e3a00000          MOV      r0,#0                 ;1565
001744  eaffff99          B        |L1.5552|
                  |L1.5960|
001748  e3a0003a          MOV      r0,#0x3a              ;1567
00174c  e4c40001          STRB     r0,[r4],#1            ;1567
001750  e3560000          CMP      r6,#0                 ;1568
001754  0a000001          BEQ      |L1.5984|
001758  e3a00009          MOV      r0,#9                 ;1570
00175c  e4c40001          STRB     r0,[r4],#1            ;1570
                  |L1.5984|
001760  e5970008          LDR      r0,[r7,#8]            ;1572
001764  e080000a          ADD      r0,r0,r10             ;1572
001768  e5870008          STR      r0,[r7,#8]            ;1572
00176c  e1a03007          MOV      r3,r7                 ;1575
001770  e1a02006          MOV      r2,r6                 ;1575
001774  e1a01008          MOV      r1,r8                 ;1575
001778  e1a00009          MOV      r0,r9                 ;1575
00177c  ebfffffe          BL       print_value
001780  e3500000          CMP      r0,#0                 ;1575
001784  1a000001          BNE      |L1.6032|
001788  e3a00000          MOV      r0,#0                 ;1577
00178c  eaffff87          B        |L1.5552|
                  |L1.6032|
001790  e1a00007          MOV      r0,r7                 ;1579
001794  ebfffffe          BL       update
001798  e5870008          STR      r0,[r7,#8]            ;1579
00179c  e3560000          CMP      r6,#0                 ;1582
0017a0  0a000001          BEQ      |L1.6060|
0017a4  e3a00001          MOV      r0,#1                 ;1582
0017a8  ea000000          B        |L1.6064|
                  |L1.6060|
0017ac  e3a00000          MOV      r0,#0                 ;1582
                  |L1.6064|
0017b0  e5991000          LDR      r1,[r9,#0]            ;1582
0017b4  e3510000          CMP      r1,#0                 ;1582
0017b8  0a000001          BEQ      |L1.6084|
0017bc  e3a01001          MOV      r1,#1                 ;1582
0017c0  ea000000          B        |L1.6088|
                  |L1.6084|
0017c4  e3a01000          MOV      r1,#0                 ;1582
                  |L1.6088|
0017c8  e080a001          ADD      r10,r0,r1             ;1582
0017cc  e28a1001          ADD      r1,r10,#1             ;1583
0017d0  e1a00007          MOV      r0,r7                 ;1583
0017d4  ebfffffe          BL       ensure
0017d8  e1a04000          MOV      r4,r0                 ;1583
0017dc  e3540000          CMP      r4,#0                 ;1584
0017e0  1a000001          BNE      |L1.6124|
0017e4  e3a00000          MOV      r0,#0                 ;1586
0017e8  eaffff70          B        |L1.5552|
                  |L1.6124|
0017ec  e5990000          LDR      r0,[r9,#0]            ;1588
0017f0  e3500000          CMP      r0,#0                 ;1588
0017f4  0a000001          BEQ      |L1.6144|
0017f8  e3a0002c          MOV      r0,#0x2c              ;1590
0017fc  e4c40001          STRB     r0,[r4],#1            ;1590
                  |L1.6144|
001800  e3560000          CMP      r6,#0                 ;1593
001804  0a000001          BEQ      |L1.6160|
001808  e3a0000a          MOV      r0,#0xa               ;1595
00180c  e4c40001          STRB     r0,[r4],#1            ;1595
                  |L1.6160|
001810  e3a00000          MOV      r0,#0                 ;1597
001814  e5c40000          STRB     r0,[r4,#0]            ;1597
001818  e5970008          LDR      r0,[r7,#8]            ;1598
00181c  e080000a          ADD      r0,r0,r10             ;1598
001820  e5870008          STR      r0,[r7,#8]            ;1598
001824  e5999000          LDR      r9,[r9,#0]            ;1600
                  |L1.6184|
001828  e3590000          CMP      r9,#0                 ;1538
00182c  1affff95          BNE      |L1.5768|
001830  e3560000          CMP      r6,#0                 ;1603
001834  0a000001          BEQ      |L1.6208|
001838  e2880001          ADD      r0,r8,#1              ;1603
00183c  ea000000          B        |L1.6212|
                  |L1.6208|
001840  e3a00002          MOV      r0,#2                 ;1603
                  |L1.6212|
001844  e1a01000          MOV      r1,r0                 ;1603
001848  e1a00007          MOV      r0,r7                 ;1603
00184c  ebfffffe          BL       ensure
001850  e1a04000          MOV      r4,r0                 ;1603
001854  e3540000          CMP      r4,#0                 ;1604
001858  1a000001          BNE      |L1.6244|
00185c  e3a00000          MOV      r0,#0                 ;1606
001860  eaffff52          B        |L1.5552|
                  |L1.6244|
001864  e3560000          CMP      r6,#0                 ;1608
001868  0a000007          BEQ      |L1.6284|
00186c  e3a05000          MOV      r5,#0                 ;1610
001870  ea000002          B        |L1.6272|
                  |L1.6260|
001874  e3a00009          MOV      r0,#9                 ;1612
001878  e4c40001          STRB     r0,[r4],#1            ;1612
00187c  e2855001          ADD      r5,r5,#1              ;1610
                  |L1.6272|
001880  e2480001          SUB      r0,r8,#1              ;1610
001884  e1500005          CMP      r0,r5                 ;1610
001888  8afffff9          BHI      |L1.6260|
                  |L1.6284|
00188c  e3a0007d          MOV      r0,#0x7d              ;1615
001890  e4c40001          STRB     r0,[r4],#1            ;1615
001894  e3a00000          MOV      r0,#0                 ;1616
001898  e5c40000          STRB     r0,[r4,#0]            ;1616
00189c  e5970000          LDR      r0,[r7,#0]            ;1617
0018a0  e0800005          ADD      r0,r0,r5              ;1617
0018a4  e58d0018          STR      r0,[sp,#0x18]         ;1617
0018a8  ea0000ea          B        |L1.7256|
                  |L1.6316|
0018ac  e59d1008          LDR      r1,[sp,#8]            ;1622
0018b0  e1a00101          LSL      r0,r1,#2              ;1622
0018b4  e59f179c          LDR      r1,|L1.8280|
0018b8  e5911000          LDR      r1,[r1,#0]            ;1622  ; cJSON_malloc
0018bc  e12fff31          BLX      r1                    ;1622
0018c0  e58d0020          STR      r0,[sp,#0x20]         ;1622
0018c4  e59d0020          LDR      r0,[sp,#0x20]         ;1623
0018c8  e3500000          CMP      r0,#0                 ;1623
0018cc  1a000001          BNE      |L1.6360|
0018d0  e3a00000          MOV      r0,#0                 ;1625
0018d4  eaffff35          B        |L1.5552|
                  |L1.6360|
0018d8  e59d1008          LDR      r1,[sp,#8]            ;1627
0018dc  e1a00101          LSL      r0,r1,#2              ;1627
0018e0  e59f1770          LDR      r1,|L1.8280|
0018e4  e5911000          LDR      r1,[r1,#0]            ;1627  ; cJSON_malloc
0018e8  e12fff31          BLX      r1                    ;1627
0018ec  e58d001c          STR      r0,[sp,#0x1c]         ;1627
0018f0  e59d001c          LDR      r0,[sp,#0x1c]         ;1628
0018f4  e3500000          CMP      r0,#0                 ;1628
0018f8  1a000005          BNE      |L1.6420|
0018fc  e59f1758          LDR      r1,|L1.8284|
001900  e59d0020          LDR      r0,[sp,#0x20]         ;1630
001904  e5911000          LDR      r1,[r1,#0]            ;1630  ; cJSON_free
001908  e12fff31          BLX      r1                    ;1630
00190c  e3a00000          MOV      r0,#0                 ;1631
001910  eaffff26          B        |L1.5552|
                  |L1.6420|
001914  e59d0008          LDR      r0,[sp,#8]            ;1633
001918  e1a01100          LSL      r1,r0,#2              ;1633
00191c  e59d0020          LDR      r0,[sp,#0x20]         ;1633
001920  ebfffffe          BL       __aeabi_memclr4
001924  e59d0008          LDR      r0,[sp,#8]            ;1634
001928  e1a01100          LSL      r1,r0,#2              ;1634
00192c  e59d001c          LDR      r0,[sp,#0x1c]         ;1634
001930  ebfffffe          BL       __aeabi_memclr4
001934  e59d0024          LDR      r0,[sp,#0x24]         ;1637
001938  e5909008          LDR      r9,[r0,#8]            ;1637
00193c  e2888001          ADD      r8,r8,#1              ;1638
001940  e3560000          CMP      r6,#0                 ;1639
001944  0a000000          BEQ      |L1.6476|
001948  e08aa008          ADD      r10,r10,r8            ;1641
                  |L1.6476|
00194c  ea000027          B        |L1.6640|
                  |L1.6480|
001950  e3a01000          MOV      r1,#0                 ;1645
001954  e5990020          LDR      r0,[r9,#0x20]         ;1645
001958  ebfffffe          BL       print_string_ptr
00195c  e58d0010          STR      r0,[sp,#0x10]         ;1645
001960  e59d101c          LDR      r1,[sp,#0x1c]         ;1645
001964  e7810105          STR      r0,[r1,r5,LSL #2]     ;1645
001968  e3a03000          MOV      r3,#0                 ;1646
00196c  e1a02006          MOV      r2,r6                 ;1646
001970  e1a01008          MOV      r1,r8                 ;1646
001974  e1a00009          MOV      r0,r9                 ;1646
001978  ebfffffe          BL       print_value
00197c  e1a01005          MOV      r1,r5                 ;1646
001980  e2855001          ADD      r5,r5,#1              ;1646
001984  e58d0014          STR      r0,[sp,#0x14]         ;1646
001988  e59d2020          LDR      r2,[sp,#0x20]         ;1646
00198c  e7820101          STR      r0,[r2,r1,LSL #2]     ;1646
001990  e59d0010          LDR      r0,[sp,#0x10]         ;1647
001994  e3500000          CMP      r0,#0                 ;1647
001998  0a000011          BEQ      |L1.6628|
00199c  e59d0014          LDR      r0,[sp,#0x14]         ;1647
0019a0  e3500000          CMP      r0,#0                 ;1647
0019a4  0a00000e          BEQ      |L1.6628|
0019a8  e59d0014          LDR      r0,[sp,#0x14]         ;1649
0019ac  ebfffffe          BL       strlen
0019b0  e1a0b000          MOV      r11,r0                ;1649
0019b4  e59d0010          LDR      r0,[sp,#0x10]         ;1649
0019b8  ebfffffe          BL       strlen
0019bc  e080000b          ADD      r0,r0,r11             ;1649
0019c0  e2801002          ADD      r1,r0,#2              ;1649
0019c4  e3560000          CMP      r6,#0                 ;1649
0019c8  0a000001          BEQ      |L1.6612|
0019cc  e2880002          ADD      r0,r8,#2              ;1649
0019d0  ea000000          B        |L1.6616|
                  |L1.6612|
0019d4  e3a00000          MOV      r0,#0                 ;1649
                  |L1.6616|
0019d8  e0800001          ADD      r0,r0,r1              ;1649
0019dc  e08aa000          ADD      r10,r10,r0            ;1649
0019e0  ea000001          B        |L1.6636|
                  |L1.6628|
0019e4  e3a00001          MOV      r0,#1                 ;1653
0019e8  e58d0004          STR      r0,[sp,#4]            ;1653
                  |L1.6636|
0019ec  e5999000          LDR      r9,[r9,#0]            ;1655
                  |L1.6640|
0019f0  e3590000          CMP      r9,#0                 ;1643
0019f4  0a000002          BEQ      |L1.6660|
0019f8  e59d0004          LDR      r0,[sp,#4]            ;1643
0019fc  e3500000          CMP      r0,#0                 ;1643
001a00  0affffd2          BEQ      |L1.6480|
                  |L1.6660|
001a04  e59d0004          LDR      r0,[sp,#4]            ;1659
001a08  e3500000          CMP      r0,#0                 ;1659
001a0c  1a000004          BNE      |L1.6692|
001a10  e1a0000a          MOV      r0,r10                ;1661
001a14  e59f163c          LDR      r1,|L1.8280|
001a18  e5911000          LDR      r1,[r1,#0]            ;1661  ; cJSON_malloc
001a1c  e12fff31          BLX      r1                    ;1661
001a20  e58d0018          STR      r0,[sp,#0x18]         ;1661
                  |L1.6692|
001a24  e59d0018          LDR      r0,[sp,#0x18]         ;1663
001a28  e3500000          CMP      r0,#0                 ;1663
001a2c  1a000001          BNE      |L1.6712|
001a30  e3a00001          MOV      r0,#1                 ;1665
001a34  e58d0004          STR      r0,[sp,#4]            ;1665
                  |L1.6712|
001a38  e59d0004          LDR      r0,[sp,#4]            ;1669
001a3c  e3500000          CMP      r0,#0                 ;1669
001a40  0a000021          BEQ      |L1.6860|
001a44  e3a05000          MOV      r5,#0                 ;1672
001a48  ea000012          B        |L1.6808|
                  |L1.6732|
001a4c  e59d001c          LDR      r0,[sp,#0x1c]         ;1674
001a50  e7900105          LDR      r0,[r0,r5,LSL #2]     ;1674
001a54  e3500000          CMP      r0,#0                 ;1674
001a58  0a000004          BEQ      |L1.6768|
001a5c  e59d101c          LDR      r1,[sp,#0x1c]         ;1676
001a60  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1676
001a64  e59f15f0          LDR      r1,|L1.8284|
001a68  e5911000          LDR      r1,[r1,#0]            ;1676  ; cJSON_free
001a6c  e12fff31          BLX      r1                    ;1676
                  |L1.6768|
001a70  e59d0020          LDR      r0,[sp,#0x20]         ;1678
001a74  e7900105          LDR      r0,[r0,r5,LSL #2]     ;1678
001a78  e3500000          CMP      r0,#0                 ;1678
001a7c  0a000004          BEQ      |L1.6804|
001a80  e59d1020          LDR      r1,[sp,#0x20]         ;1680
001a84  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1680
001a88  e59f15cc          LDR      r1,|L1.8284|
001a8c  e5911000          LDR      r1,[r1,#0]            ;1680  ; cJSON_free
001a90  e12fff31          BLX      r1                    ;1680
                  |L1.6804|
001a94  e2855001          ADD      r5,r5,#1              ;1672
                  |L1.6808|
001a98  e59d0008          LDR      r0,[sp,#8]            ;1672
001a9c  e1550000          CMP      r5,r0                 ;1672
001aa0  3affffe9          BCC      |L1.6732|
001aa4  e59f15b0          LDR      r1,|L1.8284|
001aa8  e59d001c          LDR      r0,[sp,#0x1c]         ;1683
001aac  e5911000          LDR      r1,[r1,#0]            ;1683  ; cJSON_free
001ab0  e12fff31          BLX      r1                    ;1683
001ab4  e59f15a0          LDR      r1,|L1.8284|
001ab8  e59d0020          LDR      r0,[sp,#0x20]         ;1684
001abc  e5911000          LDR      r1,[r1,#0]            ;1684  ; cJSON_free
001ac0  e12fff31          BLX      r1                    ;1684
001ac4  e3a00000          MOV      r0,#0                 ;1685
001ac8  eafffeb8          B        |L1.5552|
                  |L1.6860|
001acc  e3a0107b          MOV      r1,#0x7b              ;1689
001ad0  e59d0018          LDR      r0,[sp,#0x18]         ;1689
001ad4  e5c01000          STRB     r1,[r0,#0]            ;1689
001ad8  e59d0018          LDR      r0,[sp,#0x18]         ;1690
001adc  e2804001          ADD      r4,r0,#1              ;1690
001ae0  e3560000          CMP      r6,#0                 ;1691
001ae4  0a000001          BEQ      |L1.6896|
001ae8  e3a0000a          MOV      r0,#0xa               ;1693
001aec  e4c40001          STRB     r0,[r4],#1            ;1693
                  |L1.6896|
001af0  e3a00000          MOV      r0,#0                 ;1695
001af4  e5c40000          STRB     r0,[r4,#0]            ;1695
001af8  e3a05000          MOV      r5,#0                 ;1696
001afc  ea00003c          B        |L1.7156|
                  |L1.6912|
001b00  e3560000          CMP      r6,#0                 ;1698
001b04  0a00000a          BEQ      |L1.6964|
001b08  e3a00000          MOV      r0,#0                 ;1700
001b0c  e58d000c          STR      r0,[sp,#0xc]          ;1700
001b10  ea000004          B        |L1.6952|
                  |L1.6932|
001b14  e3a00009          MOV      r0,#9                 ;1702
001b18  e4c40001          STRB     r0,[r4],#1            ;1702
001b1c  e59d000c          LDR      r0,[sp,#0xc]          ;1700
001b20  e2800001          ADD      r0,r0,#1              ;1700
001b24  e58d000c          STR      r0,[sp,#0xc]          ;1700
                  |L1.6952|
001b28  e59d000c          LDR      r0,[sp,#0xc]          ;1700
001b2c  e1500008          CMP      r0,r8                 ;1700
001b30  3afffff7          BCC      |L1.6932|
                  |L1.6964|
001b34  e59d101c          LDR      r1,[sp,#0x1c]         ;1705
001b38  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1705
001b3c  ebfffffe          BL       strlen
001b40  e58d0000          STR      r0,[sp,#0]            ;1705
001b44  e59d001c          LDR      r0,[sp,#0x1c]         ;1706
001b48  e7901105          LDR      r1,[r0,r5,LSL #2]     ;1706
001b4c  e1a00004          MOV      r0,r4                 ;1706
001b50  e59d2000          LDR      r2,[sp,#0]            ;1706
001b54  ebfffffe          BL       __aeabi_memcpy
001b58  e59d0000          LDR      r0,[sp,#0]            ;1707
001b5c  e0844000          ADD      r4,r4,r0              ;1707
001b60  e3a0003a          MOV      r0,#0x3a              ;1708
001b64  e4c40001          STRB     r0,[r4],#1            ;1708
001b68  e3560000          CMP      r6,#0                 ;1709
001b6c  0a000001          BEQ      |L1.7032|
001b70  e3a00009          MOV      r0,#9                 ;1711
001b74  e4c40001          STRB     r0,[r4],#1            ;1711
                  |L1.7032|
001b78  e59d0020          LDR      r0,[sp,#0x20]         ;1713
001b7c  e7901105          LDR      r1,[r0,r5,LSL #2]     ;1713
001b80  e1a00004          MOV      r0,r4                 ;1713
001b84  ebfffffe          BL       strcpy
001b88  e59d1020          LDR      r1,[sp,#0x20]         ;1714
001b8c  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1714
001b90  ebfffffe          BL       strlen
001b94  e0844000          ADD      r4,r4,r0              ;1714
001b98  e59d0008          LDR      r0,[sp,#8]            ;1715
001b9c  e2400001          SUB      r0,r0,#1              ;1715
001ba0  e1500005          CMP      r0,r5                 ;1715
001ba4  0a000001          BEQ      |L1.7088|
001ba8  e3a0002c          MOV      r0,#0x2c              ;1717
001bac  e4c40001          STRB     r0,[r4],#1            ;1717
                  |L1.7088|
001bb0  e3560000          CMP      r6,#0                 ;1719
001bb4  0a000001          BEQ      |L1.7104|
001bb8  e3a0000a          MOV      r0,#0xa               ;1721
001bbc  e4c40001          STRB     r0,[r4],#1            ;1721
                  |L1.7104|
001bc0  e3a00000          MOV      r0,#0                 ;1723
001bc4  e5c40000          STRB     r0,[r4,#0]            ;1723
001bc8  e59d101c          LDR      r1,[sp,#0x1c]         ;1724
001bcc  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1724
001bd0  e59f1484          LDR      r1,|L1.8284|
001bd4  e5911000          LDR      r1,[r1,#0]            ;1724  ; cJSON_free
001bd8  e12fff31          BLX      r1                    ;1724
001bdc  e59d1020          LDR      r1,[sp,#0x20]         ;1725
001be0  e7910105          LDR      r0,[r1,r5,LSL #2]     ;1725
001be4  e59f1470          LDR      r1,|L1.8284|
001be8  e5911000          LDR      r1,[r1,#0]            ;1725  ; cJSON_free
001bec  e12fff31          BLX      r1                    ;1725
001bf0  e2855001          ADD      r5,r5,#1              ;1696
                  |L1.7156|
001bf4  e59d0008          LDR      r0,[sp,#8]            ;1696
001bf8  e1550000          CMP      r5,r0                 ;1696
001bfc  3affffbf          BCC      |L1.6912|
001c00  e59f1454          LDR      r1,|L1.8284|
001c04  e59d001c          LDR      r0,[sp,#0x1c]         ;1728
001c08  e5911000          LDR      r1,[r1,#0]            ;1728  ; cJSON_free
001c0c  e12fff31          BLX      r1                    ;1728
001c10  e59f1444          LDR      r1,|L1.8284|
001c14  e59d0020          LDR      r0,[sp,#0x20]         ;1729
001c18  e5911000          LDR      r1,[r1,#0]            ;1729  ; cJSON_free
001c1c  e12fff31          BLX      r1                    ;1729
001c20  e3560000          CMP      r6,#0                 ;1730
001c24  0a000007          BEQ      |L1.7240|
001c28  e3a05000          MOV      r5,#0                 ;1732
001c2c  ea000002          B        |L1.7228|
                  |L1.7216|
001c30  e3a00009          MOV      r0,#9                 ;1734
001c34  e4c40001          STRB     r0,[r4],#1            ;1734
001c38  e2855001          ADD      r5,r5,#1              ;1732
                  |L1.7228|
001c3c  e2480001          SUB      r0,r8,#1              ;1732
001c40  e1500005          CMP      r0,r5                 ;1732
001c44  8afffff9          BHI      |L1.7216|
                  |L1.7240|
001c48  e3a0007d          MOV      r0,#0x7d              ;1737
001c4c  e4c40001          STRB     r0,[r4],#1            ;1737
001c50  e3a00000          MOV      r0,#0                 ;1738
001c54  e4c40001          STRB     r0,[r4],#1            ;1738
                  |L1.7256|
001c58  e59d0018          LDR      r0,[sp,#0x18]         ;1741
001c5c  eafffe53          B        |L1.5552|
;;;1743   
                          ENDP

                  print_array PROC
;;;1199   /* Render an array to text */
;;;1200   static unsigned char *print_array(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)
001c60  e92d4fff          PUSH     {r0-r11,lr}
;;;1201   {
001c64  e24dd014          SUB      sp,sp,#0x14
001c68  e1a0a002          MOV      r10,r2
001c6c  e1a06003          MOV      r6,r3
;;;1202       unsigned char **entries;
;;;1203       unsigned char *out = NULL;
001c70  e3a0b000          MOV      r11,#0
;;;1204       unsigned char *ptr = NULL;
001c74  e3a04000          MOV      r4,#0
;;;1205       unsigned char *ret = NULL;
001c78  e3a00000          MOV      r0,#0
001c7c  e58d0010          STR      r0,[sp,#0x10]
;;;1206       size_t len = 5;
001c80  e3a00005          MOV      r0,#5
001c84  e58d000c          STR      r0,[sp,#0xc]
;;;1207       cJSON *child = item->child;
001c88  e59d0014          LDR      r0,[sp,#0x14]
001c8c  e5908008          LDR      r8,[r0,#8]
;;;1208       size_t numentries = 0;
001c90  e3a09000          MOV      r9,#0
;;;1209       size_t i = 0;
001c94  e3a05000          MOV      r5,#0
;;;1210       cjbool fail = false;
001c98  e3a00000          MOV      r0,#0
001c9c  e58d0008          STR      r0,[sp,#8]
;;;1211       size_t tmplen = 0;
001ca0  e58d0004          STR      r0,[sp,#4]
;;;1212   
;;;1213       /* How many entries in the array? */
;;;1214       while (child)
001ca4  ea000001          B        |L1.7344|
                  |L1.7336|
;;;1215       {
;;;1216           numentries++;
001ca8  e2899001          ADD      r9,r9,#1
;;;1217           child = child->next;
001cac  e5988000          LDR      r8,[r8,#0]
                  |L1.7344|
001cb0  e3580000          CMP      r8,#0                 ;1214
001cb4  1afffffb          BNE      |L1.7336|
;;;1218       }
;;;1219   
;;;1220       /* Explicitly handle numentries == 0 */
;;;1221       if (!numentries)
001cb8  e3590000          CMP      r9,#0
001cbc  1a000013          BNE      |L1.7440|
;;;1222       {
;;;1223           if (p)
001cc0  e3560000          CMP      r6,#0
001cc4  0a000004          BEQ      |L1.7388|
;;;1224           {
;;;1225               out = ensure(p, 3);
001cc8  e3a01003          MOV      r1,#3
001ccc  e1a00006          MOV      r0,r6
001cd0  ebfffffe          BL       ensure
001cd4  e1a0b000          MOV      r11,r0
001cd8  ea000004          B        |L1.7408|
                  |L1.7388|
;;;1226           }
;;;1227           else
;;;1228           {
;;;1229               out = (unsigned char*)cJSON_malloc(3);
001cdc  e3a00003          MOV      r0,#3
001ce0  e59f1370          LDR      r1,|L1.8280|
001ce4  e5911000          LDR      r1,[r1,#0]  ; cJSON_malloc
001ce8  e12fff31          BLX      r1
001cec  e1a0b000          MOV      r11,r0
                  |L1.7408|
;;;1230           }
;;;1231           if (out)
001cf0  e35b0000          CMP      r11,#0
001cf4  0a000002          BEQ      |L1.7428|
;;;1232           {
;;;1233               strcpy((char*)out, "[]");
001cf8  e28f1e36          ADR      r1,|L1.8288|
001cfc  e1a0000b          MOV      r0,r11
001d00  ebfffffe          BL       strcpy
                  |L1.7428|
;;;1234           }
;;;1235   
;;;1236           return out;
001d04  e1a0000b          MOV      r0,r11
                  |L1.7432|
001d08  e28dd024          ADD      sp,sp,#0x24
;;;1237       }
;;;1238   
;;;1239       if (p)
;;;1240       {
;;;1241           /* Compose the output array. */
;;;1242           /* opening square bracket */
;;;1243           i = p->offset;
;;;1244           ptr = ensure(p, 1);
;;;1245           if (!ptr)
;;;1246           {
;;;1247               return NULL;
;;;1248           }
;;;1249           *ptr = '[';
;;;1250           p->offset++;
;;;1251   
;;;1252           child = item->child;
;;;1253           while (child && !fail)
;;;1254           {
;;;1255               if (!print_value(child, depth + 1, fmt, p))
;;;1256               {
;;;1257                   return NULL;
;;;1258               }
;;;1259               p->offset = update(p);
;;;1260               if (child->next)
;;;1261               {
;;;1262                   len = fmt ? 2 : 1;
;;;1263                   ptr = ensure(p, len + 1);
;;;1264                   if (!ptr)
;;;1265                   {
;;;1266                       return NULL;
;;;1267                   }
;;;1268                   *ptr++ = ',';
;;;1269                   if(fmt)
;;;1270                   {
;;;1271                       *ptr++ = ' ';
;;;1272                   }
;;;1273                   *ptr = '\0';
;;;1274                   p->offset += len;
;;;1275               }
;;;1276               child = child->next;
;;;1277           }
;;;1278           ptr = ensure(p, 2);
;;;1279           if (!ptr)
;;;1280           {
;;;1281               return NULL;
;;;1282           }
;;;1283           *ptr++ = ']';
;;;1284           *ptr = '\0';
;;;1285           out = (p->buffer) + i;
;;;1286       }
;;;1287       else
;;;1288       {
;;;1289           /* Allocate an array to hold the pointers to all printed values */
;;;1290           entries = (unsigned char**)cJSON_malloc(numentries * sizeof(unsigned char*));
;;;1291           if (!entries)
;;;1292           {
;;;1293               return NULL;
;;;1294           }
;;;1295           memset(entries, '\0', numentries * sizeof(unsigned char*));
;;;1296   
;;;1297           /* Retrieve all the results: */
;;;1298           child = item->child;
;;;1299           while (child && !fail)
;;;1300           {
;;;1301               ret = print_value(child, depth + 1, fmt, 0);
;;;1302               entries[i++] = ret;
;;;1303               if (ret)
;;;1304               {
;;;1305                   len += strlen((char*)ret) + 2 + (fmt ? 1 : 0);
;;;1306               }
;;;1307               else
;;;1308               {
;;;1309                   fail = true;
;;;1310               }
;;;1311               child = child->next;
;;;1312           }
;;;1313   
;;;1314           /* If we didn't fail, try to (uint8_t *)pvPortMalloc the output string */
;;;1315           if (!fail)
;;;1316           {
;;;1317               out = (unsigned char*)cJSON_malloc(len);
;;;1318           }
;;;1319           /* If that fails, we fail. */
;;;1320           if (!out)
;;;1321           {
;;;1322               fail = true;
;;;1323           }
;;;1324   
;;;1325           /* Handle failure. */
;;;1326           if (fail)
;;;1327           {
;;;1328               /* vPortFree all the entries in the array */
;;;1329               for (i = 0; i < numentries; i++)
;;;1330               {
;;;1331                   if (entries[i])
;;;1332                   {
;;;1333                       cJSON_free(entries[i]);
;;;1334                   }
;;;1335               }
;;;1336               cJSON_free(entries);
;;;1337               return NULL;
;;;1338           }
;;;1339   
;;;1340           /* Compose the output array. */
;;;1341           *out='[';
;;;1342           ptr = out + 1;
;;;1343           *ptr = '\0';
;;;1344           for (i = 0; i < numentries; i++)
;;;1345           {
;;;1346               tmplen = strlen((char*)entries[i]);
;;;1347               memcpy(ptr, entries[i], tmplen);
;;;1348               ptr += tmplen;
;;;1349               if (i != (numentries - 1))
;;;1350               {
;;;1351                   *ptr++ = ',';
;;;1352                   if(fmt)
;;;1353                   {
;;;1354                       *ptr++ = ' ';
;;;1355                   }
;;;1356                   *ptr = '\0';
;;;1357               }
;;;1358               cJSON_free(entries[i]);
;;;1359           }
;;;1360           cJSON_free(entries);
;;;1361           *ptr++ = ']';
;;;1362           *ptr++ = '\0';
;;;1363       }
;;;1364   
;;;1365       return out;
;;;1366   }
001d0c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.7440|
001d10  e3560000          CMP      r6,#0                 ;1239
001d14  0a000050          BEQ      |L1.7772|
001d18  e5965008          LDR      r5,[r6,#8]            ;1243
001d1c  e3a01001          MOV      r1,#1                 ;1244
001d20  e1a00006          MOV      r0,r6                 ;1244
001d24  ebfffffe          BL       ensure
001d28  e1a04000          MOV      r4,r0                 ;1244
001d2c  e3540000          CMP      r4,#0                 ;1245
001d30  1a000001          BNE      |L1.7484|
001d34  e3a00000          MOV      r0,#0                 ;1247
001d38  eafffff2          B        |L1.7432|
                  |L1.7484|
001d3c  e3a0005b          MOV      r0,#0x5b              ;1249
001d40  e5c40000          STRB     r0,[r4,#0]            ;1249
001d44  e5960008          LDR      r0,[r6,#8]            ;1250
001d48  e2800001          ADD      r0,r0,#1              ;1250
001d4c  e5860008          STR      r0,[r6,#8]            ;1250
001d50  e59d0014          LDR      r0,[sp,#0x14]         ;1252
001d54  e5908008          LDR      r8,[r0,#8]            ;1252
001d58  ea00002b          B        |L1.7692|
                  |L1.7516|
001d5c  e1a03006          MOV      r3,r6                 ;1255
001d60  e1a0200a          MOV      r2,r10                ;1255
001d64  e59d0018          LDR      r0,[sp,#0x18]         ;1255
001d68  e2801001          ADD      r1,r0,#1              ;1255
001d6c  e1a00008          MOV      r0,r8                 ;1255
001d70  ebfffffe          BL       print_value
001d74  e3500000          CMP      r0,#0                 ;1255
001d78  1a000001          BNE      |L1.7556|
001d7c  e3a00000          MOV      r0,#0                 ;1257
001d80  eaffffe0          B        |L1.7432|
                  |L1.7556|
001d84  e1a00006          MOV      r0,r6                 ;1259
001d88  ebfffffe          BL       update
001d8c  e5860008          STR      r0,[r6,#8]            ;1259
001d90  e5980000          LDR      r0,[r8,#0]            ;1260
001d94  e3500000          CMP      r0,#0                 ;1260
001d98  0a00001a          BEQ      |L1.7688|
001d9c  e35a0000          CMP      r10,#0                ;1262
001da0  0a000001          BEQ      |L1.7596|
001da4  e3a00002          MOV      r0,#2                 ;1262
001da8  ea000000          B        |L1.7600|
                  |L1.7596|
001dac  e3a00001          MOV      r0,#1                 ;1262
                  |L1.7600|
001db0  e58d000c          STR      r0,[sp,#0xc]          ;1262
001db4  e59d000c          LDR      r0,[sp,#0xc]          ;1263
001db8  e2801001          ADD      r1,r0,#1              ;1263
001dbc  e1a00006          MOV      r0,r6                 ;1263
001dc0  ebfffffe          BL       ensure
001dc4  e1a04000          MOV      r4,r0                 ;1263
001dc8  e3540000          CMP      r4,#0                 ;1264
001dcc  1a000001          BNE      |L1.7640|
001dd0  e3a00000          MOV      r0,#0                 ;1266
001dd4  eaffffcb          B        |L1.7432|
                  |L1.7640|
001dd8  e3a0002c          MOV      r0,#0x2c              ;1268
001ddc  e4c40001          STRB     r0,[r4],#1            ;1268
001de0  e35a0000          CMP      r10,#0                ;1269
001de4  0a000001          BEQ      |L1.7664|
001de8  e3a00020          MOV      r0,#0x20              ;1271
001dec  e4c40001          STRB     r0,[r4],#1            ;1271
                  |L1.7664|
001df0  e3a00000          MOV      r0,#0                 ;1273
001df4  e5c40000          STRB     r0,[r4,#0]            ;1273
001df8  e5961008          LDR      r1,[r6,#8]            ;1274
001dfc  e59d000c          LDR      r0,[sp,#0xc]          ;1274
001e00  e0800001          ADD      r0,r0,r1              ;1274
001e04  e5860008          STR      r0,[r6,#8]            ;1274
                  |L1.7688|
001e08  e5988000          LDR      r8,[r8,#0]            ;1276
                  |L1.7692|
001e0c  e3580000          CMP      r8,#0                 ;1253
001e10  0a000002          BEQ      |L1.7712|
001e14  e59d0008          LDR      r0,[sp,#8]            ;1253
001e18  e3500000          CMP      r0,#0                 ;1253
001e1c  0affffce          BEQ      |L1.7516|
                  |L1.7712|
001e20  e3a01002          MOV      r1,#2                 ;1278
001e24  e1a00006          MOV      r0,r6                 ;1278
001e28  ebfffffe          BL       ensure
001e2c  e1a04000          MOV      r4,r0                 ;1278
001e30  e3540000          CMP      r4,#0                 ;1279
001e34  1a000001          BNE      |L1.7744|
001e38  e3a00000          MOV      r0,#0                 ;1281
001e3c  eaffffb1          B        |L1.7432|
                  |L1.7744|
001e40  e3a0005d          MOV      r0,#0x5d              ;1283
001e44  e4c40001          STRB     r0,[r4],#1            ;1283
001e48  e3a00000          MOV      r0,#0                 ;1284
001e4c  e5c40000          STRB     r0,[r4,#0]            ;1284
001e50  e5960000          LDR      r0,[r6,#0]            ;1285
001e54  e080b005          ADD      r11,r0,r5             ;1285
001e58  ea00007c          B        |L1.8272|
                  |L1.7772|
001e5c  e1a00109          LSL      r0,r9,#2              ;1290
001e60  e59f11f0          LDR      r1,|L1.8280|
001e64  e5911000          LDR      r1,[r1,#0]            ;1290  ; cJSON_malloc
001e68  e12fff31          BLX      r1                    ;1290
001e6c  e1a07000          MOV      r7,r0                 ;1290
001e70  e3570000          CMP      r7,#0                 ;1291
001e74  1a000001          BNE      |L1.7808|
001e78  e3a00000          MOV      r0,#0                 ;1293
001e7c  eaffffa1          B        |L1.7432|
                  |L1.7808|
001e80  e1a01109          LSL      r1,r9,#2              ;1295
001e84  e1a00007          MOV      r0,r7                 ;1295
001e88  ebfffffe          BL       __aeabi_memclr4
001e8c  e59d0014          LDR      r0,[sp,#0x14]         ;1298
001e90  e5908008          LDR      r8,[r0,#8]            ;1298
001e94  ea00001d          B        |L1.7952|
                  |L1.7832|
001e98  e3a03000          MOV      r3,#0                 ;1301
001e9c  e1a0200a          MOV      r2,r10                ;1301
001ea0  e59d0018          LDR      r0,[sp,#0x18]         ;1301
001ea4  e2801001          ADD      r1,r0,#1              ;1301
001ea8  e1a00008          MOV      r0,r8                 ;1301
001eac  ebfffffe          BL       print_value
001eb0  e58d0010          STR      r0,[sp,#0x10]         ;1301
001eb4  e1a01005          MOV      r1,r5                 ;1302
001eb8  e2855001          ADD      r5,r5,#1              ;1302
001ebc  e59d0010          LDR      r0,[sp,#0x10]         ;1302
001ec0  e7870101          STR      r0,[r7,r1,LSL #2]     ;1302
001ec4  e59d0010          LDR      r0,[sp,#0x10]         ;1303
001ec8  e3500000          CMP      r0,#0                 ;1303
001ecc  0a00000c          BEQ      |L1.7940|
001ed0  e59d0010          LDR      r0,[sp,#0x10]         ;1305
001ed4  ebfffffe          BL       strlen
001ed8  e2800002          ADD      r0,r0,#2              ;1305
001edc  e35a0000          CMP      r10,#0                ;1305
001ee0  0a000001          BEQ      |L1.7916|
001ee4  e3a01001          MOV      r1,#1                 ;1305
001ee8  ea000000          B        |L1.7920|
                  |L1.7916|
001eec  e3a01000          MOV      r1,#0                 ;1305
                  |L1.7920|
001ef0  e0811000          ADD      r1,r1,r0              ;1305
001ef4  e59d000c          LDR      r0,[sp,#0xc]          ;1305
001ef8  e0800001          ADD      r0,r0,r1              ;1305
001efc  e58d000c          STR      r0,[sp,#0xc]          ;1305
001f00  ea000001          B        |L1.7948|
                  |L1.7940|
001f04  e3a00001          MOV      r0,#1                 ;1309
001f08  e58d0008          STR      r0,[sp,#8]            ;1309
                  |L1.7948|
001f0c  e5988000          LDR      r8,[r8,#0]            ;1311
                  |L1.7952|
001f10  e3580000          CMP      r8,#0                 ;1299
001f14  0a000002          BEQ      |L1.7972|
001f18  e59d0008          LDR      r0,[sp,#8]            ;1299
001f1c  e3500000          CMP      r0,#0                 ;1299
001f20  0affffdc          BEQ      |L1.7832|
                  |L1.7972|
001f24  e59d0008          LDR      r0,[sp,#8]            ;1315
001f28  e3500000          CMP      r0,#0                 ;1315
001f2c  1a000004          BNE      |L1.8004|
001f30  e59f1120          LDR      r1,|L1.8280|
001f34  e59d000c          LDR      r0,[sp,#0xc]          ;1317
001f38  e5911000          LDR      r1,[r1,#0]            ;1317  ; cJSON_malloc
001f3c  e12fff31          BLX      r1                    ;1317
001f40  e1a0b000          MOV      r11,r0                ;1317
                  |L1.8004|
001f44  e35b0000          CMP      r11,#0                ;1320
001f48  1a000001          BNE      |L1.8020|
001f4c  e3a00001          MOV      r0,#1                 ;1322
001f50  e58d0008          STR      r0,[sp,#8]            ;1322
                  |L1.8020|
001f54  e59d0008          LDR      r0,[sp,#8]            ;1326
001f58  e3500000          CMP      r0,#0                 ;1326
001f5c  0a000011          BEQ      |L1.8104|
001f60  e3a05000          MOV      r5,#0                 ;1329
001f64  ea000007          B        |L1.8072|
                  |L1.8040|
001f68  e7970105          LDR      r0,[r7,r5,LSL #2]     ;1331
001f6c  e3500000          CMP      r0,#0                 ;1331
001f70  0a000003          BEQ      |L1.8068|
001f74  e7970105          LDR      r0,[r7,r5,LSL #2]     ;1333
001f78  e59f10dc          LDR      r1,|L1.8284|
001f7c  e5911000          LDR      r1,[r1,#0]            ;1333  ; cJSON_free
001f80  e12fff31          BLX      r1                    ;1333
                  |L1.8068|
001f84  e2855001          ADD      r5,r5,#1              ;1329
                  |L1.8072|
001f88  e1550009          CMP      r5,r9                 ;1329
001f8c  3afffff5          BCC      |L1.8040|
001f90  e1a00007          MOV      r0,r7                 ;1336
001f94  e59f10c0          LDR      r1,|L1.8284|
001f98  e5911000          LDR      r1,[r1,#0]            ;1336  ; cJSON_free
001f9c  e12fff31          BLX      r1                    ;1336
001fa0  e3a00000          MOV      r0,#0                 ;1337
001fa4  eaffff57          B        |L1.7432|
                  |L1.8104|
001fa8  e3a0005b          MOV      r0,#0x5b              ;1341
001fac  e5cb0000          STRB     r0,[r11,#0]           ;1341
001fb0  e28b4001          ADD      r4,r11,#1             ;1342
001fb4  e3a00000          MOV      r0,#0                 ;1343
001fb8  e5c40000          STRB     r0,[r4,#0]            ;1343
001fbc  e3a05000          MOV      r5,#0                 ;1344
001fc0  ea000018          B        |L1.8232|
                  |L1.8132|
001fc4  e7970105          LDR      r0,[r7,r5,LSL #2]     ;1346
001fc8  ebfffffe          BL       strlen
001fcc  e58d0004          STR      r0,[sp,#4]            ;1346
001fd0  e7971105          LDR      r1,[r7,r5,LSL #2]     ;1347
001fd4  e1a00004          MOV      r0,r4                 ;1347
001fd8  e59d2004          LDR      r2,[sp,#4]            ;1347
001fdc  ebfffffe          BL       __aeabi_memcpy
001fe0  e59d0004          LDR      r0,[sp,#4]            ;1348
001fe4  e0844000          ADD      r4,r4,r0              ;1348
001fe8  e2490001          SUB      r0,r9,#1              ;1349
001fec  e1500005          CMP      r0,r5                 ;1349
001ff0  0a000007          BEQ      |L1.8212|
001ff4  e3a0002c          MOV      r0,#0x2c              ;1351
001ff8  e4c40001          STRB     r0,[r4],#1            ;1351
001ffc  e35a0000          CMP      r10,#0                ;1352
002000  0a000001          BEQ      |L1.8204|
002004  e3a00020          MOV      r0,#0x20              ;1354
002008  e4c40001          STRB     r0,[r4],#1            ;1354
                  |L1.8204|
00200c  e3a00000          MOV      r0,#0                 ;1356
002010  e5c40000          STRB     r0,[r4,#0]            ;1356
                  |L1.8212|
002014  e7970105          LDR      r0,[r7,r5,LSL #2]     ;1358
002018  e59f103c          LDR      r1,|L1.8284|
00201c  e5911000          LDR      r1,[r1,#0]            ;1358  ; cJSON_free
002020  e12fff31          BLX      r1                    ;1358
002024  e2855001          ADD      r5,r5,#1              ;1344
                  |L1.8232|
002028  e1550009          CMP      r5,r9                 ;1344
00202c  3affffe4          BCC      |L1.8132|
002030  e1a00007          MOV      r0,r7                 ;1360
002034  e59f1020          LDR      r1,|L1.8284|
002038  e5911000          LDR      r1,[r1,#0]            ;1360  ; cJSON_free
00203c  e12fff31          BLX      r1                    ;1360
002040  e3a0005d          MOV      r0,#0x5d              ;1361
002044  e4c40001          STRB     r0,[r4],#1            ;1361
002048  e3a00000          MOV      r0,#0                 ;1362
00204c  e4c40001          STRB     r0,[r4],#1            ;1362
                  |L1.8272|
002050  e1a0000b          MOV      r0,r11                ;1365
002054  eaffff2b          B        |L1.7432|
                  |L1.8280|
                          DCD      cJSON_malloc
                  |L1.8284|
                          DCD      cJSON_free
                  |L1.8288|
002060  5b5d00            DCB      "[]",0
002063  00                DCB      0
                          ENDP

                  print_value PROC
;;;1012   /* Render a value to text. */
;;;1013   static unsigned char *print_value(const cJSON *item, size_t depth, cjbool fmt, printbuffer *p)
002064  e92d47f0          PUSH     {r4-r10,lr}
;;;1014   {
002068  e1a04000          MOV      r4,r0
00206c  e1a08001          MOV      r8,r1
002070  e1a09002          MOV      r9,r2
002074  e1a05003          MOV      r5,r3
;;;1015       unsigned char *out = NULL;
002078  e3a06000          MOV      r6,#0
;;;1016   
;;;1017       if (!item)
00207c  e3540000          CMP      r4,#0
002080  1a000001          BNE      |L1.8332|
;;;1018       {
;;;1019           return NULL;
002084  e3a00000          MOV      r0,#0
                  |L1.8328|
;;;1020       }
;;;1021       if (p)
;;;1022       {
;;;1023           switch ((item->type) & 0xFF)
;;;1024           {
;;;1025               case cJSON_NULL:
;;;1026                   out = ensure(p, 5);
;;;1027                   if (out)
;;;1028                   {
;;;1029                       strcpy((char*)out, "null");
;;;1030                   }
;;;1031                   break;
;;;1032               case cJSON_False:
;;;1033                   out = ensure(p, 6);
;;;1034                   if (out)
;;;1035                   {
;;;1036                       strcpy((char*)out, "false");
;;;1037                   }
;;;1038                   break;
;;;1039               case cJSON_True:
;;;1040                   out = ensure(p, 5);
;;;1041                   if (out)
;;;1042                   {
;;;1043                       strcpy((char*)out, "true");
;;;1044                   }
;;;1045                   break;
;;;1046               case cJSON_Number:
;;;1047                   out = print_number(item, p);
;;;1048                   break;
;;;1049               case cJSON_Raw:
;;;1050               {
;;;1051                   size_t raw_length = 0;
;;;1052                   if (item->valuestring == NULL)
;;;1053                   {
;;;1054                       if (!p->noalloc)
;;;1055                       {
;;;1056                           cJSON_free(p->buffer);
;;;1057                       }
;;;1058                       out = NULL;
;;;1059                       break;
;;;1060                   }
;;;1061   
;;;1062                   raw_length = strlen(item->valuestring) + sizeof('\0');
;;;1063                   out = ensure(p, raw_length);
;;;1064                   if (out)
;;;1065                   {
;;;1066                       memcpy(out, item->valuestring, raw_length);
;;;1067                   }
;;;1068                   break;
;;;1069               }
;;;1070               case cJSON_String:
;;;1071                   out = print_string(item, p);
;;;1072                   break;
;;;1073               case cJSON_Array:
;;;1074                   out = print_array(item, depth, fmt, p);
;;;1075                   break;
;;;1076               case cJSON_Object:
;;;1077                   out = print_object(item, depth, fmt, p);
;;;1078                   break;
;;;1079               default:
;;;1080                   out = NULL;
;;;1081                   break;
;;;1082           }
;;;1083       }
;;;1084       else
;;;1085       {
;;;1086           switch ((item->type) & 0xFF)
;;;1087           {
;;;1088               case cJSON_NULL:
;;;1089                   out = cJSON_strdup((const unsigned char*)"null");
;;;1090                   break;
;;;1091               case cJSON_False:
;;;1092                   out = cJSON_strdup((const unsigned char*)"false");
;;;1093                   break;
;;;1094               case cJSON_True:
;;;1095                   out = cJSON_strdup((const unsigned char*)"true");
;;;1096                   break;
;;;1097               case cJSON_Number:
;;;1098                   out = print_number(item, 0);
;;;1099                   break;
;;;1100               case cJSON_Raw:
;;;1101                   out = cJSON_strdup((unsigned char*)item->valuestring);
;;;1102                   break;
;;;1103               case cJSON_String:
;;;1104                   out = print_string(item, 0);
;;;1105                   break;
;;;1106               case cJSON_Array:
;;;1107                   out = print_array(item, depth, fmt, 0);
;;;1108                   break;
;;;1109               case cJSON_Object:
;;;1110                   out = print_object(item, depth, fmt, 0);
;;;1111                   break;
;;;1112               default:
;;;1113                   out = NULL;
;;;1114                   break;
;;;1115           }
;;;1116       }
;;;1117   
;;;1118       return out;
;;;1119   }
002088  e8bd87f0          POP      {r4-r10,pc}
                  |L1.8332|
00208c  e3550000          CMP      r5,#0                 ;1021
002090  0a000070          BEQ      |L1.8792|
002094  e5d4000c          LDRB     r0,[r4,#0xc]          ;1023
002098  e3500010          CMP      r0,#0x10              ;1023
00209c  0a000053          BEQ      |L1.8688|
0020a0  ca000008          BGT      |L1.8392|
0020a4  e3500001          CMP      r0,#1                 ;1023
0020a8  0a000018          BEQ      |L1.8464|
0020ac  e3500002          CMP      r0,#2                 ;1023
0020b0  0a000021          BEQ      |L1.8508|
0020b4  e3500004          CMP      r0,#4                 ;1023
0020b8  0a000009          BEQ      |L1.8420|
0020bc  e3500008          CMP      r0,#8                 ;1023
0020c0  1a000060          BNE      |L1.8776|
0020c4  ea000027          B        |L1.8552|
                  |L1.8392|
0020c8  e3500020          CMP      r0,#0x20              ;1023
0020cc  0a00004d          BEQ      |L1.8712|
0020d0  e3500040          CMP      r0,#0x40              ;1023
0020d4  0a000053          BEQ      |L1.8744|
0020d8  e3500080          CMP      r0,#0x80              ;1023
0020dc  1a000059          BNE      |L1.8776|
0020e0  ea000026          B        |L1.8576|
                  |L1.8420|
0020e4  e1a00000          MOV      r0,r0                 ;1025
0020e8  e3a01005          MOV      r1,#5                 ;1026
0020ec  e1a00005          MOV      r0,r5                 ;1026
0020f0  ebfffffe          BL       ensure
0020f4  e1a06000          MOV      r6,r0                 ;1026
0020f8  e3560000          CMP      r6,#0                 ;1027
0020fc  0a000002          BEQ      |L1.8460|
002100  e51f1c50          LDR      r1,|L1.5304|
002104  e1a00006          MOV      r0,r6                 ;1029
002108  ebfffffe          BL       strcpy
                  |L1.8460|
00210c  ea000050          B        |L1.8788|
                  |L1.8464|
002110  e1a00000          MOV      r0,r0                 ;1032
002114  e3a01006          MOV      r1,#6                 ;1033
002118  e1a00005          MOV      r0,r5                 ;1033
00211c  ebfffffe          BL       ensure
002120  e1a06000          MOV      r6,r0                 ;1033
002124  e3560000          CMP      r6,#0                 ;1034
002128  0a000002          BEQ      |L1.8504|
00212c  e59f1dec          LDR      r1,|L1.12064|
002130  e1a00006          MOV      r0,r6                 ;1036
002134  ebfffffe          BL       strcpy
                  |L1.8504|
002138  ea000045          B        |L1.8788|
                  |L1.8508|
00213c  e1a00000          MOV      r0,r0                 ;1039
002140  e3a01005          MOV      r1,#5                 ;1040
002144  e1a00005          MOV      r0,r5                 ;1040
002148  ebfffffe          BL       ensure
00214c  e1a06000          MOV      r6,r0                 ;1040
002150  e3560000          CMP      r6,#0                 ;1041
002154  0a000002          BEQ      |L1.8548|
002158  e59f1dc4          LDR      r1,|L1.12068|
00215c  e1a00006          MOV      r0,r6                 ;1043
002160  ebfffffe          BL       strcpy
                  |L1.8548|
002164  ea00003a          B        |L1.8788|
                  |L1.8552|
002168  e1a00000          MOV      r0,r0                 ;1046
00216c  e1a01005          MOV      r1,r5                 ;1047
002170  e1a00004          MOV      r0,r4                 ;1047
002174  ebfffffe          BL       print_number
002178  e1a06000          MOV      r6,r0                 ;1047
00217c  ea000034          B        |L1.8788|
                  |L1.8576|
002180  e1a00000          MOV      r0,r0                 ;1049
002184  e3a07000          MOV      r7,#0                 ;1051
002188  e5940010          LDR      r0,[r4,#0x10]         ;1052
00218c  e3500000          CMP      r0,#0                 ;1052
002190  1a000008          BNE      |L1.8632|
002194  e595000c          LDR      r0,[r5,#0xc]          ;1054
002198  e3500000          CMP      r0,#0                 ;1054
00219c  1a000003          BNE      |L1.8624|
0021a0  e51f114c          LDR      r1,|L1.8284|
0021a4  e5950000          LDR      r0,[r5,#0]            ;1056
0021a8  e5911000          LDR      r1,[r1,#0]            ;1056  ; cJSON_free
0021ac  e12fff31          BLX      r1                    ;1056
                  |L1.8624|
0021b0  e3a06000          MOV      r6,#0                 ;1058
0021b4  ea000026          B        |L1.8788|
                  |L1.8632|
0021b8  e5940010          LDR      r0,[r4,#0x10]         ;1062
0021bc  ebfffffe          BL       strlen
0021c0  e2807004          ADD      r7,r0,#4              ;1062
0021c4  e1a01007          MOV      r1,r7                 ;1063
0021c8  e1a00005          MOV      r0,r5                 ;1063
0021cc  ebfffffe          BL       ensure
0021d0  e1a06000          MOV      r6,r0                 ;1063
0021d4  e3560000          CMP      r6,#0                 ;1064
0021d8  0a000003          BEQ      |L1.8684|
0021dc  e1a02007          MOV      r2,r7                 ;1066
0021e0  e1a00006          MOV      r0,r6                 ;1066
0021e4  e5941010          LDR      r1,[r4,#0x10]         ;1066
0021e8  ebfffffe          BL       __aeabi_memcpy
                  |L1.8684|
0021ec  ea000018          B        |L1.8788|
                  |L1.8688|
0021f0  e1a00000          MOV      r0,r0                 ;1070
0021f4  e1a01005          MOV      r1,r5                 ;1071
0021f8  e1a00004          MOV      r0,r4                 ;1071
0021fc  ebfffffe          BL       print_string
002200  e1a06000          MOV      r6,r0                 ;1071
002204  ea000012          B        |L1.8788|
                  |L1.8712|
002208  e1a00000          MOV      r0,r0                 ;1073
00220c  e1a03005          MOV      r3,r5                 ;1074
002210  e1a02009          MOV      r2,r9                 ;1074
002214  e1a01008          MOV      r1,r8                 ;1074
002218  e1a00004          MOV      r0,r4                 ;1074
00221c  ebfffffe          BL       print_array
002220  e1a06000          MOV      r6,r0                 ;1074
002224  ea00000a          B        |L1.8788|
                  |L1.8744|
002228  e1a00000          MOV      r0,r0                 ;1076
00222c  e1a03005          MOV      r3,r5                 ;1077
002230  e1a02009          MOV      r2,r9                 ;1077
002234  e1a01008          MOV      r1,r8                 ;1077
002238  e1a00004          MOV      r0,r4                 ;1077
00223c  ebfffffe          BL       print_object
002240  e1a06000          MOV      r6,r0                 ;1077
002244  ea000002          B        |L1.8788|
                  |L1.8776|
002248  e1a00000          MOV      r0,r0                 ;1079
00224c  e3a06000          MOV      r6,#0                 ;1080
002250  e1a00000          MOV      r0,r0                 ;1081
                  |L1.8788|
002254  ea000047          B        |L1.9080|
                  |L1.8792|
002258  e5d4000c          LDRB     r0,[r4,#0xc]          ;1086
00225c  e3500010          CMP      r0,#0x10              ;1086
002260  0a00002a          BEQ      |L1.8976|
002264  ca000008          BGT      |L1.8844|
002268  e3500001          CMP      r0,#1                 ;1086
00226c  0a000012          BEQ      |L1.8892|
002270  e3500002          CMP      r0,#2                 ;1086
002274  0a000015          BEQ      |L1.8912|
002278  e3500004          CMP      r0,#4                 ;1086
00227c  0a000009          BEQ      |L1.8872|
002280  e3500008          CMP      r0,#8                 ;1086
002284  1a000037          BNE      |L1.9064|
002288  ea000015          B        |L1.8932|
                  |L1.8844|
00228c  e3500020          CMP      r0,#0x20              ;1086
002290  0a000024          BEQ      |L1.9000|
002294  e3500040          CMP      r0,#0x40              ;1086
002298  0a00002a          BEQ      |L1.9032|
00229c  e3500080          CMP      r0,#0x80              ;1086
0022a0  1a000030          BNE      |L1.9064|
0022a4  ea000014          B        |L1.8956|
                  |L1.8872|
0022a8  e1a00000          MOV      r0,r0                 ;1088
0022ac  e51f0dfc          LDR      r0,|L1.5304|
0022b0  ebfffffe          BL       cJSON_strdup
0022b4  e1a06000          MOV      r6,r0                 ;1089
0022b8  ea00002d          B        |L1.9076|
                  |L1.8892|
0022bc  e1a00000          MOV      r0,r0                 ;1091
0022c0  e59f0c58          LDR      r0,|L1.12064|
0022c4  ebfffffe          BL       cJSON_strdup
0022c8  e1a06000          MOV      r6,r0                 ;1092
0022cc  ea000028          B        |L1.9076|
                  |L1.8912|
0022d0  e1a00000          MOV      r0,r0                 ;1094
0022d4  e59f0c48          LDR      r0,|L1.12068|
0022d8  ebfffffe          BL       cJSON_strdup
0022dc  e1a06000          MOV      r6,r0                 ;1095
0022e0  ea000023          B        |L1.9076|
                  |L1.8932|
0022e4  e1a00000          MOV      r0,r0                 ;1097
0022e8  e3a01000          MOV      r1,#0                 ;1098
0022ec  e1a00004          MOV      r0,r4                 ;1098
0022f0  ebfffffe          BL       print_number
0022f4  e1a06000          MOV      r6,r0                 ;1098
0022f8  ea00001d          B        |L1.9076|
                  |L1.8956|
0022fc  e1a00000          MOV      r0,r0                 ;1100
002300  e5940010          LDR      r0,[r4,#0x10]         ;1101
002304  ebfffffe          BL       cJSON_strdup
002308  e1a06000          MOV      r6,r0                 ;1101
00230c  ea000018          B        |L1.9076|
                  |L1.8976|
002310  e1a00000          MOV      r0,r0                 ;1103
002314  e3a01000          MOV      r1,#0                 ;1104
002318  e1a00004          MOV      r0,r4                 ;1104
00231c  ebfffffe          BL       print_string
002320  e1a06000          MOV      r6,r0                 ;1104
002324  ea000012          B        |L1.9076|
                  |L1.9000|
002328  e1a00000          MOV      r0,r0                 ;1106
00232c  e3a03000          MOV      r3,#0                 ;1107
002330  e1a02009          MOV      r2,r9                 ;1107
002334  e1a01008          MOV      r1,r8                 ;1107
002338  e1a00004          MOV      r0,r4                 ;1107
00233c  ebfffffe          BL       print_array
002340  e1a06000          MOV      r6,r0                 ;1107
002344  ea00000a          B        |L1.9076|
                  |L1.9032|
002348  e1a00000          MOV      r0,r0                 ;1109
00234c  e3a03000          MOV      r3,#0                 ;1110
002350  e1a02009          MOV      r2,r9                 ;1110
002354  e1a01008          MOV      r1,r8                 ;1110
002358  e1a00004          MOV      r0,r4                 ;1110
00235c  ebfffffe          BL       print_object
002360  e1a06000          MOV      r6,r0                 ;1110
002364  ea000002          B        |L1.9076|
                  |L1.9064|
002368  e1a00000          MOV      r0,r0                 ;1112
00236c  e3a06000          MOV      r6,#0                 ;1113
002370  e1a00000          MOV      r0,r0                 ;1114
                  |L1.9076|
002374  e1a00000          MOV      r0,r0                 ;1090
                  |L1.9080|
002378  e1a00006          MOV      r0,r6                 ;1118
00237c  eaffff41          B        |L1.8328|
;;;1120   
                          ENDP

                  cJSON_Print PROC
;;;905    /* Render a cJSON item/entity/structure to text. */
;;;906    char *cJSON_Print(const cJSON *item)
002380  e92d4010          PUSH     {r4,lr}
;;;907    {
002384  e1a04000          MOV      r4,r0
;;;908        return (char*)print_value(item, 0, 1, 0);
002388  e3a03000          MOV      r3,#0
00238c  e3a02001          MOV      r2,#1
002390  e1a01003          MOV      r1,r3
002394  e1a00004          MOV      r0,r4
002398  ebfffffe          BL       print_value
;;;909    }
00239c  e8bd8010          POP      {r4,pc}
;;;910    
                          ENDP

                  cJSON_PrintUnformatted PROC
;;;911    char *cJSON_PrintUnformatted(const cJSON *item)
0023a0  e92d4070          PUSH     {r4-r6,lr}
;;;912    {
0023a4  e1a04000          MOV      r4,r0
;;;913        char* reVal;
;;;914        //sysprintf("\r\n-[cJSON_PrintUnformatted enter]-!!\n");
;;;915        reVal = (char*)print_value(item, 0, 0, 0);
0023a8  e3a03000          MOV      r3,#0
0023ac  e1a02003          MOV      r2,r3
0023b0  e1a01003          MOV      r1,r3
0023b4  e1a00004          MOV      r0,r4
0023b8  ebfffffe          BL       print_value
0023bc  e1a05000          MOV      r5,r0
;;;916        //sysprintf("\r\n-[cJSON_PrintUnformatted Exit]-!!\n");
;;;917        return reVal;
0023c0  e1a00005          MOV      r0,r5
;;;918    }
0023c4  e8bd8070          POP      {r4-r6,pc}
;;;919    
                          ENDP

                  cJSON_PrintBuffered PROC
;;;920    char *cJSON_PrintBuffered(const cJSON *item, int prebuffer, cjbool fmt)
0023c8  e92d407f          PUSH     {r0-r6,lr}
;;;921    {
0023cc  e1a05000          MOV      r5,r0
0023d0  e1a04001          MOV      r4,r1
0023d4  e1a06002          MOV      r6,r2
;;;922        printbuffer p;
;;;923    
;;;924        if (prebuffer < 0)
0023d8  e3540000          CMP      r4,#0
0023dc  aa000002          BGE      |L1.9196|
;;;925        {
;;;926            return NULL;
0023e0  e3a00000          MOV      r0,#0
                  |L1.9188|
0023e4  e28dd010          ADD      sp,sp,#0x10
;;;927        }
;;;928    
;;;929        p.buffer = (unsigned char*)cJSON_malloc((size_t)prebuffer);
;;;930        if (!p.buffer)
;;;931        {
;;;932            return NULL;
;;;933        }
;;;934    
;;;935        p.length = (size_t)prebuffer;
;;;936        p.offset = 0;
;;;937        p.noalloc = false;
;;;938    
;;;939        return (char*)print_value(item, 0, fmt, &p);
;;;940    }
0023e8  e8bd8070          POP      {r4-r6,pc}
                  |L1.9196|
0023ec  e1a00004          MOV      r0,r4                 ;929
0023f0  e51f13a0          LDR      r1,|L1.8280|
0023f4  e5911000          LDR      r1,[r1,#0]            ;929  ; cJSON_malloc
0023f8  e12fff31          BLX      r1                    ;929
0023fc  e58d0000          STR      r0,[sp,#0]            ;929
002400  e59d0000          LDR      r0,[sp,#0]            ;930
002404  e3500000          CMP      r0,#0                 ;930
002408  1a000001          BNE      |L1.9236|
00240c  e3a00000          MOV      r0,#0                 ;932
002410  eafffff3          B        |L1.9188|
                  |L1.9236|
002414  e58d4004          STR      r4,[sp,#4]            ;935
002418  e3a00000          MOV      r0,#0                 ;936
00241c  e58d0008          STR      r0,[sp,#8]            ;936
002420  e58d000c          STR      r0,[sp,#0xc]          ;937
002424  e1a0300d          MOV      r3,sp                 ;939
002428  e1a02006          MOV      r2,r6                 ;939
00242c  e3a01000          MOV      r1,#0                 ;939
002430  e1a00005          MOV      r0,r5                 ;939
002434  ebfffffe          BL       print_value
002438  eaffffe9          B        |L1.9188|
;;;941    
                          ENDP

                  cJSON_PrintPreallocated PROC
;;;942    int cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cjbool fmt)
00243c  e92d41ff          PUSH     {r0-r8,lr}
;;;943    {
002440  e1a07000          MOV      r7,r0
002444  e1a05001          MOV      r5,r1
002448  e1a04002          MOV      r4,r2
00244c  e1a06003          MOV      r6,r3
;;;944        printbuffer p;
;;;945    
;;;946        if (len < 0)
002450  e3540000          CMP      r4,#0
002454  aa000002          BGE      |L1.9316|
;;;947        {
;;;948            return false;
002458  e3a00000          MOV      r0,#0
                  |L1.9308|
00245c  e28dd010          ADD      sp,sp,#0x10
;;;949        }
;;;950    
;;;951        p.buffer = (unsigned char*)buf;
;;;952        p.length = (size_t)len;
;;;953        p.offset = 0;
;;;954        p.noalloc = true;
;;;955        return print_value(item, 0, fmt, &p) != NULL;
;;;956    }
002460  e8bd81f0          POP      {r4-r8,pc}
                  |L1.9316|
002464  e58d5000          STR      r5,[sp,#0]            ;951
002468  e58d4004          STR      r4,[sp,#4]            ;952
00246c  e3a00000          MOV      r0,#0                 ;953
002470  e58d0008          STR      r0,[sp,#8]            ;953
002474  e3a00001          MOV      r0,#1                 ;954
002478  e58d000c          STR      r0,[sp,#0xc]          ;954
00247c  e1a0300d          MOV      r3,sp                 ;955
002480  e1a02006          MOV      r2,r6                 ;955
002484  e3a01000          MOV      r1,#0                 ;955
002488  e1a00007          MOV      r0,r7                 ;955
00248c  ebfffffe          BL       print_value
002490  e3500000          CMP      r0,#0                 ;955
002494  0a000001          BEQ      |L1.9376|
002498  e3a00001          MOV      r0,#1                 ;955
00249c  eaffffee          B        |L1.9308|
                  |L1.9376|
0024a0  e3a00000          MOV      r0,#0                 ;955
0024a4  eaffffec          B        |L1.9308|
;;;957    
                          ENDP

                  cJSON_GetArraySize PROC
;;;1744   /* Get Array size/item / object item. */
;;;1745   int cJSON_GetArraySize(const cJSON *array)
0024a8  e1a01000          MOV      r1,r0
;;;1746   {
;;;1747       cJSON *c = array->child;
0024ac  e5912008          LDR      r2,[r1,#8]
;;;1748       size_t i = 0;
0024b0  e3a00000          MOV      r0,#0
;;;1749       while(c)
0024b4  ea000001          B        |L1.9408|
                  |L1.9400|
;;;1750       {
;;;1751           i++;
0024b8  e2800001          ADD      r0,r0,#1
;;;1752           c = c->next;
0024bc  e5922000          LDR      r2,[r2,#0]
                  |L1.9408|
0024c0  e3520000          CMP      r2,#0                 ;1749
0024c4  1afffffb          BNE      |L1.9400|
;;;1753       }
;;;1754   
;;;1755       /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
;;;1756   
;;;1757       return (int)i;
;;;1758   }
0024c8  e12fff1e          BX       lr
;;;1759   
                          ENDP

                  cJSON_GetArrayItem PROC
;;;1760   cJSON *cJSON_GetArrayItem(const cJSON *array, int item)
0024cc  e1a02000          MOV      r2,r0
;;;1761   {
;;;1762       cJSON *c = array ? array->child : NULL;
0024d0  e3520000          CMP      r2,#0
0024d4  0a000001          BEQ      |L1.9440|
0024d8  e5923008          LDR      r3,[r2,#8]
0024dc  ea000000          B        |L1.9444|
                  |L1.9440|
0024e0  e3a03000          MOV      r3,#0
                  |L1.9444|
0024e4  e1a00003          MOV      r0,r3
;;;1763       while (c && item > 0)
0024e8  ea000001          B        |L1.9460|
                  |L1.9452|
;;;1764       {
;;;1765           item--;
0024ec  e2411001          SUB      r1,r1,#1
;;;1766           c = c->next;
0024f0  e5900000          LDR      r0,[r0,#0]
                  |L1.9460|
0024f4  e3500000          CMP      r0,#0                 ;1763
0024f8  0a000001          BEQ      |L1.9476|
0024fc  e3510000          CMP      r1,#0                 ;1763
002500  cafffff9          BGT      |L1.9452|
                  |L1.9476|
;;;1767       }
;;;1768   
;;;1769       return c;
;;;1770   }
002504  e12fff1e          BX       lr
;;;1771   
                          ENDP

                  cJSON_GetObjectItem PROC
;;;1772   cJSON *cJSON_GetObjectItem(const cJSON *object, const char *string)
002508  e92d4070          PUSH     {r4-r6,lr}
;;;1773   {
00250c  e1a05000          MOV      r5,r0
002510  e1a06001          MOV      r6,r1
;;;1774       cJSON *c = object ? object->child : NULL;
002514  e3550000          CMP      r5,#0
002518  0a000001          BEQ      |L1.9508|
00251c  e5950008          LDR      r0,[r5,#8]
002520  ea000000          B        |L1.9512|
                  |L1.9508|
002524  e3a00000          MOV      r0,#0
                  |L1.9512|
002528  e1a04000          MOV      r4,r0
;;;1775       while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
00252c  ea000000          B        |L1.9524|
                  |L1.9520|
;;;1776       {
;;;1777           c = c->next;
002530  e5944000          LDR      r4,[r4,#0]
                  |L1.9524|
002534  e3540000          CMP      r4,#0                 ;1775
002538  0a000004          BEQ      |L1.9552|
00253c  e1a01006          MOV      r1,r6                 ;1775
002540  e5940020          LDR      r0,[r4,#0x20]         ;1775
002544  ebfffffe          BL       cJSON_strcasecmp
002548  e3500000          CMP      r0,#0                 ;1775
00254c  1afffff7          BNE      |L1.9520|
                  |L1.9552|
;;;1778       }
;;;1779       return c;
002550  e1a00004          MOV      r0,r4
;;;1780   }
002554  e8bd8070          POP      {r4-r6,pc}
;;;1781   
                          ENDP

                  cJSON_HasObjectItem PROC
;;;1782   cjbool cJSON_HasObjectItem(const cJSON *object, const char *string)
002558  e92d4070          PUSH     {r4-r6,lr}
;;;1783   {
00255c  e1a04000          MOV      r4,r0
002560  e1a05001          MOV      r5,r1
;;;1784       return cJSON_GetObjectItem(object, string) ? 1 : 0;
002564  e1a01005          MOV      r1,r5
002568  e1a00004          MOV      r0,r4
00256c  ebfffffe          BL       cJSON_GetObjectItem
002570  e3500000          CMP      r0,#0
002574  0a000001          BEQ      |L1.9600|
002578  e3a00001          MOV      r0,#1
                  |L1.9596|
;;;1785   }
00257c  e8bd8070          POP      {r4-r6,pc}
                  |L1.9600|
002580  e3a00000          MOV      r0,#0                 ;1784
002584  eafffffc          B        |L1.9596|
;;;1786   
                          ENDP

                  suffix_object PROC
;;;1787   /* Utility for array list handling. */
;;;1788   static void suffix_object(cJSON *prev, cJSON *item)
002588  e5801000          STR      r1,[r0,#0]
;;;1789   {
;;;1790       prev->next = item;
;;;1791       item->prev = prev;
00258c  e5810004          STR      r0,[r1,#4]
;;;1792   }
002590  e12fff1e          BX       lr
;;;1793   
                          ENDP

                  create_reference PROC
;;;1794   /* Utility for handling references. */
;;;1795   static cJSON *create_reference(const cJSON *item)
002594  e92d4070          PUSH     {r4-r6,lr}
;;;1796   {
002598  e1a05000          MOV      r5,r0
;;;1797       cJSON *ref = cJSON_New_Item();
00259c  ebfffffe          BL       cJSON_New_Item
0025a0  e1a04000          MOV      r4,r0
;;;1798       if (!ref)
0025a4  e3540000          CMP      r4,#0
0025a8  1a000001          BNE      |L1.9652|
;;;1799       {
;;;1800           return NULL;
0025ac  e3a00000          MOV      r0,#0
                  |L1.9648|
;;;1801       }
;;;1802       memcpy(ref, item, sizeof(cJSON));
;;;1803       ref->string = NULL;
;;;1804       ref->type |= cJSON_IsReference;
;;;1805       ref->next = ref->prev = NULL;
;;;1806       return ref;
;;;1807   }
0025b0  e8bd8070          POP      {r4-r6,pc}
                  |L1.9652|
0025b4  e3a02028          MOV      r2,#0x28              ;1802
0025b8  e1a01005          MOV      r1,r5                 ;1802
0025bc  e1a00004          MOV      r0,r4                 ;1802
0025c0  ebfffffe          BL       __aeabi_memcpy4
0025c4  e3a00000          MOV      r0,#0                 ;1803
0025c8  e5840020          STR      r0,[r4,#0x20]         ;1803
0025cc  e594000c          LDR      r0,[r4,#0xc]          ;1804
0025d0  e3800c01          ORR      r0,r0,#0x100          ;1804
0025d4  e584000c          STR      r0,[r4,#0xc]          ;1804
0025d8  e3a00000          MOV      r0,#0                 ;1805
0025dc  e5840004          STR      r0,[r4,#4]            ;1805
0025e0  e5840000          STR      r0,[r4,#0]            ;1805
0025e4  e1a00004          MOV      r0,r4                 ;1806
0025e8  eafffff0          B        |L1.9648|
;;;1808   
                          ENDP

                  cJSON_AddItemToArray PROC
;;;1809   /* Add item to array/object. */
;;;1810   void cJSON_AddItemToArray(cJSON *array, cJSON *item)
0025ec  e92d4070          PUSH     {r4-r6,lr}
;;;1811   {
0025f0  e1a04000          MOV      r4,r0
0025f4  e1a06001          MOV      r6,r1
;;;1812       cJSON *child = NULL;
0025f8  e3a05000          MOV      r5,#0
;;;1813   
;;;1814       if ((item == NULL) || (array == NULL))
0025fc  e3560000          CMP      r6,#0
002600  0a000001          BEQ      |L1.9740|
002604  e3540000          CMP      r4,#0
002608  1a000000          BNE      |L1.9744|
                  |L1.9740|
;;;1815       {
;;;1816           return;
;;;1817       }
;;;1818   
;;;1819       child = array->child;
;;;1820   
;;;1821       if (child == NULL)
;;;1822       {
;;;1823           /* list is empty, start new one */
;;;1824           array->child = item;
;;;1825       }
;;;1826       else
;;;1827       {
;;;1828           /* append to the end */
;;;1829           while (child->next)
;;;1830           {
;;;1831               child = child->next;
;;;1832           }
;;;1833           suffix_object(child, item);
;;;1834       }
;;;1835   }
00260c  e8bd8070          POP      {r4-r6,pc}
                  |L1.9744|
002610  e5945008          LDR      r5,[r4,#8]            ;1819
002614  e3550000          CMP      r5,#0                 ;1821
002618  1a000001          BNE      |L1.9764|
00261c  e5846008          STR      r6,[r4,#8]            ;1824
002620  ea000007          B        |L1.9796|
                  |L1.9764|
002624  ea000000          B        |L1.9772|
                  |L1.9768|
002628  e5955000          LDR      r5,[r5,#0]            ;1831
                  |L1.9772|
00262c  e5950000          LDR      r0,[r5,#0]            ;1829
002630  e3500000          CMP      r0,#0                 ;1829
002634  1afffffb          BNE      |L1.9768|
002638  e1a01006          MOV      r1,r6                 ;1833
00263c  e1a00005          MOV      r0,r5                 ;1833
002640  ebfffffe          BL       suffix_object
                  |L1.9796|
002644  e1a00000          MOV      r0,r0
002648  eaffffef          B        |L1.9740|
;;;1836   
                          ENDP

                  cJSON_AddItemToObjectCS PROC
;;;1845   /* Add an item to an object with constant string as key */
;;;1846   void   cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
00264c  e92d4070          PUSH     {r4-r6,lr}
;;;1847   {
002650  e1a06000          MOV      r6,r0
002654  e1a05001          MOV      r5,r1
002658  e1a04002          MOV      r4,r2
;;;1848       if (!item)
00265c  e3540000          CMP      r4,#0
002660  1a000000          BNE      |L1.9832|
                  |L1.9828|
;;;1849       {
;;;1850           return;
;;;1851       }
;;;1852       if (!(item->type & cJSON_StringIsConst) && item->string)
;;;1853       {
;;;1854           cJSON_free(item->string);
;;;1855       }
;;;1856   #pragma GCC diagnostic push
;;;1857   #pragma GCC diagnostic ignored "-Wcast-qual"
;;;1858       item->string = (char*)string;
;;;1859   #pragma GCC diagnostic pop
;;;1860       item->type |= cJSON_StringIsConst;
;;;1861       cJSON_AddItemToArray(object, item);
;;;1862   }
002664  e8bd8070          POP      {r4-r6,pc}
                  |L1.9832|
002668  e1d400bc          LDRH     r0,[r4,#0xc]          ;1852
00266c  e3100c02          TST      r0,#0x200             ;1852
002670  1a000006          BNE      |L1.9872|
002674  e5940020          LDR      r0,[r4,#0x20]         ;1852
002678  e3500000          CMP      r0,#0                 ;1852
00267c  0a000003          BEQ      |L1.9872|
002680  e51f162c          LDR      r1,|L1.8284|
002684  e5940020          LDR      r0,[r4,#0x20]         ;1854
002688  e5911000          LDR      r1,[r1,#0]            ;1854  ; cJSON_free
00268c  e12fff31          BLX      r1                    ;1854
                  |L1.9872|
002690  e5845020          STR      r5,[r4,#0x20]         ;1858
002694  e594000c          LDR      r0,[r4,#0xc]          ;1860
002698  e3800c02          ORR      r0,r0,#0x200          ;1860
00269c  e584000c          STR      r0,[r4,#0xc]          ;1860
0026a0  e1a01004          MOV      r1,r4                 ;1861
0026a4  e1a00006          MOV      r0,r6                 ;1861
0026a8  ebfffffe          BL       cJSON_AddItemToArray
0026ac  e1a00000          MOV      r0,r0
0026b0  eaffffeb          B        |L1.9828|
;;;1863   
                          ENDP

                  cJSON_AddItemToObject PROC
;;;1836   
;;;1837   void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
0026b4  e92d41f0          PUSH     {r4-r8,lr}
;;;1838   {
0026b8  e1a06000          MOV      r6,r0
0026bc  e1a05001          MOV      r5,r1
0026c0  e1a04002          MOV      r4,r2
;;;1839       /* call cJSON_AddItemToObjectCS for code reuse */
;;;1840       cJSON_AddItemToObjectCS(object, (char*)cJSON_strdup((const unsigned char*)string), item);
0026c4  e1a00005          MOV      r0,r5
0026c8  ebfffffe          BL       cJSON_strdup
0026cc  e1a07000          MOV      r7,r0
0026d0  e1a02004          MOV      r2,r4
0026d4  e1a01007          MOV      r1,r7
0026d8  e1a00006          MOV      r0,r6
0026dc  ebfffffe          BL       cJSON_AddItemToObjectCS
;;;1841       /* remove cJSON_StringIsConst flag */
;;;1842       item->type &= ~cJSON_StringIsConst;
0026e0  e594000c          LDR      r0,[r4,#0xc]
0026e4  e3c00c02          BIC      r0,r0,#0x200
0026e8  e584000c          STR      r0,[r4,#0xc]
;;;1843   }
0026ec  e8bd81f0          POP      {r4-r8,pc}
;;;1844   
                          ENDP

                  cJSON_AddItemReferenceToArray PROC
;;;1863   
;;;1864   void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
0026f0  e92d4070          PUSH     {r4-r6,lr}
;;;1865   {
0026f4  e1a05000          MOV      r5,r0
0026f8  e1a04001          MOV      r4,r1
;;;1866       cJSON_AddItemToArray(array, create_reference(item));
0026fc  e1a00004          MOV      r0,r4
002700  ebfffffe          BL       create_reference
002704  e1a06000          MOV      r6,r0
002708  e1a01006          MOV      r1,r6
00270c  e1a00005          MOV      r0,r5
002710  ebfffffe          BL       cJSON_AddItemToArray
;;;1867   }
002714  e8bd8070          POP      {r4-r6,pc}
;;;1868   
                          ENDP

                  cJSON_AddItemReferenceToObject PROC
;;;1869   void cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
002718  e92d41f0          PUSH     {r4-r8,lr}
;;;1870   {
00271c  e1a05000          MOV      r5,r0
002720  e1a06001          MOV      r6,r1
002724  e1a04002          MOV      r4,r2
;;;1871       cJSON_AddItemToObject(object, string, create_reference(item));
002728  e1a00004          MOV      r0,r4
00272c  ebfffffe          BL       create_reference
002730  e1a07000          MOV      r7,r0
002734  e1a02007          MOV      r2,r7
002738  e1a01006          MOV      r1,r6
00273c  e1a00005          MOV      r0,r5
002740  ebfffffe          BL       cJSON_AddItemToObject
;;;1872   }
002744  e8bd81f0          POP      {r4-r8,pc}
;;;1873   
                          ENDP

                  DetachItemFromArray PROC
;;;1874   static cJSON *DetachItemFromArray(cJSON *array, size_t which)
002748  e1a02000          MOV      r2,r0
;;;1875   {
00274c  e1a03001          MOV      r3,r1
;;;1876       cJSON *c = array->child;
002750  e5921008          LDR      r1,[r2,#8]
;;;1877       while (c && (which > 0))
002754  ea000001          B        |L1.10080|
                  |L1.10072|
;;;1878       {
;;;1879           c = c->next;
002758  e5911000          LDR      r1,[r1,#0]
;;;1880           which--;
00275c  e2433001          SUB      r3,r3,#1
                  |L1.10080|
002760  e3510000          CMP      r1,#0                 ;1877
002764  0a000001          BEQ      |L1.10096|
002768  e3530000          CMP      r3,#0                 ;1877
00276c  1afffff9          BNE      |L1.10072|
                  |L1.10096|
;;;1881       }
;;;1882       if (!c)
002770  e3510000          CMP      r1,#0
002774  1a000001          BNE      |L1.10112|
;;;1883       {
;;;1884           /* item doesn't exist */
;;;1885           return NULL;
002778  e3a00000          MOV      r0,#0
                  |L1.10108|
;;;1886       }
;;;1887       if (c->prev)
;;;1888       {
;;;1889           /* not the first element */
;;;1890           c->prev->next = c->next;
;;;1891       }
;;;1892       if (c->next)
;;;1893       {
;;;1894           c->next->prev = c->prev;
;;;1895       }
;;;1896       if (c==array->child)
;;;1897       {
;;;1898           array->child = c->next;
;;;1899       }
;;;1900       /* make sure the detached item doesn't point anywhere anymore */
;;;1901       c->prev = c->next = NULL;
;;;1902   
;;;1903       return c;
;;;1904   }
00277c  e12fff1e          BX       lr
                  |L1.10112|
002780  e5910004          LDR      r0,[r1,#4]            ;1887
002784  e3500000          CMP      r0,#0                 ;1887
002788  0a000001          BEQ      |L1.10132|
00278c  e8911001          LDM      r1,{r0,r12}           ;1890
002790  e58c0000          STR      r0,[r12,#0]           ;1890
                  |L1.10132|
002794  e5910000          LDR      r0,[r1,#0]            ;1892
002798  e3500000          CMP      r0,#0                 ;1892
00279c  0a000002          BEQ      |L1.10156|
0027a0  e5910004          LDR      r0,[r1,#4]            ;1894
0027a4  e591c000          LDR      r12,[r1,#0]           ;1894
0027a8  e58c0004          STR      r0,[r12,#4]           ;1894
                  |L1.10156|
0027ac  e5920008          LDR      r0,[r2,#8]            ;1896
0027b0  e1500001          CMP      r0,r1                 ;1896
0027b4  1a000001          BNE      |L1.10176|
0027b8  e5910000          LDR      r0,[r1,#0]            ;1898
0027bc  e5820008          STR      r0,[r2,#8]            ;1898
                  |L1.10176|
0027c0  e3a00000          MOV      r0,#0                 ;1901
0027c4  e5810000          STR      r0,[r1,#0]            ;1901
0027c8  e5810004          STR      r0,[r1,#4]            ;1901
0027cc  e1a00001          MOV      r0,r1                 ;1903
0027d0  eaffffe9          B        |L1.10108|
;;;1905   cJSON *cJSON_DetachItemFromArray(cJSON *array, int which)
                          ENDP

                  cJSON_DetachItemFromArray PROC
0027d4  e92d4070          PUSH     {r4-r6,lr}
;;;1906   {
0027d8  e1a05000          MOV      r5,r0
0027dc  e1a04001          MOV      r4,r1
;;;1907       if (which < 0)
0027e0  e3540000          CMP      r4,#0
0027e4  aa000001          BGE      |L1.10224|
;;;1908       {
;;;1909           return NULL;
0027e8  e3a00000          MOV      r0,#0
                  |L1.10220|
;;;1910       }
;;;1911   
;;;1912       return DetachItemFromArray(array, (size_t)which);
;;;1913   }
0027ec  e8bd8070          POP      {r4-r6,pc}
                  |L1.10224|
0027f0  e1a01004          MOV      r1,r4                 ;1912
0027f4  e1a00005          MOV      r0,r5                 ;1912
0027f8  ebfffffe          BL       DetachItemFromArray
0027fc  eafffffa          B        |L1.10220|
;;;1914   
                          ENDP

                  cJSON_DeleteItemFromArray PROC
;;;1915   void cJSON_DeleteItemFromArray(cJSON *array, int which)
002800  e92d4070          PUSH     {r4-r6,lr}
;;;1916   {
002804  e1a04000          MOV      r4,r0
002808  e1a05001          MOV      r5,r1
;;;1917       cJSON_Delete(cJSON_DetachItemFromArray(array, which));
00280c  e1a01005          MOV      r1,r5
002810  e1a00004          MOV      r0,r4
002814  ebfffffe          BL       cJSON_DetachItemFromArray
002818  e1a06000          MOV      r6,r0
00281c  ebfffffe          BL       cJSON_Delete
;;;1918   }
002820  e8bd8070          POP      {r4-r6,pc}
;;;1919   
                          ENDP

                  cJSON_DetachItemFromObject PROC
;;;1920   cJSON *cJSON_DetachItemFromObject(cJSON *object, const char *string)
002824  e92d41f0          PUSH     {r4-r8,lr}
;;;1921   {
002828  e1a05000          MOV      r5,r0
00282c  e1a07001          MOV      r7,r1
;;;1922       size_t i = 0;
002830  e3a06000          MOV      r6,#0
;;;1923       cJSON *c = object->child;
002834  e5954008          LDR      r4,[r5,#8]
;;;1924       while (c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
002838  ea000001          B        |L1.10308|
                  |L1.10300|
;;;1925       {
;;;1926           i++;
00283c  e2866001          ADD      r6,r6,#1
;;;1927           c = c->next;
002840  e5944000          LDR      r4,[r4,#0]
                  |L1.10308|
002844  e3540000          CMP      r4,#0                 ;1924
002848  0a000004          BEQ      |L1.10336|
00284c  e1a01007          MOV      r1,r7                 ;1924
002850  e5940020          LDR      r0,[r4,#0x20]         ;1924
002854  ebfffffe          BL       cJSON_strcasecmp
002858  e3500000          CMP      r0,#0                 ;1924
00285c  1afffff6          BNE      |L1.10300|
                  |L1.10336|
;;;1928       }
;;;1929       if (c)
002860  e3540000          CMP      r4,#0
002864  0a000003          BEQ      |L1.10360|
;;;1930       {
;;;1931           return DetachItemFromArray(object, i);
002868  e1a01006          MOV      r1,r6
00286c  e1a00005          MOV      r0,r5
002870  ebfffffe          BL       DetachItemFromArray
                  |L1.10356|
;;;1932       }
;;;1933   
;;;1934       return NULL;
;;;1935   }
002874  e8bd81f0          POP      {r4-r8,pc}
                  |L1.10360|
002878  e3a00000          MOV      r0,#0                 ;1934
00287c  eafffffc          B        |L1.10356|
;;;1936   
                          ENDP

                  cJSON_DeleteItemFromObject PROC
;;;1937   void cJSON_DeleteItemFromObject(cJSON *object, const char *string)
002880  e92d4070          PUSH     {r4-r6,lr}
;;;1938   {
002884  e1a04000          MOV      r4,r0
002888  e1a05001          MOV      r5,r1
;;;1939       cJSON_Delete(cJSON_DetachItemFromObject(object, string));
00288c  e1a01005          MOV      r1,r5
002890  e1a00004          MOV      r0,r4
002894  ebfffffe          BL       cJSON_DetachItemFromObject
002898  e1a06000          MOV      r6,r0
00289c  ebfffffe          BL       cJSON_Delete
;;;1940   }
0028a0  e8bd8070          POP      {r4-r6,pc}
;;;1941   
                          ENDP

                  cJSON_InsertItemInArray PROC
;;;1942   /* Replace array/object items with new ones. */
;;;1943   void cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
0028a4  e92d41f0          PUSH     {r4-r8,lr}
;;;1944   {
0028a8  e1a06000          MOV      r6,r0
0028ac  e1a07001          MOV      r7,r1
0028b0  e1a04002          MOV      r4,r2
;;;1945       cJSON *c = array->child;
0028b4  e5965008          LDR      r5,[r6,#8]
;;;1946       while (c && (which > 0))
0028b8  ea000001          B        |L1.10436|
                  |L1.10428|
;;;1947       {
;;;1948           c = c->next;
0028bc  e5955000          LDR      r5,[r5,#0]
;;;1949           which--;
0028c0  e2477001          SUB      r7,r7,#1
                  |L1.10436|
0028c4  e3550000          CMP      r5,#0                 ;1946
0028c8  0a000001          BEQ      |L1.10452|
0028cc  e3570000          CMP      r7,#0                 ;1946
0028d0  cafffff9          BGT      |L1.10428|
                  |L1.10452|
;;;1950       }
;;;1951       if (!c)
0028d4  e3550000          CMP      r5,#0
0028d8  1a000003          BNE      |L1.10476|
;;;1952       {
;;;1953           cJSON_AddItemToArray(array, newitem);
0028dc  e1a01004          MOV      r1,r4
0028e0  e1a00006          MOV      r0,r6
0028e4  ebfffffe          BL       cJSON_AddItemToArray
                  |L1.10472|
;;;1954           return;
;;;1955       }
;;;1956       newitem->next = c;
;;;1957       newitem->prev = c->prev;
;;;1958       c->prev = newitem;
;;;1959       if (c == array->child)
;;;1960       {
;;;1961           array->child = newitem;
;;;1962       }
;;;1963       else
;;;1964       {
;;;1965           newitem->prev->next = newitem;
;;;1966       }
;;;1967   }
0028e8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.10476|
0028ec  e5845000          STR      r5,[r4,#0]            ;1956
0028f0  e5950004          LDR      r0,[r5,#4]            ;1957
0028f4  e5840004          STR      r0,[r4,#4]            ;1957
0028f8  e5854004          STR      r4,[r5,#4]            ;1958
0028fc  e5960008          LDR      r0,[r6,#8]            ;1959
002900  e1500005          CMP      r0,r5                 ;1959
002904  1a000001          BNE      |L1.10512|
002908  e5864008          STR      r4,[r6,#8]            ;1961
00290c  ea000001          B        |L1.10520|
                  |L1.10512|
002910  e5940004          LDR      r0,[r4,#4]            ;1965
002914  e5804000          STR      r4,[r0,#0]            ;1965
                  |L1.10520|
002918  e1a00000          MOV      r0,r0
00291c  eafffff1          B        |L1.10472|
;;;1968   
                          ENDP

                  ReplaceItemInArray PROC
;;;1969   static void ReplaceItemInArray(cJSON *array, size_t which, cJSON *newitem)
002920  e92d41f0          PUSH     {r4-r8,lr}
;;;1970   {
002924  e1a06000          MOV      r6,r0
002928  e1a07001          MOV      r7,r1
00292c  e1a04002          MOV      r4,r2
;;;1971       cJSON *c = array->child;
002930  e5965008          LDR      r5,[r6,#8]
;;;1972       while (c && (which > 0))
002934  ea000001          B        |L1.10560|
                  |L1.10552|
;;;1973       {
;;;1974           c = c->next;
002938  e5955000          LDR      r5,[r5,#0]
;;;1975           which--;
00293c  e2477001          SUB      r7,r7,#1
                  |L1.10560|
002940  e3550000          CMP      r5,#0                 ;1972
002944  0a000001          BEQ      |L1.10576|
002948  e3570000          CMP      r7,#0                 ;1972
00294c  1afffff9          BNE      |L1.10552|
                  |L1.10576|
;;;1976       }
;;;1977       if (!c)
002950  e3550000          CMP      r5,#0
002954  1a000000          BNE      |L1.10588|
                  |L1.10584|
;;;1978       {
;;;1979           return;
;;;1980       }
;;;1981       newitem->next = c->next;
;;;1982       newitem->prev = c->prev;
;;;1983       if (newitem->next)
;;;1984       {
;;;1985           newitem->next->prev = newitem;
;;;1986       }
;;;1987       if (c == array->child)
;;;1988       {
;;;1989           array->child = newitem;
;;;1990       }
;;;1991       else
;;;1992       {
;;;1993           newitem->prev->next = newitem;
;;;1994       }
;;;1995       c->next = c->prev = NULL;
;;;1996       cJSON_Delete(c);
;;;1997   }
002958  e8bd81f0          POP      {r4-r8,pc}
                  |L1.10588|
00295c  e5950000          LDR      r0,[r5,#0]            ;1981
002960  e5840000          STR      r0,[r4,#0]            ;1981
002964  e5950004          LDR      r0,[r5,#4]            ;1982
002968  e5840004          STR      r0,[r4,#4]            ;1982
00296c  e5940000          LDR      r0,[r4,#0]            ;1983
002970  e3500000          CMP      r0,#0                 ;1983
002974  0a000001          BEQ      |L1.10624|
002978  e5940000          LDR      r0,[r4,#0]            ;1985
00297c  e5804004          STR      r4,[r0,#4]            ;1985
                  |L1.10624|
002980  e5960008          LDR      r0,[r6,#8]            ;1987
002984  e1500005          CMP      r0,r5                 ;1987
002988  1a000001          BNE      |L1.10644|
00298c  e5864008          STR      r4,[r6,#8]            ;1989
002990  ea000001          B        |L1.10652|
                  |L1.10644|
002994  e5940004          LDR      r0,[r4,#4]            ;1993
002998  e5804000          STR      r4,[r0,#0]            ;1993
                  |L1.10652|
00299c  e3a00000          MOV      r0,#0                 ;1995
0029a0  e5850004          STR      r0,[r5,#4]            ;1995
0029a4  e5850000          STR      r0,[r5,#0]            ;1995
0029a8  e1a00005          MOV      r0,r5                 ;1996
0029ac  ebfffffe          BL       cJSON_Delete
0029b0  e1a00000          MOV      r0,r0
0029b4  eaffffe7          B        |L1.10584|
;;;1998   void cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
                          ENDP

                  cJSON_ReplaceItemInArray PROC
0029b8  e92d4070          PUSH     {r4-r6,lr}
;;;1999   {
0029bc  e1a05000          MOV      r5,r0
0029c0  e1a04001          MOV      r4,r1
0029c4  e1a06002          MOV      r6,r2
;;;2000       if (which < 0)
0029c8  e3540000          CMP      r4,#0
0029cc  aa000000          BGE      |L1.10708|
                  |L1.10704|
;;;2001       {
;;;2002           return;
;;;2003       }
;;;2004   
;;;2005       ReplaceItemInArray(array, (size_t)which, newitem);
;;;2006   }
0029d0  e8bd8070          POP      {r4-r6,pc}
                  |L1.10708|
0029d4  e1a02006          MOV      r2,r6                 ;2005
0029d8  e1a01004          MOV      r1,r4                 ;2005
0029dc  e1a00005          MOV      r0,r5                 ;2005
0029e0  ebfffffe          BL       ReplaceItemInArray
0029e4  e1a00000          MOV      r0,r0
0029e8  eafffff8          B        |L1.10704|
;;;2007   
                          ENDP

                  cJSON_ReplaceItemInObject PROC
;;;2008   void cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
0029ec  e92d41f0          PUSH     {r4-r8,lr}
;;;2009   {
0029f0  e1a06000          MOV      r6,r0
0029f4  e1a07001          MOV      r7,r1
0029f8  e1a04002          MOV      r4,r2
;;;2010       size_t i = 0;
0029fc  e3a08000          MOV      r8,#0
;;;2011       cJSON *c = object->child;
002a00  e5965008          LDR      r5,[r6,#8]
;;;2012       while(c && cJSON_strcasecmp((unsigned char*)c->string, (const unsigned char*)string))
002a04  ea000001          B        |L1.10768|
                  |L1.10760|
;;;2013       {
;;;2014           i++;
002a08  e2888001          ADD      r8,r8,#1
;;;2015           c = c->next;
002a0c  e5955000          LDR      r5,[r5,#0]
                  |L1.10768|
002a10  e3550000          CMP      r5,#0                 ;2012
002a14  0a000004          BEQ      |L1.10796|
002a18  e1a01007          MOV      r1,r7                 ;2012
002a1c  e5950020          LDR      r0,[r5,#0x20]         ;2012
002a20  ebfffffe          BL       cJSON_strcasecmp
002a24  e3500000          CMP      r0,#0                 ;2012
002a28  1afffff6          BNE      |L1.10760|
                  |L1.10796|
;;;2016       }
;;;2017       if(c)
002a2c  e3550000          CMP      r5,#0
002a30  0a000010          BEQ      |L1.10872|
;;;2018       {
;;;2019           /* vPortFree the old string if not const */
;;;2020           if (!(newitem->type & cJSON_StringIsConst) && newitem->string)
002a34  e1d400bc          LDRH     r0,[r4,#0xc]
002a38  e3100c02          TST      r0,#0x200
002a3c  1a000006          BNE      |L1.10844|
002a40  e5940020          LDR      r0,[r4,#0x20]
002a44  e3500000          CMP      r0,#0
002a48  0a000003          BEQ      |L1.10844|
;;;2021           {
;;;2022                cJSON_free(newitem->string);
002a4c  e51f19f8          LDR      r1,|L1.8284|
002a50  e5940020          LDR      r0,[r4,#0x20]
002a54  e5911000          LDR      r1,[r1,#0]  ; cJSON_free
002a58  e12fff31          BLX      r1
                  |L1.10844|
;;;2023           }
;;;2024   
;;;2025           newitem->string = (char*)cJSON_strdup((const unsigned char*)string);
002a5c  e1a00007          MOV      r0,r7
002a60  ebfffffe          BL       cJSON_strdup
002a64  e5840020          STR      r0,[r4,#0x20]
;;;2026           ReplaceItemInArray(object, i, newitem);
002a68  e1a02004          MOV      r2,r4
002a6c  e1a01008          MOV      r1,r8
002a70  e1a00006          MOV      r0,r6
002a74  ebfffffe          BL       ReplaceItemInArray
                  |L1.10872|
;;;2027       }
;;;2028   }
002a78  e8bd81f0          POP      {r4-r8,pc}
;;;2029   
                          ENDP

                  cJSON_CreateNull PROC
;;;2030   /* Create basic types: */
;;;2031   cJSON *cJSON_CreateNull(void)
002a7c  e92d4010          PUSH     {r4,lr}
;;;2032   {
;;;2033       cJSON *item = cJSON_New_Item();
002a80  ebfffffe          BL       cJSON_New_Item
002a84  e1a04000          MOV      r4,r0
;;;2034       if(item)
002a88  e3540000          CMP      r4,#0
002a8c  0a000001          BEQ      |L1.10904|
;;;2035       {
;;;2036           item->type = cJSON_NULL;
002a90  e3a00004          MOV      r0,#4
002a94  e584000c          STR      r0,[r4,#0xc]
                  |L1.10904|
;;;2037       }
;;;2038   
;;;2039       return item;
002a98  e1a00004          MOV      r0,r4
;;;2040   }
002a9c  e8bd8010          POP      {r4,pc}
;;;2041   
                          ENDP

                  cJSON_CreateTrue PROC
;;;2042   cJSON *cJSON_CreateTrue(void)
002aa0  e92d4010          PUSH     {r4,lr}
;;;2043   {
;;;2044       cJSON *item = cJSON_New_Item();
002aa4  ebfffffe          BL       cJSON_New_Item
002aa8  e1a04000          MOV      r4,r0
;;;2045       if(item)
002aac  e3540000          CMP      r4,#0
002ab0  0a000001          BEQ      |L1.10940|
;;;2046       {
;;;2047           item->type = cJSON_True;
002ab4  e3a00002          MOV      r0,#2
002ab8  e584000c          STR      r0,[r4,#0xc]
                  |L1.10940|
;;;2048       }
;;;2049   
;;;2050       return item;
002abc  e1a00004          MOV      r0,r4
;;;2051   }
002ac0  e8bd8010          POP      {r4,pc}
;;;2052   
                          ENDP

                  cJSON_CreateFalse PROC
;;;2053   cJSON *cJSON_CreateFalse(void)
002ac4  e92d4010          PUSH     {r4,lr}
;;;2054   {
;;;2055       cJSON *item = cJSON_New_Item();
002ac8  ebfffffe          BL       cJSON_New_Item
002acc  e1a04000          MOV      r4,r0
;;;2056       if(item)
002ad0  e3540000          CMP      r4,#0
002ad4  0a000001          BEQ      |L1.10976|
;;;2057       {
;;;2058           item->type = cJSON_False;
002ad8  e3a00001          MOV      r0,#1
002adc  e584000c          STR      r0,[r4,#0xc]
                  |L1.10976|
;;;2059       }
;;;2060   
;;;2061       return item;
002ae0  e1a00004          MOV      r0,r4
;;;2062   }
002ae4  e8bd8010          POP      {r4,pc}
;;;2063   
                          ENDP

                  cJSON_CreateBool PROC
;;;2064   cJSON *cJSON_CreateBool(cjbool b)
002ae8  e92d4070          PUSH     {r4-r6,lr}
;;;2065   {
002aec  e1a05000          MOV      r5,r0
;;;2066       cJSON *item = cJSON_New_Item();
002af0  ebfffffe          BL       cJSON_New_Item
002af4  e1a04000          MOV      r4,r0
;;;2067       if(item)
002af8  e3540000          CMP      r4,#0
002afc  0a000005          BEQ      |L1.11032|
;;;2068       {
;;;2069           item->type = b ? cJSON_True : cJSON_False;
002b00  e3550000          CMP      r5,#0
002b04  0a000001          BEQ      |L1.11024|
002b08  e3a00002          MOV      r0,#2
002b0c  ea000000          B        |L1.11028|
                  |L1.11024|
002b10  e3a00001          MOV      r0,#1
                  |L1.11028|
002b14  e584000c          STR      r0,[r4,#0xc]
                  |L1.11032|
;;;2070       }
;;;2071   
;;;2072       return item;
002b18  e1a00004          MOV      r0,r4
;;;2073   }
002b1c  e8bd8070          POP      {r4-r6,pc}
;;;2074   
                          ENDP

                  cJSON_CreateNumber PROC
;;;2075   cJSON *cJSON_CreateNumber(double num)
002b20  e92d4070          PUSH     {r4-r6,lr}
;;;2076   {
002b24  e1a05000          MOV      r5,r0
002b28  e1a06001          MOV      r6,r1
;;;2077       cJSON *item = cJSON_New_Item();
002b2c  ebfffffe          BL       cJSON_New_Item
002b30  e1a04000          MOV      r4,r0
;;;2078       if(item)
002b34  e3540000          CMP      r4,#0
002b38  0a000019          BEQ      |L1.11172|
;;;2079       {
;;;2080           item->type = cJSON_Number;
002b3c  e3a00008          MOV      r0,#8
002b40  e584000c          STR      r0,[r4,#0xc]
;;;2081           item->valuedouble = num;
002b44  e5845018          STR      r5,[r4,#0x18]
002b48  e584601c          STR      r6,[r4,#0x1c]
002b4c  e59f23d4          LDR      r2,|L1.12072|
002b50  e59f33d4          LDR      r3,|L1.12076|
;;;2082   
;;;2083           /* use saturation in case of overflow */
;;;2084           if (num >= INT_MAX)
002b54  e1a00005          MOV      r0,r5
002b58  e1a01006          MOV      r1,r6
002b5c  ebfffffe          BL       __aeabi_cdrcmple
002b60  8a000002          BHI      |L1.11120|
;;;2085           {
;;;2086               item->valueint = INT_MAX;
002b64  e3e00102          MVN      r0,#0x80000000
002b68  e5840014          STR      r0,[r4,#0x14]
002b6c  ea00000c          B        |L1.11172|
                  |L1.11120|
002b70  e3a02000          MOV      r2,#0
002b74  e59f33b4          LDR      r3,|L1.12080|
;;;2087           }
;;;2088           else if (num <= INT_MIN)
002b78  e1a00005          MOV      r0,r5
002b7c  e1a01006          MOV      r1,r6
002b80  ebfffffe          BL       __aeabi_cdcmple
002b84  8a000002          BHI      |L1.11156|
;;;2089           {
;;;2090               item->valueint = INT_MIN;
002b88  e3a00102          MOV      r0,#0x80000000
002b8c  e5840014          STR      r0,[r4,#0x14]
002b90  ea000003          B        |L1.11172|
                  |L1.11156|
;;;2091           }
;;;2092           else
;;;2093           {
;;;2094               item->valueint = (int)num;
002b94  e1a00005          MOV      r0,r5
002b98  e1a01006          MOV      r1,r6
002b9c  ebfffffe          BL       __aeabi_d2iz
002ba0  e5840014          STR      r0,[r4,#0x14]
                  |L1.11172|
;;;2095           }
;;;2096       }
;;;2097   
;;;2098       return item;
002ba4  e1a00004          MOV      r0,r4
;;;2099   }
002ba8  e8bd8070          POP      {r4-r6,pc}
;;;2100   
                          ENDP

                  cJSON_CreateString PROC
;;;2101   cJSON *cJSON_CreateString(const char *string)
002bac  e92d4070          PUSH     {r4-r6,lr}
;;;2102   {
002bb0  e1a05000          MOV      r5,r0
;;;2103       cJSON *item = cJSON_New_Item();
002bb4  ebfffffe          BL       cJSON_New_Item
002bb8  e1a04000          MOV      r4,r0
;;;2104       if(item)
002bbc  e3540000          CMP      r4,#0
002bc0  0a00000b          BEQ      |L1.11252|
;;;2105       {
;;;2106           item->type = cJSON_String;
002bc4  e3a00010          MOV      r0,#0x10
002bc8  e584000c          STR      r0,[r4,#0xc]
;;;2107           item->valuestring = (char*)cJSON_strdup((const unsigned char*)string);
002bcc  e1a00005          MOV      r0,r5
002bd0  ebfffffe          BL       cJSON_strdup
002bd4  e5840010          STR      r0,[r4,#0x10]
;;;2108           if(!item->valuestring)
002bd8  e5940010          LDR      r0,[r4,#0x10]
002bdc  e3500000          CMP      r0,#0
002be0  1a000003          BNE      |L1.11252|
;;;2109           {
;;;2110               cJSON_Delete(item);
002be4  e1a00004          MOV      r0,r4
002be8  ebfffffe          BL       cJSON_Delete
;;;2111               return NULL;
002bec  e3a00000          MOV      r0,#0
                  |L1.11248|
;;;2112           }
;;;2113       }
;;;2114   
;;;2115       return item;
;;;2116   }
002bf0  e8bd8070          POP      {r4-r6,pc}
                  |L1.11252|
002bf4  e1a00004          MOV      r0,r4                 ;2115
002bf8  eafffffc          B        |L1.11248|
;;;2117   
                          ENDP

                  cJSON_CreateRaw PROC
;;;2118   extern cJSON *cJSON_CreateRaw(const char *raw)
002bfc  e92d4070          PUSH     {r4-r6,lr}
;;;2119   {
002c00  e1a05000          MOV      r5,r0
;;;2120       cJSON *item = cJSON_New_Item();
002c04  ebfffffe          BL       cJSON_New_Item
002c08  e1a04000          MOV      r4,r0
;;;2121       if(item)
002c0c  e3540000          CMP      r4,#0
002c10  0a00000b          BEQ      |L1.11332|
;;;2122       {
;;;2123           item->type = cJSON_Raw;
002c14  e3a00080          MOV      r0,#0x80
002c18  e584000c          STR      r0,[r4,#0xc]
;;;2124           item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw);
002c1c  e1a00005          MOV      r0,r5
002c20  ebfffffe          BL       cJSON_strdup
002c24  e5840010          STR      r0,[r4,#0x10]
;;;2125           if(!item->valuestring)
002c28  e5940010          LDR      r0,[r4,#0x10]
002c2c  e3500000          CMP      r0,#0
002c30  1a000003          BNE      |L1.11332|
;;;2126           {
;;;2127               cJSON_Delete(item);
002c34  e1a00004          MOV      r0,r4
002c38  ebfffffe          BL       cJSON_Delete
;;;2128               return NULL;
002c3c  e3a00000          MOV      r0,#0
                  |L1.11328|
;;;2129           }
;;;2130       }
;;;2131   
;;;2132       return item;
;;;2133   }
002c40  e8bd8070          POP      {r4-r6,pc}
                  |L1.11332|
002c44  e1a00004          MOV      r0,r4                 ;2132
002c48  eafffffc          B        |L1.11328|
;;;2134   
                          ENDP

                  cJSON_CreateArray PROC
;;;2135   cJSON *cJSON_CreateArray(void)
002c4c  e92d4010          PUSH     {r4,lr}
;;;2136   {
;;;2137       cJSON *item = cJSON_New_Item();
002c50  ebfffffe          BL       cJSON_New_Item
002c54  e1a04000          MOV      r4,r0
;;;2138       if(item)
002c58  e3540000          CMP      r4,#0
002c5c  0a000001          BEQ      |L1.11368|
;;;2139       {
;;;2140           item->type=cJSON_Array;
002c60  e3a00020          MOV      r0,#0x20
002c64  e584000c          STR      r0,[r4,#0xc]
                  |L1.11368|
;;;2141       }
;;;2142   
;;;2143       return item;
002c68  e1a00004          MOV      r0,r4
;;;2144   }
002c6c  e8bd8010          POP      {r4,pc}
;;;2145   
                          ENDP

                  cJSON_CreateObject PROC
;;;2146   cJSON *cJSON_CreateObject(void)
002c70  e92d4010          PUSH     {r4,lr}
;;;2147   {
;;;2148       cJSON *item = cJSON_New_Item();
002c74  ebfffffe          BL       cJSON_New_Item
002c78  e1a04000          MOV      r4,r0
;;;2149       if (item)
002c7c  e3540000          CMP      r4,#0
002c80  0a000001          BEQ      |L1.11404|
;;;2150       {
;;;2151           item->type = cJSON_Object;
002c84  e3a00040          MOV      r0,#0x40
002c88  e584000c          STR      r0,[r4,#0xc]
                  |L1.11404|
;;;2152       }
;;;2153   
;;;2154       return item;
002c8c  e1a00004          MOV      r0,r4
;;;2155   }
002c90  e8bd8010          POP      {r4,pc}
;;;2156   
                          ENDP

                  cJSON_CreateIntArray PROC
;;;2157   /* Create Arrays: */
;;;2158   cJSON *cJSON_CreateIntArray(const int *numbers, int count)
002c94  e92d5ff0          PUSH     {r4-r12,lr}
;;;2159   {
002c98  e1a0a000          MOV      r10,r0
002c9c  e1a06001          MOV      r6,r1
;;;2160       size_t i = 0;
002ca0  e3a04000          MOV      r4,#0
;;;2161       cJSON *n = NULL;
002ca4  e3a05000          MOV      r5,#0
;;;2162       cJSON *p = NULL;
002ca8  e3a0b000          MOV      r11,#0
;;;2163       cJSON *a = NULL;
002cac  e3a09000          MOV      r9,#0
;;;2164   
;;;2165       if (count < 0)
002cb0  e3560000          CMP      r6,#0
002cb4  aa000001          BGE      |L1.11456|
;;;2166       {
;;;2167           return NULL;
002cb8  e3a00000          MOV      r0,#0
                  |L1.11452|
;;;2168       }
;;;2169   
;;;2170       a = cJSON_CreateArray();
;;;2171       for(i = 0; a && (i < (size_t)count); i++)
;;;2172       {
;;;2173           n = cJSON_CreateNumber(numbers[i]);
;;;2174           if (!n)
;;;2175           {
;;;2176               cJSON_Delete(a);
;;;2177               return NULL;
;;;2178           }
;;;2179           if(!i)
;;;2180           {
;;;2181               a->child = n;
;;;2182           }
;;;2183           else
;;;2184           {
;;;2185               suffix_object(p, n);
;;;2186           }
;;;2187           p = n;
;;;2188       }
;;;2189   
;;;2190       return a;
;;;2191   }
002cbc  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.11456|
002cc0  ebfffffe          BL       cJSON_CreateArray
002cc4  e1a09000          MOV      r9,r0                 ;2170
002cc8  e3a04000          MOV      r4,#0                 ;2171
002ccc  ea000013          B        |L1.11552|
                  |L1.11472|
002cd0  e79a0104          LDR      r0,[r10,r4,LSL #2]    ;2173
002cd4  ebfffffe          BL       __aeabi_i2d
002cd8  e1a07000          MOV      r7,r0                 ;2173
002cdc  ebfffffe          BL       cJSON_CreateNumber
002ce0  e1a05000          MOV      r5,r0                 ;2173
002ce4  e3550000          CMP      r5,#0                 ;2174
002ce8  1a000003          BNE      |L1.11516|
002cec  e1a00009          MOV      r0,r9                 ;2176
002cf0  ebfffffe          BL       cJSON_Delete
002cf4  e3a00000          MOV      r0,#0                 ;2177
002cf8  eaffffef          B        |L1.11452|
                  |L1.11516|
002cfc  e3540000          CMP      r4,#0                 ;2179
002d00  1a000001          BNE      |L1.11532|
002d04  e5895008          STR      r5,[r9,#8]            ;2181
002d08  ea000002          B        |L1.11544|
                  |L1.11532|
002d0c  e1a01005          MOV      r1,r5                 ;2185
002d10  e1a0000b          MOV      r0,r11                ;2185
002d14  ebfffffe          BL       suffix_object
                  |L1.11544|
002d18  e1a0b005          MOV      r11,r5                ;2187
002d1c  e2844001          ADD      r4,r4,#1              ;2171
                  |L1.11552|
002d20  e3590000          CMP      r9,#0                 ;2171
002d24  0a000001          BEQ      |L1.11568|
002d28  e1540006          CMP      r4,r6                 ;2171
002d2c  3affffe7          BCC      |L1.11472|
                  |L1.11568|
002d30  e1a00009          MOV      r0,r9                 ;2190
002d34  eaffffe0          B        |L1.11452|
;;;2192   
                          ENDP

                  cJSON_CreateFloatArray PROC
;;;2193   cJSON *cJSON_CreateFloatArray(const float *numbers, int count)
002d38  e92d5ff0          PUSH     {r4-r12,lr}
;;;2194   {
002d3c  e1a0a000          MOV      r10,r0
002d40  e1a06001          MOV      r6,r1
;;;2195       size_t i = 0;
002d44  e3a04000          MOV      r4,#0
;;;2196       cJSON *n = NULL;
002d48  e3a05000          MOV      r5,#0
;;;2197       cJSON *p = NULL;
002d4c  e3a0b000          MOV      r11,#0
;;;2198       cJSON *a = NULL;
002d50  e3a09000          MOV      r9,#0
;;;2199   
;;;2200       if (count < 0)
002d54  e3560000          CMP      r6,#0
002d58  aa000001          BGE      |L1.11620|
;;;2201       {
;;;2202           return NULL;
002d5c  e3a00000          MOV      r0,#0
                  |L1.11616|
;;;2203       }
;;;2204   
;;;2205       a = cJSON_CreateArray();
;;;2206   
;;;2207       for(i = 0; a && (i < (size_t)count); i++)
;;;2208       {
;;;2209           n = cJSON_CreateNumber(numbers[i]);
;;;2210           if(!n)
;;;2211           {
;;;2212               cJSON_Delete(a);
;;;2213               return NULL;
;;;2214           }
;;;2215           if(!i)
;;;2216           {
;;;2217               a->child = n;
;;;2218           }
;;;2219           else
;;;2220           {
;;;2221               suffix_object(p, n);
;;;2222           }
;;;2223           p = n;
;;;2224       }
;;;2225   
;;;2226       return a;
;;;2227   }
002d60  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.11620|
002d64  ebfffffe          BL       cJSON_CreateArray
002d68  e1a09000          MOV      r9,r0                 ;2205
002d6c  e3a04000          MOV      r4,#0                 ;2207
002d70  ea000013          B        |L1.11716|
                  |L1.11636|
002d74  e79a0104          LDR      r0,[r10,r4,LSL #2]    ;2209
002d78  ebfffffe          BL       __aeabi_f2d
002d7c  e1a07000          MOV      r7,r0                 ;2209
002d80  ebfffffe          BL       cJSON_CreateNumber
002d84  e1a05000          MOV      r5,r0                 ;2209
002d88  e3550000          CMP      r5,#0                 ;2210
002d8c  1a000003          BNE      |L1.11680|
002d90  e1a00009          MOV      r0,r9                 ;2212
002d94  ebfffffe          BL       cJSON_Delete
002d98  e3a00000          MOV      r0,#0                 ;2213
002d9c  eaffffef          B        |L1.11616|
                  |L1.11680|
002da0  e3540000          CMP      r4,#0                 ;2215
002da4  1a000001          BNE      |L1.11696|
002da8  e5895008          STR      r5,[r9,#8]            ;2217
002dac  ea000002          B        |L1.11708|
                  |L1.11696|
002db0  e1a01005          MOV      r1,r5                 ;2221
002db4  e1a0000b          MOV      r0,r11                ;2221
002db8  ebfffffe          BL       suffix_object
                  |L1.11708|
002dbc  e1a0b005          MOV      r11,r5                ;2223
002dc0  e2844001          ADD      r4,r4,#1              ;2207
                  |L1.11716|
002dc4  e3590000          CMP      r9,#0                 ;2207
002dc8  0a000001          BEQ      |L1.11732|
002dcc  e1540006          CMP      r4,r6                 ;2207
002dd0  3affffe7          BCC      |L1.11636|
                  |L1.11732|
002dd4  e1a00009          MOV      r0,r9                 ;2226
002dd8  eaffffe0          B        |L1.11616|
;;;2228   
                          ENDP

                  cJSON_CreateDoubleArray PROC
;;;2229   cJSON *cJSON_CreateDoubleArray(const double *numbers, int count)
002ddc  e92d47f0          PUSH     {r4-r10,lr}
;;;2230   {
002de0  e1a08000          MOV      r8,r0
002de4  e1a06001          MOV      r6,r1
;;;2231       size_t i = 0;
002de8  e3a04000          MOV      r4,#0
;;;2232       cJSON *n = NULL;
002dec  e3a05000          MOV      r5,#0
;;;2233       cJSON *p = NULL;
002df0  e3a09000          MOV      r9,#0
;;;2234       cJSON *a = NULL;
002df4  e3a07000          MOV      r7,#0
;;;2235   
;;;2236       if (count < 0)
002df8  e3560000          CMP      r6,#0
002dfc  aa000001          BGE      |L1.11784|
;;;2237       {
;;;2238           return NULL;
002e00  e3a00000          MOV      r0,#0
                  |L1.11780|
;;;2239       }
;;;2240   
;;;2241       a = cJSON_CreateArray();
;;;2242   
;;;2243       for(i = 0;a && (i < (size_t)count); i++)
;;;2244       {
;;;2245           n = cJSON_CreateNumber(numbers[i]);
;;;2246           if(!n)
;;;2247           {
;;;2248               cJSON_Delete(a);
;;;2249               return NULL;
;;;2250           }
;;;2251           if(!i)
;;;2252           {
;;;2253               a->child = n;
;;;2254           }
;;;2255           else
;;;2256           {
;;;2257               suffix_object(p, n);
;;;2258           }
;;;2259           p = n;
;;;2260       }
;;;2261   
;;;2262       return a;
;;;2263   }
002e04  e8bd87f0          POP      {r4-r10,pc}
                  |L1.11784|
002e08  ebfffffe          BL       cJSON_CreateArray
002e0c  e1a07000          MOV      r7,r0                 ;2241
002e10  e3a04000          MOV      r4,#0                 ;2243
002e14  ea000014          B        |L1.11884|
                  |L1.11800|
002e18  e0880184          ADD      r0,r8,r4,LSL #3       ;2245
002e1c  e5901004          LDR      r1,[r0,#4]            ;2245
002e20  e5902000          LDR      r2,[r0,#0]            ;2245
002e24  e1a00002          MOV      r0,r2                 ;2245
002e28  ebfffffe          BL       cJSON_CreateNumber
002e2c  e1a05000          MOV      r5,r0                 ;2245
002e30  e3550000          CMP      r5,#0                 ;2246
002e34  1a000003          BNE      |L1.11848|
002e38  e1a00007          MOV      r0,r7                 ;2248
002e3c  ebfffffe          BL       cJSON_Delete
002e40  e3a00000          MOV      r0,#0                 ;2249
002e44  eaffffee          B        |L1.11780|
                  |L1.11848|
002e48  e3540000          CMP      r4,#0                 ;2251
002e4c  1a000001          BNE      |L1.11864|
002e50  e5875008          STR      r5,[r7,#8]            ;2253
002e54  ea000002          B        |L1.11876|
                  |L1.11864|
002e58  e1a01005          MOV      r1,r5                 ;2257
002e5c  e1a00009          MOV      r0,r9                 ;2257
002e60  ebfffffe          BL       suffix_object
                  |L1.11876|
002e64  e1a09005          MOV      r9,r5                 ;2259
002e68  e2844001          ADD      r4,r4,#1              ;2243
                  |L1.11884|
002e6c  e3570000          CMP      r7,#0                 ;2243
002e70  0a000001          BEQ      |L1.11900|
002e74  e1540006          CMP      r4,r6                 ;2243
002e78  3affffe6          BCC      |L1.11800|
                  |L1.11900|
002e7c  e1a00007          MOV      r0,r7                 ;2262
002e80  eaffffdf          B        |L1.11780|
;;;2264   
                          ENDP

                  cJSON_CreateStringArray PROC
;;;2265   cJSON *cJSON_CreateStringArray(const char **strings, int count)
002e84  e92d47f0          PUSH     {r4-r10,lr}
;;;2266   {
002e88  e1a08000          MOV      r8,r0
002e8c  e1a06001          MOV      r6,r1
;;;2267       size_t i = 0;
002e90  e3a04000          MOV      r4,#0
;;;2268       cJSON *n = NULL;
002e94  e3a05000          MOV      r5,#0
;;;2269       cJSON *p = NULL;
002e98  e3a09000          MOV      r9,#0
;;;2270       cJSON *a = NULL;
002e9c  e3a07000          MOV      r7,#0
;;;2271   
;;;2272       if (count < 0)
002ea0  e3560000          CMP      r6,#0
002ea4  aa000001          BGE      |L1.11952|
;;;2273       {
;;;2274           return NULL;
002ea8  e3a00000          MOV      r0,#0
                  |L1.11948|
;;;2275       }
;;;2276   
;;;2277       a = cJSON_CreateArray();
;;;2278   
;;;2279       for (i = 0; a && (i < (size_t)count); i++)
;;;2280       {
;;;2281           n = cJSON_CreateString(strings[i]);
;;;2282           if(!n)
;;;2283           {
;;;2284               cJSON_Delete(a);
;;;2285               return NULL;
;;;2286           }
;;;2287           if(!i)
;;;2288           {
;;;2289               a->child = n;
;;;2290           }
;;;2291           else
;;;2292           {
;;;2293               suffix_object(p,n);
;;;2294           }
;;;2295           p = n;
;;;2296       }
;;;2297   
;;;2298       return a;
;;;2299   }
002eac  e8bd87f0          POP      {r4-r10,pc}
                  |L1.11952|
002eb0  ebfffffe          BL       cJSON_CreateArray
002eb4  e1a07000          MOV      r7,r0                 ;2277
002eb8  e3a04000          MOV      r4,#0                 ;2279
002ebc  ea000011          B        |L1.12040|
                  |L1.11968|
002ec0  e7980104          LDR      r0,[r8,r4,LSL #2]     ;2281
002ec4  ebfffffe          BL       cJSON_CreateString
002ec8  e1a05000          MOV      r5,r0                 ;2281
002ecc  e3550000          CMP      r5,#0                 ;2282
002ed0  1a000003          BNE      |L1.12004|
002ed4  e1a00007          MOV      r0,r7                 ;2284
002ed8  ebfffffe          BL       cJSON_Delete
002edc  e3a00000          MOV      r0,#0                 ;2285
002ee0  eafffff1          B        |L1.11948|
                  |L1.12004|
002ee4  e3540000          CMP      r4,#0                 ;2287
002ee8  1a000001          BNE      |L1.12020|
002eec  e5875008          STR      r5,[r7,#8]            ;2289
002ef0  ea000002          B        |L1.12032|
                  |L1.12020|
002ef4  e1a01005          MOV      r1,r5                 ;2293
002ef8  e1a00009          MOV      r0,r9                 ;2293
002efc  ebfffffe          BL       suffix_object
                  |L1.12032|
002f00  e1a09005          MOV      r9,r5                 ;2295
002f04  e2844001          ADD      r4,r4,#1              ;2279
                  |L1.12040|
002f08  e3570000          CMP      r7,#0                 ;2279
002f0c  0a000001          BEQ      |L1.12056|
002f10  e1540006          CMP      r4,r6                 ;2279
002f14  3affffe9          BCC      |L1.11968|
                  |L1.12056|
002f18  e1a00007          MOV      r0,r7                 ;2298
002f1c  eaffffe2          B        |L1.11948|
                  |L1.12064|
                          DCD      ||.text||+0x14bc
                  |L1.12068|
                          DCD      ||.text||+0x14c4
                  |L1.12072|
                          DCD      0xffc00000
                  |L1.12076|
                          DCD      0x41dfffff
                  |L1.12080|
                          DCD      0xc1e00000
                          ENDP

                  cJSON_Duplicate PROC
;;;2301   /* Duplication */
;;;2302   cJSON *cJSON_Duplicate(const cJSON *item, cjbool recurse)
002f34  e92d47f0          PUSH     {r4-r10,lr}
;;;2303   {
002f38  e1a04000          MOV      r4,r0
002f3c  e1a09001          MOV      r9,r1
;;;2304       cJSON *newitem = NULL;
002f40  e3a05000          MOV      r5,#0
;;;2305       cJSON *child = NULL;
002f44  e3a07000          MOV      r7,#0
;;;2306       cJSON *next = NULL;
002f48  e3a08000          MOV      r8,#0
;;;2307       cJSON *newchild = NULL;
002f4c  e3a06000          MOV      r6,#0
;;;2308   
;;;2309       /* Bail on bad ptr */
;;;2310       if (!item)
002f50  e3540000          CMP      r4,#0
002f54  1a000000          BNE      |L1.12124|
;;;2311       {
;;;2312           goto fail;
002f58  ea00003e          B        |L1.12376|
                  |L1.12124|
;;;2313       }
;;;2314       /* Create new item */
;;;2315       newitem = cJSON_New_Item();
002f5c  ebfffffe          BL       cJSON_New_Item
002f60  e1a05000          MOV      r5,r0
;;;2316       if (!newitem)
002f64  e3550000          CMP      r5,#0
002f68  1a000000          BNE      |L1.12144|
;;;2317       {
;;;2318           goto fail;
002f6c  ea000039          B        |L1.12376|
                  |L1.12144|
;;;2319       }
;;;2320       /* Copy over all vars */
;;;2321       newitem->type = item->type & (~cJSON_IsReference);
002f70  e594000c          LDR      r0,[r4,#0xc]
002f74  e3c00c01          BIC      r0,r0,#0x100
002f78  e585000c          STR      r0,[r5,#0xc]
;;;2322       newitem->valueint = item->valueint;
002f7c  e5940014          LDR      r0,[r4,#0x14]
002f80  e5850014          STR      r0,[r5,#0x14]
;;;2323       newitem->valuedouble = item->valuedouble;
002f84  e1c401d8          LDRD     r0,r1,[r4,#0x18]
002f88  e1c501f8          STRD     r0,r1,[r5,#0x18]
;;;2324       if (item->valuestring)
002f8c  e5940010          LDR      r0,[r4,#0x10]
002f90  e3500000          CMP      r0,#0
002f94  0a000006          BEQ      |L1.12212|
;;;2325       {
;;;2326           newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring);
002f98  e5940010          LDR      r0,[r4,#0x10]
002f9c  ebfffffe          BL       cJSON_strdup
002fa0  e5850010          STR      r0,[r5,#0x10]
;;;2327           if (!newitem->valuestring)
002fa4  e5950010          LDR      r0,[r5,#0x10]
002fa8  e3500000          CMP      r0,#0
002fac  1a000000          BNE      |L1.12212|
;;;2328           {
;;;2329               goto fail;
002fb0  ea000028          B        |L1.12376|
                  |L1.12212|
;;;2330           }
;;;2331       }
;;;2332       if (item->string)
002fb4  e5940020          LDR      r0,[r4,#0x20]
002fb8  e3500000          CMP      r0,#0
002fbc  0a00000b          BEQ      |L1.12272|
;;;2333       {
;;;2334           newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string);
002fc0  e1d400bc          LDRH     r0,[r4,#0xc]
002fc4  e3100c02          TST      r0,#0x200
002fc8  0a000001          BEQ      |L1.12244|
002fcc  e5940020          LDR      r0,[r4,#0x20]
002fd0  ea000001          B        |L1.12252|
                  |L1.12244|
002fd4  e5940020          LDR      r0,[r4,#0x20]
002fd8  ebfffffe          BL       cJSON_strdup
                  |L1.12252|
002fdc  e5850020          STR      r0,[r5,#0x20]
;;;2335           if (!newitem->string)
002fe0  e5950020          LDR      r0,[r5,#0x20]
002fe4  e3500000          CMP      r0,#0
002fe8  1a000000          BNE      |L1.12272|
;;;2336           {
;;;2337               goto fail;
002fec  ea000019          B        |L1.12376|
                  |L1.12272|
;;;2338           }
;;;2339       }
;;;2340       /* If non-recursive, then we're done! */
;;;2341       if (!recurse)
002ff0  e3590000          CMP      r9,#0
002ff4  1a000001          BNE      |L1.12288|
;;;2342       {
;;;2343           return newitem;
002ff8  e1a00005          MOV      r0,r5
                  |L1.12284|
;;;2344       }
;;;2345       /* Walk the ->next chain for the child. */
;;;2346       child = item->child;
;;;2347       while (child != NULL)
;;;2348       {
;;;2349           newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
;;;2350           if (!newchild)
;;;2351           {
;;;2352               goto fail;
;;;2353           }
;;;2354           if (next != NULL)
;;;2355           {
;;;2356               /* If newitem->child already set, then crosswire ->prev and ->next and move on */
;;;2357               next->next = newchild;
;;;2358               newchild->prev = next;
;;;2359               next = newchild;
;;;2360           }
;;;2361           else
;;;2362           {
;;;2363               /* Set newitem->child and move to it */
;;;2364               newitem->child = newchild;
;;;2365               next = newchild;
;;;2366           }
;;;2367           child = child->next;
;;;2368       }
;;;2369   
;;;2370       return newitem;
;;;2371   
;;;2372   fail:
;;;2373       if (newitem != NULL)
;;;2374       {
;;;2375           cJSON_Delete(newitem);
;;;2376       }
;;;2377   
;;;2378       return NULL;
;;;2379   }
002ffc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.12288|
003000  e5947008          LDR      r7,[r4,#8]            ;2346
003004  ea00000f          B        |L1.12360|
                  |L1.12296|
003008  e3a01001          MOV      r1,#1                 ;2349
00300c  e1a00007          MOV      r0,r7                 ;2349
003010  ebfffffe          BL       cJSON_Duplicate
003014  e1a06000          MOV      r6,r0                 ;2349
003018  e3560000          CMP      r6,#0                 ;2350
00301c  1a000000          BNE      |L1.12324|
003020  ea00000c          B        |L1.12376|
                  |L1.12324|
003024  e3580000          CMP      r8,#0                 ;2354
003028  0a000003          BEQ      |L1.12348|
00302c  e5886000          STR      r6,[r8,#0]            ;2357
003030  e5868004          STR      r8,[r6,#4]            ;2358
003034  e1a08006          MOV      r8,r6                 ;2359
003038  ea000001          B        |L1.12356|
                  |L1.12348|
00303c  e5856008          STR      r6,[r5,#8]            ;2364
003040  e1a08006          MOV      r8,r6                 ;2365
                  |L1.12356|
003044  e5977000          LDR      r7,[r7,#0]            ;2367
                  |L1.12360|
003048  e3570000          CMP      r7,#0                 ;2347
00304c  1affffed          BNE      |L1.12296|
003050  e1a00005          MOV      r0,r5                 ;2370
003054  eaffffe8          B        |L1.12284|
                  |L1.12376|
003058  e1a00000          MOV      r0,r0                 ;2372
00305c  e3550000          CMP      r5,#0                 ;2373
003060  0a000001          BEQ      |L1.12396|
003064  e1a00005          MOV      r0,r5                 ;2375
003068  ebfffffe          BL       cJSON_Delete
                  |L1.12396|
00306c  e3a00000          MOV      r0,#0                 ;2378
003070  eaffffe1          B        |L1.12284|
;;;2380   
                          ENDP

                  cJSON_Minify PROC
;;;2381   void cJSON_Minify(char *json)
003074  e1a01000          MOV      r1,r0
;;;2382   {
;;;2383       unsigned char *into = (unsigned char*)json;
;;;2384       while (*json)
003078  ea00004d          B        |L1.12724|
                  |L1.12412|
;;;2385       {
;;;2386           if (*json == ' ')
00307c  e5d02000          LDRB     r2,[r0,#0]
003080  e3520020          CMP      r2,#0x20
003084  1a000001          BNE      |L1.12432|
;;;2387           {
;;;2388               json++;
003088  e2800001          ADD      r0,r0,#1
00308c  ea000048          B        |L1.12724|
                  |L1.12432|
;;;2389           }
;;;2390           else if (*json == '\t')
003090  e5d02000          LDRB     r2,[r0,#0]
003094  e3520009          CMP      r2,#9
003098  1a000001          BNE      |L1.12452|
;;;2391           {
;;;2392               /* Whitespace characters. */
;;;2393               json++;
00309c  e2800001          ADD      r0,r0,#1
0030a0  ea000043          B        |L1.12724|
                  |L1.12452|
;;;2394           }
;;;2395           else if (*json == '\r')
0030a4  e5d02000          LDRB     r2,[r0,#0]
0030a8  e352000d          CMP      r2,#0xd
0030ac  1a000001          BNE      |L1.12472|
;;;2396           {
;;;2397               json++;
0030b0  e2800001          ADD      r0,r0,#1
0030b4  ea00003e          B        |L1.12724|
                  |L1.12472|
;;;2398           }
;;;2399           else if (*json=='\n')
0030b8  e5d02000          LDRB     r2,[r0,#0]
0030bc  e352000a          CMP      r2,#0xa
0030c0  1a000001          BNE      |L1.12492|
;;;2400           {
;;;2401               json++;
0030c4  e2800001          ADD      r0,r0,#1
0030c8  ea000039          B        |L1.12724|
                  |L1.12492|
;;;2402           }
;;;2403           else if ((*json == '/') && (json[1] == '/'))
0030cc  e5d02000          LDRB     r2,[r0,#0]
0030d0  e352002f          CMP      r2,#0x2f
0030d4  1a00000b          BNE      |L1.12552|
0030d8  e5d02001          LDRB     r2,[r0,#1]
0030dc  e352002f          CMP      r2,#0x2f
0030e0  1a000008          BNE      |L1.12552|
;;;2404           {
;;;2405               /* double-slash comments, to end of line. */
;;;2406               while (*json && (*json != '\n'))
0030e4  ea000000          B        |L1.12524|
                  |L1.12520|
;;;2407               {
;;;2408                   json++;
0030e8  e2800001          ADD      r0,r0,#1
                  |L1.12524|
0030ec  e5d02000          LDRB     r2,[r0,#0]            ;2406
0030f0  e3520000          CMP      r2,#0                 ;2406
0030f4  0a00002e          BEQ      |L1.12724|
0030f8  e5d02000          LDRB     r2,[r0,#0]            ;2406
0030fc  e352000a          CMP      r2,#0xa               ;2406
003100  0a00002b          BEQ      |L1.12724|
003104  eafffff7          B        |L1.12520|
                  |L1.12552|
;;;2409               }
;;;2410           }
;;;2411           else if ((*json == '/') && (json[1] == '*'))
003108  e5d02000          LDRB     r2,[r0,#0]
00310c  e352002f          CMP      r2,#0x2f
003110  1a00000f          BNE      |L1.12628|
003114  e5d02001          LDRB     r2,[r0,#1]
003118  e352002a          CMP      r2,#0x2a
00311c  1a00000c          BNE      |L1.12628|
;;;2412           {
;;;2413               /* multiline comments. */
;;;2414               while (*json && !((*json == '*') && (json[1] == '/')))
003120  ea000000          B        |L1.12584|
                  |L1.12580|
;;;2415               {
;;;2416                   json++;
003124  e2800001          ADD      r0,r0,#1
                  |L1.12584|
003128  e5d02000          LDRB     r2,[r0,#0]            ;2414
00312c  e3520000          CMP      r2,#0                 ;2414
003130  0a000005          BEQ      |L1.12620|
003134  e5d02000          LDRB     r2,[r0,#0]            ;2414
003138  e352002a          CMP      r2,#0x2a              ;2414
00313c  1afffff8          BNE      |L1.12580|
003140  e5d02001          LDRB     r2,[r0,#1]            ;2414
003144  e352002f          CMP      r2,#0x2f              ;2414
003148  1afffff5          BNE      |L1.12580|
                  |L1.12620|
;;;2417               }
;;;2418               json += 2;
00314c  e2800002          ADD      r0,r0,#2
003150  ea000017          B        |L1.12724|
                  |L1.12628|
;;;2419           }
;;;2420           else if (*json == '\"')
003154  e5d02000          LDRB     r2,[r0,#0]
003158  e3520022          CMP      r2,#0x22
00315c  1a000012          BNE      |L1.12716|
;;;2421           {
;;;2422               /* string literals, which are \" sensitive. */
;;;2423               *into++ = (unsigned char)*json++;
003160  e4d02001          LDRB     r2,[r0],#1
003164  e4c12001          STRB     r2,[r1],#1
;;;2424               while (*json && (*json != '\"'))
003168  ea000006          B        |L1.12680|
                  |L1.12652|
;;;2425               {
;;;2426                   if (*json == '\\')
00316c  e5d02000          LDRB     r2,[r0,#0]
003170  e352005c          CMP      r2,#0x5c
003174  1a000001          BNE      |L1.12672|
;;;2427                   {
;;;2428                       *into++ = (unsigned char)*json++;
003178  e4d02001          LDRB     r2,[r0],#1
00317c  e4c12001          STRB     r2,[r1],#1
                  |L1.12672|
;;;2429                   }
;;;2430                   *into++ = (unsigned char)*json++;
003180  e4d02001          LDRB     r2,[r0],#1
003184  e4c12001          STRB     r2,[r1],#1
                  |L1.12680|
003188  e5d02000          LDRB     r2,[r0,#0]            ;2424
00318c  e3520000          CMP      r2,#0                 ;2424
003190  0a000002          BEQ      |L1.12704|
003194  e5d02000          LDRB     r2,[r0,#0]            ;2424
003198  e3520022          CMP      r2,#0x22              ;2424
00319c  1afffff2          BNE      |L1.12652|
                  |L1.12704|
;;;2431               }
;;;2432               *into++ = (unsigned char)*json++;
0031a0  e4d02001          LDRB     r2,[r0],#1
0031a4  e4c12001          STRB     r2,[r1],#1
0031a8  ea000001          B        |L1.12724|
                  |L1.12716|
;;;2433           }
;;;2434           else
;;;2435           {
;;;2436               /* All other characters. */
;;;2437               *into++ = (unsigned char)*json++;
0031ac  e4d02001          LDRB     r2,[r0],#1
0031b0  e4c12001          STRB     r2,[r1],#1
                  |L1.12724|
0031b4  e5d02000          LDRB     r2,[r0,#0]            ;2384
0031b8  e3520000          CMP      r2,#0                 ;2384
0031bc  1affffae          BNE      |L1.12412|
;;;2438           }
;;;2439       }
;;;2440   
;;;2441       /* and null-terminate. */
;;;2442       *into = '\0';
0031c0  e3a02000          MOV      r2,#0
0031c4  e5c12000          STRB     r2,[r1,#0]
;;;2443   }
0031c8  e12fff1e          BX       lr
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  version
                          %        15

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  firstByteMark
000000  0000c0e0          DCB      0x00,0x00,0xc0,0xe0
000004  f0                DCB      0xf0

                          AREA ||.data||, DATA, ALIGN=2

                  global_ep
                          DCD      0x00000000
                  cJSON_malloc
                          DCD      pvPortMalloc
                  cJSON_free
                          DCD      vPortFree
