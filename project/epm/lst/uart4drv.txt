; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart4drv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart4drv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uart4drv.crf src\userdrv\uart4drv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART4SetPower PROC
;;;168    
;;;169    BOOL UART4SetPower(BOOL flag)
000000  e92d4010          PUSH     {r4,lr}
;;;170    {
000004  e1a04000          MOV      r4,r0
;;;171        if(flag)
000008  e3540000          CMP      r4,#0
00000c  0a000008          BEQ      |L1.52|
;;;172        {         
;;;173            GPIO_SetBit(POWER_PORT, POWER_PIN);   
000010  e3a01080          MOV      r1,#0x80
000014  e3a00d06          MOV      r0,#0x180
000018  ebfffffe          BL       GPIO_SetBit
;;;174            outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<20)) | (0x1<<20));         
00001c  e3a0020b          MOV      r0,#0xb0000000
000020  e5900218          LDR      r0,[r0,#0x218]
000024  e3800601          ORR      r0,r0,#0x100000
000028  e3a0120b          MOV      r1,#0xb0000000
00002c  e5810218          STR      r0,[r1,#0x218]
000030  ea000007          B        |L1.84|
                  |L1.52|
;;;175        }
;;;176        else
;;;177        {
;;;178            GPIO_ClrBit(POWER_PORT, POWER_PIN);  
000034  e3a01080          MOV      r1,#0x80
000038  e3a00d06          MOV      r0,#0x180
00003c  ebfffffe          BL       GPIO_ClrBit
;;;179            outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<20)) | (0x0<<20));        
000040  e3a0020b          MOV      r0,#0xb0000000
000044  e5900218          LDR      r0,[r0,#0x218]
000048  e3c00601          BIC      r0,r0,#0x100000
00004c  e3a0120b          MOV      r1,#0xb0000000
000050  e5810218          STR      r0,[r1,#0x218]
                  |L1.84|
;;;180        }
;;;181        return TRUE;
000054  e3a00001          MOV      r0,#1
;;;182    }
000058  e8bd8010          POP      {r4,pc}
;;;183    BOOL UART4SetRS232Power(BOOL flag)
                          ENDP

                  hwInit PROC
;;;39     /*-----------------------------------------*/
;;;40     static BOOL hwInit(UINT32 baudRate)
00005c  e92d4070          PUSH     {r4-r6,lr}
;;;41     {
000060  e1a05000          MOV      r5,r0
;;;42         int retval;
;;;43         outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000064  e3a0020b          MOV      r0,#0xb0000000
000068  e5900218          LDR      r0,[r0,#0x218]
00006c  e3800008          ORR      r0,r0,#8
000070  e3a0120b          MOV      r1,#0xb0000000
000074  e5810218          STR      r0,[r1,#0x218]
;;;44         
;;;45         // GPH 8, 9, 10, 11 //TX, RX, RTS, CTS
;;;46         outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<<0)) | (0x9<<0));
000078  e3a0020b          MOV      r0,#0xb0000000
00007c  e59000ac          LDR      r0,[r0,#0xac]
000080  e3c0000f          BIC      r0,r0,#0xf
000084  e3800009          ORR      r0,r0,#9
000088  e58100ac          STR      r0,[r1,#0xac]
;;;47         outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<<4)) | (0x9<<4));
00008c  e3a0020b          MOV      r0,#0xb0000000
000090  e59000ac          LDR      r0,[r0,#0xac]
000094  e3c000f0          BIC      r0,r0,#0xf0
000098  e3800090          ORR      r0,r0,#0x90
00009c  e58100ac          STR      r0,[r1,#0xac]
;;;48         outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<<8)) | (0x9<<8));
0000a0  e3a0020b          MOV      r0,#0xb0000000
0000a4  e59000ac          LDR      r0,[r0,#0xac]
0000a8  e3c00c0f          BIC      r0,r0,#0xf00
0000ac  e3800c09          ORR      r0,r0,#0x900
0000b0  e58100ac          STR      r0,[r1,#0xac]
;;;49         outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<<12)) | (0x9<<12));     
0000b4  e3a0020b          MOV      r0,#0xb0000000
0000b8  e59000ac          LDR      r0,[r0,#0xac]
0000bc  e3c00a0f          BIC      r0,r0,#0xf000
0000c0  e3800a09          ORR      r0,r0,#0x9000
0000c4  e58100ac          STR      r0,[r1,#0xac]
;;;50         
;;;51         //Power pin GPG7
;;;52         outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xFu<<28)) | (0x0u<<28));
0000c8  e3a0020b          MOV      r0,#0xb0000000
0000cc  e59000a0          LDR      r0,[r0,#0xa0]
0000d0  e3c0020f          BIC      r0,r0,#0xf0000000
0000d4  e58100a0          STR      r0,[r1,#0xa0]
;;;53         GPIO_OpenBit(POWER_PORT, POWER_PIN, DIR_OUTPUT, NO_PULL_UP);
0000d8  e3a03000          MOV      r3,#0
0000dc  e3a02001          MOV      r2,#1
0000e0  e3a01080          MOV      r1,#0x80
0000e4  e3a00d06          MOV      r0,#0x180
0000e8  ebfffffe          BL       GPIO_OpenBit
;;;54         //GPIO_OpenBit(POWER_PORT, POWER_PIN, DIR_OUTPUT, PULL_UP);    
;;;55         UART4SetPower(FALSE);
0000ec  e3a00000          MOV      r0,#0
0000f0  ebfffffe          BL       UART4SetPower
;;;56         
;;;57         /* configure UART */
;;;58         param.uFreq = 12000000;
0000f4  e59f0200          LDR      r0,|L1.764|
0000f8  e59f1200          LDR      r1,|L1.768|
0000fc  e5810000          STR      r0,[r1,#0]  ; param
;;;59         param.uBaudRate = baudRate;
000100  e2810000          ADD      r0,r1,#0
000104  e5805004          STR      r5,[r0,#4]  ; param
;;;60         param.ucUartNo = UART4;
000108  e3a00004          MOV      r0,#4
00010c  e5c10008          STRB     r0,[r1,#8]  ; param
;;;61         param.ucDataBits = DATA_BITS_8;
000110  e3a00003          MOV      r0,#3
000114  e5c10009          STRB     r0,[r1,#9]  ; param
;;;62         param.ucStopBits = STOP_BITS_1;
000118  e3a00000          MOV      r0,#0
00011c  e5c1000a          STRB     r0,[r1,#0xa]  ; param
;;;63         param.ucParity = PARITY_NONE;
000120  e5c1000b          STRB     r0,[r1,#0xb]  ; param
;;;64         param.ucRxTriggerLevel = UART_FCR_RFITL_1BYTE;
000124  e5c1000c          STRB     r0,[r1,#0xc]  ; param
;;;65         retval = uartOpen(&param);
000128  e2810000          ADD      r0,r1,#0
00012c  ebfffffe          BL       uartOpen
000130  e1a04000          MOV      r4,r0
;;;66         if(retval != 0) 
000134  e3540000          CMP      r4,#0
000138  0a000003          BEQ      |L1.332|
;;;67         {
;;;68             sysprintf("hwInit Open UART error!\n");
00013c  e28f0d07          ADR      r0,|L1.772|
000140  ebfffffe          BL       sysprintf
;;;69             return FALSE;
000144  e3a00000          MOV      r0,#0
                  |L1.328|
;;;70         }
;;;71     
;;;72         /* set TX interrupt mode */
;;;73         retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTPOLLMODE /*UARTINTMODE*/ , 0);
;;;74         //retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTINTMODE , 0);
;;;75         if (retval != 0) 
;;;76         {
;;;77             sysprintf("hwInit Set TX interrupt mode fail!\n");
;;;78             return FALSE;
;;;79         }
;;;80     
;;;81         /* set RX interrupt mode */
;;;82         retval = uartIoctl(param.ucUartNo, UART_IOC_SETRXMODE, UARTINTMODE, 0);
;;;83         if (retval != 0) 
;;;84         {
;;;85             sysprintf("hwInit Set RX interrupt mode fail!\n");
;;;86             return FALSE;
;;;87         }
;;;88     
;;;89         return TRUE;
;;;90     }
000148  e8bd8070          POP      {r4-r6,pc}
                  |L1.332|
00014c  e59f11ac          LDR      r1,|L1.768|
000150  e5d10008          LDRB     r0,[r1,#8]            ;73  ; param
000154  e3a03000          MOV      r3,#0                 ;73
000158  e1a02003          MOV      r2,r3                 ;73
00015c  e3a01001          MOV      r1,#1                 ;73
000160  ebfffffe          BL       uartIoctl
000164  e1a04000          MOV      r4,r0                 ;73
000168  e3540000          CMP      r4,#0                 ;75
00016c  0a000003          BEQ      |L1.384|
000170  e28f0f6a          ADR      r0,|L1.800|
000174  ebfffffe          BL       sysprintf
000178  e3a00000          MOV      r0,#0                 ;78
00017c  eafffff1          B        |L1.328|
                  |L1.384|
000180  e59f1178          LDR      r1,|L1.768|
000184  e5d10008          LDRB     r0,[r1,#8]            ;82  ; param
000188  e3a03000          MOV      r3,#0                 ;82
00018c  e3a02001          MOV      r2,#1                 ;82
000190  e3a01002          MOV      r1,#2                 ;82
000194  ebfffffe          BL       uartIoctl
000198  e1a04000          MOV      r4,r0                 ;82
00019c  e3540000          CMP      r4,#0                 ;83
0001a0  0a000003          BEQ      |L1.436|
0001a4  e28f0f66          ADR      r0,|L1.836|
0001a8  ebfffffe          BL       sysprintf
0001ac  e3a00000          MOV      r0,#0                 ;86
0001b0  eaffffe4          B        |L1.328|
                  |L1.436|
0001b4  e3a00001          MOV      r0,#1                 ;89
0001b8  eaffffe2          B        |L1.328|
;;;91     
                          ENDP

                  UART4DrvInit PROC
;;;94     /*-----------------------------------------*/
;;;95     BOOL UART4DrvInit(UINT32 baudRate)
0001bc  e92d4070          PUSH     {r4-r6,lr}
;;;96     {
0001c0  e1a05000          MOV      r5,r0
;;;97         int retval;
;;;98         sysprintf("UART4DrvInit!!\n");
0001c4  e28f0f67          ADR      r0,|L1.872|
0001c8  ebfffffe          BL       sysprintf
;;;99         retval = hwInit(baudRate);
0001cc  e1a00005          MOV      r0,r5
0001d0  ebfffffe          BL       hwInit
0001d4  e1a04000          MOV      r4,r0
;;;100        return retval;
0001d8  e1a00004          MOV      r0,r4
;;;101    }
0001dc  e8bd8070          POP      {r4-r6,pc}
;;;102    INT32 UART4Write(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART4Write PROC
0001e0  e92d4070          PUSH     {r4-r6,lr}
;;;103    {
0001e4  e1a04000          MOV      r4,r0
0001e8  e1a05001          MOV      r5,r1
;;;104        INT32  reVal;
;;;105        
;;;106        /*
;;;107        terninalPrintf("Modem>=");
;;;108        for(int i=0;i<uLen;i++)
;;;109        terninalPrintf("%02x ",pucBuf[i]);
;;;110        terninalPrintf("\n  ");
;;;111                               
;;;112        for(int k=0;k<uLen;k++)
;;;113        {
;;;114            if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;115                terninalPrintf("%c",pucBuf[k]);
;;;116        } 
;;;117        terninalPrintf("\n"); 
;;;118        */
;;;119        
;;;120                               
;;;121        reVal = uartWrite(param.ucUartNo, pucBuf, uLen);
0001ec  e59f110c          LDR      r1,|L1.768|
0001f0  e5d10008          LDRB     r0,[r1,#8]  ; param
0001f4  e1a02005          MOV      r2,r5
0001f8  e1a01004          MOV      r1,r4
0001fc  ebfffffe          BL       uartWrite
000200  e1a06000          MOV      r6,r0
;;;122        return reVal;
000204  e1a00006          MOV      r0,r6
;;;123    }
000208  e8bd8070          POP      {r4-r6,pc}
;;;124    INT32 UART4Read(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART4Read PROC
00020c  e92d4070          PUSH     {r4-r6,lr}
;;;125    {
000210  e1a04000          MOV      r4,r0
000214  e1a05001          MOV      r5,r1
;;;126        
;;;127        /*
;;;128        INT32 temp;
;;;129        memset(pucBuf,0x00,uLen);
;;;130        temp = uartRead(param.ucUartNo, pucBuf, uLen);
;;;131        
;;;132        terninalPrintf("<=");
;;;133        int counter = 0; 
;;;134        for(int i=0;i<uLen;i++)
;;;135        {
;;;136            if(i>2)
;;;137            {                                    
;;;138                if((pucBuf[i]==0x00) && (pucBuf[i-1]==0x0A) && (pucBuf[i-2]==0x0D))
;;;139                {
;;;140                    counter = i;
;;;141                    break;
;;;142                }
;;;143                if((pucBuf[i]==0x00) && (pucBuf[i-1]==0x00) && (pucBuf[i-2]==0x00))
;;;144                {
;;;145                    //counter = i;
;;;146                    break;
;;;147                }
;;;148            }
;;;149            terninalPrintf("%02x ",pucBuf[i]);
;;;150        }
;;;151        terninalPrintf("\n  ");
;;;152        for(int k=0;k<counter;k++)
;;;153        {
;;;154            if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;155                terninalPrintf("%c",pucBuf[k]);
;;;156        } 
;;;157        terninalPrintf("\n"); 
;;;158        
;;;159        return temp;  
;;;160        */
;;;161        
;;;162        return uartRead(param.ucUartNo, pucBuf, uLen);
000218  e59f10e0          LDR      r1,|L1.768|
00021c  e5d10008          LDRB     r0,[r1,#8]  ; param
000220  e1a02005          MOV      r2,r5
000224  e1a01004          MOV      r1,r4
000228  ebfffffe          BL       uartRead
;;;163    }
00022c  e8bd8070          POP      {r4-r6,pc}
;;;164    BaseType_t UART4ReadWait(TickType_t time)
                          ENDP

                  UART4ReadWait PROC
000230  e92d4010          PUSH     {r4,lr}
;;;165    {
000234  e1a04000          MOV      r4,r0
;;;166        return  uartWaitReadEvent(param.ucUartNo, time);
000238  e59f10c0          LDR      r1,|L1.768|
00023c  e5d10008          LDRB     r0,[r1,#8]  ; param
000240  e1a01004          MOV      r1,r4
000244  ebfffffe          BL       uartWaitReadEvent
;;;167    }
000248  e8bd8010          POP      {r4,pc}
;;;168    
                          ENDP

                  UART4SetRS232Power PROC
;;;182    }
;;;183    BOOL UART4SetRS232Power(BOOL flag)
00024c  e1a01000          MOV      r1,r0
;;;184    {
;;;185        return FALSE;
000250  e3a00000          MOV      r0,#0
;;;186    }
000254  e12fff1e          BX       lr
;;;187    INT UART4Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
                          ENDP

                  UART4Ioctl PROC
000258  e92d4070          PUSH     {r4-r6,lr}
;;;188    {
00025c  e1a04000          MOV      r4,r0
000260  e1a05001          MOV      r5,r1
000264  e1a06002          MOV      r6,r2
;;;189        return uartIoctl(param.ucUartNo, uCmd, uArg0, uArg1);
000268  e59f1090          LDR      r1,|L1.768|
00026c  e5d10008          LDRB     r0,[r1,#8]  ; param
000270  e1a03006          MOV      r3,r6
000274  e1a02005          MOV      r2,r5
000278  e1a01004          MOV      r1,r4
00027c  ebfffffe          BL       uartIoctl
;;;190    }
000280  e8bd8070          POP      {r4-r6,pc}
;;;191    
                          ENDP

                  UART4SetRTS PROC
;;;192    void UART4SetRTS(BOOL flag)
000284  e92d4010          PUSH     {r4,lr}
;;;193    {
000288  e1a04000          MOV      r4,r0
;;;194        if(flag)
00028c  e3540000          CMP      r4,#0
000290  0a000006          BEQ      |L1.688|
;;;195            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
000294  e59f1064          LDR      r1,|L1.768|
000298  e5d10008          LDRB     r0,[r1,#8]  ; param
00029c  e3a03000          MOV      r3,#0
0002a0  e1a02003          MOV      r2,r3
0002a4  e3a01010          MOV      r1,#0x10
0002a8  ebfffffe          BL       uartIoctl
0002ac  ea000005          B        |L1.712|
                  |L1.688|
;;;196        else
;;;197            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
0002b0  e59f1048          LDR      r1,|L1.768|
0002b4  e5d10008          LDRB     r0,[r1,#8]  ; param
0002b8  e3a03000          MOV      r3,#0
0002bc  e3a02001          MOV      r2,#1
0002c0  e3a01010          MOV      r1,#0x10
0002c4  ebfffffe          BL       uartIoctl
                  |L1.712|
;;;198    }
0002c8  e8bd8010          POP      {r4,pc}
;;;199    
                          ENDP

                  UART4FlushBuffer PROC
;;;200    void UART4FlushBuffer(void)
0002cc  e92d4010          PUSH     {r4,lr}
;;;201    {
;;;202        //sysprintf(" --> CardFlushBuffer\n");
;;;203        //if (pUartInterface->ioctlFunc(UART_IOC_FLUSH_TX_BUFFER, 0, 0) != 0) {
;;;204       //     sysprintf("Set TX Flush fail!\n");
;;;205        //    return;
;;;206        //}
;;;207        if (UART4Ioctl(UART_IOC_FLUSH_RX_BUFFER, 0, 0) != 0) {
0002d0  e3a02000          MOV      r2,#0
0002d4  e1a01002          MOV      r1,r2
0002d8  e3a00019          MOV      r0,#0x19
0002dc  ebfffffe          BL       UART4Ioctl
0002e0  e3500000          CMP      r0,#0
0002e4  0a000002          BEQ      |L1.756|
;;;208            sysprintf("Set RX Flush fail!\n");
0002e8  e28f0088          ADR      r0,|L1.888|
0002ec  ebfffffe          BL       sysprintf
                  |L1.752|
;;;209            return;
;;;210        }
;;;211    }
0002f0  e8bd8010          POP      {r4,pc}
                  |L1.756|
0002f4  e1a00000          MOV      r0,r0
0002f8  eafffffc          B        |L1.752|
;;;212        
                          ENDP

                  |L1.764|
                          DCD      0x00b71b00
                  |L1.768|
                          DCD      param
                  |L1.772|
000304  6877496e          DCB      "hwInit Open UART error!\n",0
000308  6974204f
00030c  70656e20
000310  55415254
000314  20657272
000318  6f72210a
00031c  00      
00031d  00                DCB      0
00031e  00                DCB      0
00031f  00                DCB      0
                  |L1.800|
000320  6877496e          DCB      "hwInit Set TX interrupt mode fail!\n",0
000324  69742053
000328  65742054
00032c  5820696e
000330  74657272
000334  75707420
000338  6d6f6465
00033c  20666169
000340  6c210a00
                  |L1.836|
000344  6877496e          DCB      "hwInit Set RX interrupt mode fail!\n",0
000348  69742053
00034c  65742052
000350  5820696e
000354  74657272
000358  75707420
00035c  6d6f6465
000360  20666169
000364  6c210a00
                  |L1.872|
000368  55415254          DCB      "UART4DrvInit!!\n",0
00036c  34447276
000370  496e6974
000374  21210a00
                  |L1.888|
000378  53657420          DCB      "Set RX Flush fail!\n",0
00037c  52582046
000380  6c757368
000384  20666169
000388  6c210a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param
                          %        16
