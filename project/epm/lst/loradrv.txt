; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\loradrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\loradrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\loradrv.crf src\UserDrv\loradrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  LoraWaitForReady PROC
;;;40     /*-----------------------------------------*/
;;;41     static BOOL LoraWaitForReady(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;42     {
;;;43         int timers = 2000;
000004  e3a04e7d          MOV      r4,#0x7d0
;;;44         TickType_t mTick = xTaskGetTickCount();
000008  ebfffffe          BL       xTaskGetTickCount
00000c  e1a05000          MOV      r5,r0
;;;45         while(GPIO_ReadBit(LORA_BUSY_PORT,LORA_BUSY_PIN)==0)
000010  ea000008          B        |L1.56|
                  |L1.20|
;;;46         {
;;;47             //sysprintf("{%d}", 500-timers);
;;;48             if(timers-- == 0)
000014  e1b00004          MOVS     r0,r4
000018  e2444001          SUB      r4,r4,#1
00001c  1a000003          BNE      |L1.48|
;;;49             {
;;;50                 sysprintf("\r\n ##  LoraWaitForReady timeout  ##\n");            
000020  e28f0f65          ADR      r0,|L1.444|
000024  ebfffffe          BL       sysprintf
;;;51                 return FALSE;
000028  e3a00000          MOV      r0,#0
                  |L1.44|
;;;52             }
;;;53             vTaskDelay(1/portTICK_RATE_MS); 
;;;54             //sysDelay(1);
;;;55         };
;;;56         //if(xTaskGetTickCount() != mTick)
;;;57         //    sysprintf("\r\nLoraWaitForReady {%d}\r\n", xTaskGetTickCount() - mTick);
;;;58         return TRUE;
;;;59     }
00002c  e8bd8070          POP      {r4-r6,pc}
                  |L1.48|
000030  e3a00000          MOV      r0,#0                 ;53
000034  ebfffffe          BL       vTaskDelay
                  |L1.56|
000038  e3a01080          MOV      r1,#0x80              ;45
00003c  e3a00d07          MOV      r0,#0x1c0             ;45
000040  ebfffffe          BL       GPIO_ReadBit
000044  e3500000          CMP      r0,#0                 ;45
000048  0afffff1          BEQ      |L1.20|
00004c  e3a00001          MOV      r0,#1                 ;58
000050  eafffff5          B        |L1.44|
;;;60     static BOOL hwInit(void)
                          ENDP

                  hwInit PROC
000054  e92d4010          PUSH     {r4,lr}
;;;61     {
;;;62         //busy pin  
;;;63         /* Set PH7 to GPIO */
;;;64         outpw(REG_SYS_GPH_MFPL,(inpw(REG_SYS_GPH_MFPL) & ~(0xFu<<28)) | (0x0u<<28));    
000058  e3a0020b          MOV      r0,#0xb0000000
00005c  e59000a8          LDR      r0,[r0,#0xa8]
000060  e3c0020f          BIC      r0,r0,#0xf0000000
000064  e3a0120b          MOV      r1,#0xb0000000
000068  e58100a8          STR      r0,[r1,#0xa8]
;;;65         /* Configure PH7 to input mode */
;;;66         GPIO_OpenBit(LORA_BUSY_PORT, LORA_BUSY_PIN, DIR_INPUT, PULL_UP);
00006c  e3a03001          MOV      r3,#1
000070  e3a02000          MOV      r2,#0
000074  e3a01080          MOV      r1,#0x80
000078  e3a00d07          MOV      r0,#0x1c0
00007c  ebfffffe          BL       GPIO_OpenBit
;;;67         return TRUE;
000080  e3a00001          MOV      r0,#1
;;;68     }
000084  e8bd8010          POP      {r4,pc}
;;;69     static BOOL swInit(void)
                          ENDP

                  swInit PROC
000088  e3a00001          MOV      r0,#1
;;;70     {   
;;;71         return TRUE;
;;;72     }
00008c  e12fff1e          BX       lr
;;;73     
                          ENDP

                  LoraDrvInit PROC
;;;76     /*-----------------------------------------*/
;;;77     BOOL LoraDrvInit(void)
000090  e92d4010          PUSH     {r4,lr}
;;;78     {
;;;79         sysprintf("LoraDrvInit!!\n");
000094  e28f0f52          ADR      r0,|L1.484|
000098  ebfffffe          BL       sysprintf
;;;80         pUartInterface = UartGetInterface(LORA_UART);
00009c  e3a00005          MOV      r0,#5
0000a0  ebfffffe          BL       UartGetInterface
0000a4  e59f1148          LDR      r1,|L1.500|
0000a8  e5810000          STR      r0,[r1,#0]  ; pUartInterface
;;;81         if(pUartInterface == NULL)
0000ac  e2810000          ADD      r0,r1,#0
0000b0  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
0000b4  e3500000          CMP      r0,#0
0000b8  1a000003          BNE      |L1.204|
;;;82         {
;;;83             sysprintf("LoraDrvInit ERROR (pUartInterface == NULL)!!\n");
0000bc  e28f0f4d          ADR      r0,|L1.504|
0000c0  ebfffffe          BL       sysprintf
;;;84             return FALSE;
0000c4  e3a00000          MOV      r0,#0
                  |L1.200|
;;;85         }
;;;86         //if(pUartInterface->initFunc(9600) == FALSE)
;;;87         if(pUartInterface->initFunc(115200) == FALSE)
;;;88         {
;;;89             sysprintf("LoraDrvInit ERROR (initFunc false)!!\n");
;;;90             return FALSE;
;;;91         }
;;;92         if(hwInit() == FALSE)
;;;93         {
;;;94             sysprintf("LoraDrvInit ERROR (hwInit false)!!\n");
;;;95             return FALSE;
;;;96         }
;;;97         if(swInit() == FALSE)
;;;98         {
;;;99             sysprintf("LoraDrvInit ERROR (swInit false)!!\n");
;;;100            return FALSE;
;;;101        }
;;;102        return TRUE;
;;;103    }
0000c8  e8bd8010          POP      {r4,pc}
                  |L1.204|
0000cc  e59f0120          LDR      r0,|L1.500|
0000d0  e5900000          LDR      r0,[r0,#0]            ;87  ; pUartInterface
0000d4  e5901000          LDR      r1,[r0,#0]            ;87
0000d8  e59f0148          LDR      r0,|L1.552|
0000dc  e12fff31          BLX      r1                    ;87
0000e0  e3500000          CMP      r0,#0                 ;87
0000e4  1a000003          BNE      |L1.248|
0000e8  e28f0f4f          ADR      r0,|L1.556|
0000ec  ebfffffe          BL       sysprintf
0000f0  e3a00000          MOV      r0,#0                 ;90
0000f4  eafffff3          B        |L1.200|
                  |L1.248|
0000f8  ebfffffe          BL       hwInit
0000fc  e3500000          CMP      r0,#0                 ;92
000100  1a000003          BNE      |L1.276|
000104  e28f0f52          ADR      r0,|L1.596|
000108  ebfffffe          BL       sysprintf
00010c  e3a00000          MOV      r0,#0                 ;95
000110  eaffffec          B        |L1.200|
                  |L1.276|
000114  ebfffffe          BL       swInit
000118  e3500000          CMP      r0,#0                 ;97
00011c  1a000003          BNE      |L1.304|
000120  e28f0e15          ADR      r0,|L1.632|
000124  ebfffffe          BL       sysprintf
000128  e3a00000          MOV      r0,#0                 ;100
00012c  eaffffe5          B        |L1.200|
                  |L1.304|
000130  e3a00001          MOV      r0,#1                 ;102
000134  eaffffe3          B        |L1.200|
;;;104    
                          ENDP

                  LoraRead PROC
;;;105    
;;;106    INT32 LoraRead(PUINT8 pucBuf, UINT32 uLen)
000138  e92d4070          PUSH     {r4-r6,lr}
;;;107    {
00013c  e1a04000          MOV      r4,r0
000140  e1a05001          MOV      r5,r1
;;;108        return pUartInterface->readFunc(pucBuf, uLen);
000144  e59f00a8          LDR      r0,|L1.500|
000148  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
00014c  e1a01005          MOV      r1,r5
000150  e5902008          LDR      r2,[r0,#8]
000154  e1a00004          MOV      r0,r4
000158  e12fff32          BLX      r2
;;;109    }
00015c  e8bd8070          POP      {r4-r6,pc}
;;;110    
                          ENDP

                  LoraWrite PROC
;;;111    INT32 LoraWrite(PUINT8 pucBuf, UINT32 uLen)
000160  e92d4070          PUSH     {r4-r6,lr}
;;;112    {
000164  e1a04000          MOV      r4,r0
000168  e1a05001          MOV      r5,r1
;;;113        if(LoraWaitForReady())
00016c  ebfffffe          BL       LoraWaitForReady
000170  e3500000          CMP      r0,#0
000174  0a000006          BEQ      |L1.404|
;;;114        {
;;;115            return pUartInterface->writeFunc(pucBuf, uLen);
000178  e59f0074          LDR      r0,|L1.500|
00017c  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
000180  e1a01005          MOV      r1,r5
000184  e5902004          LDR      r2,[r0,#4]
000188  e1a00004          MOV      r0,r4
00018c  e12fff32          BLX      r2
                  |L1.400|
;;;116        }
;;;117        return 0;
;;;118    }
000190  e8bd8070          POP      {r4-r6,pc}
                  |L1.404|
000194  e3a00000          MOV      r0,#0                 ;117
000198  eafffffc          B        |L1.400|
;;;119    BaseType_t LoraReadWait(TickType_t time)
                          ENDP

                  LoraReadWait PROC
00019c  e92d4010          PUSH     {r4,lr}
;;;120    {
0001a0  e1a04000          MOV      r4,r0
;;;121        return pUartInterface->readWaitFunc(time);
0001a4  e59f0048          LDR      r0,|L1.500|
0001a8  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
0001ac  e590100c          LDR      r1,[r0,#0xc]
0001b0  e1a00004          MOV      r0,r4
0001b4  e12fff31          BLX      r1
;;;122    }
0001b8  e8bd8010          POP      {r4,pc}
;;;123    
                          ENDP

                  |L1.444|
0001bc  0d0a2023          DCB      "\r\n ##  LoraWaitForReady timeout  ##\n",0
0001c0  2320204c
0001c4  6f726157
0001c8  61697446
0001cc  6f725265
0001d0  61647920
0001d4  74696d65
0001d8  6f757420
0001dc  2023230a
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L1.484|
0001e4  4c6f7261          DCB      "LoraDrvInit!!\n",0
0001e8  44727649
0001ec  6e697421
0001f0  210a00  
0001f3  00                DCB      0
                  |L1.500|
                          DCD      pUartInterface
                  |L1.504|
0001f8  4c6f7261          DCB      "LoraDrvInit ERROR (pUartInterface == NULL)!!\n",0
0001fc  44727649
000200  6e697420
000204  4552524f
000208  52202870
00020c  55617274
000210  496e7465
000214  72666163
000218  65203d3d
00021c  204e554c
000220  4c292121
000224  0a00    
000226  00                DCB      0
000227  00                DCB      0
                  |L1.552|
                          DCD      0x0001c200
                  |L1.556|
00022c  4c6f7261          DCB      "LoraDrvInit ERROR (initFunc false)!!\n",0
000230  44727649
000234  6e697420
000238  4552524f
00023c  52202869
000240  6e697446
000244  756e6320
000248  66616c73
00024c  65292121
000250  0a00    
000252  00                DCB      0
000253  00                DCB      0
                  |L1.596|
000254  4c6f7261          DCB      "LoraDrvInit ERROR (hwInit false)!!\n",0
000258  44727649
00025c  6e697420
000260  4552524f
000264  52202868
000268  77496e69
00026c  74206661
000270  6c736529
000274  21210a00
                  |L1.632|
000278  4c6f7261          DCB      "LoraDrvInit ERROR (swInit false)!!\n",0
00027c  44727649
000280  6e697420
000284  4552524f
000288  52202873
00028c  77496e69
000290  74206661
000294  6c736529
000298  21210a00

                          AREA ||.data||, DATA, ALIGN=2

                  pUartInterface
                          DCD      0x00000000
