; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\yaffs_mtdif.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\yaffs_mtdif.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\yaffs_mtdif.crf ..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_mtdif.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  nandmtd_WriteChunkToNAND PROC
;;;60     
;;;61     int nandmtd_WriteChunkToNAND(struct yaffs_dev *dev, int chunkInNAND,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;62     			     const u8 *data, const struct yaffs_spare *spare)
;;;63     {
000004  e24dd03c          SUB      sp,sp,#0x3c
000008  e1a04000          MOV      r4,r0
00000c  e1a0a001          MOV      r10,r1
000010  e1a05002          MOV      r5,r2
000014  e1a06003          MOV      r6,r3
;;;64     	struct mtd_info *mtd = (struct mtd_info *)(dev->driver_context);
000018  e5949098          LDR      r9,[r4,#0x98]
;;;65     	struct mtd_oob_ops ops;
;;;66     	size_t dummy;
;;;67     	int retval = 0;
00001c  e3a0b000          MOV      r11,#0
;;;68     	loff_t addr = ((loff_t) chunkInNAND) * dev->data_bytes_per_chunk;
000020  e59400a4          LDR      r0,[r4,#0xa4]
000024  e0c1709a          SMULL    r7,r1,r10,r0
000028  e1a08001          MOV      r8,r1
;;;69     	u8 spareAsBytes[8]; /* OOB */
;;;70     
;;;71     	if (data && !spare)
00002c  e3550000          CMP      r5,#0
000030  0a00000b          BEQ      |L1.100|
000034  e3560000          CMP      r6,#0
000038  1a000009          BNE      |L1.100|
;;;72     		retval = mtd->write(mtd, addr, dev->data_bytes_per_chunk,
00003c  e28d1018          ADD      r1,sp,#0x18
000040  e59400a4          LDR      r0,[r4,#0xa4]
000044  e88d0023          STM      sp,{r0,r1,r5}
000048  e1a02007          MOV      r2,r7
00004c  e1a03008          MOV      r3,r8
000050  e5991044          LDR      r1,[r9,#0x44]
000054  e1a00009          MOV      r0,r9
000058  e12fff31          BLX      r1
00005c  e1a0b000          MOV      r11,r0
000060  ea000023          B        |L1.244|
                  |L1.100|
;;;73     				&dummy, data);
;;;74     	else if (spare) {
000064  e3560000          CMP      r6,#0
000068  0a000021          BEQ      |L1.244|
;;;75     		if (dev->param.use_nand_ecc) {
00006c  e5940024          LDR      r0,[r4,#0x24]
000070  e3500000          CMP      r0,#0
000074  0a000007          BEQ      |L1.152|
;;;76     			translate_spare2oob(spare, spareAsBytes);
000078  e28d1010          ADD      r1,sp,#0x10
00007c  e1a00006          MOV      r0,r6
000080  ebfffffe          BL       translate_spare2oob
;;;77     			ops.mode = MTD_OOB_AUTO;
000084  e3a00001          MOV      r0,#1
000088  e5cd001c          STRB     r0,[sp,#0x1c]
;;;78     			ops.ooblen = 8; /* temp hack */
00008c  e3a00008          MOV      r0,#8
000090  e58d0028          STR      r0,[sp,#0x28]
000094  ea000003          B        |L1.168|
                  |L1.152|
;;;79     		} else {
;;;80     			ops.mode = MTD_OOB_RAW;
000098  e3a00002          MOV      r0,#2
00009c  e5cd001c          STRB     r0,[sp,#0x1c]
;;;81     			ops.ooblen = YAFFS_BYTES_PER_SPARE;
0000a0  e3a00010          MOV      r0,#0x10
0000a4  e58d0028          STR      r0,[sp,#0x28]
                  |L1.168|
;;;82     		}
;;;83     		ops.len = data ? dev->data_bytes_per_chunk : ops.ooblen;
0000a8  e3550000          CMP      r5,#0
0000ac  0a000001          BEQ      |L1.184|
0000b0  e59400a4          LDR      r0,[r4,#0xa4]
0000b4  ea000000          B        |L1.188|
                  |L1.184|
0000b8  e59d0028          LDR      r0,[sp,#0x28]
                  |L1.188|
0000bc  e58d0020          STR      r0,[sp,#0x20]
;;;84     		ops.datbuf = (u8 *)data;
0000c0  e58d5034          STR      r5,[sp,#0x34]
;;;85     		ops.ooboffs = 0;
0000c4  e3a00000          MOV      r0,#0
0000c8  e58d0030          STR      r0,[sp,#0x30]
;;;86     		ops.oobbuf = spareAsBytes;
0000cc  e28d0010          ADD      r0,sp,#0x10
0000d0  e58d0038          STR      r0,[sp,#0x38]
;;;87     		retval = mtd->write_oob(mtd, addr, &ops);
0000d4  e28d001c          ADD      r0,sp,#0x1c
0000d8  e58d0000          STR      r0,[sp,#0]
0000dc  e1a02007          MOV      r2,r7
0000e0  e1a03008          MOV      r3,r8
0000e4  e5991050          LDR      r1,[r9,#0x50]
0000e8  e1a00009          MOV      r0,r9
0000ec  e12fff31          BLX      r1
0000f0  e1a0b000          MOV      r11,r0
                  |L1.244|
;;;88     	}
;;;89     
;;;90     	if (retval == 0)
0000f4  e35b0000          CMP      r11,#0
0000f8  1a000002          BNE      |L1.264|
;;;91     		return YAFFS_OK;
0000fc  e3a00001          MOV      r0,#1
                  |L1.256|
000100  e28dd03c          ADD      sp,sp,#0x3c
;;;92     	else
;;;93     		return YAFFS_FAIL;
;;;94     }
000104  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.264|
000108  e3a00000          MOV      r0,#0                 ;93
00010c  eafffffb          B        |L1.256|
;;;95     
                          ENDP

                  nandmtd_ReadChunkFromNAND PROC
;;;96     int nandmtd_ReadChunkFromNAND(struct yaffs_dev *dev, int chunkInNAND, u8 *data,
000110  e92d4ff0          PUSH     {r4-r11,lr}
;;;97     			      struct yaffs_spare *spare)
;;;98     {
000114  e24dd03c          SUB      sp,sp,#0x3c
000118  e1a04000          MOV      r4,r0
00011c  e1a0a001          MOV      r10,r1
000120  e1a05002          MOV      r5,r2
000124  e1a06003          MOV      r6,r3
;;;99     	struct mtd_info *mtd = (struct mtd_info *)(dev->driver_context);
000128  e5949098          LDR      r9,[r4,#0x98]
;;;100    	struct mtd_oob_ops ops;
;;;101    	size_t dummy;
;;;102    	int retval = 0;
00012c  e3a0b000          MOV      r11,#0
;;;103    
;;;104    	loff_t addr = ((loff_t) chunkInNAND) * dev->data_bytes_per_chunk;
000130  e59400a4          LDR      r0,[r4,#0xa4]
000134  e0c1709a          SMULL    r7,r1,r10,r0
000138  e1a08001          MOV      r8,r1
;;;105    	u8 spareAsBytes[8]; /* OOB */
;;;106    
;;;107    	if (data && !spare)
00013c  e3550000          CMP      r5,#0
000140  0a00000b          BEQ      |L1.372|
000144  e3560000          CMP      r6,#0
000148  1a000009          BNE      |L1.372|
;;;108    		retval = mtd->read(mtd, addr, dev->data_bytes_per_chunk,
00014c  e28d1018          ADD      r1,sp,#0x18
000150  e59400a4          LDR      r0,[r4,#0xa4]
000154  e88d0023          STM      sp,{r0,r1,r5}
000158  e1a02007          MOV      r2,r7
00015c  e1a03008          MOV      r3,r8
000160  e5991040          LDR      r1,[r9,#0x40]
000164  e1a00009          MOV      r0,r9
000168  e12fff31          BLX      r1
00016c  e1a0b000          MOV      r11,r0
000170  ea000026          B        |L1.528|
                  |L1.372|
;;;109    				&dummy, data);
;;;110    	else if (spare) {
000174  e3560000          CMP      r6,#0
000178  0a000024          BEQ      |L1.528|
;;;111    		if (dev->param.use_nand_ecc) {
00017c  e5940024          LDR      r0,[r4,#0x24]
000180  e3500000          CMP      r0,#0
000184  0a000004          BEQ      |L1.412|
;;;112    			ops.mode = MTD_OOB_AUTO;
000188  e3a00001          MOV      r0,#1
00018c  e5cd001c          STRB     r0,[sp,#0x1c]
;;;113    			ops.ooblen = 8; /* temp hack */
000190  e3a00008          MOV      r0,#8
000194  e58d0028          STR      r0,[sp,#0x28]
000198  ea000003          B        |L1.428|
                  |L1.412|
;;;114    		} else {
;;;115    			ops.mode = MTD_OOB_RAW;
00019c  e3a00002          MOV      r0,#2
0001a0  e5cd001c          STRB     r0,[sp,#0x1c]
;;;116    			ops.ooblen = YAFFS_BYTES_PER_SPARE;
0001a4  e3a00010          MOV      r0,#0x10
0001a8  e58d0028          STR      r0,[sp,#0x28]
                  |L1.428|
;;;117    		}
;;;118    		ops.len = data ? dev->data_bytes_per_chunk : ops.ooblen;
0001ac  e3550000          CMP      r5,#0
0001b0  0a000001          BEQ      |L1.444|
0001b4  e59400a4          LDR      r0,[r4,#0xa4]
0001b8  ea000000          B        |L1.448|
                  |L1.444|
0001bc  e59d0028          LDR      r0,[sp,#0x28]
                  |L1.448|
0001c0  e58d0020          STR      r0,[sp,#0x20]
;;;119    		ops.datbuf = data;
0001c4  e58d5034          STR      r5,[sp,#0x34]
;;;120    		ops.ooboffs = 0;
0001c8  e3a00000          MOV      r0,#0
0001cc  e58d0030          STR      r0,[sp,#0x30]
;;;121    		ops.oobbuf = spareAsBytes;
0001d0  e28d0010          ADD      r0,sp,#0x10
0001d4  e58d0038          STR      r0,[sp,#0x38]
;;;122    		retval = mtd->read_oob(mtd, addr, &ops);
0001d8  e28d001c          ADD      r0,sp,#0x1c
0001dc  e58d0000          STR      r0,[sp,#0]
0001e0  e1a02007          MOV      r2,r7
0001e4  e1a03008          MOV      r3,r8
0001e8  e599104c          LDR      r1,[r9,#0x4c]
0001ec  e1a00009          MOV      r0,r9
0001f0  e12fff31          BLX      r1
0001f4  e1a0b000          MOV      r11,r0
;;;123    		if (dev->param.use_nand_ecc)
0001f8  e5940024          LDR      r0,[r4,#0x24]
0001fc  e3500000          CMP      r0,#0
000200  0a000002          BEQ      |L1.528|
;;;124    			translate_oob2spare(spare, spareAsBytes);
000204  e28d1010          ADD      r1,sp,#0x10
000208  e1a00006          MOV      r0,r6
00020c  ebfffffe          BL       translate_oob2spare
                  |L1.528|
;;;125    	}
;;;126    
;;;127    	if (retval == 0)
000210  e35b0000          CMP      r11,#0
000214  1a000002          BNE      |L1.548|
;;;128    		return YAFFS_OK;
000218  e3a00001          MOV      r0,#1
                  |L1.540|
00021c  e28dd03c          ADD      sp,sp,#0x3c
;;;129    	else
;;;130    		return YAFFS_FAIL;
;;;131    }
000220  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.548|
000224  e3a00000          MOV      r0,#0                 ;130
000228  eafffffb          B        |L1.540|
;;;132    
                          ENDP

                  nandmtd_EraseBlockInNAND PROC
;;;133    int nandmtd_EraseBlockInNAND(struct yaffs_dev *dev, int blockNumber)
00022c  e92d41f0          PUSH     {r4-r8,lr}
;;;134    {
000230  e24dd048          SUB      sp,sp,#0x48
000234  e1a04000          MOV      r4,r0
000238  e1a07001          MOV      r7,r1
;;;135    	struct mtd_info *mtd = (struct mtd_info *)(dev->driver_context);
00023c  e5945098          LDR      r5,[r4,#0x98]
;;;136    	__u32 addr =
000240  e59400a4          LDR      r0,[r4,#0xa4]
000244  e0c01097          SMULL    r1,r0,r7,r0
000248  e594000c          LDR      r0,[r4,#0xc]
00024c  e0826091          UMULL    r6,r2,r1,r0
;;;137    	    ((loff_t) blockNumber) * dev->data_bytes_per_chunk
;;;138    		* dev->param.chunks_per_block;
;;;139    	struct erase_info ei;
;;;140    	int retval = 0;
000250  e3a08000          MOV      r8,#0
;;;141    
;;;142    	ei.mtd = mtd;
000254  e58d5000          STR      r5,[sp,#0]
;;;143    	ei.addr = addr;
000258  e3a00000          MOV      r0,#0
00025c  e58d000c          STR      r0,[sp,#0xc]
000260  e58d6008          STR      r6,[sp,#8]
;;;144    	ei.len = dev->data_bytes_per_chunk * dev->param.chunks_per_block;
000264  e59400a4          LDR      r0,[r4,#0xa4]
000268  e594100c          LDR      r1,[r4,#0xc]
00026c  e0000091          MUL      r0,r1,r0
000270  e1a01fc0          ASR      r1,r0,#31
000274  e1cd01f0          STRD     r0,r1,[sp,#0x10]
;;;145    	ei.time = 1000;
000278  e3a00ffa          MOV      r0,#0x3e8
00027c  e58d0020          STR      r0,[sp,#0x20]
;;;146    	ei.retries = 2;
000280  e3a00002          MOV      r0,#2
000284  e58d0024          STR      r0,[sp,#0x24]
;;;147    	ei.callback = NULL;
000288  e3a00000          MOV      r0,#0
00028c  e58d0030          STR      r0,[sp,#0x30]
;;;148    	ei.priv = (u_long) dev;
000290  e58d4034          STR      r4,[sp,#0x34]
;;;149    
;;;150    	/* Todo finish off the ei if required */
;;;151    
;;;152    
;;;153    	retval = mtd->erase(mtd, &ei);
000294  e1a0100d          MOV      r1,sp
000298  e5952034          LDR      r2,[r5,#0x34]
00029c  e1a00005          MOV      r0,r5
0002a0  e12fff32          BLX      r2
0002a4  e1a08000          MOV      r8,r0
;;;154    
;;;155    	if (retval == 0)
0002a8  e3580000          CMP      r8,#0
0002ac  1a000002          BNE      |L1.700|
;;;156    		return YAFFS_OK;
0002b0  e3a00001          MOV      r0,#1
                  |L1.692|
0002b4  e28dd048          ADD      sp,sp,#0x48
;;;157    	else
;;;158    		return YAFFS_FAIL;
;;;159    }
0002b8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.700|
0002bc  e3a00000          MOV      r0,#0                 ;158
0002c0  eafffffb          B        |L1.692|
;;;160    
                          ENDP

                  nandmtd_InitialiseNAND PROC
;;;161    int nandmtd_InitialiseNAND(struct yaffs_dev *dev)
0002c4  e1a01000          MOV      r1,r0
;;;162    {
;;;163    	return YAFFS_OK;
0002c8  e3a00001          MOV      r0,#1
;;;164    }
0002cc  e12fff1e          BX       lr
                          ENDP

                  translate_spare2oob PROC
;;;26     
;;;27     static __inline void translate_spare2oob(const struct yaffs_spare *spare, u8 *oob)
0002d0  e5d02000          LDRB     r2,[r0,#0]
;;;28     {
;;;29     	oob[0] = spare->tb0;
0002d4  e5c12000          STRB     r2,[r1,#0]
;;;30     	oob[1] = spare->tb1;
0002d8  e5d02001          LDRB     r2,[r0,#1]
0002dc  e5c12001          STRB     r2,[r1,#1]
;;;31     	oob[2] = spare->tb2;
0002e0  e5d02002          LDRB     r2,[r0,#2]
0002e4  e5c12002          STRB     r2,[r1,#2]
;;;32     	oob[3] = spare->tb3;
0002e8  e5d02003          LDRB     r2,[r0,#3]
0002ec  e5c12003          STRB     r2,[r1,#3]
;;;33     	oob[4] = spare->tb4;
0002f0  e5d02006          LDRB     r2,[r0,#6]
0002f4  e5c12004          STRB     r2,[r1,#4]
;;;34     	oob[5] = spare->tb5 & 0x3f;
0002f8  e5d02007          LDRB     r2,[r0,#7]
0002fc  e202203f          AND      r2,r2,#0x3f
000300  e5c12005          STRB     r2,[r1,#5]
;;;35     	oob[5] |= spare->block_status == 'Y' ? 0 : 0x80;
000304  e5d12005          LDRB     r2,[r1,#5]
000308  e5d03005          LDRB     r3,[r0,#5]
00030c  e3530059          CMP      r3,#0x59
000310  1a000001          BNE      |L1.796|
000314  e3a03000          MOV      r3,#0
000318  ea000000          B        |L1.800|
                  |L1.796|
00031c  e3a03080          MOV      r3,#0x80
                  |L1.800|
000320  e1822003          ORR      r2,r2,r3
000324  e5c12005          STRB     r2,[r1,#5]
;;;36     	oob[5] |= spare->page_status == 0 ? 0 : 0x40;
000328  e5d12005          LDRB     r2,[r1,#5]
00032c  e5d03004          LDRB     r3,[r0,#4]
000330  e3530000          CMP      r3,#0
000334  1a000001          BNE      |L1.832|
000338  e3a03000          MOV      r3,#0
00033c  ea000000          B        |L1.836|
                  |L1.832|
000340  e3a03040          MOV      r3,#0x40
                  |L1.836|
000344  e1822003          ORR      r2,r2,r3
000348  e5c12005          STRB     r2,[r1,#5]
;;;37     	oob[6] = spare->tb6;
00034c  e5d0200b          LDRB     r2,[r0,#0xb]
000350  e5c12006          STRB     r2,[r1,#6]
;;;38     	oob[7] = spare->tb7;
000354  e5d0200c          LDRB     r2,[r0,#0xc]
000358  e5c12007          STRB     r2,[r1,#7]
;;;39     }
00035c  e12fff1e          BX       lr
;;;40     
                          ENDP

                  translate_oob2spare PROC
;;;41     static __inline void translate_oob2spare(struct yaffs_spare *spare, u8 *oob)
000360  e1a02000          MOV      r2,r0
;;;42     {
;;;43     	struct yaffs_nand_spare *nspare = (struct yaffs_nand_spare *)spare;
;;;44     	spare->tb0 = oob[0];
000364  e5d13000          LDRB     r3,[r1,#0]
000368  e5c03000          STRB     r3,[r0,#0]
;;;45     	spare->tb1 = oob[1];
00036c  e5d13001          LDRB     r3,[r1,#1]
000370  e5c03001          STRB     r3,[r0,#1]
;;;46     	spare->tb2 = oob[2];
000374  e5d13002          LDRB     r3,[r1,#2]
000378  e5c03002          STRB     r3,[r0,#2]
;;;47     	spare->tb3 = oob[3];
00037c  e5d13003          LDRB     r3,[r1,#3]
000380  e5c03003          STRB     r3,[r0,#3]
;;;48     	spare->tb4 = oob[4];
000384  e5d13004          LDRB     r3,[r1,#4]
000388  e5c03006          STRB     r3,[r0,#6]
;;;49     	spare->tb5 = oob[5] == 0xff ? 0xff : oob[5] & 0x3f;
00038c  e5d13005          LDRB     r3,[r1,#5]
000390  e35300ff          CMP      r3,#0xff
000394  1a000001          BNE      |L1.928|
000398  e3a030ff          MOV      r3,#0xff
00039c  ea000001          B        |L1.936|
                  |L1.928|
0003a0  e5d13005          LDRB     r3,[r1,#5]
0003a4  e203303f          AND      r3,r3,#0x3f
                  |L1.936|
0003a8  e5c03007          STRB     r3,[r0,#7]
;;;50     	spare->block_status = oob[5] & 0x80 ? 0xff : 'Y';
0003ac  e5d13005          LDRB     r3,[r1,#5]
0003b0  e3130080          TST      r3,#0x80
0003b4  0a000001          BEQ      |L1.960|
0003b8  e3a030ff          MOV      r3,#0xff
0003bc  ea000000          B        |L1.964|
                  |L1.960|
0003c0  e3a03059          MOV      r3,#0x59
                  |L1.964|
0003c4  e5c03005          STRB     r3,[r0,#5]
;;;51     	spare->page_status = oob[5] & 0x40 ? 0xff : 0;
0003c8  e5d13005          LDRB     r3,[r1,#5]
0003cc  e3130040          TST      r3,#0x40
0003d0  0a000001          BEQ      |L1.988|
0003d4  e3a030ff          MOV      r3,#0xff
0003d8  ea000000          B        |L1.992|
                  |L1.988|
0003dc  e3a03000          MOV      r3,#0
                  |L1.992|
0003e0  e5c03004          STRB     r3,[r0,#4]
;;;52     	spare->ecc1[0] = spare->ecc1[1] = spare->ecc1[2] = 0xff;
0003e4  e3a030ff          MOV      r3,#0xff
0003e8  e5c0300a          STRB     r3,[r0,#0xa]
0003ec  e5c03009          STRB     r3,[r0,#9]
0003f0  e5c03008          STRB     r3,[r0,#8]
;;;53     	spare->tb6 = oob[6];
0003f4  e5d13006          LDRB     r3,[r1,#6]
0003f8  e5c0300b          STRB     r3,[r0,#0xb]
;;;54     	spare->tb7 = oob[7];
0003fc  e5d13007          LDRB     r3,[r1,#7]
000400  e5c0300c          STRB     r3,[r0,#0xc]
;;;55     	spare->ecc2[0] = spare->ecc2[1] = spare->ecc2[2] = 0xff;
000404  e3a030ff          MOV      r3,#0xff
000408  e5c0300f          STRB     r3,[r0,#0xf]
00040c  e5c0300e          STRB     r3,[r0,#0xe]
000410  e5c0300d          STRB     r3,[r0,#0xd]
;;;56     
;;;57     	nspare->eccres1 = nspare->eccres2 = 0; /* FIXME */
000414  e3a03000          MOV      r3,#0
000418  e5823014          STR      r3,[r2,#0x14]
00041c  e5823010          STR      r3,[r2,#0x10]
;;;58     }
000420  e12fff1e          BX       lr
;;;59     
                          ENDP

