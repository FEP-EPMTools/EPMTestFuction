; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\nand_bbt.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nand_bbt.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\nand_bbt.crf ..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  check_pattern_no_oob PROC
;;;76     
;;;77     static int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;78     {
000004  e1a06000          MOV      r6,r0
000008  e1a04001          MOV      r4,r1
;;;79     	int ret;
;;;80     
;;;81     	ret = memcmp(buf, td->pattern, td->len);
00000c  e1a00006          MOV      r0,r6
000010  e5941020          LDR      r1,[r4,#0x20]
000014  e5942014          LDR      r2,[r4,#0x14]
000018  ebfffffe          BL       memcmp
00001c  e1a05000          MOV      r5,r0
;;;82     	if (!ret)
000020  e3550000          CMP      r5,#0
000024  1a000001          BNE      |L1.48|
;;;83     		return ret;
000028  e1a00005          MOV      r0,r5
                  |L1.44|
;;;84     	return -1;
;;;85     }
00002c  e8bd8070          POP      {r4-r6,pc}
                  |L1.48|
000030  e3e00000          MVN      r0,#0                 ;84
000034  eafffffc          B        |L1.44|
;;;86     
                          ENDP

                  check_pattern PROC
;;;99     */
;;;100    static int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
000038  e92d47f0          PUSH     {r4-r10,lr}
;;;101    {
00003c  e1a08000          MOV      r8,r0
000040  e1a09001          MOV      r9,r1
000044  e1a0a002          MOV      r10,r2
000048  e1a04003          MOV      r4,r3
;;;102    	int i, end = 0;
00004c  e3a07000          MOV      r7,#0
;;;103    	uint8_t *p = buf;
000050  e1a06008          MOV      r6,r8
;;;104    
;;;105    	if (td->options & NAND_BBT_NO_OOB)
000054  e5940000          LDR      r0,[r4,#0]
000058  e3100501          TST      r0,#0x400000
00005c  0a000003          BEQ      |L1.112|
;;;106    		return check_pattern_no_oob(buf, td);
000060  e1a01004          MOV      r1,r4
000064  e1a00008          MOV      r0,r8
000068  ebfffffe          BL       check_pattern_no_oob
                  |L1.108|
;;;107    
;;;108    	end = paglen + td->offs;
;;;109    	if (td->options & NAND_BBT_SCANEMPTY) {
;;;110    		for (i = 0; i < end; i++) {
;;;111    			if (p[i] != 0xff)
;;;112    				return -1;
;;;113    		}
;;;114    	}
;;;115    	p += end;
;;;116    
;;;117    	/* Compare the pattern */
;;;118    	for (i = 0; i < td->len; i++) {
;;;119    		if (p[i] != td->pattern[i])
;;;120    			return -1;
;;;121    	}
;;;122    
;;;123    	/* Check both positions 1 and 6 for pattern? */
;;;124    	if (td->options & NAND_BBT_SCANBYTE1AND6) {
;;;125    		if (td->options & NAND_BBT_SCANEMPTY) {
;;;126    			p += td->len;
;;;127    			end += NAND_SMALL_BADBLOCK_POS - td->offs;
;;;128    			/* Check region between positions 1 and 6 */
;;;129    			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
;;;130    					i++) {
;;;131    				if (*p++ != 0xff)
;;;132    					return -1;
;;;133    			}
;;;134    		}
;;;135    		else {
;;;136    			p += NAND_SMALL_BADBLOCK_POS - td->offs;
;;;137    		}
;;;138    		/* Compare the pattern */
;;;139    		for (i = 0; i < td->len; i++) {
;;;140    			if (p[i] != td->pattern[i])
;;;141    				return -1;
;;;142    		}
;;;143    	}
;;;144    
;;;145    	if (td->options & NAND_BBT_SCANEMPTY) {
;;;146    		p += td->len;
;;;147    		end += td->len;
;;;148    		for (i = end; i < len; i++) {
;;;149    			if (*p++ != 0xff)
;;;150    				return -1;
;;;151    		}
;;;152    	}
;;;153    	return 0;
;;;154    }
00006c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.112|
000070  e5940008          LDR      r0,[r4,#8]            ;108
000074  e080700a          ADD      r7,r0,r10             ;108
000078  e1d400b0          LDRH     r0,[r4,#0]            ;109
00007c  e3100b02          TST      r0,#0x800             ;109
000080  0a000009          BEQ      |L1.172|
000084  e3a05000          MOV      r5,#0                 ;110
000088  ea000005          B        |L1.164|
                  |L1.140|
00008c  e7d60005          LDRB     r0,[r6,r5]            ;111
000090  e35000ff          CMP      r0,#0xff              ;111
000094  0a000001          BEQ      |L1.160|
000098  e3e00000          MVN      r0,#0                 ;112
00009c  eafffff2          B        |L1.108|
                  |L1.160|
0000a0  e2855001          ADD      r5,r5,#1              ;110
                  |L1.164|
0000a4  e1550007          CMP      r5,r7                 ;110
0000a8  bafffff7          BLT      |L1.140|
                  |L1.172|
0000ac  e0866007          ADD      r6,r6,r7              ;115
0000b0  e3a05000          MOV      r5,#0                 ;118
0000b4  ea000007          B        |L1.216|
                  |L1.184|
0000b8  e7d60005          LDRB     r0,[r6,r5]            ;119
0000bc  e5941020          LDR      r1,[r4,#0x20]         ;119
0000c0  e7d11005          LDRB     r1,[r1,r5]            ;119
0000c4  e1500001          CMP      r0,r1                 ;119
0000c8  0a000001          BEQ      |L1.212|
0000cc  e3e00000          MVN      r0,#0                 ;120
0000d0  eaffffe5          B        |L1.108|
                  |L1.212|
0000d4  e2855001          ADD      r5,r5,#1              ;118
                  |L1.216|
0000d8  e5940014          LDR      r0,[r4,#0x14]         ;118
0000dc  e1500005          CMP      r0,r5                 ;118
0000e0  cafffff4          BGT      |L1.184|
0000e4  e5940000          LDR      r0,[r4,#0]            ;124
0000e8  e3100601          TST      r0,#0x100000          ;124
0000ec  0a000026          BEQ      |L1.396|
0000f0  e1d400b0          LDRH     r0,[r4,#0]            ;125
0000f4  e3100b02          TST      r0,#0x800             ;125
0000f8  0a000013          BEQ      |L1.332|
0000fc  e5940014          LDR      r0,[r4,#0x14]         ;126
000100  e0866000          ADD      r6,r6,r0              ;126
000104  e5940008          LDR      r0,[r4,#8]            ;127
000108  e2600005          RSB      r0,r0,#5              ;127
00010c  e0877000          ADD      r7,r7,r0              ;127
000110  e3a05000          MOV      r5,#0                 ;129
000114  ea000005          B        |L1.304|
                  |L1.280|
000118  e4d60001          LDRB     r0,[r6],#1            ;131
00011c  e35000ff          CMP      r0,#0xff              ;131
000120  0a000001          BEQ      |L1.300|
000124  e3e00000          MVN      r0,#0                 ;132
000128  eaffffcf          B        |L1.108|
                  |L1.300|
00012c  e2855001          ADD      r5,r5,#1              ;130
                  |L1.304|
000130  e5940008          LDR      r0,[r4,#8]            ;129
000134  e2600005          RSB      r0,r0,#5              ;129
000138  e5941014          LDR      r1,[r4,#0x14]         ;129
00013c  e0400001          SUB      r0,r0,r1              ;129
000140  e1500005          CMP      r0,r5                 ;129
000144  cafffff3          BGT      |L1.280|
000148  ea000002          B        |L1.344|
                  |L1.332|
00014c  e5940008          LDR      r0,[r4,#8]            ;136
000150  e2600005          RSB      r0,r0,#5              ;136
000154  e0866000          ADD      r6,r6,r0              ;136
                  |L1.344|
000158  e3a05000          MOV      r5,#0                 ;139
00015c  ea000007          B        |L1.384|
                  |L1.352|
000160  e7d60005          LDRB     r0,[r6,r5]            ;140
000164  e5941020          LDR      r1,[r4,#0x20]         ;140
000168  e7d11005          LDRB     r1,[r1,r5]            ;140
00016c  e1500001          CMP      r0,r1                 ;140
000170  0a000001          BEQ      |L1.380|
000174  e3e00000          MVN      r0,#0                 ;141
000178  eaffffbb          B        |L1.108|
                  |L1.380|
00017c  e2855001          ADD      r5,r5,#1              ;139
                  |L1.384|
000180  e5940014          LDR      r0,[r4,#0x14]         ;139
000184  e1500005          CMP      r0,r5                 ;139
000188  cafffff4          BGT      |L1.352|
                  |L1.396|
00018c  e1d400b0          LDRH     r0,[r4,#0]            ;145
000190  e3100b02          TST      r0,#0x800             ;145
000194  0a00000d          BEQ      |L1.464|
000198  e5940014          LDR      r0,[r4,#0x14]         ;146
00019c  e0866000          ADD      r6,r6,r0              ;146
0001a0  e5940014          LDR      r0,[r4,#0x14]         ;147
0001a4  e0877000          ADD      r7,r7,r0              ;147
0001a8  e1a05007          MOV      r5,r7                 ;148
0001ac  ea000005          B        |L1.456|
                  |L1.432|
0001b0  e4d60001          LDRB     r0,[r6],#1            ;149
0001b4  e35000ff          CMP      r0,#0xff              ;149
0001b8  0a000001          BEQ      |L1.452|
0001bc  e3e00000          MVN      r0,#0                 ;150
0001c0  eaffffa9          B        |L1.108|
                  |L1.452|
0001c4  e2855001          ADD      r5,r5,#1              ;148
                  |L1.456|
0001c8  e1550009          CMP      r5,r9                 ;148
0001cc  bafffff7          BLT      |L1.432|
                  |L1.464|
0001d0  e3a00000          MOV      r0,#0                 ;153
0001d4  eaffffa4          B        |L1.108|
;;;155    
                          ENDP

                  check_short_pattern PROC
;;;165    */
;;;166    static int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)
0001d8  e92d4010          PUSH     {r4,lr}
;;;167    {
0001dc  e1a03000          MOV      r3,r0
0001e0  e1a02001          MOV      r2,r1
;;;168    	int i;
;;;169    	uint8_t *p = buf;
0001e4  e1a0c003          MOV      r12,r3
;;;170    
;;;171    	/* Compare the pattern */
;;;172    	for (i = 0; i < td->len; i++) {
0001e8  e3a01000          MOV      r1,#0
0001ec  ea000009          B        |L1.536|
                  |L1.496|
;;;173    		if (p[td->offs + i] != td->pattern[i])
0001f0  e5920008          LDR      r0,[r2,#8]
0001f4  e0800001          ADD      r0,r0,r1
0001f8  e7dc0000          LDRB     r0,[r12,r0]
0001fc  e5924020          LDR      r4,[r2,#0x20]
000200  e7d44001          LDRB     r4,[r4,r1]
000204  e1500004          CMP      r0,r4
000208  0a000001          BEQ      |L1.532|
;;;174    			return -1;
00020c  e3e00000          MVN      r0,#0
                  |L1.528|
;;;175    	}
;;;176    	/* Need to check location 1 AND 6? */
;;;177    	if (td->options & NAND_BBT_SCANBYTE1AND6) {
;;;178    		for (i = 0; i < td->len; i++) {
;;;179    			if (p[NAND_SMALL_BADBLOCK_POS + i] != td->pattern[i])
;;;180    				return -1;
;;;181    		}
;;;182    	}
;;;183    	return 0;
;;;184    }
000210  e8bd8010          POP      {r4,pc}
                  |L1.532|
000214  e2811001          ADD      r1,r1,#1              ;172
                  |L1.536|
000218  e5920014          LDR      r0,[r2,#0x14]         ;172
00021c  e1500001          CMP      r0,r1                 ;172
000220  cafffff2          BGT      |L1.496|
000224  e5920000          LDR      r0,[r2,#0]            ;177
000228  e3100601          TST      r0,#0x100000          ;177
00022c  0a00000d          BEQ      |L1.616|
000230  e3a01000          MOV      r1,#0                 ;178
000234  ea000008          B        |L1.604|
                  |L1.568|
000238  e2810005          ADD      r0,r1,#5              ;179
00023c  e7dc0000          LDRB     r0,[r12,r0]           ;179
000240  e5924020          LDR      r4,[r2,#0x20]         ;179
000244  e7d44001          LDRB     r4,[r4,r1]            ;179
000248  e1500004          CMP      r0,r4                 ;179
00024c  0a000001          BEQ      |L1.600|
000250  e3e00000          MVN      r0,#0                 ;180
000254  eaffffed          B        |L1.528|
                  |L1.600|
000258  e2811001          ADD      r1,r1,#1              ;178
                  |L1.604|
00025c  e5920014          LDR      r0,[r2,#0x14]         ;178
000260  e1500001          CMP      r0,r1                 ;178
000264  cafffff3          BGT      |L1.568|
                  |L1.616|
000268  e3a00000          MOV      r0,#0                 ;183
00026c  eaffffe7          B        |L1.528|
;;;185    
                          ENDP

                  add_marker_len PROC
;;;191     */
;;;192    static u32 add_marker_len(struct nand_bbt_descr *td)
000270  e1a01000          MOV      r1,r0
;;;193    {
;;;194    	u32 len;
;;;195    
;;;196    	if (!(td->options & NAND_BBT_NO_OOB))
000274  e5910000          LDR      r0,[r1,#0]
000278  e3100501          TST      r0,#0x400000
00027c  1a000001          BNE      |L1.648|
;;;197    		return 0;
000280  e3a00000          MOV      r0,#0
                  |L1.644|
;;;198    
;;;199    	len = td->len;
;;;200    	if (td->options & NAND_BBT_VERSION)
;;;201    		len++;
;;;202    	return len;
;;;203    }
000284  e12fff1e          BX       lr
                  |L1.648|
000288  e5912014          LDR      r2,[r1,#0x14]         ;199
00028c  e1d100b0          LDRH     r0,[r1,#0]            ;200
000290  e3100c01          TST      r0,#0x100             ;200
000294  0a000000          BEQ      |L1.668|
000298  e2822001          ADD      r2,r2,#1              ;201
                  |L1.668|
00029c  e1a00002          MOV      r0,r2                 ;202
0002a0  eafffff7          B        |L1.644|
;;;204    
                          ENDP

                  read_bbt PROC
;;;216     */
;;;217    static int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
0002a4  e92d4fff          PUSH     {r0-r11,lr}
;;;218    		struct nand_bbt_descr *td, int offs)
;;;219    {
0002a8  e24dd04c          SUB      sp,sp,#0x4c
0002ac  e1a07000          MOV      r7,r0
0002b0  e1a0a002          MOV      r10,r2
0002b4  e59d8084          LDR      r8,[sp,#0x84]
;;;220    	int res, i, j, act = 0;
0002b8  e3a04000          MOV      r4,#0
;;;221    	struct nand_chip *this = mtd->priv;
0002bc  e5975094          LDR      r5,[r7,#0x94]
;;;222    	size_t retlen, len, totlen;
;;;223    	loff_t from;
;;;224    	int bits = td->options & NAND_BBT_NRBITS_MSK;
0002c0  e59d0080          LDR      r0,[sp,#0x80]
0002c4  e5d00000          LDRB     r0,[r0,#0]
0002c8  e200000f          AND      r0,r0,#0xf
0002cc  e58d001c          STR      r0,[sp,#0x1c]
;;;225    	uint8_t msk = (uint8_t) ((1 << bits) - 1);
0002d0  e3a01001          MOV      r1,#1
0002d4  e59d001c          LDR      r0,[sp,#0x1c]
0002d8  e1a00011          LSL      r0,r1,r0
0002dc  e2400001          SUB      r0,r0,#1
0002e0  e20000ff          AND      r0,r0,#0xff
0002e4  e58d0018          STR      r0,[sp,#0x18]
;;;226    	u32 marker_len;
;;;227    	int reserved_block_code = td->reserved_block_code;
0002e8  e59d0080          LDR      r0,[sp,#0x80]
0002ec  e590001c          LDR      r0,[r0,#0x1c]
0002f0  e58d0014          STR      r0,[sp,#0x14]
;;;228    
;;;229    	totlen = (num * bits) >> 3;
0002f4  e59d0058          LDR      r0,[sp,#0x58]
0002f8  e59d101c          LDR      r1,[sp,#0x1c]
0002fc  e0000091          MUL      r0,r1,r0
000300  e1a001c0          ASR      r0,r0,#3
000304  e58d0028          STR      r0,[sp,#0x28]
;;;230    	marker_len = add_marker_len(td);
000308  e59d0080          LDR      r0,[sp,#0x80]
00030c  ebfffffe          BL       add_marker_len
000310  e1a09000          MOV      r9,r0
;;;231    	from = ((loff_t) page) << this->page_shift;
000314  e1a00fca          ASR      r0,r10,#31
000318  e5952054          LDR      r2,[r5,#0x54]
00031c  e58d003c          STR      r0,[sp,#0x3c]
000320  e58da040          STR      r10,[sp,#0x40]
000324  e1a0000a          MOV      r0,r10
000328  e59d103c          LDR      r1,[sp,#0x3c]
00032c  ebfffffe          BL       __aeabi_llsl
000330  e1cd02f0          STRD     r0,r1,[sp,#0x20]
;;;232    
;;;233    	while (totlen) {
000334  ea000093          B        |L1.1416|
                  |L1.824|
;;;234    		len = min(totlen, (size_t) (1 << this->bbt_erase_shift));
000338  e5d5005c          LDRB     r0,[r5,#0x5c]
00033c  e3a01001          MOV      r1,#1
000340  e1a01011          LSL      r1,r1,r0
000344  e59d0028          LDR      r0,[sp,#0x28]
000348  e1510000          CMP      r1,r0
00034c  2a000003          BCS      |L1.864|
000350  e5d5005c          LDRB     r0,[r5,#0x5c]
000354  e3a01001          MOV      r1,#1
000358  e1a00011          LSL      r0,r1,r0
00035c  ea000000          B        |L1.868|
                  |L1.864|
000360  e59d0028          LDR      r0,[sp,#0x28]
                  |L1.868|
000364  e1a06000          MOV      r6,r0
;;;235    		if (marker_len) {
000368  e3590000          CMP      r9,#0
00036c  0a000005          BEQ      |L1.904|
;;;236    			/*
;;;237    			 * In case the BBT marker is not in the OOB area it
;;;238    			 * will be just in the first page.
;;;239    			 */
;;;240    			len -= marker_len;
000370  e0466009          SUB      r6,r6,r9
;;;241    			from += marker_len;
000374  e1cd02d0          LDRD     r0,r1,[sp,#0x20]
000378  e0900009          ADDS     r0,r0,r9
00037c  e2a11000          ADC      r1,r1,#0
000380  e1cd02f0          STRD     r0,r1,[sp,#0x20]
;;;242    			marker_len = 0;
000384  e3a09000          MOV      r9,#0
                  |L1.904|
;;;243    		}
;;;244    		res = mtd->read(mtd, from, len, &retlen, buf);
000388  e59d0050          LDR      r0,[sp,#0x50]
00038c  e28d102c          ADD      r1,sp,#0x2c
000390  e58d0008          STR      r0,[sp,#8]
000394  e58d1004          STR      r1,[sp,#4]
000398  e58d6000          STR      r6,[sp,#0]
00039c  e5971040          LDR      r1,[r7,#0x40]
0003a0  e1a00007          MOV      r0,r7
0003a4  e1cd22d0          LDRD     r2,r3,[sp,#0x20]
0003a8  e12fff31          BLX      r1
0003ac  e58d0038          STR      r0,[sp,#0x38]
;;;245    		if (res < 0) {
0003b0  e59d0038          LDR      r0,[sp,#0x38]
0003b4  e3500000          CMP      r0,#0
0003b8  aa000009          BGE      |L1.996|
;;;246    			if (retlen != len) {
0003bc  e59d002c          LDR      r0,[sp,#0x2c]
0003c0  e1500006          CMP      r0,r6
0003c4  0a000004          BEQ      |L1.988|
;;;247    				sysprintf("nand_bbt: Error reading bad block table\n");
0003c8  e28f0f73          ADR      r0,|L1.1436|
0003cc  ebfffffe          BL       sysprintf
;;;248    				return res;
0003d0  e59d0038          LDR      r0,[sp,#0x38]
                  |L1.980|
0003d4  e28dd05c          ADD      sp,sp,#0x5c
;;;249    			}
;;;250    			sysprintf("nand_bbt: ECC error while reading bad block table\n");
;;;251    		}
;;;252    
;;;253    		/* Analyse data */
;;;254    		for (i = 0; i < len; i++) {
;;;255    			uint8_t dat = buf[i];
;;;256    			for (j = 0; j < 8; j += bits, act += 2) {
;;;257    				uint8_t tmp = (dat >> j) & msk;
;;;258    				if (tmp == msk)
;;;259    					continue;
;;;260    				if (reserved_block_code && (tmp == reserved_block_code)) {
;;;261    					sysprintf("nand_read_bbt: Reserved block at 0x%012llx\n",
;;;262    					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
;;;263    					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
;;;264    					mtd->ecc_stats.bbtblocks++;
;;;265    					continue;
;;;266    				}
;;;267    				MTDDEBUG(MTD_DEBUG_LEVEL0, "nand_read_bbt: " \
;;;268    					"Bad block at 0x%012llx\n",
;;;269    					(loff_t)((offs << 2) + (act >> 1))
;;;270    					<< this->bbt_erase_shift);
;;;271    				/* Factory marked bad or worn out ? */
;;;272    				if (tmp == 0)
;;;273    					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
;;;274    				else
;;;275    					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
;;;276    				mtd->ecc_stats.badblocks++;
;;;277    			}
;;;278    		}
;;;279    		totlen -= len;
;;;280    		from += len;
;;;281    	}
;;;282    	return 0;
;;;283    }
0003d8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.988|
0003dc  e28f0f79          ADR      r0,|L1.1480|
0003e0  ebfffffe          BL       sysprintf
                  |L1.996|
0003e4  e3a00000          MOV      r0,#0                 ;254
0003e8  e58d0034          STR      r0,[sp,#0x34]         ;254
0003ec  ea000059          B        |L1.1368|
                  |L1.1008|
0003f0  e59d0050          LDR      r0,[sp,#0x50]         ;255
0003f4  e59d1034          LDR      r1,[sp,#0x34]         ;255
0003f8  e7d00001          LDRB     r0,[r0,r1]            ;255
0003fc  e58d0010          STR      r0,[sp,#0x10]         ;255
000400  e3a00000          MOV      r0,#0                 ;256
000404  e58d0030          STR      r0,[sp,#0x30]         ;256
000408  ea00004c          B        |L1.1344|
                  |L1.1036|
00040c  e59d0010          LDR      r0,[sp,#0x10]         ;257
000410  e59d1030          LDR      r1,[sp,#0x30]         ;257
000414  e1a01150          ASR      r1,r0,r1              ;257
000418  e59d0018          LDR      r0,[sp,#0x18]         ;257
00041c  e0000001          AND      r0,r0,r1              ;257
000420  e58d000c          STR      r0,[sp,#0xc]          ;257
000424  e59d000c          LDR      r0,[sp,#0xc]          ;258
000428  e59d1018          LDR      r1,[sp,#0x18]         ;258
00042c  e1500001          CMP      r0,r1                 ;258
000430  1a000000          BNE      |L1.1080|
000434  ea00003c          B        |L1.1324|
                  |L1.1080|
000438  e59d0014          LDR      r0,[sp,#0x14]         ;260
00043c  e3500000          CMP      r0,#0                 ;260
000440  0a00001d          BEQ      |L1.1212|
000444  e59d000c          LDR      r0,[sp,#0xc]          ;260
000448  e59d1014          LDR      r1,[sp,#0x14]         ;260
00044c  e1500001          CMP      r0,r1                 ;260
000450  1a000019          BNE      |L1.1212|
000454  e1a00108          LSL      r0,r8,#2              ;261
000458  e080b0c4          ADD      r11,r0,r4,ASR #1      ;261
00045c  e1a00fcb          ASR      r0,r11,#31            ;261
000460  e595205c          LDR      r2,[r5,#0x5c]         ;261
000464  e58d0044          STR      r0,[sp,#0x44]         ;261
000468  e1a0000b          MOV      r0,r11                ;261
00046c  e59d1044          LDR      r1,[sp,#0x44]         ;261
000470  ebfffffe          BL       __aeabi_llsl
000474  e1cd00f0          STRD     r0,r1,[sp,#0]         ;261
000478  e1a02000          MOV      r2,r0                 ;261
00047c  e1a03001          MOV      r3,r1                 ;261
000480  e28f0f5d          ADR      r0,|L1.1532|
000484  ebfffffe          BL       sysprintf
000488  e08811c4          ADD      r1,r8,r4,ASR #3       ;263
00048c  e5950110          LDR      r0,[r5,#0x110]        ;263
000490  e7d00001          LDRB     r0,[r0,r1]            ;263
000494  e2041006          AND      r1,r4,#6              ;263
000498  e3a02002          MOV      r2,#2                 ;263
00049c  e1800112          ORR      r0,r0,r2,LSL r1       ;263
0004a0  e08821c4          ADD      r2,r8,r4,ASR #3       ;263
0004a4  e5951110          LDR      r1,[r5,#0x110]        ;263
0004a8  e7c10002          STRB     r0,[r1,r2]            ;263
0004ac  e597008c          LDR      r0,[r7,#0x8c]         ;264
0004b0  e2800001          ADD      r0,r0,#1              ;264
0004b4  e587008c          STR      r0,[r7,#0x8c]         ;264
0004b8  ea00001b          B        |L1.1324|
                  |L1.1212|
0004bc  e1a00000          MOV      r0,r0                 ;267
0004c0  e1a00000          MOV      r0,r0                 ;267
0004c4  e59d000c          LDR      r0,[sp,#0xc]          ;272
0004c8  e3500000          CMP      r0,#0                 ;272
0004cc  1a000009          BNE      |L1.1272|
0004d0  e08811c4          ADD      r1,r8,r4,ASR #3       ;273
0004d4  e5950110          LDR      r0,[r5,#0x110]        ;273
0004d8  e7d00001          LDRB     r0,[r0,r1]            ;273
0004dc  e2041006          AND      r1,r4,#6              ;273
0004e0  e3a02003          MOV      r2,#3                 ;273
0004e4  e1800112          ORR      r0,r0,r2,LSL r1       ;273
0004e8  e08821c4          ADD      r2,r8,r4,ASR #3       ;273
0004ec  e5951110          LDR      r1,[r5,#0x110]        ;273
0004f0  e7c10002          STRB     r0,[r1,r2]            ;273
0004f4  ea000008          B        |L1.1308|
                  |L1.1272|
0004f8  e08811c4          ADD      r1,r8,r4,ASR #3       ;275
0004fc  e5950110          LDR      r0,[r5,#0x110]        ;275
000500  e7d00001          LDRB     r0,[r0,r1]            ;275
000504  e2041006          AND      r1,r4,#6              ;275
000508  e3a02001          MOV      r2,#1                 ;275
00050c  e1800112          ORR      r0,r0,r2,LSL r1       ;275
000510  e08821c4          ADD      r2,r8,r4,ASR #3       ;275
000514  e5951110          LDR      r1,[r5,#0x110]        ;275
000518  e7c10002          STRB     r0,[r1,r2]            ;275
                  |L1.1308|
00051c  e5970088          LDR      r0,[r7,#0x88]         ;276
000520  e2800001          ADD      r0,r0,#1              ;276
000524  e5870088          STR      r0,[r7,#0x88]         ;276
000528  e1a00000          MOV      r0,r0                 ;259
                  |L1.1324|
00052c  e59d0030          LDR      r0,[sp,#0x30]         ;256
000530  e59d101c          LDR      r1,[sp,#0x1c]         ;256
000534  e0800001          ADD      r0,r0,r1              ;256
000538  e58d0030          STR      r0,[sp,#0x30]         ;256
00053c  e2844002          ADD      r4,r4,#2              ;256
                  |L1.1344|
000540  e59d0030          LDR      r0,[sp,#0x30]         ;256
000544  e3500008          CMP      r0,#8                 ;256
000548  baffffaf          BLT      |L1.1036|
00054c  e59d0034          LDR      r0,[sp,#0x34]         ;254
000550  e2800001          ADD      r0,r0,#1              ;254
000554  e58d0034          STR      r0,[sp,#0x34]         ;254
                  |L1.1368|
000558  e59d0034          LDR      r0,[sp,#0x34]         ;254
00055c  e1500006          CMP      r0,r6                 ;254
000560  3affffa2          BCC      |L1.1008|
000564  e59d0028          LDR      r0,[sp,#0x28]         ;279
000568  e0400006          SUB      r0,r0,r6              ;279
00056c  e58d0028          STR      r0,[sp,#0x28]         ;279
000570  e59d1020          LDR      r1,[sp,#0x20]         ;280
000574  e0911006          ADDS     r1,r1,r6              ;280
000578  e59d0024          LDR      r0,[sp,#0x24]         ;280
00057c  e2a00000          ADC      r0,r0,#0              ;280
000580  e58d0024          STR      r0,[sp,#0x24]         ;280
000584  e58d1020          STR      r1,[sp,#0x20]         ;280
                  |L1.1416|
000588  e59d0028          LDR      r0,[sp,#0x28]         ;233
00058c  e3500000          CMP      r0,#0                 ;233
000590  1affff68          BNE      |L1.824|
000594  e3a00000          MOV      r0,#0                 ;282
000598  eaffff8d          B        |L1.980|
                  |L1.1436|
00059c  6e616e64          DCB      "nand_bbt: Error reading bad block table\n",0
0005a0  5f626274
0005a4  3a204572
0005a8  726f7220
0005ac  72656164
0005b0  696e6720
0005b4  62616420
0005b8  626c6f63
0005bc  6b207461
0005c0  626c650a
0005c4  00      
0005c5  00                DCB      0
0005c6  00                DCB      0
0005c7  00                DCB      0
                  |L1.1480|
0005c8  6e616e64          DCB      "nand_bbt: ECC error while reading bad block table\n",0
0005cc  5f626274
0005d0  3a204543
0005d4  43206572
0005d8  726f7220
0005dc  7768696c
0005e0  65207265
0005e4  6164696e
0005e8  67206261
0005ec  6420626c
0005f0  6f636b20
0005f4  7461626c
0005f8  650a00  
0005fb  00                DCB      0
                  |L1.1532|
0005fc  6e616e64          DCB      "nand_read_bbt: Reserved block at 0x%012llx\n",0
000600  5f726561
000604  645f6262
000608  743a2052
00060c  65736572
000610  76656420
000614  626c6f63
000618  6b206174
00061c  20307825
000620  3031326c
000624  6c780a00
                          ENDP

                  read_abs_bbt PROC
;;;295    */
;;;296    static int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
000628  e92d4fff          PUSH     {r0-r11,lr}
;;;297    {
00062c  e24dd01c          SUB      sp,sp,#0x1c
000630  e1a04002          MOV      r4,r2
;;;298    	struct nand_chip *this = mtd->priv;
000634  e59d001c          LDR      r0,[sp,#0x1c]
000638  e5905094          LDR      r5,[r0,#0x94]
;;;299    	int res = 0, i;
00063c  e3a00000          MOV      r0,#0
000640  e58d0010          STR      r0,[sp,#0x10]
;;;300    
;;;301    	if (td->options & NAND_BBT_PERCHIP) {
000644  e5d40000          LDRB     r0,[r4,#0]
000648  e3100080          TST      r0,#0x80
00064c  0a00002a          BEQ      |L1.1788|
;;;302    		int offs = 0;
000650  e3a07000          MOV      r7,#0
;;;303    		for (i = 0; i < this->numchips; i++) {
000654  e3a06000          MOV      r6,#0
000658  ea000023          B        |L1.1772|
                  |L1.1628|
;;;304    			if (chip == -1 || chip == i)
00065c  e59d0028          LDR      r0,[sp,#0x28]
000660  e3700001          CMN      r0,#1
000664  0a000002          BEQ      |L1.1652|
000668  e59d0028          LDR      r0,[sp,#0x28]
00066c  e1500006          CMP      r0,r6
000670  1a00000f          BNE      |L1.1716|
                  |L1.1652|
;;;305    				res = read_bbt(mtd, buf, td->pages[i],
000674  e88d0090          STM      sp,{r4,r7}
000678  e1c586d8          LDRD     r8,r9,[r5,#0x68]
00067c  e1a00008          MOV      r0,r8
000680  e1a01009          MOV      r1,r9
000684  e595205c          LDR      r2,[r5,#0x5c]
000688  ebfffffe          BL       __aeabi_llsr
00068c  e58d000c          STR      r0,[sp,#0xc]
000690  e2840004          ADD      r0,r4,#4
000694  e7900106          LDR      r0,[r0,r6,LSL #2]
000698  e58d0008          STR      r0,[sp,#8]
00069c  e1a02000          MOV      r2,r0
0006a0  e59d001c          LDR      r0,[sp,#0x1c]
0006a4  e59d1020          LDR      r1,[sp,#0x20]
0006a8  e59d300c          LDR      r3,[sp,#0xc]
0006ac  ebfffffe          BL       read_bbt
0006b0  e58d0010          STR      r0,[sp,#0x10]
                  |L1.1716|
;;;306    					this->chipsize >> this->bbt_erase_shift,
;;;307    					td, offs);
;;;308    			if (res)
0006b4  e59d0010          LDR      r0,[sp,#0x10]
0006b8  e3500000          CMP      r0,#0
0006bc  0a000002          BEQ      |L1.1740|
;;;309    				return res;
0006c0  e59d0010          LDR      r0,[sp,#0x10]
                  |L1.1732|
0006c4  e28dd02c          ADD      sp,sp,#0x2c
;;;310    			offs += this->chipsize >> (this->bbt_erase_shift + 2);
;;;311    		}
;;;312    	} else {
;;;313    		res = read_bbt(mtd, buf, td->pages[0],
;;;314    				mtd->size >> this->bbt_erase_shift, td, 0);
;;;315    		if (res)
;;;316    			return res;
;;;317    	}
;;;318    	return 0;
;;;319    }
0006c8  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1740|
0006cc  e595005c          LDR      r0,[r5,#0x5c]         ;310
0006d0  e2802002          ADD      r2,r0,#2              ;310
0006d4  e1c5a6d8          LDRD     r10,r11,[r5,#0x68]    ;310
0006d8  e1a0000a          MOV      r0,r10                ;310
0006dc  e1a0100b          MOV      r1,r11                ;310
0006e0  ebfffffe          BL       __aeabi_llsr
0006e4  e0977000          ADDS     r7,r7,r0              ;310
0006e8  e2866001          ADD      r6,r6,#1              ;303
                  |L1.1772|
0006ec  e5950064          LDR      r0,[r5,#0x64]         ;303
0006f0  e1500006          CMP      r0,r6                 ;303
0006f4  caffffd8          BGT      |L1.1628|
0006f8  ea000019          B        |L1.1892|
                  |L1.1788|
0006fc  e3a00000          MOV      r0,#0                 ;313
000700  e58d0004          STR      r0,[sp,#4]            ;313
000704  e58d4000          STR      r4,[sp,#0]            ;313
000708  e59d001c          LDR      r0,[sp,#0x1c]         ;313
00070c  e5901008          LDR      r1,[r0,#8]            ;313
000710  e590000c          LDR      r0,[r0,#0xc]          ;313
000714  e595205c          LDR      r2,[r5,#0x5c]         ;313
000718  e58d0014          STR      r0,[sp,#0x14]         ;313
00071c  e58d1018          STR      r1,[sp,#0x18]         ;313
000720  e1a00001          MOV      r0,r1                 ;313
000724  e59d1014          LDR      r1,[sp,#0x14]         ;313
000728  ebfffffe          BL       __aeabi_llsr
00072c  e1a07000          MOV      r7,r0                 ;313
000730  e5940004          LDR      r0,[r4,#4]            ;313
000734  e1a03007          MOV      r3,r7                 ;313
000738  e58d000c          STR      r0,[sp,#0xc]          ;313
00073c  e1a02000          MOV      r2,r0                 ;313
000740  e59d001c          LDR      r0,[sp,#0x1c]         ;313
000744  e59d1020          LDR      r1,[sp,#0x20]         ;313
000748  ebfffffe          BL       read_bbt
00074c  e58d0010          STR      r0,[sp,#0x10]         ;313
000750  e59d0010          LDR      r0,[sp,#0x10]         ;315
000754  e3500000          CMP      r0,#0                 ;315
000758  0a000001          BEQ      |L1.1892|
00075c  e59d0010          LDR      r0,[sp,#0x10]         ;316
000760  eaffffd7          B        |L1.1732|
                  |L1.1892|
000764  e3a00000          MOV      r0,#0                 ;318
000768  eaffffd5          B        |L1.1732|
;;;320    
                          ENDP

                  scan_read_raw_data PROC
;;;323     */
;;;324    static int scan_read_raw_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
00076c  e92d47ff          PUSH     {r0-r10,lr}
;;;325    			 struct nand_bbt_descr *td)
;;;326    {
000770  e1a04000          MOV      r4,r0
000774  e1a05001          MOV      r5,r1
000778  e1a07002          MOV      r7,r2
00077c  e1a08003          MOV      r8,r3
000780  e59d6030          LDR      r6,[sp,#0x30]
;;;327    	size_t retlen;
;;;328    	size_t len;
;;;329    
;;;330    	len = td->len;
000784  e5969014          LDR      r9,[r6,#0x14]
;;;331    	if (td->options & NAND_BBT_VERSION)
000788  e1d600b0          LDRH     r0,[r6,#0]
00078c  e3100c01          TST      r0,#0x100
000790  0a000000          BEQ      |L1.1944|
;;;332    		len++;
000794  e2899001          ADD      r9,r9,#1
                  |L1.1944|
;;;333    
;;;334    	return mtd->read(mtd, offs, len, &retlen, buf);
000798  e28d000c          ADD      r0,sp,#0xc
00079c  e98d0021          STMIB    sp,{r0,r5}
0007a0  e58d9000          STR      r9,[sp,#0]
0007a4  e1a02007          MOV      r2,r7
0007a8  e1a03008          MOV      r3,r8
0007ac  e5941040          LDR      r1,[r4,#0x40]
0007b0  e1a00004          MOV      r0,r4
0007b4  e12fff31          BLX      r1
0007b8  e28dd010          ADD      sp,sp,#0x10
;;;335    }
0007bc  e8bd87f0          POP      {r4-r10,pc}
;;;336    
                          ENDP

                  scan_read_raw_oob PROC
;;;339     */
;;;340    static int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
0007c0  e92d43f0          PUSH     {r4-r9,lr}
;;;341    			 size_t len)
;;;342    {
0007c4  e24dd024          SUB      sp,sp,#0x24
0007c8  e1a04000          MOV      r4,r0
0007cc  e1a05001          MOV      r5,r1
0007d0  e1a07002          MOV      r7,r2
0007d4  e1a08003          MOV      r8,r3
0007d8  e59d6040          LDR      r6,[sp,#0x40]
;;;343    	struct mtd_oob_ops ops;
;;;344    	int res;
;;;345    
;;;346    	ops.mode = MTD_OOB_RAW;
0007dc  e3a00002          MOV      r0,#2
0007e0  e5cd0004          STRB     r0,[sp,#4]
;;;347    	ops.ooboffs = 0;
0007e4  e3a00000          MOV      r0,#0
0007e8  e58d0018          STR      r0,[sp,#0x18]
;;;348    	ops.ooblen = mtd->oobsize;
0007ec  e5940018          LDR      r0,[r4,#0x18]
0007f0  e58d0010          STR      r0,[sp,#0x10]
;;;349    
;;;350    
;;;351    	while (len > 0) {
0007f4  ea000027          B        |L1.2200|
                  |L1.2040|
;;;352    		if (len <= mtd->writesize) {
0007f8  e5940014          LDR      r0,[r4,#0x14]
0007fc  e1500006          CMP      r0,r6
000800  3a00000c          BCC      |L1.2104|
;;;353    			ops.oobbuf = buf + len;
000804  e0850006          ADD      r0,r5,r6
000808  e58d0020          STR      r0,[sp,#0x20]
;;;354    			ops.datbuf = buf;
00080c  e58d501c          STR      r5,[sp,#0x1c]
;;;355    			ops.len = len;
000810  e58d6008          STR      r6,[sp,#8]
;;;356    			return mtd->read_oob(mtd, offs, &ops);
000814  e28d0004          ADD      r0,sp,#4
000818  e58d0000          STR      r0,[sp,#0]
00081c  e1a02007          MOV      r2,r7
000820  e1a03008          MOV      r3,r8
000824  e594104c          LDR      r1,[r4,#0x4c]
000828  e1a00004          MOV      r0,r4
00082c  e12fff31          BLX      r1
                  |L1.2096|
000830  e28dd024          ADD      sp,sp,#0x24
;;;357    		} else {
;;;358    			ops.oobbuf = buf + mtd->writesize;
;;;359    			ops.datbuf = buf;
;;;360    			ops.len = mtd->writesize;
;;;361    			res = mtd->read_oob(mtd, offs, &ops);
;;;362    
;;;363    			if (res)
;;;364    				return res;
;;;365    		}
;;;366    
;;;367    		buf += mtd->oobsize + mtd->writesize;
;;;368    		len -= mtd->writesize;
;;;369    	}
;;;370    	return 0;
;;;371    }
000834  e8bd83f0          POP      {r4-r9,pc}
                  |L1.2104|
000838  e5940014          LDR      r0,[r4,#0x14]         ;358
00083c  e0800005          ADD      r0,r0,r5              ;358
000840  e58d0020          STR      r0,[sp,#0x20]         ;358
000844  e58d501c          STR      r5,[sp,#0x1c]         ;359
000848  e5940014          LDR      r0,[r4,#0x14]         ;360
00084c  e58d0008          STR      r0,[sp,#8]            ;360
000850  e28d0004          ADD      r0,sp,#4              ;361
000854  e58d0000          STR      r0,[sp,#0]            ;361
000858  e1a02007          MOV      r2,r7                 ;361
00085c  e1a03008          MOV      r3,r8                 ;361
000860  e594104c          LDR      r1,[r4,#0x4c]         ;361
000864  e1a00004          MOV      r0,r4                 ;361
000868  e12fff31          BLX      r1                    ;361
00086c  e1a09000          MOV      r9,r0                 ;361
000870  e3590000          CMP      r9,#0                 ;363
000874  0a000001          BEQ      |L1.2176|
000878  e1a00009          MOV      r0,r9                 ;364
00087c  eaffffeb          B        |L1.2096|
                  |L1.2176|
000880  e5940018          LDR      r0,[r4,#0x18]         ;367
000884  e5941014          LDR      r1,[r4,#0x14]         ;367
000888  e0800001          ADD      r0,r0,r1              ;367
00088c  e0855000          ADD      r5,r5,r0              ;367
000890  e5940014          LDR      r0,[r4,#0x14]         ;368
000894  e0466000          SUB      r6,r6,r0              ;368
                  |L1.2200|
000898  e3560000          CMP      r6,#0                 ;351
00089c  1affffd5          BNE      |L1.2040|
0008a0  e3a00000          MOV      r0,#0                 ;370
0008a4  eaffffe1          B        |L1.2096|
;;;372    
                          ENDP

                  scan_read_raw PROC
;;;373    static int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
0008a8  e92d43f8          PUSH     {r3-r9,lr}
;;;374    			 size_t len, struct nand_bbt_descr *td)
;;;375    {
0008ac  e1a07000          MOV      r7,r0
0008b0  e1a08001          MOV      r8,r1
0008b4  e1a04002          MOV      r4,r2
0008b8  e1a05003          MOV      r5,r3
0008bc  e59d6024          LDR      r6,[sp,#0x24]
0008c0  e59d9020          LDR      r9,[sp,#0x20]
;;;376    	if (td->options & NAND_BBT_NO_OOB)
0008c4  e5960000          LDR      r0,[r6,#0]
0008c8  e3100501          TST      r0,#0x400000
0008cc  0a000006          BEQ      |L1.2284|
;;;377    		return scan_read_raw_data(mtd, buf, offs, td);
0008d0  e1a02004          MOV      r2,r4
0008d4  e1a03005          MOV      r3,r5
0008d8  e1a01008          MOV      r1,r8
0008dc  e1a00007          MOV      r0,r7
0008e0  e58d6000          STR      r6,[sp,#0]
0008e4  ebfffffe          BL       scan_read_raw_data
                  |L1.2280|
;;;378    	else
;;;379    		return scan_read_raw_oob(mtd, buf, offs, len);
;;;380    }
0008e8  e8bd83f8          POP      {r3-r9,pc}
                  |L1.2284|
0008ec  e1a02004          MOV      r2,r4                 ;379
0008f0  e1a03005          MOV      r3,r5                 ;379
0008f4  e1a01008          MOV      r1,r8                 ;379
0008f8  e1a00007          MOV      r0,r7                 ;379
0008fc  e58d9000          STR      r9,[sp,#0]            ;379
000900  ebfffffe          BL       scan_read_raw_oob
000904  eafffff7          B        |L1.2280|
;;;381    
                          ENDP

                  scan_write_bbt PROC
;;;384     */
;;;385    static int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
000908  e92d43f0          PUSH     {r4-r9,lr}
;;;386    			  uint8_t *buf, uint8_t *oob)
;;;387    {
00090c  e24dd024          SUB      sp,sp,#0x24
000910  e1a04000          MOV      r4,r0
000914  e1a05002          MOV      r5,r2
000918  e1a06003          MOV      r6,r3
00091c  e28d9040          ADD      r9,sp,#0x40
000920  e8990380          LDM      r9,{r7-r9}
;;;388    	struct mtd_oob_ops ops;
;;;389    
;;;390    	ops.mode = MTD_OOB_PLACE;
000924  e3a00000          MOV      r0,#0
000928  e5cd0004          STRB     r0,[sp,#4]
;;;391    	ops.ooboffs = 0;
00092c  e58d0018          STR      r0,[sp,#0x18]
;;;392    	ops.ooblen = mtd->oobsize;
000930  e5940018          LDR      r0,[r4,#0x18]
000934  e58d0010          STR      r0,[sp,#0x10]
;;;393    	ops.datbuf = buf;
000938  e58d801c          STR      r8,[sp,#0x1c]
;;;394    	ops.oobbuf = oob;
00093c  e58d9020          STR      r9,[sp,#0x20]
;;;395    	ops.len = len;
000940  e58d7008          STR      r7,[sp,#8]
;;;396    
;;;397    	return mtd->write_oob(mtd, offs, &ops);
000944  e28d0004          ADD      r0,sp,#4
000948  e58d0000          STR      r0,[sp,#0]
00094c  e1a02005          MOV      r2,r5
000950  e1a03006          MOV      r3,r6
000954  e5941050          LDR      r1,[r4,#0x50]
000958  e1a00004          MOV      r0,r4
00095c  e12fff31          BLX      r1
000960  e28dd024          ADD      sp,sp,#0x24
;;;398    }
000964  e8bd83f0          POP      {r4-r9,pc}
;;;399    
                          ENDP

                  bbt_get_ver_offs PROC
;;;400    static u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
000968  e1a02000          MOV      r2,r0
;;;401    {
;;;402    	u32 ver_offs = td->veroffs;
00096c  e591000c          LDR      r0,[r1,#0xc]
;;;403    
;;;404    	if (!(td->options & NAND_BBT_NO_OOB))
000970  e5913000          LDR      r3,[r1,#0]
000974  e3130501          TST      r3,#0x400000
000978  1a000001          BNE      |L1.2436|
;;;405    		ver_offs += mtd->writesize;
00097c  e5923014          LDR      r3,[r2,#0x14]
000980  e0800003          ADD      r0,r0,r3
                  |L1.2436|
;;;406    	return ver_offs;
;;;407    }
000984  e12fff1e          BX       lr
;;;408    
                          ENDP

                  read_abs_bbts PROC
;;;419    */
;;;420    static int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
000988  e92d4ff0          PUSH     {r4-r11,lr}
;;;421    			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
;;;422    {
00098c  e24dd014          SUB      sp,sp,#0x14
000990  e1a06000          MOV      r6,r0
000994  e1a09001          MOV      r9,r1
000998  e1a04002          MOV      r4,r2
00099c  e1a05003          MOV      r5,r3
;;;423    	struct nand_chip *this = mtd->priv;
0009a0  e5960094          LDR      r0,[r6,#0x94]
0009a4  e58d0010          STR      r0,[sp,#0x10]
;;;424    
;;;425    	/* Read the primary version, if available */
;;;426    	if (td->options & NAND_BBT_VERSION) {
0009a8  e1d400b0          LDRH     r0,[r4,#0]
0009ac  e3100c01          TST      r0,#0x100
0009b0  0a000017          BEQ      |L1.2580|
;;;427    		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
0009b4  e5960014          LDR      r0,[r6,#0x14]
0009b8  e88d0011          STM      sp,{r0,r4}
0009bc  e5947004          LDR      r7,[r4,#4]
0009c0  e1a0afc7          ASR      r10,r7,#31
0009c4  e59d0010          LDR      r0,[sp,#0x10]
0009c8  e5902054          LDR      r2,[r0,#0x54]
0009cc  e1a00007          MOV      r0,r7
0009d0  e1a0100a          MOV      r1,r10
0009d4  ebfffffe          BL       __aeabi_llsl
0009d8  e1cd00f8          STRD     r0,r1,[sp,#8]
0009dc  e1a02000          MOV      r2,r0
0009e0  e1a03001          MOV      r3,r1
0009e4  e1a01009          MOV      r1,r9
0009e8  e1a00006          MOV      r0,r6
0009ec  ebfffffe          BL       scan_read_raw
;;;428    			      mtd->writesize, td);
;;;429    		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
0009f0  e1a01004          MOV      r1,r4
0009f4  e1a00006          MOV      r0,r6
0009f8  ebfffffe          BL       bbt_get_ver_offs
0009fc  e7d90000          LDRB     r0,[r9,r0]
000a00  e5c40010          STRB     r0,[r4,#0x10]
;;;430    		sysprintf("Bad block table at page %d, version 0x%02X\n",
000a04  e5d42010          LDRB     r2,[r4,#0x10]
000a08  e28f0fd6          ADR      r0,|L1.3432|
000a0c  e5941004          LDR      r1,[r4,#4]
000a10  ebfffffe          BL       sysprintf
                  |L1.2580|
;;;431    		       td->pages[0], td->version[0]);
;;;432    	}
;;;433    
;;;434    	/* Read the mirror version, if available */
;;;435    	if (md && (md->options & NAND_BBT_VERSION)) {
000a14  e3550000          CMP      r5,#0
000a18  0a00001a          BEQ      |L1.2696|
000a1c  e1d500b0          LDRH     r0,[r5,#0]
000a20  e3100c01          TST      r0,#0x100
000a24  0a000017          BEQ      |L1.2696|
;;;436    		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
000a28  e5960014          LDR      r0,[r6,#0x14]
000a2c  e88d0011          STM      sp,{r0,r4}
000a30  e5958004          LDR      r8,[r5,#4]
000a34  e1a0bfc8          ASR      r11,r8,#31
000a38  e59d0010          LDR      r0,[sp,#0x10]
000a3c  e5902054          LDR      r2,[r0,#0x54]
000a40  e1a00008          MOV      r0,r8
000a44  e1a0100b          MOV      r1,r11
000a48  ebfffffe          BL       __aeabi_llsl
000a4c  e1cd00f8          STRD     r0,r1,[sp,#8]
000a50  e1a02000          MOV      r2,r0
000a54  e1a03001          MOV      r3,r1
000a58  e1a01009          MOV      r1,r9
000a5c  e1a00006          MOV      r0,r6
000a60  ebfffffe          BL       scan_read_raw
;;;437    			      mtd->writesize, td);
;;;438    		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
000a64  e1a01005          MOV      r1,r5
000a68  e1a00006          MOV      r0,r6
000a6c  ebfffffe          BL       bbt_get_ver_offs
000a70  e7d90000          LDRB     r0,[r9,r0]
000a74  e5c50010          STRB     r0,[r5,#0x10]
;;;439    		sysprintf("Bad block table at page %d, version 0x%02X\n",
000a78  e5d52010          LDRB     r2,[r5,#0x10]
000a7c  e28f0fb9          ADR      r0,|L1.3432|
000a80  e5951004          LDR      r1,[r5,#4]
000a84  ebfffffe          BL       sysprintf
                  |L1.2696|
;;;440    		       md->pages[0], md->version[0]);
;;;441    	}
;;;442    	return 1;
000a88  e3a00001          MOV      r0,#1
000a8c  e28dd014          ADD      sp,sp,#0x14
;;;443    }
000a90  e8bd8ff0          POP      {r4-r11,pc}
;;;444    
                          ENDP

                  scan_block_full PROC
;;;447     */
;;;448    static int scan_block_full(struct mtd_info *mtd, struct nand_bbt_descr *bd,
000a94  e92d4ff8          PUSH     {r3-r11,lr}
;;;449    			   loff_t offs, uint8_t *buf, size_t readlen,
;;;450    			   int scanlen, int len)
;;;451    {
000a98  e1a06000          MOV      r6,r0
000a9c  e1a09001          MOV      r9,r1
000aa0  e1a07002          MOV      r7,r2
000aa4  e1a08003          MOV      r8,r3
000aa8  e59d4028          LDR      r4,[sp,#0x28]
000aac  e59da030          LDR      r10,[sp,#0x30]
;;;452    	int ret, j;
;;;453    
;;;454    	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
000ab0  e59d002c          LDR      r0,[sp,#0x2c]
000ab4  e1a02007          MOV      r2,r7
000ab8  e1a03008          MOV      r3,r8
000abc  e1a01004          MOV      r1,r4
000ac0  e58d0000          STR      r0,[sp,#0]
000ac4  e1a00006          MOV      r0,r6
000ac8  ebfffffe          BL       scan_read_raw_oob
000acc  e1a0b000          MOV      r11,r0
;;;455    	if (ret)
000ad0  e35b0000          CMP      r11,#0
000ad4  0a000001          BEQ      |L1.2784|
;;;456    		return ret;
000ad8  e1a0000b          MOV      r0,r11
                  |L1.2780|
;;;457    
;;;458    	for (j = 0; j < len; j++, buf += scanlen) {
;;;459    		if (check_pattern(buf, scanlen, mtd->writesize, bd))
;;;460    			return 1;
;;;461    	}
;;;462    	return 0;
;;;463    }
000adc  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2784|
000ae0  e3a05000          MOV      r5,#0                 ;458
000ae4  ea00000a          B        |L1.2836|
                  |L1.2792|
000ae8  e1a03009          MOV      r3,r9                 ;459
000aec  e1a0100a          MOV      r1,r10                ;459
000af0  e1a00004          MOV      r0,r4                 ;459
000af4  e5962014          LDR      r2,[r6,#0x14]         ;459
000af8  ebfffffe          BL       check_pattern
000afc  e3500000          CMP      r0,#0                 ;459
000b00  0a000001          BEQ      |L1.2828|
000b04  e3a00001          MOV      r0,#1                 ;460
000b08  eafffff3          B        |L1.2780|
                  |L1.2828|
000b0c  e2855001          ADD      r5,r5,#1              ;458
000b10  e084400a          ADD      r4,r4,r10             ;458
                  |L1.2836|
000b14  e59d0034          LDR      r0,[sp,#0x34]         ;458
000b18  e1550000          CMP      r5,r0                 ;458
000b1c  bafffff1          BLT      |L1.2792|
000b20  e3a00000          MOV      r0,#0                 ;462
000b24  eaffffec          B        |L1.2780|
;;;464    
                          ENDP

                  scan_block_fast PROC
;;;467     */
;;;468    static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
000b28  e92d4ff0          PUSH     {r4-r11,lr}
;;;469    			   loff_t offs, uint8_t *buf, int len)
;;;470    {
000b2c  e24dd024          SUB      sp,sp,#0x24
000b30  e1a04000          MOV      r4,r0
000b34  e1a0a001          MOV      r10,r1
000b38  e1a06002          MOV      r6,r2
000b3c  e1a07003          MOV      r7,r3
000b40  e59d8048          LDR      r8,[sp,#0x48]
000b44  e59db04c          LDR      r11,[sp,#0x4c]
;;;471    	struct mtd_oob_ops ops;
;;;472    	int j, ret;
;;;473    
;;;474    	ops.ooblen = mtd->oobsize;
000b48  e5940018          LDR      r0,[r4,#0x18]
000b4c  e58d0010          STR      r0,[sp,#0x10]
;;;475    	ops.oobbuf = buf;
000b50  e58d8020          STR      r8,[sp,#0x20]
;;;476    	ops.ooboffs = 0;
000b54  e3a00000          MOV      r0,#0
000b58  e58d0018          STR      r0,[sp,#0x18]
;;;477    	ops.datbuf = NULL;
000b5c  e58d001c          STR      r0,[sp,#0x1c]
;;;478    	ops.mode = MTD_OOB_PLACE;
000b60  e5cd0004          STRB     r0,[sp,#4]
;;;479    
;;;480    	for (j = 0; j < len; j++) {
000b64  e3a09000          MOV      r9,#0
000b68  ea000017          B        |L1.3020|
                  |L1.2924|
;;;481    		/*
;;;482    		 * Read the full oob until read_oob is fixed to
;;;483    		 * handle single byte reads for 16 bit
;;;484    		 * buswidth
;;;485    		 */
;;;486    		ret = mtd->read_oob(mtd, offs, &ops);
000b6c  e28d0004          ADD      r0,sp,#4
000b70  e58d0000          STR      r0,[sp,#0]
000b74  e1a02006          MOV      r2,r6
000b78  e1a03007          MOV      r3,r7
000b7c  e594104c          LDR      r1,[r4,#0x4c]
000b80  e1a00004          MOV      r0,r4
000b84  e12fff31          BLX      r1
000b88  e1a05000          MOV      r5,r0
;;;487    		if (ret)
000b8c  e3550000          CMP      r5,#0
000b90  0a000002          BEQ      |L1.2976|
;;;488    			return ret;
000b94  e1a00005          MOV      r0,r5
                  |L1.2968|
000b98  e28dd024          ADD      sp,sp,#0x24
;;;489    
;;;490    		if (check_short_pattern(buf, bd))
;;;491    			return 1;
;;;492    
;;;493    		offs += mtd->writesize;
;;;494    	}
;;;495    	return 0;
;;;496    }
000b9c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2976|
000ba0  e1a0100a          MOV      r1,r10                ;490
000ba4  e1a00008          MOV      r0,r8                 ;490
000ba8  ebfffffe          BL       check_short_pattern
000bac  e3500000          CMP      r0,#0                 ;490
000bb0  0a000001          BEQ      |L1.3004|
000bb4  e3a00001          MOV      r0,#1                 ;491
000bb8  eafffff6          B        |L1.2968|
                  |L1.3004|
000bbc  e5940014          LDR      r0,[r4,#0x14]         ;493
000bc0  e0966000          ADDS     r6,r6,r0              ;493
000bc4  e2a77000          ADC      r7,r7,#0              ;493
000bc8  e2899001          ADD      r9,r9,#1              ;480
                  |L1.3020|
000bcc  e159000b          CMP      r9,r11                ;480
000bd0  baffffe5          BLT      |L1.2924|
000bd4  e3a00000          MOV      r0,#0                 ;495
000bd8  eaffffee          B        |L1.2968|
;;;497    
                          ENDP

                  create_bbt PROC
;;;508     */
;;;509    static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
000bdc  e92d4fff          PUSH     {r0-r11,lr}
;;;510    	struct nand_bbt_descr *bd, int chip)
;;;511    {
000be0  e24dd03c          SUB      sp,sp,#0x3c
000be4  e1a05000          MOV      r5,r0
000be8  e1a06002          MOV      r6,r2
;;;512    	struct nand_chip *this = mtd->priv;
000bec  e5954094          LDR      r4,[r5,#0x94]
;;;513    	int i, numblocks, len, scanlen;
;;;514    	int startblock;
;;;515    	loff_t from;
;;;516    	size_t readlen;
;;;517    
;;;518    	MTDDEBUG(MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");
000bf0  e1a00000          MOV      r0,r0
000bf4  e1a00000          MOV      r0,r0
;;;519    
;;;520    	if (bd->options & NAND_BBT_SCANALLPAGES)
000bf8  e1d600b0          LDRH     r0,[r6,#0]
000bfc  e3100b01          TST      r0,#0x400
000c00  0a000005          BEQ      |L1.3100|
;;;521    		len = 1 << (this->bbt_erase_shift - this->page_shift);
000c04  e5d4005c          LDRB     r0,[r4,#0x5c]
000c08  e5d41054          LDRB     r1,[r4,#0x54]
000c0c  e0400001          SUB      r0,r0,r1
000c10  e3a01001          MOV      r1,#1
000c14  e1a09011          LSL      r9,r1,r0
000c18  ea000005          B        |L1.3124|
                  |L1.3100|
;;;522    	else if (bd->options & NAND_BBT_SCAN2NDPAGE)
000c1c  e1d600b0          LDRH     r0,[r6,#0]
000c20  e3100901          TST      r0,#0x4000
000c24  0a000001          BEQ      |L1.3120|
;;;523    		len = 2;
000c28  e3a09002          MOV      r9,#2
000c2c  ea000000          B        |L1.3124|
                  |L1.3120|
;;;524    	else
;;;525    		len = 1;
000c30  e3a09001          MOV      r9,#1
                  |L1.3124|
;;;526    
;;;527    	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
000c34  e1d600b0          LDRH     r0,[r6,#0]
000c38  e3100b02          TST      r0,#0x800
000c3c  1a000004          BNE      |L1.3156|
;;;528    		/* We need only read few bytes from the OOB area */
;;;529    		scanlen = 0;
000c40  e3a00000          MOV      r0,#0
000c44  e58d001c          STR      r0,[sp,#0x1c]
;;;530    		readlen = bd->len;
000c48  e5960014          LDR      r0,[r6,#0x14]
000c4c  e58d0018          STR      r0,[sp,#0x18]
000c50  ea000006          B        |L1.3184|
                  |L1.3156|
;;;531    	} else {
;;;532    		/* Full page content should be read */
;;;533    		scanlen = mtd->writesize + mtd->oobsize;
000c54  e5950014          LDR      r0,[r5,#0x14]
000c58  e5951018          LDR      r1,[r5,#0x18]
000c5c  e0800001          ADD      r0,r0,r1
000c60  e58d001c          STR      r0,[sp,#0x1c]
;;;534    		readlen = len * mtd->writesize;
000c64  e5950014          LDR      r0,[r5,#0x14]
000c68  e0000099          MUL      r0,r9,r0
000c6c  e58d0018          STR      r0,[sp,#0x18]
                  |L1.3184|
;;;535    	}
;;;536    
;;;537    	if (chip == -1) {
000c70  e59d0048          LDR      r0,[sp,#0x48]
000c74  e3700001          CMN      r0,#1
000c78  1a00000a          BNE      |L1.3240|
;;;538    		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
;;;539    		 * below as it makes shifting and masking less painful */
;;;540    		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
000c7c  e1c500d8          LDRD     r0,r1,[r5,#8]
000c80  e594205c          LDR      r2,[r4,#0x5c]
000c84  e2422001          SUB      r2,r2,#1
000c88  e58d0028          STR      r0,[sp,#0x28]
000c8c  e58d1024          STR      r1,[sp,#0x24]
000c90  ebfffffe          BL       __aeabi_llsr
000c94  e58d0020          STR      r0,[sp,#0x20]
;;;541    		startblock = 0;
000c98  e3a0a000          MOV      r10,#0
000c9c  e3a07000          MOV      r7,#0
000ca0  e1a08007          MOV      r8,r7
;;;542    		from = 0;
000ca4  ea000025          B        |L1.3392|
                  |L1.3240|
;;;543    	} else {
;;;544    		if (chip >= this->numchips) {
000ca8  e5941064          LDR      r1,[r4,#0x64]
000cac  e59d0048          LDR      r0,[sp,#0x48]
000cb0  e1510000          CMP      r1,r0
000cb4  ca000007          BGT      |L1.3288|
;;;545    			sysprintf("create_bbt(): chipnr (%d) > available chips (%d)\n",
000cb8  e5942064          LDR      r2,[r4,#0x64]
000cbc  e59d0048          LDR      r0,[sp,#0x48]
000cc0  e2801001          ADD      r1,r0,#1
000cc4  e28f00c8          ADR      r0,|L1.3476|
000cc8  ebfffffe          BL       sysprintf
;;;546    			       chip + 1, this->numchips);
;;;547    			return -EINVAL;
000ccc  e3e00015          MVN      r0,#0x15
                  |L1.3280|
000cd0  e28dd04c          ADD      sp,sp,#0x4c
;;;548    		}
;;;549    		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
;;;550    		startblock = chip * numblocks;
;;;551    		numblocks += startblock;
;;;552    		from = (loff_t)startblock << (this->bbt_erase_shift - 1);
;;;553    	}
;;;554    
;;;555    	if (this->options & NAND_BBT_SCANLASTPAGE)
;;;556    		from += mtd->erasesize - (mtd->writesize * len);
;;;557    
;;;558    	for (i = startblock; i < numblocks;) {
;;;559    		int ret;
;;;560    
;;;561    		BUG_ON(bd->options & NAND_BBT_NO_OOB);
;;;562    
;;;563    		if (bd->options & NAND_BBT_SCANALLPAGES)
;;;564    			ret = scan_block_full(mtd, bd, from, buf, readlen,
;;;565    					      scanlen, len);
;;;566    		else
;;;567    			ret = scan_block_fast(mtd, bd, from, buf, len);
;;;568    
;;;569    		if (ret < 0)
;;;570    			return ret;
;;;571    
;;;572    		if (ret) {
;;;573    			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
;;;574    			MTDDEBUG(MTD_DEBUG_LEVEL0,
;;;575    				  "Bad eraseblock %d at 0x%012llx\n",
;;;576    				  i >> 1, (unsigned long long)from);
;;;577    			mtd->ecc_stats.badblocks++;
;;;578    		}
;;;579    
;;;580    		i += 2;
;;;581    		from += (1 << this->bbt_erase_shift);
;;;582    	}
;;;583    	return 0;
;;;584    }
000cd4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3288|
000cd8  e594205c          LDR      r2,[r4,#0x5c]         ;549
000cdc  e2422001          SUB      r2,r2,#1              ;549
000ce0  e594006c          LDR      r0,[r4,#0x6c]         ;549
000ce4  e5941068          LDR      r1,[r4,#0x68]         ;549
000ce8  e58d0034          STR      r0,[sp,#0x34]         ;549
000cec  e58d1038          STR      r1,[sp,#0x38]         ;549
000cf0  e1a00001          MOV      r0,r1                 ;549
000cf4  e59d1034          LDR      r1,[sp,#0x34]         ;549
000cf8  ebfffffe          BL       __aeabi_llsr
000cfc  e58d0020          STR      r0,[sp,#0x20]         ;549
000d00  e59d0048          LDR      r0,[sp,#0x48]         ;550
000d04  e59d1020          LDR      r1,[sp,#0x20]         ;550
000d08  e00a0190          MUL      r10,r0,r1             ;550
000d0c  e59d0020          LDR      r0,[sp,#0x20]         ;551
000d10  e080000a          ADD      r0,r0,r10             ;551
000d14  e58d0020          STR      r0,[sp,#0x20]         ;551
000d18  e594005c          LDR      r0,[r4,#0x5c]         ;552
000d1c  e2402001          SUB      r2,r0,#1              ;552
000d20  e1a00fca          ASR      r0,r10,#31            ;552
000d24  e58d002c          STR      r0,[sp,#0x2c]         ;552
000d28  e58da030          STR      r10,[sp,#0x30]        ;552
000d2c  e1a0000a          MOV      r0,r10                ;552
000d30  e59d102c          LDR      r1,[sp,#0x2c]         ;552
000d34  ebfffffe          BL       __aeabi_llsl
000d38  e1a07000          MOV      r7,r0                 ;552
000d3c  e1a08001          MOV      r8,r1                 ;552
                  |L1.3392|
000d40  e1d405b0          LDRH     r0,[r4,#0x50]         ;555
000d44  e3100902          TST      r0,#0x8000            ;555
000d48  0a000004          BEQ      |L1.3424|
000d4c  e1c501d0          LDRD     r0,r1,[r5,#0x10]      ;556
000d50  e0010199          MUL      r1,r9,r1              ;556
000d54  e0400001          SUB      r0,r0,r1              ;556
000d58  e0977000          ADDS     r7,r7,r0              ;556
000d5c  e2a88000          ADC      r8,r8,#0              ;556
                  |L1.3424|
000d60  e1a0b00a          MOV      r11,r10               ;558
000d64  ea000052          B        |L1.3764|
                  |L1.3432|
000d68  42616420          DCB      "Bad block table at page %d, version 0x%02X\n",0
000d6c  626c6f63
000d70  6b207461
000d74  626c6520
000d78  61742070
000d7c  61676520
000d80  25642c20
000d84  76657273
000d88  696f6e20
000d8c  30782530
000d90  32580a00
                  |L1.3476|
000d94  63726561          DCB      "create_bbt(): chipnr (%d) > available chips (%d)\n",0
000d98  74655f62
000d9c  62742829
000da0  3a206368
000da4  69706e72
000da8  20282564
000dac  29203e20
000db0  61766169
000db4  6c61626c
000db8  65206368
000dbc  69707320
000dc0  28256429
000dc4  0a00    
000dc6  00                DCB      0
000dc7  00                DCB      0
                  |L1.3528|
000dc8  e5960000          LDR      r0,[r6,#0]            ;561
000dcc  e3100501          TST      r0,#0x400000          ;561
000dd0  0a000004          BEQ      |L1.3560|
000dd4  e59f1308          LDR      r1,|L1.4324|
000dd8  e28f0fc2          ADR      r0,|L1.4328|
000ddc  ebfffffe          BL       sysprintf
000de0  e1a00000          MOV      r0,r0                 ;561
                  |L1.3556|
000de4  eafffffe          B        |L1.3556|
                  |L1.3560|
000de8  e1d600b0          LDRH     r0,[r6,#0]            ;563
000dec  e3100b01          TST      r0,#0x400             ;563
000df0  0a00000c          BEQ      |L1.3624|
000df4  e59d0040          LDR      r0,[sp,#0x40]         ;564
000df8  e59d101c          LDR      r1,[sp,#0x1c]         ;564
000dfc  e59d2018          LDR      r2,[sp,#0x18]         ;564
000e00  e88d0005          STM      sp,{r0,r2}            ;564
000e04  e1a02007          MOV      r2,r7                 ;564
000e08  e1a03008          MOV      r3,r8                 ;564
000e0c  e58d1008          STR      r1,[sp,#8]            ;564
000e10  e58d900c          STR      r9,[sp,#0xc]          ;564
000e14  e1a01006          MOV      r1,r6                 ;564
000e18  e1a00005          MOV      r0,r5                 ;564
000e1c  ebfffffe          BL       scan_block_full
000e20  e58d0014          STR      r0,[sp,#0x14]         ;564
000e24  ea000007          B        |L1.3656|
                  |L1.3624|
000e28  e59d0040          LDR      r0,[sp,#0x40]         ;567
000e2c  e1a02007          MOV      r2,r7                 ;567
000e30  e1a03008          MOV      r3,r8                 ;567
000e34  e1a01006          MOV      r1,r6                 ;567
000e38  e88d0201          STM      sp,{r0,r9}            ;567
000e3c  e1a00005          MOV      r0,r5                 ;567
000e40  ebfffffe          BL       scan_block_fast
000e44  e58d0014          STR      r0,[sp,#0x14]         ;567
                  |L1.3656|
000e48  e59d0014          LDR      r0,[sp,#0x14]         ;569
000e4c  e3500000          CMP      r0,#0                 ;569
000e50  aa000001          BGE      |L1.3676|
000e54  e59d0014          LDR      r0,[sp,#0x14]         ;570
000e58  eaffff9c          B        |L1.3280|
                  |L1.3676|
000e5c  e59d0014          LDR      r0,[sp,#0x14]         ;572
000e60  e3500000          CMP      r0,#0                 ;572
000e64  0a00000b          BEQ      |L1.3736|
000e68  e5940110          LDR      r0,[r4,#0x110]        ;573
000e6c  e7d001cb          LDRB     r0,[r0,r11,ASR #3]    ;573
000e70  e20b1006          AND      r1,r11,#6             ;573
000e74  e3a02003          MOV      r2,#3                 ;573
000e78  e1800112          ORR      r0,r0,r2,LSL r1       ;573
000e7c  e5941110          LDR      r1,[r4,#0x110]        ;573
000e80  e7c101cb          STRB     r0,[r1,r11,ASR #3]    ;573
000e84  e1a00000          MOV      r0,r0                 ;574
000e88  e1a00000          MOV      r0,r0                 ;574
000e8c  e5950088          LDR      r0,[r5,#0x88]         ;577
000e90  e2800001          ADD      r0,r0,#1              ;577
000e94  e5850088          STR      r0,[r5,#0x88]         ;577
                  |L1.3736|
000e98  e28bb002          ADD      r11,r11,#2            ;580
000e9c  e5d4005c          LDRB     r0,[r4,#0x5c]         ;581
000ea0  e3a01001          MOV      r1,#1                 ;581
000ea4  e1a00011          LSL      r0,r1,r0              ;581
000ea8  e0977000          ADDS     r7,r7,r0              ;581
000eac  e0a88fc0          ADC      r8,r8,r0,ASR #31      ;581
000eb0  e1a00000          MOV      r0,r0                 ;582
                  |L1.3764|
000eb4  e59d0020          LDR      r0,[sp,#0x20]         ;558
000eb8  e15b0000          CMP      r11,r0                ;558
000ebc  baffffc1          BLT      |L1.3528|
000ec0  e3a00000          MOV      r0,#0                 ;583
000ec4  eaffff81          B        |L1.3280|
;;;585    
                          ENDP

                  search_bbt PROC
;;;602     */
;;;603    static int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
000ec8  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;604    {
000ecc  e24dd048          SUB      sp,sp,#0x48
000ed0  e1a09000          MOV      r9,r0
000ed4  e1a04002          MOV      r4,r2
;;;605    	struct nand_chip *this = mtd->priv;
000ed8  e5996094          LDR      r6,[r9,#0x94]
;;;606    	int i, chips;
;;;607    	int startblock, block, dir;
;;;608    	int scanlen = mtd->writesize + mtd->oobsize;
000edc  e5990014          LDR      r0,[r9,#0x14]
000ee0  e5991018          LDR      r1,[r9,#0x18]
000ee4  e0800001          ADD      r0,r0,r1
000ee8  e58d0014          STR      r0,[sp,#0x14]
;;;609    	int bbtblocks;
;;;610    	int blocktopage = this->bbt_erase_shift - this->page_shift;
000eec  e596005c          LDR      r0,[r6,#0x5c]
000ef0  e5961054          LDR      r1,[r6,#0x54]
000ef4  e0400001          SUB      r0,r0,r1
000ef8  e58d000c          STR      r0,[sp,#0xc]
;;;611    
;;;612    	/* Search direction top -> down ? */
;;;613    	if (td->options & NAND_BBT_LASTBLOCK) {
000efc  e5d40000          LDRB     r0,[r4,#0]
000f00  e3100010          TST      r0,#0x10
000f04  0a00000b          BEQ      |L1.3896|
;;;614    		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
000f08  e599000c          LDR      r0,[r9,#0xc]
000f0c  e5991008          LDR      r1,[r9,#8]
000f10  e596205c          LDR      r2,[r6,#0x5c]
000f14  e58d0024          STR      r0,[sp,#0x24]
000f18  e58d1028          STR      r1,[sp,#0x28]
000f1c  e1a00001          MOV      r0,r1
000f20  e59d1024          LDR      r1,[sp,#0x24]
000f24  ebfffffe          BL       __aeabi_llsr
000f28  e250a001          SUBS     r10,r0,#1
;;;615    		dir = -1;
000f2c  e3e00000          MVN      r0,#0
000f30  e58d0018          STR      r0,[sp,#0x18]
000f34  ea000002          B        |L1.3908|
                  |L1.3896|
;;;616    	} else {
;;;617    		startblock = 0;
000f38  e3a0a000          MOV      r10,#0
;;;618    		dir = 1;
000f3c  e3a00001          MOV      r0,#1
000f40  e58d0018          STR      r0,[sp,#0x18]
                  |L1.3908|
;;;619    	}
;;;620    
;;;621    	/* Do we have a bbt per chip ? */
;;;622    	if (td->options & NAND_BBT_PERCHIP) {
000f44  e5d40000          LDRB     r0,[r4,#0]
000f48  e3100080          TST      r0,#0x80
000f4c  0a00000e          BEQ      |L1.3980|
;;;623    		chips = this->numchips;
000f50  e5960064          LDR      r0,[r6,#0x64]
000f54  e58d0020          STR      r0,[sp,#0x20]
;;;624    		bbtblocks = this->chipsize >> this->bbt_erase_shift;
000f58  e596006c          LDR      r0,[r6,#0x6c]
000f5c  e5961068          LDR      r1,[r6,#0x68]
000f60  e596205c          LDR      r2,[r6,#0x5c]
000f64  e58d002c          STR      r0,[sp,#0x2c]
000f68  e58d1030          STR      r1,[sp,#0x30]
000f6c  e1a00001          MOV      r0,r1
000f70  e59d102c          LDR      r1,[sp,#0x2c]
000f74  ebfffffe          BL       __aeabi_llsr
000f78  e58d0010          STR      r0,[sp,#0x10]
;;;625    		startblock &= bbtblocks - 1;
000f7c  e59d0010          LDR      r0,[sp,#0x10]
000f80  e2400001          SUB      r0,r0,#1
000f84  e00aa000          AND      r10,r10,r0
000f88  ea00000a          B        |L1.4024|
                  |L1.3980|
;;;626    	} else {
;;;627    		chips = 1;
000f8c  e3a00001          MOV      r0,#1
000f90  e58d0020          STR      r0,[sp,#0x20]
;;;628    		bbtblocks = mtd->size >> this->bbt_erase_shift;
000f94  e599000c          LDR      r0,[r9,#0xc]
000f98  e5991008          LDR      r1,[r9,#8]
000f9c  e596205c          LDR      r2,[r6,#0x5c]
000fa0  e58d0034          STR      r0,[sp,#0x34]
000fa4  e58d1038          STR      r1,[sp,#0x38]
000fa8  e1a00001          MOV      r0,r1
000fac  e59d1034          LDR      r1,[sp,#0x34]
000fb0  ebfffffe          BL       __aeabi_llsr
000fb4  e58d0010          STR      r0,[sp,#0x10]
                  |L1.4024|
;;;629    	}
;;;630    
;;;631    	for (i = 0; i < chips; i++) {
000fb8  e3a05000          MOV      r5,#0
000fbc  ea000043          B        |L1.4304|
                  |L1.4032|
;;;632    		/* Reset version information */
;;;633    		td->version[i] = 0;
000fc0  e3a00000          MOV      r0,#0
000fc4  e2841010          ADD      r1,r4,#0x10
000fc8  e7c10005          STRB     r0,[r1,r5]
;;;634    		td->pages[i] = -1;
000fcc  e3e00000          MVN      r0,#0
000fd0  e2841004          ADD      r1,r4,#4
000fd4  e7810105          STR      r0,[r1,r5,LSL #2]
;;;635    		/* Scan the maximum number of blocks */
;;;636    		for (block = 0; block < td->maxblocks; block++) {
000fd8  e3a00000          MOV      r0,#0
000fdc  e58d001c          STR      r0,[sp,#0x1c]
000fe0  ea00002c          B        |L1.4248|
                  |L1.4068|
;;;637    
;;;638    			int actblock = startblock + dir * block;
000fe4  e1cd01d8          LDRD     r0,r1,[sp,#0x18]
000fe8  e02ba190          MLA      r11,r0,r1,r10
000fec  e58db008          STR      r11,[sp,#8]
;;;639    			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;
000ff0  e596205c          LDR      r2,[r6,#0x5c]
000ff4  e59db008          LDR      r11,[sp,#8]
000ff8  e1a00fcb          ASR      r0,r11,#31
000ffc  e58d003c          STR      r0,[sp,#0x3c]
001000  e1a0000b          MOV      r0,r11
001004  e59d103c          LDR      r1,[sp,#0x3c]
001008  ebfffffe          BL       __aeabi_llsl
00100c  e1a07000          MOV      r7,r0
001010  e1a08001          MOV      r8,r1
;;;640    
;;;641    			/* Read first page */
;;;642    			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
001014  e5990014          LDR      r0,[r9,#0x14]
001018  e1a02007          MOV      r2,r7
00101c  e1a03008          MOV      r3,r8
001020  e88d0011          STM      sp,{r0,r4}
001024  e1a00009          MOV      r0,r9
001028  e59d104c          LDR      r1,[sp,#0x4c]
00102c  ebfffffe          BL       scan_read_raw
;;;643    			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
001030  e1a03004          MOV      r3,r4
001034  e5992014          LDR      r2,[r9,#0x14]
001038  e59d004c          LDR      r0,[sp,#0x4c]
00103c  e59d1014          LDR      r1,[sp,#0x14]
001040  ebfffffe          BL       check_pattern
001044  e3500000          CMP      r0,#0
001048  1a00000f          BNE      |L1.4236|
;;;644    				td->pages[i] = actblock << blocktopage;
00104c  e1cd00d8          LDRD     r0,r1,[sp,#8]
001050  e1a00110          LSL      r0,r0,r1
001054  e2841004          ADD      r1,r4,#4
001058  e7810105          STR      r0,[r1,r5,LSL #2]
;;;645    				if (td->options & NAND_BBT_VERSION) {
00105c  e1d400b0          LDRH     r0,[r4,#0]
001060  e3100c01          TST      r0,#0x100
001064  0a000007          BEQ      |L1.4232|
;;;646    					offs = bbt_get_ver_offs(mtd, td);
001068  e1a01004          MOV      r1,r4
00106c  e1a00009          MOV      r0,r9
001070  ebfffffe          BL       bbt_get_ver_offs
001074  e1a07000          MOV      r7,r0
;;;647    					td->version[i] = buf[offs];
001078  e59d104c          LDR      r1,[sp,#0x4c]
00107c  e7d10007          LDRB     r0,[r1,r7]
001080  e2841010          ADD      r1,r4,#0x10
001084  e7c10005          STRB     r0,[r1,r5]
                  |L1.4232|
;;;648    				}
;;;649    				break;
001088  ea000006          B        |L1.4264|
                  |L1.4236|
00108c  e59d001c          LDR      r0,[sp,#0x1c]         ;636
001090  e2800001          ADD      r0,r0,#1              ;636
001094  e58d001c          STR      r0,[sp,#0x1c]         ;636
                  |L1.4248|
001098  e5941018          LDR      r1,[r4,#0x18]         ;636
00109c  e59d001c          LDR      r0,[sp,#0x1c]         ;636
0010a0  e1510000          CMP      r1,r0                 ;636
0010a4  caffffce          BGT      |L1.4068|
                  |L1.4264|
0010a8  e1a00000          MOV      r0,r0
;;;650    			}
;;;651    		}
;;;652    		startblock += this->chipsize >> this->bbt_erase_shift;
0010ac  e596006c          LDR      r0,[r6,#0x6c]
0010b0  e5961068          LDR      r1,[r6,#0x68]
0010b4  e596205c          LDR      r2,[r6,#0x5c]
0010b8  e1cd04f0          STRD     r0,r1,[sp,#0x40]
0010bc  e1a00001          MOV      r0,r1
0010c0  e59d1040          LDR      r1,[sp,#0x40]
0010c4  ebfffffe          BL       __aeabi_llsr
0010c8  e09aa000          ADDS     r10,r10,r0
0010cc  e2855001          ADD      r5,r5,#1              ;631
                  |L1.4304|
0010d0  e59d0020          LDR      r0,[sp,#0x20]         ;631
0010d4  e1550000          CMP      r5,r0                 ;631
0010d8  baffffb8          BLT      |L1.4032|
;;;653    	}
;;;654    	/* Check, if we found a bbt for each requested chip */
;;;655    	for (i = 0; i < chips; i++) {
0010dc  e3a05000          MOV      r5,#0
0010e0  ea00000e          B        |L1.4384|
                  |L1.4324|
                          DCD      __func__
                  |L1.4328|
0010e8  42554721          DCB      "BUG!! %s\n",0
0010ec  21202573
0010f0  0a00    
0010f2  00                DCB      0
0010f3  00                DCB      0
                  |L1.4340|
;;;656    		if (td->pages[i] == -1)
0010f4  e2840004          ADD      r0,r4,#4
0010f8  e7900105          LDR      r0,[r0,r5,LSL #2]
0010fc  e3700001          CMN      r0,#1
001100  1a000003          BNE      |L1.4372|
;;;657    			sysprintf("Bad block table not found for chip %d\n", i);
001104  e1a01005          MOV      r1,r5
001108  e28f0fb6          ADR      r0,|L1.5096|
00110c  ebfffffe          BL       sysprintf
001110  ea000001          B        |L1.4380|
                  |L1.4372|
;;;658    		else
;;;659    			MTDDEBUG(MTD_DEBUG_LEVEL0, "Bad block table found " \
001114  e1a00000          MOV      r0,r0
001118  e1a00000          MOV      r0,r0
                  |L1.4380|
00111c  e2855001          ADD      r5,r5,#1              ;655
                  |L1.4384|
001120  e59d0020          LDR      r0,[sp,#0x20]         ;655
001124  e1550000          CMP      r5,r0                 ;655
001128  bafffff1          BLT      |L1.4340|
;;;660    				"at page %d, version 0x%02X\n", td->pages[i],
;;;661    				td->version[i]);
;;;662    	}
;;;663    	return 0;
00112c  e3a00000          MOV      r0,#0
001130  e28dd054          ADD      sp,sp,#0x54
;;;664    }
001134  e8bd8ff0          POP      {r4-r11,pc}
;;;665    
                          ENDP

                  search_read_bbts PROC
;;;674    */
;;;675    static int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
001138  e92d41f0          PUSH     {r4-r8,lr}
;;;676    {
00113c  e1a05000          MOV      r5,r0
001140  e1a06001          MOV      r6,r1
001144  e1a07002          MOV      r7,r2
001148  e1a04003          MOV      r4,r3
;;;677    	/* Search the primary table */
;;;678    	search_bbt(mtd, buf, td);
00114c  e1a02007          MOV      r2,r7
001150  e1a01006          MOV      r1,r6
001154  e1a00005          MOV      r0,r5
001158  ebfffffe          BL       search_bbt
;;;679    
;;;680    	/* Search the mirror table */
;;;681    	if (md)
00115c  e3540000          CMP      r4,#0
001160  0a000003          BEQ      |L1.4468|
;;;682    		search_bbt(mtd, buf, md);
001164  e1a02004          MOV      r2,r4
001168  e1a01006          MOV      r1,r6
00116c  e1a00005          MOV      r0,r5
001170  ebfffffe          BL       search_bbt
                  |L1.4468|
;;;683    
;;;684    	/* Force result check */
;;;685    	return 1;
001174  e3a00001          MOV      r0,#1
;;;686    }
001178  e8bd81f0          POP      {r4-r8,pc}
;;;687    
                          ENDP

                  write_bbt PROC
;;;699    */
;;;700    static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
00117c  e92d4fff          PUSH     {r0-r11,lr}
;;;701    		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
;;;702    		     int chipsel)
;;;703    {
001180  e24dd0e4          SUB      sp,sp,#0xe4
001184  e1a06000          MOV      r6,r0
001188  e1a0a001          MOV      r10,r1
00118c  e1a04002          MOV      r4,r2
;;;704    	struct nand_chip *this = mtd->priv;
001190  e5965094          LDR      r5,[r6,#0x94]
;;;705    	struct erase_info einfo;
;;;706    	int i, j, res, chip = 0;
001194  e3a0b000          MOV      r11,#0
;;;707    	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
;;;708    	int nrchips, bbtoffs, pageoffs, ooboffs;
;;;709    	uint8_t msk[4];
;;;710    	uint8_t rcode = td->reserved_block_code;
001198  e5d4001c          LDRB     r0,[r4,#0x1c]
00119c  e58d0034          STR      r0,[sp,#0x34]
;;;711    	size_t retlen, len = 0;
0011a0  e3a09000          MOV      r9,#0
;;;712    	loff_t to;
;;;713    	struct mtd_oob_ops ops;
;;;714    
;;;715    	ops.ooblen = mtd->oobsize;
0011a4  e5960018          LDR      r0,[r6,#0x18]
0011a8  e58d001c          STR      r0,[sp,#0x1c]
;;;716    	ops.ooboffs = 0;
0011ac  e3a00000          MOV      r0,#0
0011b0  e58d0024          STR      r0,[sp,#0x24]
;;;717    	ops.datbuf = NULL;
0011b4  e58d0028          STR      r0,[sp,#0x28]
;;;718    	ops.mode = MTD_OOB_PLACE;
0011b8  e5cd0010          STRB     r0,[sp,#0x10]
;;;719    
;;;720    	if (!rcode)
0011bc  e59d0034          LDR      r0,[sp,#0x34]
0011c0  e3500000          CMP      r0,#0
0011c4  1a000001          BNE      |L1.4560|
;;;721    		rcode = 0xff;
0011c8  e3a000ff          MOV      r0,#0xff
0011cc  e58d0034          STR      r0,[sp,#0x34]
                  |L1.4560|
;;;722    	/* Write bad block table per chip rather than per device ? */
;;;723    	if (td->options & NAND_BBT_PERCHIP) {
0011d0  e5d40000          LDRB     r0,[r4,#0]
0011d4  e3100080          TST      r0,#0x80
0011d8  0a000012          BEQ      |L1.4648|
;;;724    		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
0011dc  e595006c          LDR      r0,[r5,#0x6c]
0011e0  e5951068          LDR      r1,[r5,#0x68]
0011e4  e595205c          LDR      r2,[r5,#0x5c]
0011e8  e1cd0cf0          STRD     r0,r1,[sp,#0xc0]
0011ec  e1a00001          MOV      r0,r1
0011f0  e59d10c0          LDR      r1,[sp,#0xc0]
0011f4  ebfffffe          BL       __aeabi_llsr
0011f8  e58d0054          STR      r0,[sp,#0x54]
;;;725    		/* Full device write or specific chip ? */
;;;726    		if (chipsel == -1) {
0011fc  e59d0118          LDR      r0,[sp,#0x118]
001200  e3700001          CMN      r0,#1
001204  1a000002          BNE      |L1.4628|
;;;727    			nrchips = this->numchips;
001208  e5950064          LDR      r0,[r5,#0x64]
00120c  e58d0048          STR      r0,[sp,#0x48]
001210  ea00000e          B        |L1.4688|
                  |L1.4628|
;;;728    		} else {
;;;729    			nrchips = chipsel + 1;
001214  e59d0118          LDR      r0,[sp,#0x118]
001218  e2800001          ADD      r0,r0,#1
00121c  e58d0048          STR      r0,[sp,#0x48]
;;;730    			chip = chipsel;
001220  e59db118          LDR      r11,[sp,#0x118]
001224  ea000009          B        |L1.4688|
                  |L1.4648|
;;;731    		}
;;;732    	} else {
;;;733    		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
001228  e596000c          LDR      r0,[r6,#0xc]
00122c  e5961008          LDR      r1,[r6,#8]
001230  e595205c          LDR      r2,[r5,#0x5c]
001234  e1cd0cf8          STRD     r0,r1,[sp,#0xc8]
001238  e1a00001          MOV      r0,r1
00123c  e59d10c8          LDR      r1,[sp,#0xc8]
001240  ebfffffe          BL       __aeabi_llsr
001244  e58d0054          STR      r0,[sp,#0x54]
;;;734    		nrchips = 1;
001248  e3a00001          MOV      r0,#1
00124c  e58d0048          STR      r0,[sp,#0x48]
                  |L1.4688|
;;;735    	}
;;;736    
;;;737    	/* Loop through the chips */
;;;738    	for (; chip < nrchips; chip++) {
001250  ea0001b4          B        |L1.6440|
                  |L1.4692|
;;;739    
;;;740    		/* There was already a version of the table, reuse the page
;;;741    		 * This applies for absolute placement too, as we have the
;;;742    		 * page nr. in td->pages.
;;;743    		 */
;;;744    		if (td->pages[chip] != -1) {
001254  e2840004          ADD      r0,r4,#4
001258  e790010b          LDR      r0,[r0,r11,LSL #2]
00125c  e3700001          CMN      r0,#1
001260  0a000003          BEQ      |L1.4724|
;;;745    			page = td->pages[chip];
001264  e2840004          ADD      r0,r4,#4
001268  e790010b          LDR      r0,[r0,r11,LSL #2]
00126c  e58d005c          STR      r0,[sp,#0x5c]
;;;746    			goto write;
001270  ea000040          B        |L1.4984|
                  |L1.4724|
;;;747    		}
;;;748    
;;;749    		/* Automatic placement of the bad block table */
;;;750    		/* Search direction top -> down ? */
;;;751    		if (td->options & NAND_BBT_LASTBLOCK) {
001274  e5d40000          LDRB     r0,[r4,#0]
001278  e3100010          TST      r0,#0x10
00127c  0a000007          BEQ      |L1.4768|
;;;752    			startblock = numblocks * (chip + 1) - 1;
001280  e28b1001          ADD      r1,r11,#1
001284  e59d0054          LDR      r0,[sp,#0x54]
001288  e0000091          MUL      r0,r1,r0
00128c  e2400001          SUB      r0,r0,#1
001290  e58d0064          STR      r0,[sp,#0x64]
;;;753    			dir = -1;
001294  e3e00000          MVN      r0,#0
001298  e58d0060          STR      r0,[sp,#0x60]
00129c  ea000004          B        |L1.4788|
                  |L1.4768|
;;;754    		} else {
;;;755    			startblock = chip * numblocks;
0012a0  e59d0054          LDR      r0,[sp,#0x54]
0012a4  e000009b          MUL      r0,r11,r0
0012a8  e58d0064          STR      r0,[sp,#0x64]
;;;756    			dir = 1;
0012ac  e3a00001          MOV      r0,#1
0012b0  e58d0060          STR      r0,[sp,#0x60]
                  |L1.4788|
;;;757    		}
;;;758    
;;;759    		for (i = 0; i < td->maxblocks; i++) {
0012b4  e3a00000          MOV      r0,#0
0012b8  e58d0074          STR      r0,[sp,#0x74]
0012bc  ea000024          B        |L1.4948|
                  |L1.4800|
;;;760    			int block = startblock + dir * i;
0012c0  e59d1064          LDR      r1,[sp,#0x64]
0012c4  e59d2060          LDR      r2,[sp,#0x60]
0012c8  e59d3074          LDR      r3,[sp,#0x74]
0012cc  e0201392          MLA      r0,r2,r3,r1
;;;761    			/* Check, if the block is bad */
;;;762    			switch ((this->bbt[block >> 2] >>
0012d0  e5951110          LDR      r1,[r5,#0x110]
0012d4  e7d11140          LDRB     r1,[r1,r0,ASR #2]
0012d8  e1a02f00          LSL      r2,r0,#30
0012dc  e1a02ea2          LSR      r2,r2,#29
0012e0  e1a01251          ASR      r1,r1,r2
0012e4  e2011003          AND      r1,r1,#3
0012e8  e3510001          CMP      r1,#1
0012ec  0a000002          BEQ      |L1.4860|
0012f0  e3510003          CMP      r1,#3
0012f4  1a000003          BNE      |L1.4872|
0012f8  ea000001          B        |L1.4868|
                  |L1.4860|
;;;763    				 (2 * (block & 0x03))) & 0x03) {
;;;764    			case 0x01:
0012fc  e1a00000          MOV      r0,r0
;;;765    			case 0x03:
001300  e1a00000          MOV      r0,r0
                  |L1.4868|
;;;766    				continue;
001304  ea00000f          B        |L1.4936|
                  |L1.4872|
;;;767    			}
;;;768    			page = block <<
001308  e5d5105c          LDRB     r1,[r5,#0x5c]
00130c  e5d52054          LDRB     r2,[r5,#0x54]
001310  e0411002          SUB      r1,r1,r2
001314  e1a01110          LSL      r1,r0,r1
001318  e58d105c          STR      r1,[sp,#0x5c]
;;;769    				(this->bbt_erase_shift - this->page_shift);
;;;770    			/* Check, if the block is used by the mirror table */
;;;771    			if (!md || md->pages[chip] != page)
00131c  e59d10f0          LDR      r1,[sp,#0xf0]
001320  e3510000          CMP      r1,#0
001324  0a000005          BEQ      |L1.4928|
001328  e59d10f0          LDR      r1,[sp,#0xf0]
00132c  e2811004          ADD      r1,r1,#4
001330  e791210b          LDR      r2,[r1,r11,LSL #2]
001334  e59d105c          LDR      r1,[sp,#0x5c]
001338  e1520001          CMP      r2,r1
00133c  0a000000          BEQ      |L1.4932|
                  |L1.4928|
;;;772    				goto write;
001340  ea00000c          B        |L1.4984|
                  |L1.4932|
001344  e1a00000          MOV      r0,r0                 ;766
                  |L1.4936|
001348  e59d0074          LDR      r0,[sp,#0x74]         ;759
00134c  e2800001          ADD      r0,r0,#1              ;759
001350  e58d0074          STR      r0,[sp,#0x74]         ;759
                  |L1.4948|
001354  e5941018          LDR      r1,[r4,#0x18]         ;759
001358  e59d0074          LDR      r0,[sp,#0x74]         ;759
00135c  e1510000          CMP      r1,r0                 ;759
001360  caffffd6          BGT      |L1.4800|
;;;773    		}
;;;774    		sysprintf("No space left to write bad block table\n");
001364  e28f00a4          ADR      r0,|L1.5136|
001368  ebfffffe          BL       sysprintf
;;;775    		return -ENOSPC;
00136c  e3e0001b          MVN      r0,#0x1b
                  |L1.4976|
001370  e28dd0f4          ADD      sp,sp,#0xf4
;;;776    	write:
;;;777    
;;;778    		/* Set up shift count and masks for the flash table */
;;;779    		bits = td->options & NAND_BBT_NRBITS_MSK;
;;;780    		msk[2] = ~rcode;
;;;781    		switch (bits) {
;;;782    		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
;;;783    			msk[3] = 0x01;
;;;784    			break;
;;;785    		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
;;;786    			msk[3] = 0x03;
;;;787    			break;
;;;788    		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
;;;789    			msk[3] = 0x0f;
;;;790    			break;
;;;791    		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
;;;792    			msk[3] = 0xff;
;;;793    			break;
;;;794    		default: return -EINVAL;
;;;795    		}
;;;796    
;;;797    		bbtoffs = chip * (numblocks >> 2);
;;;798    
;;;799    		to = ((loff_t) page) << this->page_shift;
;;;800    
;;;801    		/* Must we save the block contents ? */
;;;802    		if (td->options & NAND_BBT_SAVECONTENT) {
;;;803    			/* Make it block aligned */
;;;804    			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
;;;805    			len = 1 << this->bbt_erase_shift;
;;;806    			res = mtd->read(mtd, to, len, &retlen, buf);
;;;807    			if (res < 0) {
;;;808    				if (retlen != len) {
;;;809    					sysprintf("nand_bbt: Error "
;;;810    					       "reading block for writing "
;;;811    					       "the bad block table\n");
;;;812    					return res;
;;;813    				}
;;;814    				sysprintf("nand_bbt: ECC error while reading block for writing bad block table\n");
;;;815    			}
;;;816    			/* Read oob data */
;;;817    			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
;;;818    			ops.oobbuf = &buf[len];
;;;819    			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
;;;820    			if (res < 0 || ops.oobretlen != ops.ooblen)
;;;821    				goto outerr;
;;;822    
;;;823    			/* Calc the byte offset in the buffer */
;;;824    			pageoffs = page - (int)(to >> this->page_shift);
;;;825    			offs = pageoffs << this->page_shift;
;;;826    			/* Preset the bbt area with 0xff */
;;;827    			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
;;;828    			ooboffs = len + (pageoffs * mtd->oobsize);
;;;829    
;;;830    		} else if (td->options & NAND_BBT_NO_OOB) {
;;;831    			ooboffs = 0;
;;;832    			offs = td->len;
;;;833    			/* the version byte */
;;;834    			if (td->options & NAND_BBT_VERSION)
;;;835    				offs++;
;;;836    			/* Calc length */
;;;837    			len = (size_t) (numblocks >> sft);
;;;838    			len += offs;
;;;839    			/* Make it page aligned ! */
;;;840    			//len = ALIGN(len, mtd->writesize);
;;;841                if (len < mtd->writesize)
;;;842                    len = mtd->writesize;
;;;843                else
;;;844                    len = 0;
;;;845    			/* Preset the buffer with 0xff */
;;;846    			memset(buf, 0xff, len);
;;;847    			/* Pattern is located at the begin of first page */
;;;848    			memcpy(buf, td->pattern, td->len);
;;;849    		} else {
;;;850    			/* Calc length */
;;;851    			len = (size_t) (numblocks >> sft);
;;;852    			/* Make it page aligned ! */
;;;853    			//len = ALIGN(len, mtd->writesize);
;;;854                if (len < mtd->writesize)
;;;855                    len = mtd->writesize;
;;;856                else
;;;857                    len = 0;
;;;858    			/* Preset the buffer with 0xff */
;;;859    			memset(buf, 0xff, len +
;;;860    			       (len >> this->page_shift)* mtd->oobsize);
;;;861    			offs = 0;
;;;862    			ooboffs = len;
;;;863    			/* Pattern is located in oob area of first page */
;;;864    			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
;;;865    		}
;;;866    
;;;867    		if (td->options & NAND_BBT_VERSION)
;;;868    			buf[ooboffs + td->veroffs] = td->version[chip];
;;;869    
;;;870    		/* walk through the memory table */
;;;871    		for (i = 0; i < numblocks;) {
;;;872    			uint8_t dat;
;;;873    			dat = this->bbt[bbtoffs + (i >> 2)];
;;;874    			for (j = 0; j < 4; j++, i++) {
;;;875    				int sftcnt = (i << (3 - sft)) & sftmsk;
;;;876    				/* Do not store the reserved bbt blocks ! */
;;;877    				buf[offs + (i >> sft)] &=
;;;878    					~(msk[dat & 0x03] << sftcnt);
;;;879    				dat >>= 2;
;;;880    			}
;;;881    		}
;;;882    
;;;883    		memset(&einfo, 0, sizeof(einfo));
;;;884    		einfo.mtd = mtd;
;;;885    		einfo.addr = to;
;;;886    		einfo.len = 1 << this->bbt_erase_shift;
;;;887    		res = nand_erase_nand(mtd, &einfo, 1);
;;;888    		if (res < 0)
;;;889    			goto outerr;
;;;890    
;;;891    		res = scan_write_bbt(mtd, to, len, buf,
;;;892    				td->options & NAND_BBT_NO_OOB ? NULL :
;;;893    				&buf[len]);
;;;894    		if (res < 0)
;;;895    			goto outerr;
;;;896    
;;;897    		sysprintf("Bad block table written to 0x%012llx, version "
;;;898    		       "0x%02X\n", (unsigned long long)to, td->version[chip]);
;;;899    
;;;900    		/* Mark it as used */
;;;901    		td->pages[chip] = page;
;;;902    	}
;;;903    	return 0;
;;;904    
;;;905     outerr:
;;;906    	sysprintf("nand_bbt: Error while writing bad block table %d\n", res);
;;;907    	return res;
;;;908    }
001374  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4984|
001378  e1a00000          MOV      r0,r0                 ;776
00137c  e5d40000          LDRB     r0,[r4,#0]            ;779
001380  e200000f          AND      r0,r0,#0xf            ;779
001384  e58d0068          STR      r0,[sp,#0x68]         ;779
001388  e59d0034          LDR      r0,[sp,#0x34]         ;780
00138c  e1e00000          MVN      r0,r0                 ;780
001390  e5cd003a          STRB     r0,[sp,#0x3a]         ;780
001394  e59d0068          LDR      r0,[sp,#0x68]         ;781
001398  e3500001          CMP      r0,#1                 ;781
00139c  0a000006          BEQ      |L1.5052|
0013a0  e3500002          CMP      r0,#2                 ;781
0013a4  0a000023          BEQ      |L1.5176|
0013a8  e3500004          CMP      r0,#4                 ;781
0013ac  0a00002d          BEQ      |L1.5224|
0013b0  e3500008          CMP      r0,#8                 ;781
0013b4  1a000041          BNE      |L1.5312|
0013b8  ea000036          B        |L1.5272|
                  |L1.5052|
0013bc  e1a00000          MOV      r0,r0                 ;782
0013c0  e3a00003          MOV      r0,#3                 ;782
0013c4  e58d0050          STR      r0,[sp,#0x50]         ;782
0013c8  e3a00007          MOV      r0,#7                 ;782
0013cc  e58d004c          STR      r0,[sp,#0x4c]         ;782
0013d0  e3a00000          MOV      r0,#0                 ;782
0013d4  e5cd0038          STRB     r0,[sp,#0x38]         ;782
0013d8  e3a00001          MOV      r0,#1                 ;782
0013dc  e5cd0039          STRB     r0,[sp,#0x39]         ;782
0013e0  e5cd003b          STRB     r0,[sp,#0x3b]         ;783
0013e4  ea000038          B        |L1.5324|
                  |L1.5096|
0013e8  42616420          DCB      "Bad block table not found for chip %d\n",0
0013ec  626c6f63
0013f0  6b207461
0013f4  626c6520
0013f8  6e6f7420
0013fc  666f756e
001400  6420666f
001404  72206368
001408  69702025
00140c  640a00  
00140f  00                DCB      0
                  |L1.5136|
001410  4e6f2073          DCB      "No space left to write bad block table\n",0
001414  70616365
001418  206c6566
00141c  7420746f
001420  20777269
001424  74652062
001428  61642062
00142c  6c6f636b
001430  20746162
001434  6c650a00
                  |L1.5176|
001438  e1a00000          MOV      r0,r0                 ;785
00143c  e3a00002          MOV      r0,#2                 ;785
001440  e58d0050          STR      r0,[sp,#0x50]         ;785
001444  e3a00006          MOV      r0,#6                 ;785
001448  e58d004c          STR      r0,[sp,#0x4c]         ;785
00144c  e3a00000          MOV      r0,#0                 ;785
001450  e5cd0038          STRB     r0,[sp,#0x38]         ;785
001454  e3a00001          MOV      r0,#1                 ;785
001458  e5cd0039          STRB     r0,[sp,#0x39]         ;785
00145c  e3a00003          MOV      r0,#3                 ;786
001460  e5cd003b          STRB     r0,[sp,#0x3b]         ;786
001464  ea000018          B        |L1.5324|
                  |L1.5224|
001468  e1a00000          MOV      r0,r0                 ;788
00146c  e3a00001          MOV      r0,#1                 ;788
001470  e58d0050          STR      r0,[sp,#0x50]         ;788
001474  e3a00004          MOV      r0,#4                 ;788
001478  e58d004c          STR      r0,[sp,#0x4c]         ;788
00147c  e3a00000          MOV      r0,#0                 ;788
001480  e5cd0038          STRB     r0,[sp,#0x38]         ;788
001484  e3a0000c          MOV      r0,#0xc               ;788
001488  e5cd0039          STRB     r0,[sp,#0x39]         ;788
00148c  e3a0000f          MOV      r0,#0xf               ;789
001490  e5cd003b          STRB     r0,[sp,#0x3b]         ;789
001494  ea00000c          B        |L1.5324|
                  |L1.5272|
001498  e1a00000          MOV      r0,r0                 ;791
00149c  e3a00000          MOV      r0,#0                 ;791
0014a0  e58d0050          STR      r0,[sp,#0x50]         ;791
0014a4  e58d004c          STR      r0,[sp,#0x4c]         ;791
0014a8  e5cd0038          STRB     r0,[sp,#0x38]         ;791
0014ac  e3a0000f          MOV      r0,#0xf               ;791
0014b0  e5cd0039          STRB     r0,[sp,#0x39]         ;791
0014b4  e3a000ff          MOV      r0,#0xff              ;792
0014b8  e5cd003b          STRB     r0,[sp,#0x3b]         ;792
0014bc  ea000002          B        |L1.5324|
                  |L1.5312|
0014c0  e1a00000          MOV      r0,r0                 ;794
0014c4  e3e00015          MVN      r0,#0x15              ;794
0014c8  eaffffa8          B        |L1.4976|
                  |L1.5324|
0014cc  e1a00000          MOV      r0,r0                 ;784
0014d0  e59d0054          LDR      r0,[sp,#0x54]         ;797
0014d4  e1a00140          ASR      r0,r0,#2              ;797
0014d8  e000009b          MUL      r0,r11,r0             ;797
0014dc  e58d0044          STR      r0,[sp,#0x44]         ;797
0014e0  e5952054          LDR      r2,[r5,#0x54]         ;799
0014e4  e59d005c          LDR      r0,[sp,#0x5c]         ;799
0014e8  e1a01fc0          ASR      r1,r0,#31             ;799
0014ec  e58d00d4          STR      r0,[sp,#0xd4]         ;799
0014f0  e58d10d0          STR      r1,[sp,#0xd0]         ;799
0014f4  ebfffffe          BL       __aeabi_llsl
0014f8  e1a07000          MOV      r7,r0                 ;799
0014fc  e1a08001          MOV      r8,r1                 ;799
001500  e1d400b0          LDRH     r0,[r4,#0]            ;802
001504  e3100a02          TST      r0,#0x2000            ;802
001508  0a000051          BEQ      |L1.5716|
00150c  e5d5005c          LDRB     r0,[r5,#0x5c]         ;804
001510  e3a01001          MOV      r1,#1                 ;804
001514  e1a00011          LSL      r0,r1,r0              ;804
001518  e2400001          SUB      r0,r0,#1              ;804
00151c  e1c77000          BIC      r7,r7,r0              ;804
001520  e1c88fc0          BIC      r8,r8,r0,ASR #31      ;804
001524  e5d5005c          LDRB     r0,[r5,#0x5c]         ;805
001528  e1a09011          LSL      r9,r1,r0              ;805
00152c  e28d0030          ADD      r0,sp,#0x30           ;806
001530  e98d0401          STMIB    sp,{r0,r10}           ;806
001534  e58d9000          STR      r9,[sp,#0]            ;806
001538  e1a02007          MOV      r2,r7                 ;806
00153c  e1a03008          MOV      r3,r8                 ;806
001540  e5961040          LDR      r1,[r6,#0x40]         ;806
001544  e1a00006          MOV      r0,r6                 ;806
001548  e12fff31          BLX      r1                    ;806
00154c  e58d006c          STR      r0,[sp,#0x6c]         ;806
001550  e59d006c          LDR      r0,[sp,#0x6c]         ;807
001554  e3500000          CMP      r0,#0                 ;807
001558  aa000008          BGE      |L1.5504|
00155c  e59d0030          LDR      r0,[sp,#0x30]         ;808
001560  e1500009          CMP      r0,r9                 ;808
001564  0a000003          BEQ      |L1.5496|
001568  e28f0fc1          ADR      r0,|L1.6260|
00156c  ebfffffe          BL       sysprintf
001570  e59d006c          LDR      r0,[sp,#0x6c]         ;812
001574  eaffff7d          B        |L1.4976|
                  |L1.5496|
001578  e59f0334          LDR      r0,|L1.6324|
00157c  ebfffffe          BL       sysprintf
                  |L1.5504|
001580  e5d50054          LDRB     r0,[r5,#0x54]         ;817
001584  e1a00039          LSR      r0,r9,r0              ;817
001588  e5961018          LDR      r1,[r6,#0x18]         ;817
00158c  e0000091          MUL      r0,r1,r0              ;817
001590  e58d001c          STR      r0,[sp,#0x1c]         ;817
001594  e08a0009          ADD      r0,r10,r9             ;818
001598  e58d002c          STR      r0,[sp,#0x2c]         ;818
00159c  e28d0010          ADD      r0,sp,#0x10           ;819
0015a0  e58d0000          STR      r0,[sp,#0]            ;819
0015a4  e5960014          LDR      r0,[r6,#0x14]         ;819
0015a8  e0900007          ADDS     r0,r0,r7              ;819
0015ac  e2a82000          ADC      r2,r8,#0              ;819
0015b0  e58d0008          STR      r0,[sp,#8]            ;819
0015b4  e58d200c          STR      r2,[sp,#0xc]          ;819
0015b8  e1a02000          MOV      r2,r0                 ;819
0015bc  e596104c          LDR      r1,[r6,#0x4c]         ;819
0015c0  e1a00006          MOV      r0,r6                 ;819
0015c4  e59d300c          LDR      r3,[sp,#0xc]          ;819
0015c8  e12fff31          BLX      r1                    ;819
0015cc  e58d006c          STR      r0,[sp,#0x6c]         ;819
0015d0  e59d006c          LDR      r0,[sp,#0x6c]         ;820
0015d4  e3500000          CMP      r0,#0                 ;820
0015d8  ba000003          BLT      |L1.5612|
0015dc  e59d0020          LDR      r0,[sp,#0x20]         ;820
0015e0  e59d101c          LDR      r1,[sp,#0x1c]         ;820
0015e4  e1500001          CMP      r0,r1                 ;820
0015e8  0a000000          BEQ      |L1.5616|
                  |L1.5612|
0015ec  ea0000d2          B        |L1.6460|
                  |L1.5616|
0015f0  e5952054          LDR      r2,[r5,#0x54]         ;824
0015f4  e58d70dc          STR      r7,[sp,#0xdc]         ;824
0015f8  e1a00007          MOV      r0,r7                 ;824
0015fc  e58d80d8          STR      r8,[sp,#0xd8]         ;824
001600  e1a01008          MOV      r1,r8                 ;824
001604  ebfffffe          BL       __aeabi_lasr
001608  e59d105c          LDR      r1,[sp,#0x5c]         ;824
00160c  e0410000          SUB      r0,r1,r0              ;824
001610  e58d0040          STR      r0,[sp,#0x40]         ;824
001614  e5d51054          LDRB     r1,[r5,#0x54]         ;825
001618  e59d0040          LDR      r0,[sp,#0x40]         ;825
00161c  e1a00110          LSL      r0,r0,r1              ;825
001620  e58d0058          STR      r0,[sp,#0x58]         ;825
001624  e59d2054          LDR      r2,[sp,#0x54]         ;827
001628  e59d3050          LDR      r3,[sp,#0x50]         ;827
00162c  e1a01352          ASR      r1,r2,r3              ;827
001630  e59d2058          LDR      r2,[sp,#0x58]         ;827
001634  e08a0002          ADD      r0,r10,r2             ;827
001638  e3a020ff          MOV      r2,#0xff              ;827
00163c  ebfffffe          BL       __aeabi_memset
001640  e5961018          LDR      r1,[r6,#0x18]         ;828
001644  e59d0040          LDR      r0,[sp,#0x40]         ;828
001648  e0209091          MLA      r0,r1,r0,r9           ;828
00164c  e58d003c          STR      r0,[sp,#0x3c]         ;828
001650  ea00003a          B        |L1.5952|
                  |L1.5716|
001654  e5940000          LDR      r0,[r4,#0]            ;830
001658  e3100501          TST      r0,#0x400000          ;830
00165c  0a00001d          BEQ      |L1.5848|
001660  e3a00000          MOV      r0,#0                 ;831
001664  e58d003c          STR      r0,[sp,#0x3c]         ;831
001668  e5940014          LDR      r0,[r4,#0x14]         ;832
00166c  e58d0058          STR      r0,[sp,#0x58]         ;832
001670  e1d400b0          LDRH     r0,[r4,#0]            ;834
001674  e3100c01          TST      r0,#0x100             ;834
001678  0a000002          BEQ      |L1.5768|
00167c  e59d0058          LDR      r0,[sp,#0x58]         ;835
001680  e2800001          ADD      r0,r0,#1              ;835
001684  e58d0058          STR      r0,[sp,#0x58]         ;835
                  |L1.5768|
001688  e59d0054          LDR      r0,[sp,#0x54]         ;837
00168c  e59d1050          LDR      r1,[sp,#0x50]         ;837
001690  e1a09150          ASR      r9,r0,r1              ;837
001694  e59d0058          LDR      r0,[sp,#0x58]         ;838
001698  e0899000          ADD      r9,r9,r0              ;838
00169c  e5960014          LDR      r0,[r6,#0x14]         ;841
0016a0  e1500009          CMP      r0,r9                 ;841
0016a4  9a000001          BLS      |L1.5808|
0016a8  e5969014          LDR      r9,[r6,#0x14]         ;842
0016ac  ea000000          B        |L1.5812|
                  |L1.5808|
0016b0  e3a09000          MOV      r9,#0                 ;844
                  |L1.5812|
0016b4  e3a020ff          MOV      r2,#0xff              ;846
0016b8  e1a01009          MOV      r1,r9                 ;846
0016bc  e1a0000a          MOV      r0,r10                ;846
0016c0  ebfffffe          BL       __aeabi_memset
0016c4  e1a0000a          MOV      r0,r10                ;848
0016c8  e5941020          LDR      r1,[r4,#0x20]         ;848
0016cc  e5942014          LDR      r2,[r4,#0x14]         ;848
0016d0  ebfffffe          BL       __aeabi_memcpy
0016d4  ea000019          B        |L1.5952|
                  |L1.5848|
0016d8  e59d0054          LDR      r0,[sp,#0x54]         ;851
0016dc  e59d1050          LDR      r1,[sp,#0x50]         ;851
0016e0  e1a09150          ASR      r9,r0,r1              ;851
0016e4  e5960014          LDR      r0,[r6,#0x14]         ;854
0016e8  e1500009          CMP      r0,r9                 ;854
0016ec  9a000001          BLS      |L1.5880|
0016f0  e5969014          LDR      r9,[r6,#0x14]         ;855
0016f4  ea000000          B        |L1.5884|
                  |L1.5880|
0016f8  e3a09000          MOV      r9,#0                 ;857
                  |L1.5884|
0016fc  e5d50054          LDRB     r0,[r5,#0x54]         ;859
001700  e1a00039          LSR      r0,r9,r0              ;859
001704  e5962018          LDR      r2,[r6,#0x18]         ;859
001708  e0219290          MLA      r1,r0,r2,r9           ;859
00170c  e3a020ff          MOV      r2,#0xff              ;859
001710  e1a0000a          MOV      r0,r10                ;859
001714  ebfffffe          BL       __aeabi_memset
001718  e3a00000          MOV      r0,#0                 ;861
00171c  e58d0058          STR      r0,[sp,#0x58]         ;861
001720  e58d903c          STR      r9,[sp,#0x3c]         ;862
001724  e5941020          LDR      r1,[r4,#0x20]         ;864
001728  e5942014          LDR      r2,[r4,#0x14]         ;864
00172c  e5943008          LDR      r3,[r4,#8]            ;864
001730  e59d903c          LDR      r9,[sp,#0x3c]         ;864
001734  e0833009          ADD      r3,r3,r9              ;864
001738  e083000a          ADD      r0,r3,r10             ;864
00173c  ebfffffe          BL       __aeabi_memcpy
                  |L1.5952|
001740  e1d400b0          LDRH     r0,[r4,#0]            ;867
001744  e3100c01          TST      r0,#0x100             ;867
001748  0a000005          BEQ      |L1.5988|
00174c  e2840010          ADD      r0,r4,#0x10           ;868
001750  e7d0100b          LDRB     r1,[r0,r11]           ;868
001754  e594200c          LDR      r2,[r4,#0xc]          ;868
001758  e59d003c          LDR      r0,[sp,#0x3c]         ;868
00175c  e0800002          ADD      r0,r0,r2              ;868
001760  e7ca1000          STRB     r1,[r10,r0]           ;868
                  |L1.5988|
001764  e3a00000          MOV      r0,#0                 ;871
001768  e58d0074          STR      r0,[sp,#0x74]         ;871
00176c  ea000028          B        |L1.6164|
                  |L1.6000|
001770  e5953110          LDR      r3,[r5,#0x110]        ;873
001774  e59d1044          LDR      r1,[sp,#0x44]         ;873
001778  e59d2074          LDR      r2,[sp,#0x74]         ;873
00177c  e0811142          ADD      r1,r1,r2,ASR #2       ;873
001780  e7d30001          LDRB     r0,[r3,r1]            ;873
001784  e3a01000          MOV      r1,#0                 ;874
001788  e58d1070          STR      r1,[sp,#0x70]         ;874
00178c  ea00001c          B        |L1.6148|
                  |L1.6032|
001790  e59d2050          LDR      r2,[sp,#0x50]         ;875
001794  e2623003          RSB      r3,r2,#3              ;875
001798  e59d2074          LDR      r2,[sp,#0x74]         ;875
00179c  e1a03312          LSL      r3,r2,r3              ;875
0017a0  e59d204c          LDR      r2,[sp,#0x4c]         ;875
0017a4  e0031002          AND      r1,r3,r2              ;875
0017a8  e59d2074          LDR      r2,[sp,#0x74]         ;877
0017ac  e59d3050          LDR      r3,[sp,#0x50]         ;877
0017b0  e1a03352          ASR      r3,r2,r3              ;877
0017b4  e59d2058          LDR      r2,[sp,#0x58]         ;877
0017b8  e0822003          ADD      r2,r2,r3              ;877
0017bc  e7da2002          LDRB     r2,[r10,r2]           ;877
0017c0  e2003003          AND      r3,r0,#3              ;877
0017c4  e28dc038          ADD      r12,sp,#0x38          ;877
0017c8  e7dc3003          LDRB     r3,[r12,r3]           ;877
0017cc  e1c2c113          BIC      r12,r2,r3,LSL r1      ;877
0017d0  e59d2050          LDR      r2,[sp,#0x50]         ;877
0017d4  e59d3074          LDR      r3,[sp,#0x74]         ;877
0017d8  e1a03253          ASR      r3,r3,r2              ;877
0017dc  e59d2058          LDR      r2,[sp,#0x58]         ;877
0017e0  e0822003          ADD      r2,r2,r3              ;877
0017e4  e7cac002          STRB     r12,[r10,r2]          ;877
0017e8  e1a00140          ASR      r0,r0,#2              ;879
0017ec  e59d1070          LDR      r1,[sp,#0x70]         ;874
0017f0  e2811001          ADD      r1,r1,#1              ;874
0017f4  e58d1070          STR      r1,[sp,#0x70]         ;874
0017f8  e59d1074          LDR      r1,[sp,#0x74]         ;874
0017fc  e2811001          ADD      r1,r1,#1              ;874
001800  e58d1074          STR      r1,[sp,#0x74]         ;874
                  |L1.6148|
001804  e59d1070          LDR      r1,[sp,#0x70]         ;874
001808  e3510004          CMP      r1,#4                 ;874
00180c  baffffdf          BLT      |L1.6032|
001810  e1a00000          MOV      r0,r0                 ;881
                  |L1.6164|
001814  e59d0074          LDR      r0,[sp,#0x74]         ;871
001818  e59d1054          LDR      r1,[sp,#0x54]         ;871
00181c  e1500001          CMP      r0,r1                 ;871
001820  baffffd2          BLT      |L1.6000|
001824  e3a01048          MOV      r1,#0x48              ;883
001828  e28d0078          ADD      r0,sp,#0x78           ;883
00182c  ebfffffe          BL       __aeabi_memclr4
001830  e58d6078          STR      r6,[sp,#0x78]         ;884
001834  e58d7080          STR      r7,[sp,#0x80]         ;885
001838  e58d8084          STR      r8,[sp,#0x84]         ;885
00183c  e5d5005c          LDRB     r0,[r5,#0x5c]         ;886
001840  e3a01001          MOV      r1,#1                 ;886
001844  e1a00011          LSL      r0,r1,r0              ;886
001848  e1a01fc0          ASR      r1,r0,#31             ;886
00184c  e1cd08f8          STRD     r0,r1,[sp,#0x88]      ;886
001850  e3a02001          MOV      r2,#1                 ;887
001854  e28d1078          ADD      r1,sp,#0x78           ;887
001858  e1a00006          MOV      r0,r6                 ;887
00185c  ebfffffe          BL       nand_erase_nand
001860  e58d006c          STR      r0,[sp,#0x6c]         ;887
001864  e59d006c          LDR      r0,[sp,#0x6c]         ;888
001868  e3500000          CMP      r0,#0                 ;888
00186c  aa000011          BGE      |L1.6328|
001870  ea000031          B        |L1.6460|
                  |L1.6260|
001874  6e616e64          DCB      "nand_bbt: Error reading block for writing the bad block"
001878  5f626274
00187c  3a204572
001880  726f7220
001884  72656164
001888  696e6720
00188c  626c6f63
001890  6b20666f
001894  72207772
001898  6974696e
00189c  67207468
0018a0  65206261
0018a4  6420626c
0018a8  6f636b  
0018ab  20746162          DCB      " table\n",0
0018af  6c650a00
0018b3  00                DCB      0
                  |L1.6324|
                          DCD      ||.constdata||+0x1c
                  |L1.6328|
0018b8  e5940000          LDR      r0,[r4,#0]            ;891
0018bc  e3100501          TST      r0,#0x400000          ;891
0018c0  0a000001          BEQ      |L1.6348|
0018c4  e3a00000          MOV      r0,#0                 ;892
0018c8  ea000000          B        |L1.6352|
                  |L1.6348|
0018cc  e08a0009          ADD      r0,r10,r9             ;893
                  |L1.6352|
0018d0  e1a02007          MOV      r2,r7                 ;893
0018d4  e1a03008          MOV      r3,r8                 ;893
0018d8  e58d0008          STR      r0,[sp,#8]            ;893
0018dc  e1a00006          MOV      r0,r6                 ;893
0018e0  e88d0600          STM      sp,{r9,r10}           ;893
0018e4  ebfffffe          BL       scan_write_bbt
0018e8  e58d006c          STR      r0,[sp,#0x6c]         ;893
0018ec  e59d006c          LDR      r0,[sp,#0x6c]         ;894
0018f0  e3500000          CMP      r0,#0                 ;894
0018f4  aa000000          BGE      |L1.6396|
0018f8  ea00000f          B        |L1.6460|
                  |L1.6396|
0018fc  e2840010          ADD      r0,r4,#0x10           ;897
001900  e7d0000b          LDRB     r0,[r0,r11]           ;897
001904  e1a02007          MOV      r2,r7                 ;897
001908  e1a03008          MOV      r3,r8                 ;897
00190c  e58d0000          STR      r0,[sp,#0]            ;897
001910  e28f0fbe          ADR      r0,|L1.7184|
001914  ebfffffe          BL       sysprintf
001918  e2841004          ADD      r1,r4,#4              ;901
00191c  e59d005c          LDR      r0,[sp,#0x5c]         ;901
001920  e781010b          STR      r0,[r1,r11,LSL #2]    ;901
001924  e28bb001          ADD      r11,r11,#1            ;738
                  |L1.6440|
001928  e59d0048          LDR      r0,[sp,#0x48]         ;738
00192c  e15b0000          CMP      r11,r0                ;738
001930  bafffe47          BLT      |L1.4692|
001934  e3a00000          MOV      r0,#0                 ;903
001938  eafffe8c          B        |L1.4976|
                  |L1.6460|
00193c  e1a00000          MOV      r0,r0                 ;905
001940  e28f0c03          ADR      r0,|L1.7240|
001944  e59d106c          LDR      r1,[sp,#0x6c]         ;906
001948  ebfffffe          BL       sysprintf
00194c  e59d006c          LDR      r0,[sp,#0x6c]         ;907
001950  eafffe86          B        |L1.4976|
;;;909    
                          ENDP

                  check_create PROC
;;;937    */
;;;938    static int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
001954  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;939    {
001958  e24dd010          SUB      sp,sp,#0x10
;;;940    	int i, chips, writeops, chipsel, res;
;;;941    	struct nand_chip *this = mtd->priv;
00195c  e59d0010          LDR      r0,[sp,#0x10]
001960  e5908094          LDR      r8,[r0,#0x94]
;;;942    	struct nand_bbt_descr *td = this->bbt_td;
001964  e5985114          LDR      r5,[r8,#0x114]
;;;943    	struct nand_bbt_descr *md = this->bbt_md;
001968  e5986118          LDR      r6,[r8,#0x118]
;;;944    	struct nand_bbt_descr *rd, *rd2;
;;;945    
;;;946    	/* Do we have a bbt per chip ? */
;;;947    	if (td->options & NAND_BBT_PERCHIP)
00196c  e5d50000          LDRB     r0,[r5,#0]
001970  e3100080          TST      r0,#0x80
001974  0a000001          BEQ      |L1.6528|
;;;948    		chips = this->numchips;
001978  e5989064          LDR      r9,[r8,#0x64]
00197c  ea000000          B        |L1.6532|
                  |L1.6528|
;;;949    	else
;;;950    		chips = 1;
001980  e3a09001          MOV      r9,#1
                  |L1.6532|
;;;951    
;;;952    	for (i = 0; i < chips; i++) {
001984  e3a04000          MOV      r4,#0
001988  ea0000bd          B        |L1.7300|
                  |L1.6540|
;;;953    		writeops = 0;
00198c  e3a00000          MOV      r0,#0
001990  e58d000c          STR      r0,[sp,#0xc]
;;;954    		rd = NULL;
001994  e3a07000          MOV      r7,#0
;;;955    		rd2 = NULL;
001998  e58d0008          STR      r0,[sp,#8]
;;;956    		/* Per chip or per device ? */
;;;957    		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
00199c  e5d50000          LDRB     r0,[r5,#0]
0019a0  e3100080          TST      r0,#0x80
0019a4  0a000001          BEQ      |L1.6576|
0019a8  e1a00004          MOV      r0,r4
0019ac  ea000000          B        |L1.6580|
                  |L1.6576|
0019b0  e3e00000          MVN      r0,#0
                  |L1.6580|
0019b4  e1a0a000          MOV      r10,r0
;;;958    		/* Mirrored table available ? */
;;;959    		if (md) {
0019b8  e3560000          CMP      r6,#0
0019bc  0a000046          BEQ      |L1.6876|
;;;960    			if (td->pages[i] == -1 && md->pages[i] == -1) {
0019c0  e2850004          ADD      r0,r5,#4
0019c4  e7900104          LDR      r0,[r0,r4,LSL #2]
0019c8  e3700001          CMN      r0,#1
0019cc  1a000006          BNE      |L1.6636|
0019d0  e2860004          ADD      r0,r6,#4
0019d4  e7900104          LDR      r0,[r0,r4,LSL #2]
0019d8  e3700001          CMN      r0,#1
0019dc  1a000002          BNE      |L1.6636|
;;;961    				writeops = 0x03;
0019e0  e3a00003          MOV      r0,#3
0019e4  e58d000c          STR      r0,[sp,#0xc]
;;;962    				goto create;
0019e8  ea000044          B        |L1.6912|
                  |L1.6636|
;;;963    			}
;;;964    
;;;965    			if (td->pages[i] == -1) {
0019ec  e2850004          ADD      r0,r5,#4
0019f0  e7900104          LDR      r0,[r0,r4,LSL #2]
0019f4  e3700001          CMN      r0,#1
0019f8  1a000007          BNE      |L1.6684|
;;;966    				rd = md;
0019fc  e1a07006          MOV      r7,r6
;;;967    				td->version[i] = md->version[i];
001a00  e2860010          ADD      r0,r6,#0x10
001a04  e7d00004          LDRB     r0,[r0,r4]
001a08  e2851010          ADD      r1,r5,#0x10
001a0c  e7c10004          STRB     r0,[r1,r4]
;;;968    				writeops = 1;
001a10  e3a00001          MOV      r0,#1
001a14  e58d000c          STR      r0,[sp,#0xc]
;;;969    				goto writecheck;
001a18  ea00004c          B        |L1.6992|
                  |L1.6684|
;;;970    			}
;;;971    
;;;972    			if (md->pages[i] == -1) {
001a1c  e2860004          ADD      r0,r6,#4
001a20  e7900104          LDR      r0,[r0,r4,LSL #2]
001a24  e3700001          CMN      r0,#1
001a28  1a000007          BNE      |L1.6732|
;;;973    				rd = td;
001a2c  e1a07005          MOV      r7,r5
;;;974    				md->version[i] = td->version[i];
001a30  e2850010          ADD      r0,r5,#0x10
001a34  e7d00004          LDRB     r0,[r0,r4]
001a38  e2861010          ADD      r1,r6,#0x10
001a3c  e7c10004          STRB     r0,[r1,r4]
;;;975    				writeops = 2;
001a40  e3a00002          MOV      r0,#2
001a44  e58d000c          STR      r0,[sp,#0xc]
;;;976    				goto writecheck;
001a48  ea000040          B        |L1.6992|
                  |L1.6732|
;;;977    			}
;;;978    
;;;979    			if (td->version[i] == md->version[i]) {
001a4c  e2850010          ADD      r0,r5,#0x10
001a50  e7d00004          LDRB     r0,[r0,r4]
001a54  e2861010          ADD      r1,r6,#0x10
001a58  e7d11004          LDRB     r1,[r1,r4]
001a5c  e1500001          CMP      r0,r1
001a60  1a000005          BNE      |L1.6780|
;;;980    				rd = td;
001a64  e1a07005          MOV      r7,r5
;;;981    				if (!(td->options & NAND_BBT_VERSION))
001a68  e1d500b0          LDRH     r0,[r5,#0]
001a6c  e3100c01          TST      r0,#0x100
001a70  1a000000          BNE      |L1.6776|
;;;982    					rd2 = md;
001a74  e58d6008          STR      r6,[sp,#8]
                  |L1.6776|
;;;983    				goto writecheck;
001a78  ea000034          B        |L1.6992|
                  |L1.6780|
;;;984    			}
;;;985    
;;;986    			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
001a7c  e2850010          ADD      r0,r5,#0x10
001a80  e7d00004          LDRB     r0,[r0,r4]
001a84  e2861010          ADD      r1,r6,#0x10
001a88  e7d11004          LDRB     r1,[r1,r4]
001a8c  e0400001          SUB      r0,r0,r1
001a90  e1a00c00          LSL      r0,r0,#24
001a94  e3500000          CMP      r0,#0
001a98  da000007          BLE      |L1.6844|
;;;987    				rd = td;
001a9c  e1a07005          MOV      r7,r5
;;;988    				md->version[i] = td->version[i];
001aa0  e2850010          ADD      r0,r5,#0x10
001aa4  e7d00004          LDRB     r0,[r0,r4]
001aa8  e2861010          ADD      r1,r6,#0x10
001aac  e7c10004          STRB     r0,[r1,r4]
;;;989    				writeops = 2;
001ab0  e3a00002          MOV      r0,#2
001ab4  e58d000c          STR      r0,[sp,#0xc]
001ab8  ea000006          B        |L1.6872|
                  |L1.6844|
;;;990    			} else {
;;;991    				rd = md;
001abc  e1a07006          MOV      r7,r6
;;;992    				td->version[i] = md->version[i];
001ac0  e2860010          ADD      r0,r6,#0x10
001ac4  e7d00004          LDRB     r0,[r0,r4]
001ac8  e2851010          ADD      r1,r5,#0x10
001acc  e7c10004          STRB     r0,[r1,r4]
;;;993    				writeops = 1;
001ad0  e3a00001          MOV      r0,#1
001ad4  e58d000c          STR      r0,[sp,#0xc]
                  |L1.6872|
;;;994    			}
;;;995    
;;;996    			goto writecheck;
001ad8  ea00001c          B        |L1.6992|
                  |L1.6876|
;;;997    
;;;998    		} else {
;;;999    			if (td->pages[i] == -1) {
001adc  e2850004          ADD      r0,r5,#4
001ae0  e7900104          LDR      r0,[r0,r4,LSL #2]
001ae4  e3700001          CMN      r0,#1
001ae8  1a000002          BNE      |L1.6904|
;;;1000   				writeops = 0x01;
001aec  e3a00001          MOV      r0,#1
001af0  e58d000c          STR      r0,[sp,#0xc]
;;;1001   				goto create;
001af4  ea000001          B        |L1.6912|
                  |L1.6904|
;;;1002   			}
;;;1003   			rd = td;
001af8  e1a07005          MOV      r7,r5
;;;1004   			goto writecheck;
001afc  ea000013          B        |L1.6992|
                  |L1.6912|
;;;1005   		}
;;;1006   	create:
001b00  e1a00000          MOV      r0,r0
;;;1007   		/* Create the bad block table by scanning the device ? */
;;;1008   		if (!(td->options & NAND_BBT_CREATE))
001b04  e1d500b0          LDRH     r0,[r5,#0]
001b08  e3100c02          TST      r0,#0x200
001b0c  1a000000          BNE      |L1.6932|
;;;1009   			continue;
001b10  ea00005a          B        |L1.7296|
                  |L1.6932|
;;;1010   
;;;1011   		/* Create the table in memory by scanning the chip(s) */
;;;1012   		if (!(this->options & NAND_CREATE_EMPTY_BBT))
001b14  e5980050          LDR      r0,[r8,#0x50]
001b18  e3100401          TST      r0,#0x1000000
001b1c  1a000003          BNE      |L1.6960|
;;;1013   			create_bbt(mtd, buf, bd, chipsel);
001b20  e1a0300a          MOV      r3,r10
001b24  e28d2010          ADD      r2,sp,#0x10
001b28  e8920007          LDM      r2,{r0-r2}
001b2c  ebfffffe          BL       create_bbt
                  |L1.6960|
;;;1014   
;;;1015   		td->version[i] = 1;
001b30  e3a00001          MOV      r0,#1
001b34  e2851010          ADD      r1,r5,#0x10
001b38  e7c10004          STRB     r0,[r1,r4]
;;;1016   		if (md)
001b3c  e3560000          CMP      r6,#0
001b40  0a000001          BEQ      |L1.6988|
;;;1017   			md->version[i] = 1;
001b44  e2861010          ADD      r1,r6,#0x10
001b48  e7c10004          STRB     r0,[r1,r4]
                  |L1.6988|
;;;1018   	writecheck:
001b4c  e1a00000          MOV      r0,r0
                  |L1.6992|
;;;1019   		/* read back first ? */
;;;1020   		if (rd)
001b50  e3570000          CMP      r7,#0
001b54  0a000003          BEQ      |L1.7016|
;;;1021   			read_abs_bbt(mtd, buf, rd, chipsel);
001b58  e1a0300a          MOV      r3,r10
001b5c  e1a02007          MOV      r2,r7
001b60  e1cd01d0          LDRD     r0,r1,[sp,#0x10]
001b64  ebfffffe          BL       read_abs_bbt
                  |L1.7016|
;;;1022   		/* If they weren't versioned, read both. */
;;;1023   		if (rd2)
001b68  e59d0008          LDR      r0,[sp,#8]
001b6c  e3500000          CMP      r0,#0
001b70  0a000003          BEQ      |L1.7044|
;;;1024   			read_abs_bbt(mtd, buf, rd2, chipsel);
001b74  e1a0300a          MOV      r3,r10
001b78  e1cd01d0          LDRD     r0,r1,[sp,#0x10]
001b7c  e59d2008          LDR      r2,[sp,#8]
001b80  ebfffffe          BL       read_abs_bbt
                  |L1.7044|
;;;1025   
;;;1026   		/* Write the bad block table to the device ? */
;;;1027   		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
001b84  e59d000c          LDR      r0,[sp,#0xc]
001b88  e3100001          TST      r0,#1
001b8c  0a00000d          BEQ      |L1.7112|
001b90  e1d500b0          LDRH     r0,[r5,#0]
001b94  e3100a01          TST      r0,#0x1000
001b98  0a00000a          BEQ      |L1.7112|
;;;1028   			res = write_bbt(mtd, buf, td, md, chipsel);
001b9c  e1a03006          MOV      r3,r6
001ba0  e1a02005          MOV      r2,r5
001ba4  e58da000          STR      r10,[sp,#0]
001ba8  e1cd01d0          LDRD     r0,r1,[sp,#0x10]
001bac  ebfffffe          BL       write_bbt
001bb0  e1a0b000          MOV      r11,r0
;;;1029   			if (res < 0)
001bb4  e35b0000          CMP      r11,#0
001bb8  aa000002          BGE      |L1.7112|
;;;1030   				return res;
001bbc  e1a0000b          MOV      r0,r11
                  |L1.7104|
001bc0  e28dd01c          ADD      sp,sp,#0x1c
;;;1031   		}
;;;1032   
;;;1033   		/* Write the mirror bad block table to the device ? */
;;;1034   		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
;;;1035   			res = write_bbt(mtd, buf, md, td, chipsel);
;;;1036   			if (res < 0)
;;;1037   				return res;
;;;1038   		}
;;;1039   	}
;;;1040   	return 0;
;;;1041   }
001bc4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.7112|
001bc8  e59d000c          LDR      r0,[sp,#0xc]          ;1034
001bcc  e3100002          TST      r0,#2                 ;1034
001bd0  0a000029          BEQ      |L1.7292|
001bd4  e3560000          CMP      r6,#0                 ;1034
001bd8  0a000027          BEQ      |L1.7292|
001bdc  e1d600b0          LDRH     r0,[r6,#0]            ;1034
001be0  e3100a01          TST      r0,#0x1000            ;1034
001be4  0a000024          BEQ      |L1.7292|
001be8  e1a03005          MOV      r3,r5                 ;1035
001bec  e1a02006          MOV      r2,r6                 ;1035
001bf0  e58da000          STR      r10,[sp,#0]           ;1035
001bf4  e1cd01d0          LDRD     r0,r1,[sp,#0x10]      ;1035
001bf8  ebfffffe          BL       write_bbt
001bfc  e1a0b000          MOV      r11,r0                ;1035
001c00  e35b0000          CMP      r11,#0                ;1036
001c04  aa00001c          BGE      |L1.7292|
001c08  e1a0000b          MOV      r0,r11                ;1037
001c0c  eaffffeb          B        |L1.7104|
                  |L1.7184|
001c10  42616420          DCB      "Bad block table written to 0x%012llx, version 0x%02X\n",0
001c14  626c6f63
001c18  6b207461
001c1c  626c6520
001c20  77726974
001c24  74656e20
001c28  746f2030
001c2c  78253031
001c30  326c6c78
001c34  2c207665
001c38  7273696f
001c3c  6e203078
001c40  25303258
001c44  0a00    
001c46  00                DCB      0
001c47  00                DCB      0
                  |L1.7240|
001c48  6e616e64          DCB      "nand_bbt: Error while writing bad block table %d\n",0
001c4c  5f626274
001c50  3a204572
001c54  726f7220
001c58  7768696c
001c5c  65207772
001c60  6974696e
001c64  67206261
001c68  6420626c
001c6c  6f636b20
001c70  7461626c
001c74  65202564
001c78  0a00    
001c7a  00                DCB      0
001c7b  00                DCB      0
                  |L1.7292|
001c7c  e1a00000          MOV      r0,r0                 ;1009
                  |L1.7296|
001c80  e2844001          ADD      r4,r4,#1              ;952
                  |L1.7300|
001c84  e1540009          CMP      r4,r9                 ;952
001c88  baffff3f          BLT      |L1.6540|
001c8c  e3a00000          MOV      r0,#0                 ;1040
001c90  eaffffca          B        |L1.7104|
;;;1042   
                          ENDP

                  nand_update_bbt PROC
;;;1234   */
;;;1235   int nand_update_bbt(struct mtd_info *mtd, loff_t offs)
001c94  e92d5fff          PUSH     {r0-r12,lr}
;;;1236   {
001c98  e24dd018          SUB      sp,sp,#0x18
001c9c  e1a0b000          MOV      r11,r0
;;;1237   	struct nand_chip *this = mtd->priv;
001ca0  e59b7094          LDR      r7,[r11,#0x94]
;;;1238   	int len, res = 0, writeops = 0;
001ca4  e3a00000          MOV      r0,#0
001ca8  e58d000c          STR      r0,[sp,#0xc]
001cac  e58d0008          STR      r0,[sp,#8]
;;;1239   	int chip, chipsel;
;;;1240   	uint8_t *buf;
;;;1241   	struct nand_bbt_descr *td = this->bbt_td;
001cb0  e5976114          LDR      r6,[r7,#0x114]
;;;1242   	struct nand_bbt_descr *md = this->bbt_md;
001cb4  e5975118          LDR      r5,[r7,#0x118]
;;;1243   
;;;1244   	if (!this->bbt || !td)
001cb8  e5970110          LDR      r0,[r7,#0x110]
001cbc  e3500000          CMP      r0,#0
001cc0  0a000001          BEQ      |L1.7372|
001cc4  e3560000          CMP      r6,#0
001cc8  1a000002          BNE      |L1.7384|
                  |L1.7372|
;;;1245   		return -EINVAL;
001ccc  e3e00015          MVN      r0,#0x15
                  |L1.7376|
001cd0  e28dd028          ADD      sp,sp,#0x28
;;;1246   
;;;1247   	/* Allocate a temporary buffer for one eraseblock incl. oob */
;;;1248   	len = (1 << this->bbt_erase_shift);
;;;1249   	len += (len >> this->page_shift) * mtd->oobsize;
;;;1250   	buf = yaffs_malloc(len);
;;;1251   	if (!buf) {
;;;1252   		sysprintf("nand_update_bbt: Out of memory\n");
;;;1253   		return -ENOMEM;
;;;1254   	}
;;;1255   	memset((void*)buf,0,len);
;;;1256   
;;;1257   	writeops = md != NULL ? 0x03 : 0x01;
;;;1258   
;;;1259   	/* Do we have a bbt per chip ? */
;;;1260   	if (td->options & NAND_BBT_PERCHIP) {
;;;1261   		chip = (int)(offs >> this->chip_shift);
;;;1262   		chipsel = chip;
;;;1263   	} else {
;;;1264   		chip = 0;
;;;1265   		chipsel = -1;
;;;1266   	}
;;;1267   
;;;1268   	td->version[chip]++;
;;;1269   	if (md)
;;;1270   		md->version[chip]++;
;;;1271   
;;;1272   	/* Write the bad block table to the device ? */
;;;1273   	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
;;;1274   		res = write_bbt(mtd, buf, td, md, chipsel);
;;;1275   		if (res < 0)
;;;1276   			goto out;
;;;1277   	}
;;;1278   	/* Write the mirror bad block table to the device ? */
;;;1279   	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
;;;1280   		res = write_bbt(mtd, buf, md, td, chipsel);
;;;1281   	}
;;;1282   
;;;1283    out:
;;;1284   	yaffs_free(buf);
;;;1285   	return res;
;;;1286   }
001cd4  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.7384|
001cd8  e5d7005c          LDRB     r0,[r7,#0x5c]         ;1248
001cdc  e3a01001          MOV      r1,#1                 ;1248
001ce0  e1a09011          LSL      r9,r1,r0              ;1248
001ce4  e5d70054          LDRB     r0,[r7,#0x54]         ;1249
001ce8  e1a00059          ASR      r0,r9,r0              ;1249
001cec  e59b1018          LDR      r1,[r11,#0x18]        ;1249
001cf0  e0299190          MLA      r9,r0,r1,r9           ;1249
001cf4  e1a00009          MOV      r0,r9                 ;1250
001cf8  ebfffffe          BL       yaffs_malloc
001cfc  e1a0a000          MOV      r10,r0                ;1250
001d00  e35a0000          CMP      r10,#0                ;1251
001d04  1a000003          BNE      |L1.7448|
001d08  e28f0e35          ADR      r0,|L1.8288|
001d0c  ebfffffe          BL       sysprintf
001d10  e3e0000b          MVN      r0,#0xb               ;1253
001d14  eaffffed          B        |L1.7376|
                  |L1.7448|
001d18  e1a01009          MOV      r1,r9                 ;1255
001d1c  e1a0000a          MOV      r0,r10                ;1255
001d20  ebfffffe          BL       __aeabi_memclr
001d24  e3550000          CMP      r5,#0                 ;1257
001d28  0a000001          BEQ      |L1.7476|
001d2c  e3a00003          MOV      r0,#3                 ;1257
001d30  ea000000          B        |L1.7480|
                  |L1.7476|
001d34  e3a00001          MOV      r0,#1                 ;1257
                  |L1.7480|
001d38  e58d0008          STR      r0,[sp,#8]            ;1257
001d3c  e5d60000          LDRB     r0,[r6,#0]            ;1260
001d40  e3100080          TST      r0,#0x80              ;1260
001d44  0a000007          BEQ      |L1.7528|
001d48  e5972060          LDR      r2,[r7,#0x60]         ;1261
001d4c  e1cd02d0          LDRD     r0,r1,[sp,#0x20]      ;1261
001d50  e58d0014          STR      r0,[sp,#0x14]         ;1261
001d54  e58d1010          STR      r1,[sp,#0x10]         ;1261
001d58  ebfffffe          BL       __aeabi_lasr
001d5c  e1a04000          MOV      r4,r0                 ;1261
001d60  e1a08004          MOV      r8,r4                 ;1262
001d64  ea000001          B        |L1.7536|
                  |L1.7528|
001d68  e3a04000          MOV      r4,#0                 ;1264
001d6c  e3e08000          MVN      r8,#0                 ;1265
                  |L1.7536|
001d70  e2860010          ADD      r0,r6,#0x10           ;1268
001d74  e7d00004          LDRB     r0,[r0,r4]            ;1268
001d78  e2800001          ADD      r0,r0,#1              ;1268
001d7c  e2861010          ADD      r1,r6,#0x10           ;1268
001d80  e7c10004          STRB     r0,[r1,r4]            ;1268
001d84  e3550000          CMP      r5,#0                 ;1269
001d88  0a000004          BEQ      |L1.7584|
001d8c  e2850010          ADD      r0,r5,#0x10           ;1270
001d90  e7d00004          LDRB     r0,[r0,r4]            ;1270
001d94  e2800001          ADD      r0,r0,#1              ;1270
001d98  e2851010          ADD      r1,r5,#0x10           ;1270
001d9c  e7c10004          STRB     r0,[r1,r4]            ;1270
                  |L1.7584|
001da0  e59d0008          LDR      r0,[sp,#8]            ;1273
001da4  e3100001          TST      r0,#1                 ;1273
001da8  0a00000d          BEQ      |L1.7652|
001dac  e1d600b0          LDRH     r0,[r6,#0]            ;1273
001db0  e3100a01          TST      r0,#0x1000            ;1273
001db4  0a00000a          BEQ      |L1.7652|
001db8  e1a03005          MOV      r3,r5                 ;1274
001dbc  e1a02006          MOV      r2,r6                 ;1274
001dc0  e1a0100a          MOV      r1,r10                ;1274
001dc4  e1a0000b          MOV      r0,r11                ;1274
001dc8  e58d8000          STR      r8,[sp,#0]            ;1274
001dcc  ebfffffe          BL       write_bbt
001dd0  e58d000c          STR      r0,[sp,#0xc]          ;1274
001dd4  e59d000c          LDR      r0,[sp,#0xc]          ;1275
001dd8  e3500000          CMP      r0,#0                 ;1275
001ddc  aa000000          BGE      |L1.7652|
001de0  ea00000f          B        |L1.7716|
                  |L1.7652|
001de4  e59d0008          LDR      r0,[sp,#8]            ;1279
001de8  e3100002          TST      r0,#2                 ;1279
001dec  0a00000b          BEQ      |L1.7712|
001df0  e3550000          CMP      r5,#0                 ;1279
001df4  0a000009          BEQ      |L1.7712|
001df8  e1d500b0          LDRH     r0,[r5,#0]            ;1279
001dfc  e3100a01          TST      r0,#0x1000            ;1279
001e00  0a000006          BEQ      |L1.7712|
001e04  e1a03006          MOV      r3,r6                 ;1280
001e08  e1a02005          MOV      r2,r5                 ;1280
001e0c  e1a0100a          MOV      r1,r10                ;1280
001e10  e1a0000b          MOV      r0,r11                ;1280
001e14  e58d8000          STR      r8,[sp,#0]            ;1280
001e18  ebfffffe          BL       write_bbt
001e1c  e58d000c          STR      r0,[sp,#0xc]          ;1280
                  |L1.7712|
001e20  e1a00000          MOV      r0,r0                 ;1283
                  |L1.7716|
001e24  e1a0000a          MOV      r0,r10                ;1284
001e28  ebfffffe          BL       yaffs_free
001e2c  e59d000c          LDR      r0,[sp,#0xc]          ;1285
001e30  eaffffa6          B        |L1.7376|
;;;1287   
                          ENDP

                  mark_bbt_region PROC
;;;1051   */
;;;1052   static void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
001e34  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;1053   {
001e38  e24dd034          SUB      sp,sp,#0x34
001e3c  e1a06001          MOV      r6,r1
;;;1054   	struct nand_chip *this = mtd->priv;
001e40  e59d0034          LDR      r0,[sp,#0x34]
001e44  e5905094          LDR      r5,[r0,#0x94]
;;;1055   	int i, j, chips, block, nrblocks, update;
;;;1056   	uint8_t oldval, newval;
;;;1057   
;;;1058   	/* Do we have a bbt per chip ? */
;;;1059   	if (td->options & NAND_BBT_PERCHIP) {
001e48  e5d60000          LDRB     r0,[r6,#0]
001e4c  e3100080          TST      r0,#0x80
001e50  0a00000b          BEQ      |L1.7812|
;;;1060   		chips = this->numchips;
001e54  e5950064          LDR      r0,[r5,#0x64]
001e58  e58d000c          STR      r0,[sp,#0xc]
;;;1061   		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
001e5c  e595006c          LDR      r0,[r5,#0x6c]
001e60  e5951068          LDR      r1,[r5,#0x68]
001e64  e595205c          LDR      r2,[r5,#0x5c]
001e68  e58d0014          STR      r0,[sp,#0x14]
001e6c  e58d1018          STR      r1,[sp,#0x18]
001e70  e1a00001          MOV      r0,r1
001e74  e59d1014          LDR      r1,[sp,#0x14]
001e78  ebfffffe          BL       __aeabi_llsr
001e7c  e1a08000          MOV      r8,r0
001e80  ea00000b          B        |L1.7860|
                  |L1.7812|
;;;1062   	} else {
;;;1063   		chips = 1;
001e84  e3a00001          MOV      r0,#1
001e88  e58d000c          STR      r0,[sp,#0xc]
;;;1064   		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
001e8c  e59d0034          LDR      r0,[sp,#0x34]
001e90  e5901008          LDR      r1,[r0,#8]
001e94  e590000c          LDR      r0,[r0,#0xc]
001e98  e595205c          LDR      r2,[r5,#0x5c]
001e9c  e58d001c          STR      r0,[sp,#0x1c]
001ea0  e58d1020          STR      r1,[sp,#0x20]
001ea4  e1a00001          MOV      r0,r1
001ea8  e59d101c          LDR      r1,[sp,#0x1c]
001eac  ebfffffe          BL       __aeabi_llsr
001eb0  e1a08000          MOV      r8,r0
                  |L1.7860|
;;;1065   	}
;;;1066   
;;;1067   	for (i = 0; i < chips; i++) {
001eb4  e3a07000          MOV      r7,#0
001eb8  ea000063          B        |L1.8268|
                  |L1.7868|
;;;1068   		if ((td->options & NAND_BBT_ABSPAGE) ||
001ebc  e5d60000          LDRB     r0,[r6,#0]
001ec0  e3100020          TST      r0,#0x20
001ec4  1a000002          BNE      |L1.7892|
;;;1069   		    !(td->options & NAND_BBT_WRITE)) {
001ec8  e1d600b0          LDRH     r0,[r6,#0]
001ecc  e3100a01          TST      r0,#0x1000
001ed0  1a000026          BNE      |L1.8048|
                  |L1.7892|
;;;1070   			if (td->pages[i] == -1)
001ed4  e2860004          ADD      r0,r6,#4
001ed8  e7900107          LDR      r0,[r0,r7,LSL #2]
001edc  e3700001          CMN      r0,#1
001ee0  1a000000          BNE      |L1.7912|
;;;1071   				continue;
001ee4  ea000057          B        |L1.8264|
                  |L1.7912|
;;;1072   			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
001ee8  e5d5005c          LDRB     r0,[r5,#0x5c]
001eec  e5d51054          LDRB     r1,[r5,#0x54]
001ef0  e0400001          SUB      r0,r0,r1
001ef4  e2861004          ADD      r1,r6,#4
001ef8  e7911107          LDR      r1,[r1,r7,LSL #2]
001efc  e1a04051          ASR      r4,r1,r0
;;;1073   			block <<= 1;
001f00  e1a04084          LSL      r4,r4,#1
;;;1074   			oldval = this->bbt[(block >> 3)];
001f04  e5950110          LDR      r0,[r5,#0x110]
001f08  e7d091c4          LDRB     r9,[r0,r4,ASR #3]
;;;1075   			newval = oldval | (0x2 << (block & 0x06));
001f0c  e2040006          AND      r0,r4,#6
001f10  e3a01002          MOV      r1,#2
001f14  e1890011          ORR      r0,r9,r1,LSL r0
001f18  e200a0ff          AND      r10,r0,#0xff
;;;1076   			this->bbt[(block >> 3)] = newval;
001f1c  e5950110          LDR      r0,[r5,#0x110]
001f20  e7c0a1c4          STRB     r10,[r0,r4,ASR #3]
;;;1077   			if ((oldval != newval) && td->reserved_block_code)
001f24  e159000a          CMP      r9,r10
001f28  0a00000f          BEQ      |L1.8044|
001f2c  e596001c          LDR      r0,[r6,#0x1c]
001f30  e3500000          CMP      r0,#0
001f34  0a00000c          BEQ      |L1.8044|
;;;1078   				nand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));
001f38  e595005c          LDR      r0,[r5,#0x5c]
001f3c  e2402001          SUB      r2,r0,#1
001f40  e1a00fc4          ASR      r0,r4,#31
001f44  e1a0b004          MOV      r11,r4
001f48  e58d0024          STR      r0,[sp,#0x24]
001f4c  e1a0000b          MOV      r0,r11
001f50  e59d1024          LDR      r1,[sp,#0x24]
001f54  ebfffffe          BL       __aeabi_llsl
001f58  e1cd00f0          STRD     r0,r1,[sp,#0]
001f5c  e1a02000          MOV      r2,r0
001f60  e1a03001          MOV      r3,r1
001f64  e59d0034          LDR      r0,[sp,#0x34]
001f68  ebfffffe          BL       nand_update_bbt
                  |L1.8044|
;;;1079   			continue;
001f6c  ea000035          B        |L1.8264|
                  |L1.8048|
;;;1080   		}
;;;1081   		update = 0;
001f70  e3a00000          MOV      r0,#0
001f74  e58d0008          STR      r0,[sp,#8]
;;;1082   		if (td->options & NAND_BBT_LASTBLOCK)
001f78  e5d60000          LDRB     r0,[r6,#0]
001f7c  e3100010          TST      r0,#0x10
001f80  0a000004          BEQ      |L1.8088|
;;;1083   			block = ((i + 1) * nrblocks) - td->maxblocks;
001f84  e2870001          ADD      r0,r7,#1
001f88  e0000098          MUL      r0,r8,r0
001f8c  e5961018          LDR      r1,[r6,#0x18]
001f90  e0404001          SUB      r4,r0,r1
001f94  ea000000          B        |L1.8092|
                  |L1.8088|
;;;1084   		else
;;;1085   			block = i * nrblocks;
001f98  e0040897          MUL      r4,r7,r8
                  |L1.8092|
;;;1086   		block <<= 1;
001f9c  e1a04084          LSL      r4,r4,#1
;;;1087   		for (j = 0; j < td->maxblocks; j++) {
001fa0  e3a00000          MOV      r0,#0
001fa4  e58d0010          STR      r0,[sp,#0x10]
001fa8  ea00000f          B        |L1.8172|
                  |L1.8108|
;;;1088   			oldval = this->bbt[(block >> 3)];
001fac  e5950110          LDR      r0,[r5,#0x110]
001fb0  e7d091c4          LDRB     r9,[r0,r4,ASR #3]
;;;1089   			newval = oldval | (0x2 << (block & 0x06));
001fb4  e2040006          AND      r0,r4,#6
001fb8  e3a01002          MOV      r1,#2
001fbc  e1890011          ORR      r0,r9,r1,LSL r0
001fc0  e200a0ff          AND      r10,r0,#0xff
;;;1090   			this->bbt[(block >> 3)] = newval;
001fc4  e5950110          LDR      r0,[r5,#0x110]
001fc8  e7c0a1c4          STRB     r10,[r0,r4,ASR #3]
;;;1091   			if (oldval != newval)
001fcc  e159000a          CMP      r9,r10
001fd0  0a000001          BEQ      |L1.8156|
;;;1092   				update = 1;
001fd4  e3a00001          MOV      r0,#1
001fd8  e58d0008          STR      r0,[sp,#8]
                  |L1.8156|
;;;1093   			block += 2;
001fdc  e2844002          ADD      r4,r4,#2
001fe0  e59d0010          LDR      r0,[sp,#0x10]         ;1087
001fe4  e2800001          ADD      r0,r0,#1              ;1087
001fe8  e58d0010          STR      r0,[sp,#0x10]         ;1087
                  |L1.8172|
001fec  e5961018          LDR      r1,[r6,#0x18]         ;1087
001ff0  e59d0010          LDR      r0,[sp,#0x10]         ;1087
001ff4  e1510000          CMP      r1,r0                 ;1087
001ff8  caffffeb          BGT      |L1.8108|
;;;1094   		}
;;;1095   		/* If we want reserved blocks to be recorded to flash, and some
;;;1096   		   new ones have been marked, then we need to update the stored
;;;1097   		   bbts.  This should only happen once. */
;;;1098   		if (update && td->reserved_block_code)
001ffc  e59d0008          LDR      r0,[sp,#8]
002000  e3500000          CMP      r0,#0
002004  0a00000e          BEQ      |L1.8260|
002008  e596001c          LDR      r0,[r6,#0x1c]
00200c  e3500000          CMP      r0,#0
002010  0a00000b          BEQ      |L1.8260|
;;;1099   			nand_update_bbt(mtd, (loff_t)(block - 2) << (this->bbt_erase_shift - 1));
002014  e2440002          SUB      r0,r4,#2
002018  e1a01fc0          ASR      r1,r0,#31
00201c  e595205c          LDR      r2,[r5,#0x5c]
002020  e2422001          SUB      r2,r2,#1
002024  e58d002c          STR      r0,[sp,#0x2c]
002028  e58d1028          STR      r1,[sp,#0x28]
00202c  ebfffffe          BL       __aeabi_llsl
002030  e1cd00f0          STRD     r0,r1,[sp,#0]
002034  e1a02000          MOV      r2,r0
002038  e1a03001          MOV      r3,r1
00203c  e59d0034          LDR      r0,[sp,#0x34]
002040  ebfffffe          BL       nand_update_bbt
                  |L1.8260|
002044  e1a00000          MOV      r0,r0                 ;1071
                  |L1.8264|
002048  e2877001          ADD      r7,r7,#1              ;1067
                  |L1.8268|
00204c  e59d000c          LDR      r0,[sp,#0xc]          ;1067
002050  e1570000          CMP      r7,r0                 ;1067
002054  baffff98          BLT      |L1.7868|
;;;1100   	}
;;;1101   }
002058  e28dd03c          ADD      sp,sp,#0x3c
00205c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.8288|
002060  6e616e64          DCB      "nand_update_bbt: Out of memory\n",0
002064  5f757064
002068  6174655f
00206c  6262743a
002070  204f7574
002074  206f6620
002078  6d656d6f
00207c  72790a00
                          ENDP

                  verify_bbt_descr PROC
;;;1110    */
;;;1111   static void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
002080  e92d5ffc          PUSH     {r2-r12,lr}
;;;1112   {
002084  e1a07000          MOV      r7,r0
002088  e1a04001          MOV      r4,r1
;;;1113   	struct nand_chip *this = mtd->priv;
00208c  e5975094          LDR      r5,[r7,#0x94]
;;;1114   	u32 pattern_len;
;;;1115   	u32 bits;
;;;1116   	u32 table_size;
;;;1117   
;;;1118   	if (!bd)
002090  e3540000          CMP      r4,#0
002094  1a000000          BNE      |L1.8348|
                  |L1.8344|
;;;1119   		return;
;;;1120   
;;;1121   	pattern_len = bd->len;
;;;1122   	bits = bd->options & NAND_BBT_NRBITS_MSK;
;;;1123   
;;;1124   	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
;;;1125   			!(this->options & NAND_USE_FLASH_BBT));
;;;1126   	BUG_ON(!bits);
;;;1127   
;;;1128   	if (bd->options & NAND_BBT_VERSION)
;;;1129   		pattern_len++;
;;;1130   
;;;1131   	if (bd->options & NAND_BBT_NO_OOB) {
;;;1132   		BUG_ON(!(this->options & NAND_USE_FLASH_BBT));
;;;1133   		BUG_ON(!(this->options & NAND_USE_FLASH_BBT_NO_OOB));
;;;1134   		BUG_ON(bd->offs);
;;;1135   		if (bd->options & NAND_BBT_VERSION)
;;;1136   			BUG_ON(bd->veroffs != bd->len);
;;;1137   		BUG_ON(bd->options & NAND_BBT_SAVECONTENT);
;;;1138   	}
;;;1139   
;;;1140   	if (bd->options & NAND_BBT_PERCHIP)
;;;1141   		table_size = this->chipsize >> this->bbt_erase_shift;
;;;1142   	else
;;;1143   		table_size = mtd->size >> this->bbt_erase_shift;
;;;1144   	table_size >>= 3;
;;;1145   	table_size *= bits;
;;;1146   	if (bd->options & NAND_BBT_NO_OOB)
;;;1147   		table_size += pattern_len;
;;;1148   	BUG_ON(table_size > (1 << this->bbt_erase_shift));
;;;1149   }
002098  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.8348|
00209c  e5948014          LDR      r8,[r4,#0x14]         ;1121
0020a0  e5d40000          LDRB     r0,[r4,#0]            ;1122
0020a4  e200900f          AND      r9,r0,#0xf            ;1122
0020a8  e5950050          LDR      r0,[r5,#0x50]         ;1124
0020ac  e3100502          TST      r0,#0x800000          ;1124
0020b0  0a000007          BEQ      |L1.8404|
0020b4  e5950050          LDR      r0,[r5,#0x50]         ;1124
0020b8  e3100801          TST      r0,#0x10000           ;1124
0020bc  1a000004          BNE      |L1.8404|
0020c0  e59f140c          LDR      r1,|L1.9428|
0020c4  e59f040c          LDR      r0,|L1.9432|
0020c8  ebfffffe          BL       sysprintf
0020cc  e1a00000          MOV      r0,r0                 ;1124
                  |L1.8400|
0020d0  eafffffe          B        |L1.8400|
                  |L1.8404|
0020d4  e3590000          CMP      r9,#0                 ;1126
0020d8  1a000004          BNE      |L1.8432|
0020dc  e59f13f0          LDR      r1,|L1.9428|
0020e0  e59f03f0          LDR      r0,|L1.9432|
0020e4  ebfffffe          BL       sysprintf
0020e8  e1a00000          MOV      r0,r0                 ;1126
                  |L1.8428|
0020ec  eafffffe          B        |L1.8428|
                  |L1.8432|
0020f0  e1d400b0          LDRH     r0,[r4,#0]            ;1128
0020f4  e3100c01          TST      r0,#0x100             ;1128
0020f8  0a000000          BEQ      |L1.8448|
0020fc  e2888001          ADD      r8,r8,#1              ;1129
                  |L1.8448|
002100  e5940000          LDR      r0,[r4,#0]            ;1131
002104  e3100501          TST      r0,#0x400000          ;1131
002108  0a00002b          BEQ      |L1.8636|
00210c  e5950050          LDR      r0,[r5,#0x50]         ;1132
002110  e3100801          TST      r0,#0x10000           ;1132
002114  1a000004          BNE      |L1.8492|
002118  e59f13b4          LDR      r1,|L1.9428|
00211c  e59f03b4          LDR      r0,|L1.9432|
002120  ebfffffe          BL       sysprintf
002124  e1a00000          MOV      r0,r0                 ;1132
                  |L1.8488|
002128  eafffffe          B        |L1.8488|
                  |L1.8492|
00212c  e5950050          LDR      r0,[r5,#0x50]         ;1133
002130  e3100502          TST      r0,#0x800000          ;1133
002134  1a000004          BNE      |L1.8524|
002138  e59f1394          LDR      r1,|L1.9428|
00213c  e59f0394          LDR      r0,|L1.9432|
002140  ebfffffe          BL       sysprintf
002144  e1a00000          MOV      r0,r0                 ;1133
                  |L1.8520|
002148  eafffffe          B        |L1.8520|
                  |L1.8524|
00214c  e5940008          LDR      r0,[r4,#8]            ;1134
002150  e3500000          CMP      r0,#0                 ;1134
002154  0a000004          BEQ      |L1.8556|
002158  e59f1374          LDR      r1,|L1.9428|
00215c  e59f0374          LDR      r0,|L1.9432|
002160  ebfffffe          BL       sysprintf
002164  e1a00000          MOV      r0,r0                 ;1134
                  |L1.8552|
002168  eafffffe          B        |L1.8552|
                  |L1.8556|
00216c  e1d400b0          LDRH     r0,[r4,#0]            ;1135
002170  e3100c01          TST      r0,#0x100             ;1135
002174  0a000008          BEQ      |L1.8604|
002178  e594000c          LDR      r0,[r4,#0xc]          ;1136
00217c  e5941014          LDR      r1,[r4,#0x14]         ;1136
002180  e1500001          CMP      r0,r1                 ;1136
002184  0a000004          BEQ      |L1.8604|
002188  e59f1344          LDR      r1,|L1.9428|
00218c  e59f0344          LDR      r0,|L1.9432|
002190  ebfffffe          BL       sysprintf
002194  e1a00000          MOV      r0,r0                 ;1136
                  |L1.8600|
002198  eafffffe          B        |L1.8600|
                  |L1.8604|
00219c  e1d400b0          LDRH     r0,[r4,#0]            ;1137
0021a0  e3100a02          TST      r0,#0x2000            ;1137
0021a4  0a000004          BEQ      |L1.8636|
0021a8  e59f1324          LDR      r1,|L1.9428|
0021ac  e59f0324          LDR      r0,|L1.9432|
0021b0  ebfffffe          BL       sysprintf
0021b4  e1a00000          MOV      r0,r0                 ;1137
                  |L1.8632|
0021b8  eafffffe          B        |L1.8632|
                  |L1.8636|
0021bc  e5d40000          LDRB     r0,[r4,#0]            ;1140
0021c0  e3100080          TST      r0,#0x80              ;1140
0021c4  0a000006          BEQ      |L1.8676|
0021c8  e1c5a6d8          LDRD     r10,r11,[r5,#0x68]    ;1141
0021cc  e1a0000a          MOV      r0,r10                ;1141
0021d0  e1a0100b          MOV      r1,r11                ;1141
0021d4  e595205c          LDR      r2,[r5,#0x5c]         ;1141
0021d8  ebfffffe          BL       __aeabi_llsr
0021dc  e1a06000          MOV      r6,r0                 ;1141
0021e0  ea000007          B        |L1.8708|
                  |L1.8676|
0021e4  e597000c          LDR      r0,[r7,#0xc]          ;1143
0021e8  e5971008          LDR      r1,[r7,#8]            ;1143
0021ec  e595205c          LDR      r2,[r5,#0x5c]         ;1143
0021f0  e1cd00f0          STRD     r0,r1,[sp,#0]         ;1143
0021f4  e1a00001          MOV      r0,r1                 ;1143
0021f8  e59d1000          LDR      r1,[sp,#0]            ;1143
0021fc  ebfffffe          BL       __aeabi_llsr
002200  e1a06000          MOV      r6,r0                 ;1143
                  |L1.8708|
002204  e1a061a6          LSR      r6,r6,#3              ;1144
002208  e0060699          MUL      r6,r9,r6              ;1145
00220c  e5940000          LDR      r0,[r4,#0]            ;1146
002210  e3100501          TST      r0,#0x400000          ;1146
002214  0a000000          BEQ      |L1.8732|
002218  e0866008          ADD      r6,r6,r8              ;1147
                  |L1.8732|
00221c  e5d5005c          LDRB     r0,[r5,#0x5c]         ;1148
002220  e3a01001          MOV      r1,#1                 ;1148
002224  e1a00011          LSL      r0,r1,r0              ;1148
002228  e1500006          CMP      r0,r6                 ;1148
00222c  2a000004          BCS      |L1.8772|
002230  e59f129c          LDR      r1,|L1.9428|
002234  e59f029c          LDR      r0,|L1.9432|
002238  ebfffffe          BL       sysprintf
00223c  e1a00000          MOV      r0,r0                 ;1148
                  |L1.8768|
002240  eafffffe          B        |L1.8768|
                  |L1.8772|
002244  e1a00000          MOV      r0,r0
002248  eaffff92          B        |L1.8344|
;;;1150   
                          ENDP

                  nand_scan_bbt PROC
;;;1164   */
;;;1165   int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
00224c  e92d4ffe          PUSH     {r1-r11,lr}
;;;1166   {
002250  e1a05000          MOV      r5,r0
002254  e1a06001          MOV      r6,r1
;;;1167   	struct nand_chip *this = mtd->priv;
002258  e5954094          LDR      r4,[r5,#0x94]
;;;1168   	int len, res = 0;
00225c  e3a00000          MOV      r0,#0
002260  e58d0004          STR      r0,[sp,#4]
;;;1169   	uint8_t *buf;
;;;1170   	struct nand_bbt_descr *td = this->bbt_td;
002264  e5949114          LDR      r9,[r4,#0x114]
;;;1171   	struct nand_bbt_descr *md = this->bbt_md;
002268  e594b118          LDR      r11,[r4,#0x118]
;;;1172   
;;;1173   	len = mtd->size >> (this->bbt_erase_shift + 2);
00226c  e595000c          LDR      r0,[r5,#0xc]
002270  e595a008          LDR      r10,[r5,#8]
002274  e594105c          LDR      r1,[r4,#0x5c]
002278  e2812002          ADD      r2,r1,#2
00227c  e58d0008          STR      r0,[sp,#8]
002280  e1a0000a          MOV      r0,r10
002284  e59d1008          LDR      r1,[sp,#8]
002288  ebfffffe          BL       __aeabi_llsr
00228c  e1a07000          MOV      r7,r0
;;;1174   	/* Allocate memory (2bit per block) and clear the memory bad block table */
;;;1175   	this->bbt = yaffs_malloc(len);
002290  e1a00007          MOV      r0,r7
002294  ebfffffe          BL       yaffs_malloc
002298  e5840110          STR      r0,[r4,#0x110]
;;;1176   	if (!this->bbt) {
00229c  e5940110          LDR      r0,[r4,#0x110]
0022a0  e3500000          CMP      r0,#0
0022a4  1a000003          BNE      |L1.8888|
;;;1177   		sysprintf("nand_scan_bbt: Out of memory\n");
0022a8  e28f0f8b          ADR      r0,|L1.9436|
0022ac  ebfffffe          BL       sysprintf
;;;1178   		return -ENOMEM;
0022b0  e3e0000b          MVN      r0,#0xb
                  |L1.8884|
;;;1179   	}
;;;1180   	memset((void*)this->bbt,0,len);
;;;1181   
;;;1182   	/* If no primary table decriptor is given, scan the device
;;;1183   	 * to build a memory based bad block table
;;;1184   	 */
;;;1185   	if (!td) {
;;;1186   		if ((res = nand_memory_bbt(mtd, bd))) {
;;;1187   			sysprintf("nand_bbt: Can't scan flash and build the RAM-based BBT\n");
;;;1188   			yaffs_free(this->bbt);
;;;1189   			this->bbt = NULL;
;;;1190   		}
;;;1191   		return res;
;;;1192   	}
;;;1193   	verify_bbt_descr(mtd, td);
;;;1194   	verify_bbt_descr(mtd, md);
;;;1195   
;;;1196   	/* Allocate a temporary buffer for one eraseblock incl. oob */
;;;1197   	len = (1 << this->bbt_erase_shift);
;;;1198   	len += (len >> this->page_shift) * mtd->oobsize;
;;;1199   	buf = yaffs_malloc(len);
;;;1200   	if (!buf) {
;;;1201   		sysprintf("nand_bbt: Out of memory\n");
;;;1202   		yaffs_free(this->bbt);
;;;1203   		this->bbt = NULL;
;;;1204   		return -ENOMEM;
;;;1205   	}
;;;1206   	memset((void*)buf,0,len);
;;;1207   
;;;1208   	/* Is the bbt at a given page ? */
;;;1209   	if (td->options & NAND_BBT_ABSPAGE) {
;;;1210   		res = read_abs_bbts(mtd, buf, td, md);
;;;1211   	} else {
;;;1212   		/* Search the bad block table using a pattern in oob */
;;;1213   		res = search_read_bbts(mtd, buf, td, md);
;;;1214   	}
;;;1215   
;;;1216   	if (res)
;;;1217   		res = check_create(mtd, buf, bd);
;;;1218   
;;;1219   	/* Prevent the bbt regions from erasing / writing */
;;;1220   	mark_bbt_region(mtd, td);
;;;1221   	if (md)
;;;1222   		mark_bbt_region(mtd, md);
;;;1223   
;;;1224   	yaffs_free(buf);
;;;1225   	return res;
;;;1226   }
0022b4  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.8888|
0022b8  e1a01007          MOV      r1,r7                 ;1180
0022bc  e5940110          LDR      r0,[r4,#0x110]        ;1180
0022c0  ebfffffe          BL       __aeabi_memclr
0022c4  e3590000          CMP      r9,#0                 ;1185
0022c8  1a000017          BNE      |L1.9004|
0022cc  e1a00000          MOV      r0,r0                 ;1186
0022d0  e5950094          LDR      r0,[r5,#0x94]         ;1186
0022d4  e58d0000          STR      r0,[sp,#0]            ;1186
0022d8  e5960000          LDR      r0,[r6,#0]            ;1186
0022dc  e3c00b02          BIC      r0,r0,#0x800          ;1186
0022e0  e5860000          STR      r0,[r6,#0]            ;1186
0022e4  e59d0000          LDR      r0,[sp,#0]            ;1186
0022e8  e59000e8          LDR      r0,[r0,#0xe8]         ;1186
0022ec  e2801d12          ADD      r1,r0,#0x480          ;1186
0022f0  e3e03000          MVN      r3,#0                 ;1186
0022f4  e1a02006          MOV      r2,r6                 ;1186
0022f8  e1a00005          MOV      r0,r5                 ;1186
0022fc  ebfffffe          BL       create_bbt
002300  e58d0004          STR      r0,[sp,#4]            ;1186
002304  e3500000          CMP      r0,#0                 ;1186
002308  0a000005          BEQ      |L1.8996|
00230c  e28f0f7a          ADR      r0,|L1.9468|
002310  ebfffffe          BL       sysprintf
002314  e5940110          LDR      r0,[r4,#0x110]        ;1188
002318  ebfffffe          BL       yaffs_free
00231c  e3a00000          MOV      r0,#0                 ;1189
002320  e5840110          STR      r0,[r4,#0x110]        ;1189
                  |L1.8996|
002324  e59d0004          LDR      r0,[sp,#4]            ;1191
002328  eaffffe1          B        |L1.8884|
                  |L1.9004|
00232c  e1a01009          MOV      r1,r9                 ;1193
002330  e1a00005          MOV      r0,r5                 ;1193
002334  ebfffffe          BL       verify_bbt_descr
002338  e1a0100b          MOV      r1,r11                ;1194
00233c  e1a00005          MOV      r0,r5                 ;1194
002340  ebfffffe          BL       verify_bbt_descr
002344  e5d4005c          LDRB     r0,[r4,#0x5c]         ;1197
002348  e3a01001          MOV      r1,#1                 ;1197
00234c  e1a07011          LSL      r7,r1,r0              ;1197
002350  e5d40054          LDRB     r0,[r4,#0x54]         ;1198
002354  e1a00057          ASR      r0,r7,r0              ;1198
002358  e5951018          LDR      r1,[r5,#0x18]         ;1198
00235c  e0277190          MLA      r7,r0,r1,r7           ;1198
002360  e1a00007          MOV      r0,r7                 ;1199
002364  ebfffffe          BL       yaffs_malloc
002368  e1a08000          MOV      r8,r0                 ;1199
00236c  e3580000          CMP      r8,#0                 ;1200
002370  1a000007          BNE      |L1.9108|
002374  e28f0f6e          ADR      r0,|L1.9524|
002378  ebfffffe          BL       sysprintf
00237c  e5940110          LDR      r0,[r4,#0x110]        ;1202
002380  ebfffffe          BL       yaffs_free
002384  e3a00000          MOV      r0,#0                 ;1203
002388  e5840110          STR      r0,[r4,#0x110]        ;1203
00238c  e3e0000b          MVN      r0,#0xb               ;1204
002390  eaffffc7          B        |L1.8884|
                  |L1.9108|
002394  e1a01007          MOV      r1,r7                 ;1206
002398  e1a00008          MOV      r0,r8                 ;1206
00239c  ebfffffe          BL       __aeabi_memclr
0023a0  e5d90000          LDRB     r0,[r9,#0]            ;1209
0023a4  e3100020          TST      r0,#0x20              ;1209
0023a8  0a000006          BEQ      |L1.9160|
0023ac  e1a0300b          MOV      r3,r11                ;1210
0023b0  e1a02009          MOV      r2,r9                 ;1210
0023b4  e1a01008          MOV      r1,r8                 ;1210
0023b8  e1a00005          MOV      r0,r5                 ;1210
0023bc  ebfffffe          BL       read_abs_bbts
0023c0  e58d0004          STR      r0,[sp,#4]            ;1210
0023c4  ea000005          B        |L1.9184|
                  |L1.9160|
0023c8  e1a0300b          MOV      r3,r11                ;1213
0023cc  e1a02009          MOV      r2,r9                 ;1213
0023d0  e1a01008          MOV      r1,r8                 ;1213
0023d4  e1a00005          MOV      r0,r5                 ;1213
0023d8  ebfffffe          BL       search_read_bbts
0023dc  e58d0004          STR      r0,[sp,#4]            ;1213
                  |L1.9184|
0023e0  e59d0004          LDR      r0,[sp,#4]            ;1216
0023e4  e3500000          CMP      r0,#0                 ;1216
0023e8  0a000004          BEQ      |L1.9216|
0023ec  e1a02006          MOV      r2,r6                 ;1217
0023f0  e1a01008          MOV      r1,r8                 ;1217
0023f4  e1a00005          MOV      r0,r5                 ;1217
0023f8  ebfffffe          BL       check_create
0023fc  e58d0004          STR      r0,[sp,#4]            ;1217
                  |L1.9216|
002400  e1a01009          MOV      r1,r9                 ;1220
002404  e1a00005          MOV      r0,r5                 ;1220
002408  ebfffffe          BL       mark_bbt_region
00240c  e35b0000          CMP      r11,#0                ;1221
002410  0a000002          BEQ      |L1.9248|
002414  e1a0100b          MOV      r1,r11                ;1222
002418  e1a00005          MOV      r0,r5                 ;1222
00241c  ebfffffe          BL       mark_bbt_region
                  |L1.9248|
002420  e1a00008          MOV      r0,r8                 ;1224
002424  ebfffffe          BL       yaffs_free
002428  e59d0004          LDR      r0,[sp,#4]            ;1225
00242c  eaffffa0          B        |L1.8884|
;;;1227   
                          ENDP

                  nand_create_default_bbt_descr PROC
;;;1320    */
;;;1321   static int nand_create_default_bbt_descr(struct nand_chip *this)
002430  e92d4070          PUSH     {r4-r6,lr}
;;;1322   {
002434  e1a05000          MOV      r5,r0
;;;1323   	struct nand_bbt_descr *bd;
;;;1324   	if (this->badblock_pattern) {
002438  e595011c          LDR      r0,[r5,#0x11c]
00243c  e3500000          CMP      r0,#0
002440  0a000003          BEQ      |L1.9300|
;;;1325   		sysprintf("BBT descr already allocated; not replacing.\n");
002444  e28f0f41          ADR      r0,|L1.9552|
002448  ebfffffe          BL       sysprintf
;;;1326   		return -EINVAL;
00244c  e3e00015          MVN      r0,#0x15
                  |L1.9296|
;;;1327   	}
;;;1328   	bd = yaffs_malloc(sizeof(*bd));
;;;1329   	if (!bd) {
;;;1330   		sysprintf("nand_create_default_bbt_descr: Out of memory\n");
;;;1331   		return -ENOMEM;
;;;1332   	}
;;;1333   	memset((void*)bd,0,sizeof(*bd));
;;;1334   
;;;1335   	bd->options = this->options & BBT_SCAN_OPTIONS;
;;;1336   	bd->offs = this->badblockpos;
;;;1337   	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
;;;1338   	bd->pattern = scan_ff_pattern;
;;;1339   	bd->options |= NAND_BBT_DYNAMICSTRUCT;
;;;1340   	this->badblock_pattern = bd;
;;;1341   	return 0;
;;;1342   }
002450  e8bd8070          POP      {r4-r6,pc}
                  |L1.9300|
002454  e3a00024          MOV      r0,#0x24              ;1328
002458  ebfffffe          BL       yaffs_malloc
00245c  e1a04000          MOV      r4,r0                 ;1328
002460  e3540000          CMP      r4,#0                 ;1329
002464  1a000003          BNE      |L1.9336|
002468  e28f0e11          ADR      r0,|L1.9600|
00246c  ebfffffe          BL       sysprintf
002470  e3e0000b          MVN      r0,#0xb               ;1331
002474  eafffff5          B        |L1.9296|
                  |L1.9336|
002478  e3a01024          MOV      r1,#0x24              ;1333
00247c  e1a00004          MOV      r0,r4                 ;1333
002480  ebfffffe          BL       __aeabi_memclr4
002484  e5950050          LDR      r0,[r5,#0x50]         ;1335
002488  e2000943          AND      r0,r0,#0x10c000       ;1335
00248c  e5840000          STR      r0,[r4,#0]            ;1335
002490  e5950080          LDR      r0,[r5,#0x80]         ;1336
002494  e5840008          STR      r0,[r4,#8]            ;1336
002498  e5d50050          LDRB     r0,[r5,#0x50]         ;1337
00249c  e3100002          TST      r0,#2                 ;1337
0024a0  0a000001          BEQ      |L1.9388|
0024a4  e3a00002          MOV      r0,#2                 ;1337
0024a8  ea000000          B        |L1.9392|
                  |L1.9388|
0024ac  e3a00001          MOV      r0,#1                 ;1337
                  |L1.9392|
0024b0  e5840014          STR      r0,[r4,#0x14]         ;1337
0024b4  e59f00f4          LDR      r0,|L1.9648|
0024b8  e5840020          STR      r0,[r4,#0x20]         ;1338
0024bc  e5940000          LDR      r0,[r4,#0]            ;1339
0024c0  e3800602          ORR      r0,r0,#0x200000       ;1339
0024c4  e5840000          STR      r0,[r4,#0]            ;1339
0024c8  e585411c          STR      r4,[r5,#0x11c]        ;1340
0024cc  e3a00000          MOV      r0,#0                 ;1341
0024d0  eaffffde          B        |L1.9296|
                  |L1.9428|
                          DCD      |symbol_number.31|
                  |L1.9432|
                          DCD      ||.text||+0x10e8
                  |L1.9436|
0024dc  6e616e64          DCB      "nand_scan_bbt: Out of memory\n",0
0024e0  5f736361
0024e4  6e5f6262
0024e8  743a204f
0024ec  7574206f
0024f0  66206d65
0024f4  6d6f7279
0024f8  0a00    
0024fa  00                DCB      0
0024fb  00                DCB      0
                  |L1.9468|
0024fc  6e616e64          DCB      "nand_bbt: Can't scan flash and build the RAM-based BBT\n"
002500  5f626274
002504  3a204361
002508  6e277420
00250c  7363616e
002510  20666c61
002514  73682061
002518  6e642062
00251c  75696c64
002520  20746865
002524  2052414d
002528  2d626173
00252c  65642042
002530  42540a  
002533  00                DCB      0
                  |L1.9524|
002534  6e616e64          DCB      "nand_bbt: Out of memory\n",0
002538  5f626274
00253c  3a204f75
002540  74206f66
002544  206d656d
002548  6f72790a
00254c  00      
00254d  00                DCB      0
00254e  00                DCB      0
00254f  00                DCB      0
                  |L1.9552|
002550  42425420          DCB      "BBT descr already allocated; not replacing.\n",0
002554  64657363
002558  7220616c
00255c  72656164
002560  7920616c
002564  6c6f6361
002568  7465643b
00256c  206e6f74
002570  20726570
002574  6c616369
002578  6e672e0a
00257c  00      
00257d  00                DCB      0
00257e  00                DCB      0
00257f  00                DCB      0
                  |L1.9600|
002580  6e616e64          DCB      "nand_create_default_bbt_descr: Out of memory\n",0
002584  5f637265
002588  6174655f
00258c  64656661
002590  756c745f
002594  6262745f
002598  64657363
00259c  723a204f
0025a0  7574206f
0025a4  66206d65
0025a8  6d6f7279
0025ac  0a00    
0025ae  00                DCB      0
0025af  00                DCB      0
                  |L1.9648|
                          DCD      scan_ff_pattern
                          ENDP

                  nand_default_bbt PROC
;;;1351   */
;;;1352   int nand_default_bbt(struct mtd_info *mtd)
0025b4  e92d4070          PUSH     {r4-r6,lr}
;;;1353   {
0025b8  e1a05000          MOV      r5,r0
;;;1354   	struct nand_chip *this = mtd->priv;
0025bc  e5954094          LDR      r4,[r5,#0x94]
;;;1355   
;;;1356       /* bbt_main_descr */
;;;1357       bbt_main_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP;
0025c0  e59f0240          LDR      r0,|L1.10248|
0025c4  e59f1240          LDR      r1,|L1.10252|
0025c8  e5810000          STR      r0,[r1,#0]  ; bbt_main_descr
;;;1358   	bbt_main_descr.offs = 8;
0025cc  e3a00008          MOV      r0,#8
0025d0  e5810008          STR      r0,[r1,#8]  ; bbt_main_descr
;;;1359   	bbt_main_descr.len = 4;
0025d4  e3a00004          MOV      r0,#4
0025d8  e5810014          STR      r0,[r1,#0x14]  ; bbt_main_descr
;;;1360   	bbt_main_descr.veroffs = 12;
0025dc  e3a0000c          MOV      r0,#0xc
0025e0  e581000c          STR      r0,[r1,#0xc]  ; bbt_main_descr
;;;1361   	bbt_main_descr.maxblocks = 4;
0025e4  e3a00004          MOV      r0,#4
0025e8  e5810018          STR      r0,[r1,#0x18]  ; bbt_main_descr
;;;1362   	bbt_main_descr.pattern = bbt_pattern;
0025ec  e59f021c          LDR      r0,|L1.10256|
0025f0  e5810020          STR      r0,[r1,#0x20]  ; bbt_main_descr
;;;1363       
;;;1364       /* agand_flashbased */
;;;1365       agand_flashbased.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES;
0025f4  e3a00b03          MOV      r0,#0xc00
0025f8  e59f1214          LDR      r1,|L1.10260|
0025fc  e5810000          STR      r0,[r1,#0]  ; agand_flashbased
;;;1366       agand_flashbased.offs = 0x20;
002600  e3a00020          MOV      r0,#0x20
002604  e5810008          STR      r0,[r1,#8]  ; agand_flashbased
;;;1367       agand_flashbased.len = 6;
002608  e3a00006          MOV      r0,#6
00260c  e5810014          STR      r0,[r1,#0x14]  ; agand_flashbased
;;;1368       agand_flashbased.pattern = scan_agand_pattern;
002610  e59f0200          LDR      r0,|L1.10264|
002614  e5810020          STR      r0,[r1,#0x20]  ; agand_flashbased
;;;1369   
;;;1370       /* bbt_mirror_descr */
;;;1371       bbt_mirror_descr.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP;
002618  e59f01e8          LDR      r0,|L1.10248|
00261c  e59f11f8          LDR      r1,|L1.10268|
002620  e5810000          STR      r0,[r1,#0]  ; bbt_mirror_descr
;;;1372   	bbt_mirror_descr.offs =	8;
002624  e3a00008          MOV      r0,#8
002628  e5810008          STR      r0,[r1,#8]  ; bbt_mirror_descr
;;;1373   	bbt_mirror_descr.len = 4;
00262c  e3a00004          MOV      r0,#4
002630  e5810014          STR      r0,[r1,#0x14]  ; bbt_mirror_descr
;;;1374   	bbt_mirror_descr.veroffs = 12;
002634  e3a0000c          MOV      r0,#0xc
002638  e581000c          STR      r0,[r1,#0xc]  ; bbt_mirror_descr
;;;1375   	bbt_mirror_descr.maxblocks = 4;
00263c  e3a00004          MOV      r0,#4
002640  e5810018          STR      r0,[r1,#0x18]  ; bbt_mirror_descr
;;;1376   	bbt_mirror_descr.pattern = mirror_pattern;
002644  e59f01d4          LDR      r0,|L1.10272|
002648  e5810020          STR      r0,[r1,#0x20]  ; bbt_mirror_descr
;;;1377   
;;;1378       /* bbt_main_no_bbt_descr */
;;;1379       bbt_main_no_bbt_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP|NAND_BBT_NO_OOB;
00264c  e59f01d0          LDR      r0,|L1.10276|
002650  e59f11d0          LDR      r1,|L1.10280|
002654  e5810000          STR      r0,[r1,#0]  ; bbt_main_no_bbt_descr
;;;1380   	bbt_main_no_bbt_descr.len = 4;
002658  e3a00004          MOV      r0,#4
00265c  e5810014          STR      r0,[r1,#0x14]  ; bbt_main_no_bbt_descr
;;;1381   	bbt_main_no_bbt_descr.veroffs = 4;
002660  e581000c          STR      r0,[r1,#0xc]  ; bbt_main_no_bbt_descr
;;;1382   	bbt_main_no_bbt_descr.maxblocks = 4;
002664  e5810018          STR      r0,[r1,#0x18]  ; bbt_main_no_bbt_descr
;;;1383   	bbt_main_no_bbt_descr.pattern = bbt_pattern;
002668  e59f01a0          LDR      r0,|L1.10256|
00266c  e5810020          STR      r0,[r1,#0x20]  ; bbt_main_no_bbt_descr
;;;1384   
;;;1385       /* bbt_mirror_no_bbt_descr */
;;;1386       bbt_mirror_no_bbt_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP|NAND_BBT_NO_OOB;
002670  e59f01ac          LDR      r0,|L1.10276|
002674  e59f11b0          LDR      r1,|L1.10284|
002678  e5810000          STR      r0,[r1,#0]  ; bbt_mirror_no_bbt_descr
;;;1387   	bbt_mirror_no_bbt_descr.len = 4;
00267c  e3a00004          MOV      r0,#4
002680  e5810014          STR      r0,[r1,#0x14]  ; bbt_mirror_no_bbt_descr
;;;1388   	bbt_mirror_no_bbt_descr.veroffs = 4;
002684  e581000c          STR      r0,[r1,#0xc]  ; bbt_mirror_no_bbt_descr
;;;1389   	bbt_mirror_no_bbt_descr.maxblocks = 4;
002688  e5810018          STR      r0,[r1,#0x18]  ; bbt_mirror_no_bbt_descr
;;;1390   	bbt_mirror_no_bbt_descr.pattern = mirror_pattern;
00268c  e59f018c          LDR      r0,|L1.10272|
002690  e5810020          STR      r0,[r1,#0x20]  ; bbt_mirror_no_bbt_descr
;;;1391   
;;;1392   	/* Default for AG-AND. We must use a flash based
;;;1393   	 * bad block table as the devices have factory marked
;;;1394   	 * _good_ blocks. Erasing those blocks leads to loss
;;;1395   	 * of the good / bad information, so we _must_ store
;;;1396   	 * this information in a good / bad table during
;;;1397   	 * startup
;;;1398   	 */
;;;1399   	if (this->options & NAND_IS_AND) {
002694  e5d40050          LDRB     r0,[r4,#0x50]
002698  e3100020          TST      r0,#0x20
00269c  0a00000d          BEQ      |L1.9944|
;;;1400   		/* Use the default pattern descriptors */
;;;1401   		if (!this->bbt_td) {
0026a0  e5940114          LDR      r0,[r4,#0x114]
0026a4  e3500000          CMP      r0,#0
0026a8  1a000003          BNE      |L1.9916|
;;;1402   			this->bbt_td = &bbt_main_descr;
0026ac  e59f0158          LDR      r0,|L1.10252|
0026b0  e5840114          STR      r0,[r4,#0x114]
;;;1403   			this->bbt_md = &bbt_mirror_descr;
0026b4  e59f0160          LDR      r0,|L1.10268|
0026b8  e5840118          STR      r0,[r4,#0x118]
                  |L1.9916|
;;;1404   		}
;;;1405   		this->options |= NAND_USE_FLASH_BBT;
0026bc  e5940050          LDR      r0,[r4,#0x50]
0026c0  e3800801          ORR      r0,r0,#0x10000
0026c4  e5840050          STR      r0,[r4,#0x50]
;;;1406   		return nand_scan_bbt(mtd, &agand_flashbased);
0026c8  e59f1144          LDR      r1,|L1.10260|
0026cc  e1a00005          MOV      r0,r5
0026d0  ebfffffe          BL       nand_scan_bbt
                  |L1.9940|
;;;1407   	}
;;;1408   
;;;1409   	/* Is a flash based bad block table requested ? */
;;;1410   	if (this->options & NAND_USE_FLASH_BBT) {
;;;1411   		/* Use the default pattern descriptors */
;;;1412   		if (!this->bbt_td) {
;;;1413   			if (this->options & NAND_USE_FLASH_BBT_NO_OOB) {
;;;1414   				this->bbt_td = &bbt_main_no_bbt_descr;
;;;1415   				this->bbt_md = &bbt_mirror_no_bbt_descr;
;;;1416   			} else {
;;;1417   				this->bbt_td = &bbt_main_descr;
;;;1418   				this->bbt_md = &bbt_mirror_descr;
;;;1419   			}
;;;1420   		}
;;;1421   	} else {
;;;1422   		this->bbt_td = NULL;
;;;1423   		this->bbt_md = NULL;
;;;1424   	}
;;;1425   
;;;1426   	if (!this->badblock_pattern)
;;;1427   		nand_create_default_bbt_descr(this);
;;;1428   
;;;1429   	return nand_scan_bbt(mtd, this->badblock_pattern);
;;;1430   }
0026d4  e8bd8070          POP      {r4-r6,pc}
                  |L1.9944|
0026d8  e5940050          LDR      r0,[r4,#0x50]         ;1410
0026dc  e3100801          TST      r0,#0x10000           ;1410
0026e0  0a00000f          BEQ      |L1.10020|
0026e4  e5940114          LDR      r0,[r4,#0x114]        ;1412
0026e8  e3500000          CMP      r0,#0                 ;1412
0026ec  1a00000f          BNE      |L1.10032|
0026f0  e5940050          LDR      r0,[r4,#0x50]         ;1413
0026f4  e3100502          TST      r0,#0x800000          ;1413
0026f8  0a000004          BEQ      |L1.10000|
0026fc  e59f0124          LDR      r0,|L1.10280|
002700  e5840114          STR      r0,[r4,#0x114]        ;1414
002704  e59f0120          LDR      r0,|L1.10284|
002708  e5840118          STR      r0,[r4,#0x118]        ;1415
00270c  ea000007          B        |L1.10032|
                  |L1.10000|
002710  e59f00f4          LDR      r0,|L1.10252|
002714  e5840114          STR      r0,[r4,#0x114]        ;1417
002718  e59f00fc          LDR      r0,|L1.10268|
00271c  e5840118          STR      r0,[r4,#0x118]        ;1418
002720  ea000002          B        |L1.10032|
                  |L1.10020|
002724  e3a00000          MOV      r0,#0                 ;1422
002728  e5840114          STR      r0,[r4,#0x114]        ;1422
00272c  e5840118          STR      r0,[r4,#0x118]        ;1423
                  |L1.10032|
002730  e594011c          LDR      r0,[r4,#0x11c]        ;1426
002734  e3500000          CMP      r0,#0                 ;1426
002738  1a000001          BNE      |L1.10052|
00273c  e1a00004          MOV      r0,r4                 ;1427
002740  ebfffffe          BL       nand_create_default_bbt_descr
                  |L1.10052|
002744  e1a00005          MOV      r0,r5                 ;1429
002748  e594111c          LDR      r1,[r4,#0x11c]        ;1429
00274c  ebfffffe          BL       nand_scan_bbt
002750  eaffffdf          B        |L1.9940|
;;;1431   
                          ENDP

                  nand_isbad_bbt PROC
;;;1438   */
;;;1439   int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
002754  e92d4ff8          PUSH     {r3-r11,lr}
;;;1440   {
002758  e1a08000          MOV      r8,r0
00275c  e1a06002          MOV      r6,r2
002760  e1a07003          MOV      r7,r3
002764  e59db028          LDR      r11,[sp,#0x28]
;;;1441   	struct nand_chip *this = mtd->priv;
002768  e5989094          LDR      r9,[r8,#0x94]
;;;1442   	int block;
;;;1443   	uint8_t res;
;;;1444   
;;;1445   	/* Get block number * 2 */
;;;1446   	block = (int)(offs >> (this->bbt_erase_shift - 1));
00276c  e599005c          LDR      r0,[r9,#0x5c]
002770  e2402001          SUB      r2,r0,#1
002774  e1a04006          MOV      r4,r6
002778  e1a05007          MOV      r5,r7
00277c  e1a00004          MOV      r0,r4
002780  e1a01005          MOV      r1,r5
002784  ebfffffe          BL       __aeabi_lasr
002788  e1a0a000          MOV      r10,r0
;;;1447   	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
00278c  e5990110          LDR      r0,[r9,#0x110]
002790  e7d001ca          LDRB     r0,[r0,r10,ASR #3]
002794  e20a1006          AND      r1,r10,#6
002798  e1a00150          ASR      r0,r0,r1
00279c  e2000003          AND      r0,r0,#3
0027a0  e58d0000          STR      r0,[sp,#0]
;;;1448   
;;;1449   	MTDDEBUG(MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
0027a4  e1a00000          MOV      r0,r0
0027a8  e1a00000          MOV      r0,r0
;;;1450   	      (unsigned int)offs, block >> 1, res);
;;;1451   
;;;1452   	switch ((int)res) {
0027ac  e59d0000          LDR      r0,[sp,#0]
0027b0  e3500000          CMP      r0,#0
0027b4  0a000004          BEQ      |L1.10188|
0027b8  e3500001          CMP      r0,#1
0027bc  0a000005          BEQ      |L1.10200|
0027c0  e3500002          CMP      r0,#2
0027c4  1a00000d          BNE      |L1.10240|
0027c8  ea000005          B        |L1.10212|
                  |L1.10188|
;;;1453   	case 0x00:
0027cc  e1a00000          MOV      r0,r0
;;;1454   		return 0;
0027d0  e3a00000          MOV      r0,#0
                  |L1.10196|
;;;1455   	case 0x01:
;;;1456   		return 1;
;;;1457   	case 0x02:
;;;1458   		return allowbbt ? 0 : 1;
;;;1459   	}
;;;1460   	return 1;
;;;1461   }
0027d4  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.10200|
0027d8  e1a00000          MOV      r0,r0                 ;1455
0027dc  e3a00001          MOV      r0,#1                 ;1456
0027e0  eafffffb          B        |L1.10196|
                  |L1.10212|
0027e4  e1a00000          MOV      r0,r0                 ;1457
0027e8  e35b0000          CMP      r11,#0                ;1458
0027ec  1a000001          BNE      |L1.10232|
0027f0  e3a00001          MOV      r0,#1                 ;1458
0027f4  eafffff6          B        |L1.10196|
                  |L1.10232|
0027f8  e3a00000          MOV      r0,#0                 ;1458
0027fc  eafffff4          B        |L1.10196|
                  |L1.10240|
002800  e3a00001          MOV      r0,#1                 ;1460
002804  eafffff2          B        |L1.10196|
                          ENDP

                  |L1.10248|
                          DCD      0x00001392
                  |L1.10252|
                          DCD      bbt_main_descr
                  |L1.10256|
                          DCD      bbt_pattern
                  |L1.10260|
                          DCD      agand_flashbased
                  |L1.10264|
                          DCD      scan_agand_pattern
                  |L1.10268|
                          DCD      bbt_mirror_descr
                  |L1.10272|
                          DCD      mirror_pattern
                  |L1.10276|
                          DCD      0x00401392
                  |L1.10280|
                          DCD      bbt_main_no_bbt_descr
                  |L1.10284|
                          DCD      bbt_mirror_no_bbt_descr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  agand_flashbased
                          %        36
                  bbt_main_descr
                          %        36
                  bbt_mirror_descr
                          %        36
                  bbt_main_no_bbt_descr
                          %        36
                  bbt_mirror_no_bbt_descr
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __func__
000000  63726561          DCB      0x63,0x72,0x65,0x61
000004  74655f62          DCB      0x74,0x65,0x5f,0x62
000008  627400            DCB      0x62,0x74,0x00
                  |symbol_number.31|
00000b  76                DCB      0x76
00000c  65726966          DCB      0x65,0x72,0x69,0x66
000010  795f6262          DCB      0x79,0x5f,0x62,0x62
000014  745f6465          DCB      0x74,0x5f,0x64,0x65
000018  73637200          DCB      0x73,0x63,0x72,0x00
00001c  6e616e64          DCB      0x6e,0x61,0x6e,0x64
000020  5f626274          DCB      0x5f,0x62,0x62,0x74
000024  3a204543          DCB      0x3a,0x20,0x45,0x43
000028  43206572          DCB      0x43,0x20,0x65,0x72
00002c  726f7220          DCB      0x72,0x6f,0x72,0x20
000030  7768696c          DCB      0x77,0x68,0x69,0x6c
000034  65207265          DCB      0x65,0x20,0x72,0x65
000038  6164696e          DCB      0x61,0x64,0x69,0x6e
00003c  6720626c          DCB      0x67,0x20,0x62,0x6c
000040  6f636b20          DCB      0x6f,0x63,0x6b,0x20
000044  666f7220          DCB      0x66,0x6f,0x72,0x20
000048  77726974          DCB      0x77,0x72,0x69,0x74
00004c  696e6720          DCB      0x69,0x6e,0x67,0x20
000050  62616420          DCB      0x62,0x61,0x64,0x20
000054  626c6f63          DCB      0x62,0x6c,0x6f,0x63
000058  6b207461          DCB      0x6b,0x20,0x74,0x61
00005c  626c650a          DCB      0x62,0x6c,0x65,0x0a
000060  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=0

                  scan_ff_pattern
000000  ffff              DCB      0xff,0xff
                  scan_agand_pattern
000002  1c71              DCB      0x1c,0x71
000004  c71c71c7          DCB      0xc7,0x1c,0x71,0xc7
                  bbt_pattern
000008  42627430          DCB      0x42,0x62,0x74,0x30
                  mirror_pattern
00000c  31746242          DCB      0x31,0x74,0x62,0x42
