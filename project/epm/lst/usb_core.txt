; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\usb_core.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usb_core.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\usb_core.crf ..\..\common\src\BSP\Library\USB_HOST\src_core\usb_core.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usbh_core_init PROC
;;;41       */
;;;42     void  usbh_core_init()
000000  e92d4010          PUSH     {r4,lr}
;;;43     {
;;;44         DISABLE_EHCI_IRQ();
000004  e3a00017          MOV      r0,#0x17
000008  ebfffffe          BL       sysDisableInterrupt
;;;45         DISABLE_OHCI_IRQ();
00000c  e3a00018          MOV      r0,#0x18
000010  ebfffffe          BL       sysDisableInterrupt
;;;46     
;;;47         _ohci = USBH;
000014  e59f049c          LDR      r0,|L1.1208|
000018  e59f149c          LDR      r1,|L1.1212|
00001c  e5810000          STR      r0,[r1,#0]  ; _ohci
;;;48         _ehci = HSUSBH;
000020  e2400a02          SUB      r0,r0,#0x2000
000024  e59f1494          LDR      r1,|L1.1216|
000028  e5810000          STR      r0,[r1,#0]  ; _ehci
;;;49     
;;;50         memset(_drivers, 0, sizeof(_drivers));
00002c  e3a01020          MOV      r1,#0x20
000030  e59f048c          LDR      r0,|L1.1220|
000034  ebfffffe          BL       __aeabi_memclr4
;;;51     
;;;52         g_conn_func = NULL;
000038  e3a00000          MOV      r0,#0
00003c  e59f1484          LDR      r1,|L1.1224|
000040  e5810000          STR      r0,[r1,#0]  ; g_conn_func
;;;53         g_disconn_func = NULL;
000044  e59f1480          LDR      r1,|L1.1228|
000048  e5810000          STR      r0,[r1,#0]  ; g_disconn_func
;;;54     
;;;55         usbh_hub_init();
00004c  ebfffffe          BL       usbh_hub_init
;;;56     
;;;57         _ehci->USBPCR0 = 0x160;                /* enable PHY 0          */
000050  e3a00e16          MOV      r0,#0x160
000054  e59f1464          LDR      r1,|L1.1216|
000058  e5911000          LDR      r1,[r1,#0]  ; _ehci
00005c  e58100c4          STR      r0,[r1,#0xc4]
;;;58         _ehci->USBPCR1 = 0x520;                /* enable PHY 1          */
000060  e3a00e52          MOV      r0,#0x520
000064  e59f1454          LDR      r1,|L1.1216|
000068  e5911000          LDR      r1,[r1,#0]  ; _ehci
00006c  e58100c8          STR      r0,[r1,#0xc8]
;;;59         usbh_memory_init();
000070  ebfffffe          BL       usbh_memory_init
;;;60     
;;;61         //_ohci->HcMiscControl |= USBH_HcMiscControl_OCAL_Msk; /* Over-current active low  */
;;;62         _ohci->HcMiscControl &= ~USBH_HcMiscControl_OCAL_Msk; /* Over-current active high  */
000074  e59f0440          LDR      r0,|L1.1212|
000078  e5900000          LDR      r0,[r0,#0]  ; _ohci
00007c  e5900204          LDR      r0,[r0,#0x204]
000080  e3c00008          BIC      r0,r0,#8
000084  e59f1430          LDR      r1,|L1.1212|
000088  e5911000          LDR      r1,[r1,#0]  ; _ohci
00008c  e5810204          STR      r0,[r1,#0x204]
;;;63     
;;;64     #ifdef ENABLE_OHCI
;;;65         sysInstallISR(HIGH_LEVEL_SENSITIVE | IRQ_LEVEL_1, OHCI_IRQn, (PVOID)OHCI_IRQHandler);
000090  e59f2438          LDR      r2,|L1.1232|
000094  e3a01018          MOV      r1,#0x18
000098  e3a00041          MOV      r0,#0x41
00009c  ebfffffe          BL       sysInstallISR
;;;66         ohci_driver.init();
0000a0  e59f142c          LDR      r1,|L1.1236|
0000a4  e5910000          LDR      r0,[r1,#0]  ; ohci_driver
0000a8  e12fff30          BLX      r0
;;;67         ENABLE_OHCI_IRQ();
0000ac  e3a00018          MOV      r0,#0x18
0000b0  ebfffffe          BL       sysEnableInterrupt
;;;68     #endif
;;;69     
;;;70     #ifdef ENABLE_EHCI
;;;71         sysInstallISR(HIGH_LEVEL_SENSITIVE | IRQ_LEVEL_1, EHCI_IRQn, (PVOID)EHCI_IRQHandler);
0000b4  e59f241c          LDR      r2,|L1.1240|
0000b8  e3a01017          MOV      r1,#0x17
0000bc  e3a00041          MOV      r0,#0x41
0000c0  ebfffffe          BL       sysInstallISR
;;;72         ehci_driver.init();
0000c4  e59f1410          LDR      r1,|L1.1244|
0000c8  e5910000          LDR      r0,[r1,#0]  ; ehci_driver
0000cc  e12fff30          BLX      r0
;;;73         ENABLE_EHCI_IRQ();
0000d0  e3a00017          MOV      r0,#0x17
0000d4  ebfffffe          BL       sysEnableInterrupt
;;;74     #endif
;;;75     
;;;76         sysFlushCache(I_D_CACHE);
0000d8  e3a00008          MOV      r0,#8
0000dc  ebfffffe          BL       sysFlushCache
;;;77     
;;;78         sysSetLocalInterrupt(ENABLE_IRQ);   /* enable CPSR I bit */
0000e0  e3a0007f          MOV      r0,#0x7f
0000e4  ebfffffe          BL       sysSetLocalInterrupt
;;;79     }
0000e8  e8bd8010          POP      {r4,pc}
;;;80     
                          ENDP

                  usbh_install_conn_callback PROC
;;;87       */
;;;88     void usbh_install_conn_callback(CONN_FUNC *conn_func, CONN_FUNC *disconn_func)
0000ec  e59f23d4          LDR      r2,|L1.1224|
;;;89     {
;;;90         g_conn_func = conn_func;
0000f0  e5820000          STR      r0,[r2,#0]  ; g_conn_func
;;;91         g_disconn_func = disconn_func;
0000f4  e59f23d0          LDR      r2,|L1.1228|
0000f8  e5821000          STR      r1,[r2,#0]  ; g_disconn_func
;;;92     }
0000fc  e12fff1e          BX       lr
;;;93     
                          ENDP

                  reset_device PROC
;;;94     static int  reset_device(UDEV_T *udev)
000100  e92d4010          PUSH     {r4,lr}
;;;95     {
000104  e1a04000          MOV      r4,r0
;;;96         if (udev->parent == NULL)
000108  e5940014          LDR      r0,[r4,#0x14]
00010c  e3500000          CMP      r0,#0
000110  1a00000a          BNE      |L1.320|
;;;97         {
;;;98             if (udev->hc_driver)
000114  e594002c          LDR      r0,[r4,#0x2c]
000118  e3500000          CMP      r0,#0
00011c  0a000005          BEQ      |L1.312|
;;;99                 return udev->hc_driver->rthub_port_reset(udev->port_num-1);
000120  e5d42018          LDRB     r2,[r4,#0x18]
000124  e2420001          SUB      r0,r2,#1
000128  e594202c          LDR      r2,[r4,#0x2c]
00012c  e5921024          LDR      r1,[r2,#0x24]
000130  e12fff31          BLX      r1
                  |L1.308|
;;;100            else
;;;101                return USBH_ERR_NOT_FOUND;
;;;102        }
;;;103        else
;;;104        {
;;;105            return udev->parent->port_reset(udev->parent, udev->port_num);
;;;106        }
;;;107    }
000134  e8bd8010          POP      {r4,pc}
                  |L1.312|
000138  e3e00069          MVN      r0,#0x69              ;101
00013c  eafffffc          B        |L1.308|
                  |L1.320|
000140  e5d41018          LDRB     r1,[r4,#0x18]         ;105
000144  e5940014          LDR      r0,[r4,#0x14]         ;105
000148  e5902018          LDR      r2,[r0,#0x18]         ;105
00014c  e12fff32          BLX      r2                    ;105
000150  eafffff7          B        |L1.308|
;;;108    
                          ENDP

                  usbh_suspend PROC
;;;116      */
;;;117    void usbh_suspend()
000154  e92d4010          PUSH     {r4,lr}
;;;118    {
;;;119    #ifdef ENABLE_EHCI
;;;120        int   time_out = 10;   /* ms */
000158  e3a0400a          MOV      r4,#0xa
;;;121    #endif
;;;122    
;;;123    #ifdef ENABLE_OHCI
;;;124        /* set port suspend if connected */
;;;125        if (_ohci->HcRhPortStatus[0] & USBH_HcRhPortStatus_CCS_Msk)
00015c  e59f0358          LDR      r0,|L1.1212|
000160  e5900000          LDR      r0,[r0,#0]  ; _ohci
000164  e5900054          LDR      r0,[r0,#0x54]
000168  e3100001          TST      r0,#1
00016c  0a000003          BEQ      |L1.384|
;;;126            _ohci->HcRhPortStatus[0] = USBH_HcRhPortStatus_PSS_Msk;    /* set port suspend    */
000170  e3a00004          MOV      r0,#4
000174  e59f1340          LDR      r1,|L1.1212|
000178  e5911000          LDR      r1,[r1,#0]  ; _ohci
00017c  e5810054          STR      r0,[r1,#0x54]
                  |L1.384|
;;;127    
;;;128        if (_ohci->HcRhPortStatus[1] & USBH_HcRhPortStatus_CCS_Msk)
000180  e59f0334          LDR      r0,|L1.1212|
000184  e5900000          LDR      r0,[r0,#0]  ; _ohci
000188  e5900058          LDR      r0,[r0,#0x58]
00018c  e3100001          TST      r0,#1
000190  0a000003          BEQ      |L1.420|
;;;129            _ohci->HcRhPortStatus[1] = USBH_HcRhPortStatus_PSS_Msk;    /* set port suspend    */
000194  e3a00004          MOV      r0,#4
000198  e59f131c          LDR      r1,|L1.1212|
00019c  e5911000          LDR      r1,[r1,#0]  ; _ohci
0001a0  e5810058          STR      r0,[r1,#0x58]
                  |L1.420|
;;;130    
;;;131        /* enable Device Remote Wakeup */
;;;132        _ohci->HcRhStatus |= USBH_HcRhStatus_DRWE_Msk;
0001a4  e59f0310          LDR      r0,|L1.1212|
0001a8  e5900000          LDR      r0,[r0,#0]  ; _ohci
0001ac  e5900050          LDR      r0,[r0,#0x50]
0001b0  e3800902          ORR      r0,r0,#0x8000
0001b4  e59f1300          LDR      r1,|L1.1212|
0001b8  e5911000          LDR      r1,[r1,#0]  ; _ohci
0001bc  e5810050          STR      r0,[r1,#0x50]
;;;133    
;;;134        /* enable USBH RHSC interrupt for system wakeup */
;;;135        _ohci->HcInterruptEnable =  USBH_HcInterruptEnable_RHSC_Msk | USBH_HcInterruptEnable_RD_Msk;
0001c0  e3a00048          MOV      r0,#0x48
0001c4  e59f12f0          LDR      r1,|L1.1212|
0001c8  e5911000          LDR      r1,[r1,#0]  ; _ohci
0001cc  e5810010          STR      r0,[r1,#0x10]
;;;136    
;;;137        /* set Host Controller enter suspend state */
;;;138        _ohci->HcControl = (_ohci->HcControl & ~USBH_HcControl_HCFS_Msk) | (3 << USBH_HcControl_HCFS_Pos);
0001d0  e59f02e4          LDR      r0,|L1.1212|
0001d4  e5900000          LDR      r0,[r0,#0]  ; _ohci
0001d8  e5900004          LDR      r0,[r0,#4]
0001dc  e38000c0          ORR      r0,r0,#0xc0
0001e0  e59f12d4          LDR      r1,|L1.1212|
0001e4  e5911000          LDR      r1,[r1,#0]  ; _ohci
0001e8  e5810004          STR      r0,[r1,#4]
;;;139    #endif
;;;140    
;;;141    #ifdef ENABLE_EHCI
;;;142        ehci_UCMDR = _ehci->UCMDR;
0001ec  e59f02cc          LDR      r0,|L1.1216|
0001f0  e5900000          LDR      r0,[r0,#0]  ; _ehci
0001f4  e5900020          LDR      r0,[r0,#0x20]
0001f8  e59f12e0          LDR      r1,|L1.1248|
0001fc  e5810000          STR      r0,[r1,#0]  ; ehci_UCMDR
;;;143    
;;;144        if (_ehci->UPSCR[0] & HSUSBH_UPSCR_PE_Msk)
000200  e59f02b8          LDR      r0,|L1.1216|
000204  e5900000          LDR      r0,[r0,#0]  ; _ehci
000208  e5900064          LDR      r0,[r0,#0x64]
00020c  e3100004          TST      r0,#4
000210  0a000008          BEQ      |L1.568|
;;;145        {
;;;146            _ehci->UPSCR[0] |= HSUSBH_UPSCR_SUSPEND_Msk;
000214  e59f02a4          LDR      r0,|L1.1216|
000218  e5900000          LDR      r0,[r0,#0]  ; _ehci
00021c  e5900064          LDR      r0,[r0,#0x64]
000220  e3800080          ORR      r0,r0,#0x80
000224  e59f1294          LDR      r1,|L1.1216|
000228  e5911000          LDR      r1,[r1,#0]  ; _ehci
00022c  e5810064          STR      r0,[r1,#0x64]
;;;147            delay_us(2000);         /* wait 2 ms */
000230  e3a00e7d          MOV      r0,#0x7d0
000234  ebfffffe          BL       delay_us
                  |L1.568|
;;;148        }
;;;149    
;;;150        if (_ehci->UPSCR[1] & HSUSBH_UPSCR_PE_Msk)
000238  e59f0280          LDR      r0,|L1.1216|
00023c  e5900000          LDR      r0,[r0,#0]  ; _ehci
000240  e5900068          LDR      r0,[r0,#0x68]
000244  e3100004          TST      r0,#4
000248  0a000008          BEQ      |L1.624|
;;;151        {
;;;152            _ehci->UPSCR[1] |= HSUSBH_UPSCR_SUSPEND_Msk;
00024c  e59f026c          LDR      r0,|L1.1216|
000250  e5900000          LDR      r0,[r0,#0]  ; _ehci
000254  e5900068          LDR      r0,[r0,#0x68]
000258  e3800080          ORR      r0,r0,#0x80
00025c  e59f125c          LDR      r1,|L1.1216|
000260  e5911000          LDR      r1,[r1,#0]  ; _ehci
000264  e5810068          STR      r0,[r1,#0x68]
;;;153            delay_us(2000);         /* wait 2 ms */
000268  e3a00e7d          MOV      r0,#0x7d0
00026c  ebfffffe          BL       delay_us
                  |L1.624|
;;;154        }
;;;155    
;;;156        _ehci->UCMDR &= ~(HSUSBH_UCMDR_PSEN_Msk | HSUSBH_UCMDR_ASEN_Msk | HSUSBH_UCMDR_RUN_Msk);
000270  e59f0248          LDR      r0,|L1.1216|
000274  e5900000          LDR      r0,[r0,#0]  ; _ehci
000278  e5900020          LDR      r0,[r0,#0x20]
00027c  e3c00031          BIC      r0,r0,#0x31
000280  e59f1238          LDR      r1,|L1.1216|
000284  e5911000          LDR      r1,[r1,#0]  ; _ehci
000288  e5810020          STR      r0,[r1,#0x20]
;;;157        while (time_out > 0)
00028c  ea00000a          B        |L1.700|
                  |L1.656|
;;;158        {
;;;159            if (!(_ehci->UCMDR & HSUSBH_UCMDR_RUN_Msk) && (_ehci->USTSR & HSUSBH_USTSR_HCHalted_Msk))
000290  e59f0228          LDR      r0,|L1.1216|
000294  e5900000          LDR      r0,[r0,#0]  ; _ehci
000298  e5900020          LDR      r0,[r0,#0x20]
00029c  e3100001          TST      r0,#1
0002a0  1a000005          BNE      |L1.700|
0002a4  e59f0214          LDR      r0,|L1.1216|
0002a8  e5900000          LDR      r0,[r0,#0]  ; _ehci
0002ac  e5900024          LDR      r0,[r0,#0x24]
0002b0  e3100a01          TST      r0,#0x1000
0002b4  0a000000          BEQ      |L1.700|
;;;160            {
;;;161                break;
0002b8  ea000001          B        |L1.708|
                  |L1.700|
0002bc  e3540000          CMP      r4,#0                 ;157
0002c0  cafffff2          BGT      |L1.656|
                  |L1.708|
0002c4  e1a00000          MOV      r0,r0
;;;162            }
;;;163        }
;;;164        if (time_out == 0)
0002c8  e3540000          CMP      r4,#0
0002cc  1a000001          BNE      |L1.728|
;;;165        {
;;;166            USB_error("usbh_suspend - RUN/HCHalted error!\n");
0002d0  e28f0f83          ADR      r0,|L1.1252|
0002d4  ebfffffe          BL       sysprintf
                  |L1.728|
;;;167        }
;;;168        delay_us(100);
0002d8  e3a00064          MOV      r0,#0x64
0002dc  ebfffffe          BL       delay_us
;;;169    #endif
;;;170    }
0002e0  e8bd8010          POP      {r4,pc}
;;;171    
                          ENDP

                  usbh_resume PROC
;;;176      */
;;;177    void usbh_resume(void)
0002e4  e92d4010          PUSH     {r4,lr}
;;;178    {
;;;179    #ifdef ENABLE_OHCI
;;;180        _ohci->HcControl = (_ohci->HcControl & ~USBH_HcControl_HCFS_Msk) | (2 << USBH_HcControl_HCFS_Pos);
0002e8  e59f01cc          LDR      r0,|L1.1212|
0002ec  e5900000          LDR      r0,[r0,#0]  ; _ohci
0002f0  e5900004          LDR      r0,[r0,#4]
0002f4  e3c000c0          BIC      r0,r0,#0xc0
0002f8  e3800080          ORR      r0,r0,#0x80
0002fc  e59f11b8          LDR      r1,|L1.1212|
000300  e5911000          LDR      r1,[r1,#0]  ; _ohci
000304  e5810004          STR      r0,[r1,#4]
;;;181    
;;;182        if (_ohci->HcRhPortStatus[0] & USBH_HcRhPortStatus_PSS_Msk)
000308  e59f01ac          LDR      r0,|L1.1212|
00030c  e5900000          LDR      r0,[r0,#0]  ; _ohci
000310  e5900054          LDR      r0,[r0,#0x54]
000314  e3100004          TST      r0,#4
000318  0a000003          BEQ      |L1.812|
;;;183            _ohci->HcRhPortStatus[0] = USBH_HcRhPortStatus_POCI_Msk;   /* clear suspend status */
00031c  e3a00008          MOV      r0,#8
000320  e59f1194          LDR      r1,|L1.1212|
000324  e5911000          LDR      r1,[r1,#0]  ; _ohci
000328  e5810054          STR      r0,[r1,#0x54]
                  |L1.812|
;;;184        if (_ohci->HcRhPortStatus[1] & USBH_HcRhPortStatus_PSS_Msk)
00032c  e59f0188          LDR      r0,|L1.1212|
000330  e5900000          LDR      r0,[r0,#0]  ; _ohci
000334  e5900058          LDR      r0,[r0,#0x58]
000338  e3100004          TST      r0,#4
00033c  0a000003          BEQ      |L1.848|
;;;185            _ohci->HcRhPortStatus[1] = USBH_HcRhPortStatus_POCI_Msk;   /* clear suspend status */
000340  e3a00008          MOV      r0,#8
000344  e59f1170          LDR      r1,|L1.1212|
000348  e5911000          LDR      r1,[r1,#0]  ; _ohci
00034c  e5810058          STR      r0,[r1,#0x58]
                  |L1.848|
;;;186    
;;;187        delay_us(30000);                       /* wait at least 20ms for Host to resume device */
000350  e59f01b0          LDR      r0,|L1.1288|
000354  ebfffffe          BL       delay_us
;;;188    #endif
;;;189    
;;;190    #ifdef ENABLE_EHCI
;;;191        _ehci->UCMDR = ehci_UCMDR;
000358  e59f0180          LDR      r0,|L1.1248|
00035c  e5900000          LDR      r0,[r0,#0]  ; ehci_UCMDR
000360  e59f1158          LDR      r1,|L1.1216|
000364  e5911000          LDR      r1,[r1,#0]  ; _ehci
000368  e5810020          STR      r0,[r1,#0x20]
;;;192    
;;;193        if (_ehci->UPSCR[0] & HSUSBH_UPSCR_PE_Msk)
00036c  e59f014c          LDR      r0,|L1.1216|
000370  e5900000          LDR      r0,[r0,#0]  ; _ehci
000374  e5900064          LDR      r0,[r0,#0x64]
000378  e3100004          TST      r0,#4
00037c  0a00000f          BEQ      |L1.960|
;;;194        {
;;;195            _ehci->UPSCR[0] |= HSUSBH_UPSCR_FPR_Msk;
000380  e59f0138          LDR      r0,|L1.1216|
000384  e5900000          LDR      r0,[r0,#0]  ; _ehci
000388  e5900064          LDR      r0,[r0,#0x64]
00038c  e3800040          ORR      r0,r0,#0x40
000390  e59f1128          LDR      r1,|L1.1216|
000394  e5911000          LDR      r1,[r1,#0]  ; _ehci
000398  e5810064          STR      r0,[r1,#0x64]
;;;196            delay_us(20000);                         /* keep resume signal for 20 ms */
00039c  e59f0168          LDR      r0,|L1.1292|
0003a0  ebfffffe          BL       delay_us
;;;197            _ehci->UPSCR[0] &= ~HSUSBH_UPSCR_FPR_Msk;
0003a4  e59f0114          LDR      r0,|L1.1216|
0003a8  e5900000          LDR      r0,[r0,#0]  ; _ehci
0003ac  e5900064          LDR      r0,[r0,#0x64]
0003b0  e3c00040          BIC      r0,r0,#0x40
0003b4  e59f1104          LDR      r1,|L1.1216|
0003b8  e5911000          LDR      r1,[r1,#0]  ; _ehci
0003bc  e5810064          STR      r0,[r1,#0x64]
                  |L1.960|
;;;198        }
;;;199    
;;;200        if (_ehci->UPSCR[1] & HSUSBH_UPSCR_PE_Msk)
0003c0  e59f00f8          LDR      r0,|L1.1216|
0003c4  e5900000          LDR      r0,[r0,#0]  ; _ehci
0003c8  e5900068          LDR      r0,[r0,#0x68]
0003cc  e3100004          TST      r0,#4
0003d0  0a00000f          BEQ      |L1.1044|
;;;201        {
;;;202            _ehci->UPSCR[1] |= HSUSBH_UPSCR_FPR_Msk;
0003d4  e59f00e4          LDR      r0,|L1.1216|
0003d8  e5900000          LDR      r0,[r0,#0]  ; _ehci
0003dc  e5900068          LDR      r0,[r0,#0x68]
0003e0  e3800040          ORR      r0,r0,#0x40
0003e4  e59f10d4          LDR      r1,|L1.1216|
0003e8  e5911000          LDR      r1,[r1,#0]  ; _ehci
0003ec  e5810068          STR      r0,[r1,#0x68]
;;;203            delay_us(20000);                         /* keep resume signal for 20 ms */
0003f0  e59f0114          LDR      r0,|L1.1292|
0003f4  ebfffffe          BL       delay_us
;;;204            _ehci->UPSCR[1] &= ~HSUSBH_UPSCR_FPR_Msk;
0003f8  e59f00c0          LDR      r0,|L1.1216|
0003fc  e5900000          LDR      r0,[r0,#0]  ; _ehci
000400  e5900068          LDR      r0,[r0,#0x68]
000404  e3c00040          BIC      r0,r0,#0x40
000408  e59f10b0          LDR      r1,|L1.1216|
00040c  e5911000          LDR      r1,[r1,#0]  ; _ehci
000410  e5810068          STR      r0,[r1,#0x68]
                  |L1.1044|
;;;205        }
;;;206        delay_us(1000);
000414  e3a00ffa          MOV      r0,#0x3e8
000418  ebfffffe          BL       delay_us
;;;207    #endif
;;;208    }
00041c  e8bd8010          POP      {r4,pc}
;;;209    
                          ENDP

                  usbh_register_driver PROC
;;;221      */
;;;222    int  usbh_register_driver(UDEV_DRV_T *udrv)
000420  e1a02000          MOV      r2,r0
;;;223    {
;;;224        int   i;
;;;225    
;;;226        for (i = 0; i < MAX_UDEV_DRIVER; i++)
000424  e3a01000          MOV      r1,#0
000428  ea00000e          B        |L1.1128|
                  |L1.1068|
;;;227        {
;;;228            if (_drivers[i] == udrv)
00042c  e59f0090          LDR      r0,|L1.1220|
000430  e7900101          LDR      r0,[r0,r1,LSL #2]
000434  e1500002          CMP      r0,r2
000438  1a000001          BNE      |L1.1092|
;;;229                return 0;                  /* already registered, do nothing */
00043c  e3a00000          MOV      r0,#0
                  |L1.1088|
;;;230    
;;;231            if (_drivers[i] == NULL)
;;;232            {
;;;233                _drivers[i] = udrv;        /* register this driver */
;;;234                return 0;
;;;235            }
;;;236        }
;;;237        return USBH_ERR_MEMORY_OUT;        /* reached MAX_UDEV_DRIVER limitation, aborted */
;;;238    }
000440  e12fff1e          BX       lr
                  |L1.1092|
000444  e59f0078          LDR      r0,|L1.1220|
000448  e7900101          LDR      r0,[r0,r1,LSL #2]     ;231
00044c  e3500000          CMP      r0,#0                 ;231
000450  1a000003          BNE      |L1.1124|
000454  e59f0068          LDR      r0,|L1.1220|
000458  e7802101          STR      r2,[r0,r1,LSL #2]     ;233
00045c  e3a00000          MOV      r0,#0                 ;234
000460  eafffff6          B        |L1.1088|
                  |L1.1124|
000464  e2811001          ADD      r1,r1,#1              ;226
                  |L1.1128|
000468  e3510008          CMP      r1,#8                 ;226
00046c  baffffee          BLT      |L1.1068|
000470  e3e00009          MVN      r0,#9                 ;237
000474  eafffff1          B        |L1.1088|
;;;239    
                          ENDP

                  usbh_quit_utr PROC
;;;369      */
;;;370    int usbh_quit_utr(UTR_T *utr)
000478  e92d4010          PUSH     {r4,lr}
;;;371    {
00047c  e1a04000          MOV      r4,r0
;;;372        if (!utr || !utr->udev)
000480  e3540000          CMP      r4,#0
000484  0a000002          BEQ      |L1.1172|
000488  e5940000          LDR      r0,[r4,#0]
00048c  e3500000          CMP      r0,#0
000490  1a000001          BNE      |L1.1180|
                  |L1.1172|
;;;373            return USBH_ERR_NOT_FOUND;
000494  e3e00069          MVN      r0,#0x69
                  |L1.1176|
;;;374    
;;;375        return utr->udev->hc_driver->quit_xfer(utr, NULL);
;;;376    }
000498  e8bd8010          POP      {r4,pc}
                  |L1.1180|
00049c  e5940000          LDR      r0,[r4,#0]            ;375
0004a0  e590002c          LDR      r0,[r0,#0x2c]         ;375
0004a4  e3a01000          MOV      r1,#0                 ;375
0004a8  e5902020          LDR      r2,[r0,#0x20]         ;375
0004ac  e1a00004          MOV      r0,r4                 ;375
0004b0  e12fff32          BLX      r2                    ;375
0004b4  eafffff7          B        |L1.1176|
                  |L1.1208|
                          DCD      0xb0007000
                  |L1.1212|
                          DCD      _ohci
                  |L1.1216|
                          DCD      _ehci
                  |L1.1220|
                          DCD      _drivers
                  |L1.1224|
                          DCD      g_conn_func
                  |L1.1228|
                          DCD      g_disconn_func
                  |L1.1232|
                          DCD      OHCI_IRQHandler
                  |L1.1236|
                          DCD      ohci_driver
                  |L1.1240|
                          DCD      EHCI_IRQHandler
                  |L1.1244|
                          DCD      ehci_driver
                  |L1.1248|
                          DCD      ehci_UCMDR
                  |L1.1252|
0004e4  75736268          DCB      "usbh_suspend - RUN/HCHalted error!\n",0
0004e8  5f737573
0004ec  70656e64
0004f0  202d2052
0004f4  554e2f48
0004f8  4348616c
0004fc  74656420
000500  6572726f
000504  72210a00
                  |L1.1288|
                          DCD      0x00007530
                  |L1.1292|
                          DCD      0x00004e20
                          ENDP

                  usbh_ctrl_xfer PROC
;;;256      */
;;;257    int usbh_ctrl_xfer(UDEV_T *udev, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
000510  e92d5ff0          PUSH     {r4-r12,lr}
;;;258                       uint16_t wLength, uint8_t *buff, uint32_t *xfer_len, uint32_t timeout)
;;;259    {
000514  e1a05000          MOV      r5,r0
000518  e1a08001          MOV      r8,r1
00051c  e1a09002          MOV      r9,r2
000520  e1a0a003          MOV      r10,r3
000524  e59db034          LDR      r11,[sp,#0x34]
;;;260        UTR_T      *utr;
;;;261        uint32_t   t0;
;;;262        int        status;
;;;263    
;;;264        *xfer_len = 0;
000528  e3a00000          MOV      r0,#0
00052c  e58b0000          STR      r0,[r11,#0]
;;;265    
;;;266        //if (check_device(udev))
;;;267        //    return USBH_ERR_INVALID_PARAM;
;;;268    
;;;269        utr = alloc_utr(udev);
000530  e1a00005          MOV      r0,r5
000534  ebfffffe          BL       alloc_utr
000538  e1a04000          MOV      r4,r0
;;;270        if (utr == NULL)
00053c  e3540000          CMP      r4,#0
000540  1a000001          BNE      |L1.1356|
;;;271            return USBH_ERR_MEMORY_OUT;
000544  e3e00009          MVN      r0,#9
                  |L1.1352|
;;;272    
;;;273        utr->setup.bmRequestType = bmRequestType;
;;;274        utr->setup.bRequest   = bRequest;
;;;275        utr->setup.wValue     = wValue;
;;;276        utr->setup.wIndex     = wIndex;
;;;277        utr->setup.wLength    = wLength;
;;;278    
;;;279        utr->buff = buff;
;;;280        utr->data_len = wLength;
;;;281        utr->bIsTransferDone = 0;
;;;282        status = udev->hc_driver->ctrl_xfer(utr);
;;;283        if (status < 0)
;;;284        {
;;;285            udev->ep0.hw_pipe = NULL;
;;;286            free_utr(utr);
;;;287            return status;
;;;288        }
;;;289    
;;;290        t0 = get_ticks();
;;;291        while (utr->bIsTransferDone == 0)
;;;292        {
;;;293            if (get_ticks() - t0 > timeout)
;;;294            {
;;;295                usbh_quit_utr(utr);
;;;296                free_utr(utr);
;;;297                udev->ep0.hw_pipe = NULL;
;;;298                return USBH_ERR_TIMEOUT;
;;;299            }
;;;300        }
;;;301    
;;;302        status = utr->status;
;;;303    
;;;304        if (status == 0)
;;;305        {
;;;306            *xfer_len = utr->xfer_len;
;;;307        }
;;;308        free_utr(utr);
;;;309    
;;;310        return status;
;;;311    }
000548  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1356|
00054c  e5c48004          STRB     r8,[r4,#4]            ;273
000550  e5c49005          STRB     r9,[r4,#5]            ;274
000554  e1c4a0b6          STRH     r10,[r4,#6]           ;275
000558  e59d0028          LDR      r0,[sp,#0x28]         ;276
00055c  e1c400b8          STRH     r0,[r4,#8]            ;276
000560  e59d002c          LDR      r0,[sp,#0x2c]         ;277
000564  e1c400ba          STRH     r0,[r4,#0xa]          ;277
000568  e59d0030          LDR      r0,[sp,#0x30]         ;279
00056c  e5840010          STR      r0,[r4,#0x10]         ;279
000570  e59d002c          LDR      r0,[sp,#0x2c]         ;280
000574  e5840018          STR      r0,[r4,#0x18]         ;280
000578  e3a00000          MOV      r0,#0                 ;281
00057c  e5c40014          STRB     r0,[r4,#0x14]         ;281
000580  e595002c          LDR      r0,[r5,#0x2c]         ;282
000584  e5901010          LDR      r1,[r0,#0x10]         ;282
000588  e1a00004          MOV      r0,r4                 ;282
00058c  e12fff31          BLX      r1                    ;282
000590  e1a06000          MOV      r6,r0                 ;282
000594  e3560000          CMP      r6,#0                 ;283
000598  aa000005          BGE      |L1.1460|
00059c  e3a00000          MOV      r0,#0                 ;285
0005a0  e5850028          STR      r0,[r5,#0x28]         ;285
0005a4  e1a00004          MOV      r0,r4                 ;286
0005a8  ebfffffe          BL       free_utr
0005ac  e1a00006          MOV      r0,r6                 ;287
0005b0  eaffffe4          B        |L1.1352|
                  |L1.1460|
0005b4  ebfffffe          BL       get_ticks
0005b8  e1a07000          MOV      r7,r0                 ;290
0005bc  ea00000c          B        |L1.1524|
                  |L1.1472|
0005c0  ebfffffe          BL       get_ticks
0005c4  e0401007          SUB      r1,r0,r7              ;293
0005c8  e59d0038          LDR      r0,[sp,#0x38]         ;293
0005cc  e1510000          CMP      r1,r0                 ;293
0005d0  9a000007          BLS      |L1.1524|
0005d4  e1a00004          MOV      r0,r4                 ;295
0005d8  ebfffffe          BL       usbh_quit_utr
0005dc  e1a00004          MOV      r0,r4                 ;296
0005e0  ebfffffe          BL       free_utr
0005e4  e3a00000          MOV      r0,#0                 ;297
0005e8  e5850028          STR      r0,[r5,#0x28]         ;297
0005ec  e3e000ca          MVN      r0,#0xca              ;298
0005f0  eaffffd4          B        |L1.1352|
                  |L1.1524|
0005f4  e5d40014          LDRB     r0,[r4,#0x14]         ;291
0005f8  e3500000          CMP      r0,#0                 ;291
0005fc  0affffef          BEQ      |L1.1472|
000600  e5946078          LDR      r6,[r4,#0x78]         ;302
000604  e3560000          CMP      r6,#0                 ;304
000608  1a000001          BNE      |L1.1556|
00060c  e594001c          LDR      r0,[r4,#0x1c]         ;306
000610  e58b0000          STR      r0,[r11,#0]           ;306
                  |L1.1556|
000614  e1a00004          MOV      r0,r4                 ;308
000618  ebfffffe          BL       free_utr
00061c  e1a00006          MOV      r0,r6                 ;310
000620  eaffffc8          B        |L1.1352|
;;;312    
                          ENDP

                  usbh_bulk_xfer PROC
;;;321      */
;;;322    int usbh_bulk_xfer(UTR_T *utr)
000624  e92d4010          PUSH     {r4,lr}
;;;323    {
000628  e1a04000          MOV      r4,r0
;;;324        return utr->udev->hc_driver->bulk_xfer(utr);
00062c  e5940000          LDR      r0,[r4,#0]
000630  e590002c          LDR      r0,[r0,#0x2c]
000634  e5901014          LDR      r1,[r0,#0x14]
000638  e1a00004          MOV      r0,r4
00063c  e12fff31          BLX      r1
;;;325    }
000640  e8bd8010          POP      {r4,pc}
;;;326    
                          ENDP

                  usbh_int_xfer PROC
;;;334      */
;;;335    int usbh_int_xfer(UTR_T *utr)
000644  e92d4010          PUSH     {r4,lr}
;;;336    {
000648  e1a04000          MOV      r4,r0
;;;337        sysFlushCache(I_D_CACHE);
00064c  e3a00008          MOV      r0,#8
000650  ebfffffe          BL       sysFlushCache
;;;338        return utr->udev->hc_driver->int_xfer(utr);
000654  e5940000          LDR      r0,[r4,#0]
000658  e590002c          LDR      r0,[r0,#0x2c]
00065c  e5901018          LDR      r1,[r0,#0x18]
000660  e1a00004          MOV      r0,r4
000664  e12fff31          BLX      r1
;;;339    }
000668  e8bd8010          POP      {r4,pc}
;;;340    
                          ENDP

                  usbh_iso_xfer PROC
;;;348      */
;;;349    int usbh_iso_xfer(UTR_T *utr)
00066c  e92d4010          PUSH     {r4,lr}
;;;350    {
000670  e1a04000          MOV      r4,r0
;;;351        if (utr->udev->hc_driver == NULL)
000674  e5940000          LDR      r0,[r4,#0]
000678  e590002c          LDR      r0,[r0,#0x2c]
00067c  e3500000          CMP      r0,#0
000680  1a000005          BNE      |L1.1692|
;;;352        {
;;;353            sysprintf("hc_driver - 0x%x\n", (int)utr->udev->hc_driver);
000684  e5940000          LDR      r0,[r4,#0]
000688  e590102c          LDR      r1,[r0,#0x2c]
00068c  e28f0f92          ADR      r0,|L1.2268|
000690  ebfffffe          BL       sysprintf
;;;354            return -1;
000694  e3e00000          MVN      r0,#0
                  |L1.1688|
;;;355        }
;;;356        if (utr->udev->hc_driver->iso_xfer == NULL)
;;;357        {
;;;358            sysprintf("iso_xfer - 0x%x\n", (int)utr->udev->hc_driver->iso_xfer);
;;;359            return -1;
;;;360        }
;;;361        return utr->udev->hc_driver->iso_xfer(utr);
;;;362    }
000698  e8bd8010          POP      {r4,pc}
                  |L1.1692|
00069c  e5940000          LDR      r0,[r4,#0]            ;356
0006a0  e590002c          LDR      r0,[r0,#0x2c]         ;356
0006a4  e590001c          LDR      r0,[r0,#0x1c]         ;356
0006a8  e3500000          CMP      r0,#0                 ;356
0006ac  1a000006          BNE      |L1.1740|
0006b0  e5940000          LDR      r0,[r4,#0]            ;358
0006b4  e590002c          LDR      r0,[r0,#0x2c]         ;358
0006b8  e590101c          LDR      r1,[r0,#0x1c]         ;358
0006bc  e28f0f8b          ADR      r0,|L1.2288|
0006c0  ebfffffe          BL       sysprintf
0006c4  e3e00000          MVN      r0,#0                 ;359
0006c8  eafffff2          B        |L1.1688|
                  |L1.1740|
0006cc  e5940000          LDR      r0,[r4,#0]            ;361
0006d0  e590002c          LDR      r0,[r0,#0x2c]         ;361
0006d4  e590101c          LDR      r1,[r0,#0x1c]         ;361
0006d8  e1a00004          MOV      r0,r4                 ;361
0006dc  e12fff31          BLX      r1                    ;361
0006e0  eaffffec          B        |L1.1688|
;;;363    
                          ENDP

                  usbh_quit_xfer PROC
;;;385      */
;;;386    int usbh_quit_xfer(UDEV_T *udev, EP_INFO_T *ep)
0006e4  e92d4070          PUSH     {r4-r6,lr}
;;;387    {
0006e8  e1a04000          MOV      r4,r0
0006ec  e1a05001          MOV      r5,r1
;;;388        return udev->hc_driver->quit_xfer(NULL, ep);
0006f0  e594002c          LDR      r0,[r4,#0x2c]
0006f4  e1a01005          MOV      r1,r5
0006f8  e5902020          LDR      r2,[r0,#0x20]
0006fc  e3a00000          MOV      r0,#0
000700  e12fff32          BLX      r2
;;;389    }
000704  e8bd8070          POP      {r4-r6,pc}
;;;390    
                          ENDP

                  dump_device_descriptor PROC
;;;391    
;;;392    void  dump_device_descriptor(DESC_DEV_T *desc)
000708  e12fff1e          BX       lr
;;;393    {
;;;394        USB_debug("\n[Device Descriptor]\n");
;;;395        USB_debug("----------------------------------------------\n");
;;;396        USB_debug("  Length              = %2d\n",  desc->bLength);
;;;397        USB_debug("  DescriptorType      = 0x%02x\n", desc->bDescriptorType);
;;;398        USB_debug("  USB version         = %x.%02x\n",
;;;399                  desc->bcdUSB >> 8, desc->bcdUSB & 0xff);
;;;400        USB_debug("  Vendor:Product      = %04x:%04x\n",
;;;401                  desc->idVendor, desc->idProduct);
;;;402        USB_debug("  MaxPacketSize0      = %d\n",   desc->bMaxPacketSize0);
;;;403        USB_debug("  NumConfigurations   = %d\n",   desc->bNumConfigurations);
;;;404        USB_debug("  Device version      = %x.%02x\n",
;;;405                  desc->bcdDevice >> 8, desc->bcdDevice & 0xff);
;;;406        USB_debug("  Device Class:SubClass:Protocol = %02x:%02x:%02x\n",
;;;407                  desc->bDeviceClass, desc->bDeviceSubClass, desc->bDeviceProtocol);
;;;408    }
;;;409    
                          ENDP

                  usbh_dump_interface_descriptor PROC
;;;410    void usbh_dump_interface_descriptor(DESC_IF_T *if_desc)
00070c  e12fff1e          BX       lr
;;;411    {
;;;412        USB_debug("\n    [Interface Descriptor]\n");
;;;413        USB_debug("    ----------------------------------------------\n");
;;;414        USB_debug("      Length              = %2d\n",  if_desc->bLength);
;;;415        USB_debug("      DescriptorType      = %02x\n", if_desc->bDescriptorType);
;;;416        USB_debug("      bInterfaceNumber    = %d\n", if_desc->bInterfaceNumber);
;;;417        USB_debug("      bAlternateSetting   = %d\n", if_desc->bAlternateSetting);
;;;418        USB_debug("      bNumEndpoints       = %d\n", if_desc->bNumEndpoints);
;;;419        USB_debug("      bInterfaceClass     = 0x%02x\n", if_desc->bInterfaceClass);
;;;420        USB_debug("      bInterfaceSubClass  = 0x%02x\n", if_desc->bInterfaceSubClass);
;;;421        USB_debug("      bInterfaceProtocol  = 0x%02x\n", if_desc->bInterfaceProtocol);
;;;422        USB_debug("      iInterface          = %d\n", if_desc->iInterface);
;;;423    }
;;;424    
                          ENDP

                  usbh_dump_endpoint_descriptor PROC
;;;425    void usbh_dump_endpoint_descriptor(DESC_EP_T *ep_desc)
000710  e12fff1e          BX       lr
;;;426    {
;;;427        USB_debug("\n        [Endpoint Descriptor]\n");
;;;428        USB_debug("        ----------------------------------------------\n");
;;;429        USB_debug("          Length              = %2d\n",  ep_desc->bLength);
;;;430        USB_debug("          DescriptorType      = %02x\n", ep_desc->bDescriptorType);
;;;431        USB_debug("          bEndpointAddress    = 0x%02x\n", ep_desc->bEndpointAddress);
;;;432        USB_debug("          bmAttributes        = 0x%02x\n", ep_desc->bmAttributes);
;;;433        USB_debug("          wMaxPacketSize      = %d\n", ep_desc->wMaxPacketSize);
;;;434        USB_debug("          bInterval           = %d\n", ep_desc->bInterval);
;;;435        USB_debug("          bRefresh            = %d\n", ep_desc->bRefresh);
;;;436        USB_debug("          bSynchAddress       = %d\n", ep_desc->bSynchAddress);
;;;437    }
;;;438    
                          ENDP

                  dump_config_descriptor PROC
;;;439    void  dump_config_descriptor(DESC_CONF_T *desc)
000714  e92d4010          PUSH     {r4,lr}
;;;440    {
000718  e1a02000          MOV      r2,r0
;;;441        uint8_t     *bptr = (uint8_t *)desc;
00071c  e1a01002          MOV      r1,r2
;;;442        DESC_HDR_T  *hdr;
;;;443        int         tlen = desc->wTotalLength;
000720  e5d20003          LDRB     r0,[r2,#3]
000724  e5d2c002          LDRB     r12,[r2,#2]
000728  e18c3400          ORR      r3,r12,r0,LSL #8
;;;444    
;;;445        while (tlen > 0)
00072c  ea00001d          B        |L1.1960|
                  |L1.1840|
;;;446        {
;;;447            switch (bptr[1])
000730  e5d10001          LDRB     r0,[r1,#1]
000734  e3500002          CMP      r0,#2
000738  0a000004          BEQ      |L1.1872|
00073c  e3500004          CMP      r0,#4
000740  0a000004          BEQ      |L1.1880|
000744  e3500005          CMP      r0,#5
000748  1a00000a          BNE      |L1.1912|
00074c  ea000005          B        |L1.1896|
                  |L1.1872|
;;;448            {
;;;449            case USB_DT_CONFIGURATION:
000750  e1a00000          MOV      r0,r0
;;;450                USB_debug("\n[Configuration Descriptor]\n");
;;;451                USB_debug("----------------------------------------------\n");
;;;452                USB_debug("  Length              = %2d\n",  desc->bLength);
;;;453                USB_debug("  DescriptorType      = %02x\n", desc->bDescriptorType);
;;;454                USB_debug("  wTotalLength        = %2d\n", desc->wTotalLength);
;;;455                USB_debug("  bNumInterfaces      = %d\n", desc->bNumInterfaces);
;;;456                USB_debug("  bConfigurationValue = %d\n", desc->bConfigurationValue);
;;;457                USB_debug("  iConfiguration      = %d\n", desc->iConfiguration);
;;;458                USB_debug("  bmAttributes        = 0x%02x\n", desc->bmAttributes);
;;;459                USB_debug("  MaxPower            = %d\n", desc->MaxPower);
;;;460                break;
000754  ea00000a          B        |L1.1924|
                  |L1.1880|
;;;461    
;;;462            case USB_DT_INTERFACE:
000758  e1a00000          MOV      r0,r0
;;;463                usbh_dump_interface_descriptor((DESC_IF_T *)bptr);
00075c  e1a00001          MOV      r0,r1
000760  ebfffffe          BL       usbh_dump_interface_descriptor
;;;464                break;
000764  ea000006          B        |L1.1924|
                  |L1.1896|
;;;465    
;;;466            case USB_DT_ENDPOINT:
000768  e1a00000          MOV      r0,r0
;;;467                usbh_dump_endpoint_descriptor((DESC_EP_T *)bptr);
00076c  e1a00001          MOV      r0,r1
000770  ebfffffe          BL       usbh_dump_endpoint_descriptor
;;;468                break;
000774  ea000002          B        |L1.1924|
                  |L1.1912|
;;;469    
;;;470            default:
000778  e1a00000          MOV      r0,r0
;;;471                hdr = (DESC_HDR_T *)bptr;
00077c  e1a04001          MOV      r4,r1
;;;472                USB_debug("\n!![Unknown Descriptor]\n");
;;;473                USB_debug("----------------------------------------------\n");
;;;474                USB_debug("Length              = %2d\n",  hdr->bLength);
;;;475                USB_debug("DescriptorType      = %02x\n", hdr->bDescriptorType);
;;;476                break;
000780  e1a00000          MOV      r0,r0
                  |L1.1924|
000784  e1a00000          MOV      r0,r0                 ;460
;;;477            }
;;;478            if (bptr[0] == 0)
000788  e5d10000          LDRB     r0,[r1,#0]
00078c  e3500000          CMP      r0,#0
000790  1a000000          BNE      |L1.1944|
;;;479                break;
000794  ea000005          B        |L1.1968|
                  |L1.1944|
;;;480            tlen -= bptr[0];
000798  e5d10000          LDRB     r0,[r1,#0]
00079c  e0433000          SUB      r3,r3,r0
;;;481            bptr += bptr[0];
0007a0  e5d10000          LDRB     r0,[r1,#0]
0007a4  e0811000          ADD      r1,r1,r0
                  |L1.1960|
0007a8  e3530000          CMP      r3,#0                 ;445
0007ac  caffffdf          BGT      |L1.1840|
                  |L1.1968|
0007b0  e1a00000          MOV      r0,r0                 ;479
;;;482        }
;;;483    }
0007b4  e8bd8010          POP      {r4,pc}
;;;484    
                          ENDP

                  usbh_set_address PROC
;;;490     */
;;;491    int usbh_set_address(UDEV_T *udev)
0007b8  e92d4070          PUSH     {r4-r6,lr}
;;;492    {
0007bc  e24dd018          SUB      sp,sp,#0x18
0007c0  e1a05000          MOV      r5,r0
;;;493        uint32_t  read_len;
;;;494        int       dev_num, ret;
;;;495    
;;;496        if (udev->dev_num != 0)
0007c4  e5d50019          LDRB     r0,[r5,#0x19]
0007c8  e3500000          CMP      r0,#0
0007cc  0a000002          BEQ      |L1.2012|
;;;497            return USBH_ERR_SET_DEV_ADDR;
0007d0  e3e0008a          MVN      r0,#0x8a
                  |L1.2004|
0007d4  e28dd018          ADD      sp,sp,#0x18
;;;498    
;;;499        dev_num = alloc_dev_address();
;;;500    
;;;501        /*------------------------------------------------------------------------------------*/
;;;502        /* Issue SET ADDRESS command to set device address                                    */
;;;503        /*------------------------------------------------------------------------------------*/
;;;504        ret = usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
;;;505                             USB_REQ_SET_ADDRESS, dev_num, 0, 0,
;;;506                             NULL, &read_len, 100);
;;;507        if (ret < 0)
;;;508        {
;;;509            free_dev_address(dev_num);
;;;510            return ret;
;;;511        }
;;;512    
;;;513        udev->dev_num = dev_num;
;;;514    
;;;515        return 0;
;;;516    }
0007d8  e8bd8070          POP      {r4-r6,pc}
                  |L1.2012|
0007dc  ebfffffe          BL       alloc_dev_address
0007e0  e1a04000          MOV      r4,r0                 ;499
0007e4  e3a00064          MOV      r0,#0x64              ;504
0007e8  e28d1014          ADD      r1,sp,#0x14           ;504
0007ec  e3a02000          MOV      r2,#0                 ;504
0007f0  e58d2004          STR      r2,[sp,#4]            ;504
0007f4  e58d0010          STR      r0,[sp,#0x10]         ;504
0007f8  e58d100c          STR      r1,[sp,#0xc]          ;504
0007fc  e58d2008          STR      r2,[sp,#8]            ;504
000800  e1a03804          LSL      r3,r4,#16             ;504
000804  e1a03823          LSR      r3,r3,#16             ;504
000808  e58d2000          STR      r2,[sp,#0]            ;504
00080c  e3a02005          MOV      r2,#5                 ;504
000810  e3a01000          MOV      r1,#0                 ;504
000814  e1a00005          MOV      r0,r5                 ;504
000818  ebfffffe          BL       usbh_ctrl_xfer
00081c  e1a06000          MOV      r6,r0                 ;504
000820  e3560000          CMP      r6,#0                 ;507
000824  aa000003          BGE      |L1.2104|
000828  e1a00004          MOV      r0,r4                 ;509
00082c  ebfffffe          BL       free_dev_address
000830  e1a00006          MOV      r0,r6                 ;510
000834  eaffffe6          B        |L1.2004|
                  |L1.2104|
000838  e5c54019          STRB     r4,[r5,#0x19]         ;513
00083c  e3a00000          MOV      r0,#0                 ;515
000840  eaffffe3          B        |L1.2004|
;;;517    
                          ENDP

                  usbh_set_configuration PROC
;;;523     */
;;;524    int usbh_set_configuration(UDEV_T *udev, uint8_t conf_val)
000844  e92d4070          PUSH     {r4-r6,lr}
;;;525    {
000848  e24dd018          SUB      sp,sp,#0x18
00084c  e1a04000          MOV      r4,r0
000850  e1a05001          MOV      r5,r1
;;;526        uint32_t  read_len;
;;;527        int       ret;
;;;528    
;;;529        /* Current configuration is the same. Do nothing. */
;;;530        if (udev->cur_conf == conf_val)
000854  e1d401da          LDRSB    r0,[r4,#0x1a]
000858  e1500005          CMP      r0,r5
00085c  1a000002          BNE      |L1.2156|
;;;531            return 0;
000860  e3a00000          MOV      r0,#0
                  |L1.2148|
000864  e28dd018          ADD      sp,sp,#0x18
;;;532    
;;;533        /* Set another configuration is currently not supported! */
;;;534        if (udev->cur_conf != -1)
;;;535            return USBH_ERR_SET_CONFIG;
;;;536    
;;;537        /*------------------------------------------------------------------------------------*/
;;;538        /* Issue SET CONFIGURATION command to select device configuration                     */
;;;539        /*------------------------------------------------------------------------------------*/
;;;540        ret = usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
;;;541                             USB_REQ_SET_CONFIGURATION, conf_val, 0, 0,
;;;542                             NULL, &read_len, 300);
;;;543        if (ret < 0)
;;;544            return ret;
;;;545    
;;;546        udev->cur_conf = (int8_t)conf_val;
;;;547    
;;;548        return 0;
;;;549    }
000868  e8bd8070          POP      {r4-r6,pc}
                  |L1.2156|
00086c  e1d401da          LDRSB    r0,[r4,#0x1a]         ;534
000870  e3700001          CMN      r0,#1                 ;534
000874  0a000001          BEQ      |L1.2176|
000878  e3e00096          MVN      r0,#0x96              ;535
00087c  eafffff8          B        |L1.2148|
                  |L1.2176|
000880  e3a00f4b          MOV      r0,#0x12c             ;540
000884  e28d1014          ADD      r1,sp,#0x14           ;540
000888  e3a02000          MOV      r2,#0                 ;540
00088c  e58d2004          STR      r2,[sp,#4]            ;540
000890  e58d0010          STR      r0,[sp,#0x10]         ;540
000894  e58d100c          STR      r1,[sp,#0xc]          ;540
000898  e58d2008          STR      r2,[sp,#8]            ;540
00089c  e1a03005          MOV      r3,r5                 ;540
0008a0  e58d2000          STR      r2,[sp,#0]            ;540
0008a4  e3a02009          MOV      r2,#9                 ;540
0008a8  e3a01000          MOV      r1,#0                 ;540
0008ac  e1a00004          MOV      r0,r4                 ;540
0008b0  ebfffffe          BL       usbh_ctrl_xfer
0008b4  e1a06000          MOV      r6,r0                 ;540
0008b8  e3560000          CMP      r6,#0                 ;543
0008bc  aa000001          BGE      |L1.2248|
0008c0  e1a00006          MOV      r0,r6                 ;544
0008c4  eaffffe6          B        |L1.2148|
                  |L1.2248|
0008c8  e1a00c05          LSL      r0,r5,#24             ;546
0008cc  e1a00c40          ASR      r0,r0,#24             ;546
0008d0  e5c4001a          STRB     r0,[r4,#0x1a]         ;546
0008d4  e3a00000          MOV      r0,#0                 ;548
0008d8  eaffffe1          B        |L1.2148|
                  |L1.2268|
0008dc  68635f64          DCB      "hc_driver - 0x%x\n",0
0008e0  72697665
0008e4  72202d20
0008e8  30782578
0008ec  0a00    
0008ee  00                DCB      0
0008ef  00                DCB      0
                  |L1.2288|
0008f0  69736f5f          DCB      "iso_xfer - 0x%x\n",0
0008f4  78666572
0008f8  202d2030
0008fc  7825780a
000900  00      
000901  00                DCB      0
000902  00                DCB      0
000903  00                DCB      0
                          ENDP

                  usbh_set_interface PROC
;;;557     */
;;;558    int usbh_set_interface(IFACE_T *iface, uint16_t alt_setting)
000904  e92d41f0          PUSH     {r4-r8,lr}
;;;559    {
000908  e24dd018          SUB      sp,sp,#0x18
00090c  e1a04000          MOV      r4,r0
000910  e1a06001          MOV      r6,r1
;;;560        ALT_IFACE_T  *aif = NULL;
000914  e3a07000          MOV      r7,#0
;;;561        uint32_t     xfer_len;
;;;562        int          i, ret;
;;;563    
;;;564        for (i = 0; i < iface->num_alt; i++)
000918  e3a05000          MOV      r5,#0
00091c  ea00000c          B        |L1.2388|
                  |L1.2336|
;;;565        {
;;;566            if (iface->alt[i].ifd->bAlternateSetting == alt_setting)
000920  e0850185          ADD      r0,r5,r5,LSL #3
000924  e0800205          ADD      r0,r0,r5,LSL #4
000928  e284100c          ADD      r1,r4,#0xc
00092c  e7910100          LDR      r0,[r1,r0,LSL #2]
000930  e5d00003          LDRB     r0,[r0,#3]
000934  e1500006          CMP      r0,r6
000938  1a000004          BNE      |L1.2384|
;;;567            {
;;;568                aif = &iface->alt[i];
00093c  e0850185          ADD      r0,r5,r5,LSL #3
000940  e0800205          ADD      r0,r0,r5,LSL #4
000944  e284100c          ADD      r1,r4,#0xc
000948  e0817100          ADD      r7,r1,r0,LSL #2
;;;569                break;
00094c  ea000003          B        |L1.2400|
                  |L1.2384|
000950  e2855001          ADD      r5,r5,#1              ;564
                  |L1.2388|
000954  e5d40005          LDRB     r0,[r4,#5]            ;564
000958  e1500005          CMP      r0,r5                 ;564
00095c  caffffef          BGT      |L1.2336|
                  |L1.2400|
000960  e1a00000          MOV      r0,r0
;;;570            }
;;;571        }
;;;572        if (aif == NULL)
000964  e3570000          CMP      r7,#0
000968  1a000002          BNE      |L1.2424|
;;;573            return USBH_ERR_NOT_FOUND;          /* cannot find desired alternative setting    */
00096c  e3e00069          MVN      r0,#0x69
                  |L1.2416|
000970  e28dd018          ADD      sp,sp,#0x18
;;;574    
;;;575        ret = usbh_ctrl_xfer(iface->udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_IFACE,
;;;576                             USB_REQ_SET_INTERFACE, alt_setting, iface->if_num, 0,
;;;577                             NULL, &xfer_len, 500);
;;;578        if (ret == 0)
;;;579            iface->aif = aif;                   /* change active alternative setting          */
;;;580        return ret;
;;;581    }
000974  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2424|
000978  e3a00f7d          MOV      r0,#0x1f4             ;575
00097c  e28d1014          ADD      r1,sp,#0x14           ;575
000980  e3a02000          MOV      r2,#0                 ;575
000984  e58d2004          STR      r2,[sp,#4]            ;575
000988  e58d0010          STR      r0,[sp,#0x10]         ;575
00098c  e58d100c          STR      r1,[sp,#0xc]          ;575
000990  e58d2008          STR      r2,[sp,#8]            ;575
000994  e5d40004          LDRB     r0,[r4,#4]            ;575
000998  e58d0000          STR      r0,[sp,#0]            ;575
00099c  e1a03006          MOV      r3,r6                 ;575
0009a0  e3a0200b          MOV      r2,#0xb               ;575
0009a4  e3a01001          MOV      r1,#1                 ;575
0009a8  e5940000          LDR      r0,[r4,#0]            ;575
0009ac  ebfffffe          BL       usbh_ctrl_xfer
0009b0  e1a08000          MOV      r8,r0                 ;575
0009b4  e3580000          CMP      r8,#0                 ;578
0009b8  1a000000          BNE      |L1.2496|
0009bc  e5847008          STR      r7,[r4,#8]            ;579
                  |L1.2496|
0009c0  e1a00008          MOV      r0,r8                 ;580
0009c4  eaffffe9          B        |L1.2416|
;;;582    
                          ENDP

                  usbh_get_device_descriptor PROC
;;;590     */
;;;591    int usbh_get_device_descriptor(UDEV_T *udev, DESC_DEV_T *desc_buff)
0009c8  e92d41f0          PUSH     {r4-r8,lr}
;;;592    {
0009cc  e24dd018          SUB      sp,sp,#0x18
0009d0  e1a07000          MOV      r7,r0
0009d4  e1a05001          MOV      r5,r1
;;;593        uint32_t  read_len;
;;;594        int       ret, retry;
;;;595        int       timeout = 5;
0009d8  e3a08005          MOV      r8,#5
;;;596    
;;;597        for (retry = 0; retry < 3; retry++)
0009dc  e3a06000          MOV      r6,#0
0009e0  ea000011          B        |L1.2604|
                  |L1.2532|
;;;598        {
;;;599            ret = usbh_ctrl_xfer(udev, REQ_TYPE_IN | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
0009e4  e28d0014          ADD      r0,sp,#0x14
0009e8  e3a01012          MOV      r1,#0x12
0009ec  e58d000c          STR      r0,[sp,#0xc]
0009f0  e58d8010          STR      r8,[sp,#0x10]
0009f4  e3a00000          MOV      r0,#0
0009f8  e3a03c01          MOV      r3,#0x100
0009fc  e3a02006          MOV      r2,#6
000a00  e88d0023          STM      sp,{r0,r1,r5}
000a04  e3a01080          MOV      r1,#0x80
000a08  e1a00007          MOV      r0,r7
000a0c  ebfffffe          BL       usbh_ctrl_xfer
000a10  e1a04000          MOV      r4,r0
;;;600                                 USB_REQ_GET_DESCRIPTOR,
;;;601                                 ((USB_DT_STANDARD | USB_DT_DEVICE) << 8), 0, sizeof(DESC_DEV_T),
;;;602                                 (uint8_t *)desc_buff, &read_len, timeout);
;;;603            if (ret == 0)
000a14  e3540000          CMP      r4,#0
000a18  1a000002          BNE      |L1.2600|
;;;604                return 0;
000a1c  e3a00000          MOV      r0,#0
                  |L1.2592|
000a20  e28dd018          ADD      sp,sp,#0x18
;;;605    
;;;606            USB_debug("Get device descriptor failed - %d, retry!\n", ret);
;;;607        }
;;;608        return ret;
;;;609    }
000a24  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2600|
000a28  e2866001          ADD      r6,r6,#1              ;597
                  |L1.2604|
000a2c  e3560003          CMP      r6,#3                 ;597
000a30  baffffeb          BLT      |L1.2532|
000a34  e1a00004          MOV      r0,r4                 ;608
000a38  eafffff8          B        |L1.2592|
;;;610    
                          ENDP

                  usbh_get_config_descriptor PROC
;;;619     */
;;;620    int usbh_get_config_descriptor(UDEV_T *udev, uint8_t *desc_buff, int buff_len)
000a3c  e92d41f0          PUSH     {r4-r8,lr}
;;;621    {
000a40  e24dd018          SUB      sp,sp,#0x18
000a44  e1a08000          MOV      r8,r0
000a48  e1a04001          MOV      r4,r1
000a4c  e1a07002          MOV      r7,r2
;;;622        uint32_t  read_len;
;;;623        DESC_CONF_T  *conf = (DESC_CONF_T *)desc_buff;
000a50  e1a05004          MOV      r5,r4
;;;624        int       ret;
;;;625    
;;;626        /*------------------------------------------------------------------------------------*/
;;;627        /* Issue GET DESCRIPTOR command to get configuration descriptor                       */
;;;628        /*------------------------------------------------------------------------------------*/
;;;629        ret = usbh_ctrl_xfer(udev, REQ_TYPE_IN | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
000a54  e3a000c8          MOV      r0,#0xc8
000a58  e28d1014          ADD      r1,sp,#0x14
000a5c  e3a02009          MOV      r2,#9
000a60  e58d0010          STR      r0,[sp,#0x10]
000a64  e3a00000          MOV      r0,#0
000a68  e3a03c02          MOV      r3,#0x200
000a6c  e88d0015          STM      sp,{r0,r2,r4}
000a70  e3a02006          MOV      r2,#6
000a74  e58d100c          STR      r1,[sp,#0xc]
000a78  e3a01080          MOV      r1,#0x80
000a7c  e1a00008          MOV      r0,r8
000a80  ebfffffe          BL       usbh_ctrl_xfer
000a84  e1a06000          MOV      r6,r0
;;;630                             USB_REQ_GET_DESCRIPTOR,
;;;631                             ((USB_DT_STANDARD | USB_DT_CONFIGURATION) << 8), 0, 9,
;;;632                             desc_buff, &read_len, 200);
;;;633        if (ret < 0)
000a88  e3560000          CMP      r6,#0
000a8c  aa000002          BGE      |L1.2716|
;;;634            return ret;
000a90  e1a00006          MOV      r0,r6
                  |L1.2708|
000a94  e28dd018          ADD      sp,sp,#0x18
;;;635    
;;;636        if (conf->wTotalLength > buff_len)
;;;637        {
;;;638            USB_error("Device configuration %d length > %d!\n", conf->wTotalLength, buff_len);
;;;639            return USBH_ERR_DATA_OVERRUN;
;;;640        }
;;;641    
;;;642        read_len = conf->wTotalLength;
;;;643    
;;;644        ret = usbh_ctrl_xfer(udev, REQ_TYPE_IN | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
;;;645                             USB_REQ_GET_DESCRIPTOR,
;;;646                             ((USB_DT_STANDARD | USB_DT_CONFIGURATION) << 8), 0, read_len,
;;;647                             desc_buff, &read_len, 200);
;;;648        if (ret < 0)
;;;649            return ret;
;;;650    
;;;651        return 0;
;;;652    }
000a98  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2716|
000a9c  e5d50003          LDRB     r0,[r5,#3]            ;636
000aa0  e5d51002          LDRB     r1,[r5,#2]            ;636
000aa4  e1810400          ORR      r0,r1,r0,LSL #8       ;636
000aa8  e1500007          CMP      r0,r7                 ;636
000aac  da000007          BLE      |L1.2768|
000ab0  e5d50003          LDRB     r0,[r5,#3]            ;638
000ab4  e5d52002          LDRB     r2,[r5,#2]            ;638
000ab8  e1821400          ORR      r1,r2,r0,LSL #8       ;638
000abc  e1a02007          MOV      r2,r7                 ;638
000ac0  e28f0e23          ADR      r0,|L1.3320|
000ac4  ebfffffe          BL       sysprintf
000ac8  e59f0250          LDR      r0,|L1.3360|
000acc  eafffff0          B        |L1.2708|
                  |L1.2768|
000ad0  e5d50003          LDRB     r0,[r5,#3]            ;642
000ad4  e5d51002          LDRB     r1,[r5,#2]            ;642
000ad8  e1810400          ORR      r0,r1,r0,LSL #8       ;642
000adc  e58d0014          STR      r0,[sp,#0x14]         ;642
000ae0  e3a010c8          MOV      r1,#0xc8              ;644
000ae4  e28d2014          ADD      r2,sp,#0x14           ;644
000ae8  e59d0014          LDR      r0,[sp,#0x14]         ;644
000aec  e1a00800          LSL      r0,r0,#16             ;644
000af0  e1a00820          LSR      r0,r0,#16             ;644
000af4  e98d0011          STMIB    sp,{r0,r4}            ;644
000af8  e3a00000          MOV      r0,#0                 ;644
000afc  e3a03c02          MOV      r3,#0x200             ;644
000b00  e58d200c          STR      r2,[sp,#0xc]          ;644
000b04  e3a02006          MOV      r2,#6                 ;644
000b08  e58d1010          STR      r1,[sp,#0x10]         ;644
000b0c  e3a01080          MOV      r1,#0x80              ;644
000b10  e58d0000          STR      r0,[sp,#0]            ;644
000b14  e1a00008          MOV      r0,r8                 ;644
000b18  ebfffffe          BL       usbh_ctrl_xfer
000b1c  e1a06000          MOV      r6,r0                 ;644
000b20  e3560000          CMP      r6,#0                 ;648
000b24  aa000001          BGE      |L1.2864|
000b28  e1a00006          MOV      r0,r6                 ;649
000b2c  eaffffd8          B        |L1.2708|
                  |L1.2864|
000b30  e3a00000          MOV      r0,#0                 ;651
000b34  eaffffd6          B        |L1.2708|
;;;653    
                          ENDP

                  usbh_get_string_descriptor PROC
;;;663     */
;;;664    int usbh_get_string_descriptor(UDEV_T *udev, int index, uint8_t *desc_buff, int buff_len)
000b38  e92d41f0          PUSH     {r4-r8,lr}
;;;665    {
000b3c  e24dd018          SUB      sp,sp,#0x18
000b40  e1a07000          MOV      r7,r0
000b44  e1a04001          MOV      r4,r1
000b48  e1a05002          MOV      r5,r2
000b4c  e1a06003          MOV      r6,r3
;;;666        uint32_t  read_len;
;;;667        int       ret;
;;;668    
;;;669        /*------------------------------------------------------------------------------------*/
;;;670        /* Issue GET DESCRIPTOR command to get configuration descriptor                       */
;;;671        /*------------------------------------------------------------------------------------*/
;;;672        ret = usbh_ctrl_xfer(udev, REQ_TYPE_IN | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
000b50  e3a010c8          MOV      r1,#0xc8
000b54  e28d2014          ADD      r2,sp,#0x14
000b58  e1a00806          LSL      r0,r6,#16
000b5c  e1a00820          LSR      r0,r0,#16
000b60  e98d0021          STMIB    sp,{r0,r5}
000b64  e58d1010          STR      r1,[sp,#0x10]
000b68  e58d200c          STR      r2,[sp,#0xc]
000b6c  e59f01b0          LDR      r0,|L1.3364|
000b70  e58d0000          STR      r0,[sp,#0]
000b74  e1a00804          LSL      r0,r4,#16
000b78  e1a00820          LSR      r0,r0,#16
000b7c  e3803c03          ORR      r3,r0,#0x300
000b80  e3a02006          MOV      r2,#6
000b84  e3a01080          MOV      r1,#0x80
000b88  e1a00007          MOV      r0,r7
000b8c  ebfffffe          BL       usbh_ctrl_xfer
000b90  e1a08000          MOV      r8,r0
;;;673                             USB_REQ_GET_DESCRIPTOR,
;;;674                             ((USB_DT_STANDARD | USB_DT_STRING) << 8) | index, 0x0409, buff_len,
;;;675                             desc_buff, &read_len, 200);
;;;676        return ret;
000b94  e1a00008          MOV      r0,r8
000b98  e28dd018          ADD      sp,sp,#0x18
;;;677    }
000b9c  e8bd81f0          POP      {r4-r8,pc}
;;;678    
                          ENDP

                  usbh_clear_halt PROC
;;;685     */
;;;686    int usbh_clear_halt(UDEV_T *udev, uint16_t ep_addr)
000ba0  e92d4030          PUSH     {r4,r5,lr}
;;;687    {
000ba4  e24dd01c          SUB      sp,sp,#0x1c
000ba8  e1a05000          MOV      r5,r0
000bac  e1a04001          MOV      r4,r1
;;;688        uint32_t  read_len;
;;;689    
;;;690        USB_debug("Clear endpoint 0x%x halt.\n", ep_addr);
;;;691        return usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_EP,
000bb0  e3a00064          MOV      r0,#0x64
000bb4  e28d1018          ADD      r1,sp,#0x18
000bb8  e3a02000          MOV      r2,#0
000bbc  e58d2004          STR      r2,[sp,#4]
000bc0  e58d2008          STR      r2,[sp,#8]
000bc4  e1a03002          MOV      r3,r2
000bc8  e3a02001          MOV      r2,#1
000bcc  e58d100c          STR      r1,[sp,#0xc]
000bd0  e3a01002          MOV      r1,#2
000bd4  e58d0010          STR      r0,[sp,#0x10]
000bd8  e1a00005          MOV      r0,r5
000bdc  e58d4000          STR      r4,[sp,#0]
000be0  ebfffffe          BL       usbh_ctrl_xfer
000be4  e28dd01c          ADD      sp,sp,#0x1c
;;;692                              USB_REQ_CLEAR_FEATURE, 0, ep_addr, 0,
;;;693                              NULL, &read_len, 100);
;;;694    }
000be8  e8bd8030          POP      {r4,r5,pc}
;;;695    
                          ENDP

                  usbh_parse_endpoint PROC
;;;696    static int  usbh_parse_endpoint(ALT_IFACE_T *alt, int ep_idx, uint8_t *desc_buff, int len)
000bec  e92d47f0          PUSH     {r4-r10,lr}
;;;697    {
000bf0  e1a05000          MOV      r5,r0
000bf4  e1a06001          MOV      r6,r1
000bf8  e1a07002          MOV      r7,r2
000bfc  e1a08003          MOV      r8,r3
;;;698        DESC_EP_T    *ep_desc;
;;;699        int          parsed_len = 0;
000c00  e3a0a000          MOV      r10,#0
;;;700        int          pksz;
;;;701    
;;;702        while (len > 0)
000c04  ea000016          B        |L1.3172|
                  |L1.3080|
;;;703        {
;;;704            ep_desc = (DESC_EP_T *)desc_buff;
000c08  e1a04007          MOV      r4,r7
;;;705    
;;;706            if ((len < ep_desc->bLength) || (ep_desc->bLength < 2))
000c0c  e5d40000          LDRB     r0,[r4,#0]
000c10  e1500008          CMP      r0,r8
000c14  ca000002          BGT      |L1.3108|
000c18  e5d40000          LDRB     r0,[r4,#0]
000c1c  e3500002          CMP      r0,#2
000c20  aa000005          BGE      |L1.3132|
                  |L1.3108|
;;;707            {
;;;708                USB_error("ERR DESCRIPTOR EP LEN [0x%X %d]\n", ep_desc->bDescriptorType, ep_desc->bLength);
000c24  e5d42000          LDRB     r2,[r4,#0]
000c28  e5d41001          LDRB     r1,[r4,#1]
000c2c  e28f00f4          ADR      r0,|L1.3368|
000c30  ebfffffe          BL       sysprintf
;;;709                return USBH_ERR_DESCRIPTOR;
000c34  e3e00088          MVN      r0,#0x88
                  |L1.3128|
;;;710            }
;;;711    
;;;712            if (ep_desc->bDescriptorType == USB_DT_ENDPOINT)
;;;713                break;     /* endpoint descriptor found */
;;;714    
;;;715            /* unrecognized descriptor */
;;;716            USB_vdebug("ignore descriptor 0x%X %d\n", ep_desc->bDescriptorType, ep_desc->bLength);
;;;717            desc_buff += ep_desc->bLength;
;;;718            parsed_len += ep_desc->bLength;
;;;719            len -= ep_desc->bLength;
;;;720        }
;;;721    
;;;722        USB_vdebug("Descriptor Found - Alt: %d, Endpoint 0x%x, remaining len: %d\n", alt->ifd->bAlternateSetting, ep_desc->bEndpointAddress, len);
;;;723    
;;;724        alt->ep[ep_idx].bEndpointAddress = ep_desc->bEndpointAddress;
;;;725        alt->ep[ep_idx].bmAttributes     = ep_desc->bmAttributes;
;;;726        alt->ep[ep_idx].bInterval        = ep_desc->bInterval;
;;;727        pksz = ep_desc->wMaxPacketSize;
;;;728        pksz = (pksz & 0x07ff) * (1 + ((pksz >> 11) & 3));
;;;729        alt->ep[ep_idx].wMaxPacketSize   = pksz;
;;;730        alt->ep[ep_idx].hw_pipe          = NULL;
;;;731    
;;;732        return parsed_len + ep_desc->bLength;
;;;733    }
000c38  e8bd87f0          POP      {r4-r10,pc}
                  |L1.3132|
000c3c  e5d40001          LDRB     r0,[r4,#1]            ;712
000c40  e3500005          CMP      r0,#5                 ;712
000c44  1a000000          BNE      |L1.3148|
000c48  ea000007          B        |L1.3180|
                  |L1.3148|
000c4c  e5d40000          LDRB     r0,[r4,#0]            ;717
000c50  e0877000          ADD      r7,r7,r0              ;717
000c54  e5d40000          LDRB     r0,[r4,#0]            ;718
000c58  e08aa000          ADD      r10,r10,r0            ;718
000c5c  e5d40000          LDRB     r0,[r4,#0]            ;719
000c60  e0488000          SUB      r8,r8,r0              ;719
                  |L1.3172|
000c64  e3580000          CMP      r8,#0                 ;702
000c68  caffffe6          BGT      |L1.3080|
                  |L1.3180|
000c6c  e1a00000          MOV      r0,r0                 ;713
000c70  e5d40002          LDRB     r0,[r4,#2]            ;724
000c74  e0861086          ADD      r1,r6,r6,LSL #1       ;724
000c78  e2852004          ADD      r2,r5,#4              ;724
000c7c  e7c20101          STRB     r0,[r2,r1,LSL #2]     ;724
000c80  e5d40003          LDRB     r0,[r4,#3]            ;725
000c84  e0861086          ADD      r1,r6,r6,LSL #1       ;725
000c88  e2852004          ADD      r2,r5,#4              ;725
000c8c  e0821101          ADD      r1,r2,r1,LSL #2       ;725
000c90  e5c10001          STRB     r0,[r1,#1]            ;725
000c94  e5d40006          LDRB     r0,[r4,#6]            ;726
000c98  e0861086          ADD      r1,r6,r6,LSL #1       ;726
000c9c  e2852004          ADD      r2,r5,#4              ;726
000ca0  e0821101          ADD      r1,r2,r1,LSL #2       ;726
000ca4  e5c10002          STRB     r0,[r1,#2]            ;726
000ca8  e5d40005          LDRB     r0,[r4,#5]            ;727
000cac  e5d41004          LDRB     r1,[r4,#4]            ;727
000cb0  e1819400          ORR      r9,r1,r0,LSL #8       ;727
000cb4  e3c90b3e          BIC      r0,r9,#0xf800         ;728
000cb8  e3a01003          MOV      r1,#3                 ;728
000cbc  e00115c9          AND      r1,r1,r9,ASR #11      ;728
000cc0  e2811001          ADD      r1,r1,#1              ;728
000cc4  e1690180          SMULBB   r9,r0,r1              ;728
000cc8  e0861086          ADD      r1,r6,r6,LSL #1       ;729
000ccc  e2852004          ADD      r2,r5,#4              ;729
000cd0  e0821101          ADD      r1,r2,r1,LSL #2       ;729
000cd4  e1c190b4          STRH     r9,[r1,#4]            ;729
000cd8  e3a00000          MOV      r0,#0                 ;730
000cdc  e0861086          ADD      r1,r6,r6,LSL #1       ;730
000ce0  e2852004          ADD      r2,r5,#4              ;730
000ce4  e0821101          ADD      r1,r2,r1,LSL #2       ;730
000ce8  e5810008          STR      r0,[r1,#8]            ;730
000cec  e5d40000          LDRB     r0,[r4,#0]            ;732
000cf0  e080000a          ADD      r0,r0,r10             ;732
000cf4  eaffffcf          B        |L1.3128|
                  |L1.3320|
000cf8  44657669          DCB      "Device configuration %d length > %d!\n",0
000cfc  63652063
000d00  6f6e6669
000d04  67757261
000d08  74696f6e
000d0c  20256420
000d10  6c656e67
000d14  7468203e
000d18  20256421
000d1c  0a00    
000d1e  00                DCB      0
000d1f  00                DCB      0
                  |L1.3360|
                          DCD      0xfffffee0
                  |L1.3364|
                          DCD      0x00000409
                  |L1.3368|
000d28  45525220          DCB      "ERR DESCRIPTOR EP LEN [0x%X %d]\n",0
000d2c  44455343
000d30  52495054
000d34  4f522045
000d38  50204c45
000d3c  4e205b30
000d40  78255820
000d44  25645d0a
000d48  00      
000d49  00                DCB      0
000d4a  00                DCB      0
000d4b  00                DCB      0
                          ENDP

                  usbh_parse_interface PROC
;;;743      */
;;;744    static int  usbh_parse_interface(UDEV_T *udev, uint8_t *desc_buff, int len)
000d4c  e92d5ffc          PUSH     {r2-r12,lr}
;;;745    {
000d50  e1a0a000          MOV      r10,r0
000d54  e1a07001          MOV      r7,r1
000d58  e1a08002          MOV      r8,r2
;;;746        int         i, matched, parsed_len = 0;
000d5c  e3a00000          MOV      r0,#0
000d60  e58d0000          STR      r0,[sp,#0]
;;;747        DESC_HDR_T  *hdr;
;;;748        DESC_IF_T   *if_desc;
;;;749        IFACE_T     *iface = NULL;
000d64  e3a04000          MOV      r4,#0
;;;750        int         ret;
;;;751    
;;;752        iface = usbh_alloc_mem(sizeof(*iface)); /* create an interface                        */
000d68  e59f02d4          LDR      r0,|L1.4164|
000d6c  ebfffffe          BL       usbh_alloc_mem
000d70  e1a04000          MOV      r4,r0
;;;753        if (iface == NULL)
000d74  e3540000          CMP      r4,#0
000d78  1a000001          BNE      |L1.3460|
;;;754            return USBH_ERR_MEMORY_OUT;
000d7c  e3e00009          MVN      r0,#9
                  |L1.3456|
;;;755        iface->udev = udev;
;;;756        iface->aif = &iface->alt[0];            /* Default active interface should be the
;;;757                                                   first found alternative interface          */
;;;758        iface->if_num = ((DESC_IF_T *)desc_buff)->bInterfaceNumber;
;;;759    
;;;760        while (len > 0)
;;;761        {
;;;762            /*--------------------------------------------------------------------------------*/
;;;763            /* Find the first/next interface descriptor                                       */
;;;764            /*--------------------------------------------------------------------------------*/
;;;765            if_desc = (DESC_IF_T *)desc_buff;
;;;766    
;;;767            if (if_desc->bDescriptorType != USB_DT_INTERFACE)
;;;768            {
;;;769                desc_buff += if_desc->bLength;
;;;770                parsed_len += if_desc->bLength;
;;;771                len -= if_desc->bLength;
;;;772                continue;
;;;773            }
;;;774    
;;;775            if (if_desc->bInterfaceNumber != iface->if_num)
;;;776            {
;;;777                goto parse_done;
;;;778            }
;;;779    
;;;780            if (if_desc->bNumEndpoints > MAX_EP_PER_IFACE)
;;;781            {
;;;782                USB_error("IF EP LIMITE %d\n", if_desc->bNumEndpoints);
;;;783                ret = USBH_ERR_IF_EP_LIMIT;
;;;784                goto err_out;
;;;785            }
;;;786    
;;;787            /* Step over the interface descriptor */
;;;788            desc_buff += if_desc->bLength;
;;;789            parsed_len += if_desc->bLength;
;;;790            len -= if_desc->bLength;
;;;791            USB_vdebug("Descriptor Found - Interface %d, Alt: %d, num_alt:%d, remaining len: %d\n", if_desc->bInterfaceNumber, if_desc->bAlternateSetting, iface->num_alt, len);
;;;792    
;;;793            /*--------------------------------------------------------------------------------*/
;;;794            /* Add to alternative interface list                                              */
;;;795            /*--------------------------------------------------------------------------------*/
;;;796            if (iface->num_alt >= MAX_ALT_PER_IFACE)
;;;797            {
;;;798                ret = USBH_ERR_IF_ALT_LIMIT;
;;;799                goto err_out;
;;;800            }
;;;801    
;;;802            /*--------------------------------------------------------------------------------*/
;;;803            /* Find the next alternative interface or endpoint descriptor                     */
;;;804            /*--------------------------------------------------------------------------------*/
;;;805            while (len > 0)
;;;806            {
;;;807                hdr = (DESC_HDR_T *)desc_buff;
;;;808    
;;;809                if ((len < hdr->bLength) || (hdr->bLength < 2))
;;;810                {
;;;811                    USB_error("ERR DESCRIPTOR IF LEN [0x%X %d]\n", hdr->bDescriptorType, hdr->bLength);
;;;812                    ret = USBH_ERR_DESCRIPTOR;
;;;813                    goto err_out;
;;;814                }
;;;815    
;;;816                if (hdr->bDescriptorType == USB_DT_CONFIGURATION)
;;;817                    goto parse_done;            /* is other configuration, parsing completed  */
;;;818    
;;;819                if ((hdr->bDescriptorType == USB_DT_INTERFACE) || (hdr->bDescriptorType == USB_DT_ENDPOINT))
;;;820                    break;                      /* the first endpoint descriptor found        */
;;;821    
;;;822                /* unrecognized descriptor */
;;;823                USB_vdebug("ignore descriptor 0x%X %d\n", hdr->bDescriptorType, hdr->bLength);
;;;824                desc_buff += hdr->bLength;
;;;825                parsed_len += hdr->bLength;
;;;826                len -= hdr->bLength;
;;;827            }
;;;828    
;;;829            iface->alt[iface->num_alt].ifd = if_desc;
;;;830            iface->num_alt++;
;;;831    
;;;832            if (len == 0)
;;;833                goto parse_done;
;;;834    
;;;835            if (hdr->bDescriptorType == USB_DT_INTERFACE)
;;;836                continue;                       /* is the next interface descriptor           */
;;;837    
;;;838            USB_vdebug("Finding %d endpoints of interface %d, alt %d...\n", if_desc->bNumEndpoints, if_desc->bInterfaceNumber, if_desc->bAlternateSetting);
;;;839    
;;;840            /* parsign all endpoint descriptors */
;;;841            for (i = 0; i < if_desc->bNumEndpoints; i++)
;;;842            {
;;;843                ret = usbh_parse_endpoint(&iface->alt[iface->num_alt-1], i, desc_buff, len);
;;;844                if (ret < 0)
;;;845                    goto err_out;
;;;846    
;;;847                desc_buff += ret;
;;;848                parsed_len += ret;
;;;849                len -= ret;
;;;850                USB_vdebug("EP parse remaining %d\n", len);
;;;851            }
;;;852        }
;;;853    
;;;854    parse_done:
;;;855    
;;;856        /*
;;;857         *  Probing all registered USB device drivers to find a matched driver.
;;;858         */
;;;859        matched = 0;
;;;860        for (i = 0; i < MAX_UDEV_DRIVER; i++)
;;;861        {
;;;862            if ((_drivers[i] != NULL) && (_drivers[i]->probe(iface) == 0))
;;;863            {
;;;864                matched = 1;
;;;865                break;
;;;866            }
;;;867        }
;;;868    
;;;869        if (matched)
;;;870        {
;;;871            iface->driver = _drivers[i];        /* have a driver now */
;;;872            iface->next = NULL;
;;;873    
;;;874            /* Added this interface to USB device interface list */
;;;875            if (udev->iface_list == NULL)
;;;876                udev->iface_list = iface;
;;;877            else
;;;878            {
;;;879                iface->next = udev->iface_list;
;;;880                udev->iface_list = iface;
;;;881            }
;;;882        }
;;;883        else
;;;884        {
;;;885            usbh_free_mem(iface, sizeof(*iface));
;;;886            iface = NULL;
;;;887        }
;;;888    
;;;889        return parsed_len;
;;;890    
;;;891    err_out:
;;;892        usbh_free_mem(iface, sizeof(*iface));
;;;893        return ret;
;;;894    }
000d80  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.3460|
000d84  e584a000          STR      r10,[r4,#0]           ;755
000d88  e284000c          ADD      r0,r4,#0xc            ;756
000d8c  e5840008          STR      r0,[r4,#8]            ;756
000d90  e5d70002          LDRB     r0,[r7,#2]            ;758
000d94  e5c40004          STRB     r0,[r4,#4]            ;758
000d98  ea000073          B        |L1.3948|
                  |L1.3484|
000d9c  e1a05007          MOV      r5,r7                 ;765
000da0  e5d50001          LDRB     r0,[r5,#1]            ;767
000da4  e3500004          CMP      r0,#4                 ;767
000da8  0a000008          BEQ      |L1.3536|
000dac  e5d50000          LDRB     r0,[r5,#0]            ;769
000db0  e0877000          ADD      r7,r7,r0              ;769
000db4  e5d51000          LDRB     r1,[r5,#0]            ;770
000db8  e59d0000          LDR      r0,[sp,#0]            ;770
000dbc  e0800001          ADD      r0,r0,r1              ;770
000dc0  e58d0000          STR      r0,[sp,#0]            ;770
000dc4  e5d50000          LDRB     r0,[r5,#0]            ;771
000dc8  e0488000          SUB      r8,r8,r0              ;771
000dcc  ea000066          B        |L1.3948|
                  |L1.3536|
000dd0  e5d50002          LDRB     r0,[r5,#2]            ;775
000dd4  e5d41004          LDRB     r1,[r4,#4]            ;775
000dd8  e1500001          CMP      r0,r1                 ;775
000ddc  0a000000          BEQ      |L1.3556|
000de0  ea000064          B        |L1.3960|
                  |L1.3556|
000de4  e5d50004          LDRB     r0,[r5,#4]            ;780
000de8  e3500008          CMP      r0,#8                 ;780
000dec  da000004          BLE      |L1.3588|
000df0  e5d51004          LDRB     r1,[r5,#4]            ;782
000df4  e28f0f93          ADR      r0,|L1.4168|
000df8  ebfffffe          BL       sysprintf
000dfc  e3e0b00e          MVN      r11,#0xe              ;783
000e00  ea000089          B        |L1.4140|
                  |L1.3588|
000e04  e5d50000          LDRB     r0,[r5,#0]            ;788
000e08  e0877000          ADD      r7,r7,r0              ;788
000e0c  e5d51000          LDRB     r1,[r5,#0]            ;789
000e10  e59d0000          LDR      r0,[sp,#0]            ;789
000e14  e0800001          ADD      r0,r0,r1              ;789
000e18  e58d0000          STR      r0,[sp,#0]            ;789
000e1c  e5d50000          LDRB     r0,[r5,#0]            ;790
000e20  e0488000          SUB      r8,r8,r0              ;790
000e24  e5d40005          LDRB     r0,[r4,#5]            ;796
000e28  e350000c          CMP      r0,#0xc               ;796
000e2c  ba000001          BLT      |L1.3640|
000e30  e3e0b00a          MVN      r11,#0xa              ;798
000e34  ea00007c          B        |L1.4140|
                  |L1.3640|
000e38  ea00001f          B        |L1.3772|
                  |L1.3644|
000e3c  e1a06007          MOV      r6,r7                 ;807
000e40  e5d60000          LDRB     r0,[r6,#0]            ;809
000e44  e1500008          CMP      r0,r8                 ;809
000e48  ca000002          BGT      |L1.3672|
000e4c  e5d60000          LDRB     r0,[r6,#0]            ;809
000e50  e3500002          CMP      r0,#2                 ;809
000e54  aa000005          BGE      |L1.3696|
                  |L1.3672|
000e58  e5d62000          LDRB     r2,[r6,#0]            ;811
000e5c  e5d61001          LDRB     r1,[r6,#1]            ;811
000e60  e28f0f7d          ADR      r0,|L1.4188|
000e64  ebfffffe          BL       sysprintf
000e68  e3e0b088          MVN      r11,#0x88             ;812
000e6c  ea00006e          B        |L1.4140|
                  |L1.3696|
000e70  e5d60001          LDRB     r0,[r6,#1]            ;816
000e74  e3500002          CMP      r0,#2                 ;816
000e78  1a000000          BNE      |L1.3712|
000e7c  ea00003d          B        |L1.3960|
                  |L1.3712|
000e80  e5d60001          LDRB     r0,[r6,#1]            ;819
000e84  e3500004          CMP      r0,#4                 ;819
000e88  0a000002          BEQ      |L1.3736|
000e8c  e5d60001          LDRB     r0,[r6,#1]            ;819
000e90  e3500005          CMP      r0,#5                 ;819
000e94  1a000000          BNE      |L1.3740|
                  |L1.3736|
000e98  ea000009          B        |L1.3780|
                  |L1.3740|
000e9c  e5d60000          LDRB     r0,[r6,#0]            ;824
000ea0  e0877000          ADD      r7,r7,r0              ;824
000ea4  e5d61000          LDRB     r1,[r6,#0]            ;825
000ea8  e59d0000          LDR      r0,[sp,#0]            ;825
000eac  e0800001          ADD      r0,r0,r1              ;825
000eb0  e58d0000          STR      r0,[sp,#0]            ;825
000eb4  e5d60000          LDRB     r0,[r6,#0]            ;826
000eb8  e0488000          SUB      r8,r8,r0              ;826
                  |L1.3772|
000ebc  e3580000          CMP      r8,#0                 ;805
000ec0  caffffdd          BGT      |L1.3644|
                  |L1.3780|
000ec4  e1a00000          MOV      r0,r0                 ;820
000ec8  e5d40005          LDRB     r0,[r4,#5]            ;829
000ecc  e0801180          ADD      r1,r0,r0,LSL #3       ;829
000ed0  e0810200          ADD      r0,r1,r0,LSL #4       ;829
000ed4  e284100c          ADD      r1,r4,#0xc            ;829
000ed8  e7815100          STR      r5,[r1,r0,LSL #2]     ;829
000edc  e5d40005          LDRB     r0,[r4,#5]            ;830
000ee0  e2800001          ADD      r0,r0,#1              ;830
000ee4  e5c40005          STRB     r0,[r4,#5]            ;830
000ee8  e3580000          CMP      r8,#0                 ;832
000eec  1a000000          BNE      |L1.3828|
000ef0  ea000020          B        |L1.3960|
                  |L1.3828|
000ef4  e5d60001          LDRB     r0,[r6,#1]            ;835
000ef8  e3500004          CMP      r0,#4                 ;835
000efc  1a000000          BNE      |L1.3844|
000f00  ea000019          B        |L1.3948|
                  |L1.3844|
000f04  e3a09000          MOV      r9,#0                 ;841
000f08  ea000013          B        |L1.3932|
                  |L1.3852|
000f0c  e5d41005          LDRB     r1,[r4,#5]            ;843
000f10  e2411001          SUB      r1,r1,#1              ;843
000f14  e0812181          ADD      r2,r1,r1,LSL #3       ;843
000f18  e0821201          ADD      r1,r2,r1,LSL #4       ;843
000f1c  e284200c          ADD      r2,r4,#0xc            ;843
000f20  e0820101          ADD      r0,r2,r1,LSL #2       ;843
000f24  e1a03008          MOV      r3,r8                 ;843
000f28  e1a02007          MOV      r2,r7                 ;843
000f2c  e1a01009          MOV      r1,r9                 ;843
000f30  ebfffffe          BL       usbh_parse_endpoint
000f34  e1a0b000          MOV      r11,r0                ;843
000f38  e35b0000          CMP      r11,#0                ;844
000f3c  aa000000          BGE      |L1.3908|
000f40  ea000039          B        |L1.4140|
                  |L1.3908|
000f44  e087700b          ADD      r7,r7,r11             ;847
000f48  e59d0000          LDR      r0,[sp,#0]            ;848
000f4c  e080000b          ADD      r0,r0,r11             ;848
000f50  e58d0000          STR      r0,[sp,#0]            ;848
000f54  e048800b          SUB      r8,r8,r11             ;849
000f58  e2899001          ADD      r9,r9,#1              ;841
                  |L1.3932|
000f5c  e5d50004          LDRB     r0,[r5,#4]            ;841
000f60  e1500009          CMP      r0,r9                 ;841
000f64  caffffe8          BGT      |L1.3852|
000f68  e1a00000          MOV      r0,r0                 ;772
                  |L1.3948|
000f6c  e3580000          CMP      r8,#0                 ;760
000f70  caffff89          BGT      |L1.3484|
000f74  e1a00000          MOV      r0,r0                 ;854
                  |L1.3960|
000f78  e3a00000          MOV      r0,#0                 ;859
000f7c  e58d0004          STR      r0,[sp,#4]            ;859
000f80  e3a09000          MOV      r9,#0                 ;860
000f84  ea00000e          B        |L1.4036|
                  |L1.3976|
000f88  e51f0acc          LDR      r0,|L1.1220|
000f8c  e7900109          LDR      r0,[r0,r9,LSL #2]     ;862
000f90  e3500000          CMP      r0,#0                 ;862
000f94  0a000009          BEQ      |L1.4032|
000f98  e51f0adc          LDR      r0,|L1.1220|
000f9c  e7900109          LDR      r0,[r0,r9,LSL #2]     ;862
000fa0  e5901000          LDR      r1,[r0,#0]            ;862
000fa4  e1a00004          MOV      r0,r4                 ;862
000fa8  e12fff31          BLX      r1                    ;862
000fac  e3500000          CMP      r0,#0                 ;862
000fb0  1a000002          BNE      |L1.4032|
000fb4  e3a00001          MOV      r0,#1                 ;864
000fb8  e58d0004          STR      r0,[sp,#4]            ;864
000fbc  ea000002          B        |L1.4044|
                  |L1.4032|
000fc0  e2899001          ADD      r9,r9,#1              ;860
                  |L1.4036|
000fc4  e3590008          CMP      r9,#8                 ;860
000fc8  baffffee          BLT      |L1.3976|
                  |L1.4044|
000fcc  e1a00000          MOV      r0,r0                 ;865
000fd0  e59d0004          LDR      r0,[sp,#4]            ;869
000fd4  e3500000          CMP      r0,#0                 ;869
000fd8  0a00000d          BEQ      |L1.4116|
000fdc  e51f0b20          LDR      r0,|L1.1220|
000fe0  e7900109          LDR      r0,[r0,r9,LSL #2]     ;871
000fe4  e58404bc          STR      r0,[r4,#0x4bc]        ;871
000fe8  e3a00000          MOV      r0,#0                 ;872
000fec  e58404c4          STR      r0,[r4,#0x4c4]        ;872
000ff0  e59a0030          LDR      r0,[r10,#0x30]        ;875
000ff4  e3500000          CMP      r0,#0                 ;875
000ff8  1a000001          BNE      |L1.4100|
000ffc  e58a4030          STR      r4,[r10,#0x30]        ;876
001000  ea000007          B        |L1.4132|
                  |L1.4100|
001004  e59a0030          LDR      r0,[r10,#0x30]        ;879
001008  e58404c4          STR      r0,[r4,#0x4c4]        ;879
00100c  e58a4030          STR      r4,[r10,#0x30]        ;880
001010  ea000003          B        |L1.4132|
                  |L1.4116|
001014  e59f1028          LDR      r1,|L1.4164|
001018  e1a00004          MOV      r0,r4                 ;885
00101c  ebfffffe          BL       usbh_free_mem
001020  e3a04000          MOV      r4,#0                 ;886
                  |L1.4132|
001024  e59d0000          LDR      r0,[sp,#0]            ;889
001028  eaffff54          B        |L1.3456|
                  |L1.4140|
00102c  e1a00000          MOV      r0,r0                 ;891
001030  e59f100c          LDR      r1,|L1.4164|
001034  e1a00004          MOV      r0,r4                 ;892
001038  ebfffffe          BL       usbh_free_mem
00103c  e1a0000b          MOV      r0,r11                ;893
001040  eaffff4e          B        |L1.3456|
                  |L1.4164|
                          DCD      0x000004c8
                  |L1.4168|
001048  49462045          DCB      "IF EP LIMITE %d\n",0
00104c  50204c49
001050  4d495445
001054  2025640a
001058  00      
001059  00                DCB      0
00105a  00                DCB      0
00105b  00                DCB      0
                  |L1.4188|
00105c  45525220          DCB      "ERR DESCRIPTOR IF LEN [0x%X %d]\n",0
001060  44455343
001064  52495054
001068  4f522049
00106c  46204c45
001070  4e205b30
001074  78255820
001078  25645d0a
00107c  00      
00107d  00                DCB      0
00107e  00                DCB      0
00107f  00                DCB      0
                          ENDP

                  usbh_parse_configuration PROC
;;;896    
;;;897    static int  usbh_parse_configuration(UDEV_T *udev, uint8_t *desc_buff)
001080  e92d47f0          PUSH     {r4-r10,lr}
;;;898    {
001084  e1a0a000          MOV      r10,r0
001088  e1a04001          MOV      r4,r1
;;;899        DESC_CONF_T  *config = (DESC_CONF_T *)desc_buff;
00108c  e1a07004          MOV      r7,r4
;;;900        DESC_HDR_T   *hdr;
;;;901        int    i, ret, len;
;;;902    
;;;903        len = config->wTotalLength;
001090  e5d70003          LDRB     r0,[r7,#3]
001094  e5d71002          LDRB     r1,[r7,#2]
001098  e1815400          ORR      r5,r1,r0,LSL #8
;;;904    
;;;905        desc_buff += config->bLength;
00109c  e5d70000          LDRB     r0,[r7,#0]
0010a0  e0844000          ADD      r4,r4,r0
;;;906        len -= config->bLength;
0010a4  e5d70000          LDRB     r0,[r7,#0]
0010a8  e0455000          SUB      r5,r5,r0
;;;907    
;;;908        USB_vdebug("Parsing CONFIG =>\n");
;;;909    
;;;910        for (i = 0; i < config->bNumInterfaces; i++)
0010ac  e3a09000          MOV      r9,#0
0010b0  ea000024          B        |L1.4424|
                  |L1.4276|
;;;911        {
;;;912            /*
;;;913             *  find the next interface descriptor
;;;914             */
;;;915            while (len >= sizeof(DESC_HDR_T))
0010b4  ea000014          B        |L1.4364|
                  |L1.4280|
;;;916            {
;;;917                hdr = (DESC_HDR_T *)desc_buff;
0010b8  e1a06004          MOV      r6,r4
;;;918    
;;;919                if ((hdr->bLength > len) || (hdr->bLength < 2))
0010bc  e1a04006          MOV      r4,r6
0010c0  e5d60000          LDRB     r0,[r6,#0]
0010c4  e1500005          CMP      r0,r5
0010c8  ca000002          BGT      |L1.4312|
0010cc  e5d60000          LDRB     r0,[r6,#0]
0010d0  e3500002          CMP      r0,#2
0010d4  aa000004          BGE      |L1.4332|
                  |L1.4312|
;;;920                {
;;;921                    USB_error("ERR DESCRIPTOR CONFIG [%d]\n", hdr->bLength);
0010d8  e5d61000          LDRB     r1,[r6,#0]
0010dc  e28f0fb5          ADR      r0,|L1.5048|
0010e0  ebfffffe          BL       sysprintf
;;;922                    return USBH_ERR_DESCRIPTOR;
0010e4  e3e00088          MVN      r0,#0x88
                  |L1.4328|
;;;923                }
;;;924    
;;;925                if (hdr->bDescriptorType == USB_DT_INTERFACE)
;;;926                    break;
;;;927    
;;;928                USB_debug("ignore descriptor 0x%X %d\n", hdr->bDescriptorType, hdr->bLength);
;;;929    
;;;930                desc_buff += hdr->bLength;
;;;931                len -= hdr->bLength;
;;;932            }
;;;933    
;;;934            ret = usbh_parse_interface(udev, desc_buff, len);
;;;935            if (ret < 0)
;;;936                return ret;
;;;937    
;;;938            desc_buff += ret;
;;;939            len -= ret;
;;;940            USB_vdebug("IFACE parse remaining %d\n", len);
;;;941        }
;;;942    
;;;943        if (len > 0)
;;;944        {
;;;945            USB_debug("ERR DESCRIPTOR CONFIG LEN %d\n", len);
;;;946            return USBH_ERR_DESCRIPTOR;
;;;947        }
;;;948        return len;
;;;949    }
0010e8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4332|
0010ec  e5d60001          LDRB     r0,[r6,#1]            ;925
0010f0  e3500004          CMP      r0,#4                 ;925
0010f4  1a000000          BNE      |L1.4348|
0010f8  ea000005          B        |L1.4372|
                  |L1.4348|
0010fc  e5d60000          LDRB     r0,[r6,#0]            ;930
001100  e0844000          ADD      r4,r4,r0              ;930
001104  e5d60000          LDRB     r0,[r6,#0]            ;931
001108  e0455000          SUB      r5,r5,r0              ;931
                  |L1.4364|
00110c  e3550002          CMP      r5,#2                 ;915
001110  2affffe8          BCS      |L1.4280|
                  |L1.4372|
001114  e1a00000          MOV      r0,r0                 ;926
001118  e1a02005          MOV      r2,r5                 ;934
00111c  e1a01004          MOV      r1,r4                 ;934
001120  e1a0000a          MOV      r0,r10                ;934
001124  ebfffffe          BL       usbh_parse_interface
001128  e1a08000          MOV      r8,r0                 ;934
00112c  e3580000          CMP      r8,#0                 ;935
001130  aa000001          BGE      |L1.4412|
001134  e1a00008          MOV      r0,r8                 ;936
001138  eaffffea          B        |L1.4328|
                  |L1.4412|
00113c  e0844008          ADD      r4,r4,r8              ;938
001140  e0455008          SUB      r5,r5,r8              ;939
001144  e2899001          ADD      r9,r9,#1              ;910
                  |L1.4424|
001148  e5d70004          LDRB     r0,[r7,#4]            ;910
00114c  e1500009          CMP      r0,r9                 ;910
001150  caffffd7          BGT      |L1.4276|
001154  e3550000          CMP      r5,#0                 ;943
001158  da000001          BLE      |L1.4452|
00115c  e3e00088          MVN      r0,#0x88              ;946
001160  eaffffe0          B        |L1.4328|
                  |L1.4452|
001164  e1a00005          MOV      r0,r5                 ;948
001168  eaffffde          B        |L1.4328|
;;;950    
                          ENDP

                  print_usb_string PROC
;;;951    void print_usb_string(char *lead, uint8_t *str)
00116c  e1a03000          MOV      r3,r0
;;;952    {
;;;953        int  len, i = 2;
001170  e3a00002          MOV      r0,#2
;;;954    
;;;955        USB_debug("%s", lead);
;;;956        len = str[0];
001174  e5d12000          LDRB     r2,[r1,#0]
;;;957        while (i < len)
001178  ea000000          B        |L1.4480|
                  |L1.4476|
;;;958        {
;;;959            USB_debug("%c", str[i]);
;;;960            i += 2;
00117c  e2800002          ADD      r0,r0,#2
                  |L1.4480|
001180  e1500002          CMP      r0,r2                 ;957
001184  bafffffc          BLT      |L1.4476|
;;;961        }
;;;962        USB_debug("\n");
;;;963    }
001188  e12fff1e          BX       lr
;;;964    
                          ENDP

                  connect_device PROC
;;;965    
;;;966    int  connect_device(UDEV_T *udev)
00118c  e92d40f0          PUSH     {r4-r7,lr}
;;;967    {
001190  e24dd01c          SUB      sp,sp,#0x1c
001194  e1a04000          MOV      r4,r0
;;;968        DESC_CONF_T  *conf;
;;;969        uint8_t      *str_buff;
;;;970        uint32_t     read_len;
;;;971        int          ret;
;;;972    
;;;973        USB_debug("Connect device =>\n");
;;;974    
;;;975        delay_us(100 * 1000);                   /* initially, give 100 ms delay               */
001198  e59f0234          LDR      r0,|L1.5076|
00119c  ebfffffe          BL       delay_us
;;;976    
;;;977        usbh_get_device_descriptor(udev, &udev->descriptor);
0011a0  e1a01004          MOV      r1,r4
0011a4  e1a00004          MOV      r0,r4
0011a8  ebfffffe          BL       usbh_get_device_descriptor
;;;978    
;;;979        reset_device(udev);
0011ac  e1a00004          MOV      r0,r4
0011b0  ebfffffe          BL       reset_device
;;;980    
;;;981        delay_us(100 * 1000);
0011b4  e59f0218          LDR      r0,|L1.5076|
0011b8  ebfffffe          BL       delay_us
;;;982    
;;;983        ret = usbh_set_address(udev);
0011bc  e1a00004          MOV      r0,r4
0011c0  ebfffffe          BL       usbh_set_address
0011c4  e1a06000          MOV      r6,r0
;;;984        if (ret < 0)
0011c8  e3560000          CMP      r6,#0
0011cc  aa000002          BGE      |L1.4572|
;;;985        {
;;;986            USB_debug("Set address command failed!!\n");
;;;987            return ret;
0011d0  e1a00006          MOV      r0,r6
                  |L1.4564|
0011d4  e28dd01c          ADD      sp,sp,#0x1c
;;;988        }
;;;989    
;;;990        delay_us(100 * 1000);                   /* after set address, give 100 ms delay       */
;;;991    
;;;992        USB_debug("New %s device address %d assigned.\n", (udev->speed == SPEED_HIGH) ? "high-speed" : ((udev->speed == SPEED_FULL) ? "full-speed" : "low-speed"), udev->dev_num);
;;;993    
;;;994        /* Get device descriptor again with new device address */
;;;995        ret = usbh_get_device_descriptor(udev, &udev->descriptor);
;;;996        if (ret < 0)
;;;997        {
;;;998            free_dev_address(udev->dev_num);
;;;999            return ret;
;;;1000       }
;;;1001   
;;;1002   #if  defined(DUMP_DESCRIPTOR) && defined(ENABLE_DEBUG_MSG)
;;;1003       dump_device_descriptor(&udev->descriptor);
;;;1004   #endif
;;;1005   
;;;1006       if (udev->descriptor.bNumConfigurations != 1)
;;;1007       {
;;;1008           USB_debug("Warning! This device has multiple configurations [%d]. \n", udev->descriptor.bNumConfigurations);
;;;1009       }
;;;1010   
;;;1011       conf = (DESC_CONF_T *)usbh_alloc_mem(MAX_DESC_BUFF_SIZE);
;;;1012       if (conf == NULL)
;;;1013       {
;;;1014           free_dev_address(udev->dev_num);
;;;1015           return USBH_ERR_MEMORY_OUT;
;;;1016       }
;;;1017   
;;;1018       udev->cfd_buff = (uint8_t *)conf;
;;;1019   
;;;1020       /* Get configuration descriptor again with new device address */
;;;1021       ret = usbh_get_config_descriptor(udev, (uint8_t *)conf, MAX_DESC_BUFF_SIZE);
;;;1022       if (ret < 0)
;;;1023       {
;;;1024           free_dev_address(udev->dev_num);
;;;1025           return ret;
;;;1026       }
;;;1027   
;;;1028   #if  defined(DUMP_DESCRIPTOR) && defined(ENABLE_DEBUG_MSG)
;;;1029       dump_config_descriptor(conf);
;;;1030   #endif
;;;1031   
;;;1032   #if 1  /* printf string descriptors, for debug only */
;;;1033       str_buff = (uint8_t *)usbh_alloc_mem(MAX_DESC_BUFF_SIZE);
;;;1034       if (udev->descriptor.iManufacturer != 0)
;;;1035       {
;;;1036           usbh_get_string_descriptor(udev, udev->descriptor.iManufacturer, str_buff, MAX_DESC_BUFF_SIZE);
;;;1037           print_usb_string("Manufacturer: ", str_buff);
;;;1038       }
;;;1039       if (udev->descriptor.iProduct != 0)
;;;1040       {
;;;1041           usbh_get_string_descriptor(udev, udev->descriptor.iProduct, str_buff, MAX_DESC_BUFF_SIZE);
;;;1042           print_usb_string("Product: ", str_buff);
;;;1043       }
;;;1044       if (udev->descriptor.iSerialNumber != 0)
;;;1045       {
;;;1046           usbh_get_string_descriptor(udev, udev->descriptor.iSerialNumber, str_buff, MAX_DESC_BUFF_SIZE);
;;;1047           print_usb_string("Serial Number: ", str_buff);
;;;1048       }
;;;1049       usbh_free_mem(str_buff, MAX_DESC_BUFF_SIZE);
;;;1050   #endif
;;;1051   
;;;1052       /* Always select the first configuration */
;;;1053       ret = usbh_set_configuration(udev, conf->bConfigurationValue);
;;;1054       if (ret < 0)
;;;1055       {
;;;1056           USB_debug("Set configuration %d failed!\n", conf->bConfigurationValue);
;;;1057           free_dev_address(udev->dev_num);
;;;1058           return ret;
;;;1059       }
;;;1060   
;;;1061       /* Parse the configuration/interface/endpoint descriptors and find corresponding drivers. */
;;;1062       ret = usbh_parse_configuration(udev, (uint8_t *)conf);
;;;1063       if (ret < 0)
;;;1064       {
;;;1065           USB_debug("Parse configuration %d failed!\n", conf->bConfigurationValue);
;;;1066           free_dev_address(udev->dev_num);
;;;1067           return ret;
;;;1068       }
;;;1069   
;;;1070       if (conf->bmAttributes & (1<<5))
;;;1071       {
;;;1072           /* Enable remote wakeup                                                                   */
;;;1073           if (usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
;;;1074                              USB_REQ_SET_FEATURE, 0x01, 0x0000, 0x0000,
;;;1075                              NULL, &read_len, 300) < 0)
;;;1076           {
;;;1077               USB_debug("Device does not accept remote wakeup enable command.\n");
;;;1078           }
;;;1079       }
;;;1080   
;;;1081       if (g_conn_func)
;;;1082           g_conn_func(udev, 0);
;;;1083   
;;;1084       return ret;
;;;1085   }
0011d8  e8bd80f0          POP      {r4-r7,pc}
                  |L1.4572|
0011dc  e59f01f0          LDR      r0,|L1.5076|
0011e0  ebfffffe          BL       delay_us
0011e4  e1a01004          MOV      r1,r4                 ;995
0011e8  e1a00004          MOV      r0,r4                 ;995
0011ec  ebfffffe          BL       usbh_get_device_descriptor
0011f0  e1a06000          MOV      r6,r0                 ;995
0011f4  e3560000          CMP      r6,#0                 ;996
0011f8  aa000003          BGE      |L1.4620|
0011fc  e5d40019          LDRB     r0,[r4,#0x19]         ;998
001200  ebfffffe          BL       free_dev_address
001204  e1a00006          MOV      r0,r6                 ;999
001208  eafffff1          B        |L1.4564|
                  |L1.4620|
00120c  e3a00a01          MOV      r0,#0x1000            ;1011
001210  ebfffffe          BL       usbh_alloc_mem
001214  e1a05000          MOV      r5,r0                 ;1011
001218  e3550000          CMP      r5,#0                 ;1012
00121c  1a000003          BNE      |L1.4656|
001220  e5d40019          LDRB     r0,[r4,#0x19]         ;1014
001224  ebfffffe          BL       free_dev_address
001228  e3e00009          MVN      r0,#9                 ;1015
00122c  eaffffe8          B        |L1.4564|
                  |L1.4656|
001230  e584501c          STR      r5,[r4,#0x1c]         ;1018
001234  e3a02a01          MOV      r2,#0x1000            ;1021
001238  e1a01005          MOV      r1,r5                 ;1021
00123c  e1a00004          MOV      r0,r4                 ;1021
001240  ebfffffe          BL       usbh_get_config_descriptor
001244  e1a06000          MOV      r6,r0                 ;1021
001248  e3560000          CMP      r6,#0                 ;1022
00124c  aa000003          BGE      |L1.4704|
001250  e5d40019          LDRB     r0,[r4,#0x19]         ;1024
001254  ebfffffe          BL       free_dev_address
001258  e1a00006          MOV      r0,r6                 ;1025
00125c  eaffffdc          B        |L1.4564|
                  |L1.4704|
001260  e3a00a01          MOV      r0,#0x1000            ;1033
001264  ebfffffe          BL       usbh_alloc_mem
001268  e1a07000          MOV      r7,r0                 ;1033
00126c  e5d4000e          LDRB     r0,[r4,#0xe]          ;1034
001270  e3500000          CMP      r0,#0                 ;1034
001274  0a000007          BEQ      |L1.4760|
001278  e5d4100e          LDRB     r1,[r4,#0xe]          ;1036
00127c  e3a03a01          MOV      r3,#0x1000            ;1036
001280  e1a02007          MOV      r2,r7                 ;1036
001284  e1a00004          MOV      r0,r4                 ;1036
001288  ebfffffe          BL       usbh_get_string_descriptor
00128c  e1a01007          MOV      r1,r7                 ;1037
001290  e28f0d05          ADR      r0,|L1.5080|
001294  ebfffffe          BL       print_usb_string
                  |L1.4760|
001298  e5d4000f          LDRB     r0,[r4,#0xf]          ;1039
00129c  e3500000          CMP      r0,#0                 ;1039
0012a0  0a000007          BEQ      |L1.4804|
0012a4  e5d4100f          LDRB     r1,[r4,#0xf]          ;1041
0012a8  e3a03a01          MOV      r3,#0x1000            ;1041
0012ac  e1a02007          MOV      r2,r7                 ;1041
0012b0  e1a00004          MOV      r0,r4                 ;1041
0012b4  ebfffffe          BL       usbh_get_string_descriptor
0012b8  e1a01007          MOV      r1,r7                 ;1042
0012bc  e28f0f49          ADR      r0,|L1.5096|
0012c0  ebfffffe          BL       print_usb_string
                  |L1.4804|
0012c4  e5d40010          LDRB     r0,[r4,#0x10]         ;1044
0012c8  e3500000          CMP      r0,#0                 ;1044
0012cc  0a000007          BEQ      |L1.4848|
0012d0  e5d41010          LDRB     r1,[r4,#0x10]         ;1046
0012d4  e3a03a01          MOV      r3,#0x1000            ;1046
0012d8  e1a02007          MOV      r2,r7                 ;1046
0012dc  e1a00004          MOV      r0,r4                 ;1046
0012e0  ebfffffe          BL       usbh_get_string_descriptor
0012e4  e1a01007          MOV      r1,r7                 ;1047
0012e8  e28f0f41          ADR      r0,|L1.5108|
0012ec  ebfffffe          BL       print_usb_string
                  |L1.4848|
0012f0  e3a01a01          MOV      r1,#0x1000            ;1049
0012f4  e1a00007          MOV      r0,r7                 ;1049
0012f8  ebfffffe          BL       usbh_free_mem
0012fc  e5d51005          LDRB     r1,[r5,#5]            ;1053
001300  e1a00004          MOV      r0,r4                 ;1053
001304  ebfffffe          BL       usbh_set_configuration
001308  e1a06000          MOV      r6,r0                 ;1053
00130c  e3560000          CMP      r6,#0                 ;1054
001310  aa000003          BGE      |L1.4900|
001314  e5d40019          LDRB     r0,[r4,#0x19]         ;1057
001318  ebfffffe          BL       free_dev_address
00131c  e1a00006          MOV      r0,r6                 ;1058
001320  eaffffab          B        |L1.4564|
                  |L1.4900|
001324  e1a01005          MOV      r1,r5                 ;1062
001328  e1a00004          MOV      r0,r4                 ;1062
00132c  ebfffffe          BL       usbh_parse_configuration
001330  e1a06000          MOV      r6,r0                 ;1062
001334  e3560000          CMP      r6,#0                 ;1063
001338  aa000003          BGE      |L1.4940|
00133c  e5d40019          LDRB     r0,[r4,#0x19]         ;1066
001340  ebfffffe          BL       free_dev_address
001344  e1a00006          MOV      r0,r6                 ;1067
001348  eaffffa1          B        |L1.4564|
                  |L1.4940|
00134c  e5d50007          LDRB     r0,[r5,#7]            ;1070
001350  e3100020          TST      r0,#0x20              ;1070
001354  0a00000c          BEQ      |L1.5004|
001358  e3a00f4b          MOV      r0,#0x12c             ;1073
00135c  e28d1018          ADD      r1,sp,#0x18           ;1073
001360  e3a02000          MOV      r2,#0                 ;1073
001364  e58d2004          STR      r2,[sp,#4]            ;1073
001368  e58d0010          STR      r0,[sp,#0x10]         ;1073
00136c  e58d100c          STR      r1,[sp,#0xc]          ;1073
001370  e58d2008          STR      r2,[sp,#8]            ;1073
001374  e3a03001          MOV      r3,#1                 ;1073
001378  e58d2000          STR      r2,[sp,#0]            ;1073
00137c  e3a02003          MOV      r2,#3                 ;1073
001380  e3a01000          MOV      r1,#0                 ;1073
001384  e1a00004          MOV      r0,r4                 ;1073
001388  ebfffffe          BL       usbh_ctrl_xfer
                  |L1.5004|
00138c  e51f0ecc          LDR      r0,|L1.1224|
001390  e5900000          LDR      r0,[r0,#0]            ;1081  ; g_conn_func
001394  e3500000          CMP      r0,#0                 ;1081
001398  0a000004          BEQ      |L1.5040|
00139c  e3a01000          MOV      r1,#0                 ;1082
0013a0  e1a00004          MOV      r0,r4                 ;1082
0013a4  e51f2ee4          LDR      r2,|L1.1224|
0013a8  e5922000          LDR      r2,[r2,#0]            ;1082  ; g_conn_func
0013ac  e12fff32          BLX      r2                    ;1082
                  |L1.5040|
0013b0  e1a00006          MOV      r0,r6                 ;1084
0013b4  eaffff86          B        |L1.4564|
                  |L1.5048|
0013b8  45525220          DCB      "ERR DESCRIPTOR CONFIG [%d]\n",0
0013bc  44455343
0013c0  52495054
0013c4  4f522043
0013c8  4f4e4649
0013cc  47205b25
0013d0  645d0a00
                  |L1.5076|
                          DCD      0x000186a0
                  |L1.5080|
0013d8  4d616e75          DCB      "Manufacturer: ",0
0013dc  66616374
0013e0  75726572
0013e4  3a2000  
0013e7  00                DCB      0
                  |L1.5096|
0013e8  50726f64          DCB      "Product: ",0
0013ec  7563743a
0013f0  2000    
0013f2  00                DCB      0
0013f3  00                DCB      0
                  |L1.5108|
0013f4  53657269          DCB      "Serial Number: ",0
0013f8  616c204e
0013fc  756d6265
001400  723a2000
                          ENDP

                  usbh_reset_device PROC
;;;1086   
;;;1087   int  usbh_reset_device(UDEV_T *udev)
001404  e92d41f0          PUSH     {r4-r8,lr}
;;;1088   {
001408  e24dd018          SUB      sp,sp,#0x18
00140c  e1a04000          MOV      r4,r0
;;;1089       IFACE_T      *iface;
;;;1090       DESC_CONF_T  *conf;
;;;1091       uint32_t     read_len;
;;;1092       int          dev_num, ret;
;;;1093   
;;;1094       USB_debug("Reset device =>\n");
;;;1095   
;;;1096       usbh_pooling_hubs();
001410  ebfffffe          BL       usbh_pooling_hubs
;;;1097   
;;;1098       /*------------------------------------------------------------------------------------*/
;;;1099       /*  Disconnect device                                                                 */
;;;1100       /*------------------------------------------------------------------------------------*/
;;;1101   
;;;1102       if (g_disconn_func)
001414  e51f0f50          LDR      r0,|L1.1228|
001418  e5900000          LDR      r0,[r0,#0]  ; g_disconn_func
00141c  e3500000          CMP      r0,#0
001420  0a000004          BEQ      |L1.5176|
;;;1103           g_disconn_func(udev, 0);
001424  e3a01000          MOV      r1,#0
001428  e1a00004          MOV      r0,r4
00142c  e51f2f68          LDR      r2,|L1.1228|
001430  e5922000          LDR      r2,[r2,#0]  ; g_disconn_func
001434  e12fff32          BLX      r2
                  |L1.5176|
;;;1104   
;;;1105       usbh_quit_xfer(udev, &(udev->ep0));    /* Quit control transfer if hw_pipe is not NULL.  */
001438  e2841020          ADD      r1,r4,#0x20
00143c  e1a00004          MOV      r0,r4
001440  ebfffffe          BL       usbh_quit_xfer
;;;1106   
;;;1107       /* Notified all actived interface device driver  */
;;;1108       iface = udev->iface_list;
001444  e5946030          LDR      r6,[r4,#0x30]
;;;1109       while (iface != NULL)
001448  ea000009          B        |L1.5236|
                  |L1.5196|
;;;1110       {
;;;1111           udev->iface_list = iface->next;
00144c  e59604c4          LDR      r0,[r6,#0x4c4]
001450  e5840030          STR      r0,[r4,#0x30]
;;;1112           iface->driver->disconnect(iface);
001454  e59604bc          LDR      r0,[r6,#0x4bc]
001458  e5901004          LDR      r1,[r0,#4]
00145c  e1a00006          MOV      r0,r6
001460  e12fff31          BLX      r1
;;;1113           usbh_free_mem(iface, sizeof(*iface));
001464  e51f1428          LDR      r1,|L1.4164|
001468  e1a00006          MOV      r0,r6
00146c  ebfffffe          BL       usbh_free_mem
;;;1114           iface = udev->iface_list;
001470  e5946030          LDR      r6,[r4,#0x30]
                  |L1.5236|
001474  e3560000          CMP      r6,#0                 ;1109
001478  1afffff3          BNE      |L1.5196|
;;;1115       }
;;;1116   
;;;1117       /*------------------------------------------------------------------------------------*/
;;;1118       /*  Reset device                                                                      */
;;;1119       /*------------------------------------------------------------------------------------*/
;;;1120   
;;;1121       reset_device(udev);
00147c  e1a00004          MOV      r0,r4
001480  ebfffffe          BL       reset_device
;;;1122   
;;;1123       delay_us(100 * 1000);
001484  e51f00b8          LDR      r0,|L1.5076|
001488  ebfffffe          BL       delay_us
;;;1124   
;;;1125       /*------------------------------------------------------------------------------------*/
;;;1126       /*  Set address (use current address)                                                 */
;;;1127       /*------------------------------------------------------------------------------------*/
;;;1128   
;;;1129       dev_num = udev->dev_num;
00148c  e5d47019          LDRB     r7,[r4,#0x19]
;;;1130       udev->dev_num = 0;
001490  e3a00000          MOV      r0,#0
001494  e5c40019          STRB     r0,[r4,#0x19]
;;;1131       /* Issue SET ADDRESS command to set the same device address                           */
;;;1132       ret = usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
001498  e3a00064          MOV      r0,#0x64
00149c  e28d1014          ADD      r1,sp,#0x14
0014a0  e3a02000          MOV      r2,#0
0014a4  e58d2004          STR      r2,[sp,#4]
0014a8  e58d0010          STR      r0,[sp,#0x10]
0014ac  e58d100c          STR      r1,[sp,#0xc]
0014b0  e58d2008          STR      r2,[sp,#8]
0014b4  e1a03007          MOV      r3,r7
0014b8  e58d2000          STR      r2,[sp,#0]
0014bc  e3a02005          MOV      r2,#5
0014c0  e3a01000          MOV      r1,#0
0014c4  e1a00004          MOV      r0,r4
0014c8  ebfffffe          BL       usbh_ctrl_xfer
0014cc  e1a05000          MOV      r5,r0
;;;1133                            USB_REQ_SET_ADDRESS, dev_num, 0, 0,
;;;1134                            NULL, &read_len, 100);
;;;1135       udev->dev_num = dev_num;
0014d0  e5c47019          STRB     r7,[r4,#0x19]
;;;1136       if (ret < 0)
0014d4  e3550000          CMP      r5,#0
0014d8  aa000002          BGE      |L1.5352|
;;;1137           return ret;
0014dc  e1a00005          MOV      r0,r5
                  |L1.5344|
0014e0  e28dd018          ADD      sp,sp,#0x18
;;;1138   
;;;1139       delay_us(100 * 1000);                   /* after set address, give 100 ms delay       */
;;;1140   
;;;1141       /*------------------------------------------------------------------------------------*/
;;;1142       /*  Get device descriptor                                                             */
;;;1143       /*------------------------------------------------------------------------------------*/
;;;1144   
;;;1145       /* Get device descriptor again with new device address */
;;;1146       ret = usbh_get_device_descriptor(udev, &udev->descriptor);
;;;1147       if (ret < 0)
;;;1148           return ret;
;;;1149   
;;;1150       /*------------------------------------------------------------------------------------*/
;;;1151       /*  Get configuration descriptor                                                      */
;;;1152       /*------------------------------------------------------------------------------------*/
;;;1153   
;;;1154       conf = (DESC_CONF_T *)udev->cfd_buff;   /* using the previously allocated buffer      */
;;;1155   
;;;1156       /* Get configuration descriptor again with new device address */
;;;1157       ret = usbh_get_config_descriptor(udev, (uint8_t *)conf, MAX_DESC_BUFF_SIZE);
;;;1158       if (ret < 0)
;;;1159           return ret;
;;;1160   
;;;1161       /* Always select the first configuration */
;;;1162       ret = usbh_set_configuration(udev, udev->cur_conf);
;;;1163       if (ret < 0)
;;;1164       {
;;;1165           USB_debug("Set configuration %d failed!\n", udev->cur_conf);
;;;1166           return ret;
;;;1167       }
;;;1168   
;;;1169       /* Parse the configuration/interface/endpoint descriptors and find corresponding drivers. */
;;;1170       ret = usbh_parse_configuration(udev, (uint8_t *)conf);
;;;1171       if (ret < 0)
;;;1172       {
;;;1173           USB_debug("Parse configuration %d failed!\n", conf->bConfigurationValue);
;;;1174           return ret;
;;;1175       }
;;;1176   
;;;1177       /* Enable remote wakeup                                                                   */
;;;1178       if (usbh_ctrl_xfer(udev, REQ_TYPE_OUT | REQ_TYPE_STD_DEV | REQ_TYPE_TO_DEV,
;;;1179                          USB_REQ_SET_FEATURE, 0x01, 0x0000, 0x0000,
;;;1180                          NULL, &read_len, 300) < 0)
;;;1181       {
;;;1182           USB_debug("Device not accept remote wakeup enable command.\n");
;;;1183       }
;;;1184   
;;;1185       if (g_conn_func)
;;;1186           g_conn_func(udev, 0);
;;;1187   
;;;1188       return ret;
;;;1189   }
0014e4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.5352|
0014e8  e51f011c          LDR      r0,|L1.5076|
0014ec  ebfffffe          BL       delay_us
0014f0  e1a01004          MOV      r1,r4                 ;1146
0014f4  e1a00004          MOV      r0,r4                 ;1146
0014f8  ebfffffe          BL       usbh_get_device_descriptor
0014fc  e1a05000          MOV      r5,r0                 ;1146
001500  e3550000          CMP      r5,#0                 ;1147
001504  aa000001          BGE      |L1.5392|
001508  e1a00005          MOV      r0,r5                 ;1148
00150c  eafffff3          B        |L1.5344|
                  |L1.5392|
001510  e594801c          LDR      r8,[r4,#0x1c]         ;1154
001514  e3a02a01          MOV      r2,#0x1000            ;1157
001518  e1a01008          MOV      r1,r8                 ;1157
00151c  e1a00004          MOV      r0,r4                 ;1157
001520  ebfffffe          BL       usbh_get_config_descriptor
001524  e1a05000          MOV      r5,r0                 ;1157
001528  e3550000          CMP      r5,#0                 ;1158
00152c  aa000001          BGE      |L1.5432|
001530  e1a00005          MOV      r0,r5                 ;1159
001534  eaffffe9          B        |L1.5344|
                  |L1.5432|
001538  e5d4101a          LDRB     r1,[r4,#0x1a]         ;1162
00153c  e1a00004          MOV      r0,r4                 ;1162
001540  ebfffffe          BL       usbh_set_configuration
001544  e1a05000          MOV      r5,r0                 ;1162
001548  e3550000          CMP      r5,#0                 ;1163
00154c  aa000001          BGE      |L1.5464|
001550  e1a00005          MOV      r0,r5                 ;1166
001554  eaffffe1          B        |L1.5344|
                  |L1.5464|
001558  e1a01008          MOV      r1,r8                 ;1170
00155c  e1a00004          MOV      r0,r4                 ;1170
001560  ebfffffe          BL       usbh_parse_configuration
001564  e1a05000          MOV      r5,r0                 ;1170
001568  e3550000          CMP      r5,#0                 ;1171
00156c  aa000001          BGE      |L1.5496|
001570  e1a00005          MOV      r0,r5                 ;1174
001574  eaffffd9          B        |L1.5344|
                  |L1.5496|
001578  e3a00f4b          MOV      r0,#0x12c             ;1178
00157c  e28d1014          ADD      r1,sp,#0x14           ;1178
001580  e3a02000          MOV      r2,#0                 ;1178
001584  e58d2004          STR      r2,[sp,#4]            ;1178
001588  e58d0010          STR      r0,[sp,#0x10]         ;1178
00158c  e58d100c          STR      r1,[sp,#0xc]          ;1178
001590  e58d2008          STR      r2,[sp,#8]            ;1178
001594  e3a03001          MOV      r3,#1                 ;1178
001598  e58d2000          STR      r2,[sp,#0]            ;1178
00159c  e3a02003          MOV      r2,#3                 ;1178
0015a0  e3a01000          MOV      r1,#0                 ;1178
0015a4  e1a00004          MOV      r0,r4                 ;1178
0015a8  ebfffffe          BL       usbh_ctrl_xfer
0015ac  e59f0254          LDR      r0,|L1.6152|
0015b0  e5900000          LDR      r0,[r0,#0]            ;1185  ; g_conn_func
0015b4  e3500000          CMP      r0,#0                 ;1185
0015b8  0a000004          BEQ      |L1.5584|
0015bc  e3a01000          MOV      r1,#0                 ;1186
0015c0  e1a00004          MOV      r0,r4                 ;1186
0015c4  e59f223c          LDR      r2,|L1.6152|
0015c8  e5922000          LDR      r2,[r2,#0]            ;1186  ; g_conn_func
0015cc  e12fff32          BLX      r2                    ;1186
                  |L1.5584|
0015d0  e1a00005          MOV      r0,r5                 ;1188
0015d4  eaffffc1          B        |L1.5344|
;;;1190   
                          ENDP

                  disconnect_device PROC
;;;1191   void disconnect_device(UDEV_T *udev)
0015d8  e92d4070          PUSH     {r4-r6,lr}
;;;1192   {
0015dc  e1a04000          MOV      r4,r0
;;;1193       IFACE_T      *iface;
;;;1194   
;;;1195       USB_debug("disconnect device...\n");
;;;1196   
;;;1197       if (g_disconn_func)
0015e0  e59f0224          LDR      r0,|L1.6156|
0015e4  e5900000          LDR      r0,[r0,#0]  ; g_disconn_func
0015e8  e3500000          CMP      r0,#0
0015ec  0a000004          BEQ      |L1.5636|
;;;1198           g_disconn_func(udev, 0);
0015f0  e3a01000          MOV      r1,#0
0015f4  e1a00004          MOV      r0,r4
0015f8  e59f220c          LDR      r2,|L1.6156|
0015fc  e5922000          LDR      r2,[r2,#0]  ; g_disconn_func
001600  e12fff32          BLX      r2
                  |L1.5636|
;;;1199   
;;;1200       usbh_quit_xfer(udev, &(udev->ep0));    /* Quit control transfer if hw_pipe is not NULL.  */
001604  e2841020          ADD      r1,r4,#0x20
001608  e1a00004          MOV      r0,r4
00160c  ebfffffe          BL       usbh_quit_xfer
;;;1201   
;;;1202       /* Notified all actived interface device driver  */
;;;1203       iface = udev->iface_list;
001610  e5945030          LDR      r5,[r4,#0x30]
;;;1204       while (iface != NULL)
001614  ea000009          B        |L1.5696|
                  |L1.5656|
;;;1205       {
;;;1206           udev->iface_list = iface->next;
001618  e59504c4          LDR      r0,[r5,#0x4c4]
00161c  e5840030          STR      r0,[r4,#0x30]
;;;1207           iface->driver->disconnect(iface);
001620  e59504bc          LDR      r0,[r5,#0x4bc]
001624  e5901004          LDR      r1,[r0,#4]
001628  e1a00005          MOV      r0,r5
00162c  e12fff31          BLX      r1
;;;1208           usbh_free_mem(iface, sizeof(*iface));
001630  e51f15f4          LDR      r1,|L1.4164|
001634  e1a00005          MOV      r0,r5
001638  ebfffffe          BL       usbh_free_mem
;;;1209           iface = udev->iface_list;
00163c  e5945030          LDR      r5,[r4,#0x30]
                  |L1.5696|
001640  e3550000          CMP      r5,#0                 ;1204
001644  1afffff3          BNE      |L1.5656|
;;;1210       }
;;;1211   
;;;1212       /* remove device from global device list */
;;;1213       free_dev_address(udev->dev_num);
001648  e5d40019          LDRB     r0,[r4,#0x19]
00164c  ebfffffe          BL       free_dev_address
;;;1214       free_device(udev);
001650  e1a00004          MOV      r0,r4
001654  ebfffffe          BL       free_device
;;;1215   
;;;1216       usbh_memory_used();
001658  ebfffffe          BL       usbh_memory_used
;;;1217   }
00165c  e8bd8070          POP      {r4-r6,pc}
;;;1218   
                          ENDP

                  usbh_iface_find_ep PROC
;;;1240   
;;;1241   EP_INFO_T * usbh_iface_find_ep(IFACE_T *iface, uint8_t ep_addr, uint8_t dir_type)
001660  e92d4030          PUSH     {r4,r5,lr}
;;;1242   {
001664  e1a04000          MOV      r4,r0
001668  e1a03001          MOV      r3,r1
00166c  e1a0c002          MOV      r12,r2
;;;1243       ALT_IFACE_T  *aif = iface->aif;
001670  e5942008          LDR      r2,[r4,#8]
;;;1244       int     i;
;;;1245   
;;;1246       if (ep_addr == 0)      /* find the first EP matched with specified direction and type */
001674  e3530000          CMP      r3,#0
001678  1a000019          BNE      |L1.5860|
;;;1247       {
;;;1248           for (i = 0; i < aif->ifd->bNumEndpoints; i++)
00167c  e3a01000          MOV      r1,#0
001680  ea000012          B        |L1.5840|
                  |L1.5764|
;;;1249           {
;;;1250               if (((aif->ep[i].bEndpointAddress & EP_ADDR_DIR_MASK) == (dir_type & EP_ADDR_DIR_MASK)) &&
001684  e0810081          ADD      r0,r1,r1,LSL #1
001688  e2825004          ADD      r5,r2,#4
00168c  e7d50100          LDRB     r0,[r5,r0,LSL #2]
001690  e2000080          AND      r0,r0,#0x80
001694  e20c5080          AND      r5,r12,#0x80
001698  e1500005          CMP      r0,r5
00169c  1a00000a          BNE      |L1.5836|
;;;1251                       ((aif->ep[i].bmAttributes & EP_ATTR_TT_MASK) == (dir_type & EP_ATTR_TT_MASK)))
0016a0  e0810081          ADD      r0,r1,r1,LSL #1
0016a4  e2825004          ADD      r5,r2,#4
0016a8  e0850100          ADD      r0,r5,r0,LSL #2
0016ac  e5d00001          LDRB     r0,[r0,#1]
0016b0  e1a00f00          LSL      r0,r0,#30
0016b4  e1500f0c          CMP      r0,r12,LSL #30
0016b8  1a000003          BNE      |L1.5836|
;;;1252                   return &aif->ep[i];
0016bc  e0810081          ADD      r0,r1,r1,LSL #1
0016c0  e2825004          ADD      r5,r2,#4
0016c4  e0850100          ADD      r0,r5,r0,LSL #2
                  |L1.5832|
;;;1253           }
;;;1254       }
;;;1255       else                   /* find the EP with specified endpoint address                 */
;;;1256       {
;;;1257           for (i = 0; i < aif->ifd->bNumEndpoints; i++)
;;;1258           {
;;;1259               if (aif->ep[i].bEndpointAddress == ep_addr)
;;;1260                   return &aif->ep[i];
;;;1261           }
;;;1262       }
;;;1263       return NULL;
;;;1264   }
0016c8  e8bd8030          POP      {r4,r5,pc}
                  |L1.5836|
0016cc  e2811001          ADD      r1,r1,#1              ;1248
                  |L1.5840|
0016d0  e5920000          LDR      r0,[r2,#0]            ;1248
0016d4  e5d00004          LDRB     r0,[r0,#4]            ;1248
0016d8  e1500001          CMP      r0,r1                 ;1248
0016dc  caffffe8          BGT      |L1.5764|
0016e0  ea00000f          B        |L1.5924|
                  |L1.5860|
0016e4  e3a01000          MOV      r1,#0                 ;1257
0016e8  ea000009          B        |L1.5908|
                  |L1.5868|
0016ec  e0810081          ADD      r0,r1,r1,LSL #1       ;1259
0016f0  e2825004          ADD      r5,r2,#4              ;1259
0016f4  e7d50100          LDRB     r0,[r5,r0,LSL #2]     ;1259
0016f8  e1500003          CMP      r0,r3                 ;1259
0016fc  1a000003          BNE      |L1.5904|
001700  e0810081          ADD      r0,r1,r1,LSL #1       ;1260
001704  e2825004          ADD      r5,r2,#4              ;1260
001708  e0850100          ADD      r0,r5,r0,LSL #2       ;1260
00170c  eaffffed          B        |L1.5832|
                  |L1.5904|
001710  e2811001          ADD      r1,r1,#1              ;1257
                  |L1.5908|
001714  e5920000          LDR      r0,[r2,#0]            ;1257
001718  e5d00004          LDRB     r0,[r0,#4]            ;1257
00171c  e1500001          CMP      r0,r1                 ;1257
001720  cafffff1          BGT      |L1.5868|
                  |L1.5924|
001724  e3a00000          MOV      r0,#0                 ;1263
001728  eaffffe6          B        |L1.5832|
;;;1265   
                          ENDP

                  usbh_dump_buff_bytes PROC
;;;1266   void  usbh_dump_buff_bytes(uint8_t *buff, int nSize)
00172c  e92d41f0          PUSH     {r4-r8,lr}
;;;1267   {
001730  e1a06000          MOV      r6,r0
001734  e1a07001          MOV      r7,r1
;;;1268       int     nIdx, i;
;;;1269   
;;;1270       nIdx = 0;
001738  e3a05000          MOV      r5,#0
;;;1271       while (nSize > 0)
00173c  ea000025          B        |L1.6104|
                  |L1.5952|
;;;1272       {
;;;1273           sysprintf("0x%04X  ", nIdx);
001740  e1a01005          MOV      r1,r5
001744  e28f00c4          ADR      r0,|L1.6160|
001748  ebfffffe          BL       sysprintf
;;;1274           for (i = 0; i < 16; i++)
00174c  e3a04000          MOV      r4,#0
001750  ea000004          B        |L1.5992|
                  |L1.5972|
;;;1275               sysprintf("%02x ", buff[nIdx + i]);
001754  e0850004          ADD      r0,r5,r4
001758  e7d61000          LDRB     r1,[r6,r0]
00175c  e28f00b8          ADR      r0,|L1.6172|
001760  ebfffffe          BL       sysprintf
001764  e2844001          ADD      r4,r4,#1              ;1274
                  |L1.5992|
001768  e3540010          CMP      r4,#0x10              ;1274
00176c  bafffff8          BLT      |L1.5972|
;;;1276           sysprintf("  ");
001770  e28f00ac          ADR      r0,|L1.6180|
001774  ebfffffe          BL       sysprintf
;;;1277           for (i = 0; i < 16; i++)
001778  e3a04000          MOV      r4,#0
00177c  ea000010          B        |L1.6084|
                  |L1.6016|
;;;1278           {
;;;1279               if ((buff[nIdx + i] >= 0x20) && (buff[nIdx + i] < 127))
001780  e0850004          ADD      r0,r5,r4
001784  e7d60000          LDRB     r0,[r6,r0]
001788  e3500020          CMP      r0,#0x20
00178c  ba000008          BLT      |L1.6068|
001790  e0850004          ADD      r0,r5,r4
001794  e7d60000          LDRB     r0,[r6,r0]
001798  e350007f          CMP      r0,#0x7f
00179c  aa000004          BGE      |L1.6068|
;;;1280                   sysprintf("%c", buff[nIdx + i]);
0017a0  e0850004          ADD      r0,r5,r4
0017a4  e7d61000          LDRB     r1,[r6,r0]
0017a8  e28f0078          ADR      r0,|L1.6184|
0017ac  ebfffffe          BL       sysprintf
0017b0  ea000001          B        |L1.6076|
                  |L1.6068|
;;;1281               else
;;;1282                   sysprintf(".");
0017b4  e28f0070          ADR      r0,|L1.6188|
0017b8  ebfffffe          BL       sysprintf
                  |L1.6076|
;;;1283               nSize--;
0017bc  e2477001          SUB      r7,r7,#1
0017c0  e2844001          ADD      r4,r4,#1              ;1277
                  |L1.6084|
0017c4  e3540010          CMP      r4,#0x10              ;1277
0017c8  baffffec          BLT      |L1.6016|
;;;1284           }
;;;1285           nIdx += 16;
0017cc  e2855010          ADD      r5,r5,#0x10
;;;1286           sysprintf("\n");
0017d0  e28f0058          ADR      r0,|L1.6192|
0017d4  ebfffffe          BL       sysprintf
                  |L1.6104|
0017d8  e3570000          CMP      r7,#0                 ;1271
0017dc  caffffd7          BGT      |L1.5952|
;;;1287       }
;;;1288       sysprintf("\n");
0017e0  e28f0048          ADR      r0,|L1.6192|
0017e4  ebfffffe          BL       sysprintf
;;;1289   }
0017e8  e8bd81f0          POP      {r4-r8,pc}
;;;1290   
                          ENDP

                  usbh_dump_iface PROC
;;;1291   void usbh_dump_iface(IFACE_T *iface)
0017ec  e52de004          PUSH     {lr}
;;;1292   {
0017f0  e1a01000          MOV      r1,r0
;;;1293       USB_debug("\n  [IFACE info] (0x%x)\n", (int)iface);
;;;1294       USB_debug("  ----------------------------------------------\n");
;;;1295       USB_debug("  udev       = 0x%x\n", iface->udev);
;;;1296       USB_debug("  if_num     = %d\n", iface->if_num);
;;;1297       USB_debug("  driver     = 0x%x\n", (int)iface->driver);
;;;1298       USB_debug("  next       = 0x%x\n", (int)iface->next);
;;;1299       usbh_dump_interface_descriptor(iface->aif->ifd);
0017f4  e5912008          LDR      r2,[r1,#8]
0017f8  e5920000          LDR      r0,[r2,#0]
0017fc  ebfffffe          BL       usbh_dump_interface_descriptor
;;;1300   }
001800  e49df004          POP      {pc}
;;;1301   
                          ENDP

                  usbh_dump_ep_info PROC
;;;1302   void usbh_dump_ep_info(EP_INFO_T *ep)
001804  e12fff1e          BX       lr
;;;1303   {
;;;1304       USB_debug("\n  [Endpoint Info] (0x%x)\n", (int)ep);
;;;1305       USB_debug("  ----------------------------------------------\n");
;;;1306       USB_debug("  bEndpointAddress    = 0x%02x\n", ep->bEndpointAddress);
;;;1307       USB_debug("  bmAttributes        = 0x%02x\n", ep->bmAttributes);
;;;1308       USB_debug("  bInterval           = %d\n",     ep->bInterval);
;;;1309       USB_debug("  wMaxPacketSize      = %d\n",     ep->wMaxPacketSize);
;;;1310       USB_debug("  hw_pipe             = 0x%x\n",   (int)ep->hw_pipe);
;;;1311   }
;;;1312   
                          ENDP

                  |L1.6152|
                          DCD      g_conn_func
                  |L1.6156|
                          DCD      g_disconn_func
                  |L1.6160|
001810  30782530          DCB      "0x%04X  ",0
001814  34582020
001818  00      
001819  00                DCB      0
00181a  00                DCB      0
00181b  00                DCB      0
                  |L1.6172|
00181c  25303278          DCB      "%02x ",0
001820  2000    
001822  00                DCB      0
001823  00                DCB      0
                  |L1.6180|
001824  202000            DCB      "  ",0
001827  00                DCB      0
                  |L1.6184|
001828  256300            DCB      "%c",0
00182b  00                DCB      0
                  |L1.6188|
00182c  2e00              DCB      ".",0
00182e  00                DCB      0
00182f  00                DCB      0
                  |L1.6192|
001830  0a00              DCB      "\n",0
001832  00                DCB      0
001833  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _drivers
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  _ohci
                          DCD      0x00000000
                  _ehci
                          DCD      0x00000000
                  g_conn_func
                          DCD      0x00000000
                  g_disconn_func
                          DCD      0x00000000
                  ehci_UCMDR
                          DCD      0x00000000
