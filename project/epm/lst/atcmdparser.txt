; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\atcmdparser.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\atcmdparser.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\atcmdparser.crf src\syshal\modemlib\atcmdparser.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  printfBuffData PROC
;;;135    //#if(0)
;;;136    static void printfBuffData(char* str, uint8_t* data, int len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;137    {
000004  e1a07000          MOV      r7,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
;;;138        int i;
;;;139        sysprintf("\r\n %s: len = %d...\r\n   -%02d:-> ", str, len, len);
000010  e1a03006          MOV      r3,r6
000014  e1a02006          MOV      r2,r6
000018  e1a01007          MOV      r1,r7
00001c  e28f0faf          ADR      r0,|L1.736|
000020  ebfffffe          BL       sysprintf
;;;140        
;;;141        for(i = 0; i<len; i++)
000024  e3a04000          MOV      r4,#0
000028  ea000010          B        |L1.112|
                  |L1.44|
;;;142        { 
;;;143            if((data[i]>=0x20)&&(data[i]<=0x7e))
00002c  e7d50004          LDRB     r0,[r5,r4]
000030  e3500020          CMP      r0,#0x20
000034  ba000008          BLT      |L1.92|
000038  e7d50004          LDRB     r0,[r5,r4]
00003c  e350007e          CMP      r0,#0x7e
000040  ca000005          BGT      |L1.92|
;;;144                sysprintf("[%02d]:0x%02x(%c)\r\n", i, (unsigned char)data[i], (unsigned char)data[i]);
000044  e7d53004          LDRB     r3,[r5,r4]
000048  e7d52004          LDRB     r2,[r5,r4]
00004c  e1a01004          MOV      r1,r4
000050  e28f0fab          ADR      r0,|L1.772|
000054  ebfffffe          BL       sysprintf
000058  ea000003          B        |L1.108|
                  |L1.92|
;;;145            else
;;;146                sysprintf("[%02d]:0x%02x\r\n", i, (unsigned char)data[i]);
00005c  e7d52004          LDRB     r2,[r5,r4]
000060  e1a01004          MOV      r1,r4
000064  e28f0fab          ADR      r0,|L1.792|
000068  ebfffffe          BL       sysprintf
                  |L1.108|
00006c  e2844001          ADD      r4,r4,#1              ;141
                  |L1.112|
000070  e1540006          CMP      r4,r6                 ;141
000074  baffffec          BLT      |L1.44|
;;;147        }
;;;148        sysprintf("\r\n");
000078  e28f0faa          ADR      r0,|L1.808|
00007c  ebfffffe          BL       sysprintf
;;;149        
;;;150    }
000080  e8bd81f0          POP      {r4-r8,pc}
;;;151    //#endif
                          ENDP

                  fineCurrentCmdRegType PROC
;;;152    
;;;153    static CmdReq fineCurrentCmdRegType(uint8_t* data, uint8_t len, WaitOKFlag* waitOKFlag)
000084  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
000088  e1a06000          MOV      r6,r0
00008c  e1a08001          MOV      r8,r1
000090  e1a05002          MOV      r5,r2
;;;155        int i;
;;;156        #if(ENABLE_AT_CMD_DEBUG_2)
;;;157                sysprintf("   ~enter~ fineCurrentCmdRegType\r\n");
;;;158        #endif
;;;159        *waitOKFlag = WAIT_OK_FLAG_FALSE;
000094  e3a00002          MOV      r0,#2
000098  e5c50000          STRB     r0,[r5,#0]
;;;160        for(i = 0; ; i++)
00009c  e3a04000          MOV      r4,#0
0000a0  e1a00000          MOV      r0,r0
                  |L1.164|
;;;161        {
;;;162    		if (cmdList[i].cmdId == CMD_REQ_NULL)
0000a4  e0840084          ADD      r0,r4,r4,LSL #1
0000a8  e59f127c          LDR      r1,|L1.812|
0000ac  e0810100          ADD      r0,r1,r0,LSL #2
0000b0  e1d000b0          LDRH     r0,[r0,#0]
0000b4  e3500000          CMP      r0,#0
0000b8  1a000000          BNE      |L1.192|
;;;163                break;
0000bc  ea000019          B        |L1.296|
                  |L1.192|
;;;164            if(memcmp(data, cmdList[i].checkcmd, strlen((char*)cmdList[i].checkcmd)) == 0)
0000c0  e0841084          ADD      r1,r4,r4,LSL #1
0000c4  e59f2260          LDR      r2,|L1.812|
0000c8  e0821101          ADD      r1,r2,r1,LSL #2
0000cc  e5910004          LDR      r0,[r1,#4]
0000d0  ebfffffe          BL       strlen
0000d4  e1a07000          MOV      r7,r0
0000d8  e0840084          ADD      r0,r4,r4,LSL #1
0000dc  e59f2248          LDR      r2,|L1.812|
0000e0  e0820100          ADD      r0,r2,r0,LSL #2
0000e4  e1a02007          MOV      r2,r7
0000e8  e5901004          LDR      r1,[r0,#4]
0000ec  e1a00006          MOV      r0,r6
0000f0  ebfffffe          BL       memcmp
0000f4  e3500000          CMP      r0,#0
0000f8  1a000008          BNE      |L1.288|
;;;165            {
;;;166                #if(ENABLE_AT_CMD_DEBUG_2)
;;;167                sysprintf("   ~~ fineCurrentCmdRegType return: %d (len = %d) \r\n", cmdList[i].cmdId, (unsigned char)len);
;;;168                #endif
;;;169                *waitOKFlag = cmdList[i].waitOKFlag;
0000fc  e0840084          ADD      r0,r4,r4,LSL #1
000100  e59f1224          LDR      r1,|L1.812|
000104  e0810100          ADD      r0,r1,r0,LSL #2
000108  e5d00008          LDRB     r0,[r0,#8]
00010c  e5c50000          STRB     r0,[r5,#0]
;;;170                return cmdList[i].cmdId;
000110  e0840084          ADD      r0,r4,r4,LSL #1
000114  e0810100          ADD      r0,r1,r0,LSL #2
000118  e1d000b0          LDRH     r0,[r0,#0]
                  |L1.284|
;;;171            }
;;;172        }
;;;173        return CMD_REQ_NULL;
;;;174    }
00011c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.288|
000120  e2844001          ADD      r4,r4,#1              ;160
000124  eaffffde          B        |L1.164|
                  |L1.296|
000128  e1a00000          MOV      r0,r0                 ;163
00012c  e3a00000          MOV      r0,#0                 ;173
000130  eafffff9          B        |L1.284|
;;;175    
                          ENDP

                  preProcessCmdData PROC
;;;176    static CmdReq preProcessCmdData(DataType targetHeaderIndex, uint8_t* data, int len, ParserType parserType)
000134  e92d43f8          PUSH     {r3-r9,lr}
;;;177    {
000138  e1a05000          MOV      r5,r0
00013c  e1a06001          MOV      r6,r1
000140  e1a04002          MOV      r4,r2
000144  e1a08003          MOV      r8,r3
;;;178    	CmdReq cmdReq = CMD_REQ_NULL;
000148  e3a07000          MOV      r7,#0
;;;179        WaitOKFlag waitOKFlag;
;;;180        //sysprintf("   ~ AT Receive [type %d] : (%d)~ [%s] \r\n", targetHeaderIndex, len, data);
;;;181        switch(targetHeaderIndex)
00014c  e3550008          CMP      r5,#8
000150  308ff105          ADDCC    pc,pc,r5,LSL #2
000154  ea00004f          B        |L1.664|
000158  ea00004e          B        |L1.664|
00015c  ea000005          B        |L1.376|
000160  ea000011          B        |L1.428|
000164  ea000033          B        |L1.568|
000168  ea000015          B        |L1.452|
00016c  ea000037          B        |L1.592|
000170  ea00003c          B        |L1.616|
000174  ea000041          B        |L1.640|
                  |L1.376|
;;;182        {
;;;183        case DATA_TYPE_OK:
000178  e1a00000          MOV      r0,r0
;;;184            if(currentCmdType != CMD_REQ_NULL)
00017c  e59f01ac          LDR      r0,|L1.816|
000180  e1d000b0          LDRH     r0,[r0,#0]  ; currentCmdType
000184  e3500000          CMP      r0,#0
000188  0a000005          BEQ      |L1.420|
;;;185            {
;;;186                cmdReq = currentCmdType;
00018c  e59f019c          LDR      r0,|L1.816|
000190  e1d070b0          LDRH     r7,[r0,#0]  ; currentCmdType
;;;187                currentCmdType = CMD_REQ_NULL;
000194  e3a00000          MOV      r0,#0
000198  e59f1190          LDR      r1,|L1.816|
00019c  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
0001a0  ea000000          B        |L1.424|
                  |L1.420|
;;;188            }
;;;189            else
;;;190            {
;;;191                cmdReq = CMD_REQ_OK;
0001a4  e3a07064          MOV      r7,#0x64
                  |L1.424|
;;;192            }
;;;193            break;
0001a8  ea00003a          B        |L1.664|
                  |L1.428|
;;;194            
;;;195        case DATA_TYPE_ERROR:
0001ac  e1a00000          MOV      r0,r0
;;;196            cmdReq = CMD_REQ_ERROR;
0001b0  e3a070c8          MOV      r7,#0xc8
;;;197            currentCmdType = CMD_REQ_NULL;
0001b4  e3a00000          MOV      r0,#0
0001b8  e59f1170          LDR      r1,|L1.816|
0001bc  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;198            //writeFlag = 0;
;;;199            break;
0001c0  ea000034          B        |L1.664|
                  |L1.452|
;;;200        case DATA_TYPE_AT_CMD:
0001c4  e1a00000          MOV      r0,r0
;;;201            currentCmdType = fineCurrentCmdRegType(data, len, &waitOKFlag);
0001c8  e20410ff          AND      r1,r4,#0xff
0001cc  e1a0200d          MOV      r2,sp
0001d0  e1a00006          MOV      r0,r6
0001d4  ebfffffe          BL       fineCurrentCmdRegType
0001d8  e59f1150          LDR      r1,|L1.816|
0001dc  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;202            if(currentCmdType != CMD_REQ_NULL)
0001e0  e2810000          ADD      r0,r1,#0
0001e4  e1d000b0          LDRH     r0,[r0,#0]  ; currentCmdType
0001e8  e3500000          CMP      r0,#0
0001ec  0a000010          BEQ      |L1.564|
;;;203            {
;;;204                if(waitOKFlag == WAIT_OK_FLAG_FALSE)
0001f0  e5dd0000          LDRB     r0,[sp,#0]
0001f4  e3500002          CMP      r0,#2
0001f8  1a000004          BNE      |L1.528|
;;;205                {
;;;206                    cmdReq = currentCmdType;
0001fc  e2810000          ADD      r0,r1,#0
000200  e1d070b0          LDRH     r7,[r0,#0]  ; currentCmdType
;;;207                    currentCmdType = CMD_REQ_NULL;
000204  e3a00000          MOV      r0,#0
000208  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
00020c  ea000008          B        |L1.564|
                  |L1.528|
;;;208                }
;;;209                else
;;;210                {
;;;211                    memcpy(dataTempBuffer2, data, len);
000210  e1a02004          MOV      r2,r4
000214  e1a01006          MOV      r1,r6
000218  e59f0114          LDR      r0,|L1.820|
00021c  ebfffffe          BL       __aeabi_memcpy
;;;212                    dataTempBuffer2[len] = 0x0;
000220  e3a00000          MOV      r0,#0
000224  e59f1108          LDR      r1,|L1.820|
000228  e7c10004          STRB     r0,[r1,r4]
;;;213                    dataTempBufferLen2 = len;
00022c  e59f0104          LDR      r0,|L1.824|
000230  e5804000          STR      r4,[r0,#0]  ; dataTempBufferLen2
                  |L1.564|
;;;214                }
;;;215            }
;;;216            break;
000234  ea000017          B        |L1.664|
                  |L1.568|
;;;217            
;;;218        case DATA_TYPE_CME_ERROR:
000238  e1a00000          MOV      r0,r0
;;;219            cmdReq = CMD_REQ_CME_ERROR;
00023c  e3a07f4b          MOV      r7,#0x12c
;;;220            currentCmdType = CMD_REQ_NULL;
000240  e3a00000          MOV      r0,#0
000244  e59f10e4          LDR      r1,|L1.816|
000248  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;221        #if(ENABLE_AT_CMD_DEBUG_FINAL)
;;;222            sysprintf("\r\n   ERROR ~ DATA_TYPE_CME_ERROR(%d) ~ [%s]\r\n", len, data);
;;;223        #endif
;;;224            //writeFlag = 0;
;;;225            break;
00024c  ea000011          B        |L1.664|
                  |L1.592|
;;;226        
;;;227        case DATA_TYPE_CONNECT:
000250  e1a00000          MOV      r0,r0
;;;228            cmdReq = CMD_REQ_CONNECT_OK;
000254  e3a0706b          MOV      r7,#0x6b
;;;229            currentCmdType = CMD_REQ_NULL;
000258  e3a00000          MOV      r0,#0
00025c  e59f10cc          LDR      r1,|L1.816|
000260  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;230            //writeFlag = 0;
;;;231            break;
000264  ea00000b          B        |L1.664|
                  |L1.616|
;;;232    
;;;233        case DATA_TYPE_WEB_POST_GET_DATA:
000268  e1a00000          MOV      r0,r0
;;;234            cmdReq = CMD_REQ_WEB_POST_GET_DATA;
00026c  e3a07070          MOV      r7,#0x70
;;;235            currentCmdType = CMD_REQ_NULL;
000270  e3a00000          MOV      r0,#0
000274  e59f10b4          LDR      r1,|L1.816|
000278  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;236            //writeFlag = 0;
;;;237            break;
00027c  ea000005          B        |L1.664|
                  |L1.640|
;;;238        
;;;239        case DATA_TYPE_FTP_GET_DATA:
000280  e1a00000          MOV      r0,r0
;;;240            cmdReq = CMD_REQ_FTP_GET_DATA_OK;
000284  e3a07073          MOV      r7,#0x73
;;;241            currentCmdType = CMD_REQ_NULL;
000288  e3a00000          MOV      r0,#0
00028c  e59f109c          LDR      r1,|L1.816|
000290  e1c100b0          STRH     r0,[r1,#0]  ; currentCmdType
;;;242            //writeFlag = 0;
;;;243            break;
000294  e1a00000          MOV      r0,r0
                  |L1.664|
000298  e1a00000          MOV      r0,r0                 ;193
;;;244        }
;;;245        
;;;246        if(cmdReq != CMD_REQ_NULL)
00029c  e3570000          CMP      r7,#0
0002a0  0a000009          BEQ      |L1.716|
;;;247        {
;;;248            //BaseType_t DataAgentSignalReqCmd(void *pvBuffer);
;;;249            //DataAgentSignalReqCmd(&cmdReq);
;;;250            //if((cmdReq != CMD_REQ_OK) && (cmdReq != CMD_REQ_ERROR))
;;;251            {
;;;252                memcpy(dataTempBuffer, data, len);
0002a4  e1a02004          MOV      r2,r4
0002a8  e1a01006          MOV      r1,r6
0002ac  e59f0088          LDR      r0,|L1.828|
0002b0  ebfffffe          BL       __aeabi_memcpy
;;;253                dataTempBuffer[len] = 0x0;
0002b4  e3a00000          MOV      r0,#0
0002b8  e59f107c          LDR      r1,|L1.828|
0002bc  e7c10004          STRB     r0,[r1,r4]
;;;254                dataTempBufferLen = len;
0002c0  e59f0078          LDR      r0,|L1.832|
0002c4  e5804000          STR      r4,[r0,#0]  ; dataTempBufferLen
0002c8  ea000002          B        |L1.728|
                  |L1.716|
;;;255            }
;;;256            #if(ENABLE_AT_CMD_DEBUG_FINAL)
;;;257            //sysprintf("\r\n  ~ CMD TYPE ~  *** [%03d] ***\r\n", cmdReq);
;;;258            sysprintf("\r\n  ~ CMD TYPE ~  *** [%03d:%s] ***\r\n", cmdReq, dataTempBuffer);
;;;259            #endif
;;;260            
;;;261        }
;;;262        else
;;;263        {
;;;264            dataTempBufferLen = 0;
0002cc  e3a00000          MOV      r0,#0
0002d0  e59f1068          LDR      r1,|L1.832|
0002d4  e5810000          STR      r0,[r1,#0]  ; dataTempBufferLen
                  |L1.728|
;;;265        }
;;;266       
;;;267        return cmdReq;
0002d8  e1a00007          MOV      r0,r7
;;;268    }
0002dc  e8bd83f8          POP      {r3-r9,pc}
                  |L1.736|
0002e0  0d0a2025          DCB      "\r\n %s: len = %d...\r\n   -%02d:-> ",0
0002e4  733a206c
0002e8  656e203d
0002ec  2025642e
0002f0  2e2e0d0a
0002f4  2020202d
0002f8  25303264
0002fc  3a2d3e20
000300  00      
000301  00                DCB      0
000302  00                DCB      0
000303  00                DCB      0
                  |L1.772|
000304  5b253032          DCB      "[%02d]:0x%02x(%c)\r\n",0
000308  645d3a30
00030c  78253032
000310  78282563
000314  290d0a00
                  |L1.792|
000318  5b253032          DCB      "[%02d]:0x%02x\r\n",0
00031c  645d3a30
000320  78253032
000324  780d0a00
                  |L1.808|
000328  0d0a00            DCB      "\r\n",0
00032b  00                DCB      0
                  |L1.812|
                          DCD      cmdList
                  |L1.816|
                          DCD      currentCmdType
                  |L1.820|
                          DCD      dataTempBuffer2
                  |L1.824|
                          DCD      dataTempBufferLen2
                  |L1.828|
                          DCD      dataTempBuffer
                  |L1.832|
                          DCD      dataTempBufferLen
                          ENDP

                  findStartAddress PROC
;;;269    
;;;270    static uint8_t* findStartAddress(uint8_t* srcPr, int srcLen, uint8_t* destPr, int destLen)
000344  e92d41f0          PUSH     {r4-r8,lr}
;;;271    {
000348  e1a05000          MOV      r5,r0
00034c  e1a07001          MOV      r7,r1
000350  e1a08002          MOV      r8,r2
000354  e1a06003          MOV      r6,r3
;;;272        int i;
;;;273        for (i = 0; i < (srcLen - destLen)+1; i++)
000358  e3a04000          MOV      r4,#0
00035c  ea000008          B        |L1.900|
                  |L1.864|
;;;274        {
;;;275            if(memcmp(srcPr+i, destPr, destLen) == 0)
000360  e0850004          ADD      r0,r5,r4
000364  e1a02006          MOV      r2,r6
000368  e1a01008          MOV      r1,r8
00036c  ebfffffe          BL       memcmp
000370  e3500000          CMP      r0,#0
000374  1a000001          BNE      |L1.896|
;;;276            {
;;;277                return srcPr + i;
000378  e0850004          ADD      r0,r5,r4
                  |L1.892|
;;;278            }
;;;279    #if(0)
;;;280            for (j = 0; j < destLen; j++)
;;;281            {
;;;282                if (srcPr[i+j] != destPr[j])
;;;283                    break;
;;;284            }
;;;285            if (j == destLen)
;;;286                return srcPr + i;
;;;287    #endif
;;;288        }
;;;289        return NULL;
;;;290    }
00037c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.896|
000380  e2844001          ADD      r4,r4,#1              ;273
                  |L1.900|
000384  e0470006          SUB      r0,r7,r6              ;273
000388  e2800001          ADD      r0,r0,#1              ;273
00038c  e1500004          CMP      r0,r4                 ;273
000390  cafffff2          BGT      |L1.864|
000394  e3a00000          MOV      r0,#0                 ;289
000398  eafffff7          B        |L1.892|
;;;291    
                          ENDP

                  atCmdProcessReadData PROC
;;;295    
;;;296    CmdReq atCmdProcessReadData(uint8_t* data, int len, ParserType parserType)
00039c  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;297    {
0003a0  e24dd018          SUB      sp,sp,#0x18
0003a4  e1a09000          MOV      r9,r0
;;;298        //printfBuffData((char*)"DATA TEMP", cmdDataTmp, cmdDataTmpIndex);
;;;299        CmdReq reVal = CMD_REQ_NULL;
0003a8  e3a00000          MOV      r0,#0
0003ac  e58d0014          STR      r0,[sp,#0x14]
;;;300        int i;
;;;301        uint8_t* startAddress;
;;;302        int     targetHeaderIndex;
;;;303        uint8_t* targetStartTempPr = NULL;
0003b0  e3a05000          MOV      r5,#0
;;;304        uint8_t* targetEndTempPr = NULL;
0003b4  e58d000c          STR      r0,[sp,#0xc]
;;;305        int targetLen = 0;
0003b8  e58d0008          STR      r0,[sp,#8]
;;;306    
;;;307        int dataCurrentIndex = 0;
0003bc  e3a0a000          MOV      r10,#0
;;;308        int dataLeftLen = 0;
0003c0  e3a08000          MOV      r8,#0
;;;309        uint8_t* dataCurrentPr = 0;
0003c4  e58d0004          STR      r0,[sp,#4]
;;;310    	int totalCmdDataLen;
;;;311        
;;;312        TargetCmdList* pTargetCmdList = NULL;
0003c8  e3a06000          MOV      r6,#0
;;;313        
;;;314        switch(parserType)
0003cc  e59d0020          LDR      r0,[sp,#0x20]
0003d0  e3500001          CMP      r0,#1
0003d4  0a000004          BEQ      |L1.1004|
0003d8  e3500002          CMP      r0,#2
0003dc  0a000005          BEQ      |L1.1016|
0003e0  e3500003          CMP      r0,#3
0003e4  1a000009          BNE      |L1.1040|
0003e8  ea000005          B        |L1.1028|
                  |L1.1004|
;;;315        {
;;;316            case PARSER_TYPE_NORMAL:
0003ec  e1a00000          MOV      r0,r0
;;;317                pTargetCmdList = &targetCmdList;
0003f0  e59f6258          LDR      r6,|L1.1616|
;;;318                break;
0003f4  ea000005          B        |L1.1040|
                  |L1.1016|
;;;319            case PARSER_TYPE_WEB_POST:
0003f8  e1a00000          MOV      r0,r0
;;;320                pTargetCmdList = &webPostTargetCmdList;
0003fc  e59f6250          LDR      r6,|L1.1620|
;;;321                break;
000400  ea000002          B        |L1.1040|
                  |L1.1028|
;;;322            case PARSER_TYPE_FTP:
000404  e1a00000          MOV      r0,r0
;;;323                pTargetCmdList = &ftpCmdList;
000408  e59f6248          LDR      r6,|L1.1624|
;;;324                break;
00040c  e1a00000          MOV      r0,r0
                  |L1.1040|
000410  e1a00000          MOV      r0,r0                 ;318
;;;325        }
;;;326    
;;;327        
;;;328    //#if(ENABLE_AT_CMD_DEBUG)
;;;329    #if(0)
;;;330        printfBuffData((char*)" [START]", data, len);
;;;331    #endif
;;;332    	totalCmdDataLen = cmdDataTmpIndex + len;
000414  e59f0240          LDR      r0,|L1.1628|
000418  e5901000          LDR      r1,[r0,#0]  ; cmdDataTmpIndex
00041c  e59d001c          LDR      r0,[sp,#0x1c]
000420  e081b000          ADD      r11,r1,r0
;;;333    	//{
;;;334    	//	char str[512];
;;;335    	//	sprintf(str, " @@  totalCmdDataLen = %d, cmdDataTmpIndex = %d, len = %d\r\n", totalCmdDataLen, cmdDataTmpIndex, len);
;;;336    	//	updateMainMessagechar(str);
;;;337    	//}
;;;338        memcpy(cmdData, cmdDataTmp, cmdDataTmpIndex);
000424  e59f0230          LDR      r0,|L1.1628|
000428  e59f1230          LDR      r1,|L1.1632|
00042c  e5902000          LDR      r2,[r0,#0]  ; cmdDataTmpIndex
000430  e59f022c          LDR      r0,|L1.1636|
000434  ebfffffe          BL       __aeabi_memcpy
;;;339        memcpy(cmdData + cmdDataTmpIndex, data, len);
000438  e59f1224          LDR      r1,|L1.1636|
00043c  e59f2218          LDR      r2,|L1.1628|
000440  e5922000          LDR      r2,[r2,#0]  ; cmdDataTmpIndex
000444  e0810002          ADD      r0,r1,r2
000448  e1a01009          MOV      r1,r9
00044c  e59d201c          LDR      r2,[sp,#0x1c]
000450  ebfffffe          BL       __aeabi_memcpy
;;;340        data = cmdData;
000454  e59f9208          LDR      r9,|L1.1636|
;;;341    	
;;;342    //#if(ENABLE_AT_CMD_DEBUG)
;;;343    //#if(ENABLE_AT_CMD_DEBUG_RECEIVE_RAW)
;;;344        if(enableReceiveDebug)
000458  e59f0208          LDR      r0,|L1.1640|
00045c  e5900000          LDR      r0,[r0,#0]  ; enableReceiveDebug
000460  e3500000          CMP      r0,#0
000464  0a000003          BEQ      |L1.1144|
;;;345            printfBuffData((char*)"START_2", data, totalCmdDataLen);
000468  e1a0200b          MOV      r2,r11
00046c  e1a01009          MOV      r1,r9
000470  e28f0f7d          ADR      r0,|L1.1644|
000474  ebfffffe          BL       printfBuffData
                  |L1.1144|
;;;346    //#endif
;;;347        cmdDataTmpIndex = 0;
000478  e3a00000          MOV      r0,#0
00047c  e59f11d8          LDR      r1,|L1.1628|
000480  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;348        while (dataCurrentIndex < totalCmdDataLen)
000484  ea00006b          B        |L1.1592|
                  |L1.1160|
;;;349        {   
;;;350     redo:
000488  e1a00000          MOV      r0,r0
                  |L1.1164|
;;;351            //sysprintf("  \r\n *[INFO]** Start check 1(%d): dataCurrentIndex = %d, dataLeftLen = %d\r\n", totalCmdDataLen, dataCurrentIndex, dataLeftLen);
;;;352            dataLeftLen = totalCmdDataLen - dataCurrentIndex;
00048c  e04b800a          SUB      r8,r11,r10
;;;353            dataCurrentPr = data + dataCurrentIndex;
000490  e089000a          ADD      r0,r9,r10
000494  e58d0004          STR      r0,[sp,#4]
;;;354            
;;;355            if(dataLeftLen <= 0)
000498  e3580000          CMP      r8,#0
00049c  ca000000          BGT      |L1.1188|
;;;356            {
;;;357                //sysprintf("  \r\n *[INFO]** atCmdProcessReadData: break\r\n");
;;;358                break;
0004a0  ea000066          B        |L1.1600|
                  |L1.1188|
;;;359            }
;;;360            #if(ENABLE_AT_CMD_DEBUG_2)
;;;361            //#if(1)
;;;362            sysprintf("  \r\n *[INFO]** Start check 2: dataCurrentIndex = %d, dataLeftLen = %d\r\n", dataCurrentIndex, dataLeftLen);
;;;363            #endif
;;;364            targetStartTempPr = 0;
0004a4  e3a05000          MOV      r5,#0
;;;365            targetHeaderIndex = -1;
0004a8  e3e00000          MVN      r0,#0
0004ac  e58d0010          STR      r0,[sp,#0x10]
;;;366            for(i = 0; i<TARGET_CMD_ITME_NUM; i++)    
0004b0  e3a04000          MOV      r4,#0
0004b4  ea000016          B        |L1.1300|
                  |L1.1208|
;;;367            {
;;;368                startAddress  = findStartAddress(dataCurrentPr, dataLeftLen, pTargetCmdList->item[i]->headerStr, strlen((char*)pTargetCmdList->item[i]->headerStr));
0004b8  e7961104          LDR      r1,[r6,r4,LSL #2]
0004bc  e5910000          LDR      r0,[r1,#0]
0004c0  ebfffffe          BL       strlen
0004c4  e58d0000          STR      r0,[sp,#0]
0004c8  e7960104          LDR      r0,[r6,r4,LSL #2]
0004cc  e5902000          LDR      r2,[r0,#0]
0004d0  e1a01008          MOV      r1,r8
0004d4  e59d0004          LDR      r0,[sp,#4]
0004d8  e59d3000          LDR      r3,[sp,#0]
0004dc  ebfffffe          BL       findStartAddress
0004e0  e1a07000          MOV      r7,r0
;;;369                if(startAddress)
0004e4  e3570000          CMP      r7,#0
0004e8  0a000008          BEQ      |L1.1296|
;;;370                {
;;;371                    if(targetStartTempPr == 0)
0004ec  e3550000          CMP      r5,#0
0004f0  1a000002          BNE      |L1.1280|
;;;372                    {
;;;373                        targetStartTempPr = startAddress;
0004f4  e1a05007          MOV      r5,r7
;;;374                        targetHeaderIndex = i;
0004f8  e58d4010          STR      r4,[sp,#0x10]
0004fc  ea000003          B        |L1.1296|
                  |L1.1280|
;;;375                    }
;;;376                    else
;;;377                    {
;;;378                        if(targetStartTempPr > startAddress)
000500  e1550007          CMP      r5,r7
000504  9a000001          BLS      |L1.1296|
;;;379                        {
;;;380                            targetStartTempPr = startAddress;
000508  e1a05007          MOV      r5,r7
;;;381                            targetHeaderIndex = i;
00050c  e58d4010          STR      r4,[sp,#0x10]
                  |L1.1296|
000510  e2844001          ADD      r4,r4,#1              ;366
                  |L1.1300|
000514  e3540005          CMP      r4,#5                 ;366
000518  baffffe6          BLT      |L1.1208|
;;;382                        }
;;;383                    }
;;;384                }           
;;;385            }
;;;386            #if(ENABLE_AT_CMD_DEBUG_2)
;;;387            sysprintf("   ==> get  targetHeaderIndex  %d\r\n", targetHeaderIndex);
;;;388            #endif
;;;389            if(targetHeaderIndex != -1)
00051c  e59d0010          LDR      r0,[sp,#0x10]
000520  e3700001          CMN      r0,#1
000524  0a00003c          BEQ      |L1.1564|
;;;390            {
;;;391                i = targetHeaderIndex;
000528  e59d4010          LDR      r4,[sp,#0x10]
;;;392                //sysprintf("   ==> check [%d]: %d, %d\r\n", i, strlen((char*)pTargetCmdList->item[i]->headerStr), strlen((char*)pTargetCmdList->item[i]->endStr));
;;;393                targetLen = 0;
00052c  e3a00000          MOV      r0,#0
000530  e58d0008          STR      r0,[sp,#8]
;;;394                //targetStartTempPr = findStartAddress(dataCurrentPr, dataLeftLen, pTargetCmdList->item[i]->headerStr, strlen((char*)pTargetCmdList->item[i]->headerStr));
;;;395                #if(ENABLE_AT_CMD_DEBUG_2)
;;;396                sysprintf("   =find header=> %d\r\n", targetStartTempPr - dataCurrentPr);
;;;397                #endif
;;;398                if(targetStartTempPr)
000534  e3550000          CMP      r5,#0
000538  0a000037          BEQ      |L1.1564|
;;;399                {
;;;400                    targetEndTempPr = findStartAddress(targetStartTempPr+1, dataLeftLen - (targetStartTempPr - dataCurrentPr), pTargetCmdList->item[i]->endStr, strlen((char*)pTargetCmdList->item[i]->endStr));
00053c  e7961104          LDR      r1,[r6,r4,LSL #2]
000540  e5910004          LDR      r0,[r1,#4]
000544  ebfffffe          BL       strlen
000548  e58d0000          STR      r0,[sp,#0]
00054c  e7960104          LDR      r0,[r6,r4,LSL #2]
000550  e5902004          LDR      r2,[r0,#4]
000554  e59d0004          LDR      r0,[sp,#4]
000558  e0450000          SUB      r0,r5,r0
00055c  e0481000          SUB      r1,r8,r0
000560  e2850001          ADD      r0,r5,#1
000564  e59d3000          LDR      r3,[sp,#0]
000568  ebfffffe          BL       findStartAddress
00056c  e58d000c          STR      r0,[sp,#0xc]
;;;401                    #if(ENABLE_AT_CMD_DEBUG_2)
;;;402                    sysprintf("   =find end=> %d\r\n", targetEndTempPr - dataCurrentPr);
;;;403                    #endif
;;;404                    if(targetEndTempPr)
000570  e59d000c          LDR      r0,[sp,#0xc]
000574  e3500000          CMP      r0,#0
000578  0a000008          BEQ      |L1.1440|
;;;405                    {
;;;406                        targetLen = targetEndTempPr - targetStartTempPr + strlen((char*)pTargetCmdList->item[i]->endStr);
00057c  e7961104          LDR      r1,[r6,r4,LSL #2]
000580  e5910004          LDR      r0,[r1,#4]
000584  ebfffffe          BL       strlen
000588  e1a01000          MOV      r1,r0
00058c  e59d000c          LDR      r0,[sp,#0xc]
000590  e0400005          SUB      r0,r0,r5
000594  e0800001          ADD      r0,r0,r1
000598  e58d0008          STR      r0,[sp,#8]
;;;407                        dataCurrentPr = targetStartTempPr; 
00059c  e58d5004          STR      r5,[sp,#4]
                  |L1.1440|
;;;408                    }
;;;409                    else
;;;410                    {
;;;411                        #if(ENABLE_AT_CMD_DEBUG_2)
;;;412                        sysprintf("   =Cant find end=>\r\n");
;;;413                        #endif
;;;414                    }
;;;415    
;;;416                    if (targetLen)
0005a0  e59d0008          LDR      r0,[sp,#8]
0005a4  e3500000          CMP      r0,#0
0005a8  0a00001b          BEQ      |L1.1564|
;;;417                    {//頭尾都有找到
;;;418                        #if(ENABLE_AT_CMD_DEBUG_2)
;;;419                        sysprintf("   =targetHeaderIndex = %d, dataType = %d=>\r\n", targetHeaderIndex, pTargetCmdList->item[targetHeaderIndex]->dataType);
;;;420                        #endif 
;;;421    					memset(cmdDataTmp, 0x0, sizeof(cmdDataTmp));
0005ac  e3a01601          MOV      r1,#0x100000
0005b0  e59f00a8          LDR      r0,|L1.1632|
0005b4  ebfffffe          BL       __aeabi_memclr
;;;422                        memcpy(cmdDataTmp, dataCurrentPr, targetLen);
0005b8  e59f00a0          LDR      r0,|L1.1632|
0005bc  e99d0006          LDMIB    sp,{r1,r2}
0005c0  ebfffffe          BL       __aeabi_memcpy
;;;423                        dataCurrentIndex = targetEndTempPr - data + strlen((char*)(pTargetCmdList->item[i]->endStr));
0005c4  e7961104          LDR      r1,[r6,r4,LSL #2]
0005c8  e5910004          LDR      r0,[r1,#4]
0005cc  ebfffffe          BL       strlen
0005d0  e59d100c          LDR      r1,[sp,#0xc]
0005d4  e0411009          SUB      r1,r1,r9
0005d8  e080a001          ADD      r10,r0,r1
;;;424                        cmdDataTmpIndex = targetLen;
0005dc  e59f1078          LDR      r1,|L1.1628|
0005e0  e59d0008          LDR      r0,[sp,#8]
0005e4  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;425                        #if(ENABLE_AT_CMD_DEBUG)
;;;426                        printfBuffData((char*) "[DATA]", cmdDataTmp, cmdDataTmpIndex);
;;;427                        #endif
;;;428                        //processCmdData(preProcessCmdData(pTargetCmdList->item[targetHeaderIndex]->dataType, cmdDataTmp, cmdDataTmpIndex));
;;;429                        reVal = preProcessCmdData(pTargetCmdList->item[targetHeaderIndex]->dataType, cmdDataTmp, cmdDataTmpIndex, parserType);
0005e8  e59d1010          LDR      r1,[sp,#0x10]
0005ec  e7961101          LDR      r1,[r6,r1,LSL #2]
0005f0  e5d10008          LDRB     r0,[r1,#8]
0005f4  e59f1060          LDR      r1,|L1.1628|
0005f8  e59d3020          LDR      r3,[sp,#0x20]
0005fc  e5912000          LDR      r2,[r1,#0]  ; cmdDataTmpIndex
000600  e59f1058          LDR      r1,|L1.1632|
000604  ebfffffe          BL       preProcessCmdData
000608  e58d0014          STR      r0,[sp,#0x14]
;;;430                        cmdDataTmpIndex = 0;
00060c  e3a00000          MOV      r0,#0
000610  e59f1044          LDR      r1,|L1.1628|
000614  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;431                        goto redo;
000618  eaffff9b          B        |L1.1164|
                  |L1.1564|
;;;432                    }
;;;433                    else
;;;434                    {//只有找到頭  沒有尾 還沒有收完 
;;;435    
;;;436                    }
;;;437                }
;;;438                else
;;;439                {//沒找到這次頭
;;;440                    #if(ENABLE_AT_CMD_DEBUG_2)
;;;441                    sysprintf("   =Cant find header=>\r\n");
;;;442                    #endif
;;;443                }
;;;444            }
;;;445            #if(ENABLE_AT_CMD_DEBUG_2)
;;;446            sysprintf("   =copy to temp=>\r\n");
;;;447            printfBuffData((char*)"Copy to TEMP", dataCurrentPr, dataLeftLen);
;;;448            #endif
;;;449            memcpy(cmdDataTmp, dataCurrentPr, dataLeftLen);
00061c  e1a02008          MOV      r2,r8
000620  e59f0038          LDR      r0,|L1.1632|
000624  e59d1004          LDR      r1,[sp,#4]
000628  ebfffffe          BL       __aeabi_memcpy
;;;450            dataCurrentIndex = dataCurrentIndex + dataLeftLen;
00062c  e08aa008          ADD      r10,r10,r8
;;;451            cmdDataTmpIndex = dataLeftLen;
000630  e59f0024          LDR      r0,|L1.1628|
000634  e5808000          STR      r8,[r0,#0]  ; cmdDataTmpIndex
                  |L1.1592|
000638  e15a000b          CMP      r10,r11               ;348
00063c  baffff91          BLT      |L1.1160|
                  |L1.1600|
000640  e1a00000          MOV      r0,r0                 ;358
;;;452        }
;;;453        return reVal;
000644  e59d0014          LDR      r0,[sp,#0x14]
000648  e28dd024          ADD      sp,sp,#0x24
;;;454    }
00064c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1616|
                          DCD      targetCmdList
                  |L1.1620|
                          DCD      webPostTargetCmdList
                  |L1.1624|
                          DCD      ftpCmdList
                  |L1.1628|
                          DCD      cmdDataTmpIndex
                  |L1.1632|
                          DCD      cmdDataTmp
                  |L1.1636|
                          DCD      cmdData
                  |L1.1640|
                          DCD      enableReceiveDebug
                  |L1.1644|
00066c  53544152          DCB      "START_2",0
000670  545f3200
                          ENDP

                  atCmdProcessReadData2 PROC
;;;455    
;;;456    CmdReq atCmdProcessReadData2(uint8_t* data, int len, ParserType parserType, int atLeastSize)
000674  e92d4fff          PUSH     {r0-r11,lr}
;;;457    {
000678  e24dd01c          SUB      sp,sp,#0x1c
00067c  e1a0a000          MOV      r10,r0
;;;458        //printfBuffData((char*)"DATA TEMP", cmdDataTmp, cmdDataTmpIndex);
;;;459        //sysprintf("  \r\n !! atCmdProcessReadData:%d !!\r\n", atLeastSize);
;;;460        CmdReq reVal = CMD_REQ_NULL;
000680  e3a00000          MOV      r0,#0
000684  e58d0018          STR      r0,[sp,#0x18]
;;;461        int i;
;;;462        uint8_t* startAddress;
;;;463        int     targetHeaderIndex;
;;;464        uint8_t* targetStartTempPr = NULL;
000688  e3a07000          MOV      r7,#0
;;;465        uint8_t* targetEndTempPr = NULL;
00068c  e58d0010          STR      r0,[sp,#0x10]
;;;466        int targetLen = 0;
000690  e58d000c          STR      r0,[sp,#0xc]
;;;467    
;;;468        int dataCurrentIndex = 0;
000694  e3a0b000          MOV      r11,#0
;;;469        int dataLeftLen = 0;
000698  e3a08000          MOV      r8,#0
;;;470        uint8_t* dataCurrentPr = 0;
00069c  e58d0008          STR      r0,[sp,#8]
;;;471    	int totalCmdDataLen;
;;;472        
;;;473        TargetCmdList* pTargetCmdList = NULL;
0006a0  e3a05000          MOV      r5,#0
;;;474        
;;;475        switch(parserType)
0006a4  e59d0024          LDR      r0,[sp,#0x24]
0006a8  e3500001          CMP      r0,#1
0006ac  0a000004          BEQ      |L1.1732|
0006b0  e3500002          CMP      r0,#2
0006b4  0a000005          BEQ      |L1.1744|
0006b8  e3500003          CMP      r0,#3
0006bc  1a000009          BNE      |L1.1768|
0006c0  ea000005          B        |L1.1756|
                  |L1.1732|
;;;476        {
;;;477            case PARSER_TYPE_NORMAL:
0006c4  e1a00000          MOV      r0,r0
;;;478                pTargetCmdList = &targetCmdList;
0006c8  e51f5080          LDR      r5,|L1.1616|
;;;479                break;
0006cc  ea000005          B        |L1.1768|
                  |L1.1744|
;;;480            case PARSER_TYPE_WEB_POST:
0006d0  e1a00000          MOV      r0,r0
;;;481                pTargetCmdList = &webPostTargetCmdList;
0006d4  e51f5088          LDR      r5,|L1.1620|
;;;482                break;
0006d8  ea000002          B        |L1.1768|
                  |L1.1756|
;;;483            case PARSER_TYPE_FTP:
0006dc  e1a00000          MOV      r0,r0
;;;484                pTargetCmdList = &ftpCmdList;
0006e0  e51f5090          LDR      r5,|L1.1624|
;;;485                break;
0006e4  e1a00000          MOV      r0,r0
                  |L1.1768|
0006e8  e1a00000          MOV      r0,r0                 ;479
;;;486            /*
;;;487            case PARSER_TYPE_SOCKET:
;;;488                pTargetCmdList = &socketCmdList;
;;;489                break;
;;;490            case PARSER_TYPE_SMS:
;;;491                pTargetCmdList = &smsCmdList;
;;;492                break;
;;;493            case PARSER_TYPE_FTP_GET_LIST:
;;;494                pTargetCmdList = &ftpGetListCmdList;
;;;495                break;
;;;496            case PARSER_TYPE_SPECIAL:
;;;497                pTargetCmdList = &targetSpecialCmdList;
;;;498                break;
;;;499            */
;;;500        }
;;;501    
;;;502        
;;;503    //#if(ENABLE_AT_CMD_DEBUG)
;;;504    #if(0)
;;;505        printfBuffData((char*)" [START]", data, len);
;;;506    #endif
;;;507    	totalCmdDataLen = cmdDataTmpIndex + len;
0006ec  e51f0098          LDR      r0,|L1.1628|
0006f0  e5901000          LDR      r1,[r0,#0]  ; cmdDataTmpIndex
0006f4  e59d0020          LDR      r0,[sp,#0x20]
0006f8  e0819000          ADD      r9,r1,r0
;;;508    	//{
;;;509    	//	char str[512];
;;;510    	//	sprintf(str, " @@  totalCmdDataLen = %d, cmdDataTmpIndex = %d, len = %d\r\n", totalCmdDataLen, cmdDataTmpIndex, len);
;;;511    	//	updateMainMessagechar(str);
;;;512    	//}
;;;513        memcpy(cmdData, cmdDataTmp, cmdDataTmpIndex);
0006fc  e51f00a8          LDR      r0,|L1.1628|
000700  e51f10a8          LDR      r1,|L1.1632|
000704  e5902000          LDR      r2,[r0,#0]  ; cmdDataTmpIndex
000708  e51f00ac          LDR      r0,|L1.1636|
00070c  ebfffffe          BL       __aeabi_memcpy
;;;514        memcpy(cmdData + cmdDataTmpIndex, data, len);
000710  e51f10b4          LDR      r1,|L1.1636|
000714  e51f20c0          LDR      r2,|L1.1628|
000718  e5922000          LDR      r2,[r2,#0]  ; cmdDataTmpIndex
00071c  e0810002          ADD      r0,r1,r2
000720  e1a0100a          MOV      r1,r10
000724  e59d2020          LDR      r2,[sp,#0x20]
000728  ebfffffe          BL       __aeabi_memcpy
;;;515        data = cmdData;
00072c  e51fa0d0          LDR      r10,|L1.1636|
;;;516    	
;;;517    //#if(ENABLE_AT_CMD_DEBUG)
;;;518    //#if(ENABLE_AT_CMD_DEBUG_RECEIVE_RAW)
;;;519        if(enableReceiveDebug)
000730  e51f00d0          LDR      r0,|L1.1640|
000734  e5900000          LDR      r0,[r0,#0]  ; enableReceiveDebug
000738  e3500000          CMP      r0,#0
00073c  0a000003          BEQ      |L1.1872|
;;;520            printfBuffData((char*)"START_2", data, totalCmdDataLen);
000740  e1a02009          MOV      r2,r9
000744  e1a0100a          MOV      r1,r10
000748  e24f00e4          ADR      r0,|L1.1644|
00074c  ebfffffe          BL       printfBuffData
                  |L1.1872|
;;;521    //#endif
;;;522        cmdDataTmpIndex = 0;
000750  e3a00000          MOV      r0,#0
000754  e51f1100          LDR      r1,|L1.1628|
000758  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;523        //sysprintf("  \r\n *-[%d:%d]-* \r\n", atLeastSize, totalCmdDataLen);
;;;524        if(atLeastSize < totalCmdDataLen)
00075c  e59d0028          LDR      r0,[sp,#0x28]
000760  e1500009          CMP      r0,r9
000764  aa00007a          BGE      |L1.2388|
;;;525        {
;;;526            while (dataCurrentIndex < totalCmdDataLen)
000768  ea000076          B        |L1.2376|
                  |L1.1900|
;;;527            {   
;;;528            redo:
00076c  e1a00000          MOV      r0,r0
                  |L1.1904|
;;;529                //sysprintf("  \r\n *[INFO]** Start check 1(%d): dataCurrentIndex = %d, dataLeftLen = %d\r\n", totalCmdDataLen, dataCurrentIndex, dataLeftLen);
;;;530                dataLeftLen = totalCmdDataLen - dataCurrentIndex;
000770  e049800b          SUB      r8,r9,r11
;;;531                dataCurrentPr = data + dataCurrentIndex;
000774  e08a000b          ADD      r0,r10,r11
000778  e58d0008          STR      r0,[sp,#8]
;;;532                
;;;533                if(dataLeftLen <= 0)
00077c  e3580000          CMP      r8,#0
000780  ca000000          BGT      |L1.1928|
;;;534                {
;;;535                    //sysprintf("  \r\n *[INFO]** atCmdProcessReadData: break\r\n");
;;;536                    break;
000784  ea000071          B        |L1.2384|
                  |L1.1928|
;;;537                }
;;;538                #if(ENABLE_AT_CMD_DEBUG_2)
;;;539                //#if(1)
;;;540                sysprintf("  \r\n *[INFO]** Start check 2: dataCurrentIndex = %d, dataLeftLen = %d\r\n", dataCurrentIndex, dataLeftLen);
;;;541                #endif
;;;542                targetStartTempPr = 0;
000788  e3a07000          MOV      r7,#0
;;;543                targetHeaderIndex = -1;
00078c  e3e00000          MVN      r0,#0
000790  e58d0014          STR      r0,[sp,#0x14]
;;;544                for(i = 0; i<TARGET_CMD_ITME_NUM; i++)    
000794  e3a04000          MOV      r4,#0
000798  ea00001b          B        |L1.2060|
                  |L1.1948|
;;;545                {
;;;546                    //add 2020.02.07
;;;547                    if(pTargetCmdList->item[i] == NULL)
00079c  e7950104          LDR      r0,[r5,r4,LSL #2]
0007a0  e3500000          CMP      r0,#0
0007a4  1a000000          BNE      |L1.1964|
;;;548                        continue;
0007a8  ea000016          B        |L1.2056|
                  |L1.1964|
;;;549                    
;;;550                    startAddress  = findStartAddress(dataCurrentPr, dataLeftLen, pTargetCmdList->item[i]->headerStr, strlen((char*)pTargetCmdList->item[i]->headerStr));
0007ac  e7951104          LDR      r1,[r5,r4,LSL #2]
0007b0  e5910000          LDR      r0,[r1,#0]
0007b4  ebfffffe          BL       strlen
0007b8  e58d0004          STR      r0,[sp,#4]
0007bc  e7950104          LDR      r0,[r5,r4,LSL #2]
0007c0  e5902000          LDR      r2,[r0,#0]
0007c4  e1a01008          MOV      r1,r8
0007c8  e59d0008          LDR      r0,[sp,#8]
0007cc  e59d3004          LDR      r3,[sp,#4]
0007d0  ebfffffe          BL       findStartAddress
0007d4  e1a06000          MOV      r6,r0
;;;551                    if(startAddress)
0007d8  e3560000          CMP      r6,#0
0007dc  0a000008          BEQ      |L1.2052|
;;;552                    {
;;;553                        if(targetStartTempPr == 0)
0007e0  e3570000          CMP      r7,#0
0007e4  1a000002          BNE      |L1.2036|
;;;554                        {
;;;555                            targetStartTempPr = startAddress;
0007e8  e1a07006          MOV      r7,r6
;;;556                            targetHeaderIndex = i;
0007ec  e58d4014          STR      r4,[sp,#0x14]
0007f0  ea000003          B        |L1.2052|
                  |L1.2036|
;;;557                        }
;;;558                        else
;;;559                        {
;;;560                            if(targetStartTempPr > startAddress)
0007f4  e1570006          CMP      r7,r6
0007f8  9a000001          BLS      |L1.2052|
;;;561                            {
;;;562                                targetStartTempPr = startAddress;
0007fc  e1a07006          MOV      r7,r6
;;;563                                targetHeaderIndex = i;
000800  e58d4014          STR      r4,[sp,#0x14]
                  |L1.2052|
000804  e1a00000          MOV      r0,r0                 ;548
                  |L1.2056|
000808  e2844001          ADD      r4,r4,#1              ;544
                  |L1.2060|
00080c  e3540005          CMP      r4,#5                 ;544
000810  baffffe1          BLT      |L1.1948|
;;;564                            }
;;;565                        }
;;;566                    }           
;;;567                }
;;;568                #if(ENABLE_AT_CMD_DEBUG_2)
;;;569                sysprintf("   ==> get  targetHeaderIndex  %d\r\n", targetHeaderIndex);
;;;570                #endif
;;;571                if(targetHeaderIndex != -1)
000814  e59d0014          LDR      r0,[sp,#0x14]
000818  e3700001          CMN      r0,#1
00081c  0a000042          BEQ      |L1.2348|
;;;572                {
;;;573                    i = targetHeaderIndex;
000820  e59d4014          LDR      r4,[sp,#0x14]
;;;574                    //sysprintf("   ==> check [%d]: %d, %d\r\n", i, strlen((char*)pTargetCmdList->item[i]->headerStr), strlen((char*)pTargetCmdList->item[i]->endStr));
;;;575                    targetLen = 0;
000824  e3a00000          MOV      r0,#0
000828  e58d000c          STR      r0,[sp,#0xc]
;;;576                    //targetStartTempPr = findStartAddress(dataCurrentPr, dataLeftLen, pTargetCmdList->item[i]->headerStr, strlen((char*)pTargetCmdList->item[i]->headerStr));
;;;577                    #if(ENABLE_AT_CMD_DEBUG_2)
;;;578                    sysprintf("   =find header=> %d\r\n", targetStartTempPr - dataCurrentPr);
;;;579                    #endif
;;;580                    if(targetStartTempPr)
00082c  e3570000          CMP      r7,#0
000830  0a00003d          BEQ      |L1.2348|
;;;581                    {
;;;582                        //targetEndTempPr = findStartAddress(targetStartTempPr+1, dataLeftLen - (targetStartTempPr - dataCurrentPr), pTargetCmdList->item[i]->endStr, strlen((char*)pTargetCmdList->item[i]->endStr));
;;;583                        //限制最少長度是 atLeastSize
;;;584                        uint8_t* targetStartTempPr2 = targetStartTempPr+atLeastSize;
000834  e59d0028          LDR      r0,[sp,#0x28]
000838  e0800007          ADD      r0,r0,r7
00083c  e58d0004          STR      r0,[sp,#4]
;;;585                        targetEndTempPr = findStartAddress(targetStartTempPr2+1, dataLeftLen - (targetStartTempPr2 - dataCurrentPr), pTargetCmdList->item[i]->endStr, strlen((char*)pTargetCmdList->item[i]->endStr));
000840  e7951104          LDR      r1,[r5,r4,LSL #2]
000844  e5910004          LDR      r0,[r1,#4]
000848  ebfffffe          BL       strlen
00084c  e58d0000          STR      r0,[sp,#0]
000850  e7950104          LDR      r0,[r5,r4,LSL #2]
000854  e5902004          LDR      r2,[r0,#4]
000858  e99d0009          LDMIB    sp,{r0,r3}
00085c  e0400003          SUB      r0,r0,r3
000860  e0481000          SUB      r1,r8,r0
000864  e59d0004          LDR      r0,[sp,#4]
000868  e2800001          ADD      r0,r0,#1
00086c  e59d3000          LDR      r3,[sp,#0]
000870  ebfffffe          BL       findStartAddress
000874  e58d0010          STR      r0,[sp,#0x10]
;;;586                        #if(ENABLE_AT_CMD_DEBUG_2)
;;;587                        sysprintf("   =find end=> %d\r\n", targetEndTempPr - dataCurrentPr);
;;;588                        #endif
;;;589                        if(targetEndTempPr)
000878  e59d0010          LDR      r0,[sp,#0x10]
00087c  e3500000          CMP      r0,#0
000880  0a000007          BEQ      |L1.2212|
;;;590                        {
;;;591                            targetLen = targetEndTempPr - targetStartTempPr + strlen((char*)pTargetCmdList->item[i]->endStr);
000884  e7951104          LDR      r1,[r5,r4,LSL #2]
000888  e5910004          LDR      r0,[r1,#4]
00088c  ebfffffe          BL       strlen
000890  e59d1010          LDR      r1,[sp,#0x10]
000894  e0411007          SUB      r1,r1,r7
000898  e0800001          ADD      r0,r0,r1
00089c  e58d000c          STR      r0,[sp,#0xc]
;;;592                            dataCurrentPr = targetStartTempPr; 
0008a0  e58d7008          STR      r7,[sp,#8]
                  |L1.2212|
;;;593                        }
;;;594                        else
;;;595                        {
;;;596                            #if(ENABLE_AT_CMD_DEBUG_2)
;;;597                            sysprintf("   =Cant find end=>\r\n");
;;;598                            #endif
;;;599                        }
;;;600    
;;;601                        if (targetLen)
0008a4  e59d000c          LDR      r0,[sp,#0xc]
0008a8  e3500000          CMP      r0,#0
0008ac  0a00001d          BEQ      |L1.2344|
;;;602                        {//頭尾都有找到
;;;603                            #if(ENABLE_AT_CMD_DEBUG_2)
;;;604                            sysprintf("   =targetHeaderIndex = %d, dataType = %d=>\r\n", targetHeaderIndex, pTargetCmdList->item[targetHeaderIndex]->dataType);
;;;605                            #endif 
;;;606                            memset(cmdDataTmp, 0x0, sizeof(cmdDataTmp));
0008b0  e3a01601          MOV      r1,#0x100000
0008b4  e51f025c          LDR      r0,|L1.1632|
0008b8  ebfffffe          BL       __aeabi_memclr
;;;607                            memcpy(cmdDataTmp, dataCurrentPr, targetLen);
0008bc  e51f0264          LDR      r0,|L1.1632|
0008c0  e59d1008          LDR      r1,[sp,#8]
0008c4  e59d200c          LDR      r2,[sp,#0xc]
0008c8  ebfffffe          BL       __aeabi_memcpy
;;;608                            dataCurrentIndex = targetEndTempPr - data + strlen((char*)(pTargetCmdList->item[i]->endStr));
0008cc  e7951104          LDR      r1,[r5,r4,LSL #2]
0008d0  e5910004          LDR      r0,[r1,#4]
0008d4  ebfffffe          BL       strlen
0008d8  e1a01000          MOV      r1,r0
0008dc  e59d0010          LDR      r0,[sp,#0x10]
0008e0  e040000a          SUB      r0,r0,r10
0008e4  e081b000          ADD      r11,r1,r0
;;;609                            cmdDataTmpIndex = targetLen;
0008e8  e51f1294          LDR      r1,|L1.1628|
0008ec  e59d000c          LDR      r0,[sp,#0xc]
0008f0  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;610                            #if(ENABLE_AT_CMD_DEBUG)
;;;611                            printfBuffData((char*) "[DATA]", cmdDataTmp, cmdDataTmpIndex);
;;;612                            #endif
;;;613                            //processCmdData(preProcessCmdData(pTargetCmdList->item[targetHeaderIndex]->dataType, cmdDataTmp, cmdDataTmpIndex));
;;;614                            reVal = preProcessCmdData(pTargetCmdList->item[targetHeaderIndex]->dataType, cmdDataTmp, cmdDataTmpIndex, parserType);
0008f4  e59d1014          LDR      r1,[sp,#0x14]
0008f8  e7951101          LDR      r1,[r5,r1,LSL #2]
0008fc  e5d10008          LDRB     r0,[r1,#8]
000900  e51f12ac          LDR      r1,|L1.1628|
000904  e59d3024          LDR      r3,[sp,#0x24]
000908  e5912000          LDR      r2,[r1,#0]  ; cmdDataTmpIndex
00090c  e51f12b4          LDR      r1,|L1.1632|
000910  ebfffffe          BL       preProcessCmdData
000914  e58d0018          STR      r0,[sp,#0x18]
;;;615                            cmdDataTmpIndex = 0;
000918  e3a00000          MOV      r0,#0
00091c  e51f12c8          LDR      r1,|L1.1628|
000920  e5810000          STR      r0,[r1,#0]  ; cmdDataTmpIndex
;;;616                            goto redo;
000924  eaffff91          B        |L1.1904|
                  |L1.2344|
;;;617                        }
;;;618                        else
;;;619                        {//只有找到頭  沒有尾 還沒有收完 
;;;620    
;;;621                        }
;;;622                    }
000928  e1a00000          MOV      r0,r0
                  |L1.2348|
;;;623                    else
;;;624                    {//沒找到這次頭
;;;625                        #if(ENABLE_AT_CMD_DEBUG_2)
;;;626                        sysprintf("   =Cant find header=>\r\n");
;;;627                        #endif
;;;628                    }
;;;629                }
;;;630                #if(ENABLE_AT_CMD_DEBUG_2)
;;;631                sysprintf("   =copy to temp=>\r\n");
;;;632                printfBuffData((char*)"Copy to TEMP", dataCurrentPr, dataLeftLen);
;;;633                #endif
;;;634                memcpy(cmdDataTmp, dataCurrentPr, dataLeftLen);
00092c  e1a02008          MOV      r2,r8
000930  e51f02d8          LDR      r0,|L1.1632|
000934  e59d1008          LDR      r1,[sp,#8]
000938  ebfffffe          BL       __aeabi_memcpy
;;;635                dataCurrentIndex = dataCurrentIndex + dataLeftLen;
00093c  e08bb008          ADD      r11,r11,r8
;;;636                cmdDataTmpIndex = dataLeftLen;
000940  e51f02ec          LDR      r0,|L1.1628|
000944  e5808000          STR      r8,[r0,#0]  ; cmdDataTmpIndex
                  |L1.2376|
000948  e15b0009          CMP      r11,r9                ;526
00094c  baffff86          BLT      |L1.1900|
                  |L1.2384|
000950  ea000005          B        |L1.2412|
                  |L1.2388|
;;;637            }
;;;638        }
;;;639        else
;;;640        {
;;;641            #if(ENABLE_AT_CMD_DEBUG_2)
;;;642            sysprintf("   =copy to temp=>\r\n");
;;;643            printfBuffData((char*)"Copy to TEMP", dataCurrentPr, dataLeftLen);
;;;644            #endif
;;;645            memcpy(cmdDataTmp, cmdData, totalCmdDataLen);
000954  e1a02009          MOV      r2,r9
000958  e51f12fc          LDR      r1,|L1.1636|
00095c  e51f0304          LDR      r0,|L1.1632|
000960  ebfffffe          BL       __aeabi_memcpy
;;;646            cmdDataTmpIndex = totalCmdDataLen;
000964  e51f0310          LDR      r0,|L1.1628|
000968  e5809000          STR      r9,[r0,#0]  ; cmdDataTmpIndex
                  |L1.2412|
;;;647        }
;;;648        return reVal;
00096c  e59d0018          LDR      r0,[sp,#0x18]
000970  e28dd02c          ADD      sp,sp,#0x2c
;;;649    }
000974  e8bd8ff0          POP      {r4-r11,pc}
;;;650    
                          ENDP

                  ATCmdSetReceiveDebugFlag PROC
;;;651    void ATCmdSetReceiveDebugFlag(int flag)
000978  e51f1318          LDR      r1,|L1.1640|
;;;652    {
;;;653        enableReceiveDebug = flag;
00097c  e5810000          STR      r0,[r1,#0]  ; enableReceiveDebug
;;;654    }
000980  e12fff1e          BX       lr
;;;655    
                          ENDP

                  ATCmdGetReceiveDebugFlag PROC
;;;656    BOOL ATCmdGetReceiveDebugFlag(void)
000984  e51f0324          LDR      r0,|L1.1640|
;;;657    {
;;;658        return enableReceiveDebug;
000988  e5d00000          LDRB     r0,[r0,#0]  ; enableReceiveDebug
;;;659    }
00098c  e12fff1e          BX       lr
;;;660    
                          ENDP

                  ATCmdDataTempBuffer PROC
;;;661    uint8_t* ATCmdDataTempBuffer(uint32_t* len)
000990  e1a01000          MOV      r1,r0
;;;662    {
;;;663        if(len != NULL)
000994  e3510000          CMP      r1,#0
000998  0a000002          BEQ      |L1.2472|
;;;664        {
;;;665            *len = dataTempBufferLen;
00099c  e51f0664          LDR      r0,|L1.832|
0009a0  e5900000          LDR      r0,[r0,#0]  ; dataTempBufferLen
0009a4  e5810000          STR      r0,[r1,#0]
                  |L1.2472|
;;;666        }
;;;667        //printfBuffData((char*)"Get Temp buffer", dataTempBuffer, dataTempBufferLen);
;;;668        return dataTempBuffer;
0009a8  e51f0674          LDR      r0,|L1.828|
;;;669    }
0009ac  e12fff1e          BX       lr
;;;670    
                          ENDP

                  ATCmdDataTempBuffer2 PROC
;;;671    uint8_t* ATCmdDataTempBuffer2(uint32_t* len)
0009b0  e1a01000          MOV      r1,r0
;;;672    {
;;;673        if(len != NULL)
0009b4  e3510000          CMP      r1,#0
0009b8  0a000002          BEQ      |L1.2504|
;;;674        {
;;;675            *len = dataTempBufferLen2;
0009bc  e51f068c          LDR      r0,|L1.824|
0009c0  e5900000          LDR      r0,[r0,#0]  ; dataTempBufferLen2
0009c4  e5810000          STR      r0,[r1,#0]
                  |L1.2504|
;;;676        }
;;;677        //printfBuffData((char*)"Get Temp buffer", dataTempBuffer, dataTempBufferLen);
;;;678        return dataTempBuffer2;
0009c8  e51f069c          LDR      r0,|L1.820|
;;;679    }
0009cc  e12fff1e          BX       lr
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  dataTempBuffer
                          %        1048576
                  dataTempBuffer2
                          %        65536
                  cmdDataTmp
                          %        1048576
                  cmdData
                          %        1048576

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  0d0a2b43          DCB      "\r\n+CPIN: READY\r\n",0
000004  50494e3a
000008  20524541
00000c  44590d0a
000010  00      
000011  0d0a2b43          DCB      "\r\n+CPIN: SIM PIN\r\n",0
000015  50494e3a
000019  2053494d
00001d  2050494e
000021  0d0a00  
000024  0d0a2b43          DCB      "\r\n+CREG: 0,1",0
000028  5245473a
00002c  20302c31
000030  00      
000031  0d0a2b43          DCB      "\r\n+CGATT: 1",0
000035  47415454
000039  3a203100
00003d  0d0a2b43          DCB      "\r\n+CGREG: 0,1",0
000041  47524547
000045  3a20302c
000049  3100    
00004b  0d0a2b51          DCB      "\r\n+QIACT: 1,1,1,",0
00004f  49414354
000053  3a20312c
000057  312c312c
00005b  00      
00005c  0d0a2b51          DCB      "\r\n+QFTPOPEN: 0,0\r\n",0
000060  4654504f
000064  50454e3a
000068  20302c30
00006c  0d0a00  
00006f  0d0a2b51          DCB      "\r\n+QFTPPUT: 0,",0
000073  46545050
000077  55543a20
00007b  302c00  
00007e  0d0a2b51          DCB      "\r\n+QFTPPUT: 609,0\r\n",0
000082  46545050
000086  55543a20
00008a  3630392c
00008e  300d0a00
000092  0d0a2b51          DCB      "\r\n+QFTPCLOSE:",0
000096  46545043
00009a  4c4f5345
00009e  3a00    
0000a0  0d0a2b51          DCB      "\r\n+QHTTPPOST: 0,200",0
0000a4  48545450
0000a8  504f5354
0000ac  3a20302c
0000b0  32303000
0000b4  0d0a2b51          DCB      "\r\n+QFTPCWD: 0,0\r\n",0
0000b8  46545043
0000bc  57443a20
0000c0  302c300d
0000c4  0a00    
0000c6  0d0a2b51          DCB      "\r\n+QFTPCWD: 627",0
0000ca  46545043
0000ce  57443a20
0000d2  36323700
0000d6  0d0a2b51          DCB      "\r\n+QFTPMKDIR:",0
0000da  4654504d
0000de  4b444952
0000e2  3a00    
0000e4  0d0a2b51          DCB      "\r\n+QFTPMKDIR: 627",0
0000e8  4654504d
0000ec  4b444952
0000f0  3a203632
0000f4  3700    
0000f6  0d0a2b51          DCB      "\r\n+QFTPPWD: 0,",0
0000fa  46545050
0000fe  57443a20
000102  302c00  
000105  0d0a2b51          DCB      "\r\n+QFTPPWD: 627",0
000109  46545050
00010d  57443a20
000111  36323700
000115  0d0a2b43          DCB      "\r\n+CSQ: ",0
000119  53513a20
00011d  00      
00011e  0d0a2b51          DCB      "\r\n+QFTPSIZE: ",0
000122  46545053
000126  495a453a
00012a  2000    
00012c  00                DCB      0
00012d  0d0a4f4b          DCB      "\r\nOK",0
000131  00      
000132  0d0a00            DCB      "\r\n",0
000135  0d0a4552          DCB      "\r\nERROR",0
000139  524f5200
00013d  0d0a2b43          DCB      "\r\n+CME ERROR:",0
000141  4d452045
000145  52524f52
000149  3a00    
00014b  0d0a2b00          DCB      "\r\n+",0
00014f  0d0a434f          DCB      "\r\nCONNECT",0
000153  4e4e4543
000157  5400    
000159  2b514854          DCB      "+QHTTPREAD: 0\r\n",0
00015d  54505245
000161  41443a20
000165  300d0a00
000169  2b514654          DCB      "+QFTPGET: 0",0
00016d  50474554
000171  3a203000

                          AREA ||.data||, DATA, ALIGN=2

                  enableReceiveDebug
                          DCD      0x00000000
                  cmdList
000004  0065              DCW      0x0065
000006  0000              DCB      0x00,0x00
                          DCD      ||.conststring||
00000c  01000000          DCB      0x01,0x00,0x00,0x00
000010  0079              DCW      0x0079
000012  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x11
000018  01000000          DCB      0x01,0x00,0x00,0x00
00001c  0066              DCW      0x0066
00001e  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x24
000024  01000000          DCB      0x01,0x00,0x00,0x00
000028  0067              DCW      0x0067
00002a  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x31
000030  01000000          DCB      0x01,0x00,0x00,0x00
000034  0068              DCW      0x0068
000036  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x3d
00003c  01000000          DCB      0x01,0x00,0x00,0x00
000040  0069              DCW      0x0069
000042  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x4b
000048  01000000          DCB      0x01,0x00,0x00,0x00
00004c  006a              DCW      0x006a
00004e  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x5c
000054  02000000          DCB      0x02,0x00,0x00,0x00
000058  006c              DCW      0x006c
00005a  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x6f
000060  02000000          DCB      0x02,0x00,0x00,0x00
000064  006d              DCW      0x006d
000066  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x7e
00006c  02000000          DCB      0x02,0x00,0x00,0x00
000070  006e              DCW      0x006e
000072  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x92
000078  02000000          DCB      0x02,0x00,0x00,0x00
00007c  006f              DCW      0x006f
00007e  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xa0
000084  02000000          DCB      0x02,0x00,0x00,0x00
000088  0071              DCW      0x0071
00008a  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xb4
000090  02000000          DCB      0x02,0x00,0x00,0x00
000094  0072              DCW      0x0072
000096  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xc6
00009c  02000000          DCB      0x02,0x00,0x00,0x00
0000a0  0074              DCW      0x0074
0000a2  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xd6
0000a8  02000000          DCB      0x02,0x00,0x00,0x00
0000ac  0075              DCW      0x0075
0000ae  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xe4
0000b4  02000000          DCB      0x02,0x00,0x00,0x00
0000b8  0076              DCW      0x0076
0000ba  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0xf6
0000c0  02000000          DCB      0x02,0x00,0x00,0x00
0000c4  0077              DCW      0x0077
0000c6  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x105
0000cc  02000000          DCB      0x02,0x00,0x00,0x00
0000d0  0078              DCW      0x0078
0000d2  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x115
0000d8  01000000          DCB      0x01,0x00,0x00,0x00
0000dc  007a              DCW      0x007a
0000de  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x11e
0000e4  02000000          DCB      0x02,0x00,0x00,0x00
0000e8  0000              DCW      0x0000
0000ea  0000              DCB      0x00,0x00
                          DCD      ||.conststring||+0x12c
0000f0  01000000          DCB      0x01,0x00,0x00,0x00
                  targetCmdItemOK
                          DCD      ||.conststring||+0x12d
                          DCD      ||.conststring||+0x132
0000fc  01000000          DCB      0x01,0x00,0x00,0x00
                  targetCmdItemError
                          DCD      ||.conststring||+0x135
                          DCD      ||.conststring||+0x132
000108  02000000          DCB      0x02,0x00,0x00,0x00
                  targetCmdItemCMEError
                          DCD      ||.conststring||+0x13d
                          DCD      ||.conststring||+0x132
000114  03000000          DCB      0x03,0x00,0x00,0x00
                  targetCmdItemATCmd
                          DCD      ||.conststring||+0x14b
                          DCD      ||.conststring||+0x132
000120  04000000          DCB      0x04,0x00,0x00,0x00
                  targetCmdItemConnect
                          DCD      ||.conststring||+0x14f
                          DCD      ||.conststring||+0x132
00012c  05000000          DCB      0x05,0x00,0x00,0x00
                  targetCmdItemWebPostGetData
                          DCD      ||.conststring||+0x14f
                          DCD      ||.conststring||+0x159
000138  06000000          DCB      0x06,0x00,0x00,0x00
                  targetCmdItemFtpGetData
                          DCD      ||.conststring||+0x14f
                          DCD      ||.conststring||+0x169
000144  07000000          DCB      0x07,0x00,0x00,0x00
                  targetCmdList
                          DCD      targetCmdItemOK
                          DCD      targetCmdItemError
                          DCD      targetCmdItemCMEError
                          DCD      targetCmdItemATCmd
                          DCD      targetCmdItemConnect
                  webPostTargetCmdList
                          DCD      targetCmdItemOK
                          DCD      targetCmdItemError
                          DCD      targetCmdItemCMEError
                          DCD      targetCmdItemATCmd
                          DCD      targetCmdItemWebPostGetData
                  ftpCmdList
                          DCD      targetCmdItemOK
                          DCD      targetCmdItemError
                          DCD      targetCmdItemCMEError
                          DCD      targetCmdItemATCmd
                          DCD      targetCmdItemFtpGetData
                  currentCmdType
000184  0000              DCW      0x0000
000186  0000              DCB      0x00,0x00
                  cmdDataTmpIndex
                          DCD      0x00000000
                  dataTempBufferLen
                          DCD      0x00000000
                  dataTempBufferLen2
                          DCD      0x00000000
