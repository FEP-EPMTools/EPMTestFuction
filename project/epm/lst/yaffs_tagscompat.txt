; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\yaffs_tagscompat.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\yaffs_tagscompat.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\yaffs_tagscompat.crf ..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_tagscompat.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  generic_hweight8 PROC
;;;99     
;;;100    static __inline unsigned int generic_hweight8(unsigned int w)
000000  e1a02000          MOV      r2,r0
;;;101    {
;;;102    	unsigned int res = (w & 0x55) + ((w >> 1) & 0x55);
000004  e2020055          AND      r0,r2,#0x55
000008  e3a03055          MOV      r3,#0x55
00000c  e00330a2          AND      r3,r3,r2,LSR #1
000010  e0801003          ADD      r1,r0,r3
;;;103    	res = (res & 0x33) + ((res >> 2) & 0x33);
000014  e2010033          AND      r0,r1,#0x33
000018  e3a03033          MOV      r3,#0x33
00001c  e0033121          AND      r3,r3,r1,LSR #2
000020  e0801003          ADD      r1,r0,r3
;;;104    	return (res & 0x0F) + ((res >> 4) & 0x0F);
000024  e201000f          AND      r0,r1,#0xf
000028  e3a0300f          MOV      r3,#0xf
00002c  e0033221          AND      r3,r3,r1,LSR #4
000030  e0800003          ADD      r0,r0,r3
;;;105    }
000034  e12fff1e          BX       lr
;;;106    
                          ENDP

                  yaffs_calc_ecc PROC
;;;26     
;;;27     void yaffs_calc_ecc(const u8 *data, struct yaffs_spare *spare)
000038  e92d4070          PUSH     {r4-r6,lr}
;;;28     {
00003c  e1a05000          MOV      r5,r0
000040  e1a04001          MOV      r4,r1
;;;29     	yaffs_ecc_calc(data, spare->ecc1);
000044  e2841008          ADD      r1,r4,#8
000048  e1a00005          MOV      r0,r5
00004c  ebfffffe          BL       yaffs_ecc_calc
;;;30     	yaffs_ecc_calc(&data[256], spare->ecc2);
000050  e284100d          ADD      r1,r4,#0xd
000054  e2850c01          ADD      r0,r5,#0x100
000058  ebfffffe          BL       yaffs_ecc_calc
;;;31     }
00005c  e8bd8070          POP      {r4-r6,pc}
;;;32     
                          ENDP

                  yaffs_calc_tags_ecc PROC
;;;33     void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
000060  e92d4070          PUSH     {r4-r6,lr}
;;;34     {
;;;35     	/* Calculate an ecc */
;;;36     	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
000064  e1a01000          MOV      r1,r0
;;;37     	unsigned i, j;
;;;38     	unsigned ecc = 0;
000068  e3a0c000          MOV      r12,#0
;;;39     	unsigned bit = 0;
00006c  e3a04000          MOV      r4,#0
;;;40     
;;;41     	tags->ecc = 0;
000070  e5905004          LDR      r5,[r0,#4]
000074  e3c5530f          BIC      r5,r5,#0x3c000000
000078  e3c557ff          BIC      r5,r5,#0x3fc0000
00007c  e5805004          STR      r5,[r0,#4]
;;;42     
;;;43     	for (i = 0; i < 8; i++) {
000080  e3a02000          MOV      r2,#0
000084  ea00000a          B        |L1.180|
                  |L1.136|
;;;44     		for (j = 1; j & 0xff; j <<= 1) {
000088  e3a03001          MOV      r3,#1
00008c  ea000005          B        |L1.168|
                  |L1.144|
;;;45     			bit++;
000090  e2844001          ADD      r4,r4,#1
;;;46     			if (b[i] & j)
000094  e7d15002          LDRB     r5,[r1,r2]
000098  e1150003          TST      r5,r3
00009c  0a000000          BEQ      |L1.164|
;;;47     				ecc ^= bit;
0000a0  e02cc004          EOR      r12,r12,r4
                  |L1.164|
0000a4  e1a03083          LSL      r3,r3,#1              ;44
                  |L1.168|
0000a8  e31300ff          TST      r3,#0xff              ;44
0000ac  1afffff7          BNE      |L1.144|
0000b0  e2822001          ADD      r2,r2,#1              ;43
                  |L1.180|
0000b4  e3520008          CMP      r2,#8                 ;43
0000b8  3afffff2          BCC      |L1.136|
;;;48     		}
;;;49     	}
;;;50     	tags->ecc = ecc;
0000bc  e5905004          LDR      r5,[r0,#4]
0000c0  e3c5530f          BIC      r5,r5,#0x3c000000
0000c4  e3c557ff          BIC      r5,r5,#0x3fc0000
0000c8  e59f6380          LDR      r6,|L1.1104|
0000cc  e006690c          AND      r6,r6,r12,LSL #18
0000d0  e1855006          ORR      r5,r5,r6
0000d4  e5805004          STR      r5,[r0,#4]
;;;51     }
0000d8  e8bd8070          POP      {r4-r6,pc}
;;;52     
                          ENDP

                  yaffs_check_tags_ecc PROC
;;;53     int yaffs_check_tags_ecc(struct yaffs_tags *tags)
0000dc  e92d4070          PUSH     {r4-r6,lr}
;;;54     {
0000e0  e1a05000          MOV      r5,r0
;;;55     	unsigned ecc = tags->ecc;
0000e4  e5950004          LDR      r0,[r5,#4]
0000e8  e1a00100          LSL      r0,r0,#2
0000ec  e1a04a20          LSR      r4,r0,#20
;;;56     
;;;57     	yaffs_calc_tags_ecc(tags);
0000f0  e1a00005          MOV      r0,r5
0000f4  ebfffffe          BL       yaffs_calc_tags_ecc
;;;58     
;;;59     	ecc ^= tags->ecc;
0000f8  e5950004          LDR      r0,[r5,#4]
0000fc  e1a00100          LSL      r0,r0,#2
000100  e0244a20          EOR      r4,r4,r0,LSR #20
;;;60     
;;;61     	if (ecc && ecc <= 64) {
000104  e3540000          CMP      r4,#0
000108  0a00000c          BEQ      |L1.320|
00010c  e3540040          CMP      r4,#0x40
000110  8a00000a          BHI      |L1.320|
;;;62     		/* TODO: Handle the failure better. Retire? */
;;;63     		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
000114  e1a06005          MOV      r6,r5
;;;64     
;;;65     		ecc--;
000118  e2444001          SUB      r4,r4,#1
;;;66     
;;;67     		b[ecc / 8] ^= (1 << (ecc & 7));
00011c  e7d601a4          LDRB     r0,[r6,r4,LSR #3]
000120  e2041007          AND      r1,r4,#7
000124  e3a02001          MOV      r2,#1
000128  e0200112          EOR      r0,r0,r2,LSL r1
00012c  e7c601a4          STRB     r0,[r6,r4,LSR #3]
;;;68     
;;;69     		/* Now recvalc the ecc */
;;;70     		yaffs_calc_tags_ecc(tags);
000130  e1a00005          MOV      r0,r5
000134  ebfffffe          BL       yaffs_calc_tags_ecc
;;;71     
;;;72     		return 1;	/* recovered error */
000138  e3a00001          MOV      r0,#1
                  |L1.316|
;;;73     	} else if (ecc) {
;;;74     		/* Wierd ecc failure value */
;;;75     		/* TODO Need to do somethiong here */
;;;76     		return -1;	/* unrecovered error */
;;;77     	}
;;;78     	return 0;
;;;79     }
00013c  e8bd8070          POP      {r4-r6,pc}
                  |L1.320|
000140  e1a00000          MOV      r0,r0                 ;73
000144  e3540000          CMP      r4,#0                 ;73
000148  0a000001          BEQ      |L1.340|
00014c  e3e00000          MVN      r0,#0                 ;76
000150  eafffff9          B        |L1.316|
                  |L1.340|
000154  e3a00000          MOV      r0,#0                 ;78
000158  eafffff7          B        |L1.316|
;;;80     
                          ENDP

                  yaffs_load_tags_to_spare PROC
;;;82     
;;;83     static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
00015c  e92d4070          PUSH     {r4-r6,lr}
;;;84     				     struct yaffs_tags *tags_ptr)
;;;85     {
000160  e1a05000          MOV      r5,r0
000164  e1a04001          MOV      r4,r1
;;;86     	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
000168  e1a06004          MOV      r6,r4
;;;87     
;;;88     	yaffs_calc_tags_ecc(tags_ptr);
00016c  e1a00004          MOV      r0,r4
000170  ebfffffe          BL       yaffs_calc_tags_ecc
;;;89     
;;;90     	spare_ptr->tb0 = tu->as_bytes[0];
000174  e5d60000          LDRB     r0,[r6,#0]
000178  e5c50000          STRB     r0,[r5,#0]
;;;91     	spare_ptr->tb1 = tu->as_bytes[1];
00017c  e5d60001          LDRB     r0,[r6,#1]
000180  e5c50001          STRB     r0,[r5,#1]
;;;92     	spare_ptr->tb2 = tu->as_bytes[2];
000184  e5d60002          LDRB     r0,[r6,#2]
000188  e5c50002          STRB     r0,[r5,#2]
;;;93     	spare_ptr->tb3 = tu->as_bytes[3];
00018c  e5d60003          LDRB     r0,[r6,#3]
000190  e5c50003          STRB     r0,[r5,#3]
;;;94     	spare_ptr->tb4 = tu->as_bytes[4];
000194  e5d60004          LDRB     r0,[r6,#4]
000198  e5c50006          STRB     r0,[r5,#6]
;;;95     	spare_ptr->tb5 = tu->as_bytes[5];
00019c  e5d60005          LDRB     r0,[r6,#5]
0001a0  e5c50007          STRB     r0,[r5,#7]
;;;96     	spare_ptr->tb6 = tu->as_bytes[6];
0001a4  e5d60006          LDRB     r0,[r6,#6]
0001a8  e5c5000b          STRB     r0,[r5,#0xb]
;;;97     	spare_ptr->tb7 = tu->as_bytes[7];
0001ac  e5d60007          LDRB     r0,[r6,#7]
0001b0  e5c5000c          STRB     r0,[r5,#0xc]
;;;98     }
0001b4  e8bd8070          POP      {r4-r6,pc}
;;;99     
                          ENDP

                  yaffs_get_tags_from_spare PROC
;;;100    static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
0001b8  e92d41f0          PUSH     {r4-r8,lr}
;;;101    				      struct yaffs_spare *spare_ptr,
;;;102    				      struct yaffs_tags *tags_ptr)
;;;103    {
0001bc  e1a07000          MOV      r7,r0
0001c0  e1a05001          MOV      r5,r1
0001c4  e1a04002          MOV      r4,r2
;;;104    	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
0001c8  e1a06004          MOV      r6,r4
;;;105    	int result;
;;;106    
;;;107    	tu->as_bytes[0] = spare_ptr->tb0;
0001cc  e5d50000          LDRB     r0,[r5,#0]
0001d0  e5c60000          STRB     r0,[r6,#0]
;;;108    	tu->as_bytes[1] = spare_ptr->tb1;
0001d4  e5d50001          LDRB     r0,[r5,#1]
0001d8  e5c60001          STRB     r0,[r6,#1]
;;;109    	tu->as_bytes[2] = spare_ptr->tb2;
0001dc  e5d50002          LDRB     r0,[r5,#2]
0001e0  e5c60002          STRB     r0,[r6,#2]
;;;110    	tu->as_bytes[3] = spare_ptr->tb3;
0001e4  e5d50003          LDRB     r0,[r5,#3]
0001e8  e5c60003          STRB     r0,[r6,#3]
;;;111    	tu->as_bytes[4] = spare_ptr->tb4;
0001ec  e5d50006          LDRB     r0,[r5,#6]
0001f0  e5c60004          STRB     r0,[r6,#4]
;;;112    	tu->as_bytes[5] = spare_ptr->tb5;
0001f4  e5d50007          LDRB     r0,[r5,#7]
0001f8  e5c60005          STRB     r0,[r6,#5]
;;;113    	tu->as_bytes[6] = spare_ptr->tb6;
0001fc  e5d5000b          LDRB     r0,[r5,#0xb]
000200  e5c60006          STRB     r0,[r6,#6]
;;;114    	tu->as_bytes[7] = spare_ptr->tb7;
000204  e5d5000c          LDRB     r0,[r5,#0xc]
000208  e5c60007          STRB     r0,[r6,#7]
;;;115    
;;;116    	result = yaffs_check_tags_ecc(tags_ptr);
00020c  e1a00004          MOV      r0,r4
000210  ebfffffe          BL       yaffs_check_tags_ecc
000214  e1a08000          MOV      r8,r0
;;;117    	if (result > 0)
000218  e3580000          CMP      r8,#0
00021c  da000003          BLE      |L1.560|
;;;118    		dev->n_tags_ecc_fixed++;
000220  e5970e48          LDR      r0,[r7,#0xe48]
000224  e2800001          ADD      r0,r0,#1
000228  e5870e48          STR      r0,[r7,#0xe48]
00022c  ea000004          B        |L1.580|
                  |L1.560|
;;;119    	else if (result < 0)
000230  e3580000          CMP      r8,#0
000234  aa000002          BGE      |L1.580|
;;;120    		dev->n_tags_ecc_unfixed++;
000238  e5970e4c          LDR      r0,[r7,#0xe4c]
00023c  e2800001          ADD      r0,r0,#1
000240  e5870e4c          STR      r0,[r7,#0xe4c]
                  |L1.580|
;;;121    }
000244  e8bd81f0          POP      {r4-r8,pc}
;;;122    
                          ENDP

                  yaffs_spare_init PROC
;;;123    static void yaffs_spare_init(struct yaffs_spare *spare)
000248  e92d4010          PUSH     {r4,lr}
;;;124    {
00024c  e1a04000          MOV      r4,r0
;;;125    	memset(spare, 0xff, sizeof(struct yaffs_spare));
000250  e3a020ff          MOV      r2,#0xff
000254  e3a01010          MOV      r1,#0x10
000258  e1a00004          MOV      r0,r4
00025c  ebfffffe          BL       __aeabi_memset
;;;126    }
000260  e8bd8010          POP      {r4,pc}
;;;127    
                          ENDP

                  yaffs_wr_nand PROC
;;;128    static int yaffs_wr_nand(struct yaffs_dev *dev,
000264  e92d41f0          PUSH     {r4-r8,lr}
;;;129    			 int nand_chunk, const u8 *data,
;;;130    			 struct yaffs_spare *spare)
;;;131    {
000268  e1a04000          MOV      r4,r0
00026c  e1a05001          MOV      r5,r1
000270  e1a06002          MOV      r6,r2
000274  e1a07003          MOV      r7,r3
;;;132    	if (nand_chunk < dev->param.start_block * dev->param.chunks_per_block) {
000278  e5940014          LDR      r0,[r4,#0x14]
00027c  e594100c          LDR      r1,[r4,#0xc]
000280  e0000091          MUL      r0,r1,r0
000284  e1500005          CMP      r0,r5
000288  da000008          BLE      |L1.688|
;;;133    		yaffs_trace(YAFFS_TRACE_ERROR,
00028c  e59f01c0          LDR      r0,|L1.1108|
000290  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000294  e3100101          TST      r0,#0x40000000
000298  0a000002          BEQ      |L1.680|
00029c  e1a01005          MOV      r1,r5
0002a0  e28f0e1b          ADR      r0,|L1.1112|
0002a4  ebfffffe          BL       sysprintf
                  |L1.680|
;;;134    			"**>> yaffs chunk %d is not valid",
;;;135    			nand_chunk);
;;;136    		return YAFFS_FAIL;
0002a8  e3a00000          MOV      r0,#0
                  |L1.684|
;;;137    	}
;;;138    
;;;139    	return dev->param.write_chunk_fn(dev, nand_chunk, data, spare);
;;;140    }
0002ac  e8bd81f0          POP      {r4-r8,pc}
                  |L1.688|
0002b0  e1a03007          MOV      r3,r7                 ;139
0002b4  e1a02006          MOV      r2,r6                 ;139
0002b8  e1a01005          MOV      r1,r5                 ;139
0002bc  e594c044          LDR      r12,[r4,#0x44]        ;139
0002c0  e1a00004          MOV      r0,r4                 ;139
0002c4  e12fff3c          BLX      r12                   ;139
0002c8  eafffff7          B        |L1.684|
;;;141    
                          ENDP

                  yaffs_handle_rd_data_error PROC
;;;263    
;;;264    static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
0002cc  e92d41f0          PUSH     {r4-r8,lr}
;;;265    {
0002d0  e1a04000          MOV      r4,r0
0002d4  e1a07001          MOV      r7,r1
;;;266    	int flash_block = nand_chunk / dev->param.chunks_per_block;
0002d8  e1a00007          MOV      r0,r7
0002dc  e594100c          LDR      r1,[r4,#0xc]
0002e0  ebfffffe          BL       __aeabi_idivmod
0002e4  e1a08000          MOV      r8,r0
;;;267    
;;;268    	/* Mark the block for retirement */
;;;269    	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
0002e8  e59400d8          LDR      r0,[r4,#0xd8]
0002ec  e0805008          ADD      r5,r0,r8
0002f0  e59400d0          LDR      r0,[r4,#0xd0]
0002f4  e1500005          CMP      r0,r5
0002f8  ca000002          BGT      |L1.776|
0002fc  e59400d4          LDR      r0,[r4,#0xd4]
000300  e1500005          CMP      r0,r5
000304  aa00000c          BGE      |L1.828|
                  |L1.776|
000308  e59f0144          LDR      r0,|L1.1108|
00030c  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000310  e3100101          TST      r0,#0x40000000
000314  0a000002          BEQ      |L1.804|
000318  e1a01005          MOV      r1,r5
00031c  e28f0e16          ADR      r0,|L1.1156|
000320  ebfffffe          BL       sysprintf
                  |L1.804|
000324  e1a00000          MOV      r0,r0
000328  e3a0201f          MOV      r2,#0x1f
00032c  e28f1f63          ADR      r1,|L1.1216|
000330  e28f0f71          ADR      r0,|L1.1276|
000334  ebfffffe          BL       sysprintf
000338  e1a00000          MOV      r0,r0
                  |L1.828|
00033c  e1a00000          MOV      r0,r0
000340  e59410d0          LDR      r1,[r4,#0xd0]
000344  e0451001          SUB      r1,r5,r1
000348  e5940118          LDR      r0,[r4,#0x118]
00034c  e0806181          ADD      r6,r0,r1,LSL #3
000350  e5960000          LDR      r0,[r6,#0]
000354  e3800401          ORR      r0,r0,#0x1000000
000358  e5860000          STR      r0,[r6,#0]
;;;270    		needs_retiring = 1;
;;;271    	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
00035c  e59f00f0          LDR      r0,|L1.1108|
000360  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000364  e3100141          TST      r0,#0x40000010
000368  0a000002          BEQ      |L1.888|
00036c  e1a01008          MOV      r1,r8
000370  e28f0f67          ADR      r0,|L1.1300|
000374  ebfffffe          BL       sysprintf
                  |L1.888|
;;;272    		"**>>Block %d marked for retirement",
;;;273    		flash_block);
;;;274    
;;;275    	/* TODO:
;;;276    	 * Just do a garbage collection on the affected block
;;;277    	 * then retire the block
;;;278    	 * NB recursion
;;;279    	 */
;;;280    }
000378  e8bd81f0          POP      {r4-r8,pc}
;;;281    
                          ENDP

                  yaffs_rd_chunk_nand PROC
;;;141    
;;;142    static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
00037c  e92d4fff          PUSH     {r0-r11,lr}
;;;143    			       int nand_chunk,
;;;144    			       u8 *data,
;;;145    			       struct yaffs_spare *spare,
;;;146    			       enum yaffs_ecc_result *ecc_result,
;;;147    			       int correct_errors)
;;;148    {
000380  e24dd02c          SUB      sp,sp,#0x2c
000384  e1a04000          MOV      r4,r0
000388  e1a05002          MOV      r5,r2
00038c  e1a07003          MOV      r7,r3
000390  e59d6060          LDR      r6,[sp,#0x60]
000394  e59db064          LDR      r11,[sp,#0x64]
;;;149    	int ret_val;
;;;150    	struct yaffs_spare local_spare;
;;;151    
;;;152    	if (!spare) {
000398  e3570000          CMP      r7,#0
00039c  1a000000          BNE      |L1.932|
;;;153    		/* If we don't have a real spare, then we use a local one. */
;;;154    		/* Need this for the calculation of the ecc */
;;;155    		spare = &local_spare;
0003a0  e28d701c          ADD      r7,sp,#0x1c
                  |L1.932|
;;;156    	}
;;;157    
;;;158    	if (!dev->param.use_nand_ecc) {
0003a4  e5940024          LDR      r0,[r4,#0x24]
0003a8  e3500000          CMP      r0,#0
0003ac  1a0000ae          BNE      |L1.1644|
;;;159    		ret_val =
0003b0  e1a03007          MOV      r3,r7
0003b4  e1a02005          MOV      r2,r5
0003b8  e594c048          LDR      r12,[r4,#0x48]
0003bc  e1a00004          MOV      r0,r4
0003c0  e59d1030          LDR      r1,[sp,#0x30]
0003c4  e12fff3c          BLX      r12
0003c8  e1a0a000          MOV      r10,r0
;;;160    		    dev->param.read_chunk_fn(dev, nand_chunk, data, spare);
;;;161    		if (data && correct_errors) {
0003cc  e3550000          CMP      r5,#0
0003d0  0a00014f          BEQ      |L1.2324|
0003d4  e35b0000          CMP      r11,#0
0003d8  0a00014d          BEQ      |L1.2324|
;;;162    			/* Do ECC correction */
;;;163    			/* Todo handle any errors */
;;;164    			int ecc_result1, ecc_result2;
;;;165    			u8 calc_ecc[3];
;;;166    
;;;167    			yaffs_ecc_calc(data, calc_ecc);
0003dc  e28d1018          ADD      r1,sp,#0x18
0003e0  e1a00005          MOV      r0,r5
0003e4  ebfffffe          BL       yaffs_ecc_calc
;;;168    			ecc_result1 =
0003e8  e28d2018          ADD      r2,sp,#0x18
0003ec  e2871008          ADD      r1,r7,#8
0003f0  e1a00005          MOV      r0,r5
0003f4  ebfffffe          BL       yaffs_ecc_correct
0003f8  e1a08000          MOV      r8,r0
;;;169    			    yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
;;;170    			yaffs_ecc_calc(&data[256], calc_ecc);
0003fc  e28d1018          ADD      r1,sp,#0x18
000400  e2850c01          ADD      r0,r5,#0x100
000404  ebfffffe          BL       yaffs_ecc_calc
;;;171    			ecc_result2 =
000408  e28d2018          ADD      r2,sp,#0x18
00040c  e287100d          ADD      r1,r7,#0xd
000410  e2850c01          ADD      r0,r5,#0x100
000414  ebfffffe          BL       yaffs_ecc_correct
000418  e1a09000          MOV      r9,r0
;;;172    			    yaffs_ecc_correct(&data[256], spare->ecc2,
;;;173    					      calc_ecc);
;;;174    
;;;175    			if (ecc_result1 > 0) {
00041c  e3580000          CMP      r8,#0
000420  da000054          BLE      |L1.1400|
;;;176    				yaffs_trace(YAFFS_TRACE_ERROR,
000424  e59f0028          LDR      r0,|L1.1108|
000428  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00042c  e3100101          TST      r0,#0x40000000
000430  0a000002          BEQ      |L1.1088|
000434  e28f0f41          ADR      r0,|L1.1344|
000438  e59d1030          LDR      r1,[sp,#0x30]
00043c  ebfffffe          BL       sysprintf
                  |L1.1088|
;;;177    					"**>>yaffs ecc error fix performed on chunk %d:0",
;;;178    					nand_chunk);
;;;179    				dev->n_ecc_fixed++;
000440  e5940e40          LDR      r0,[r4,#0xe40]
000444  e2800001          ADD      r0,r0,#1
000448  e5840e40          STR      r0,[r4,#0xe40]
00044c  ea000055          B        |L1.1448|
                  |L1.1104|
                          DCD      0x3ffc0000
                  |L1.1108|
                          DCD      yaffs_trace_mask
                  |L1.1112|
000458  79616666          DCB      "yaffs: **>> yaffs chunk %d is not valid\n",0
00045c  733a202a
000460  2a3e3e20
000464  79616666
000468  73206368
00046c  756e6b20
000470  25642069
000474  73206e6f
000478  74207661
00047c  6c69640a
000480  00      
000481  00                DCB      0
000482  00                DCB      0
000483  00                DCB      0
                  |L1.1156|
000484  79616666          DCB      "yaffs: **>> yaffs: get_block_info block %d is not valid"
000488  733a202a
00048c  2a3e3e20
000490  79616666
000494  733a2067
000498  65745f62
00049c  6c6f636b
0004a0  5f696e66
0004a4  6f20626c
0004a8  6f636b20
0004ac  25642069
0004b0  73206e6f
0004b4  74207661
0004b8  6c6964  
0004bb  0a00              DCB      "\n",0
0004bd  00                DCB      0
0004be  00                DCB      0
0004bf  00                DCB      0
                  |L1.1216|
0004c0  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\yaffs_get"
0004c4  2e5c636f
0004c8  6d6d6f6e
0004cc  5c737263
0004d0  5c425350
0004d4  5c546869
0004d8  72645061
0004dc  7274795c
0004e0  79616666
0004e4  73325c79
0004e8  61666673
0004ec  5f676574
0004f0  626c6f63          DCB      "blockinfo.h",0
0004f4  6b696e66
0004f8  6f2e6800
                  |L1.1276|
0004fc  552d426f          DCB      "U-Boot BUG at %s:%d!\n",0
000500  6f742042
000504  55472061
000508  74202573
00050c  3a256421
000510  0a00    
000512  00                DCB      0
000513  00                DCB      0
                  |L1.1300|
000514  79616666          DCB      "yaffs: **>>Block %d marked for retirement\n",0
000518  733a202a
00051c  2a3e3e42
000520  6c6f636b
000524  20256420
000528  6d61726b
00052c  65642066
000530  6f722072
000534  65746972
000538  656d656e
00053c  740a00  
00053f  00                DCB      0
                  |L1.1344|
000540  79616666          DCB      "yaffs: **>>yaffs ecc error fix performed on chunk %d:0\n"
000544  733a202a
000548  2a3e3e79
00054c  61666673
000550  20656363
000554  20657272
000558  6f722066
00055c  69782070
000560  6572666f
000564  726d6564
000568  206f6e20
00056c  6368756e
000570  6b202564
000574  3a300a  
000577  00                DCB      0
                  |L1.1400|
;;;180    			} else if (ecc_result1 < 0) {
000578  e3580000          CMP      r8,#0
00057c  aa000009          BGE      |L1.1448|
;;;181    				yaffs_trace(YAFFS_TRACE_ERROR,
000580  e51f0134          LDR      r0,|L1.1108|
000584  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000588  e3100101          TST      r0,#0x40000000
00058c  0a000002          BEQ      |L1.1436|
000590  e28f0f67          ADR      r0,|L1.1844|
000594  e59d1030          LDR      r1,[sp,#0x30]
000598  ebfffffe          BL       sysprintf
                  |L1.1436|
;;;182    					"**>>yaffs ecc error unfixed on chunk %d:0",
;;;183    					nand_chunk);
;;;184    				dev->n_ecc_unfixed++;
00059c  e5940e44          LDR      r0,[r4,#0xe44]
0005a0  e2800001          ADD      r0,r0,#1
0005a4  e5840e44          STR      r0,[r4,#0xe44]
                  |L1.1448|
;;;185    			}
;;;186    
;;;187    			if (ecc_result2 > 0) {
0005a8  e3590000          CMP      r9,#0
0005ac  da00000a          BLE      |L1.1500|
;;;188    				yaffs_trace(YAFFS_TRACE_ERROR,
0005b0  e51f0164          LDR      r0,|L1.1108|
0005b4  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0005b8  e3100101          TST      r0,#0x40000000
0005bc  0a000002          BEQ      |L1.1484|
0005c0  e28f0e1a          ADR      r0,|L1.1896|
0005c4  e59d1030          LDR      r1,[sp,#0x30]
0005c8  ebfffffe          BL       sysprintf
                  |L1.1484|
;;;189    					"**>>yaffs ecc error fix performed on chunk %d:1",
;;;190    					nand_chunk);
;;;191    				dev->n_ecc_fixed++;
0005cc  e5940e40          LDR      r0,[r4,#0xe40]
0005d0  e2800001          ADD      r0,r0,#1
0005d4  e5840e40          STR      r0,[r4,#0xe40]
0005d8  ea00000b          B        |L1.1548|
                  |L1.1500|
;;;192    			} else if (ecc_result2 < 0) {
0005dc  e3590000          CMP      r9,#0
0005e0  aa000009          BGE      |L1.1548|
;;;193    				yaffs_trace(YAFFS_TRACE_ERROR,
0005e4  e51f0198          LDR      r0,|L1.1108|
0005e8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0005ec  e3100101          TST      r0,#0x40000000
0005f0  0a000002          BEQ      |L1.1536|
0005f4  e28f0f69          ADR      r0,|L1.1952|
0005f8  e59d1030          LDR      r1,[sp,#0x30]
0005fc  ebfffffe          BL       sysprintf
                  |L1.1536|
;;;194    					"**>>yaffs ecc error unfixed on chunk %d:1",
;;;195    					nand_chunk);
;;;196    				dev->n_ecc_unfixed++;
000600  e5940e44          LDR      r0,[r4,#0xe44]
000604  e2800001          ADD      r0,r0,#1
000608  e5840e44          STR      r0,[r4,#0xe44]
                  |L1.1548|
;;;197    			}
;;;198    
;;;199    			if (ecc_result1 || ecc_result2) {
00060c  e3580000          CMP      r8,#0
000610  1a000001          BNE      |L1.1564|
000614  e3590000          CMP      r9,#0
000618  0a000002          BEQ      |L1.1576|
                  |L1.1564|
;;;200    				/* We had a data problem on this page */
;;;201    				yaffs_handle_rd_data_error(dev, nand_chunk);
00061c  e1a00004          MOV      r0,r4
000620  e59d1030          LDR      r1,[sp,#0x30]
000624  ebfffffe          BL       yaffs_handle_rd_data_error
                  |L1.1576|
;;;202    			}
;;;203    
;;;204    			if (ecc_result1 < 0 || ecc_result2 < 0)
000628  e3580000          CMP      r8,#0
00062c  ba000001          BLT      |L1.1592|
000630  e3590000          CMP      r9,#0
000634  aa000002          BGE      |L1.1604|
                  |L1.1592|
;;;205    				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
000638  e3a00003          MOV      r0,#3
00063c  e5c60000          STRB     r0,[r6,#0]
000640  ea000008          B        |L1.1640|
                  |L1.1604|
;;;206    			else if (ecc_result1 > 0 || ecc_result2 > 0)
000644  e3580000          CMP      r8,#0
000648  ca000001          BGT      |L1.1620|
00064c  e3590000          CMP      r9,#0
000650  da000002          BLE      |L1.1632|
                  |L1.1620|
;;;207    				*ecc_result = YAFFS_ECC_RESULT_FIXED;
000654  e3a00002          MOV      r0,#2
000658  e5c60000          STRB     r0,[r6,#0]
00065c  ea000001          B        |L1.1640|
                  |L1.1632|
;;;208    			else
;;;209    				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
000660  e3a00001          MOV      r0,#1
000664  e5c60000          STRB     r0,[r6,#0]
                  |L1.1640|
;;;210    		}
000668  ea0000a9          B        |L1.2324|
                  |L1.1644|
;;;211    	} else {
;;;212    		/* Must allocate enough memory for spare+2*sizeof(int) */
;;;213    		/* for ecc results from device. */
;;;214    		struct yaffs_nand_spare nspare;
;;;215    
;;;216    		memset(&nspare, 0, sizeof(nspare));
00066c  e3a01018          MOV      r1,#0x18
000670  e28d0004          ADD      r0,sp,#4
000674  ebfffffe          BL       __aeabi_memclr4
;;;217    
;;;218    		ret_val = dev->param.read_chunk_fn(dev, nand_chunk, data,
000678  e28d3004          ADD      r3,sp,#4
00067c  e1a02005          MOV      r2,r5
000680  e594c048          LDR      r12,[r4,#0x48]
000684  e1a00004          MOV      r0,r4
000688  e59d1030          LDR      r1,[sp,#0x30]
00068c  e12fff3c          BLX      r12
000690  e1a0a000          MOV      r10,r0
;;;219    						   (struct yaffs_spare *)
;;;220    						   &nspare);
;;;221    		memcpy(spare, &nspare, sizeof(struct yaffs_spare));
000694  e3a02010          MOV      r2,#0x10
000698  e28d1004          ADD      r1,sp,#4
00069c  e1a00007          MOV      r0,r7
0006a0  ebfffffe          BL       __aeabi_memcpy
;;;222    		if (data && correct_errors) {
0006a4  e3550000          CMP      r5,#0
0006a8  0a000098          BEQ      |L1.2320|
0006ac  e35b0000          CMP      r11,#0
0006b0  0a000096          BEQ      |L1.2320|
;;;223    			if (nspare.eccres1 > 0) {
0006b4  e59d0014          LDR      r0,[sp,#0x14]
0006b8  e3500000          CMP      r0,#0
0006bc  da000007          BLE      |L1.1760|
;;;224    				yaffs_trace(YAFFS_TRACE_ERROR,
0006c0  e51f0274          LDR      r0,|L1.1108|
0006c4  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0006c8  e3100101          TST      r0,#0x40000000
0006cc  0a00000d          BEQ      |L1.1800|
0006d0  e28f00fc          ADR      r0,|L1.2004|
0006d4  e59d1030          LDR      r1,[sp,#0x30]
0006d8  ebfffffe          BL       sysprintf
0006dc  ea000009          B        |L1.1800|
                  |L1.1760|
;;;225    					"**>>mtd ecc error fix performed on chunk %d:0",
;;;226    					nand_chunk);
;;;227    			} else if (nspare.eccres1 < 0) {
0006e0  e59d0014          LDR      r0,[sp,#0x14]
0006e4  e3500000          CMP      r0,#0
0006e8  aa000006          BGE      |L1.1800|
;;;228    				yaffs_trace(YAFFS_TRACE_ERROR,
0006ec  e51f02a0          LDR      r0,|L1.1108|
0006f0  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0006f4  e3100101          TST      r0,#0x40000000
0006f8  0a000002          BEQ      |L1.1800|
0006fc  e28f0f42          ADR      r0,|L1.2060|
000700  e59d1030          LDR      r1,[sp,#0x30]
000704  ebfffffe          BL       sysprintf
                  |L1.1800|
;;;229    					"**>>mtd ecc error unfixed on chunk %d:0",
;;;230    					nand_chunk);
;;;231    			}
;;;232    
;;;233    			if (nspare.eccres2 > 0) {
000708  e59d0018          LDR      r0,[sp,#0x18]
00070c  e3500000          CMP      r0,#0
000710  da000057          BLE      |L1.2164|
;;;234    				yaffs_trace(YAFFS_TRACE_ERROR,
000714  e51f02c8          LDR      r0,|L1.1108|
000718  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00071c  e3100101          TST      r0,#0x40000000
000720  0a00005d          BEQ      |L1.2204|
000724  e28f0f44          ADD      r0,pc,#0x44, 30 ; #0x110
000728  e59d1030          LDR      r1,[sp,#0x30]
00072c  ebfffffe          BL       sysprintf
000730  ea000059          B        |L1.2204|
                  |L1.1844|
000734  79616666          DCB      "yaffs: **>>yaffs ecc error unfixed on chunk %d:0\n",0
000738  733a202a
00073c  2a3e3e79
000740  61666673
000744  20656363
000748  20657272
00074c  6f722075
000750  6e666978
000754  6564206f
000758  6e206368
00075c  756e6b20
000760  25643a30
000764  0a00    
000766  00                DCB      0
000767  00                DCB      0
                  |L1.1896|
000768  79616666          DCB      "yaffs: **>>yaffs ecc error fix performed on chunk %d:1\n"
00076c  733a202a
000770  2a3e3e79
000774  61666673
000778  20656363
00077c  20657272
000780  6f722066
000784  69782070
000788  6572666f
00078c  726d6564
000790  206f6e20
000794  6368756e
000798  6b202564
00079c  3a310a  
00079f  00                DCB      0
                  |L1.1952|
0007a0  79616666          DCB      "yaffs: **>>yaffs ecc error unfixed on chunk %d:1\n",0
0007a4  733a202a
0007a8  2a3e3e79
0007ac  61666673
0007b0  20656363
0007b4  20657272
0007b8  6f722075
0007bc  6e666978
0007c0  6564206f
0007c4  6e206368
0007c8  756e6b20
0007cc  25643a31
0007d0  0a00    
0007d2  00                DCB      0
0007d3  00                DCB      0
                  |L1.2004|
0007d4  79616666          DCB      "yaffs: **>>mtd ecc error fix performed on chunk %d:0\n",0
0007d8  733a202a
0007dc  2a3e3e6d
0007e0  74642065
0007e4  63632065
0007e8  72726f72
0007ec  20666978
0007f0  20706572
0007f4  666f726d
0007f8  6564206f
0007fc  6e206368
000800  756e6b20
000804  25643a30
000808  0a00    
00080a  00                DCB      0
00080b  00                DCB      0
                  |L1.2060|
00080c  79616666          DCB      "yaffs: **>>mtd ecc error unfixed on chunk %d:0\n",0
000810  733a202a
000814  2a3e3e6d
000818  74642065
00081c  63632065
000820  72726f72
000824  20756e66
000828  69786564
00082c  206f6e20
000830  6368756e
000834  6b202564
000838  3a300a00
00083c  79616666          DCB      "yaffs: **>>mtd ecc error fix performed on chunk %d:1\n",0
000840  733a202a
000844  2a3e3e6d
000848  74642065
00084c  63632065
000850  72726f72
000854  20666978
000858  20706572
00085c  666f726d
000860  6564206f
000864  6e206368
000868  756e6b20
00086c  25643a31
000870  0a00    
000872  00                DCB      0
000873  00                DCB      0
                  |L1.2164|
;;;235    					"**>>mtd ecc error fix performed on chunk %d:1",
;;;236    					nand_chunk);
;;;237    			} else if (nspare.eccres2 < 0) {
000874  e59d0018          LDR      r0,[sp,#0x18]
000878  e3500000          CMP      r0,#0
00087c  aa000006          BGE      |L1.2204|
;;;238    				yaffs_trace(YAFFS_TRACE_ERROR,
000880  e51f0434          LDR      r0,|L1.1108|
000884  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000888  e3100101          TST      r0,#0x40000000
00088c  0a000002          BEQ      |L1.2204|
000890  e28f0e33          ADR      r0,|L1.3016|
000894  e59d1030          LDR      r1,[sp,#0x30]
000898  ebfffffe          BL       sysprintf
                  |L1.2204|
;;;239    					"**>>mtd ecc error unfixed on chunk %d:1",
;;;240    					nand_chunk);
;;;241    			}
;;;242    
;;;243    			if (nspare.eccres1 || nspare.eccres2) {
00089c  e59d0014          LDR      r0,[sp,#0x14]
0008a0  e3500000          CMP      r0,#0
0008a4  1a000002          BNE      |L1.2228|
0008a8  e59d0018          LDR      r0,[sp,#0x18]
0008ac  e3500000          CMP      r0,#0
0008b0  0a000002          BEQ      |L1.2240|
                  |L1.2228|
;;;244    				/* We had a data problem on this page */
;;;245    				yaffs_handle_rd_data_error(dev, nand_chunk);
0008b4  e1a00004          MOV      r0,r4
0008b8  e59d1030          LDR      r1,[sp,#0x30]
0008bc  ebfffffe          BL       yaffs_handle_rd_data_error
                  |L1.2240|
;;;246    			}
;;;247    
;;;248    			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
0008c0  e59d0014          LDR      r0,[sp,#0x14]
0008c4  e3500000          CMP      r0,#0
0008c8  ba000002          BLT      |L1.2264|
0008cc  e59d0018          LDR      r0,[sp,#0x18]
0008d0  e3500000          CMP      r0,#0
0008d4  aa000002          BGE      |L1.2276|
                  |L1.2264|
;;;249    				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
0008d8  e3a00003          MOV      r0,#3
0008dc  e5c60000          STRB     r0,[r6,#0]
0008e0  ea00000a          B        |L1.2320|
                  |L1.2276|
;;;250    			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
0008e4  e59d0014          LDR      r0,[sp,#0x14]
0008e8  e3500000          CMP      r0,#0
0008ec  ca000002          BGT      |L1.2300|
0008f0  e59d0018          LDR      r0,[sp,#0x18]
0008f4  e3500000          CMP      r0,#0
0008f8  da000002          BLE      |L1.2312|
                  |L1.2300|
;;;251    				*ecc_result = YAFFS_ECC_RESULT_FIXED;
0008fc  e3a00002          MOV      r0,#2
000900  e5c60000          STRB     r0,[r6,#0]
000904  ea000001          B        |L1.2320|
                  |L1.2312|
;;;252    			else
;;;253    				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
000908  e3a00001          MOV      r0,#1
00090c  e5c60000          STRB     r0,[r6,#0]
                  |L1.2320|
;;;254    
;;;255    		}
;;;256    	}
000910  e1a00000          MOV      r0,r0
                  |L1.2324|
;;;257    	return ret_val;
000914  e1a0000a          MOV      r0,r10
000918  e28dd03c          ADD      sp,sp,#0x3c
;;;258    }
00091c  e8bd8ff0          POP      {r4-r11,pc}
;;;259    
                          ENDP

                  yaffs_tags_compat_wr PROC
;;;281    
;;;282    int yaffs_tags_compat_wr(struct yaffs_dev *dev,
000920  e92d40f0          PUSH     {r4-r7,lr}
;;;283    			 int nand_chunk,
;;;284    			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
;;;285    {
000924  e24dd01c          SUB      sp,sp,#0x1c
000928  e1a05000          MOV      r5,r0
00092c  e1a07001          MOV      r7,r1
000930  e1a06002          MOV      r6,r2
000934  e1a04003          MOV      r4,r3
;;;286    	struct yaffs_spare spare;
;;;287    	struct yaffs_tags tags;
;;;288    
;;;289    	yaffs_spare_init(&spare);
000938  e28d000c          ADD      r0,sp,#0xc
00093c  ebfffffe          BL       yaffs_spare_init
;;;290    
;;;291    	if (ext_tags->is_deleted)
000940  e5940018          LDR      r0,[r4,#0x18]
000944  e3500000          CMP      r0,#0
000948  0a000002          BEQ      |L1.2392|
;;;292    		spare.page_status = 0;
00094c  e3a00000          MOV      r0,#0
000950  e5cd0010          STRB     r0,[sp,#0x10]
000954  ea000038          B        |L1.2620|
                  |L1.2392|
;;;293    	else {
;;;294    		tags.obj_id = ext_tags->obj_id;
000958  e59d0008          LDR      r0,[sp,#8]
00095c  e1a00920          LSR      r0,r0,#18
000960  e1a00900          LSL      r0,r0,#18
000964  e5941004          LDR      r1,[r4,#4]
000968  e1a01701          LSL      r1,r1,#14
00096c  e1a01721          LSR      r1,r1,#14
000970  e1800001          ORR      r0,r0,r1
000974  e58d0008          STR      r0,[sp,#8]
;;;295    		tags.chunk_id = ext_tags->chunk_id;
000978  e59d0004          LDR      r0,[sp,#4]
00097c  e1a00a20          LSR      r0,r0,#20
000980  e1a00a00          LSL      r0,r0,#20
000984  e5941008          LDR      r1,[r4,#8]
000988  e1a01601          LSL      r1,r1,#12
00098c  e1a01621          LSR      r1,r1,#12
000990  e1800001          ORR      r0,r0,r1
000994  e58d0004          STR      r0,[sp,#4]
;;;296    
;;;297    		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
000998  e59d0004          LDR      r0,[sp,#4]
00099c  e1a00500          LSL      r0,r0,#10
0009a0  e1a00520          LSR      r0,r0,#10
0009a4  e1d410bc          LDRH     r1,[r4,#0xc]
0009a8  e59f2248          LDR      r2,|L1.3064|
0009ac  e0021b01          AND      r1,r2,r1,LSL #22
0009b0  e1800001          ORR      r0,r0,r1
0009b4  e58d0004          STR      r0,[sp,#4]
;;;298    
;;;299    		if (dev->data_bytes_per_chunk >= 1024)
0009b8  e59500a4          LDR      r0,[r5,#0xa4]
0009bc  e3500b01          CMP      r0,#0x400
0009c0  ba000008          BLT      |L1.2536|
;;;300    			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
0009c4  e59d0008          LDR      r0,[sp,#8]
0009c8  e3c00103          BIC      r0,r0,#0xc0000000
0009cc  e1d410bc          LDRH     r1,[r4,#0xc]
0009d0  e1a01521          LSR      r1,r1,#10
0009d4  e3a02103          MOV      r2,#0xc0000000
0009d8  e0021f01          AND      r1,r2,r1,LSL #30
0009dc  e1800001          ORR      r0,r0,r1
0009e0  e58d0008          STR      r0,[sp,#8]
0009e4  ea000002          B        |L1.2548|
                  |L1.2536|
;;;301    		else
;;;302    			tags.n_bytes_msb = 3;
0009e8  e59d0008          LDR      r0,[sp,#8]
0009ec  e3800103          ORR      r0,r0,#0xc0000000
0009f0  e58d0008          STR      r0,[sp,#8]
                  |L1.2548|
;;;303    
;;;304    		tags.serial_number = ext_tags->serial_number;
0009f4  e59d0004          LDR      r0,[sp,#4]
0009f8  e3c00603          BIC      r0,r0,#0x300000
0009fc  e1d411bc          LDRH     r1,[r4,#0x1c]
000a00  e3a02603          MOV      r2,#0x300000
000a04  e0021a01          AND      r1,r2,r1,LSL #20
000a08  e1800001          ORR      r0,r0,r1
000a0c  e58d0004          STR      r0,[sp,#4]
;;;305    
;;;306    		if (!dev->param.use_nand_ecc && data)
000a10  e5950024          LDR      r0,[r5,#0x24]
000a14  e3500000          CMP      r0,#0
000a18  1a000004          BNE      |L1.2608|
000a1c  e3560000          CMP      r6,#0
000a20  0a000002          BEQ      |L1.2608|
;;;307    			yaffs_calc_ecc(data, &spare);
000a24  e28d100c          ADD      r1,sp,#0xc
000a28  e1a00006          MOV      r0,r6
000a2c  ebfffffe          BL       yaffs_calc_ecc
                  |L1.2608|
;;;308    
;;;309    		yaffs_load_tags_to_spare(&spare, &tags);
000a30  e28d1004          ADD      r1,sp,#4
000a34  e28d000c          ADD      r0,sp,#0xc
000a38  ebfffffe          BL       yaffs_load_tags_to_spare
                  |L1.2620|
;;;310    	}
;;;311    	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
000a3c  e28d300c          ADD      r3,sp,#0xc
000a40  e1a02006          MOV      r2,r6
000a44  e1a01007          MOV      r1,r7
000a48  e1a00005          MOV      r0,r5
000a4c  ebfffffe          BL       yaffs_wr_nand
000a50  e28dd01c          ADD      sp,sp,#0x1c
;;;312    }
000a54  e8bd80f0          POP      {r4-r7,pc}
;;;313    
                          ENDP

                  yaffs_tags_compat_rd PROC
;;;314    int yaffs_tags_compat_rd(struct yaffs_dev *dev,
000a58  e92d41f0          PUSH     {r4-r8,lr}
;;;315    			 int nand_chunk,
;;;316    			 u8 *data, struct yaffs_ext_tags *ext_tags)
;;;317    {
000a5c  e24dd028          SUB      sp,sp,#0x28
000a60  e1a05000          MOV      r5,r0
000a64  e1a06001          MOV      r6,r1
000a68  e1a07002          MOV      r7,r2
000a6c  e1a04003          MOV      r4,r3
;;;318    	struct yaffs_spare spare;
;;;319    	struct yaffs_tags tags;
;;;320    	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
000a70  e3a00000          MOV      r0,#0
000a74  e58d000c          STR      r0,[sp,#0xc]
;;;321    	static struct yaffs_spare spare_ff;
;;;322    	static int init;
;;;323    	int deleted;
;;;324    
;;;325    	if (!init) {
000a78  e59f017c          LDR      r0,|L1.3068|
000a7c  e5900000          LDR      r0,[r0,#0]  ; init
000a80  e3500000          CMP      r0,#0
000a84  1a000006          BNE      |L1.2724|
;;;326    		memset(&spare_ff, 0xff, sizeof(spare_ff));
000a88  e3a020ff          MOV      r2,#0xff
000a8c  e3a01010          MOV      r1,#0x10
000a90  e59f0168          LDR      r0,|L1.3072|
000a94  ebfffffe          BL       __aeabi_memset
;;;327    		init = 1;
000a98  e3a00001          MOV      r0,#1
000a9c  e59f1158          LDR      r1,|L1.3068|
000aa0  e5810000          STR      r0,[r1,#0]  ; init
                  |L1.2724|
;;;328    	}
;;;329    
;;;330    	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
000aa4  e3a00001          MOV      r0,#1
000aa8  e28d100c          ADD      r1,sp,#0xc
000aac  e58d0004          STR      r0,[sp,#4]
000ab0  e58d1000          STR      r1,[sp,#0]
000ab4  e28d3018          ADD      r3,sp,#0x18
000ab8  e1a02007          MOV      r2,r7
000abc  e1a01006          MOV      r1,r6
000ac0  e1a00005          MOV      r0,r5
000ac4  ebfffffe          BL       yaffs_rd_chunk_nand
000ac8  e3500000          CMP      r0,#0
000acc  1a000002          BNE      |L1.2780|
;;;331    					data, &spare, &ecc_result, 1))
;;;332    		return YAFFS_FAIL;
000ad0  e3a00000          MOV      r0,#0
                  |L1.2772|
000ad4  e28dd028          ADD      sp,sp,#0x28
;;;333    
;;;334    	/* ext_tags may be NULL */
;;;335    	if (!ext_tags)
;;;336    		return YAFFS_OK;
;;;337    
;;;338    	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
;;;339    
;;;340    	ext_tags->is_deleted = deleted;
;;;341    	ext_tags->ecc_result = ecc_result;
;;;342    	ext_tags->block_bad = 0;	/* We're reading it */
;;;343    	/* therefore it is not a bad block */
;;;344    	ext_tags->chunk_used =
;;;345    		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
;;;346    
;;;347    	if (ext_tags->chunk_used) {
;;;348    		yaffs_get_tags_from_spare(dev, &spare, &tags);
;;;349    		ext_tags->obj_id = tags.obj_id;
;;;350    		ext_tags->chunk_id = tags.chunk_id;
;;;351    		ext_tags->n_bytes = tags.n_bytes_lsb;
;;;352    
;;;353    		if (dev->data_bytes_per_chunk >= 1024)
;;;354    			ext_tags->n_bytes |=
;;;355    				(((unsigned)tags.n_bytes_msb) << 10);
;;;356    
;;;357    		ext_tags->serial_number = tags.serial_number;
;;;358    	}
;;;359    
;;;360    	return YAFFS_OK;
;;;361    }
000ad8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2780|
000adc  e3540000          CMP      r4,#0                 ;335
000ae0  1a000001          BNE      |L1.2796|
000ae4  e3a00001          MOV      r0,#1                 ;336
000ae8  eafffff9          B        |L1.2772|
                  |L1.2796|
000aec  e5dd001c          LDRB     r0,[sp,#0x1c]         ;338
000af0  ebfffffe          BL       generic_hweight8
000af4  e3500007          CMP      r0,#7                 ;338
000af8  2a000001          BCS      |L1.2820|
000afc  e3a00001          MOV      r0,#1                 ;338
000b00  ea000000          B        |L1.2824|
                  |L1.2820|
000b04  e3a00000          MOV      r0,#0                 ;338
                  |L1.2824|
000b08  e1a08000          MOV      r8,r0                 ;338
000b0c  e5848018          STR      r8,[r4,#0x18]         ;340
000b10  e5dd000c          LDRB     r0,[sp,#0xc]          ;341
000b14  e5c40010          STRB     r0,[r4,#0x10]         ;341
000b18  e3a00000          MOV      r0,#0                 ;342
000b1c  e5840014          STR      r0,[r4,#0x14]         ;342
000b20  e3a02010          MOV      r2,#0x10              ;344
000b24  e28d1018          ADD      r1,sp,#0x18           ;344
000b28  e59f00d0          LDR      r0,|L1.3072|
000b2c  ebfffffe          BL       memcmp
000b30  e3500000          CMP      r0,#0                 ;344
000b34  0a000001          BEQ      |L1.2880|
000b38  e3a00001          MOV      r0,#1                 ;345
000b3c  ea000000          B        |L1.2884|
                  |L1.2880|
000b40  e3a00000          MOV      r0,#0                 ;345
                  |L1.2884|
000b44  e5840000          STR      r0,[r4,#0]            ;345
000b48  e5940000          LDR      r0,[r4,#0]            ;347
000b4c  e3500000          CMP      r0,#0                 ;347
000b50  0a00001a          BEQ      |L1.3008|
000b54  e28d2010          ADD      r2,sp,#0x10           ;348
000b58  e28d1018          ADD      r1,sp,#0x18           ;348
000b5c  e1a00005          MOV      r0,r5                 ;348
000b60  ebfffffe          BL       yaffs_get_tags_from_spare
000b64  e59d0014          LDR      r0,[sp,#0x14]         ;349
000b68  e1a00700          LSL      r0,r0,#14             ;349
000b6c  e1a00720          LSR      r0,r0,#14             ;349
000b70  e5840004          STR      r0,[r4,#4]            ;349
000b74  e59d0010          LDR      r0,[sp,#0x10]         ;350
000b78  e1a00600          LSL      r0,r0,#12             ;350
000b7c  e1a00620          LSR      r0,r0,#12             ;350
000b80  e5840008          STR      r0,[r4,#8]            ;350
000b84  e59d0010          LDR      r0,[sp,#0x10]         ;351
000b88  e1a00b20          LSR      r0,r0,#22             ;351
000b8c  e584000c          STR      r0,[r4,#0xc]          ;351
000b90  e59500a4          LDR      r0,[r5,#0xa4]         ;353
000b94  e3500b01          CMP      r0,#0x400             ;353
000b98  ba000004          BLT      |L1.2992|
000b9c  e594000c          LDR      r0,[r4,#0xc]          ;354
000ba0  e59d1014          LDR      r1,[sp,#0x14]         ;354
000ba4  e1a01f21          LSR      r1,r1,#30             ;354
000ba8  e1800501          ORR      r0,r0,r1,LSL #10      ;354
000bac  e584000c          STR      r0,[r4,#0xc]          ;354
                  |L1.2992|
000bb0  e59d0010          LDR      r0,[sp,#0x10]         ;357
000bb4  e1a00500          LSL      r0,r0,#10             ;357
000bb8  e1a00f20          LSR      r0,r0,#30             ;357
000bbc  e584001c          STR      r0,[r4,#0x1c]         ;357
                  |L1.3008|
000bc0  e3a00001          MOV      r0,#1                 ;360
000bc4  eaffffc2          B        |L1.2772|
                  |L1.3016|
000bc8  79616666          DCB      "yaffs: **>>mtd ecc error unfixed on chunk %d:1\n",0
000bcc  733a202a
000bd0  2a3e3e6d
000bd4  74642065
000bd8  63632065
000bdc  72726f72
000be0  20756e66
000be4  69786564
000be8  206f6e20
000bec  6368756e
000bf0  6b202564
000bf4  3a310a00
                  |L1.3064|
                          DCD      0xffc00000
                  |L1.3068|
                          DCD      init
                  |L1.3072|
                          DCD      spare_ff
                          ENDP

                  yaffs_tags_compat_mark_bad PROC
;;;362    
;;;363    int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
000c04  e92d407f          PUSH     {r0-r6,lr}
;;;364    {
000c08  e1a04000          MOV      r4,r0
000c0c  e1a05001          MOV      r5,r1
;;;365    	struct yaffs_spare spare;
;;;366    
;;;367    	memset(&spare, 0xff, sizeof(struct yaffs_spare));
000c10  e3a020ff          MOV      r2,#0xff
000c14  e3a01010          MOV      r1,#0x10
000c18  e1a0000d          MOV      r0,sp
000c1c  ebfffffe          BL       __aeabi_memset
;;;368    
;;;369    	spare.block_status = 'Y';
000c20  e3a00059          MOV      r0,#0x59
000c24  e5cd0005          STRB     r0,[sp,#5]
;;;370    
;;;371    	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
000c28  e594000c          LDR      r0,[r4,#0xc]
000c2c  e0010590          MUL      r1,r0,r5
000c30  e1a0300d          MOV      r3,sp
000c34  e3a02000          MOV      r2,#0
000c38  e1a00004          MOV      r0,r4
000c3c  ebfffffe          BL       yaffs_wr_nand
;;;372    		      &spare);
;;;373    	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
000c40  e594000c          LDR      r0,[r4,#0xc]
000c44  e0000095          MUL      r0,r5,r0
000c48  e2801001          ADD      r1,r0,#1
000c4c  e1a0300d          MOV      r3,sp
000c50  e3a02000          MOV      r2,#0
000c54  e1a00004          MOV      r0,r4
000c58  ebfffffe          BL       yaffs_wr_nand
;;;374    		      NULL, &spare);
;;;375    
;;;376    	return YAFFS_OK;
000c5c  e3a00001          MOV      r0,#1
000c60  e28dd010          ADD      sp,sp,#0x10
;;;377    }
000c64  e8bd8070          POP      {r4-r6,pc}
;;;378    
                          ENDP

                  yaffs_tags_compat_query_block PROC
;;;379    int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
000c68  e92d40f0          PUSH     {r4-r7,lr}
;;;380    				  int block_no,
;;;381    				  enum yaffs_block_state *state,
;;;382    				  u32 *seq_number)
;;;383    {
000c6c  e24dd02c          SUB      sp,sp,#0x2c
000c70  e1a05000          MOV      r5,r0
000c74  e1a06001          MOV      r6,r1
000c78  e1a04002          MOV      r4,r2
000c7c  e1a07003          MOV      r7,r3
;;;384    	struct yaffs_spare spare0, spare1;
;;;385    	static struct yaffs_spare spare_ff;
;;;386    	static int init;
;;;387    	enum yaffs_ecc_result dummy;
;;;388    
;;;389    	if (!init) {
000c80  e59f00dc          LDR      r0,|L1.3428|
000c84  e5900000          LDR      r0,[r0,#0]  ; init
000c88  e3500000          CMP      r0,#0
000c8c  1a000006          BNE      |L1.3244|
;;;390    		memset(&spare_ff, 0xff, sizeof(spare_ff));
000c90  e3a020ff          MOV      r2,#0xff
000c94  e3a01010          MOV      r1,#0x10
000c98  e59f00c8          LDR      r0,|L1.3432|
000c9c  ebfffffe          BL       __aeabi_memset
;;;391    		init = 1;
000ca0  e3a00001          MOV      r0,#1
000ca4  e59f10b8          LDR      r1,|L1.3428|
000ca8  e5810000          STR      r0,[r1,#0]  ; init
                  |L1.3244|
;;;392    	}
;;;393    
;;;394    	*seq_number = 0;
000cac  e3a00000          MOV      r0,#0
000cb0  e5870000          STR      r0,[r7,#0]
;;;395    
;;;396    	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block, NULL,
000cb4  e3a00001          MOV      r0,#1
000cb8  e28d1008          ADD      r1,sp,#8
000cbc  e58d0004          STR      r0,[sp,#4]
000cc0  e58d1000          STR      r1,[sp,#0]
000cc4  e595000c          LDR      r0,[r5,#0xc]
000cc8  e0010690          MUL      r1,r0,r6
000ccc  e28d301c          ADD      r3,sp,#0x1c
000cd0  e3a02000          MOV      r2,#0
000cd4  e1a00005          MOV      r0,r5
000cd8  ebfffffe          BL       yaffs_rd_chunk_nand
;;;397    			    &spare0, &dummy, 1);
;;;398    	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
000cdc  e3a00001          MOV      r0,#1
000ce0  e28d1008          ADD      r1,sp,#8
000ce4  e58d0004          STR      r0,[sp,#4]
000ce8  e58d1000          STR      r1,[sp,#0]
000cec  e595000c          LDR      r0,[r5,#0xc]
000cf0  e0000096          MUL      r0,r6,r0
000cf4  e2801001          ADD      r1,r0,#1
000cf8  e28d300c          ADD      r3,sp,#0xc
000cfc  e3a02000          MOV      r2,#0
000d00  e1a00005          MOV      r0,r5
000d04  ebfffffe          BL       yaffs_rd_chunk_nand
;;;399    			    NULL, &spare1, &dummy, 1);
;;;400    
;;;401    	if (hweight8(spare0.block_status & spare1.block_status) < 7)
000d08  e5dd1021          LDRB     r1,[sp,#0x21]
000d0c  e5dd2011          LDRB     r2,[sp,#0x11]
000d10  e0010002          AND      r0,r1,r2
000d14  ebfffffe          BL       generic_hweight8
000d18  e3500007          CMP      r0,#7
000d1c  2a000002          BCS      |L1.3372|
;;;402    		*state = YAFFS_BLOCK_STATE_DEAD;
000d20  e3a00009          MOV      r0,#9
000d24  e5c40000          STRB     r0,[r4,#0]
000d28  ea00000a          B        |L1.3416|
                  |L1.3372|
;;;403    	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
000d2c  e3a02010          MOV      r2,#0x10
000d30  e28d101c          ADD      r1,sp,#0x1c
000d34  e59f002c          LDR      r0,|L1.3432|
000d38  ebfffffe          BL       memcmp
000d3c  e3500000          CMP      r0,#0
000d40  1a000002          BNE      |L1.3408|
;;;404    		*state = YAFFS_BLOCK_STATE_EMPTY;
000d44  e3a00003          MOV      r0,#3
000d48  e5c40000          STRB     r0,[r4,#0]
000d4c  ea000001          B        |L1.3416|
                  |L1.3408|
;;;405    	else
;;;406    		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
000d50  e3a00002          MOV      r0,#2
000d54  e5c40000          STRB     r0,[r4,#0]
                  |L1.3416|
;;;407    
;;;408    	return YAFFS_OK;
000d58  e3a00001          MOV      r0,#1
000d5c  e28dd02c          ADD      sp,sp,#0x2c
;;;409    }
000d60  e8bd80f0          POP      {r4-r7,pc}
                          ENDP

                  |L1.3428|
                          DCD      |symbol_number.17|
                  |L1.3432|
                          DCD      |symbol_number.15|

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  spare_ff
                          %        16
                  |symbol_number.15|
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  init
                          DCD      0x00000000
                  |symbol_number.17|
                          DCD      0x00000000
