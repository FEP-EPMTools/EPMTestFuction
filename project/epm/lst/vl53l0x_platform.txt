; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\vl53l0x_platform.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vl53l0x_platform.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\vl53l0x_platform.crf src\UserDrv\vl53l0x\platform\src\vl53l0x_platform.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  VL53L0X_LockSequenceAccess PROC
;;;98     
;;;99     VL53L0X_Error VL53L0X_LockSequenceAccess(VL53L0X_DEV Dev){
000000  e1a01000          MOV      r1,r0
;;;100        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000004  e3a00000          MOV      r0,#0
;;;101    
;;;102        return Status;
;;;103    }
000008  e12fff1e          BX       lr
;;;104    
                          ENDP

                  VL53L0X_UnlockSequenceAccess PROC
;;;105    VL53L0X_Error VL53L0X_UnlockSequenceAccess(VL53L0X_DEV Dev){
00000c  e1a01000          MOV      r1,r0
;;;106        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000010  e3a00000          MOV      r0,#0
;;;107    
;;;108        return Status;
;;;109    }
000014  e12fff1e          BX       lr
;;;110    
                          ENDP

                  VL53L0X_WriteMulti PROC
;;;111    // the ranging_sensor_comms.dll will take care of the page selection
;;;112    VL53L0X_Error VL53L0X_WriteMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata, uint32_t count){
000018  e92d47f0          PUSH     {r4-r10,lr}
00001c  e1a04000          MOV      r4,r0
000020  e1a07001          MOV      r7,r1
000024  e1a08002          MOV      r8,r2
000028  e1a05003          MOV      r5,r3
;;;113    
;;;114        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00002c  e3a09000          MOV      r9,#0
;;;115        int32_t status_int = 0;
000030  e3a0a000          MOV      r10,#0
;;;116    	uint8_t deviceAddress;
;;;117    
;;;118        if (count>=VL53L0X_MAX_I2C_XFER_SIZE){
000034  e3550040          CMP      r5,#0x40
000038  3a000000          BCC      |L1.64|
;;;119            Status = VL53L0X_ERROR_INVALID_PARAMS;
00003c  e3e09003          MVN      r9,#3
                  |L1.64|
;;;120        }
;;;121    
;;;122    	deviceAddress = Dev->I2cDevAddr;
000040  e5d4615c          LDRB     r6,[r4,#0x15c]
;;;123    
;;;124    	status_int = VL53L0X_write_multi(deviceAddress, index, pdata, count);
000044  e1a03005          MOV      r3,r5
000048  e1a02008          MOV      r2,r8
00004c  e1a01007          MOV      r1,r7
000050  e1a00006          MOV      r0,r6
000054  ebfffffe          BL       VL53L0X_write_multi
000058  e1a0a000          MOV      r10,r0
;;;125    
;;;126    	if (status_int != 0)
00005c  e35a0000          CMP      r10,#0
000060  0a000000          BEQ      |L1.104|
;;;127    		Status = VL53L0X_ERROR_CONTROL_INTERFACE;
000064  e3e09013          MVN      r9,#0x13
                  |L1.104|
;;;128    
;;;129        return Status;
000068  e1a00009          MOV      r0,r9
;;;130    }
00006c  e8bd87f0          POP      {r4-r10,pc}
;;;131    
                          ENDP

                  VL53L0X_ReadMulti PROC
;;;132    // the ranging_sensor_comms.dll will take care of the page selection
;;;133    VL53L0X_Error VL53L0X_ReadMulti(VL53L0X_DEV Dev, uint8_t index, uint8_t *pdata, uint32_t count){
000070  e92d47f0          PUSH     {r4-r10,lr}
000074  e1a05000          MOV      r5,r0
000078  e1a08001          MOV      r8,r1
00007c  e1a09002          MOV      r9,r2
000080  e1a06003          MOV      r6,r3
;;;134        VL53L0X_I2C_USER_VAR
;;;135        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000084  e3a0a000          MOV      r10,#0
;;;136        int32_t status_int;
;;;137    	uint8_t deviceAddress;
;;;138    
;;;139        if (count>=VL53L0X_MAX_I2C_XFER_SIZE){
000088  e3560040          CMP      r6,#0x40
00008c  3a000000          BCC      |L1.148|
;;;140            Status = VL53L0X_ERROR_INVALID_PARAMS;
000090  e3e0a003          MVN      r10,#3
                  |L1.148|
;;;141        }
;;;142    
;;;143        deviceAddress = Dev->I2cDevAddr;
000094  e5d5715c          LDRB     r7,[r5,#0x15c]
;;;144    
;;;145    	status_int = VL53L0X_read_multi(deviceAddress, index, pdata, count);
000098  e1a03006          MOV      r3,r6
00009c  e1a02009          MOV      r2,r9
0000a0  e1a01008          MOV      r1,r8
0000a4  e1a00007          MOV      r0,r7
0000a8  ebfffffe          BL       VL53L0X_read_multi
0000ac  e1a04000          MOV      r4,r0
;;;146    
;;;147    	if (status_int != 0)
0000b0  e3540000          CMP      r4,#0
0000b4  0a000000          BEQ      |L1.188|
;;;148    		Status = VL53L0X_ERROR_CONTROL_INTERFACE;
0000b8  e3e0a013          MVN      r10,#0x13
                  |L1.188|
;;;149    
;;;150        return Status;
0000bc  e1a0000a          MOV      r0,r10
;;;151    }
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;152    
                          ENDP

                  VL53L0X_WrByte PROC
;;;153    
;;;154    VL53L0X_Error VL53L0X_WrByte(VL53L0X_DEV Dev, uint8_t index, uint8_t data){
0000c4  e92d47f0          PUSH     {r4-r10,lr}
0000c8  e1a04000          MOV      r4,r0
0000cc  e1a05001          MOV      r5,r1
0000d0  e1a06002          MOV      r6,r2
;;;155        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0000d4  e3a07000          MOV      r7,#0
;;;156        int32_t status_int;
;;;157    	uint8_t deviceAddress;
;;;158    
;;;159        deviceAddress = Dev->I2cDevAddr;
0000d8  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;160    
;;;161    	status_int = VL53L0X_write_byte(deviceAddress, index, data);
0000dc  e1a02006          MOV      r2,r6
0000e0  e1a01005          MOV      r1,r5
0000e4  e1a00009          MOV      r0,r9
0000e8  ebfffffe          BL       VL53L0X_write_byte
0000ec  e1a08000          MOV      r8,r0
;;;162    
;;;163    	if (status_int != 0)
0000f0  e3580000          CMP      r8,#0
0000f4  0a000000          BEQ      |L1.252|
;;;164    		Status = VL53L0X_ERROR_CONTROL_INTERFACE;
0000f8  e3e07013          MVN      r7,#0x13
                  |L1.252|
;;;165    
;;;166        return Status;
0000fc  e1a00007          MOV      r0,r7
;;;167    }
000100  e8bd87f0          POP      {r4-r10,pc}
;;;168    
                          ENDP

                  VL53L0X_WrWord PROC
;;;169    VL53L0X_Error VL53L0X_WrWord(VL53L0X_DEV Dev, uint8_t index, uint16_t data){
000104  e92d47f0          PUSH     {r4-r10,lr}
000108  e1a04000          MOV      r4,r0
00010c  e1a05001          MOV      r5,r1
000110  e1a06002          MOV      r6,r2
;;;170        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000114  e3a07000          MOV      r7,#0
;;;171        int32_t status_int;
;;;172    	uint8_t deviceAddress;
;;;173    
;;;174        deviceAddress = Dev->I2cDevAddr;
000118  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;175    
;;;176    	status_int = VL53L0X_write_word(deviceAddress, index, data);
00011c  e1a02006          MOV      r2,r6
000120  e1a01005          MOV      r1,r5
000124  e1a00009          MOV      r0,r9
000128  ebfffffe          BL       VL53L0X_write_word
00012c  e1a08000          MOV      r8,r0
;;;177    
;;;178    	if (status_int != 0)
000130  e3580000          CMP      r8,#0
000134  0a000000          BEQ      |L1.316|
;;;179    		Status = VL53L0X_ERROR_CONTROL_INTERFACE;
000138  e3e07013          MVN      r7,#0x13
                  |L1.316|
;;;180    
;;;181        return Status;
00013c  e1a00007          MOV      r0,r7
;;;182    }
000140  e8bd87f0          POP      {r4-r10,pc}
;;;183    
                          ENDP

                  VL53L0X_WrDWord PROC
;;;184    VL53L0X_Error VL53L0X_WrDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t data){
000144  e92d47f0          PUSH     {r4-r10,lr}
000148  e1a04000          MOV      r4,r0
00014c  e1a05001          MOV      r5,r1
000150  e1a06002          MOV      r6,r2
;;;185        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000154  e3a07000          MOV      r7,#0
;;;186        int32_t status_int;
;;;187    	uint8_t deviceAddress;
;;;188    
;;;189        deviceAddress = Dev->I2cDevAddr;
000158  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;190    
;;;191    	status_int = VL53L0X_write_dword(deviceAddress, index, data);
00015c  e1a02006          MOV      r2,r6
000160  e1a01005          MOV      r1,r5
000164  e1a00009          MOV      r0,r9
000168  ebfffffe          BL       VL53L0X_write_dword
00016c  e1a08000          MOV      r8,r0
;;;192    
;;;193    	if (status_int != 0)
000170  e3580000          CMP      r8,#0
000174  0a000000          BEQ      |L1.380|
;;;194    		Status = VL53L0X_ERROR_CONTROL_INTERFACE;
000178  e3e07013          MVN      r7,#0x13
                  |L1.380|
;;;195    
;;;196        return Status;
00017c  e1a00007          MOV      r0,r7
;;;197    }
000180  e8bd87f0          POP      {r4-r10,pc}
;;;198    
                          ENDP

                  VL53L0X_UpdateByte PROC
;;;199    VL53L0X_Error VL53L0X_UpdateByte(VL53L0X_DEV Dev, uint8_t index, uint8_t AndData, uint8_t OrData){
000184  e92d4ff8          PUSH     {r3-r11,lr}
000188  e1a04000          MOV      r4,r0
00018c  e1a09001          MOV      r9,r1
000190  e1a05002          MOV      r5,r2
000194  e1a06003          MOV      r6,r3
;;;200        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000198  e3a07000          MOV      r7,#0
;;;201        int32_t status_int;
;;;202        uint8_t deviceAddress;
;;;203        uint8_t data;
;;;204    
;;;205        deviceAddress = Dev->I2cDevAddr;
00019c  e5d4a15c          LDRB     r10,[r4,#0x15c]
;;;206    
;;;207        status_int = VL53L0X_read_byte(deviceAddress, index, &data);
0001a0  e1a0200d          MOV      r2,sp
0001a4  e1a01009          MOV      r1,r9
0001a8  e1a0000a          MOV      r0,r10
0001ac  ebfffffe          BL       VL53L0X_read_byte
0001b0  e1a08000          MOV      r8,r0
;;;208    
;;;209        if (status_int != 0)
0001b4  e3580000          CMP      r8,#0
0001b8  0a000000          BEQ      |L1.448|
;;;210            Status = VL53L0X_ERROR_CONTROL_INTERFACE;
0001bc  e3e07013          MVN      r7,#0x13
                  |L1.448|
;;;211    
;;;212        if (Status == VL53L0X_ERROR_NONE) {
0001c0  e3570000          CMP      r7,#0
0001c4  1a00000b          BNE      |L1.504|
;;;213            data = (data & AndData) | OrData;
0001c8  e5dd0000          LDRB     r0,[sp,#0]
0001cc  e0000005          AND      r0,r0,r5
0001d0  e1800006          ORR      r0,r0,r6
0001d4  e58d0000          STR      r0,[sp,#0]
;;;214            status_int = VL53L0X_write_byte(deviceAddress, index, data);
0001d8  e5dd2000          LDRB     r2,[sp,#0]
0001dc  e1a01009          MOV      r1,r9
0001e0  e1a0000a          MOV      r0,r10
0001e4  ebfffffe          BL       VL53L0X_write_byte
0001e8  e1a08000          MOV      r8,r0
;;;215    
;;;216            if (status_int != 0)
0001ec  e3580000          CMP      r8,#0
0001f0  0a000000          BEQ      |L1.504|
;;;217                Status = VL53L0X_ERROR_CONTROL_INTERFACE;
0001f4  e3e07013          MVN      r7,#0x13
                  |L1.504|
;;;218        }
;;;219    
;;;220        return Status;
0001f8  e1a00007          MOV      r0,r7
;;;221    }
0001fc  e8bd8ff8          POP      {r3-r11,pc}
;;;222    
                          ENDP

                  VL53L0X_RdByte PROC
;;;223    VL53L0X_Error VL53L0X_RdByte(VL53L0X_DEV Dev, uint8_t index, uint8_t *data){
000200  e92d47f0          PUSH     {r4-r10,lr}
000204  e1a04000          MOV      r4,r0
000208  e1a05001          MOV      r5,r1
00020c  e1a06002          MOV      r6,r2
;;;224        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000210  e3a07000          MOV      r7,#0
;;;225        int32_t status_int;
;;;226        uint8_t deviceAddress;
;;;227    
;;;228        deviceAddress = Dev->I2cDevAddr;
000214  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;229    
;;;230        status_int = VL53L0X_read_byte(deviceAddress, index, data);
000218  e1a02006          MOV      r2,r6
00021c  e1a01005          MOV      r1,r5
000220  e1a00009          MOV      r0,r9
000224  ebfffffe          BL       VL53L0X_read_byte
000228  e1a08000          MOV      r8,r0
;;;231    
;;;232        if (status_int != 0)
00022c  e3580000          CMP      r8,#0
000230  0a000000          BEQ      |L1.568|
;;;233            Status = VL53L0X_ERROR_CONTROL_INTERFACE;
000234  e3e07013          MVN      r7,#0x13
                  |L1.568|
;;;234    
;;;235        return Status;
000238  e1a00007          MOV      r0,r7
;;;236    }
00023c  e8bd87f0          POP      {r4-r10,pc}
;;;237    
                          ENDP

                  VL53L0X_RdWord PROC
;;;238    VL53L0X_Error VL53L0X_RdWord(VL53L0X_DEV Dev, uint8_t index, uint16_t *data){
000240  e92d47f0          PUSH     {r4-r10,lr}
000244  e1a04000          MOV      r4,r0
000248  e1a05001          MOV      r5,r1
00024c  e1a06002          MOV      r6,r2
;;;239        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000250  e3a07000          MOV      r7,#0
;;;240        int32_t status_int;
;;;241        uint8_t deviceAddress;
;;;242    
;;;243        deviceAddress = Dev->I2cDevAddr;
000254  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;244    
;;;245        status_int = VL53L0X_read_word(deviceAddress, index, data);
000258  e1a02006          MOV      r2,r6
00025c  e1a01005          MOV      r1,r5
000260  e1a00009          MOV      r0,r9
000264  ebfffffe          BL       VL53L0X_read_word
000268  e1a08000          MOV      r8,r0
;;;246    
;;;247        if (status_int != 0)
00026c  e3580000          CMP      r8,#0
000270  0a000000          BEQ      |L1.632|
;;;248            Status = VL53L0X_ERROR_CONTROL_INTERFACE;
000274  e3e07013          MVN      r7,#0x13
                  |L1.632|
;;;249    
;;;250        return Status;
000278  e1a00007          MOV      r0,r7
;;;251    }
00027c  e8bd87f0          POP      {r4-r10,pc}
;;;252    
                          ENDP

                  VL53L0X_RdDWord PROC
;;;253    VL53L0X_Error  VL53L0X_RdDWord(VL53L0X_DEV Dev, uint8_t index, uint32_t *data){
000280  e92d47f0          PUSH     {r4-r10,lr}
000284  e1a04000          MOV      r4,r0
000288  e1a05001          MOV      r5,r1
00028c  e1a06002          MOV      r6,r2
;;;254        VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000290  e3a07000          MOV      r7,#0
;;;255        int32_t status_int;
;;;256        uint8_t deviceAddress;
;;;257    
;;;258        deviceAddress = Dev->I2cDevAddr;
000294  e5d4915c          LDRB     r9,[r4,#0x15c]
;;;259    
;;;260        status_int = VL53L0X_read_dword(deviceAddress, index, data);
000298  e1a02006          MOV      r2,r6
00029c  e1a01005          MOV      r1,r5
0002a0  e1a00009          MOV      r0,r9
0002a4  ebfffffe          BL       VL53L0X_read_dword
0002a8  e1a08000          MOV      r8,r0
;;;261    
;;;262        if (status_int != 0)
0002ac  e3580000          CMP      r8,#0
0002b0  0a000000          BEQ      |L1.696|
;;;263            Status = VL53L0X_ERROR_CONTROL_INTERFACE;
0002b4  e3e07013          MVN      r7,#0x13
                  |L1.696|
;;;264    
;;;265        return Status;
0002b8  e1a00007          MOV      r0,r7
;;;266    }
0002bc  e8bd87f0          POP      {r4-r10,pc}
;;;267    
                          ENDP

                  VL53L0X_PollingDelay PROC
;;;269    void sysDelay(UINT32 uTicks);
;;;270    VL53L0X_Error VL53L0X_PollingDelay(VL53L0X_DEV Dev){
0002c0  e92d4038          PUSH     {r3-r5,lr}
0002c4  e1a05000          MOV      r5,r0
;;;271        VL53L0X_Error status = VL53L0X_ERROR_NONE;
0002c8  e3a04000          MOV      r4,#0
;;;272        volatile uint32_t i;
;;;273        LOG_FUNCTION_START("");
;;;274    
;;;275        for(i=0;i<VL53L0X_POLLINGDELAY_LOOPNB;i++){
0002cc  e3a00000          MOV      r0,#0
0002d0  e58d0000          STR      r0,[sp,#0]
0002d4  ea000004          B        |L1.748|
                  |L1.728|
;;;276            #if(FREERTOS_USE_1000MHZ)
;;;277            vTaskDelay(1/portTICK_RATE_MS); 
;;;278            #else
;;;279            //#error
;;;280            vTaskDelay(10/portTICK_RATE_MS); 
0002d8  e3a00001          MOV      r0,#1
0002dc  ebfffffe          BL       vTaskDelay
0002e0  e59d0000          LDR      r0,[sp,#0]            ;275
0002e4  e2800001          ADD      r0,r0,#1              ;275
0002e8  e58d0000          STR      r0,[sp,#0]            ;275
                  |L1.748|
0002ec  e59d0000          LDR      r0,[sp,#0]            ;275
0002f0  e35000fa          CMP      r0,#0xfa              ;275
0002f4  3afffff7          BCC      |L1.728|
;;;281            #endif        
;;;282        }
;;;283    
;;;284        LOG_FUNCTION_END(status);
;;;285        return status;
0002f8  e1a00004          MOV      r0,r4
;;;286    }
0002fc  e8bd8038          POP      {r3-r5,pc}
                          ENDP

