L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c"
N/*
N *  drivers/mtd/nand_bbt.c
N *
N *  Overview:
N *   Bad block table support for the NAND driver
N *
N *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N * Description:
N *
N * When nand_scan_bbt is called, then it tries to find the bad block table
N * depending on the options in the BBT descriptor(s). If no flash based BBT
N * (NAND_USE_FLASH_BBT) is specified then the device is scanned for factory
N * marked good / bad blocks. This information is used to create a memory BBT.
N * Once a new bad block is discovered then the "factory" information is updated
N * on the device.
N * If a flash based BBT is specified then the function first tries to find the
N * BBT on flash. If a BBT is found then the contents are read and the memory
N * based BBT is created. If a mirrored BBT is selected then the mirror is
N * searched too and the versions are compared. If the mirror has a greater
N * version number than the mirror BBT is used to build the memory based BBT.
N * If the tables are not versioned, then we "or" the bad block information.
N * If one of the BBTs is out of date or does not exist it is (re)created.
N * If no BBT exists at all then the device is scanned for factory marked
N * good / bad blocks and the bad block tables are created.
N *
N * For manufacturer created BBTs like the one found on M-SYS DOC devices
N * the BBT is searched and read but never created
N *
N * The auto generated bad block table is located in the last good blocks
N * of the device. The table is mirrored, so it can be updated eventually.
N * The table is marked in the OOB area with an ident pattern and a version
N * number which indicates which of both tables is more up to date. If the NAND
N * controller needs the complete OOB area for the ECC information then the
N * option NAND_USE_FLASH_BBT_NO_OOB should be used: it moves the ident pattern
N * and the version byte into the data area and the OOB area will remain
N * untouched.
N *
N * The table uses 2 bits per block
N * 11b:		block is good
N * 00b:		block is factory marked bad
N * 01b, 10b:	block is marked bad due to wear
N *
N * The memory bad block table uses the following scheme:
N * 00b:		block is good
N * 01b:		block is marked bad due to wear
N * 10b:		block is reserved (to protect the bbt area)
N * 11b:		block is factory marked bad
N *
N * Multichip devices like DOC store the bad block info per floor.
N *
N * Following assumptions are made:
N * - bbts start at a page boundary, if autolocated on a block boundary
N * - the space necessary for a bbt in FLASH does not exceed a block boundary
N *
N */
N
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 63 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "common.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\common.h" 1
N/*
N * (C) Copyright 2000-2009
N * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
N *
N * See file CREDITS for list of people who contributed to this
N * project.
N *
N * This program is free software; you can redistribute it and/or
N * modify it under the terms of the GNU General Public License as
N * published by the Free Software Foundation; either version 2 of
N * the License, or (at your option) any later version.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
N * MA 02111-1307 USA
N */
N#if 0
S
S#ifndef __COMMON_H_
S#define __COMMON_H_	1
S
S#undef	_LINUX_CONFIG_H
S#define _LINUX_CONFIG_H 1	/* avoid reading Linux autoconf.h file	*/
S
S#ifndef __ASSEMBLY__		/* put C only stuff in this section */
S
Stypedef unsigned char		uchar;
Stypedef volatile unsigned long	vu_long;
Stypedef volatile unsigned short vu_short;
Stypedef volatile unsigned char	vu_char;
S
S#include "config.h"
S//#include <asm-offsets.h>
S#include <linux/bitops.h>
S#include <linux/types.h>
S#include <linux/string.h>
S#include <linux/stringify.h>
S#include <asm/ptrace.h>
S#include <stdarg.h>
S#if defined(CONFIG_PCI) && defined(CONFIG_4xx)
S#include <pci.h>
S#endif
S#if defined(CONFIG_8xx)
S#include <asm/8xx_immap.h>
S#if defined(CONFIG_MPC852)	|| defined(CONFIG_MPC852T)	|| \
S    defined(CONFIG_MPC859)	|| defined(CONFIG_MPC859T)	|| \
S    defined(CONFIG_MPC859DSL)	|| \
S    defined(CONFIG_MPC866)	|| defined(CONFIG_MPC866T)	|| \
S    defined(CONFIG_MPC866P)
X#if defined(CONFIG_MPC852)	|| defined(CONFIG_MPC852T)	||     defined(CONFIG_MPC859)	|| defined(CONFIG_MPC859T)	||     defined(CONFIG_MPC859DSL)	||     defined(CONFIG_MPC866)	|| defined(CONFIG_MPC866T)	||     defined(CONFIG_MPC866P)
S# define CONFIG_MPC866_FAMILY 1
S#elif defined(CONFIG_MPC870) \
S   || defined(CONFIG_MPC875) \
S   || defined(CONFIG_MPC880) \
S   || defined(CONFIG_MPC885)
X#elif defined(CONFIG_MPC870)    || defined(CONFIG_MPC875)    || defined(CONFIG_MPC880)    || defined(CONFIG_MPC885)
S# define CONFIG_MPC885_FAMILY   1
S#endif
S#if   defined(CONFIG_MPC860)	   \
S   || defined(CONFIG_MPC860T)	   \
S   || defined(CONFIG_MPC866_FAMILY) \
S   || defined(CONFIG_MPC885_FAMILY)
X#if   defined(CONFIG_MPC860)	      || defined(CONFIG_MPC860T)	      || defined(CONFIG_MPC866_FAMILY)    || defined(CONFIG_MPC885_FAMILY)
S# define CONFIG_MPC86x 1
S#endif
S#elif defined(CONFIG_5xx)
S#include <asm/5xx_immap.h>
S#elif defined(CONFIG_MPC5xxx)
S#include <mpc5xxx.h>
S#elif defined(CONFIG_MPC512X)
S#include <asm/immap_512x.h>
S#elif defined(CONFIG_MPC8220)
S#include <asm/immap_8220.h>
S#elif defined(CONFIG_8260)
S#if   defined(CONFIG_MPC8247) \
S   || defined(CONFIG_MPC8248) \
S   || defined(CONFIG_MPC8271) \
S   || defined(CONFIG_MPC8272)
X#if   defined(CONFIG_MPC8247)    || defined(CONFIG_MPC8248)    || defined(CONFIG_MPC8271)    || defined(CONFIG_MPC8272)
S#define CONFIG_MPC8272_FAMILY	1
S#endif
S#if defined(CONFIG_MPC8272_FAMILY)
S#define CONFIG_MPC8260	1
S#endif
S#include <asm/immap_8260.h>
S#endif
S#ifdef CONFIG_MPC86xx
S#include <mpc86xx.h>
S#include <asm/immap_86xx.h>
S#endif
S#ifdef CONFIG_MPC85xx
S#include <mpc85xx.h>
S#include <asm/immap_85xx.h>
S#endif
S#ifdef CONFIG_MPC83xx
S#include <mpc83xx.h>
S#include <asm/immap_83xx.h>
S#endif
S#ifdef	CONFIG_4xx
S#include <asm/ppc4xx.h>
S#endif
S#ifdef CONFIG_HYMOD
S#include <board/hymod/hymod.h>
S#endif
S#ifdef CONFIG_ARM
S#define asmlinkage	/* nothing */
S#endif
S#ifdef CONFIG_BLACKFIN
S#include <asm/blackfin.h>
S#endif
S#ifdef CONFIG_SOC_DA8XX
S#include <asm/arch/hardware.h>
S#endif
S
S#include "part.h"
S#include "flash.h"
S#include "image.h"
S
S#ifdef DEBUG
S#define _DEBUG	1
S#else
S#define _DEBUG	0
S#endif
S
S/*
S * Output a debug text when condition "cond" is met. The "cond" should be
S * computed by a preprocessor in the best case, allowing for the best
S * optimization.
S */
S#define debug_cond(cond, fmt, args...)		\
S	do {					\
S		if (cond)			\
S			sysprintf(fmt, ##args);	\
S	} while (0)
X#define debug_cond(cond, fmt, args...)			do {							if (cond)						sysprintf(fmt, ##args);		} while (0)
S
S#define debug(fmt, args...)			\
S	debug_cond(_DEBUG, fmt, ##args)
X#define debug(fmt, args...)				debug_cond(_DEBUG, fmt, ##args)
S
S/*
S * An assertion is run-time check done in debug mode only. If DEBUG is not
S * defined then it is skipped. If DEBUG is defined and the assertion fails,
S * then it calls panic*( which may or may not reset/halt U-Boot (see
S * CONFIG_PANIC_HANG), It is hoped that all failing assertions are found
S * before release, and after release it is hoped that they don't matter. But
S * in any case these failing assertions cannot be fixed with a reset (which
S * may just do the same assertion again).
S */
Svoid __assert_fail(const char *assertion, const char *file, unsigned line,
S		   const char *function);
S#define assert(x) \
S	({ if (!(x) && _DEBUG) \
S		__assert_fail(#x, __FILE__, __LINE__, __func__); })
X#define assert(x) 	({ if (!(x) && _DEBUG) 		__assert_fail(#x, __FILE__, __LINE__, __func__); })
S
S#define error(fmt, args...) do {					\
S		sysprintf("ERROR: " fmt "\nat %s:%d/%s()\n",		\
S			##args, __FILE__, __LINE__, __func__);		\
S} while (0)
X#define error(fmt, args...) do {							sysprintf("ERROR: " fmt "\nat %s:%d/%s()\n",					##args, __FILE__, __LINE__, __func__);		} while (0)
S
S#ifndef BUG
S#define BUG() do { \
S	sysprintf("BUG: failure at %s:%d/%s()!\n", __FILE__, __LINE__, __FUNCTION__); \
S	panic("BUG!"); \
S} while (0)
X#define BUG() do { 	sysprintf("BUG: failure at %s:%d/%s()!\n", __FILE__, __LINE__, __FUNCTION__); 	panic("BUG!"); } while (0)
S#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
S#endif /* BUG */
S
S/* Force a compilation error if condition is true */
S#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
S
Stypedef void (interrupt_handler_t)(void *);
S
S#include <asm/u-boot.h> /* boot information for Linux kernel */
S#include <asm/global_data.h>	/* global data used for startup functions */
S
S/*
S * enable common handling for all TQM8xxL/M boards:
S * - CONFIG_TQM8xxM will be defined for all TQM8xxM boards
S * - CONFIG_TQM8xxL will be defined for all TQM8xxL _and_ TQM8xxM boards
S *                  and for the TQM885D board
S */
S#if defined(CONFIG_TQM823M) || defined(CONFIG_TQM850M) || \
S    defined(CONFIG_TQM855M) || defined(CONFIG_TQM860M) || \
S    defined(CONFIG_TQM862M) || defined(CONFIG_TQM866M)
X#if defined(CONFIG_TQM823M) || defined(CONFIG_TQM850M) ||     defined(CONFIG_TQM855M) || defined(CONFIG_TQM860M) ||     defined(CONFIG_TQM862M) || defined(CONFIG_TQM866M)
S# ifndef CONFIG_TQM8xxM
S#  define CONFIG_TQM8xxM
S# endif
S#endif
S#if defined(CONFIG_TQM823L) || defined(CONFIG_TQM850L) || \
S    defined(CONFIG_TQM855L) || defined(CONFIG_TQM860L) || \
S    defined(CONFIG_TQM862L) || defined(CONFIG_TQM8xxM) || \
S    defined(CONFIG_TQM885D)
X#if defined(CONFIG_TQM823L) || defined(CONFIG_TQM850L) ||     defined(CONFIG_TQM855L) || defined(CONFIG_TQM860L) ||     defined(CONFIG_TQM862L) || defined(CONFIG_TQM8xxM) ||     defined(CONFIG_TQM885D)
S# ifndef CONFIG_TQM8xxL
S#  define CONFIG_TQM8xxL
S# endif
S#endif
S
S/*
S * General Purpose Utilities
S */
S#define min(X, Y)				\
S	({ typeof (X) __x = (X);		\
S		typeof (Y) __y = (Y);		\
S		(__x < __y) ? __x : __y; })
X#define min(X, Y)					({ typeof (X) __x = (X);				typeof (Y) __y = (Y);				(__x < __y) ? __x : __y; })
S
S#define max(X, Y)				\
S	({ typeof (X) __x = (X);		\
S		typeof (Y) __y = (Y);		\
S		(__x > __y) ? __x : __y; })
X#define max(X, Y)					({ typeof (X) __x = (X);				typeof (Y) __y = (Y);				(__x > __y) ? __x : __y; })
S
S#define MIN(x, y)  min(x, y)
S#define MAX(x, y)  max(x, y)
S
S/*
S * Return the absolute value of a number.
S *
S * This handles unsigned and signed longs, ints, shorts and chars.  For all
S * input types abs() returns a signed long.
S *
S * For 64-bit types, use abs64()
S */
S#define abs(x) ({						\
S		long ret;					\
S		if (sizeof(x) == sizeof(long)) {		\
S			long __x = (x);				\
S			ret = (__x < 0) ? -__x : __x;		\
S		} else {					\
S			int __x = (x);				\
S			ret = (__x < 0) ? -__x : __x;		\
S		}						\
S		ret;						\
S	})
X#define abs(x) ({								long ret;							if (sizeof(x) == sizeof(long)) {					long __x = (x);							ret = (__x < 0) ? -__x : __x;				} else {								int __x = (x);							ret = (__x < 0) ? -__x : __x;				}								ret;							})
S
S#define abs64(x) ({				\
S		s64 __x = (x);			\
S		(__x < 0) ? -__x : __x;		\
S	})
X#define abs64(x) ({						s64 __x = (x);					(__x < 0) ? -__x : __x;			})
S
S#if defined(CONFIG_ENV_IS_EMBEDDED)
S#define TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
S#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) < CONFIG_SYS_MONITOR_BASE) || \
S	(CONFIG_ENV_ADDR >= (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)) ) || \
S      defined(CONFIG_ENV_IS_IN_NVRAM)
X#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) < CONFIG_SYS_MONITOR_BASE) || 	(CONFIG_ENV_ADDR >= (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)) ) ||       defined(CONFIG_ENV_IS_IN_NVRAM)
S#define	TOTAL_MALLOC_LEN	(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)
S#else
S#define	TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
S#endif
S
S/**
S * container_of - cast a member of a structure out to the containing structure
S * @ptr:	the pointer to the member.
S * @type:	the type of the container struct this is embedded in.
S * @member:	the name of the member within the struct.
S *
S */
S#define container_of(ptr, type, member) ({			\
S	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
S	(type *)( (char *)__mptr - offsetof(type,member) );})
X#define container_of(ptr, type, member) ({				const typeof( ((type *)0)->member ) *__mptr = (ptr);		(type *)( (char *)__mptr - offsetof(type,member) );})
S
S/*
S * Function Prototypes
S */
S
Svoid	hang		(void) __attribute__ ((noreturn));
S
Sint	timer_init(void);
Sint	cpu_init(void);
S
S/* */
S// phys_size_t initdram (int);
Sint	display_options (void);
Svoid	print_size(unsigned long long, const char *);
Sint print_buffer(ulong addr, const void *data, uint width, uint count,
S		 uint linelen);
S
S/* common/main.c */
Svoid	main_loop	(void);
Sint run_command(const char *cmd, int flag);
S
S/**
S * Run a list of commands separated by ; or even \0
S *
S * Note that if 'len' is not -1, then the command does not need to be nul
S * terminated, Memory will be allocated for the command in that case.
S *
S * @param cmd	List of commands to run, each separated bu semicolon
S * @param len	Length of commands excluding terminator if known (-1 if not)
S * @param flag	Execution flags (CMD_FLAG_...)
S * @return 0 on success, or != 0 on error.
S */
Sint run_command_list(const char *cmd, int len, int flag);
Sint	readline	(const char *const prompt);
Sint	readline_into_buffer(const char *const prompt, char *buffer,
S			int timeout);
Sint	parse_line (char *, char *[]);
Svoid	init_cmd_timeout(void);
Svoid	reset_cmd_timeout(void);
S#ifdef CONFIG_MENU
Sint	abortboot(int bootdelay);
S#endif
Sextern char console_buffer[];
S
S/* arch/$(ARCH)/lib/board.c */
S// void	board_init_f(ulong);
S// void	board_init_r  (gd_t *, ulong) __attribute__ ((noreturn));
S// int	checkboard    (void);
S// int	checkflash    (void);
S// int	checkdram     (void);
S// int	last_stage_init(void);
S// extern ulong monitor_flash_len;
S// int mac_read_from_eeprom(void);
S// extern u8 _binary_dt_dtb_start[];	/* embedded device tree blob */
S// int set_cpu_clk_info(void);
S// int print_cpuinfo(void);
S// int update_flash_size(int flash_size);
S
S/**
S * Show the DRAM size in a board-specific way
S *
S * This is used by boards to display DRAM information in their own way.
S *
S * @param size	Size of DRAM (which should be displayed along with other info)
S */
Svoid board_show_dram(ulong size);
S
S/* common/flash.c */
Svoid flash_perror (int);
S
S/* common/cmd_source.c */
Sint	source (ulong addr, const char *fit_uname);
S
Sextern ulong load_addr;		/* Default Load Address */
Sextern ulong save_addr;		/* Default Save Address */
Sextern ulong save_size;		/* Default Save Size */
S
S/* common/cmd_doc.c */
S// void	doc_probe(unsigned long physadr);
S
S/* common/cmd_net.c */
S// int do_tftpb(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
S
S/* common/cmd_fat.c */
S// int do_fat_fsload(cmd_tbl_t *, int, int, char * const []);
S
S/* common/cmd_ext2.c */
S// int do_ext2load(cmd_tbl_t *, int, int, char * const []);
S
S/* common/cmd_nvedit.c */
S// int	env_init     (void);
S// void	env_relocate (void);
S// int	envmatch     (uchar *, int);
S// char	*getenv	     (const char *);
S// int	getenv_f     (const char *name, char *buf, unsigned len);
S// ulong getenv_ulong(const char *name, int base, ulong default_val);
S/*
S * Read an environment variable as a boolean
S * Return -1 if variable does not exist (default to true)
S */
Sint getenv_yesno(const char *var);
Sint	saveenv	     (void);
Sint	setenv	     (const char *, const char *);
Sint setenv_ulong(const char *varname, ulong value);
Sint setenv_hex(const char *varname, ulong value);
S/**
S * setenv_addr - Set an environment variable to an address in hex
S *
S * @varname:	Environmet variable to set
S * @addr:	Value to set it to
S * @return 0 if ok, 1 on error
S */
Sstatic __inline int setenv_addr(const char *varname, const void *addr)
S{
S	return setenv_hex(varname, (ulong)addr);
S}
S
S#ifdef CONFIG_ARM
S# include <asm/mach-types.h>
S# include <asm/setup.h>
S# include <asm/u-boot-arm.h>	/* ARM version to be fixed! */
S#endif /* CONFIG_ARM */
S#ifdef CONFIG_X86		/* x86 version to be fixed! */
S# include <asm/u-boot-x86.h>
S#endif /* CONFIG_X86 */
S#ifdef CONFIG_SANDBOX
S# include <asm/u-boot-sandbox.h>	/* TODO(sjg) what needs to be fixed? */
S#endif
S#ifdef CONFIG_NDS32
S# include <asm/mach-types.h>
S# include <asm/u-boot-nds32.h>
S#endif /* CONFIG_NDS32 */
S#ifdef CONFIG_MIPS
S# include <asm/u-boot-mips.h>
S#endif /* CONFIG_MIPS */
S
S#ifdef CONFIG_AUTO_COMPLETE
Sint env_complete(char *var, int maxv, char *cmdv[], int maxsz, char *buf);
S#endif
Sint get_env_id (void);
S
Svoid	pci_init      (void);
Svoid	pci_init_board(void);
Svoid	pciinfo	      (int, int);
S
S#if defined(CONFIG_PCI) && defined(CONFIG_4xx)
S    int	   pci_pre_init	       (struct pci_controller *);
S    int	   is_pci_host	       (struct pci_controller *);
S#endif
S
S#if defined(CONFIG_PCI) && (defined(CONFIG_440) || defined(CONFIG_405EX))
S#   if defined(CONFIG_SYS_PCI_TARGET_INIT)
S	void	pci_target_init	     (struct pci_controller *);
S#   endif
S#   if defined(CONFIG_SYS_PCI_MASTER_INIT)
S	void	pci_master_init	     (struct pci_controller *);
S#   endif
S#if defined(CONFIG_440SPE) || \
S    defined(CONFIG_460EX) || defined(CONFIG_460GT) || \
S    defined(CONFIG_405EX)
X#if defined(CONFIG_440SPE) ||     defined(CONFIG_460EX) || defined(CONFIG_460GT) ||     defined(CONFIG_405EX)
S   void pcie_setup_hoses(int busno);
S#endif
S#endif
S
Sint	misc_init_f   (void);
Sint	misc_init_r   (void);
S
S/* common/exports.c */
Svoid	jumptable_init(void);
S
S/* common/kallsysm.c */
Sconst char *symbol_lookup(unsigned long addr, unsigned long *caddr);
S
S/* api/api.c */
Svoid	api_init (void);
S
S/* common/memsize.c */
Slong	get_ram_size  (long *, long);
S
S/* $(BOARD)/$(BOARD).c */
Svoid	reset_phy     (void);
Svoid	fdc_hw_init   (void);
S
S/* $(BOARD)/eeprom.c */
Svoid eeprom_init  (void);
S#ifndef CONFIG_SPI
Sint  eeprom_probe (unsigned dev_addr, unsigned offset);
S#endif
Sint  eeprom_read  (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt);
Sint  eeprom_write (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt);
S#ifdef CONFIG_LWMON
Sextern uchar pic_read  (uchar reg);
Sextern void  pic_write (uchar reg, uchar val);
S#endif
S
S/*
S * Set this up regardless of board
S * type, to prevent errors.
S */
S#if defined(CONFIG_SPI) || !defined(CONFIG_SYS_I2C_EEPROM_ADDR)
S# define CONFIG_SYS_DEF_EEPROM_ADDR 0
S#else
S#if !defined(CONFIG_ENV_EEPROM_IS_ON_I2C)
S# define CONFIG_SYS_DEF_EEPROM_ADDR CONFIG_SYS_I2C_EEPROM_ADDR
S#endif
S#endif /* CONFIG_SPI || !defined(CONFIG_SYS_I2C_EEPROM_ADDR) */
S
S#if defined(CONFIG_SPI)
Sextern void spi_init_f (void);
Sextern void spi_init_r (void);
Sextern ssize_t spi_read	 (uchar *, int, uchar *, int);
Sextern ssize_t spi_write (uchar *, int, uchar *, int);
S#endif
S
S#ifdef CONFIG_RPXCLASSIC
Svoid rpxclassic_init (void);
S#endif
S
Svoid rpxlite_init (void);
S
S#ifdef CONFIG_MBX
S/* $(BOARD)/mbx8xx.c */
Svoid	mbx_init (void);
Svoid	board_serial_init (void);
Svoid	board_ether_init (void);
S#endif
S
S#ifdef CONFIG_HERMES
S/* $(BOARD)/hermes.c */
Svoid hermes_start_lxt980 (int speed);
S#endif
S
S#ifdef CONFIG_EVB64260
Svoid  evb64260_init(void);
Svoid  debug_led(int, int);
Svoid  display_mem_map(void);
Svoid  perform_soft_reset(void);
S#endif
S
S/* $(BOARD)/$(BOARD).c */
Sint board_early_init_f (void);
Sint board_late_init (void);
Sint board_postclk_init (void); /* after clocks/timebase, before env/serial */
Sint board_early_init_r (void);
Svoid board_poweroff (void);
S
S#if defined(CONFIG_SYS_DRAM_TEST)
Sint testdram(void);
S#endif /* CONFIG_SYS_DRAM_TEST */
S
S/* $(CPU)/start.S */
S#if defined(CONFIG_5xx) || \
S    defined(CONFIG_8xx)
X#if defined(CONFIG_5xx) ||     defined(CONFIG_8xx)
Suint	get_immr      (uint);
S#endif
Suint	get_pir	      (void);
S#if defined(CONFIG_MPC5xxx)
Suint	get_svr       (void);
S#endif
Suint	get_pvr	      (void);
Suint	get_svr	      (void);
Suint	rd_ic_cst     (void);
Svoid	wr_ic_cst     (uint);
Svoid	wr_ic_adr     (uint);
Suint	rd_dc_cst     (void);
Svoid	wr_dc_cst     (uint);
Svoid	wr_dc_adr     (uint);
Sint	icache_status (void);
Svoid	icache_enable (void);
Svoid	icache_disable(void);
Sint	dcache_status (void);
Svoid	dcache_enable (void);
Svoid	dcache_disable(void);
Svoid	mmu_disable(void);
Svoid	relocate_code (ulong, gd_t *, ulong) __attribute__ ((noreturn));
Sulong	get_endaddr   (void);
Svoid	trap_init     (ulong);
S#if defined (CONFIG_4xx)	|| \
S    defined (CONFIG_MPC5xxx)	|| \
S    defined (CONFIG_74xx_7xx)	|| \
S    defined (CONFIG_74x)	|| \
S    defined (CONFIG_75x)	|| \
S    defined (CONFIG_74xx)	|| \
S    defined (CONFIG_MPC8220)	|| \
S    defined (CONFIG_MPC85xx)	|| \
S    defined (CONFIG_MPC86xx)	|| \
S    defined (CONFIG_MPC83xx)
X#if defined (CONFIG_4xx)	||     defined (CONFIG_MPC5xxx)	||     defined (CONFIG_74xx_7xx)	||     defined (CONFIG_74x)	||     defined (CONFIG_75x)	||     defined (CONFIG_74xx)	||     defined (CONFIG_MPC8220)	||     defined (CONFIG_MPC85xx)	||     defined (CONFIG_MPC86xx)	||     defined (CONFIG_MPC83xx)
Sunsigned char	in8(unsigned int);
Svoid		out8(unsigned int, unsigned char);
Sunsigned short	in16(unsigned int);
Sunsigned short	in16r(unsigned int);
Svoid		out16(unsigned int, unsigned short value);
Svoid		out16r(unsigned int, unsigned short value);
Sunsigned long	in32(unsigned int);
Sunsigned long	in32r(unsigned int);
Svoid		out32(unsigned int, unsigned long value);
Svoid		out32r(unsigned int, unsigned long value);
Svoid		ppcDcbf(unsigned long value);
Svoid		ppcDcbi(unsigned long value);
Svoid		ppcSync(void);
Svoid		ppcDcbz(unsigned long value);
S#endif
S#if defined (CONFIG_MICROBLAZE)
Sunsigned short	in16(unsigned int);
Svoid		out16(unsigned int, unsigned short value);
S#endif
S
S#if defined (CONFIG_MPC83xx)
Svoid		ppcDWload(unsigned int *addr, unsigned int *ret);
Svoid		ppcDWstore(unsigned int *addr, unsigned int *value);
Svoid disable_addr_trans(void);
Svoid enable_addr_trans(void);
S#if defined(CONFIG_DDR_ECC) && !defined(CONFIG_ECC_INIT_VIA_DDRCONTROLLER)
Svoid ddr_enable_ecc(unsigned int dram_size);
S#endif
S#endif
S
S/* $(CPU)/cpu.c */
Sstatic __inline int cpumask_next(int cpu, unsigned int mask)
S{
S	for (cpu++; !((1 << cpu) & mask); cpu++)
S		;
S
S	return cpu;
S}
S
S#define for_each_cpu(iter, cpu, num_cpus, mask) \
S	for (iter = 0, cpu = cpumask_next(-1, mask); \
S		iter < num_cpus; \
S		iter++, cpu = cpumask_next(cpu, mask)) \
S
X#define for_each_cpu(iter, cpu, num_cpus, mask) 	for (iter = 0, cpu = cpumask_next(-1, mask); 		iter < num_cpus; 		iter++, cpu = cpumask_next(cpu, mask)) 
Sint	cpu_numcores  (void);
Su32	cpu_mask      (void);
Sint	is_core_valid (unsigned int);
Sint	probecpu      (void);
Sint	checkcpu      (void);
Sint	checkicache   (void);
Sint	checkdcache   (void);
Svoid	upmconfig     (unsigned int, unsigned int *, unsigned int);
Sulong	get_tbclk     (void);
Svoid	reset_cpu     (ulong addr);
S#if defined (CONFIG_OF_LIBFDT) && defined (CONFIG_OF_BOARD_SETUP)
Svoid ft_cpu_setup(void *blob, bd_t *bd);
S#ifdef CONFIG_PCI
Svoid ft_pci_setup(void *blob, bd_t *bd);
S#endif
S#endif
S
S
S/* $(CPU)/serial.c */
Sint	serial_init   (void);
Svoid	serial_setbrg (void);
Svoid	serial_putc   (const char);
Svoid	serial_putc_raw(const char);
Svoid	serial_puts   (const char *);
Sint	serial_getc   (void);
Sint	serial_tstc   (void);
S
Svoid	_serial_setbrg (const int);
Svoid	_serial_putc   (const char, const int);
Svoid	_serial_putc_raw(const char, const int);
Svoid	_serial_puts   (const char *, const int);
Sint	_serial_getc   (const int);
Sint	_serial_tstc   (const int);
S
S/* $(CPU)/speed.c */
Sint	get_clocks (void);
Sint	get_clocks_866 (void);
Sint	sdram_adjust_866 (void);
Sint	adjust_sdram_tbs_8xx (void);
S#if defined(CONFIG_8260)
Sint	prt_8260_clks (void);
S#elif defined(CONFIG_MPC5xxx)
Sint	prt_mpc5xxx_clks (void);
S#endif
S#if defined(CONFIG_MPC512X)
Sint	prt_mpc512xxx_clks (void);
S#endif
S#if defined(CONFIG_MPC8220)
Sint	prt_mpc8220_clks (void);
S#endif
S#ifdef CONFIG_4xx
Sulong	get_OPB_freq (void);
Sulong	get_PCI_freq (void);
S#endif
S#if defined(CONFIG_S3C24X0) || \
S    defined(CONFIG_LH7A40X) || \
S    defined(CONFIG_S3C6400) || \
S    defined(CONFIG_EP93XX)
X#if defined(CONFIG_S3C24X0) ||     defined(CONFIG_LH7A40X) ||     defined(CONFIG_S3C6400) ||     defined(CONFIG_EP93XX)
Sulong	get_FCLK (void);
Sulong	get_HCLK (void);
Sulong	get_PCLK (void);
Sulong	get_UCLK (void);
S#endif
S#if defined(CONFIG_LH7A40X)
Sulong	get_PLLCLK (void);
S#endif
S#if defined CONFIG_INCA_IP
Suint	incaip_get_cpuclk (void);
S#endif
S#if defined(CONFIG_IMX)
Sulong get_systemPLLCLK(void);
Sulong get_FCLK(void);
Sulong get_HCLK(void);
Sulong get_BCLK(void);
Sulong get_PERCLK1(void);
Sulong get_PERCLK2(void);
Sulong get_PERCLK3(void);
S#endif
Sulong	get_bus_freq  (ulong);
Sint get_serial_clock(void);
S
S#if defined(CONFIG_MPC83xx) || defined(CONFIG_MPC85xx)
Sulong get_ddr_freq(ulong);
S#endif
S#if defined(CONFIG_MPC85xx)
Stypedef MPC85xx_SYS_INFO sys_info_t;
Svoid	get_sys_info  ( sys_info_t * );
S#endif
S#if defined(CONFIG_MPC86xx)
Stypedef MPC86xx_SYS_INFO sys_info_t;
Svoid   get_sys_info  ( sys_info_t * );
Sstatic __inline ulong get_ddr_freq(ulong dummy)
S{
S	return get_bus_freq(dummy);
S}
S#endif
S
S#if defined(CONFIG_4xx)
S#  if defined(CONFIG_440)
S#	if defined(CONFIG_440SPE)
S	 unsigned long determine_sysper(void);
S	 unsigned long determine_pci_clock_per(void);
S#	endif
S#  endif
Stypedef PPC4xx_SYS_INFO sys_info_t;
Sint	ppc440spe_revB(void);
Svoid	get_sys_info  ( sys_info_t * );
S#endif
S
S/* $(CPU)/cpu_init.c */
S#if defined(CONFIG_8xx) || defined(CONFIG_8260)
Svoid	cpu_init_f    (volatile immap_t *immr);
S#endif
S#if defined(CONFIG_4xx) || defined(CONFIG_MPC85xx) || defined(CONFIG_MCF52x2) ||defined(CONFIG_MPC86xx)
Svoid	cpu_init_f    (void);
S#endif
S
Sint	cpu_init_r    (void);
S#if defined(CONFIG_8260)
Sint	prt_8260_rsr  (void);
S#elif defined(CONFIG_MPC83xx)
Sint	prt_83xx_rsr  (void);
S#endif
S
S/* $(CPU)/interrupts.c */
Sint	interrupt_init	   (void);
Svoid	timer_interrupt	   (struct pt_regs *);
Svoid	external_interrupt (struct pt_regs *);
Svoid	irq_install_handler(int, interrupt_handler_t *, void *);
Svoid	irq_free_handler   (int);
Svoid	reset_timer	   (void);
Sulong	get_timer	   (ulong base);
Svoid	enable_interrupts  (void);
Sint	disable_interrupts (void);
S
S/* $(CPU)/.../commproc.c */
Sint	dpram_init (void);
Suint	dpram_base(void);
Suint	dpram_base_align(uint align);
Suint	dpram_alloc(uint size);
Suint	dpram_alloc_align(uint size,uint align);
Svoid	bootcount_store (ulong);
Sulong	bootcount_load (void);
S#define BOOTCOUNT_MAGIC		0xB001C041
S
S/* $(CPU)/.../<eth> */
Svoid mii_init (void);
S
S/* $(CPU)/.../lcd.c */
Sulong	lcd_setmem (ulong);
S
S/* $(CPU)/.../video.c */
Sulong	video_setmem (ulong);
S
S/* arch/$(ARCH)/lib/cache.c */
Svoid	enable_caches(void);
Svoid	flush_cache   (unsigned long, unsigned long);
Svoid	flush_dcache_all(void);
Svoid	flush_dcache_range(unsigned long start, unsigned long stop);
Svoid	invalidate_dcache_range(unsigned long start, unsigned long stop);
Svoid	invalidate_dcache_all(void);
Svoid	invalidate_icache_all(void);
S
S/* arch/$(ARCH)/lib/ticks.S */
Sunsigned long long get_ticks(void);
Svoid	wait_ticks    (unsigned long);
S
S/* arch/$(ARCH)/lib/time.c */
Svoid	__udelay      (unsigned long);
Sulong	usec2ticks    (unsigned long usec);
Sulong	ticks2usec    (unsigned long ticks);
Sint	init_timebase (void);
S
S/* lib/gunzip.c */
Sint gunzip(void *, int, unsigned char *, unsigned long *);
Sint zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
S						int stoponerr, int offset);
S
S/* lib/qsort.c */
Svoid qsort(void *base, size_t nmemb, size_t size,
S	   int(*compar)(const void *, const void *));
Sint strcmp_compar(const void *, const void *);
S
S/* lib/time.c */
Svoid	udelay        (unsigned long);
Svoid mdelay(unsigned long);
S
S/* lib/uuid.c */
Svoid uuid_str_to_bin(const char *uuid, unsigned char *out);
Sint uuid_str_valid(const char *uuid);
S
S/* lib/vsprintf.c */
S#include "vsprintf.h"
S
S/* lib/strmhz.c */
Schar *	strmhz(char *buf, unsigned long hz);
S
S/* lib/crc32.c */
S#include "crc.h"
S
S/* lib/rand.c */
S#if defined(CONFIG_RANDOM_MACADDR) || \
S	defined(CONFIG_BOOTP_RANDOM_DELAY) || \
S	defined(CONFIG_CMD_LINK_LOCAL)
X#if defined(CONFIG_RANDOM_MACADDR) || 	defined(CONFIG_BOOTP_RANDOM_DELAY) || 	defined(CONFIG_CMD_LINK_LOCAL)
S#define RAND_MAX -1U
Svoid srand(unsigned int seed);
Sunsigned int rand(void);
Sunsigned int rand_r(unsigned int *seedp);
S#endif
S
S/* common/console.c */
Sint	console_init_f(void);	/* Before relocation; uses the serial  stuff	*/
Sint	console_init_r(void);	/* After  relocation; uses the console stuff	*/
Sint	console_assign(int file, const char *devname);	/* Assign the console	*/
Sint	ctrlc (void);
Sint	had_ctrlc (void);	/* have we had a Control-C since last clear? */
Svoid	clear_ctrlc (void);	/* clear the Control-C condition */
Sint	disable_ctrlc (int);	/* 1 to disable, 0 to enable Control-C detect */
S
S/*
S * STDIO based functions (can always be used)
S */
S/* serial stuff */
Sint	serial_printf (const char *fmt, ...)
S		__attribute__ ((format (__printf__, 1, 2)));
S/* stdin */
S// int	getc(void);
S// int	tstc(void);
S
S/* stdout */
S// void	putc(const char c);
S// void	puts(const char *s);
S// int	printf(const char *fmt, ...)
S// 		__attribute__ ((format (__printf__, 1, 2)));
Sint	vprintf(const char *fmt, va_list args);
S
S/* stderr */
S#define eputc(c)		fputc(stderr, c)
S#define eputs(s)		fputs(stderr, s)
S#define eprintf(fmt,args...)	fprintf(stderr,fmt ,##args)
S
S/*
S * FILE based functions (can only be used AFTER relocation!)
S */
S#define stdin		0
S#define stdout		1
S#define stderr		2
S#define MAX_FILES	3
S
Sint	fprintf(int file, const char *fmt, ...)
S		__attribute__ ((format (__printf__, 2, 3)));
Svoid	fputs(int file, const char *s);
Svoid	fputc(int file, const char c);
Sint	ftstc(int file);
Sint	fgetc(int file);
S
S/* lib/gzip.c */
Sint gzip(void *dst, unsigned long *lenp,
S		unsigned char *src, unsigned long srclen);
Sint zzip(void *dst, unsigned long *lenp, unsigned char *src,
S		unsigned long srclen, int stoponerr,
S		int (*func)(unsigned long, unsigned long));
S
S/* lib/net_utils.c */
S// #include <net.h>
S// static __inline IPaddr_t getenv_IPaddr(char *var)
S// {
S// 	return string_to_ip(getenv(var));
S// }
S
S/*
S * CONSOLE multiplexing.
S */
S#ifdef CONFIG_CONSOLE_MUX
S#include <iomux.h>
S#endif
S
Sint	pcmcia_init (void);
S
S#ifdef CONFIG_STATUS_LED
S# include <status_led.h>
S#endif
S
S#include "bootstage.h"
S
S#ifdef CONFIG_SHOW_ACTIVITY
Svoid show_activity(int arg);
S#endif
S
S/* Multicore arch functions */
S#ifdef CONFIG_MP
Sint cpu_status(int nr);
Sint cpu_reset(int nr);
Sint cpu_disable(int nr);
Sint cpu_release(int nr, int argc, char * const argv[]);
S#endif
S
S/* Define a null map_sysmem() if the architecture doesn't use it */
S# ifndef CONFIG_ARCH_MAP_SYSMEM
Sstatic __inline void *map_sysmem(phys_addr_t paddr, unsigned long len)
S{
S	return (void *)(uintptr_t)paddr;
S}
S
Sstatic __inline void unmap_sysmem(const void *vaddr)
S{
S}
S# endif
S
S#endif /* __ASSEMBLY__ */
S
S#ifdef CONFIG_PPC
S/*
S * Has to be included outside of the #ifndef __ASSEMBLY__ section.
S * Otherwise might lead to compilation errors in assembler files.
S */
S#include <asm/cache.h>
S#endif
S
S/* Put only stuff here that the assembler can digest */
S
S#ifdef CONFIG_POST
S#define CONFIG_HAS_POST
S#ifndef CONFIG_POST_ALT_LIST
S#define CONFIG_POST_STD_LIST
S#endif
S#endif
S
S#ifdef CONFIG_INIT_CRITICAL
S#error CONFIG_INIT_CRITICAL is deprecated!
S#error Read section CONFIG_SKIP_LOWLEVEL_INIT in README.
S#endif
S
S#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
S
S#define ROUND(a,b)		(((a) + (b) - 1) & ~((b) - 1))
S#define DIV_ROUND(n,d)		(((n) + ((d)/2)) / (d))
S#define DIV_ROUND_UP(n,d)	(((n) + (d) - 1) / (d))
S#define roundup(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
S
S#define ALIGN(x,a)		__ALIGN_MASK((x),(typeof(x))(a)-1)
S#define __ALIGN_MASK(x,mask)	(((x)+(mask))&~(mask))
S
S/*
S * ARCH_DMA_MINALIGN is defined in asm/cache.h for each architecture.  It
S * is used to align DMA buffers.
S */
S#ifndef __ASSEMBLY__
S#include "asm/cache.h"
S#endif
S
S/*
S * The ALLOC_CACHE_ALIGN_BUFFER macro is used to allocate a buffer on the
S * stack that meets the minimum architecture alignment requirements for DMA.
S * Such a buffer is useful for DMA operations where flushing and invalidating
S * the cache before and after a read and/or write operation is required for
S * correct operations.
S *
S * When called the macro creates an array on the stack that is sized such
S * that:
S *
S * 1) The beginning of the array can be advanced enough to be aligned.
S *
S * 2) The size of the aligned portion of the array is a multiple of the minimum
S *    architecture alignment required for DMA.
S *
S * 3) The aligned portion contains enough space for the original number of
S *    elements requested.
S *
S * The macro then creates a pointer to the aligned portion of this array and
S * assigns to the pointer the address of the first element in the aligned
S * portion of the array.
S *
S * Calling the macro as:
S *
S *     ALLOC_CACHE_ALIGN_BUFFER(uint32_t, buffer, 1024);
S *
S * Will result in something similar to saying:
S *
S *     uint32_t    buffer[1024];
S *
S * The following differences exist:
S *
S * 1) The resulting buffer is guaranteed to be aligned to the value of
S *    ARCH_DMA_MINALIGN.
S *
S * 2) The buffer variable created by the macro is a pointer to the specified
S *    type, and NOT an array of the specified type.  This can be very important
S *    if you want the address of the buffer, which you probably do, to pass it
S *    to the DMA hardware.  The value of &buffer is different in the two cases.
S *    In the macro case it will be the address of the pointer, not the address
S *    of the space reserved for the buffer.  However, in the second case it
S *    would be the address of the buffer.  So if you are replacing hard coded
S *    stack buffers with this macro you need to make sure you remove the & from
S *    the locations where you are taking the address of the buffer.
S *
S * Note that the size parameter is the number of array elements to allocate,
S * not the number of bytes.
S *
S * This macro can not be used outside of function scope, or for the creation
S * of a function scoped static buffer.  It can not be used to create a cache
S * line aligned global buffer.
S */
S#define ALLOC_ALIGN_BUFFER(type, name, size, align)			\
S	char __##name[ROUND(size * sizeof(type), align) + (align - 1)];	\
S									\
S	type *name = (type *) ALIGN((uintptr_t)__##name, align)
X#define ALLOC_ALIGN_BUFFER(type, name, size, align)				char __##name[ROUND(size * sizeof(type), align) + (align - 1)];											type *name = (type *) ALIGN((uintptr_t)__##name, align)
S#define ALLOC_CACHE_ALIGN_BUFFER(type, name, size)			\
S	ALLOC_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)
X#define ALLOC_CACHE_ALIGN_BUFFER(type, name, size)				ALLOC_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)
S
S/*
S * DEFINE_CACHE_ALIGN_BUFFER() is similar to ALLOC_CACHE_ALIGN_BUFFER, but it's
S * purpose is to allow allocating aligned buffers outside of function scope.
S * Usage of this macro shall be avoided or used with extreme care!
S */
S#define DEFINE_ALIGN_BUFFER(type, name, size, align)			\
S	static char __##name[roundup(size * sizeof(type), align)]	\
S			__attribute__((aligned(align)));				\
S									\
S	static type *name = (type *)__##name
X#define DEFINE_ALIGN_BUFFER(type, name, size, align)				static char __##name[roundup(size * sizeof(type), align)]				__attribute__((aligned(align)));														static type *name = (type *)__##name
S#define DEFINE_CACHE_ALIGN_BUFFER(type, name, size)			\
S	DEFINE_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)
X#define DEFINE_CACHE_ALIGN_BUFFER(type, name, size)				DEFINE_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)
S
S/* Pull in stuff for the build system */
S#ifdef DO_DEPS_ONLY
S# include <environment.h>
S#endif
S
S#endif	/* __COMMON_H_ */
N#endif // if 0
L 64 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "malloc.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\malloc.h" 1
N/*
N  A version of malloc/free/realloc written by Doug Lea and released to the
N  public domain.  Send questions/comments/complaints/performance data
N  to dl@cs.oswego.edu
N
N* VERSION 2.6.6  Sun Mar  5 19:10:03 2000  Doug Lea  (dl at gee)
N
N   Note: There may be an updated version of this malloc obtainable at
N	   ftp://g.oswego.edu/pub/misc/malloc.c
N	 Check before installing!
N
N* Why use this malloc?
N
N  This is not the fastest, most space-conserving, most portable, or
N  most tunable malloc ever written. However it is among the fastest
N  while also being among the most space-conserving, portable and tunable.
N  Consistent balance across these factors results in a good general-purpose
N  allocator. For a high-level description, see
N     http://g.oswego.edu/dl/html/malloc.html
N
N* Synopsis of public routines
N
N  (Much fuller descriptions are contained in the program documentation below.)
N
N  malloc(size_t n);
N     Return a pointer to a newly allocated chunk of at least n bytes, or null
N     if no space is available.
N  free(Void_t* p);
N     Release the chunk of memory pointed to by p, or no effect if p is null.
N  realloc(Void_t* p, size_t n);
N     Return a pointer to a chunk of size n that contains the same data
N     as does chunk p up to the minimum of (n, p's size) bytes, or null
N     if no space is available. The returned pointer may or may not be
N     the same as p. If p is null, equivalent to malloc.  Unless the
N     #define REALLOC_ZERO_BYTES_FREES below is set, realloc with a
N     size argument of zero (re)allocates a minimum-sized chunk.
N  memalign(size_t alignment, size_t n);
N     Return a pointer to a newly allocated chunk of n bytes, aligned
N     in accord with the alignment argument, which must be a power of
N     two.
N  valloc(size_t n);
N     Equivalent to memalign(pagesize, n), where pagesize is the page
N     size of the system (or as near to this as can be figured out from
N     all the includes/defines below.)
N  pvalloc(size_t n);
N     Equivalent to valloc(minimum-page-that-holds(n)), that is,
N     round up n to nearest pagesize.
N  calloc(size_t unit, size_t quantity);
N     Returns a pointer to quantity * unit bytes, with all locations
N     set to zero.
N  cfree(Void_t* p);
N     Equivalent to free(p).
N  malloc_trim(size_t pad);
N     Release all but pad bytes of freed top-most memory back
N     to the system. Return 1 if successful, else 0.
N  malloc_usable_size(Void_t* p);
N     Report the number usable allocated bytes associated with allocated
N     chunk p. This may or may not report more bytes than were requested,
N     due to alignment and minimum size constraints.
N  malloc_stats();
N     Prints brief summary statistics on stderr.
N  mallinfo()
N     Returns (by copy) a struct containing various summary statistics.
N  mallopt(int parameter_number, int parameter_value)
N     Changes one of the tunable parameters described below. Returns
N     1 if successful in changing the parameter, else 0.
N
N* Vital statistics:
N
N  Alignment:                            8-byte
N       8 byte alignment is currently hardwired into the design.  This
N       seems to suffice for all current machines and C compilers.
N
N  Assumed pointer representation:       4 or 8 bytes
N       Code for 8-byte pointers is untested by me but has worked
N       reliably by Wolfram Gloger, who contributed most of the
N       changes supporting this.
N
N  Assumed size_t  representation:       4 or 8 bytes
N       Note that size_t is allowed to be 4 bytes even if pointers are 8.
N
N  Minimum overhead per allocated chunk: 4 or 8 bytes
N       Each malloced chunk has a hidden overhead of 4 bytes holding size
N       and status information.
N
N  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)
N			  8-byte ptrs:  24/32 bytes (including, 4/8 overhead)
N
N       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte
N       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are
N       needed; 4 (8) for a trailing size field
N       and 8 (16) bytes for free list pointers. Thus, the minimum
N       allocatable size is 16/24/32 bytes.
N
N       Even a request for zero bytes (i.e., malloc(0)) returns a
N       pointer to something of the minimum allocatable size.
N
N  Maximum allocated size: 4-byte size_t: 2^31 -  8 bytes
N			  8-byte size_t: 2^63 - 16 bytes
N
N       It is assumed that (possibly signed) size_t bit values suffice to
N       represent chunk sizes. `Possibly signed' is due to the fact
N       that `size_t' may be defined on a system as either a signed or
N       an unsigned type. To be conservative, values that would appear
N       as negative numbers are avoided.
N       Requests for sizes with a negative sign bit when the request
N       size is treaded as a long will return null.
N
N  Maximum overhead wastage per allocated chunk: normally 15 bytes
N
N       Alignnment demands, plus the minimum allocatable size restriction
N       make the normal worst-case wastage 15 bytes (i.e., up to 15
N       more bytes will be allocated than were requested in malloc), with
N       two exceptions:
N	 1. Because requests for zero bytes allocate non-zero space,
N	    the worst case wastage for a request of zero bytes is 24 bytes.
N	 2. For requests >= mmap_threshold that are serviced via
N	    mmap(), the worst case wastage is 8 bytes plus the remainder
N	    from a system page (the minimal mmap unit); typically 4096 bytes.
N
N* Limitations
N
N    Here are some features that are NOT currently supported
N
N    * No user-definable hooks for callbacks and the like.
N    * No automated mechanism for fully checking that all accesses
N      to malloced memory stay within their bounds.
N    * No support for compaction.
N
N* Synopsis of compile-time options:
N
N    People have reported using previous versions of this malloc on all
N    versions of Unix, sometimes by tweaking some of the defines
N    below. It has been tested most extensively on Solaris and
N    Linux. It is also reported to work on WIN32 platforms.
N    People have also reported adapting this malloc for use in
N    stand-alone embedded systems.
N
N    The implementation is in straight, hand-tuned ANSI C.  Among other
N    consequences, it uses a lot of macros.  Because of this, to be at
N    all usable, this code should be compiled using an optimizing compiler
N    (for example gcc -O2) that can simplify expressions and control
N    paths.
N
N  __STD_C                  (default: derived from C compiler defines)
N     Nonzero if using ANSI-standard C compiler, a C++ compiler, or
N     a C compiler sufficiently close to ANSI to get away with it.
N  DEBUG                    (default: NOT defined)
N     Define to enable debugging. Adds fairly extensive assertion-based
N     checking to help track down memory errors, but noticeably slows down
N     execution.
N  REALLOC_ZERO_BYTES_FREES (default: NOT defined)
N     Define this if you think that realloc(p, 0) should be equivalent
N     to free(p). Otherwise, since malloc returns a unique pointer for
N     malloc(0), so does realloc(p, 0).
N  HAVE_MEMCPY               (default: defined)
N     Define if you are not otherwise using ANSI STD C, but still
N     have memcpy and memset in your C library and want to use them.
N     Otherwise, simple internal versions are supplied.
N  USE_MEMCPY               (default: 1 if HAVE_MEMCPY is defined, 0 otherwise)
N     Define as 1 if you want the C library versions of memset and
N     memcpy called in realloc and calloc (otherwise macro versions are used).
N     At least on some platforms, the simple macro versions usually
N     outperform libc versions.
N  HAVE_MMAP                 (default: defined as 1)
N     Define to non-zero to optionally make malloc() use mmap() to
N     allocate very large blocks.
N  HAVE_MREMAP                 (default: defined as 0 unless Linux libc set)
N     Define to non-zero to optionally make realloc() use mremap() to
N     reallocate very large blocks.
N  malloc_getpagesize        (default: derived from system #includes)
N     Either a constant or routine call returning the system page size.
N  HAVE_USR_INCLUDE_MALLOC_H (default: NOT defined)
N     Optionally define if you are on a system with a /usr/include/malloc.h
N     that declares struct mallinfo. It is not at all necessary to
N     define this even if you do, but will ensure consistency.
N  INTERNAL_SIZE_T           (default: size_t)
N     Define to a 32-bit type (probably `unsigned int') if you are on a
N     64-bit machine, yet do not want or need to allow malloc requests of
N     greater than 2^31 to be handled. This saves space, especially for
N     very small chunks.
N  INTERNAL_LINUX_C_LIB      (default: NOT defined)
N     Defined only when compiled as part of Linux libc.
N     Also note that there is some odd internal name-mangling via defines
N     (for example, internally, `malloc' is named `mALLOc') needed
N     when compiling in this case. These look funny but don't otherwise
N     affect anything.
N  WIN32                     (default: undefined)
N     Define this on MS win (95, nt) platforms to compile in sbrk emulation.
N  LACKS_UNISTD_H            (default: undefined if not WIN32)
N     Define this if your system does not have a <unistd.h>.
N  LACKS_SYS_PARAM_H         (default: undefined if not WIN32)
N     Define this if your system does not have a <sys/param.h>.
N  MORECORE                  (default: sbrk)
N     The name of the routine to call to obtain more memory from the system.
N  MORECORE_FAILURE          (default: -1)
N     The value returned upon failure of MORECORE.
N  MORECORE_CLEARS           (default 1)
N     true (1) if the routine mapped to MORECORE zeroes out memory (which
N     holds for sbrk).
N  DEFAULT_TRIM_THRESHOLD
N  DEFAULT_TOP_PAD
N  DEFAULT_MMAP_THRESHOLD
N  DEFAULT_MMAP_MAX
N     Default values of tunable parameters (described in detail below)
N     controlling interaction with host system routines (sbrk, mmap, etc).
N     These values may also be changed dynamically via mallopt(). The
N     preset defaults are those that give best performance for typical
N     programs/systems.
N  USE_DL_PREFIX             (default: undefined)
N     Prefix all public routines with the string 'dl'.  Useful to
N     quickly avoid procedure declaration conflicts and linker symbol
N     conflicts with existing memory allocation routines.
N
N
N*/
N
N
N#ifndef __MALLOC_H__
N#define __MALLOC_H__
N
N/* Preliminaries */
N
N#ifndef __STD_C
N#ifdef __STDC__
N#define __STD_C     1
N#else
S#if __cplusplus
S#define __STD_C     1
S#else
S#define __STD_C     0
S#endif /*__cplusplus*/
N#endif /*__STDC__*/
N#endif /*__STD_C*/
N
N#ifndef Void_t
N#if (__STD_C || defined(WIN32))
X#if (1 || 0L)
N#define Void_t      void
N#else
S#define Void_t      char
N#endif
N#endif /*Void_t*/
N
N#if __STD_C
X#if 1
N#include <linux/stddef.h>	/* for size_t */
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/stddef.h" 1
N#ifndef _LINUX_STDDEF_H
N#define _LINUX_STDDEF_H
N
N#undef NULL
N#if defined(__cplusplus)
X#if 0L
S#define NULL 0
N#else
N#define NULL ((void *)0)
N#endif
N
N#ifndef _SIZE_T
N#include "linux\types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 1
N#ifndef _LINUX_TYPES_H
N#define _LINUX_TYPES_H
N
N#ifdef	__KERNEL__
S#include <linux/config.h>
N#endif
N
N#include "linux\posix_types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 1
N#ifndef _LINUX_POSIX_TYPES_H
N#define _LINUX_POSIX_TYPES_H
N
N#include <linux/stddef.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/stddef.h" 1
N#ifndef _LINUX_STDDEF_H
S#define _LINUX_STDDEF_H
S
S#undef NULL
S#if defined(__cplusplus)
S#define NULL 0
S#else
S#define NULL ((void *)0)
S#endif
S
S#ifndef _SIZE_T
S#include "linux\types.h"
S#endif
S
S#ifndef __CHECKER__
S#undef offsetof
S#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
S#endif
S
N#endif
L 5 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 2
N
N/*
N * This allows for 1024 file descriptors: if NR_OPEN is ever grown
N * beyond that you'll have to change this too. But 1024 fd's seem to be
N * enough even for such "real" unices like OSF/1, so hopefully this is
N * one limit that doesn't have to be changed [again].
N *
N * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
N * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
N * place for them. Solved by having dummy defines in <sys/time.h>.
N */
N
N/*
N * Those macros may have been defined in <gnu/types.h>. But we always
N * use the ones here.
N */
N#undef __NFDBITS
N#define __NFDBITS	(8 * sizeof(unsigned long))
N
N#undef __FD_SETSIZE
N#define __FD_SETSIZE	1024
N
N#undef __FDSET_LONGS
N#define __FDSET_LONGS	(__FD_SETSIZE/__NFDBITS)
N
N#undef __FDELT
N#define	__FDELT(d)	((d) / __NFDBITS)
N
N#undef __FDMASK
N#define	__FDMASK(d)	(1UL << ((d) % __NFDBITS))
N
Ntypedef struct {
N	unsigned long fds_bits [__FDSET_LONGS];
X	unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
N} __kernel_fd_set;
N
N/* Type of a signal handler.  */
Ntypedef void (*__kernel_sighandler_t)(int);
N
N/* Type of a SYSV IPC key.  */
Ntypedef int __kernel_key_t;
N
N#include <asm/posix_types.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm/posix_types.h" 1
N/*
N *  linux/include/asm-arm/posix_types.h
N *
N *  Copyright (C) 1996-1998 Russell King.
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N *  Changelog:
N *   27-06-1996	RMK	Created
N */
N#ifndef __ARCH_ARM_POSIX_TYPES_H
N#define __ARCH_ARM_POSIX_TYPES_H
N
N/*
N * This file is generally used by user-level software, so you need to
N * be a little careful about namespace pollution etc.  Also, we cannot
N * assume GCC is being used.
N */
N
Ntypedef unsigned short		__kernel_dev_t;
Ntypedef unsigned long		__kernel_ino_t;
Ntypedef unsigned short		__kernel_mode_t;
Ntypedef unsigned short		__kernel_nlink_t;
Ntypedef long			__kernel_off_t;
Ntypedef int			__kernel_pid_t;
Ntypedef unsigned short		__kernel_ipc_pid_t;
Ntypedef unsigned short		__kernel_uid_t;
Ntypedef unsigned short		__kernel_gid_t;
Ntypedef unsigned int		__kernel_size_t;
Ntypedef int			__kernel_ssize_t;
Ntypedef int			__kernel_ptrdiff_t;
Ntypedef long			__kernel_time_t;
Ntypedef long			__kernel_suseconds_t;
Ntypedef long			__kernel_clock_t;
Ntypedef int			__kernel_daddr_t;
Ntypedef char *			__kernel_caddr_t;
Ntypedef unsigned short		__kernel_uid16_t;
Ntypedef unsigned short		__kernel_gid16_t;
Ntypedef unsigned int		__kernel_uid32_t;
Ntypedef unsigned int		__kernel_gid32_t;
N
Ntypedef unsigned short		__kernel_old_uid_t;
Ntypedef unsigned short		__kernel_old_gid_t;
N
N#ifdef __GNUC__
Stypedef long long		__kernel_loff_t;
N#endif
N
Ntypedef struct {
N#if defined(__KERNEL__) || defined(__USE_ALL)
X#if 0L || 0L
S	int	val[2];
N#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
N	int	__val[2];
N#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
N} __kernel_fsid_t;
N
N#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
X#if 0L || !0L || (__GLIBC__ < 2)
N
N#undef	__FD_SET
N#define __FD_SET(fd, fdsetp) \
N		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
X#define __FD_SET(fd, fdsetp) 		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
N
N#undef	__FD_CLR
N#define __FD_CLR(fd, fdsetp) \
N		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
X#define __FD_CLR(fd, fdsetp) 		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
N
N#undef	__FD_ISSET
N#define __FD_ISSET(fd, fdsetp) \
N		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
X#define __FD_ISSET(fd, fdsetp) 		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
N
N#undef	__FD_ZERO
N#define __FD_ZERO(fdsetp) \
N		(memset (fdsetp, 0, sizeof (*(fd_set *)fdsetp)))
X#define __FD_ZERO(fdsetp) 		(memset (fdsetp, 0, sizeof (*(fd_set *)fdsetp)))
N
N#endif
N
N#endif
L 47 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\posix_types.h" 2
N
N#endif /* _LINUX_POSIX_TYPES_H */
L 9 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 2
N#include "asm\types.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm\types.h" 1
N#ifndef __ASM_ARM_TYPES_H
N#define __ASM_ARM_TYPES_H
N
Ntypedef unsigned short umode_t;
N
N/*
N * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
N * header files exported to user space
N */
N
Ntypedef char __s8;
Ntypedef unsigned char __u8;
N
Ntypedef short __s16;
Ntypedef unsigned short __u16;
N
Ntypedef int __s32;
Ntypedef unsigned int __u32;
N
Ntypedef long long __s64;
Ntypedef unsigned long long __u64;
N
N#if defined(__GNUC__)
X#if 0L
S__extension__ typedef __signed__ long long __s64;
S__extension__ typedef unsigned long long __u64;
N#endif
N
N/*
N * These aren't exported outside the kernel to avoid name space clashes
N */
N// #ifdef __KERNEL__
N
Ntypedef signed char s8;
Ntypedef unsigned char u8;
N
Ntypedef signed short s16;
Ntypedef unsigned short u16;
N
Ntypedef signed int s32;
Ntypedef unsigned int u32;
N
Ntypedef signed long long s64;
Ntypedef unsigned long long u64;
N
N#define BITS_PER_LONG 32
N
N/* Dma addresses are 32-bits wide.  */
N
Ntypedef u32 dma_addr_t;
N
Ntypedef unsigned long phys_addr_t;
Ntypedef unsigned long phys_size_t;
N
N// #endif /* __KERNEL__ */
N
N#endif
L 10 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\types.h" 2
N//#include "stdbool.h"
N
N#ifndef __KERNEL_STRICT_NAMES
N
Ntypedef __kernel_fd_set		fd_set;
Ntypedef __kernel_dev_t		dev_t;
Ntypedef __kernel_ino_t		ino_t;
Ntypedef __kernel_mode_t		mode_t;
Ntypedef __kernel_nlink_t	nlink_t;
Ntypedef __kernel_off_t		off_t;
Ntypedef __kernel_pid_t		pid_t;
Ntypedef __kernel_daddr_t	daddr_t;
Ntypedef __kernel_key_t		key_t;
Ntypedef __kernel_suseconds_t	suseconds_t;
N
N#ifdef __KERNEL__
Stypedef __kernel_uid32_t	uid_t;
Stypedef __kernel_gid32_t	gid_t;
Stypedef __kernel_uid16_t        uid16_t;
Stypedef __kernel_gid16_t        gid16_t;
S
S#ifdef CONFIG_UID16
S/* This is defined by include/asm-{arch}/posix_types.h */
Stypedef __kernel_old_uid_t	old_uid_t;
Stypedef __kernel_old_gid_t	old_gid_t;
S#endif /* CONFIG_UID16 */
S
S/* libc5 includes this file to define uid_t, thus uid_t can never change
S * when it is included by non-kernel code
S */
N#else
Ntypedef __kernel_uid_t		uid_t;
Ntypedef __kernel_gid_t		gid_t;
N#endif /* __KERNEL__ */
N
N#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
X#if 0L && !0L
Stypedef __kernel_loff_t		loff_t;
N#endif
Ntypedef long long		loff_t;
N
N/*
N * The following typedefs are also protected by individual ifdefs for
N * historical reasons:
N */
N#ifndef _SIZE_T
N#define _SIZE_T
Ntypedef __kernel_size_t		size_t;
N#endif
N
N#ifndef _SSIZE_T
N#define _SSIZE_T
Ntypedef __kernel_ssize_t	ssize_t;
N#endif
N
N#ifndef _PTRDIFF_T
N#define _PTRDIFF_T
Ntypedef __kernel_ptrdiff_t	ptrdiff_t;
N#endif
N
N#ifndef _TIME_T
N#define _TIME_T
Ntypedef __kernel_time_t		time_t;
N#endif
N
N#ifndef _CLOCK_T
N#define _CLOCK_T
Ntypedef __kernel_clock_t	clock_t;
N#endif
N
N#ifndef _CADDR_T
N#define _CADDR_T
Ntypedef __kernel_caddr_t	caddr_t;
N#endif
N
N/* bsd */
Ntypedef unsigned char		u_char;
Ntypedef unsigned short		u_short;
Ntypedef unsigned int		u_int;
Ntypedef unsigned long		u_long;
N
N/* sysv */
Ntypedef unsigned char		unchar;
Ntypedef unsigned short		ushort;
Ntypedef unsigned int		uint;
Ntypedef unsigned long		ulong;
N
N#ifndef __BIT_TYPES_DEFINED__
N#define __BIT_TYPES_DEFINED__
N
Ntypedef		__u8		u_int8_t;
N// typedef		__s8		int8_t;
Ntypedef		__u16		u_int16_t;
N// typedef		__s16		int16_t;
Ntypedef		__u32		u_int32_t;
N// typedef		__s32		int32_t;
N
N#endif /* !(__BIT_TYPES_DEFINED__) */
N
N// typedef		__u8		uint8_t;
N// typedef		__u16		uint16_t;
N// typedef		__u32		uint32_t;
N
N// #if defined(__GNUC__) && !defined(__STRICT_ANSI__)
Ntypedef		__u64		uint64_t;
Ntypedef		__u64		u_int64_t;
Ntypedef		__s64		int64_t;
N// #endif
N
N#endif /* __KERNEL_STRICT_NAMES */
N
N/*
N * Below are truly Linux-specific types that should never collide with
N * any application/library that wants linux/types.h.
N */
N#ifdef __CHECKER__
S#define __bitwise__ __attribute__((bitwise))
N#else
N#define __bitwise__
N#endif
N#ifdef __CHECK_ENDIAN__
S#define __bitwise __bitwise__
N#else
N#define __bitwise
N#endif
N
Ntypedef __u16 __bitwise __le16;
Xtypedef __u16  __le16;
Ntypedef __u16 __bitwise __be16;
Xtypedef __u16  __be16;
Ntypedef __u32 __bitwise __le32;
Xtypedef __u32  __le32;
Ntypedef __u32 __bitwise __be32;
Xtypedef __u32  __be32;
N// #if defined(__GNUC__)
Ntypedef __u64 __bitwise __le64;
Xtypedef __u64  __le64;
Ntypedef __u64 __bitwise __be64;
Xtypedef __u64  __be64;
N// #endif
Ntypedef __u16 __bitwise __sum16;
Xtypedef __u16  __sum16;
Ntypedef __u32 __bitwise __wsum;
Xtypedef __u32  __wsum;
N
N
Ntypedef unsigned __bitwise__	gfp_t;
Xtypedef unsigned 	gfp_t;
N
Nstruct ustat {
N	__kernel_daddr_t	f_tfree;
N	__kernel_ino_t		f_tinode;
N	char			f_fname[6];
N	char			f_fpack[6];
N};
N
N#endif /* _LINUX_TYPES_H */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/stddef.h" 2
N#endif
N
N#ifndef __CHECKER__
N#undef offsetof
N#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
N#endif
N
N#endif
L 246 "..\..\common\src\BSP\ThirdParty\yaffs2\include\malloc.h" 2
N#else
S#include <sys/types.h>
N#endif	/* __STD_C */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if 0	/* not for U-Boot */
S#include <stdio.h>	/* needed for malloc_stats */
N#endif
N
N
N/*
N  Compile-time options
N*/
N
N
N/*
N    Debugging:
N
N    Because freed chunks may be overwritten with link fields, this
N    malloc will often die when freed memory is overwritten by user
N    programs.  This can be very effective (albeit in an annoying way)
N    in helping track down dangling pointers.
N
N    If you compile with -DDEBUG, a number of assertion checks are
N    enabled that will catch more memory errors. You probably won't be
N    able to make much sense of the actual assertion errors, but they
N    should help you locate incorrectly overwritten memory.  The
N    checking is fairly extensive, and will slow down execution
N    noticeably. Calling malloc_stats or mallinfo with DEBUG set will
N    attempt to check every non-mmapped allocated and free chunk in the
N    course of computing the summmaries. (By nature, mmapped regions
N    cannot be checked very much automatically.)
N
N    Setting DEBUG may also be helpful if you are trying to modify
N    this code. The assertions in the check routines spell out in more
N    detail the assumptions and invariants underlying the algorithms.
N
N*/
N
N/*
N  INTERNAL_SIZE_T is the word-size used for internal bookkeeping
N  of chunk sizes. On a 64-bit machine, you can reduce malloc
N  overhead by defining INTERNAL_SIZE_T to be a 32 bit `unsigned int'
N  at the expense of not being able to handle requests greater than
N  2^31. This limitation is hardly ever a concern; you are encouraged
N  to set this. However, the default version is the same as size_t.
N*/
N
N#ifndef INTERNAL_SIZE_T
N#define INTERNAL_SIZE_T size_t
N#endif
N
N/*
N  REALLOC_ZERO_BYTES_FREES should be set if a call to
N  realloc with zero bytes should be the same as a call to free.
N  Some people think it should. Otherwise, since this malloc
N  returns a unique pointer for malloc(0), so does realloc(p, 0).
N*/
N
N
N/*   #define REALLOC_ZERO_BYTES_FREES */
N
N
N/*
N  WIN32 causes an emulation of sbrk to be compiled in
N  mmap-based options are not currently supported in WIN32.
N*/
N
N/* #define WIN32 */
N#ifdef WIN32
S#define MORECORE wsbrk
S#define HAVE_MMAP 0
S
S#define LACKS_UNISTD_H
S#define LACKS_SYS_PARAM_H
S
S/*
S  Include 'windows.h' to get the necessary declarations for the
S  Microsoft Visual C++ data structures and routines used in the 'sbrk'
S  emulation.
S
S  Define WIN32_LEAN_AND_MEAN so that only the essential Microsoft
S  Visual C++ header files are included.
S*/
S#define WIN32_LEAN_AND_MEAN
S#include <windows.h>
N#endif
N
N
N/*
N  HAVE_MEMCPY should be defined if you are not otherwise using
N  ANSI STD C, but still have memcpy and memset in your C library
N  and want to use them in calloc and realloc. Otherwise simple
N  macro versions are defined here.
N
N  USE_MEMCPY should be defined as 1 if you actually want to
N  have memset and memcpy called. People report that the macro
N  versions are often enough faster than libc versions on many
N  systems that it is better to use them.
N
N*/
N
N#define HAVE_MEMCPY
N
N#ifndef USE_MEMCPY
N#ifdef HAVE_MEMCPY
N#define USE_MEMCPY 1
N#else
S#define USE_MEMCPY 0
N#endif
N#endif
N
N#if (__STD_C || defined(HAVE_MEMCPY))
X#if (1 || 1L)
N
N#if __STD_C
X#if 1
Nvoid* memset(void*, int, size_t);
Nvoid* memcpy(void*, const void*, size_t);
N#else
S#ifdef WIN32
S/* On Win32 platforms, 'memset()' and 'memcpy()' are already declared in */
S/* 'windows.h' */
S#else
SVoid_t* memset();
SVoid_t* memcpy();
S#endif
N#endif
N#endif
N
N#if USE_MEMCPY
X#if 1
N
N/* The following macros are only invoked with (2n+1)-multiples of
N   INTERNAL_SIZE_T units, with a positive integer n. This is exploited
N   for fast inline execution when n is small. */
N
N#define MALLOC_ZERO(charp, nbytes)                                            \
Ndo {                                                                          \
N  INTERNAL_SIZE_T mzsz = (nbytes);                                            \
N  if(mzsz <= 9*sizeof(mzsz)) {                                                \
N    INTERNAL_SIZE_T* mz = (INTERNAL_SIZE_T*) (charp);                         \
N    if(mzsz >= 5*sizeof(mzsz)) {     *mz++ = 0;                               \
N				     *mz++ = 0;                               \
N      if(mzsz >= 7*sizeof(mzsz)) {   *mz++ = 0;                               \
N				     *mz++ = 0;                               \
N	if(mzsz >= 9*sizeof(mzsz)) { *mz++ = 0;                               \
N				     *mz++ = 0; }}}                           \
N				     *mz++ = 0;                               \
N				     *mz++ = 0;                               \
N				     *mz   = 0;                               \
N  } else memset((charp), 0, mzsz);                                            \
N} while(0)
X#define MALLOC_ZERO(charp, nbytes)                                            do {                                                                            INTERNAL_SIZE_T mzsz = (nbytes);                                              if(mzsz <= 9*sizeof(mzsz)) {                                                    INTERNAL_SIZE_T* mz = (INTERNAL_SIZE_T*) (charp);                             if(mzsz >= 5*sizeof(mzsz)) {     *mz++ = 0;                               				     *mz++ = 0;                                     if(mzsz >= 7*sizeof(mzsz)) {   *mz++ = 0;                               				     *mz++ = 0;                               	if(mzsz >= 9*sizeof(mzsz)) { *mz++ = 0;                               				     *mz++ = 0; }}}                           				     *mz++ = 0;                               				     *mz++ = 0;                               				     *mz   = 0;                                 } else memset((charp), 0, mzsz);                                            } while(0)
N
N#define MALLOC_COPY(dest,src,nbytes)                                          \
Ndo {                                                                          \
N  INTERNAL_SIZE_T mcsz = (nbytes);                                            \
N  if(mcsz <= 9*sizeof(mcsz)) {                                                \
N    INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) (src);                        \
N    INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) (dest);                       \
N    if(mcsz >= 5*sizeof(mcsz)) {     *mcdst++ = *mcsrc++;                     \
N				     *mcdst++ = *mcsrc++;                     \
N      if(mcsz >= 7*sizeof(mcsz)) {   *mcdst++ = *mcsrc++;                     \
N				     *mcdst++ = *mcsrc++;                     \
N	if(mcsz >= 9*sizeof(mcsz)) { *mcdst++ = *mcsrc++;                     \
N				     *mcdst++ = *mcsrc++; }}}                 \
N				     *mcdst++ = *mcsrc++;                     \
N				     *mcdst++ = *mcsrc++;                     \
N				     *mcdst   = *mcsrc  ;                     \
N  } else memcpy(dest, src, mcsz);                                             \
N} while(0)
X#define MALLOC_COPY(dest,src,nbytes)                                          do {                                                                            INTERNAL_SIZE_T mcsz = (nbytes);                                              if(mcsz <= 9*sizeof(mcsz)) {                                                    INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) (src);                            INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) (dest);                           if(mcsz >= 5*sizeof(mcsz)) {     *mcdst++ = *mcsrc++;                     				     *mcdst++ = *mcsrc++;                           if(mcsz >= 7*sizeof(mcsz)) {   *mcdst++ = *mcsrc++;                     				     *mcdst++ = *mcsrc++;                     	if(mcsz >= 9*sizeof(mcsz)) { *mcdst++ = *mcsrc++;                     				     *mcdst++ = *mcsrc++; }}}                 				     *mcdst++ = *mcsrc++;                     				     *mcdst++ = *mcsrc++;                     				     *mcdst   = *mcsrc  ;                       } else memcpy(dest, src, mcsz);                                             } while(0)
N
N#else /* !USE_MEMCPY */
S
S/* Use Duff's device for good zeroing/copying performance. */
S
S#define MALLOC_ZERO(charp, nbytes)                                            \
Sdo {                                                                          \
S  INTERNAL_SIZE_T* mzp = (INTERNAL_SIZE_T*)(charp);                           \
S  long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T), mcn;                         \
S  if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }             \
S  switch (mctmp) {                                                            \
S    case 0: for(;;) { *mzp++ = 0;                                             \
S    case 7:           *mzp++ = 0;                                             \
S    case 6:           *mzp++ = 0;                                             \
S    case 5:           *mzp++ = 0;                                             \
S    case 4:           *mzp++ = 0;                                             \
S    case 3:           *mzp++ = 0;                                             \
S    case 2:           *mzp++ = 0;                                             \
S    case 1:           *mzp++ = 0; if(mcn <= 0) break; mcn--; }                \
S  }                                                                           \
S} while(0)
X#define MALLOC_ZERO(charp, nbytes)                                            do {                                                                            INTERNAL_SIZE_T* mzp = (INTERNAL_SIZE_T*)(charp);                             long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T), mcn;                           if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }               switch (mctmp) {                                                                case 0: for(;;) { *mzp++ = 0;                                                 case 7:           *mzp++ = 0;                                                 case 6:           *mzp++ = 0;                                                 case 5:           *mzp++ = 0;                                                 case 4:           *mzp++ = 0;                                                 case 3:           *mzp++ = 0;                                                 case 2:           *mzp++ = 0;                                                 case 1:           *mzp++ = 0; if(mcn <= 0) break; mcn--; }                  }                                                                           } while(0)
S
S#define MALLOC_COPY(dest,src,nbytes)                                          \
Sdo {                                                                          \
S  INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) src;                            \
S  INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) dest;                           \
S  long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T), mcn;                         \
S  if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }             \
S  switch (mctmp) {                                                            \
S    case 0: for(;;) { *mcdst++ = *mcsrc++;                                    \
S    case 7:           *mcdst++ = *mcsrc++;                                    \
S    case 6:           *mcdst++ = *mcsrc++;                                    \
S    case 5:           *mcdst++ = *mcsrc++;                                    \
S    case 4:           *mcdst++ = *mcsrc++;                                    \
S    case 3:           *mcdst++ = *mcsrc++;                                    \
S    case 2:           *mcdst++ = *mcsrc++;                                    \
S    case 1:           *mcdst++ = *mcsrc++; if(mcn <= 0) break; mcn--; }       \
S  }                                                                           \
S} while(0)
X#define MALLOC_COPY(dest,src,nbytes)                                          do {                                                                            INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) src;                              INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) dest;                             long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T), mcn;                           if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; }               switch (mctmp) {                                                                case 0: for(;;) { *mcdst++ = *mcsrc++;                                        case 7:           *mcdst++ = *mcsrc++;                                        case 6:           *mcdst++ = *mcsrc++;                                        case 5:           *mcdst++ = *mcsrc++;                                        case 4:           *mcdst++ = *mcsrc++;                                        case 3:           *mcdst++ = *mcsrc++;                                        case 2:           *mcdst++ = *mcsrc++;                                        case 1:           *mcdst++ = *mcsrc++; if(mcn <= 0) break; mcn--; }         }                                                                           } while(0)
S
N#endif
N
N
N/*
N  Define HAVE_MMAP to optionally make malloc() use mmap() to
N  allocate very large blocks.  These will be returned to the
N  operating system immediately after a free().
N*/
N
N/***
N#ifndef HAVE_MMAP
N#define HAVE_MMAP 1
N#endif
N***/
N#undef	HAVE_MMAP	/* Not available for U-Boot */
N
N/*
N  Define HAVE_MREMAP to make realloc() use mremap() to re-allocate
N  large blocks.  This is currently only possible on Linux with
N  kernel versions newer than 1.3.77.
N*/
N
N/***
N#ifndef HAVE_MREMAP
N#ifdef INTERNAL_LINUX_C_LIB
N#define HAVE_MREMAP 1
N#else
N#define HAVE_MREMAP 0
N#endif
N#endif
N***/
N#undef	HAVE_MREMAP	/* Not available for U-Boot */
N
N#ifdef HAVE_MMAP
S
S#include <unistd.h>
S#include <fcntl.h>
S#include <sys/mman.h>
S
S#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
S#define MAP_ANONYMOUS MAP_ANON
S#endif
S
N#endif /* HAVE_MMAP */
N
N/*
N  Access to system page size. To the extent possible, this malloc
N  manages memory from the system in page-size units.
N
N  The following mechanics for getpagesize were adapted from
N  bsd/gnu getpagesize.h
N*/
N
N#define	LACKS_UNISTD_H	/* Shortcut for U-Boot */
N#define	malloc_getpagesize	4096
N
N#ifndef LACKS_UNISTD_H
S#  include <unistd.h>
N#endif
N
N#ifndef malloc_getpagesize
S#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
S#    ifndef _SC_PAGE_SIZE
S#      define _SC_PAGE_SIZE _SC_PAGESIZE
S#    endif
S#  endif
S#  ifdef _SC_PAGE_SIZE
S#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
S#  else
S#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
S       extern size_t getpagesize();
S#      define malloc_getpagesize getpagesize()
S#    else
S#      ifdef WIN32
S#        define malloc_getpagesize (4096) /* TBD: Use 'GetSystemInfo' instead */
S#      else
S#        ifndef LACKS_SYS_PARAM_H
S#          include <sys/param.h>
S#        endif
S#        ifdef EXEC_PAGESIZE
S#          define malloc_getpagesize EXEC_PAGESIZE
S#        else
S#          ifdef NBPG
S#            ifndef CLSIZE
S#              define malloc_getpagesize NBPG
S#            else
S#              define malloc_getpagesize (NBPG * CLSIZE)
S#            endif
S#          else
S#            ifdef NBPC
S#              define malloc_getpagesize NBPC
S#            else
S#              ifdef PAGESIZE
S#                define malloc_getpagesize PAGESIZE
S#              else
S#                define malloc_getpagesize (4096) /* just guess */
S#              endif
S#            endif
S#          endif
S#        endif
S#      endif
S#    endif
S#  endif
N#endif
N
N
N/*
N
N  This version of malloc supports the standard SVID/XPG mallinfo
N  routine that returns a struct containing the same kind of
N  information you can get from malloc_stats. It should work on
N  any SVID/XPG compliant system that has a /usr/include/malloc.h
N  defining struct mallinfo. (If you'd like to install such a thing
N  yourself, cut out the preliminary declarations as described above
N  and below and save them in a malloc.h file. But there's no
N  compelling reason to bother to do this.)
N
N  The main declaration needed is the mallinfo struct that is returned
N  (by-copy) by mallinfo().  The SVID/XPG malloinfo struct contains a
N  bunch of fields, most of which are not even meaningful in this
N  version of malloc. Some of these fields are are instead filled by
N  mallinfo() with other numbers that might possibly be of interest.
N
N  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
N  /usr/include/malloc.h file that includes a declaration of struct
N  mallinfo.  If so, it is included; else an SVID2/XPG2 compliant
N  version is declared below.  These must be precisely the same for
N  mallinfo() to work.
N
N*/
N
N/* #define HAVE_USR_INCLUDE_MALLOC_H */
N
N#ifdef HAVE_USR_INCLUDE_MALLOC_H
S#include "/usr/include/malloc.h"
N#else
N
N/* SVID2/XPG mallinfo structure */
N
Nstruct mallinfo {
N  int arena;    /* total space allocated from system */
N  int ordblks;  /* number of non-inuse chunks */
N  int smblks;   /* unused -- always zero */
N  int hblks;    /* number of mmapped regions */
N  int hblkhd;   /* total space in mmapped regions */
N  int usmblks;  /* unused -- always zero */
N  int fsmblks;  /* unused -- always zero */
N  int uordblks; /* total allocated space */
N  int fordblks; /* total non-inuse space */
N  int keepcost; /* top-most, releasable (via malloc_trim) space */
N};
N
N/* SVID2/XPG mallopt options */
N
N#define M_MXFAST  1    /* UNUSED in this malloc */
N#define M_NLBLKS  2    /* UNUSED in this malloc */
N#define M_GRAIN   3    /* UNUSED in this malloc */
N#define M_KEEP    4    /* UNUSED in this malloc */
N
N#endif
N
N/* mallopt options that actually do something */
N
N#define M_TRIM_THRESHOLD    -1
N#define M_TOP_PAD           -2
N#define M_MMAP_THRESHOLD    -3
N#define M_MMAP_MAX          -4
N
N
N#ifndef DEFAULT_TRIM_THRESHOLD
N#define DEFAULT_TRIM_THRESHOLD (128 * 1024)
N#endif
N
N/*
N    M_TRIM_THRESHOLD is the maximum amount of unused top-most memory
N      to keep before releasing via malloc_trim in free().
N
N      Automatic trimming is mainly useful in long-lived programs.
N      Because trimming via sbrk can be slow on some systems, and can
N      sometimes be wasteful (in cases where programs immediately
N      afterward allocate more large chunks) the value should be high
N      enough so that your overall system performance would improve by
N      releasing.
N
N      The trim threshold and the mmap control parameters (see below)
N      can be traded off with one another. Trimming and mmapping are
N      two different ways of releasing unused memory back to the
N      system. Between these two, it is often possible to keep
N      system-level demands of a long-lived program down to a bare
N      minimum. For example, in one test suite of sessions measuring
N      the XF86 X server on Linux, using a trim threshold of 128K and a
N      mmap threshold of 192K led to near-minimal long term resource
N      consumption.
N
N      If you are using this malloc in a long-lived program, it should
N      pay to experiment with these values.  As a rough guide, you
N      might set to a value close to the average size of a process
N      (program) running on your system.  Releasing this much memory
N      would allow such a process to run in memory.  Generally, it's
N      worth it to tune for trimming rather tham memory mapping when a
N      program undergoes phases where several large chunks are
N      allocated and released in ways that can reuse each other's
N      storage, perhaps mixed with phases where there are no such
N      chunks at all.  And in well-behaved long-lived programs,
N      controlling release of large blocks via trimming versus mapping
N      is usually faster.
N
N      However, in most programs, these parameters serve mainly as
N      protection against the system-level effects of carrying around
N      massive amounts of unneeded memory. Since frequent calls to
N      sbrk, mmap, and munmap otherwise degrade performance, the default
N      parameters are set to relatively high values that serve only as
N      safeguards.
N
N      The default trim value is high enough to cause trimming only in
N      fairly extreme (by current memory consumption standards) cases.
N      It must be greater than page size to have any useful effect.  To
N      disable trimming completely, you can set to (unsigned long)(-1);
N
N
N*/
N
N
N#ifndef DEFAULT_TOP_PAD
N#define DEFAULT_TOP_PAD        (0)
N#endif
N
N/*
N    M_TOP_PAD is the amount of extra `padding' space to allocate or
N      retain whenever sbrk is called. It is used in two ways internally:
N
N      * When sbrk is called to extend the top of the arena to satisfy
N	a new malloc request, this much padding is added to the sbrk
N	request.
N
N      * When malloc_trim is called automatically from free(),
N	it is used as the `pad' argument.
N
N      In both cases, the actual amount of padding is rounded
N      so that the end of the arena is always a system page boundary.
N
N      The main reason for using padding is to avoid calling sbrk so
N      often. Having even a small pad greatly reduces the likelihood
N      that nearly every malloc request during program start-up (or
N      after trimming) will invoke sbrk, which needlessly wastes
N      time.
N
N      Automatic rounding-up to page-size units is normally sufficient
N      to avoid measurable overhead, so the default is 0.  However, in
N      systems where sbrk is relatively slow, it can pay to increase
N      this value, at the expense of carrying around more memory than
N      the program needs.
N
N*/
N
N
N#ifndef DEFAULT_MMAP_THRESHOLD
N#define DEFAULT_MMAP_THRESHOLD (128 * 1024)
N#endif
N
N/*
N
N    M_MMAP_THRESHOLD is the request size threshold for using mmap()
N      to service a request. Requests of at least this size that cannot
N      be allocated using already-existing space will be serviced via mmap.
N      (If enough normal freed space already exists it is used instead.)
N
N      Using mmap segregates relatively large chunks of memory so that
N      they can be individually obtained and released from the host
N      system. A request serviced through mmap is never reused by any
N      other request (at least not directly; the system may just so
N      happen to remap successive requests to the same locations).
N
N      Segregating space in this way has the benefit that mmapped space
N      can ALWAYS be individually released back to the system, which
N      helps keep the system level memory demands of a long-lived
N      program low. Mapped memory can never become `locked' between
N      other chunks, as can happen with normally allocated chunks, which
N      menas that even trimming via malloc_trim would not release them.
N
N      However, it has the disadvantages that:
N
N	 1. The space cannot be reclaimed, consolidated, and then
N	    used to service later requests, as happens with normal chunks.
N	 2. It can lead to more wastage because of mmap page alignment
N	    requirements
N	 3. It causes malloc performance to be more dependent on host
N	    system memory management support routines which may vary in
N	    implementation quality and may impose arbitrary
N	    limitations. Generally, servicing a request via normal
N	    malloc steps is faster than going through a system's mmap.
N
N      All together, these considerations should lead you to use mmap
N      only for relatively large requests.
N
N
N*/
N
N
N#ifndef DEFAULT_MMAP_MAX
N#ifdef HAVE_MMAP
S#define DEFAULT_MMAP_MAX       (64)
N#else
N#define DEFAULT_MMAP_MAX       (0)
N#endif
N#endif
N
N/*
N    M_MMAP_MAX is the maximum number of requests to simultaneously
N      service using mmap. This parameter exists because:
N
N	 1. Some systems have a limited number of internal tables for
N	    use by mmap.
N	 2. In most systems, overreliance on mmap can degrade overall
N	    performance.
N	 3. If a program allocates many large regions, it is probably
N	    better off using normal sbrk-based allocation routines that
N	    can reclaim and reallocate normal heap memory. Using a
N	    small value allows transition into this mode after the
N	    first few allocations.
N
N      Setting to 0 disables all use of mmap.  If HAVE_MMAP is not set,
N      the default value is 0, and attempts to set it to non-zero values
N      in mallopt will fail.
N*/
N
N
N/*
N    USE_DL_PREFIX will prefix all public routines with the string 'dl'.
N      Useful to quickly avoid procedure declaration conflicts and linker
N      symbol conflicts with existing memory allocation routines.
N
N*/
N
N/* #define USE_DL_PREFIX */
N
N
N/*
N
N  Special defines for linux libc
N
N  Except when compiled using these special defines for Linux libc
N  using weak aliases, this malloc is NOT designed to work in
N  multithreaded applications.  No semaphores or other concurrency
N  control are provided to ensure that multiple malloc or free calls
N  don't run at the same time, which could be disasterous. A single
N  semaphore could be used across malloc, realloc, and free (which is
N  essentially the effect of the linux weak alias approach). It would
N  be hard to obtain finer granularity.
N
N*/
N
N
N#ifdef INTERNAL_LINUX_C_LIB
S
S#if __STD_C
S
SVoid_t * __default_morecore_init (ptrdiff_t);
SVoid_t *(*__morecore)(ptrdiff_t) = __default_morecore_init;
S
S#else
S
SVoid_t * __default_morecore_init ();
SVoid_t *(*__morecore)() = __default_morecore_init;
S
S#endif
S
S#define MORECORE (*__morecore)
S#define MORECORE_FAILURE 0
S#define MORECORE_CLEARS 1
S
N#else /* INTERNAL_LINUX_C_LIB */
N
N#if __STD_C
X#if 1
Nextern Void_t*     sbrk(ptrdiff_t);
Xextern void*     sbrk(ptrdiff_t);
N#else
Sextern Void_t*     sbrk();
N#endif
N
N#ifndef MORECORE
N#define MORECORE sbrk
N#endif
N
N#ifndef MORECORE_FAILURE
N#define MORECORE_FAILURE -1
N#endif
N
N#ifndef MORECORE_CLEARS
N#define MORECORE_CLEARS 1
N#endif
N
N#endif /* INTERNAL_LINUX_C_LIB */
N
N#if defined(INTERNAL_LINUX_C_LIB) && defined(__ELF__)
X#if 0L && 0L
S
S#define cALLOc		__libc_calloc
S#define fREe		__libc_free
S#define mALLOc		__libc_malloc
S#define mEMALIGn	__libc_memalign
S#define rEALLOc		__libc_realloc
S#define vALLOc		__libc_valloc
S#define pvALLOc		__libc_pvalloc
S#define mALLINFo	__libc_mallinfo
S#define mALLOPt		__libc_mallopt
S
S#pragma weak calloc = __libc_calloc
S#pragma weak free = __libc_free
S#pragma weak cfree = __libc_free
S#pragma weak malloc = __libc_malloc
S#pragma weak memalign = __libc_memalign
S#pragma weak realloc = __libc_realloc
S#pragma weak valloc = __libc_valloc
S#pragma weak pvalloc = __libc_pvalloc
S#pragma weak mallinfo = __libc_mallinfo
S#pragma weak mallopt = __libc_mallopt
S
N#else
N
N#ifdef USE_DL_PREFIX
S#define cALLOc		dlcalloc
S#define fREe		dlfree
S#define mALLOc		dlmalloc
S#define mEMALIGn	dlmemalign
S#define rEALLOc		dlrealloc
S#define vALLOc		dlvalloc
S#define pvALLOc		dlpvalloc
S#define mALLINFo	dlmallinfo
S#define mALLOPt		dlmallopt
N#else /* USE_DL_PREFIX */
N#define cALLOc		calloc
N#define fREe		free
N#define mALLOc		malloc
N#define mEMALIGn	memalign
N#define rEALLOc		realloc
N#define vALLOc		valloc
N#define pvALLOc		pvalloc
N#define mALLINFo	mallinfo
N#define mALLOPt		mallopt
N#endif /* USE_DL_PREFIX */
N
N#endif
N
N/* Public routines */
N
N#if __STD_C
X#if 1
N
NVoid_t* mALLOc(size_t);
Xvoid* malloc(size_t);
Nvoid    fREe(Void_t*);
Xvoid    free(void*);
NVoid_t* rEALLOc(Void_t*, size_t);
Xvoid* realloc(void*, size_t);
NVoid_t* mEMALIGn(size_t, size_t);
Xvoid* memalign(size_t, size_t);
NVoid_t* vALLOc(size_t);
Xvoid* valloc(size_t);
NVoid_t* pvALLOc(size_t);
Xvoid* pvalloc(size_t);
NVoid_t* cALLOc(size_t, size_t);
Xvoid* calloc(size_t, size_t);
Nvoid    cfree(Void_t*);
Xvoid    cfree(void*);
Nint     malloc_trim(size_t);
Nsize_t  malloc_usable_size(Void_t*);
Xsize_t  malloc_usable_size(void*);
Nvoid    malloc_stats(void);
Nint     mALLOPt(int, int);
Xint     mallopt(int, int);
Nstruct mallinfo mALLINFo(void);
Xstruct mallinfo mallinfo(void);
N#else
SVoid_t* mALLOc();
Svoid    fREe();
SVoid_t* rEALLOc();
SVoid_t* mEMALIGn();
SVoid_t* vALLOc();
SVoid_t* pvALLOc();
SVoid_t* cALLOc();
Svoid    cfree();
Sint     malloc_trim();
Ssize_t  malloc_usable_size();
Svoid    malloc_stats();
Sint     mALLOPt();
Sstruct mallinfo mALLINFo();
N#endif
N
N/*
N * Begin and End of memory area for malloc(), and current "brk"
N */
Nextern ulong mem_malloc_start;
Nextern ulong mem_malloc_end;
Nextern ulong mem_malloc_brk;
N
Nvoid mem_malloc_init(ulong start, ulong size);
N
N#ifdef __cplusplus
S};  /* end of extern "C" */
N#endif
N
N#endif /* __MALLOC_H__ */
L 65 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "linux\mtd.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 1
N/*
N * Copyright (C) 1999-2003 David Woodhouse <dwmw2@infradead.org> et al.
N *
N * Released under GPL
N */
N
N#ifndef __MTD_MTD_H__
N#define __MTD_MTD_H__
N
N#include "linux\types.h"
N#include "div64.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\div64.h" 1
N#ifndef _ASM_GENERIC_DIV64_H
N#define _ASM_GENERIC_DIV64_H
N/*
N * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
N * Based on former asm-ppc/div64.h and asm-m68knommu/div64.h
N *
N * The semantics of do_div() are:
N *
N * uint32_t do_div(uint64_t *n, uint32_t base)
N * {
N *	uint32_t remainder = *n % base;
N *	*n = *n / base;
N *	return remainder;
N * }
N *
N * NOTE: macro parameter n is evaluated multiple times,
N *       beware of side effects!
N */
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 20 "..\..\common\src\BSP\ThirdParty\yaffs2\include\div64.h" 2
N#include "linux\types.h"
N
Nextern uint32_t __div64_32(uint64_t *dividend, uint32_t divisor);
N
N/* The unnecessary pointer compare is there
N * to check for type safety (n must be 64bit)
N */
N#define do_div(n,base) (n = n/base)
N
N#if 0
S#define do_div(n,base) ({   \
S	uint32_t __base = (base);   \
S	uint32_t __rem; \
S	(void)(((typeof((n)) *)0) == ((uint64_t *)0));  \
S	if (((n) >> 32) == 0) { \
S		__rem = (uint32_t)(n) % __base; \
S		(n) = (uint32_t)(n) / __base;   \
S	} else  \
S		__rem = __div64_32(&(n), __base);   \
S	__rem;  \
S})
X#define do_div(n,base) ({   	uint32_t __base = (base);   	uint32_t __rem; 	(void)(((typeof((n)) *)0) == ((uint64_t *)0));  	if (((n) >> 32) == 0) { 		__rem = (uint32_t)(n) % __base; 		(n) = (uint32_t)(n) / __base;   	} else  		__rem = __div64_32(&(n), __base);   	__rem;  })
S
S/* Wrapper for do_div(). Doesn't modify dividend and returns
S * the result, not reminder.
S */
Sstatic __inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
S{
S	uint64_t __res = dividend;
S	do_div(__res, divisor);
S	return(__res);
S}
N#endif
N#endif /* _ASM_GENERIC_DIV64_H */
L 12 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 2
N#include "linux\mtd-abi.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd-abi.h" 1
N/*
N * $Id: mtd-abi.h,v 1.13 2005/11/07 11:14:56 gleixner Exp $
N *
N * Portions of MTD ABI definition which are shared by kernel and user space
N */
N
N#ifndef __MTD_ABI_H__
N#define __MTD_ABI_H__
N
N#include <stdint.h>
N
N#include <linux/compiler.h>
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux/compiler.h" 1
N#ifndef __LINUX_COMPILER_H
N#define __LINUX_COMPILER_H
N
N#ifndef __ASSEMBLY__
N
N#ifdef __CHECKER__
S# define __user		__attribute__((noderef, address_space(1)))
S# define __kernel	/* default address space */
S# define __safe		__attribute__((safe))
S# define __force	__attribute__((force))
S# define __nocast	__attribute__((nocast))
S# define __iomem	__attribute__((noderef, address_space(2)))
S# define __acquires(x)	__attribute__((context(x,0,1)))
S# define __releases(x)	__attribute__((context(x,1,0)))
S# define __acquire(x)	__context__(x,1)
S# define __release(x)	__context__(x,-1)
S# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
Sextern void __chk_user_ptr(const volatile void __user *);
Sextern void __chk_io_ptr(const volatile void __iomem *);
N#else
N# define __user
N# define __kernel
N# define __safe
N# define __force
N# define __nocast
N# define __iomem
N# define __chk_user_ptr(x) (void)0
N# define __chk_io_ptr(x) (void)0
N# define __builtin_warning(x, y...) (1)
N# define __acquires(x)
N# define __releases(x)
N# define __acquire(x) (void)0
N# define __release(x) (void)0
N# define __cond_lock(x,c) (c)
N#endif
N
N#ifdef __KERNEL__
S
S#ifdef __GNUC__
S#include <linux/compiler-gcc.h>
S#endif
S
S#define notrace __attribute__((no_instrument_function))
S
S/* Intel compiler defines __GNUC__. So we will overwrite implementations
S * coming from above header files here
S */
S#ifdef __INTEL_COMPILER
S# include <linux/compiler-intel.h>
S#endif
S
S/*
S * Generic compiler-dependent macros required for kernel
S * build go below this comment. Actual compiler/compiler version
S * specific implementations come from the above header files
S */
S
Sstruct ftrace_branch_data {
S	const char *func;
S	const char *file;
S	unsigned line;
S	union {
S		struct {
S			unsigned long correct;
S			unsigned long incorrect;
S		};
S		struct {
S			unsigned long miss;
S			unsigned long hit;
S		};
S		unsigned long miss_hit[2];
S	};
S};
S
S/*
S * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
S * to disable branch tracing on a per file basis.
S */
S#if defined(CONFIG_TRACE_BRANCH_PROFILING) \
S    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)
X#if defined(CONFIG_TRACE_BRANCH_PROFILING)     && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)
Svoid ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
S
S#define likely_notrace(x)	__builtin_expect(!!(x), 1)
S#define unlikely_notrace(x)	__builtin_expect(!!(x), 0)
S
S#define __branch_check__(x, expect) ({					\
S			int ______r;					\
S			static struct ftrace_branch_data		\
S				__attribute__((__aligned__(4)))		\
S				__attribute__((section("_ftrace_annotated_branch"))) \
S				______f = {				\
S				.func = __func__,			\
S				.file = __FILE__,			\
S				.line = __LINE__,			\
S			};						\
S			______r = likely_notrace(x);			\
S			ftrace_likely_update(&______f, ______r, expect); \
S			______r;					\
S		})
X#define __branch_check__(x, expect) ({								int ______r;								static struct ftrace_branch_data						__attribute__((__aligned__(4)))						__attribute__((section("_ftrace_annotated_branch"))) 				______f = {								.func = __func__,							.file = __FILE__,							.line = __LINE__,						};									______r = likely_notrace(x);						ftrace_likely_update(&______f, ______r, expect); 			______r;							})
S
S/*
S * Using __builtin_constant_p(x) to ignore cases where the return
S * value is always the same.  This idea is taken from a similar patch
S * written by Daniel Walker.
S */
S# ifndef likely
S#  define likely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 1))
S# endif
S# ifndef unlikely
S#  define unlikely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 0))
S# endif
S
S#ifdef CONFIG_PROFILE_ALL_BRANCHES
S/*
S * "Define 'is'", Bill Clinton
S * "Define 'if'", Steven Rostedt
S */
S#define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
S#define __trace_if(cond) \
S	if (__builtin_constant_p((cond)) ? !!(cond) :			\
S	({								\
S		int ______r;						\
S		static struct ftrace_branch_data			\
S			__attribute__((__aligned__(4)))			\
S			__attribute__((section("_ftrace_branch")))	\
S			______f = {					\
S				.func = __func__,			\
S				.file = __FILE__,			\
S				.line = __LINE__,			\
S			};						\
S		______r = !!(cond);					\
S		______f.miss_hit[______r]++;					\
S		______r;						\
S	}))
X#define __trace_if(cond) 	if (__builtin_constant_p((cond)) ? !!(cond) :				({										int ______r;								static struct ftrace_branch_data						__attribute__((__aligned__(4)))						__attribute__((section("_ftrace_branch")))				______f = {									.func = __func__,							.file = __FILE__,							.line = __LINE__,						};								______r = !!(cond);							______f.miss_hit[______r]++;							______r;							}))
S#endif /* CONFIG_PROFILE_ALL_BRANCHES */
S
S#else
S# define likely(x)	__builtin_expect(!!(x), 1)
S# define unlikely(x)	__builtin_expect(!!(x), 0)
S#endif
S
S/* Optimization barrier */
S#ifndef barrier
S# define barrier() __memory_barrier()
S#endif
S
S/* Unreachable code */
S#ifndef unreachable
S# define unreachable() do { } while (1)
S#endif
S
S#ifndef RELOC_HIDE
S# define RELOC_HIDE(ptr, off)					\
S  ({ unsigned long __ptr;					\
S     __ptr = (unsigned long) (ptr);				\
S    (typeof(ptr)) (__ptr + (off)); })
X# define RELOC_HIDE(ptr, off)					  ({ unsigned long __ptr;					     __ptr = (unsigned long) (ptr);				    (typeof(ptr)) (__ptr + (off)); })
S#endif
S
N#endif /* __KERNEL__ */
N
N#endif /* __ASSEMBLY__ */
N
N#ifdef __KERNEL__
S/*
S * Allow us to mark functions as 'deprecated' and have gcc emit a nice
S * warning for each use, in hopes of speeding the functions removal.
S * Usage is:
S * 		int __deprecated foo(void)
S */
S#ifndef __deprecated
S# define __deprecated		/* unimplemented */
S#endif
S
S#ifdef MODULE
S#define __deprecated_for_modules __deprecated
S#else
S#define __deprecated_for_modules
S#endif
S
S#ifndef __must_check
S#define __must_check
S#endif
S
S#ifndef CONFIG_ENABLE_MUST_CHECK
S#undef __must_check
S#define __must_check
S#endif
S#ifndef CONFIG_ENABLE_WARN_DEPRECATED
S#undef __deprecated
S#undef __deprecated_for_modules
S#define __deprecated
S#define __deprecated_for_modules
S#endif
S
S/*
S * Allow us to avoid 'defined but not used' warnings on functions and data,
S * as well as force them to be emitted to the assembly file.
S *
S * As of gcc 3.4, static functions that are not marked with attribute((used))
S * may be elided from the assembly file.  As of gcc 3.4, static data not so
S * marked will not be elided, but this may change in a future gcc version.
S *
S * NOTE: Because distributions shipped with a backported unit-at-a-time
S * compiler in gcc 3.3, we must define __used to be __attribute__((used))
S * for gcc >=3.3 instead of 3.4.
S *
S * In prior versions of gcc, such functions and data would be emitted, but
S * would be warned about except with attribute((unused)).
S *
S * Mark functions that are referenced only in inline assembly as __used so
S * the code is emitted even though it appears to be unreferenced.
S */
S#ifndef __used
S# define __used			/* unimplemented */
S#endif
S
S#ifndef __maybe_unused
S# define __maybe_unused		/* unimplemented */
S#endif
S
S#ifndef __always_unused
S# define __always_unused	/* unimplemented */
S#endif
S
S#ifndef noinline
S#define noinline
S#endif
S
S/*
S * Rather then using noinline to prevent stack consumption, use
S * noinline_for_stack instead.  For documentaiton reasons.
S */
S#define noinline_for_stack noinline
S
S#ifndef __always_inline
S#define __always_inline inline
S#endif
S
N#endif /* __KERNEL__ */
N
N/*
N * From the GCC manual:
N *
N * Many functions do not examine any values except their arguments,
N * and have no effects except the return value.  Basically this is
N * just slightly more strict class than the `pure' attribute above,
N * since function is not allowed to read global memory.
N *
N * Note that a function that has pointer arguments and examines the
N * data pointed to must _not_ be declared `const'.  Likewise, a
N * function that calls a non-`const' function usually must not be
N * `const'.  It does not make sense for a `const' function to return
N * `void'.
N */
N#ifndef __attribute_const__
N# define __attribute_const__	/* unimplemented */
N#endif
N
N/*
N * Tell gcc if a function is cold. The compiler will assume any path
N * directly leading to the call is unlikely.
N */
N
N#ifndef __cold
N#define __cold
N#endif
N
N/* Simple shorthand for a section definition */
N#ifndef __section
N# define __section(S) __attribute__ ((__section__(#S)))
N#endif
N
N/* Are two types/vars the same type (ignoring qualifiers)? */
N#ifndef __same_type
N# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
N#endif
N
N/* Compile time object size, -1 for unknown */
N#ifndef __compiletime_object_size
N# define __compiletime_object_size(obj) -1
N#endif
N#ifndef __compiletime_warning
N# define __compiletime_warning(message)
N#endif
N#ifndef __compiletime_error
N# define __compiletime_error(message)
N#endif
N
N/*
N * Prevent the compiler from merging or refetching accesses.  The compiler
N * is also forbidden from reordering successive instances of ACCESS_ONCE(),
N * but only when the compiler is aware of some particular ordering.  One way
N * to make the compiler aware of ordering is to put the two invocations of
N * ACCESS_ONCE() in different C statements.
N *
N * This macro does absolutely -nothing- to prevent the CPU from reordering,
N * merging, or refetching absolutely anything at any time.  Its main intended
N * use is to mediate communication between process-level code and irq/NMI
N * handlers, all running on the same CPU.
N */
N#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
N
N#endif /* __LINUX_COMPILER_H */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd-abi.h" 2
N
Nstruct erase_info_user {
N	uint32_t start;
N	uint32_t length;
N};
N
Nstruct mtd_oob_buf {
N	uint32_t start;
N	uint32_t length;
N	unsigned char __user *ptr;
X	unsigned char  *ptr;
N};
N
N#define MTD_ABSENT		0
N#define MTD_RAM			1
N#define MTD_ROM			2
N#define MTD_NORFLASH		3
N#define MTD_NANDFLASH		4
N#define MTD_DATAFLASH		6
N#define MTD_UBIVOLUME		7
N
N#define MTD_WRITEABLE		0x400	/* Device is writeable */
N#define MTD_BIT_WRITEABLE	0x800	/* Single bits can be flipped */
N#define MTD_NO_ERASE		0x1000	/* No erase necessary */
N#define MTD_STUPID_LOCK		0x2000	/* Always locked after reset */
N
N/* Some common devices / combinations of capabilities */
N#define MTD_CAP_ROM		0
N#define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
N#define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
N#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
N
N/* ECC byte placement */
N#define MTD_NANDECC_OFF		0	/* Switch off ECC (Not recommended) */
N#define MTD_NANDECC_PLACE	1	/* Use the given placement in the structure (YAFFS1 legacy mode) */
N#define MTD_NANDECC_AUTOPLACE	2	/* Use the default placement scheme */
N#define MTD_NANDECC_PLACEONLY	3	/* Use the given placement in the structure (Do not store ecc result on read) */
N#define MTD_NANDECC_AUTOPL_USR	4	/* Use the given autoplacement scheme rather than using the default */
N
N/* OTP mode selection */
N#define MTD_OTP_OFF		0
N#define MTD_OTP_FACTORY		1
N#define MTD_OTP_USER		2
N
Nstruct mtd_info_user {
N	uint8_t type;
N	uint32_t flags;
N	uint32_t size;			/* Total size of the MTD */
N	uint32_t erasesize;
N	uint32_t writesize;
N	uint32_t oobsize;		/* Amount of OOB data per block (e.g. 16) */
N	/* The below two fields are obsolete and broken, do not use them
N	 * (TODO: remove at some point) */
N	uint32_t ecctype;
N	uint32_t eccsize;
N};
N
Nstruct region_info_user {
N	uint32_t offset;		/* At which this region starts,
N					 * from the beginning of the MTD */
N	uint32_t erasesize;		/* For this region */
N	uint32_t numblocks;		/* Number of blocks in this region */
N	uint32_t regionindex;
N};
N
Nstruct otp_info {
N	uint32_t start;
N	uint32_t length;
N	uint32_t locked;
N};
N
N#define MEMGETINFO		_IOR('M', 1, struct mtd_info_user)
N#define MEMERASE		_IOW('M', 2, struct erase_info_user)
N#define MEMWRITEOOB		_IOWR('M', 3, struct mtd_oob_buf)
N#define MEMREADOOB		_IOWR('M', 4, struct mtd_oob_buf)
N#define MEMLOCK			_IOW('M', 5, struct erase_info_user)
N#define MEMUNLOCK		_IOW('M', 6, struct erase_info_user)
N#define MEMGETREGIONCOUNT	_IOR('M', 7, int)
N#define MEMGETREGIONINFO	_IOWR('M', 8, struct region_info_user)
N#define MEMSETOOBSEL		_IOW('M', 9, struct nand_oobinfo)
N#define MEMGETOOBSEL		_IOR('M', 10, struct nand_oobinfo)
N#define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
N#define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
N#define OTPSELECT		_IOR('M', 13, int)
N#define OTPGETREGIONCOUNT	_IOW('M', 14, int)
N#define OTPGETREGIONINFO	_IOW('M', 15, struct otp_info)
N#define OTPLOCK			_IOR('M', 16, struct otp_info)
N#define ECCGETLAYOUT		_IOR('M', 17, struct nand_ecclayout)
N#define ECCGETSTATS		_IOR('M', 18, struct mtd_ecc_stats)
N#define MTDFILEMODE		_IO('M', 19)
N
N/*
N * Obsolete legacy interface. Keep it in order not to break userspace
N * interfaces
N */
Nstruct nand_oobinfo {
N	uint32_t useecc;
N	uint32_t eccbytes;
N	uint32_t oobfree[8][2];
N	uint32_t eccpos[48];
N};
N
Nstruct nand_oobfree {
N	uint32_t offset;
N	uint32_t length;
N};
N
N#define MTD_MAX_OOBFREE_ENTRIES	8
N/*
N * ECC layout control structure. Exported to userspace for
N * diagnosis and to allow creation of raw images
N */
Nstruct nand_ecclayout {
N	uint32_t eccbytes;
N	uint32_t eccpos[128];
N	uint32_t oobavail;
N	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
X	struct nand_oobfree oobfree[8];
N};
N
N/**
N * struct mtd_ecc_stats - error correction stats
N *
N * @corrected:	number of corrected bits
N * @failed:	number of uncorrectable errors
N * @badblocks:	number of bad blocks in this partition
N * @bbtblocks:	number of blocks reserved for bad block tables
N */
Nstruct mtd_ecc_stats {
N	uint32_t corrected;
N	uint32_t failed;
N	uint32_t badblocks;
N	uint32_t bbtblocks;
N};
N
N/*
N * Read/write file modes for access to MTD
N */
Nenum mtd_file_modes {
N	MTD_MODE_NORMAL = MTD_OTP_OFF,
X	MTD_MODE_NORMAL = 0,
N	MTD_MODE_OTP_FACTORY = MTD_OTP_FACTORY,
X	MTD_MODE_OTP_FACTORY = 1,
N	MTD_MODE_OTP_USER = MTD_OTP_USER,
X	MTD_MODE_OTP_USER = 2,
N	MTD_MODE_RAW,
N};
N
N#endif /* __MTD_ABI_H__ */
L 13 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\mtd.h" 2
N
N#define MTD_CHAR_MAJOR 90
N#define MTD_BLOCK_MAJOR 31
N#define MAX_MTD_DEVICES 32
N
N#define MTD_ERASE_PENDING	0x01
N#define MTD_ERASING		0x02
N#define MTD_ERASE_SUSPEND	0x04
N#define MTD_ERASE_DONE          0x08
N#define MTD_ERASE_FAILED        0x10
N
N#define MTD_FAIL_ADDR_UNKNOWN	-1LL
N
N/*
N * Enumeration for NAND/OneNAND flash chip state
N */
Nenum {
N	FL_READY,
N	FL_READING,
N	FL_WRITING,
N	FL_ERASING,
N	FL_SYNCING,
N	FL_CACHEDPRG,
N	FL_RESETING,
N	FL_UNLOCKING,
N	FL_LOCKING,
N	FL_PM_SUSPENDED,
N};
N
N/* If the erase fails, fail_addr might indicate exactly which block failed.  If
N   fail_addr = MTD_FAIL_ADDR_UNKNOWN, the failure was not at the device level or was not
N   specific to any particular block. */
Nstruct erase_info {
N	struct mtd_info *mtd;
N	uint64_t addr;
N	uint64_t len;
N	uint64_t fail_addr;
N	u_long time;
N	u_long retries;
N	u_int dev;
N	u_int cell;
N	void (*callback) (struct erase_info *self);
N	u_long priv;
N	u_char state;
N	struct erase_info *next;
N	int scrub;
N};
N
Nstruct mtd_erase_region_info {
N	uint64_t offset;			/* At which this region starts, from the beginning of the MTD */
N	u_int32_t erasesize;		/* For this region */
N	u_int32_t numblocks;		/* Number of blocks of erasesize in this region */
N	unsigned long *lockmap;		/* If keeping bitmap of locks */
N};
N
N/*
N * oob operation modes
N *
N * MTD_OOB_PLACE:	oob data are placed at the given offset
N * MTD_OOB_AUTO:	oob data are automatically placed at the free areas
N *			which are defined by the ecclayout
N * MTD_OOB_RAW:		mode to read raw data+oob in one chunk. The oob data
N *			is inserted into the data. Thats a raw image of the
N *			flash contents.
N */
Ntypedef enum {
N	MTD_OOB_PLACE,
N	MTD_OOB_AUTO,
N	MTD_OOB_RAW,
N} mtd_oob_mode_t;
N
N/**
N * struct mtd_oob_ops - oob operation operands
N * @mode:	operation mode
N *
N * @len:	number of data bytes to write/read
N *
N * @retlen:	number of data bytes written/read
N *
N * @ooblen:	number of oob bytes to write/read
N * @oobretlen:	number of oob bytes written/read
N * @ooboffs:	offset of oob data in the oob area (only relevant when
N *		mode = MTD_OOB_PLACE)
N * @datbuf:	data buffer - if NULL only oob data are read/written
N * @oobbuf:	oob data buffer
N *
N * Note, it is allowed to read more then one OOB area at one go, but not write.
N * The interface assumes that the OOB write requests program only one page's
N * OOB area.
N */
Nstruct mtd_oob_ops {
N	mtd_oob_mode_t	mode;
N	size_t		len;
N	size_t		retlen;
N	size_t		ooblen;
N	size_t		oobretlen;
N	uint32_t	ooboffs;
N	uint8_t		*datbuf;
N	uint8_t		*oobbuf;
N};
N
Nstruct mtd_info {
N	u_char type;
N	u_int32_t flags;
N	uint64_t size;	 /* Total size of the MTD */
N
N	/* "Major" erase size for the device. Naïve users may take this
N	 * to be the only erase size available, or may use the more detailed
N	 * information below if they desire
N	 */
N	u_int32_t erasesize;
N	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
N	 * though individual bits can be cleared), in case of NAND flash it is
N	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
N	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
N	 * Any driver registering a struct mtd_info must ensure a writesize of
N	 * 1 or larger.
N	 */
N	u_int32_t writesize;
N
N	u_int32_t oobsize;   /* Amount of OOB data per block (e.g. 16) */
N	u_int32_t oobavail;  /* Available OOB bytes per block */
N
N	/* Kernel-only stuff starts here. */
N	const char *name;
N	int index;
N
N	/* ecc layout structure pointer - read only ! */
N	struct nand_ecclayout *ecclayout;
N
N	/* Data for variable erase regions. If numeraseregions is zero,
N	 * it means that the whole device has erasesize as given above.
N	 */
N	int numeraseregions;
N	struct mtd_erase_region_info *eraseregions;
N
N	/*
N	 * Erase is an asynchronous operation.  Device drivers are supposed
N	 * to call instr->callback() whenever the operation completes, even
N	 * if it completes with a failure.
N	 * Callers are supposed to pass a callback function and wait for it
N	 * to be called before writing to the block.
N	 */
N	int (*erase) (struct mtd_info *mtd, struct erase_info *instr);
N
N	/* This stuff for eXecute-In-Place */
N	/* phys is optional and may be set to NULL */
N	int (*point) (struct mtd_info *mtd, loff_t from, size_t len,
N			size_t *retlen, void **virt, phys_addr_t *phys);
N
N	/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
N	void (*unpoint) (struct mtd_info *mtd, loff_t from, size_t len);
N
N
N	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
N
N	/* In blackbox flight recorder like scenarios we want to make successful
N	   writes in interrupt context. panic_write() is only intended to be
N	   called when its known the kernel is about to panic and we need the
N	   write to succeed. Since the kernel is not going to be running for much
N	   longer, this function can break locks and delay to ensure the write
N	   succeeds (but not sleep). */
N
N	int (*panic_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
N
N	int (*read_oob) (struct mtd_info *mtd, loff_t from,
N			 struct mtd_oob_ops *ops);
N	int (*write_oob) (struct mtd_info *mtd, loff_t to,
N			 struct mtd_oob_ops *ops);
N
N	/*
N	 * Methods to access the protection register area, present in some
N	 * flash devices. The user data is one time programmable but the
N	 * factory data is read only.
N	 */
N	int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
N	int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);
N	int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
N	int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);
N
N	/* Sync */
N	void (*sync) (struct mtd_info *mtd);
N
N	/* Chip-supported device locking */
N	int (*lock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);
N	int (*unlock) (struct mtd_info *mtd, loff_t ofs, uint64_t len);
N
N	/* Bad block management functions */
N	int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);
N	int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);
N
N	/* ECC status information */
N	struct mtd_ecc_stats ecc_stats;
N	/* Subpage shift (NAND) */
N	int subpage_sft;
N
N	void *priv;
N
N	struct module *owner;
N	int usecount;
N
N	/* If the driver is something smart, like UBI, it may need to maintain
N	 * its own reference counting. The below functions are only for driver.
N	 * The driver may register its callbacks. These callbacks are not
N	 * supposed to be called by MTD users */
N	int (*get_device) (struct mtd_info *mtd);
N	void (*put_device) (struct mtd_info *mtd);
N	u_char rw_oob;
N	u_char skipfirstblk;
N};
N
Nstatic __inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
N{
N	do_div(sz, mtd->erasesize);
X	(sz = sz/mtd->erasesize);
N	return sz;
N}
N
Nstatic __inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
N{
N	return do_div(sz, mtd->erasesize);
X	return (sz = sz/mtd->erasesize);
N}
N
N	/* Kernel-side ioctl definitions */
N
Nextern int add_mtd_device(struct mtd_info *mtd);
Nextern int del_mtd_device (struct mtd_info *mtd);
N
Nextern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
Nextern struct mtd_info *get_mtd_device_nm(const char *name);
N
Nextern void put_mtd_device(struct mtd_info *mtd);
Nextern void mtd_get_len_incl_bad(struct mtd_info *mtd, uint64_t offset,
N				 const uint64_t length, uint64_t *len_incl_bad,
N				 int *truncated);
N
Nvoid mtd_erase_callback(struct erase_info *instr);
N
N/*
N * Debugging macro and defines
N */
N#define MTD_DEBUG_LEVEL0	(0)	/* Quiet   */
N#define MTD_DEBUG_LEVEL1	(1)	/* Audible */
N#define MTD_DEBUG_LEVEL2	(2)	/* Loud    */
N#define MTD_DEBUG_LEVEL3	(3)	/* Noisy   */
N
N#ifdef CONFIG_MTD_DEBUG
S#define MTDDEBUG(n, args...)				\
S	do {						\
S		if (n <= CONFIG_MTD_DEBUG_VERBOSE)	\
S			sysprintf(KERN_INFO args);		\
S	} while(0)
X#define MTDDEBUG(n, args...)					do {								if (n <= CONFIG_MTD_DEBUG_VERBOSE)				sysprintf(KERN_INFO args);			} while(0)
N#else /* CONFIG_MTD_DEBUG */
N#define MTDDEBUG(n, args...)				\
N	do {						\
N		if (0)					\
N			sysprintf(args);		\
N	} while(0)
X#define MTDDEBUG(n, args...)					do {								if (0)								sysprintf(args);			} while(0)
N#endif /* CONFIG_MTD_DEBUG */
N
N#endif /* __MTD_MTD_H__ */
L 66 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "linux\nand.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 1
N/*
N *  linux/include/linux/mtd/nand.h
N *
N *  Copyright © 2000-2010 David Woodhouse <dwmw2@infradead.org>
N *                        Steven J. Hill <sjhill@realitydiluted.com>
N *		          Thomas Gleixner <tglx@linutronix.de>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N * Info:
N *	Contains standard defines and IDs for NAND flash devices
N *
N * Changelog:
N *	See git changelog.
N */
N#ifndef __LINUX_MTD_NAND_H
N#define __LINUX_MTD_NAND_H
N
N#include "config.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\config.h" 1
N#ifndef _LINUX_CONFIG_H
N#define _LINUX_CONFIG_H
N
N/* #include <linux/autoconf.h> */
N
N#endif
L 22 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 2
N
N#include "linux\mtd.h"
N#include "linux\bbm.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\bbm.h" 1
N/*
N *  linux/include/linux/mtd/bbm.h
N *
N *  NAND family Bad Block Management (BBM) header file
N *    - Bad Block Table (BBT) implementation
N *
N *  Copyright (c) 2005-2007 Samsung Electronics
N *  Kyungmin Park <kyungmin.park@samsung.com>
N *
N *  Copyright (c) 2000-2005
N *  Thomas Gleixner <tglx@linuxtronix.de>
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License as published by
N * the Free Software Foundation; either version 2 of the License, or
N * (at your option) any later version.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
N *
N */
N#ifndef __LINUX_MTD_BBM_H
N#define __LINUX_MTD_BBM_H
N
N/* The maximum number of NAND chips in an array */
N#ifndef CONFIG_SYS_NAND_MAX_CHIPS
N#define CONFIG_SYS_NAND_MAX_CHIPS	1
N#endif
N
N/**
N * struct nand_bbt_descr - bad block table descriptor
N * @param options	options for this descriptor
N * @param pages		the page(s) where we find the bbt, used with
N *			option BBT_ABSPAGE when bbt is searched,
N *			then we store the found bbts pages here.
N *			Its an array and supports up to 8 chips now
N * @param offs		offset of the pattern in the oob area of the page
N * @param veroffs	offset of the bbt version counter in the oob are of the page
N * @param version	version read from the bbt page during scan
N * @param len		length of the pattern, if 0 no pattern check is performed
N * @param maxblocks	maximum number of blocks to search for a bbt. This number of
N *			blocks is reserved at the end of the device
N *			where the tables are written.
N * @param reserved_block_code	if non-0, this pattern denotes a reserved
N *			(rather than bad) block in the stored bbt
N * @param pattern	pattern to identify bad block table or factory marked
N *			good / bad blocks, can be NULL, if len = 0
N *
N * Descriptor for the bad block table marker and the descriptor for the
N * pattern which identifies good and bad blocks. The assumption is made
N * that the pattern and the version count are always located in the oob area
N * of the first block.
N */
Nstruct nand_bbt_descr {
N	int options;
N	int pages[CONFIG_SYS_NAND_MAX_CHIPS];
X	int pages[1];
N	int offs;
N	int veroffs;
N	uint8_t version[CONFIG_SYS_NAND_MAX_CHIPS];
X	uint8_t version[1];
N	int len;
N	int maxblocks;
N	int reserved_block_code;
N	uint8_t *pattern;
N};
N
N/* Options for the bad block table descriptors */
N
N/* The number of bits used per block in the bbt on the device */
N#define NAND_BBT_NRBITS_MSK	0x0000000F
N#define NAND_BBT_1BIT		0x00000001
N#define NAND_BBT_2BIT		0x00000002
N#define NAND_BBT_4BIT		0x00000004
N#define NAND_BBT_8BIT		0x00000008
N/* The bad block table is in the last good block of the device */
N#define NAND_BBT_LASTBLOCK	0x00000010
N/* The bbt is at the given page, else we must scan for the bbt */
N#define NAND_BBT_ABSPAGE	0x00000020
N/* The bbt is at the given page, else we must scan for the bbt */
N#define NAND_BBT_SEARCH		0x00000040
N/* bbt is stored per chip on multichip devices */
N#define NAND_BBT_PERCHIP	0x00000080
N/* bbt has a version counter at offset veroffs */
N#define NAND_BBT_VERSION	0x00000100
N/* Create a bbt if none exists */
N#define NAND_BBT_CREATE		0x00000200
N/* Search good / bad pattern through all pages of a block */
N#define NAND_BBT_SCANALLPAGES	0x00000400
N/* Scan block empty during good / bad block scan */
N#define NAND_BBT_SCANEMPTY	0x00000800
N/* Write bbt if neccecary */
N#define NAND_BBT_WRITE		0x00001000
N/* Read and write back block contents when writing bbt */
N#define NAND_BBT_SAVECONTENT	0x00002000
N/* Search good / bad pattern on the first and the second page */
N#define NAND_BBT_SCAN2NDPAGE	0x00004000
N/* Search good / bad pattern on the last page of the eraseblock */
N#define NAND_BBT_SCANLASTPAGE	0x00008000
N/* Chip stores bad block marker on BOTH 1st and 6th bytes of OOB */
N#define NAND_BBT_SCANBYTE1AND6 0x00100000
N/* The nand_bbt_descr was created dynamicaly and must be freed */
N#define NAND_BBT_DYNAMICSTRUCT 0x00200000
N/* The bad block table does not OOB for marker */
N#define NAND_BBT_NO_OOB		0x00400000
N
N/* The maximum number of blocks to scan for a bbt */
N#define NAND_BBT_SCAN_MAXBLOCKS	4
N
N/*
N * Constants for oob configuration
N */
N#define ONENAND_BADBLOCK_POS	0
N
N/*
N * Bad block scanning errors
N */
N#define ONENAND_BBT_READ_ERROR          1
N#define ONENAND_BBT_READ_ECC_ERROR      2
N#define ONENAND_BBT_READ_FATAL_ERROR    4
N
N/**
N * struct bbt_info - [GENERIC] Bad Block Table data structure
N * @param bbt_erase_shift	[INTERN] number of address bits in a bbt entry
N * @param badblockpos		[INTERN] position of the bad block marker in the oob area
N * @param bbt			[INTERN] bad block table pointer
N * @param badblock_pattern	[REPLACEABLE] bad block scan pattern used for initial bad block scan
N * @param priv			[OPTIONAL] pointer to private bbm date
N */
Nstruct bbm_info {
N	int bbt_erase_shift;
N	int badblockpos;
N	int options;
N
N	uint8_t *bbt;
N
N	int (*isbad_bbt) (struct mtd_info * mtd, loff_t ofs, int allowbbt);
N
N	/* TODO Add more NAND specific fileds */
N	struct nand_bbt_descr *badblock_pattern;
N
N	void *priv;
N};
N
N/* OneNAND BBT interface */
Nextern int onenand_scan_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd);
Nextern int onenand_default_bbt (struct mtd_info *mtd);
N
N#endif				/* __LINUX_MTD_BBM_H */
L 25 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand.h" 2
N
N
Nstruct mtd_info;
Nstruct nand_flash_dev;
N/* Scan and identify a NAND device */
Nextern int nand_scan (struct mtd_info *mtd, int max_chips);
N/* Separate phases of nand_scan(), allowing board driver to intervene
N * and override command or ECC setup according to flash type */
Nextern int nand_scan_ident(struct mtd_info *mtd, int max_chips,
N			   const struct nand_flash_dev *table);
Nextern int nand_scan_tail(struct mtd_info *mtd);
N
N/* Free resources held by the NAND device */
Nextern void nand_release(struct mtd_info *mtd);
N
N/* Internal helper for board drivers which need to override command function */
Nextern void nand_wait_ready(struct mtd_info *mtd);
N
N/*
N * This constant declares the max. oobsize / page, which
N * is supported now. If you add a chip with bigger oobsize/page
N * adjust this accordingly.
N */
N#define NAND_MAX_OOBSIZE	576
N#define NAND_MAX_PAGESIZE	8192
N
N/*
N * Constants for hardware specific CLE/ALE/NCE function
N *
N * These are bits which can be or'ed to set/clear multiple
N * bits in one go.
N */
N/* Select the chip by setting nCE to low */
N#define NAND_NCE		0x01
N/* Select the command latch by setting CLE to high */
N#define NAND_CLE		0x02
N/* Select the address latch by setting ALE to high */
N#define NAND_ALE		0x04
N
N#define NAND_CTRL_CLE		(NAND_NCE | NAND_CLE)
N#define NAND_CTRL_ALE		(NAND_NCE | NAND_ALE)
N#define NAND_CTRL_CHANGE	0x80
N
N/*
N * Standard NAND flash commands
N */
N#define NAND_CMD_READ0		0
N#define NAND_CMD_READ1		1
N#define NAND_CMD_RNDOUT		5
N#define NAND_CMD_PAGEPROG	0x10
N#define NAND_CMD_READOOB	0x50
N#define NAND_CMD_ERASE1		0x60
N#define NAND_CMD_STATUS		0x70
N#define NAND_CMD_STATUS_MULTI	0x71
N#define NAND_CMD_SEQIN		0x80
N#define NAND_CMD_RNDIN		0x85
N#define NAND_CMD_READID		0x90
N#define NAND_CMD_ERASE2		0xd0
N#define NAND_CMD_PARAM		0xec
N#define NAND_CMD_RESET		0xff
N
N#define NAND_CMD_LOCK		0x2a
N#define NAND_CMD_LOCK_TIGHT	0x2c
N#define NAND_CMD_UNLOCK1	0x23
N#define NAND_CMD_UNLOCK2	0x24
N#define NAND_CMD_LOCK_STATUS	0x7a
N
N/* Extended commands for large page devices */
N#define NAND_CMD_READSTART	0x30
N#define NAND_CMD_RNDOUTSTART	0xE0
N#define NAND_CMD_CACHEDPROG	0x15
N
N/* Extended commands for AG-AND device */
N/*
N * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
N *       there is no way to distinguish that from NAND_CMD_READ0
N *       until the remaining sequence of commands has been completed
N *       so add a high order bit and mask it off in the command.
N */
N#define NAND_CMD_DEPLETE1	0x100
N#define NAND_CMD_DEPLETE2	0x38
N#define NAND_CMD_STATUS_MULTI	0x71
N#define NAND_CMD_STATUS_ERROR	0x72
N/* multi-bank error status (banks 0-3) */
N#define NAND_CMD_STATUS_ERROR0	0x73
N#define NAND_CMD_STATUS_ERROR1	0x74
N#define NAND_CMD_STATUS_ERROR2	0x75
N#define NAND_CMD_STATUS_ERROR3	0x76
N#define NAND_CMD_STATUS_RESET	0x7f
N#define NAND_CMD_STATUS_CLEAR	0xff
N
N#define NAND_CMD_NONE		-1
N
N/* Status bits */
N#define NAND_STATUS_FAIL	0x01
N#define NAND_STATUS_FAIL_N1	0x02
N#define NAND_STATUS_TRUE_READY	0x20
N#define NAND_STATUS_READY	0x40
N#define NAND_STATUS_WP		0x80
N
N/*
N * Constants for ECC_MODES
N */
Ntypedef enum {
N	NAND_ECC_NONE,
N	NAND_ECC_SOFT,
N	NAND_ECC_HW,
N	NAND_ECC_HW_SYNDROME,
N	NAND_ECC_HW_OOB_FIRST,
N	NAND_ECC_SOFT_BCH,
N} nand_ecc_modes_t;
N
N/*
N * Constants for Hardware ECC
N */
N/* Reset Hardware ECC for read */
N#define NAND_ECC_READ		0
N/* Reset Hardware ECC for write */
N#define NAND_ECC_WRITE		1
N/* Enable Hardware ECC before syndrom is read back from flash */
N#define NAND_ECC_READSYN	2
N
N/* Bit mask for flags passed to do_nand_read_ecc */
N#define NAND_GET_DEVICE		0x80
N
N
N/*
N * Option constants for bizarre disfunctionality and real
N * features.
N */
N/* Chip can not auto increment pages */
N#define NAND_NO_AUTOINCR	0x00000001
N/* Buswitdh is 16 bit */
N#define NAND_BUSWIDTH_16	0x00000002
N/* Device supports partial programming without padding */
N#define NAND_NO_PADDING		0x00000004
N/* Chip has cache program function */
N#define NAND_CACHEPRG		0x00000008
N/* Chip has copy back function */
N#define NAND_COPYBACK		0x00000010
N/*
N * AND Chip which has 4 banks and a confusing page / block
N * assignment. See Renesas datasheet for further information.
N */
N#define NAND_IS_AND		0x00000020
N/*
N * Chip has a array of 4 pages which can be read without
N * additional ready /busy waits.
N */
N#define NAND_4PAGE_ARRAY	0x00000040
N/*
N * Chip requires that BBT is periodically rewritten to prevent
N * bits from adjacent blocks from 'leaking' in altering data.
N * This happens with the Renesas AG-AND chips, possibly others.
N */
N#define BBT_AUTO_REFRESH	0x00000080
N/*
N * Chip does not require ready check on read. true
N * for all large page devices, as they do not support
N * autoincrement.
N */
N#define NAND_NO_READRDY		0x00000100
N/* Chip does not allow subpage writes */
N#define NAND_NO_SUBPAGE_WRITE	0x00000200
N
N/* Device is one of 'new' xD cards that expose fake nand command set */
N#define NAND_BROKEN_XD		0x00000400
N
N/* Device behaves just like nand, but is readonly */
N#define NAND_ROM		0x00000800
N
N/* Device supports subpage reads */
N#define NAND_SUBPAGE_READ       0x00001000
N
N/* Options valid for Samsung large page devices */
N#define NAND_SAMSUNG_LP_OPTIONS \
N	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
X#define NAND_SAMSUNG_LP_OPTIONS 	(NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK)
N
N/* Macros to identify the above */
N#define NAND_CANAUTOINCR(chip) (!(chip->options & NAND_NO_AUTOINCR))
N#define NAND_MUST_PAD(chip) (!(chip->options & NAND_NO_PADDING))
N#define NAND_HAS_CACHEPROG(chip) ((chip->options & NAND_CACHEPRG))
N#define NAND_HAS_COPYBACK(chip) ((chip->options & NAND_COPYBACK))
N#define NAND_HAS_SUBPAGE_READ(chip) ((chip->options & NAND_SUBPAGE_READ))
N
N/* Non chip related options */
N/*
N * Use a flash based bad block table. OOB identifier is saved in OOB area.
N * This option is passed to the default bad block table function.
N */
N#define NAND_USE_FLASH_BBT	0x00010000
N/* This option skips the bbt scan during initialization. */
N#define NAND_SKIP_BBTSCAN	0x00020000
N/*
N * This option is defined if the board driver allocates its own buffers
N * (e.g. because it needs them DMA-coherent).
N */
N#define NAND_OWN_BUFFERS	0x00040000
N/* Chip may not exist, so silence any errors in scan */
N#define NAND_SCAN_SILENT_NODEV	0x00080000
N/*
N * If passed additionally to NAND_USE_FLASH_BBT then BBT code will not touch
N * the OOB area.
N */
N#define NAND_USE_FLASH_BBT_NO_OOB	0x00800000
N/* Create an empty BBT with no vendor information if the BBT is available */
N#define NAND_CREATE_EMPTY_BBT		0x01000000
N
N/* Options set by nand scan */
N/* bbt has already been read */
N#define NAND_BBT_SCANNED	0x40000000
N/* Nand scan has allocated controller struct */
N#define NAND_CONTROLLER_ALLOC	0x80000000
N
N/* Cell info constants */
N#define NAND_CI_CHIPNR_MSK	0x03
N#define NAND_CI_CELLTYPE_MSK	0x0C
N
N/* Keep gcc happy */
Nstruct nand_chip;
N
Nstruct nand_onfi_params {
N	/* rev info and features block */
N	/* 'O' 'N' 'F' 'I'  */
N	u8 sig[4];
N	__le16 revision;
N	__le16 features;
N	__le16 opt_cmd;
N	u8 reserved[22];
N
N	/* manufacturer information block */
N	char manufacturer[12];
N	char model[20];
N	u8 jedec_id;
N	__le16 date_code;
N	u8 reserved2[13];
N
N	/* memory organization block */
N	__le32 byte_per_page;
N	__le16 spare_bytes_per_page;
N	__le32 data_bytes_per_ppage;
N	__le16 spare_bytes_per_ppage;
N	__le32 pages_per_block;
N	__le32 blocks_per_lun;
N	u8 lun_count;
N	u8 addr_cycles;
N	u8 bits_per_cell;
N	__le16 bb_per_lun;
N	__le16 block_endurance;
N	u8 guaranteed_good_blocks;
N	__le16 guaranteed_block_endurance;
N	u8 programs_per_page;
N	u8 ppage_attr;
N	u8 ecc_bits;
N	u8 interleaved_bits;
N	u8 interleaved_ops;
N	u8 reserved3[13];
N
N	/* electrical parameter block */
N	u8 io_pin_capacitance_max;
N	__le16 async_timing_mode;
N	__le16 program_cache_timing_mode;
N	__le16 t_prog;
N	__le16 t_bers;
N	__le16 t_r;
N	__le16 t_ccs;
N	__le16 src_sync_timing_mode;
N	__le16 src_ssync_features;
N	__le16 clk_pin_capacitance_typ;
N	__le16 io_pin_capacitance_typ;
N	__le16 input_pin_capacitance_typ;
N	u8 input_pin_capacitance_max;
N	u8 driver_strenght_support;
N	__le16 t_int_r;
N	__le16 t_ald;
N	u8 reserved4[7];
N
N	/* vendor */
N	u8 reserved5[90];
N
N	__le16 crc;
N} __attribute__((packed));
N
N#define ONFI_CRC_BASE	0x4F4E
N
N/**
N * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
N * @lock:               protection lock
N * @active:		the mtd device which holds the controller currently
N * @wq:			wait queue to sleep on if a NAND operation is in
N *			progress used instead of the per chip wait queue
N *			when a hw controller is available.
N */
Nstruct nand_hw_control {
N/* XXX U-BOOT XXX */
N#if 0
S	spinlock_t	 lock;
S	wait_queue_head_t wq;
N#endif
N	struct nand_chip *active;
N};
N
N/**
N * struct nand_ecc_ctrl - Control structure for ecc
N * @mode:	ecc mode
N * @steps:	number of ecc steps per page
N * @size:	data bytes per ecc step
N * @bytes:	ecc bytes per step
N * @total:	total number of ecc bytes per page
N * @prepad:	padding information for syndrome based ecc generators
N * @postpad:	padding information for syndrome based ecc generators
N * @layout:	ECC layout control struct pointer
N * @priv:	pointer to private ecc control data
N * @hwctl:	function to control hardware ecc generator. Must only
N *		be provided if an hardware ECC is available
N * @calculate:	function for ecc calculation or readback from ecc hardware
N * @correct:	function for ecc correction, matching to ecc generator (sw/hw)
N * @read_page_raw:	function to read a raw page without ECC
N * @write_page_raw:	function to write a raw page without ECC
N * @read_page:	function to read a page according to the ecc generator
N *		requirements.
N * @read_subpage:	function to read parts of the page covered by ECC.
N * @write_page:	function to write a page according to the ecc generator
N *		requirements.
N * @read_oob:	function to read chip OOB data
N * @write_oob:	function to write chip OOB data
N */
Nstruct nand_ecc_ctrl {
N	nand_ecc_modes_t mode;
N	int steps;
N	int size;
N	int bytes;
N	int total;
N	int prepad;
N	int postpad;
N	struct nand_ecclayout	*layout;
N	void *priv;
N	void (*hwctl)(struct mtd_info *mtd, int mode);
N	int (*calculate)(struct mtd_info *mtd, const uint8_t *dat,
N			uint8_t *ecc_code);
N	int (*correct)(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
N			uint8_t *calc_ecc);
N	int (*read_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint8_t *buf, int page);
N	void (*write_page_raw)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf);
N	int (*read_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint8_t *buf, int page);
N	int (*read_subpage)(struct mtd_info *mtd, struct nand_chip *chip,
N			uint32_t offs, uint32_t len, uint8_t *buf);
N	void (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf);
N	int (*read_oob)(struct mtd_info *mtd, struct nand_chip *chip, int page,
N			int sndcmd);
N	int (*write_oob)(struct mtd_info *mtd, struct nand_chip *chip,
N			int page);
N};
N
N/**
N * struct nand_buffers - buffer structure for read/write
N * @ecccalc:	buffer for calculated ecc
N * @ecccode:	buffer for ecc read from flash
N * @databuf:	buffer for data - dynamically sized
N *
N * Do not change the order of buffers. databuf and oobrbuf must be in
N * consecutive order.
N */
Nstruct nand_buffers {
Nuint8_t ecccalc[NAND_MAX_OOBSIZE];
Xuint8_t ecccalc[576];
Nuint8_t ecccode[NAND_MAX_OOBSIZE];
Xuint8_t ecccode[576];
Nuint8_t databuf[NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE];
Xuint8_t databuf[8192 + 576];
N};
N
N/**
N * struct nand_chip - NAND Private Flash Chip Data
N * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
N *			flash device
N * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
N *			flash device.
N * @read_byte:		[REPLACEABLE] read one byte from the chip
N * @read_word:		[REPLACEABLE] read one word from the chip
N * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
N * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
N * @verify_buf:		[REPLACEABLE] verify buffer contents against the chip
N *			data.
N * @select_chip:	[REPLACEABLE] select chip nr
N * @block_bad:		[REPLACEABLE] check, if the block is bad
N * @block_markbad:	[REPLACEABLE] mark the block bad
N * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
N *			ALE/CLE/nCE. Also used to write command and address
N * @init_size:		[BOARDSPECIFIC] hardwarespecific function for setting
N *			mtd->oobsize, mtd->writesize and so on.
N *			@id_data contains the 8 bytes values of NAND_CMD_READID.
N *			Return with the bus width.
N * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accesing
N *			device ready/busy line. If set to NULL no access to
N *			ready/busy is available and the ready/busy information
N *			is read from the chip status register.
N * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
N *			commands to the chip.
N * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
N *			ready.
N * @ecc:		[BOARDSPECIFIC] ecc control ctructure
N * @buffers:		buffer structure for read/write
N * @hwcontrol:		platform-specific hardware control structure
N * @ops:		oob operation operands
N * @erase_cmd:		[INTERN] erase command write function, selectable due
N *			to AND support.
N * @scan_bbt:		[REPLACEABLE] function to scan bad block table
N * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
N *			data from array to read regs (tR).
N * @state:		[INTERN] the current state of the NAND device
N * @oob_poi:		poison value buffer
N * @page_shift:		[INTERN] number of address bits in a page (column
N *			address bits).
N * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
N * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
N * @chip_shift:		[INTERN] number of address bits in one chip
N * @options:		[BOARDSPECIFIC] various chip options. They can partly
N *			be set to inform nand_scan about special functionality.
N *			See the defines for further explanation.
N * @badblockpos:	[INTERN] position of the bad block marker in the oob
N *			area.
N * @badblockbits:	[INTERN] number of bits to left-shift the bad block
N *			number
N * @cellinfo:		[INTERN] MLC/multichip data from chip ident
N * @numchips:		[INTERN] number of physical chips
N * @chipsize:		[INTERN] the size of one chip for multichip arrays
N * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
N * @pagebuf:		[INTERN] holds the pagenumber which is currently in
N *			data_buf.
N * @subpagesize:	[INTERN] holds the subpagesize
N * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
N *			non 0 if ONFI supported.
N * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
N *			supported, 0 otherwise.
N * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
N * @bbt:		[INTERN] bad block table pointer
N * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
N *			lookup.
N * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
N * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
N *			bad block scan.
N * @controller:		[REPLACEABLE] a pointer to a hardware controller
N *			structure which is shared among multiple independend
N *			devices.
N * @priv:		[OPTIONAL] pointer to private chip date
N * @errstat:		[OPTIONAL] hardware specific function to perform
N *			additional error status checks (determine if errors are
N *			correctable).
N * @write_page:		[REPLACEABLE] High-level page write function
N */
N
Nstruct nand_chip {
N	void __iomem *IO_ADDR_R;
X	void  *IO_ADDR_R;
N	void __iomem *IO_ADDR_W;
X	void  *IO_ADDR_W;
N
N	uint8_t (*read_byte)(struct mtd_info *mtd);
N	u16 (*read_word)(struct mtd_info *mtd);
N	void (*write_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
N	void (*read_buf)(struct mtd_info *mtd, uint8_t *buf, int len);
N	int (*verify_buf)(struct mtd_info *mtd, const uint8_t *buf, int len);
N	void (*select_chip)(struct mtd_info *mtd, int chip);
N	int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);
N	int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);
N	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
N	int (*init_size)(struct mtd_info *mtd, struct nand_chip *this,
N			u8 *id_data);
N	int (*dev_ready)(struct mtd_info *mtd);
N	void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column,
N			int page_addr);
N	int(*waitfunc)(struct mtd_info *mtd, struct nand_chip *this);
N	void (*erase_cmd)(struct mtd_info *mtd, int page);
N	int (*scan_bbt)(struct mtd_info *mtd);
N	int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state,
N			int status, int page);
N	int (*write_page)(struct mtd_info *mtd, struct nand_chip *chip,
N			const uint8_t *buf, int page, int cached, int raw);
N
N	int chip_delay;
N	unsigned int options;
N
N	int page_shift;
N	int phys_erase_shift;
N	int bbt_erase_shift;
N	int chip_shift;
N	int numchips;
N	uint64_t chipsize;
N	int pagemask;
N	int pagebuf;
N	int subpagesize;
N	uint8_t cellinfo;
N	int badblockpos;
N	int badblockbits;
N
N	int onfi_version;
N#ifdef CONFIG_SYS_NAND_ONFI_DETECTION
S	struct nand_onfi_params onfi_params;
N#endif
N
N	int state;
N
N	uint8_t *oob_poi;
N	struct nand_hw_control *controller;
N	struct nand_ecclayout *ecclayout;
N
N	struct nand_ecc_ctrl ecc;
N	struct nand_buffers *buffers;
N	struct nand_hw_control hwcontrol;
N
N	struct mtd_oob_ops ops;
N
N	uint8_t *bbt;
N	struct nand_bbt_descr *bbt_td;
N	struct nand_bbt_descr *bbt_md;
N
N	struct nand_bbt_descr *badblock_pattern;
N
N	void *priv;
N};
N
N/*
N * NAND Flash Manufacturer ID Codes
N */
N#define NAND_MFR_TOSHIBA	0x98
N#define NAND_MFR_SAMSUNG	0xec
N#define NAND_MFR_FUJITSU	0x04
N#define NAND_MFR_NATIONAL	0x8f
N#define NAND_MFR_RENESAS	0x07
N#define NAND_MFR_STMICRO	0x20
N#define NAND_MFR_HYNIX		0xad
N#define NAND_MFR_MICRON		0x2c
N#define NAND_MFR_AMD		0x01
N
N/**
N * struct nand_flash_dev - NAND Flash Device ID Structure
N * @name:	Identify the device type
N * @id:		device ID code
N * @pagesize:	Pagesize in bytes. Either 256 or 512 or 0
N *		If the pagesize is 0, then the real pagesize
N *		and the eraseize are determined from the
N *		extended id bytes in the chip
N * @erasesize:	Size of an erase block in the flash device.
N * @chipsize:	Total chipsize in Mega Bytes
N * @options:	Bitfield to store chip relevant options
N */
Nstruct nand_flash_dev {
N	char *name;
N	int id;
N	unsigned long pagesize;
N	unsigned long chipsize;
N	unsigned long erasesize;
N	unsigned long options;
N};
N
N/**
N * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
N * @name:	Manufacturer name
N * @id:		manufacturer ID code of device.
N*/
Nstruct nand_manufacturers {
N	int id;
N	char *name;
N};
N
Nextern const struct nand_flash_dev nand_flash_ids[];
Nextern const struct nand_manufacturers nand_manuf_ids[];
N
Nextern int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd);
Nextern int nand_update_bbt(struct mtd_info *mtd, loff_t offs);
Nextern int nand_default_bbt(struct mtd_info *mtd);
Nextern int nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt);
Nextern int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
N			   int allowbbt);
Nextern int nand_do_read(struct mtd_info *mtd, loff_t from, size_t len,
N			size_t *retlen, uint8_t *buf);
N
N/*
N* Constants for oob configuration
N*/
N#define NAND_SMALL_BADBLOCK_POS		5
N#define NAND_LARGE_BADBLOCK_POS		0
N
N/**
N * struct platform_nand_chip - chip level device structure
N * @nr_chips:		max. number of chips to scan for
N * @chip_offset:	chip number offset
N * @nr_partitions:	number of partitions pointed to by partitions (or zero)
N * @partitions:		mtd partition list
N * @chip_delay:		R/B delay value in us
N * @options:		Option flags, e.g. 16bit buswidth
N * @ecclayout:		ecc layout info structure
N * @part_probe_types:	NULL-terminated array of probe types
N * @priv:		hardware controller specific settings
N */
Nstruct platform_nand_chip {
N	int nr_chips;
N	int chip_offset;
N	int nr_partitions;
N	struct mtd_partition *partitions;
N	struct nand_ecclayout *ecclayout;
N	int chip_delay;
N	unsigned int options;
N	const char **part_probe_types;
N	void *priv;
N};
N
N/* Keep gcc happy */
Nstruct platform_device;
N
N/**
N * struct platform_nand_ctrl - controller level device structure
N * @hwcontrol:		platform specific hardware control structure
N * @dev_ready:		platform specific function to read ready/busy pin
N * @select_chip:	platform specific chip select function
N * @cmd_ctrl:		platform specific function for controlling
N *			ALE/CLE/nCE. Also used to write command and address
N * @priv:		private data to transport driver specific settings
N *
N * All fields are optional and depend on the hardware driver requirements
N */
Nstruct platform_nand_ctrl {
N	void (*hwcontrol)(struct mtd_info *mtd, int cmd);
N	int (*dev_ready)(struct mtd_info *mtd);
N	void (*select_chip)(struct mtd_info *mtd, int chip);
N	void (*cmd_ctrl)(struct mtd_info *mtd, int dat, unsigned int ctrl);
N	void *priv;
N};
N
N/**
N * struct platform_nand_data - container structure for platform-specific data
N * @chip:		chip level chip structure
N * @ctrl:		controller level device structure
N */
Nstruct platform_nand_data {
N	struct platform_nand_chip chip;
N	struct platform_nand_ctrl ctrl;
N};
N
N/* Some helpers to access the data structures */
Nstatic __inline
Nstruct platform_nand_chip *get_platform_nandchip(struct mtd_info *mtd)
N{
N	struct nand_chip *chip = mtd->priv;
N
N	return chip->priv;
N}
N
N/* Standard NAND functions from nand_base.c */
Nvoid nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len);
Nvoid nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len);
Nvoid nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len);
Nvoid nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len);
Nuint8_t nand_read_byte(struct mtd_info *mtd);
N
N#endif /* __LINUX_MTD_NAND_H */
L 67 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "linux\nand_ecc.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\nand_ecc.h" 1
N/*
N *  drivers/mtd/nand_ecc.h
N *
N *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
N *
N * This program is free software; you can redistribute it and/or modify
N * it under the terms of the GNU General Public License version 2 as
N * published by the Free Software Foundation.
N *
N * This file is the header for the ECC algorithm.
N */
N
N#ifndef __MTD_NAND_ECC_H__
N#define __MTD_NAND_ECC_H__
N
Nstruct mtd_info;
N
N/*
N * Calculate 3 byte ECC code for 256 byte block
N */
Nint nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code);
N
N/*
N * Detect and correct a 1 bit error for 256 byte block
N */
Nint nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc);
N
N#endif /* __MTD_NAND_ECC_H__ */
L 68 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "linux\bitops.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\bitops.h" 1
N#ifndef _LINUX_BITOPS_H
N#define _LINUX_BITOPS_H
N
N#include "asm/types.h"
N
N/*
N * ffs: find first bit set. This is defined the same way as
N * the libc and compiler builtin ffs routines, therefore
N * differs in spirit from the above ffz (man ffs).
N */
N
Nstatic __inline int generic_ffs(int x)
N{
N	int r = 1;
N
N	if (!x)
N		return 0;
N	if (!(x & 0xffff)) {
N		x >>= 16;
N		r += 16;
N	}
N	if (!(x & 0xff)) {
N		x >>= 8;
N		r += 8;
N	}
N	if (!(x & 0xf)) {
N		x >>= 4;
N		r += 4;
N	}
N	if (!(x & 3)) {
N		x >>= 2;
N		r += 2;
N	}
N	if (!(x & 1)) {
N		x >>= 1;
N		r += 1;
N	}
N	return r;
N}
N
N/**
N * fls - find last (most-significant) bit set
N * @x: the word to search
N *
N * This is defined the same way as ffs.
N * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
N */
Nstatic __inline int generic_fls(int x)
N{
N	int r = 32;
N
N	if (!x)
N		return 0;
N	if (!(x & 0xffff0000u)) {
N		x <<= 16;
N		r -= 16;
N	}
N	if (!(x & 0xff000000u)) {
N		x <<= 8;
N		r -= 8;
N	}
N	if (!(x & 0xf0000000u)) {
N		x <<= 4;
N		r -= 4;
N	}
N	if (!(x & 0xc0000000u)) {
N		x <<= 2;
N		r -= 2;
N	}
N	if (!(x & 0x80000000u)) {
N		x <<= 1;
N		r -= 1;
N	}
N	return r;
N}
N
N
N/*
N * hweightN: returns the hamming weight (i.e. the number
N * of bits set) of a N-bit word
N */
N
Nstatic __inline unsigned int generic_hweight32(unsigned int w)
N{
N	unsigned int res = (w & 0x55555555) + ((w >> 1) & 0x55555555);
N	res = (res & 0x33333333) + ((res >> 2) & 0x33333333);
N	res = (res & 0x0F0F0F0F) + ((res >> 4) & 0x0F0F0F0F);
N	res = (res & 0x00FF00FF) + ((res >> 8) & 0x00FF00FF);
N	return (res & 0x0000FFFF) + ((res >> 16) & 0x0000FFFF);
N}
N
Nstatic __inline unsigned int generic_hweight16(unsigned int w)
N{
N	unsigned int res = (w & 0x5555) + ((w >> 1) & 0x5555);
N	res = (res & 0x3333) + ((res >> 2) & 0x3333);
N	res = (res & 0x0F0F) + ((res >> 4) & 0x0F0F);
N	return (res & 0x00FF) + ((res >> 8) & 0x00FF);
N}
N
Nstatic __inline unsigned int generic_hweight8(unsigned int w)
N{
N	unsigned int res = (w & 0x55) + ((w >> 1) & 0x55);
N	res = (res & 0x33) + ((res >> 2) & 0x33);
N	return (res & 0x0F) + ((res >> 4) & 0x0F);
N}
N
N#define BITS_PER_LONG 32
N#define BIT_MASK(nr)		(1UL << ((nr) % BITS_PER_LONG))
N#define BIT_WORD(nr)		((nr) / BITS_PER_LONG)
N
N#include "asm/bitops.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm/bitops.h" 1
N/*
N * Copyright 1995, Russell King.
N * Various bits and pieces copyrights include:
N *  Linus Torvalds (test_bit).
N *
N * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
N *
N * Please note that the code in this file should never be included
N * from user space.  Many of these are not implemented in assembler
N * since they would be too costly.  Also, they require priviledged
N * instructions (which are not available from user mode) to ensure
N * that they are atomic.
N */
N
N#ifndef __ASM_ARM_BITOPS_H
N#define __ASM_ARM_BITOPS_H
N
N
N/*
N * hweightN: returns the hamming weight (i.e. the number
N * of bits set) of a N-bit word
N */
N
N#define hweight32(x) generic_hweight32(x)
N#define hweight16(x) generic_hweight16(x)
N#define hweight8(x) generic_hweight8(x)
N
N
N#ifdef __KERNEL__
S
S#include <asm/proc/system.h>
S
S#define smp_mb__before_clear_bit()	do { } while (0)
S#define smp_mb__after_clear_bit()	do { } while (0)
S
S/*
S * Function prototypes to keep gcc -Wall happy.
S */
Sextern void set_bit(int nr, volatile void * addr);
S
Sextern void clear_bit(int nr, volatile void * addr);
S
Sextern void change_bit(int nr, volatile void * addr);
S
Sstatic __inline void __change_bit(int nr, volatile void *addr)
S{
S	unsigned long mask = BIT_MASK(nr);
S	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
S
S	*p ^= mask;
S}
S
Sstatic __inline int __test_and_set_bit(int nr, volatile void *addr)
S{
S	unsigned long mask = BIT_MASK(nr);
S	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
S	unsigned long old = *p;
S
S	*p = old | mask;
S	return (old & mask) != 0;
S}
S
Sstatic inline int test_and_set_bit(int nr, volatile void * addr)
S{
S	unsigned long flags;
S	int out;
S
S	local_irq_save(flags);
S	out = __test_and_set_bit(nr, addr);
S	local_irq_restore(flags);
S
S	return out;
S}
S
Sstatic inline int __test_and_clear_bit(int nr, volatile void *addr)
S{
S	unsigned long mask = BIT_MASK(nr);
S	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
S	unsigned long old = *p;
S
S	*p = old & ~mask;
S	return (old & mask) != 0;
S}
S
Sstatic inline int test_and_clear_bit(int nr, volatile void * addr)
S{
S	unsigned long flags;
S	int out;
S
S	local_irq_save(flags);
S	out = __test_and_clear_bit(nr, addr);
S	local_irq_restore(flags);
S
S	return out;
S}
S
Sextern int test_and_change_bit(int nr, volatile void * addr);
S
Sstatic inline int __test_and_change_bit(int nr, volatile void *addr)
S{
S	unsigned long mask = BIT_MASK(nr);
S	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
S	unsigned long old = *p;
S
S	*p = old ^ mask;
S	return (old & mask) != 0;
S}
S
Sextern int find_first_zero_bit(void * addr, unsigned size);
Sextern int find_next_zero_bit(void * addr, int size, int offset);
S
S/*
S * This routine doesn't need to be atomic.
S */
Sstatic inline int test_bit(int nr, const void * addr)
S{
S    return ((unsigned char *) addr)[nr >> 3] & (1U << (nr & 7));
S}
S
Sstatic inline int __ilog2(unsigned int x)
S{
S	return generic_fls(x) - 1;
S}
S
S/*
S * ffz = Find First Zero in word. Undefined if no zero exists,
S * so code should check against ~0UL first..
S */
Sstatic inline unsigned long ffz(unsigned long word)
S{
S	int k;
S
S	word = ~word;
S	k = 31;
S	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
S	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
S	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
S	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
S	if (word & 0x40000000) { k -= 1; }
S	return k;
S}
S
S/*
S * hweightN: returns the hamming weight (i.e. the number
S * of bits set) of a N-bit word
S */
S
S#define hweight32(x) generic_hweight32(x)
S#define hweight16(x) generic_hweight16(x)
S#define hweight8(x) generic_hweight8(x)
S
S#define ext2_set_bit			test_and_set_bit
S#define ext2_clear_bit			test_and_clear_bit
S#define ext2_test_bit			test_bit
S#define ext2_find_first_zero_bit	find_first_zero_bit
S#define ext2_find_next_zero_bit		find_next_zero_bit
S
S/* Bitmap functions for the minix filesystem. */
S#define minix_test_and_set_bit(nr,addr)	test_and_set_bit(nr,addr)
S#define minix_set_bit(nr,addr)		set_bit(nr,addr)
S#define minix_test_and_clear_bit(nr,addr)	test_and_clear_bit(nr,addr)
S#define minix_test_bit(nr,addr)		test_bit(nr,addr)
S#define minix_find_first_zero_bit(addr,size)	find_first_zero_bit(addr,size)
S
N#endif /* __KERNEL__ */
N
N#endif /* _ARM_BITOPS_H */
L 112 "..\..\common\src\BSP\ThirdParty\yaffs2\include\linux\bitops.h" 2
N
N/* linux/include/asm-generic/bitops/non-atomic.h */
N
N#ifndef PLATFORM__SET_BIT
N# define __set_bit generic_set_bit
N#endif
N
N#ifndef PLATFORM__CLEAR_BIT
N# define __clear_bit generic_clear_bit
N#endif
N
N#ifndef PLATFORM_FFS
N# define ffs generic_ffs
N#endif
N
N#ifndef PLATFORM_FLS
N# define fls generic_fls
N#endif
N
N/**
N * __set_bit - Set a bit in memory
N * @nr: the bit to set
N * @addr: the address to start counting from
N *
N * Unlike set_bit(), this function is non-atomic and may be reordered.
N * If it's called on the same region of memory simultaneously, the effect
N * may be that only one operation succeeds.
N */
Nstatic __inline void generic_set_bit(int nr, volatile unsigned long *addr)
N{
N	unsigned long mask = BIT_MASK(nr);
X	unsigned long mask = (1UL << ((nr) % 32));
N	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
X	unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
N
N	*p  |= mask;
N}
N
Nstatic __inline void generic_clear_bit(int nr, volatile unsigned long *addr)
N{
N	unsigned long mask = BIT_MASK(nr);
X	unsigned long mask = (1UL << ((nr) % 32));
N	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
X	unsigned long *p = ((unsigned long *)addr) + ((nr) / 32);
N
N	*p &= ~mask;
N}
N
N#endif
L 69 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N
N#include "asm\errno.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\include\asm\errno.h" 1
N/*
N * U-boot - errno.h Error number defines
N *
N * Copyright (c) 2005-2007 Analog Devices Inc.
N *
N * See file CREDITS for list of people who contributed to this
N * project.
N *
N * This program is free software; you can redistribute it and/or
N * modify it under the terms of the GNU General Public License as
N * published by the Free Software Foundation; either version 2 of
N * the License, or (at your option) any later version.
N *
N * This program is distributed in the hope that it will be useful,
N * but WITHOUT ANY WARRANTY; without even the implied warranty of
N * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N * GNU General Public License for more details.
N *
N * You should have received a copy of the GNU General Public License
N * along with this program; if not, write to the Free Software
N * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
N * MA 02110-1301 USA
N */
N
N#ifndef _GENERIC_ERRNO_H
N#define _GENERIC_ERRNO_H
N
N#define	EPERM		1	/* Operation not permitted */
N#define	ENOENT		2	/* No such file or directory */
N#define	ESRCH		3	/* No such process */
N#define	EINTR		4	/* Interrupted system call */
N#define	EIO		5	/* I/O error */
N#define	ENXIO		6	/* No such device or address */
N#define	E2BIG		7	/* Argument list too long */
N#define	ENOEXEC		8	/* Exec format error */
N#define	EBADF		9	/* Bad file number */
N#define	ECHILD		10	/* No child processes */
N#define	EAGAIN		11	/* Try again */
N#define	ENOMEM		12	/* Out of memory */
N#define	EACCES		13	/* Permission denied */
N#define	EFAULT		14	/* Bad address */
N#define	ENOTBLK		15	/* Block device required */
N#define	EBUSY		16	/* Device or resource busy */
N#define	EEXIST		17	/* File exists */
N#define	EXDEV		18	/* Cross-device link */
N#define	ENODEV		19	/* No such device */
N#define	ENOTDIR		20	/* Not a directory */
N#define	EISDIR		21	/* Is a directory */
N#define	EINVAL		22	/* Invalid argument */
N#define	ENFILE		23	/* File table overflow */
N#define	EMFILE		24	/* Too many open files */
N#define	ENOTTY		25	/* Not a typewriter */
N#define	ETXTBSY		26	/* Text file busy */
N#define	EFBIG		27	/* File too large */
N#define	ENOSPC		28	/* No space left on device */
N#define	ESPIPE		29	/* Illegal seek */
N#define	EROFS		30	/* Read-only file system */
N#define	EMLINK		31	/* Too many links */
N#define	EPIPE		32	/* Broken pipe */
N#define	EDOM		33	/* Math argument out of domain of func */
N#define	ERANGE		34	/* Math result not representable */
N#define	EDEADLK		35	/* Resource deadlock would occur */
N#define	ENAMETOOLONG	36	/* File name too long */
N#define	ENOLCK		37	/* No record locks available */
N#define	ENOSYS		38	/* Function not implemented */
N#define	ENOTEMPTY	39	/* Directory not empty */
N#define	ELOOP		40	/* Too many symbolic links encountered */
N#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
N#define	ENOMSG		42	/* No message of desired type */
N#define	EIDRM		43	/* Identifier removed */
N#define	ECHRNG		44	/* Channel number out of range */
N#define	EL2NSYNC	45	/* Level 2 not synchronized */
N#define	EL3HLT		46	/* Level 3 halted */
N#define	EL3RST		47	/* Level 3 reset */
N#define	ELNRNG		48	/* Link number out of range */
N#define	EUNATCH		49	/* Protocol driver not attached */
N#define	ENOCSI		50	/* No CSI structure available */
N#define	EL2HLT		51	/* Level 2 halted */
N#define	EBADE		52	/* Invalid exchange */
N#define	EBADR		53	/* Invalid request descriptor */
N#define	EXFULL		54	/* Exchange full */
N#define	ENOANO		55	/* No anode */
N#define	EBADRQC		56	/* Invalid request code */
N#define	EBADSLT		57	/* Invalid slot */
N
N#define	EDEADLOCK	EDEADLK
N
N#define	EBFONT		59	/* Bad font file format */
N#define	ENOSTR		60	/* Device not a stream */
N#define	ENODATA		61	/* No data available */
N#define	ETIME		62	/* Timer expired */
N#define	ENOSR		63	/* Out of streams resources */
N#define	ENONET		64	/* Machine is not on the network */
N#define	ENOPKG		65	/* Package not installed */
N#define	EREMOTE		66	/* Object is remote */
N#define	ENOLINK		67	/* Link has been severed */
N#define	EADV		68	/* Advertise error */
N#define	ESRMNT		69	/* Srmount error */
N#define	ECOMM		70	/* Communication error on send */
N#define	EPROTO		71	/* Protocol error */
N#define	EMULTIHOP	72	/* Multihop attempted */
N#define	EDOTDOT		73	/* RFS specific error */
N#define	EBADMSG		74	/* Not a data message */
N#define	EOVERFLOW	75	/* Value too large for defined data type */
N#define	ENOTUNIQ	76	/* Name not unique on network */
N#define	EBADFD		77	/* File descriptor in bad state */
N#define	EREMCHG		78	/* Remote address changed */
N#define	ELIBACC		79	/* Can not access a needed shared library */
N#define	ELIBBAD		80	/* Accessing a corrupted shared library */
N#define	ELIBSCN		81	/* .lib section in a.out corrupted */
N#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
N#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
N#define	EILSEQ		84	/* Illegal byte sequence */
N#define	ERESTART	85	/* Interrupted system call should be restarted */
N#define	ESTRPIPE	86	/* Streams pipe error */
N#define	EUSERS		87	/* Too many users */
N#define	ENOTSOCK	88	/* Socket operation on non-socket */
N#define	EDESTADDRREQ	89	/* Destination address required */
N#define	EMSGSIZE	90	/* Message too long */
N#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
N#define	ENOPROTOOPT	92	/* Protocol not available */
N#define	EPROTONOSUPPORT	93	/* Protocol not supported */
N#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
N#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
N#define	EPFNOSUPPORT	96	/* Protocol family not supported */
N#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
N#define	EADDRINUSE	98	/* Address already in use */
N#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
N#define	ENETDOWN	100	/* Network is down */
N#define	ENETUNREACH	101	/* Network is unreachable */
N#define	ENETRESET	102	/* Network dropped connection because of reset */
N#define	ECONNABORTED	103	/* Software caused connection abort */
N#define	ECONNRESET	104	/* Connection reset by peer */
N#define	ENOBUFS		105	/* No buffer space available */
N#define	EISCONN		106	/* Transport endpoint is already connected */
N#define	ENOTCONN	107	/* Transport endpoint is not connected */
N#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
N#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
N#define	ETIMEDOUT	110	/* Connection timed out */
N#define	ECONNREFUSED	111	/* Connection refused */
N#define	EHOSTDOWN	112	/* Host is down */
N#define	EHOSTUNREACH	113	/* No route to host */
N#define	EALREADY	114	/* Operation already in progress */
N#define	EINPROGRESS	115	/* Operation now in progress */
N#define	ESTALE		116	/* Stale NFS file handle */
N#define	EUCLEAN		117	/* Structure needs cleaning */
N#define	ENOTNAM		118	/* Not a XENIX named type file */
N#define	ENAVAIL		119	/* No XENIX semaphores available */
N#define	EISNAM		120	/* Is a named type file */
N#define	EREMOTEIO	121	/* Remote I/O error */
N#define	EDQUOT		122	/* Quota exceeded */
N#define	ENOMEDIUM	123	/* No medium found */
N#define	EMEDIUMTYPE	124	/* Wrong medium type */
N
N#endif
L 71 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N#include "yaffs_malloc.h"
L 1 "..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_malloc.h" 1
N
N
Nvoid *yaffs_malloc(size_t size);
Nvoid yaffs_free(void *ptr);
Nvoid  YAFFS_InitializeMemoryPool(void);
Nint yaffsfs_GetError(void);
N
L 72 "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 2
N
Nextern void sysprintf(char* pcStr,...);
N#define BUG_ON(x)	{ if (x) { sysprintf("BUG!! %s\n", __func__); while (1); } }
N#define min(a,b)	( ((a) > (b)) ? (b) : (a) )
N
Nstatic int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)
N{
N	int ret;
N
N	ret = memcmp(buf, td->pattern, td->len);
N	if (!ret)
N		return ret;
N	return -1;
N}
N
N/**
N * check_pattern - [GENERIC] check if a pattern is in the buffer
N * @buf:	the buffer to search
N * @len:	the length of buffer to search
N * @paglen:	the pagelength
N * @td:		search pattern descriptor
N *
N * Check for a pattern at the given place. Used to search bad block
N * tables and good / bad block identifiers.
N * If the SCAN_EMPTY option is set then check, if all bytes except the
N * pattern area contain 0xff
N *
N*/
Nstatic int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)
N{
N	int i, end = 0;
N	uint8_t *p = buf;
N
N	if (td->options & NAND_BBT_NO_OOB)
X	if (td->options & 0x00400000)
N		return check_pattern_no_oob(buf, td);
N
N	end = paglen + td->offs;
N	if (td->options & NAND_BBT_SCANEMPTY) {
X	if (td->options & 0x00000800) {
N		for (i = 0; i < end; i++) {
N			if (p[i] != 0xff)
N				return -1;
N		}
N	}
N	p += end;
N
N	/* Compare the pattern */
N	for (i = 0; i < td->len; i++) {
N		if (p[i] != td->pattern[i])
N			return -1;
N	}
N
N	/* Check both positions 1 and 6 for pattern? */
N	if (td->options & NAND_BBT_SCANBYTE1AND6) {
X	if (td->options & 0x00100000) {
N		if (td->options & NAND_BBT_SCANEMPTY) {
X		if (td->options & 0x00000800) {
N			p += td->len;
N			end += NAND_SMALL_BADBLOCK_POS - td->offs;
X			end += 5 - td->offs;
N			/* Check region between positions 1 and 6 */
N			for (i = 0; i < NAND_SMALL_BADBLOCK_POS - td->offs - td->len;
X			for (i = 0; i < 5 - td->offs - td->len;
N					i++) {
N				if (*p++ != 0xff)
N					return -1;
N			}
N		}
N		else {
N			p += NAND_SMALL_BADBLOCK_POS - td->offs;
X			p += 5 - td->offs;
N		}
N		/* Compare the pattern */
N		for (i = 0; i < td->len; i++) {
N			if (p[i] != td->pattern[i])
N				return -1;
N		}
N	}
N
N	if (td->options & NAND_BBT_SCANEMPTY) {
X	if (td->options & 0x00000800) {
N		p += td->len;
N		end += td->len;
N		for (i = end; i < len; i++) {
N			if (*p++ != 0xff)
N				return -1;
N		}
N	}
N	return 0;
N}
N
N/**
N * check_short_pattern - [GENERIC] check if a pattern is in the buffer
N * @buf:	the buffer to search
N * @td:		search pattern descriptor
N *
N * Check for a pattern at the given place. Used to search bad block
N * tables and good / bad block identifiers. Same as check_pattern, but
N * no optional empty check
N *
N*/
Nstatic int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)
N{
N	int i;
N	uint8_t *p = buf;
N
N	/* Compare the pattern */
N	for (i = 0; i < td->len; i++) {
N		if (p[td->offs + i] != td->pattern[i])
N			return -1;
N	}
N	/* Need to check location 1 AND 6? */
N	if (td->options & NAND_BBT_SCANBYTE1AND6) {
X	if (td->options & 0x00100000) {
N		for (i = 0; i < td->len; i++) {
N			if (p[NAND_SMALL_BADBLOCK_POS + i] != td->pattern[i])
X			if (p[5 + i] != td->pattern[i])
N				return -1;
N		}
N	}
N	return 0;
N}
N
N/**
N * add_marker_len - compute the length of the marker in data area
N * @td:		BBT descriptor used for computation
N *
N * The length will be 0 if the markeris located in OOB area.
N */
Nstatic u32 add_marker_len(struct nand_bbt_descr *td)
N{
N	u32 len;
N
N	if (!(td->options & NAND_BBT_NO_OOB))
X	if (!(td->options & 0x00400000))
N		return 0;
N
N	len = td->len;
N	if (td->options & NAND_BBT_VERSION)
X	if (td->options & 0x00000100)
N		len++;
N	return len;
N}
N
N/**
N * read_bbt - [GENERIC] Read the bad block table starting from page
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @page:	the starting page
N * @num:	the number of bbt descriptors to read
N * @td:		the bbt describtion table
N * @offs:	offset in the memory table
N *
N * Read the bad block table starting from page.
N *
N */
Nstatic int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,
N		struct nand_bbt_descr *td, int offs)
N{
N	int res, i, j, act = 0;
N	struct nand_chip *this = mtd->priv;
N	size_t retlen, len, totlen;
N	loff_t from;
N	int bits = td->options & NAND_BBT_NRBITS_MSK;
X	int bits = td->options & 0x0000000F;
N	uint8_t msk = (uint8_t) ((1 << bits) - 1);
N	u32 marker_len;
N	int reserved_block_code = td->reserved_block_code;
N
N	totlen = (num * bits) >> 3;
N	marker_len = add_marker_len(td);
N	from = ((loff_t) page) << this->page_shift;
N
N	while (totlen) {
N		len = min(totlen, (size_t) (1 << this->bbt_erase_shift));
X		len = ( ((totlen) > ((size_t) (1 << this->bbt_erase_shift))) ? ((size_t) (1 << this->bbt_erase_shift)) : (totlen) );
N		if (marker_len) {
N			/*
N			 * In case the BBT marker is not in the OOB area it
N			 * will be just in the first page.
N			 */
N			len -= marker_len;
N			from += marker_len;
N			marker_len = 0;
N		}
N		res = mtd->read(mtd, from, len, &retlen, buf);
N		if (res < 0) {
N			if (retlen != len) {
N				sysprintf("nand_bbt: Error reading bad block table\n");
N				return res;
N			}
N			sysprintf("nand_bbt: ECC error while reading bad block table\n");
N		}
N
N		/* Analyse data */
N		for (i = 0; i < len; i++) {
N			uint8_t dat = buf[i];
N			for (j = 0; j < 8; j += bits, act += 2) {
N				uint8_t tmp = (dat >> j) & msk;
N				if (tmp == msk)
N					continue;
N				if (reserved_block_code && (tmp == reserved_block_code)) {
N					sysprintf("nand_read_bbt: Reserved block at 0x%012llx\n",
N					       (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift);
N					this->bbt[offs + (act >> 3)] |= 0x2 << (act & 0x06);
N					mtd->ecc_stats.bbtblocks++;
N					continue;
N				}
N				MTDDEBUG(MTD_DEBUG_LEVEL0, "nand_read_bbt: " \
N					"Bad block at 0x%012llx\n",
N					(loff_t)((offs << 2) + (act >> 1))
N					<< this->bbt_erase_shift);
X				do { if (0) sysprintf("nand_read_bbt: " "Bad block at 0x%012llx\n", (loff_t)((offs << 2) + (act >> 1)) << this->bbt_erase_shift); } while(0);
N				/* Factory marked bad or worn out ? */
N				if (tmp == 0)
N					this->bbt[offs + (act >> 3)] |= 0x3 << (act & 0x06);
N				else
N					this->bbt[offs + (act >> 3)] |= 0x1 << (act & 0x06);
N				mtd->ecc_stats.badblocks++;
N			}
N		}
N		totlen -= len;
N		from += len;
N	}
N	return 0;
N}
N
N/**
N * read_abs_bbt - [GENERIC] Read the bad block table starting at a given page
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @td:		descriptor for the bad block table
N * @chip:	read the table for a specific chip, -1 read all chips.
N *		Applies only if NAND_BBT_PERCHIP option is set
N *
N * Read the bad block table for all chips starting at a given page
N * We assume that the bbt bits are in consecutive order.
N*/
Nstatic int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)
N{
N	struct nand_chip *this = mtd->priv;
N	int res = 0, i;
N
N	if (td->options & NAND_BBT_PERCHIP) {
X	if (td->options & 0x00000080) {
N		int offs = 0;
N		for (i = 0; i < this->numchips; i++) {
N			if (chip == -1 || chip == i)
N				res = read_bbt(mtd, buf, td->pages[i],
N					this->chipsize >> this->bbt_erase_shift,
N					td, offs);
N			if (res)
N				return res;
N			offs += this->chipsize >> (this->bbt_erase_shift + 2);
N		}
N	} else {
N		res = read_bbt(mtd, buf, td->pages[0],
N				mtd->size >> this->bbt_erase_shift, td, 0);
N		if (res)
N			return res;
N	}
N	return 0;
N}
N
N/*
N * BBT marker is in the first page, no OOB.
N */
Nstatic int scan_read_raw_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
N			 struct nand_bbt_descr *td)
N{
N	size_t retlen;
N	size_t len;
N
N	len = td->len;
N	if (td->options & NAND_BBT_VERSION)
X	if (td->options & 0x00000100)
N		len++;
N
N	return mtd->read(mtd, offs, len, &retlen, buf);
N}
N
N/*
N * Scan read raw data from flash
N */
Nstatic int scan_read_raw_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
N			 size_t len)
N{
N	struct mtd_oob_ops ops;
N	int res;
N
N	ops.mode = MTD_OOB_RAW;
N	ops.ooboffs = 0;
N	ops.ooblen = mtd->oobsize;
N
N
N	while (len > 0) {
N		if (len <= mtd->writesize) {
N			ops.oobbuf = buf + len;
N			ops.datbuf = buf;
N			ops.len = len;
N			return mtd->read_oob(mtd, offs, &ops);
N		} else {
N			ops.oobbuf = buf + mtd->writesize;
N			ops.datbuf = buf;
N			ops.len = mtd->writesize;
N			res = mtd->read_oob(mtd, offs, &ops);
N
N			if (res)
N				return res;
N		}
N
N		buf += mtd->oobsize + mtd->writesize;
N		len -= mtd->writesize;
N	}
N	return 0;
N}
N
Nstatic int scan_read_raw(struct mtd_info *mtd, uint8_t *buf, loff_t offs,
N			 size_t len, struct nand_bbt_descr *td)
N{
N	if (td->options & NAND_BBT_NO_OOB)
X	if (td->options & 0x00400000)
N		return scan_read_raw_data(mtd, buf, offs, td);
N	else
N		return scan_read_raw_oob(mtd, buf, offs, len);
N}
N
N/*
N * Scan write data with oob to flash
N */
Nstatic int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,
N			  uint8_t *buf, uint8_t *oob)
N{
N	struct mtd_oob_ops ops;
N
N	ops.mode = MTD_OOB_PLACE;
N	ops.ooboffs = 0;
N	ops.ooblen = mtd->oobsize;
N	ops.datbuf = buf;
N	ops.oobbuf = oob;
N	ops.len = len;
N
N	return mtd->write_oob(mtd, offs, &ops);
N}
N
Nstatic u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)
N{
N	u32 ver_offs = td->veroffs;
N
N	if (!(td->options & NAND_BBT_NO_OOB))
X	if (!(td->options & 0x00400000))
N		ver_offs += mtd->writesize;
N	return ver_offs;
N}
N
N/**
N * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @td:		descriptor for the bad block table
N * @md:		descriptor for the bad block table mirror
N *
N * Read the bad block table(s) for all chips starting at a given page
N * We assume that the bbt bits are in consecutive order.
N *
N*/
Nstatic int read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,
N			 struct nand_bbt_descr *td, struct nand_bbt_descr *md)
N{
N	struct nand_chip *this = mtd->priv;
N
N	/* Read the primary version, if available */
N	if (td->options & NAND_BBT_VERSION) {
X	if (td->options & 0x00000100) {
N		scan_read_raw(mtd, buf, (loff_t)td->pages[0] << this->page_shift,
N			      mtd->writesize, td);
N		td->version[0] = buf[bbt_get_ver_offs(mtd, td)];
N		sysprintf("Bad block table at page %d, version 0x%02X\n",
N		       td->pages[0], td->version[0]);
N	}
N
N	/* Read the mirror version, if available */
N	if (md && (md->options & NAND_BBT_VERSION)) {
X	if (md && (md->options & 0x00000100)) {
N		scan_read_raw(mtd, buf, (loff_t)md->pages[0] << this->page_shift,
N			      mtd->writesize, td);
N		md->version[0] = buf[bbt_get_ver_offs(mtd, md)];
N		sysprintf("Bad block table at page %d, version 0x%02X\n",
N		       md->pages[0], md->version[0]);
N	}
N	return 1;
N}
N
N/*
N * Scan a given block full
N */
Nstatic int scan_block_full(struct mtd_info *mtd, struct nand_bbt_descr *bd,
N			   loff_t offs, uint8_t *buf, size_t readlen,
N			   int scanlen, int len)
N{
N	int ret, j;
N
N	ret = scan_read_raw_oob(mtd, buf, offs, readlen);
N	if (ret)
N		return ret;
N
N	for (j = 0; j < len; j++, buf += scanlen) {
N		if (check_pattern(buf, scanlen, mtd->writesize, bd))
N			return 1;
N	}
N	return 0;
N}
N
N/*
N * Scan a given block partially
N */
Nstatic int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
N			   loff_t offs, uint8_t *buf, int len)
N{
N	struct mtd_oob_ops ops;
N	int j, ret;
N
N	ops.ooblen = mtd->oobsize;
N	ops.oobbuf = buf;
N	ops.ooboffs = 0;
N	ops.datbuf = NULL;
X	ops.datbuf = ((void *)0);
N	ops.mode = MTD_OOB_PLACE;
N
N	for (j = 0; j < len; j++) {
N		/*
N		 * Read the full oob until read_oob is fixed to
N		 * handle single byte reads for 16 bit
N		 * buswidth
N		 */
N		ret = mtd->read_oob(mtd, offs, &ops);
N		if (ret)
N			return ret;
N
N		if (check_short_pattern(buf, bd))
N			return 1;
N
N		offs += mtd->writesize;
N	}
N	return 0;
N}
N
N/**
N * create_bbt - [GENERIC] Create a bad block table by scanning the device
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @bd:		descriptor for the good/bad block search pattern
N * @chip:	create the table for a specific chip, -1 read all chips.
N *		Applies only if NAND_BBT_PERCHIP option is set
N *
N * Create a bad block table by scanning the device
N * for the given good/bad block identify pattern
N */
Nstatic int create_bbt(struct mtd_info *mtd, uint8_t *buf,
N	struct nand_bbt_descr *bd, int chip)
N{
N	struct nand_chip *this = mtd->priv;
N	int i, numblocks, len, scanlen;
N	int startblock;
N	loff_t from;
N	size_t readlen;
N
N	MTDDEBUG(MTD_DEBUG_LEVEL0, "Scanning device for bad blocks\n");
X	do { if (0) sysprintf("Scanning device for bad blocks\n"); } while(0);
N
N	if (bd->options & NAND_BBT_SCANALLPAGES)
X	if (bd->options & 0x00000400)
N		len = 1 << (this->bbt_erase_shift - this->page_shift);
N	else if (bd->options & NAND_BBT_SCAN2NDPAGE)
X	else if (bd->options & 0x00004000)
N		len = 2;
N	else
N		len = 1;
N
N	if (!(bd->options & NAND_BBT_SCANEMPTY)) {
X	if (!(bd->options & 0x00000800)) {
N		/* We need only read few bytes from the OOB area */
N		scanlen = 0;
N		readlen = bd->len;
N	} else {
N		/* Full page content should be read */
N		scanlen = mtd->writesize + mtd->oobsize;
N		readlen = len * mtd->writesize;
N	}
N
N	if (chip == -1) {
N		/* Note that numblocks is 2 * (real numblocks) here, see i+=2
N		 * below as it makes shifting and masking less painful */
N		numblocks = mtd->size >> (this->bbt_erase_shift - 1);
N		startblock = 0;
N		from = 0;
N	} else {
N		if (chip >= this->numchips) {
N			sysprintf("create_bbt(): chipnr (%d) > available chips (%d)\n",
N			       chip + 1, this->numchips);
N			return -EINVAL;
X			return -22;
N		}
N		numblocks = this->chipsize >> (this->bbt_erase_shift - 1);
N		startblock = chip * numblocks;
N		numblocks += startblock;
N		from = (loff_t)startblock << (this->bbt_erase_shift - 1);
N	}
N
N	if (this->options & NAND_BBT_SCANLASTPAGE)
X	if (this->options & 0x00008000)
N		from += mtd->erasesize - (mtd->writesize * len);
N
N	for (i = startblock; i < numblocks;) {
N		int ret;
N
N		BUG_ON(bd->options & NAND_BBT_NO_OOB);
X		{ if (bd->options & 0x00400000) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N
N		if (bd->options & NAND_BBT_SCANALLPAGES)
X		if (bd->options & 0x00000400)
N			ret = scan_block_full(mtd, bd, from, buf, readlen,
N					      scanlen, len);
N		else
N			ret = scan_block_fast(mtd, bd, from, buf, len);
N
N		if (ret < 0)
N			return ret;
N
N		if (ret) {
N			this->bbt[i >> 3] |= 0x03 << (i & 0x6);
N			MTDDEBUG(MTD_DEBUG_LEVEL0,
N				  "Bad eraseblock %d at 0x%012llx\n",
N				  i >> 1, (unsigned long long)from);
X			do { if (0) sysprintf("Bad eraseblock %d at 0x%012llx\n", i >> 1, (unsigned long long)from); } while(0);
N			mtd->ecc_stats.badblocks++;
N		}
N
N		i += 2;
N		from += (1 << this->bbt_erase_shift);
N	}
N	return 0;
N}
N
N/**
N * search_bbt - [GENERIC] scan the device for a specific bad block table
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @td:		descriptor for the bad block table
N *
N * Read the bad block table by searching for a given ident pattern.
N * Search is preformed either from the beginning up or from the end of
N * the device downwards. The search starts always at the start of a
N * block.
N * If the option NAND_BBT_PERCHIP is given, each chip is searched
N * for a bbt, which contains the bad block information of this chip.
N * This is necessary to provide support for certain DOC devices.
N *
N * The bbt ident pattern resides in the oob area of the first page
N * in a block.
N */
Nstatic int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)
N{
N	struct nand_chip *this = mtd->priv;
N	int i, chips;
N	int startblock, block, dir;
N	int scanlen = mtd->writesize + mtd->oobsize;
N	int bbtblocks;
N	int blocktopage = this->bbt_erase_shift - this->page_shift;
N
N	/* Search direction top -> down ? */
N	if (td->options & NAND_BBT_LASTBLOCK) {
X	if (td->options & 0x00000010) {
N		startblock = (mtd->size >> this->bbt_erase_shift) - 1;
N		dir = -1;
N	} else {
N		startblock = 0;
N		dir = 1;
N	}
N
N	/* Do we have a bbt per chip ? */
N	if (td->options & NAND_BBT_PERCHIP) {
X	if (td->options & 0x00000080) {
N		chips = this->numchips;
N		bbtblocks = this->chipsize >> this->bbt_erase_shift;
N		startblock &= bbtblocks - 1;
N	} else {
N		chips = 1;
N		bbtblocks = mtd->size >> this->bbt_erase_shift;
N	}
N
N	for (i = 0; i < chips; i++) {
N		/* Reset version information */
N		td->version[i] = 0;
N		td->pages[i] = -1;
N		/* Scan the maximum number of blocks */
N		for (block = 0; block < td->maxblocks; block++) {
N
N			int actblock = startblock + dir * block;
N			loff_t offs = (loff_t)actblock << this->bbt_erase_shift;
N
N			/* Read first page */
N			scan_read_raw(mtd, buf, offs, mtd->writesize, td);
N			if (!check_pattern(buf, scanlen, mtd->writesize, td)) {
N				td->pages[i] = actblock << blocktopage;
N				if (td->options & NAND_BBT_VERSION) {
X				if (td->options & 0x00000100) {
N					offs = bbt_get_ver_offs(mtd, td);
N					td->version[i] = buf[offs];
N				}
N				break;
N			}
N		}
N		startblock += this->chipsize >> this->bbt_erase_shift;
N	}
N	/* Check, if we found a bbt for each requested chip */
N	for (i = 0; i < chips; i++) {
N		if (td->pages[i] == -1)
N			sysprintf("Bad block table not found for chip %d\n", i);
N		else
N			MTDDEBUG(MTD_DEBUG_LEVEL0, "Bad block table found " \
N				"at page %d, version 0x%02X\n", td->pages[i],
N				td->version[i]);
X			do { if (0) sysprintf("Bad block table found " "at page %d, version 0x%02X\n", td->pages[i], td->version[i]); } while(0);
N	}
N	return 0;
N}
N
N/**
N * search_read_bbts - [GENERIC] scan the device for bad block table(s)
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @td:		descriptor for the bad block table
N * @md:		descriptor for the bad block table mirror
N *
N * Search and read the bad block table(s)
N*/
Nstatic int search_read_bbts(struct mtd_info *mtd, uint8_t * buf, struct nand_bbt_descr *td, struct nand_bbt_descr *md)
N{
N	/* Search the primary table */
N	search_bbt(mtd, buf, td);
N
N	/* Search the mirror table */
N	if (md)
N		search_bbt(mtd, buf, md);
N
N	/* Force result check */
N	return 1;
N}
N
N/**
N * write_bbt - [GENERIC] (Re)write the bad block table
N *
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @td:		descriptor for the bad block table
N * @md:		descriptor for the bad block table mirror
N * @chipsel:	selector for a specific chip, -1 for all
N *
N * (Re)write the bad block table
N *
N*/
Nstatic int write_bbt(struct mtd_info *mtd, uint8_t *buf,
N		     struct nand_bbt_descr *td, struct nand_bbt_descr *md,
N		     int chipsel)
N{
N	struct nand_chip *this = mtd->priv;
N	struct erase_info einfo;
N	int i, j, res, chip = 0;
N	int bits, startblock, dir, page, offs, numblocks, sft, sftmsk;
N	int nrchips, bbtoffs, pageoffs, ooboffs;
N	uint8_t msk[4];
N	uint8_t rcode = td->reserved_block_code;
N	size_t retlen, len = 0;
N	loff_t to;
N	struct mtd_oob_ops ops;
N
N	ops.ooblen = mtd->oobsize;
N	ops.ooboffs = 0;
N	ops.datbuf = NULL;
X	ops.datbuf = ((void *)0);
N	ops.mode = MTD_OOB_PLACE;
N
N	if (!rcode)
N		rcode = 0xff;
N	/* Write bad block table per chip rather than per device ? */
N	if (td->options & NAND_BBT_PERCHIP) {
X	if (td->options & 0x00000080) {
N		numblocks = (int)(this->chipsize >> this->bbt_erase_shift);
N		/* Full device write or specific chip ? */
N		if (chipsel == -1) {
N			nrchips = this->numchips;
N		} else {
N			nrchips = chipsel + 1;
N			chip = chipsel;
N		}
N	} else {
N		numblocks = (int)(mtd->size >> this->bbt_erase_shift);
N		nrchips = 1;
N	}
N
N	/* Loop through the chips */
N	for (; chip < nrchips; chip++) {
N
N		/* There was already a version of the table, reuse the page
N		 * This applies for absolute placement too, as we have the
N		 * page nr. in td->pages.
N		 */
N		if (td->pages[chip] != -1) {
N			page = td->pages[chip];
N			goto write;
N		}
N
N		/* Automatic placement of the bad block table */
N		/* Search direction top -> down ? */
N		if (td->options & NAND_BBT_LASTBLOCK) {
X		if (td->options & 0x00000010) {
N			startblock = numblocks * (chip + 1) - 1;
N			dir = -1;
N		} else {
N			startblock = chip * numblocks;
N			dir = 1;
N		}
N
N		for (i = 0; i < td->maxblocks; i++) {
N			int block = startblock + dir * i;
N			/* Check, if the block is bad */
N			switch ((this->bbt[block >> 2] >>
N				 (2 * (block & 0x03))) & 0x03) {
N			case 0x01:
N			case 0x03:
N				continue;
N			}
N			page = block <<
N				(this->bbt_erase_shift - this->page_shift);
N			/* Check, if the block is used by the mirror table */
N			if (!md || md->pages[chip] != page)
N				goto write;
N		}
N		sysprintf("No space left to write bad block table\n");
N		return -ENOSPC;
X		return -28;
N	write:
N
N		/* Set up shift count and masks for the flash table */
N		bits = td->options & NAND_BBT_NRBITS_MSK;
X		bits = td->options & 0x0000000F;
N		msk[2] = ~rcode;
N		switch (bits) {
N		case 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;
N			msk[3] = 0x01;
N			break;
N		case 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;
N			msk[3] = 0x03;
N			break;
N		case 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;
N			msk[3] = 0x0f;
N			break;
N		case 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;
N			msk[3] = 0xff;
N			break;
N		default: return -EINVAL;
X		default: return -22;
N		}
N
N		bbtoffs = chip * (numblocks >> 2);
N
N		to = ((loff_t) page) << this->page_shift;
N
N		/* Must we save the block contents ? */
N		if (td->options & NAND_BBT_SAVECONTENT) {
X		if (td->options & 0x00002000) {
N			/* Make it block aligned */
N			to &= ~((loff_t) ((1 << this->bbt_erase_shift) - 1));
N			len = 1 << this->bbt_erase_shift;
N			res = mtd->read(mtd, to, len, &retlen, buf);
N			if (res < 0) {
N				if (retlen != len) {
N					sysprintf("nand_bbt: Error "
N					       "reading block for writing "
N					       "the bad block table\n");
N					return res;
N				}
N				sysprintf("nand_bbt: ECC error while reading block for writing bad block table\n");
N			}
N			/* Read oob data */
N			ops.ooblen = (len >> this->page_shift) * mtd->oobsize;
N			ops.oobbuf = &buf[len];
N			res = mtd->read_oob(mtd, to + mtd->writesize, &ops);
N			if (res < 0 || ops.oobretlen != ops.ooblen)
N				goto outerr;
N
N			/* Calc the byte offset in the buffer */
N			pageoffs = page - (int)(to >> this->page_shift);
N			offs = pageoffs << this->page_shift;
N			/* Preset the bbt area with 0xff */
N			memset(&buf[offs], 0xff, (size_t) (numblocks >> sft));
N			ooboffs = len + (pageoffs * mtd->oobsize);
N
N		} else if (td->options & NAND_BBT_NO_OOB) {
X		} else if (td->options & 0x00400000) {
N			ooboffs = 0;
N			offs = td->len;
N			/* the version byte */
N			if (td->options & NAND_BBT_VERSION)
X			if (td->options & 0x00000100)
N				offs++;
N			/* Calc length */
N			len = (size_t) (numblocks >> sft);
N			len += offs;
N			/* Make it page aligned ! */
N			//len = ALIGN(len, mtd->writesize);
N            if (len < mtd->writesize)
N                len = mtd->writesize;
N            else
N                len = 0;
N			/* Preset the buffer with 0xff */
N			memset(buf, 0xff, len);
N			/* Pattern is located at the begin of first page */
N			memcpy(buf, td->pattern, td->len);
N		} else {
N			/* Calc length */
N			len = (size_t) (numblocks >> sft);
N			/* Make it page aligned ! */
N			//len = ALIGN(len, mtd->writesize);
N            if (len < mtd->writesize)
N                len = mtd->writesize;
N            else
N                len = 0;
N			/* Preset the buffer with 0xff */
N			memset(buf, 0xff, len +
N			       (len >> this->page_shift)* mtd->oobsize);
N			offs = 0;
N			ooboffs = len;
N			/* Pattern is located in oob area of first page */
N			memcpy(&buf[ooboffs + td->offs], td->pattern, td->len);
N		}
N
N		if (td->options & NAND_BBT_VERSION)
X		if (td->options & 0x00000100)
N			buf[ooboffs + td->veroffs] = td->version[chip];
N
N		/* walk through the memory table */
N		for (i = 0; i < numblocks;) {
N			uint8_t dat;
N			dat = this->bbt[bbtoffs + (i >> 2)];
N			for (j = 0; j < 4; j++, i++) {
N				int sftcnt = (i << (3 - sft)) & sftmsk;
N				/* Do not store the reserved bbt blocks ! */
N				buf[offs + (i >> sft)] &=
N					~(msk[dat & 0x03] << sftcnt);
N				dat >>= 2;
N			}
N		}
N
N		memset(&einfo, 0, sizeof(einfo));
N		einfo.mtd = mtd;
N		einfo.addr = to;
N		einfo.len = 1 << this->bbt_erase_shift;
N		res = nand_erase_nand(mtd, &einfo, 1);
N		if (res < 0)
N			goto outerr;
N
N		res = scan_write_bbt(mtd, to, len, buf,
N				td->options & NAND_BBT_NO_OOB ? NULL :
X				td->options & 0x00400000 ? ((void *)0) :
N				&buf[len]);
N		if (res < 0)
N			goto outerr;
N
N		sysprintf("Bad block table written to 0x%012llx, version "
N		       "0x%02X\n", (unsigned long long)to, td->version[chip]);
N
N		/* Mark it as used */
N		td->pages[chip] = page;
N	}
N	return 0;
N
N outerr:
N	sysprintf("nand_bbt: Error while writing bad block table %d\n", res);
N	return res;
N}
N
N/**
N * nand_memory_bbt - [GENERIC] create a memory based bad block table
N * @mtd:	MTD device structure
N * @bd:		descriptor for the good/bad block search pattern
N *
N * The function creates a memory based bbt by scanning the device
N * for manufacturer / software marked good / bad blocks
N*/
Nstatic __inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
N{
N	struct nand_chip *this = mtd->priv;
N
N	bd->options &= ~NAND_BBT_SCANEMPTY;
X	bd->options &= ~0x00000800;
N	return create_bbt(mtd, this->buffers->databuf, bd, -1);
N}
N
N/**
N * check_create - [GENERIC] create and write bbt(s) if necessary
N * @mtd:	MTD device structure
N * @buf:	temporary buffer
N * @bd:		descriptor for the good/bad block search pattern
N *
N * The function checks the results of the previous call to read_bbt
N * and creates / updates the bbt(s) if necessary
N * Creation is necessary if no bbt was found for the chip/device
N * Update is necessary if one of the tables is missing or the
N * version nr. of one table is less than the other
N*/
Nstatic int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)
N{
N	int i, chips, writeops, chipsel, res;
N	struct nand_chip *this = mtd->priv;
N	struct nand_bbt_descr *td = this->bbt_td;
N	struct nand_bbt_descr *md = this->bbt_md;
N	struct nand_bbt_descr *rd, *rd2;
N
N	/* Do we have a bbt per chip ? */
N	if (td->options & NAND_BBT_PERCHIP)
X	if (td->options & 0x00000080)
N		chips = this->numchips;
N	else
N		chips = 1;
N
N	for (i = 0; i < chips; i++) {
N		writeops = 0;
N		rd = NULL;
X		rd = ((void *)0);
N		rd2 = NULL;
X		rd2 = ((void *)0);
N		/* Per chip or per device ? */
N		chipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;
X		chipsel = (td->options & 0x00000080) ? i : -1;
N		/* Mirrored table available ? */
N		if (md) {
N			if (td->pages[i] == -1 && md->pages[i] == -1) {
N				writeops = 0x03;
N				goto create;
N			}
N
N			if (td->pages[i] == -1) {
N				rd = md;
N				td->version[i] = md->version[i];
N				writeops = 1;
N				goto writecheck;
N			}
N
N			if (md->pages[i] == -1) {
N				rd = td;
N				md->version[i] = td->version[i];
N				writeops = 2;
N				goto writecheck;
N			}
N
N			if (td->version[i] == md->version[i]) {
N				rd = td;
N				if (!(td->options & NAND_BBT_VERSION))
X				if (!(td->options & 0x00000100))
N					rd2 = md;
N				goto writecheck;
N			}
N
N			if (((int8_t) (td->version[i] - md->version[i])) > 0) {
N				rd = td;
N				md->version[i] = td->version[i];
N				writeops = 2;
N			} else {
N				rd = md;
N				td->version[i] = md->version[i];
N				writeops = 1;
N			}
N
N			goto writecheck;
N
N		} else {
N			if (td->pages[i] == -1) {
N				writeops = 0x01;
N				goto create;
N			}
N			rd = td;
N			goto writecheck;
N		}
N	create:
N		/* Create the bad block table by scanning the device ? */
N		if (!(td->options & NAND_BBT_CREATE))
X		if (!(td->options & 0x00000200))
N			continue;
N
N		/* Create the table in memory by scanning the chip(s) */
N		if (!(this->options & NAND_CREATE_EMPTY_BBT))
X		if (!(this->options & 0x01000000))
N			create_bbt(mtd, buf, bd, chipsel);
N
N		td->version[i] = 1;
N		if (md)
N			md->version[i] = 1;
N	writecheck:
N		/* read back first ? */
N		if (rd)
N			read_abs_bbt(mtd, buf, rd, chipsel);
N		/* If they weren't versioned, read both. */
N		if (rd2)
N			read_abs_bbt(mtd, buf, rd2, chipsel);
N
N		/* Write the bad block table to the device ? */
N		if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
X		if ((writeops & 0x01) && (td->options & 0x00001000)) {
N			res = write_bbt(mtd, buf, td, md, chipsel);
N			if (res < 0)
N				return res;
N		}
N
N		/* Write the mirror bad block table to the device ? */
N		if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
X		if ((writeops & 0x02) && md && (md->options & 0x00001000)) {
N			res = write_bbt(mtd, buf, md, td, chipsel);
N			if (res < 0)
N				return res;
N		}
N	}
N	return 0;
N}
N
N/**
N * mark_bbt_regions - [GENERIC] mark the bad block table regions
N * @mtd:	MTD device structure
N * @td:		bad block table descriptor
N *
N * The bad block table regions are marked as "bad" to prevent
N * accidental erasures / writes. The regions are identified by
N * the mark 0x02.
N*/
Nstatic void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)
N{
N	struct nand_chip *this = mtd->priv;
N	int i, j, chips, block, nrblocks, update;
N	uint8_t oldval, newval;
N
N	/* Do we have a bbt per chip ? */
N	if (td->options & NAND_BBT_PERCHIP) {
X	if (td->options & 0x00000080) {
N		chips = this->numchips;
N		nrblocks = (int)(this->chipsize >> this->bbt_erase_shift);
N	} else {
N		chips = 1;
N		nrblocks = (int)(mtd->size >> this->bbt_erase_shift);
N	}
N
N	for (i = 0; i < chips; i++) {
N		if ((td->options & NAND_BBT_ABSPAGE) ||
X		if ((td->options & 0x00000020) ||
N		    !(td->options & NAND_BBT_WRITE)) {
X		    !(td->options & 0x00001000)) {
N			if (td->pages[i] == -1)
N				continue;
N			block = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);
N			block <<= 1;
N			oldval = this->bbt[(block >> 3)];
N			newval = oldval | (0x2 << (block & 0x06));
N			this->bbt[(block >> 3)] = newval;
N			if ((oldval != newval) && td->reserved_block_code)
N				nand_update_bbt(mtd, (loff_t)block << (this->bbt_erase_shift - 1));
N			continue;
N		}
N		update = 0;
N		if (td->options & NAND_BBT_LASTBLOCK)
X		if (td->options & 0x00000010)
N			block = ((i + 1) * nrblocks) - td->maxblocks;
N		else
N			block = i * nrblocks;
N		block <<= 1;
N		for (j = 0; j < td->maxblocks; j++) {
N			oldval = this->bbt[(block >> 3)];
N			newval = oldval | (0x2 << (block & 0x06));
N			this->bbt[(block >> 3)] = newval;
N			if (oldval != newval)
N				update = 1;
N			block += 2;
N		}
N		/* If we want reserved blocks to be recorded to flash, and some
N		   new ones have been marked, then we need to update the stored
N		   bbts.  This should only happen once. */
N		if (update && td->reserved_block_code)
N			nand_update_bbt(mtd, (loff_t)(block - 2) << (this->bbt_erase_shift - 1));
N	}
N}
N
N/**
N * verify_bbt_descr - verify the bad block description
N * @mtd:	MTD device structure
N * @bd:		the table to verify
N *
N * This functions performs a few sanity checks on the bad block description
N * table.
N */
Nstatic void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
N{
N	struct nand_chip *this = mtd->priv;
N	u32 pattern_len;
N	u32 bits;
N	u32 table_size;
N
N	if (!bd)
N		return;
N
N	pattern_len = bd->len;
N	bits = bd->options & NAND_BBT_NRBITS_MSK;
X	bits = bd->options & 0x0000000F;
N
N	BUG_ON((this->options & NAND_USE_FLASH_BBT_NO_OOB) &&
N			!(this->options & NAND_USE_FLASH_BBT));
X	{ if ((this->options & 0x00800000) && !(this->options & 0x00010000)) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N	BUG_ON(!bits);
X	{ if (!bits) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N
N	if (bd->options & NAND_BBT_VERSION)
X	if (bd->options & 0x00000100)
N		pattern_len++;
N
N	if (bd->options & NAND_BBT_NO_OOB) {
X	if (bd->options & 0x00400000) {
N		BUG_ON(!(this->options & NAND_USE_FLASH_BBT));
X		{ if (!(this->options & 0x00010000)) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N		BUG_ON(!(this->options & NAND_USE_FLASH_BBT_NO_OOB));
X		{ if (!(this->options & 0x00800000)) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N		BUG_ON(bd->offs);
X		{ if (bd->offs) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N		if (bd->options & NAND_BBT_VERSION)
X		if (bd->options & 0x00000100)
N			BUG_ON(bd->veroffs != bd->len);
X			{ if (bd->veroffs != bd->len) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N		BUG_ON(bd->options & NAND_BBT_SAVECONTENT);
X		{ if (bd->options & 0x00002000) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N	}
N
N	if (bd->options & NAND_BBT_PERCHIP)
X	if (bd->options & 0x00000080)
N		table_size = this->chipsize >> this->bbt_erase_shift;
N	else
N		table_size = mtd->size >> this->bbt_erase_shift;
N	table_size >>= 3;
N	table_size *= bits;
N	if (bd->options & NAND_BBT_NO_OOB)
X	if (bd->options & 0x00400000)
N		table_size += pattern_len;
N	BUG_ON(table_size > (1 << this->bbt_erase_shift));
X	{ if (table_size > (1 << this->bbt_erase_shift)) { sysprintf("BUG!! %s\n", __func__); while (1); } };
N}
N
N/**
N * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
N * @mtd:	MTD device structure
N * @bd:		descriptor for the good/bad block search pattern
N *
N * The function checks, if a bad block table(s) is/are already
N * available. If not it scans the device for manufacturer
N * marked good / bad blocks and writes the bad block table(s) to
N * the selected place.
N *
N * The bad block table memory is allocated here. It must be freed
N * by calling the nand_free_bbt function.
N *
N*/
Nint nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
N{
N	struct nand_chip *this = mtd->priv;
N	int len, res = 0;
N	uint8_t *buf;
N	struct nand_bbt_descr *td = this->bbt_td;
N	struct nand_bbt_descr *md = this->bbt_md;
N
N	len = mtd->size >> (this->bbt_erase_shift + 2);
N	/* Allocate memory (2bit per block) and clear the memory bad block table */
N	this->bbt = yaffs_malloc(len);
N	if (!this->bbt) {
N		sysprintf("nand_scan_bbt: Out of memory\n");
N		return -ENOMEM;
X		return -12;
N	}
N	memset((void*)this->bbt,0,len);
N
N	/* If no primary table decriptor is given, scan the device
N	 * to build a memory based bad block table
N	 */
N	if (!td) {
W "..\..\common\src\BSP\ThirdParty\yaffs2\nand_bbt.c" 1186 7 assignment in condition
N		if ((res = nand_memory_bbt(mtd, bd))) {
N			sysprintf("nand_bbt: Can't scan flash and build the RAM-based BBT\n");
N			yaffs_free(this->bbt);
N			this->bbt = NULL;
X			this->bbt = ((void *)0);
N		}
N		return res;
N	}
N	verify_bbt_descr(mtd, td);
N	verify_bbt_descr(mtd, md);
N
N	/* Allocate a temporary buffer for one eraseblock incl. oob */
N	len = (1 << this->bbt_erase_shift);
N	len += (len >> this->page_shift) * mtd->oobsize;
N	buf = yaffs_malloc(len);
N	if (!buf) {
N		sysprintf("nand_bbt: Out of memory\n");
N		yaffs_free(this->bbt);
N		this->bbt = NULL;
X		this->bbt = ((void *)0);
N		return -ENOMEM;
X		return -12;
N	}
N	memset((void*)buf,0,len);
N
N	/* Is the bbt at a given page ? */
N	if (td->options & NAND_BBT_ABSPAGE) {
X	if (td->options & 0x00000020) {
N		res = read_abs_bbts(mtd, buf, td, md);
N	} else {
N		/* Search the bad block table using a pattern in oob */
N		res = search_read_bbts(mtd, buf, td, md);
N	}
N
N	if (res)
N		res = check_create(mtd, buf, bd);
N
N	/* Prevent the bbt regions from erasing / writing */
N	mark_bbt_region(mtd, td);
N	if (md)
N		mark_bbt_region(mtd, md);
N
N	yaffs_free(buf);
N	return res;
N}
N
N/**
N * nand_update_bbt - [NAND Interface] update bad block table(s)
N * @mtd:	MTD device structure
N * @offs:	the offset of the newly marked block
N *
N * The function updates the bad block table(s)
N*/
Nint nand_update_bbt(struct mtd_info *mtd, loff_t offs)
N{
N	struct nand_chip *this = mtd->priv;
N	int len, res = 0, writeops = 0;
N	int chip, chipsel;
N	uint8_t *buf;
N	struct nand_bbt_descr *td = this->bbt_td;
N	struct nand_bbt_descr *md = this->bbt_md;
N
N	if (!this->bbt || !td)
N		return -EINVAL;
X		return -22;
N
N	/* Allocate a temporary buffer for one eraseblock incl. oob */
N	len = (1 << this->bbt_erase_shift);
N	len += (len >> this->page_shift) * mtd->oobsize;
N	buf = yaffs_malloc(len);
N	if (!buf) {
N		sysprintf("nand_update_bbt: Out of memory\n");
N		return -ENOMEM;
X		return -12;
N	}
N	memset((void*)buf,0,len);
N
N	writeops = md != NULL ? 0x03 : 0x01;
X	writeops = md != ((void *)0) ? 0x03 : 0x01;
N
N	/* Do we have a bbt per chip ? */
N	if (td->options & NAND_BBT_PERCHIP) {
X	if (td->options & 0x00000080) {
N		chip = (int)(offs >> this->chip_shift);
N		chipsel = chip;
N	} else {
N		chip = 0;
N		chipsel = -1;
N	}
N
N	td->version[chip]++;
N	if (md)
N		md->version[chip]++;
N
N	/* Write the bad block table to the device ? */
N	if ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {
X	if ((writeops & 0x01) && (td->options & 0x00001000)) {
N		res = write_bbt(mtd, buf, td, md, chipsel);
N		if (res < 0)
N			goto out;
N	}
N	/* Write the mirror bad block table to the device ? */
N	if ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {
X	if ((writeops & 0x02) && md && (md->options & 0x00001000)) {
N		res = write_bbt(mtd, buf, md, td, chipsel);
N	}
N
N out:
N	yaffs_free(buf);
N	return res;
N}
N
N/* Define some generic bad / good block scan pattern which are used
N * while scanning a device for factory marked good / bad blocks. */
Nstatic uint8_t scan_ff_pattern[] = { 0xff, 0xff };
N
Nstatic uint8_t scan_agand_pattern[] = { 0x1C, 0x71, 0xC7, 0x1C, 0x71, 0xC7 };
N
Nstatic struct nand_bbt_descr agand_flashbased;
N
N/* Generic flash bbt decriptors
N*/
Nstatic uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
Nstatic uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
N
Nstatic struct nand_bbt_descr bbt_main_descr;
N
Nstatic struct nand_bbt_descr bbt_mirror_descr;
N
Nstatic struct nand_bbt_descr bbt_main_no_bbt_descr;
N
Nstatic struct nand_bbt_descr bbt_mirror_no_bbt_descr;
N
N#define BBT_SCAN_OPTIONS (NAND_BBT_SCANLASTPAGE | NAND_BBT_SCAN2NDPAGE | \
N		NAND_BBT_SCANBYTE1AND6)
X#define BBT_SCAN_OPTIONS (NAND_BBT_SCANLASTPAGE | NAND_BBT_SCAN2NDPAGE | 		NAND_BBT_SCANBYTE1AND6)
N/**
N * nand_create_default_bbt_descr - [Internal] Creates a BBT descriptor structure
N * @this:	NAND chip to create descriptor for
N *
N * This function allocates and initializes a nand_bbt_descr for BBM detection
N * based on the properties of "this". The new descriptor is stored in
N * this->badblock_pattern. Thus, this->badblock_pattern should be NULL when
N * passed to this function.
N *
N */
Nstatic int nand_create_default_bbt_descr(struct nand_chip *this)
N{
N	struct nand_bbt_descr *bd;
N	if (this->badblock_pattern) {
N		sysprintf("BBT descr already allocated; not replacing.\n");
N		return -EINVAL;
X		return -22;
N	}
N	bd = yaffs_malloc(sizeof(*bd));
N	if (!bd) {
N		sysprintf("nand_create_default_bbt_descr: Out of memory\n");
N		return -ENOMEM;
X		return -12;
N	}
N	memset((void*)bd,0,sizeof(*bd));
N
N	bd->options = this->options & BBT_SCAN_OPTIONS;
X	bd->options = this->options & (0x00008000 | 0x00004000 | 0x00100000);
N	bd->offs = this->badblockpos;
N	bd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;
X	bd->len = (this->options & 0x00000002) ? 2 : 1;
N	bd->pattern = scan_ff_pattern;
N	bd->options |= NAND_BBT_DYNAMICSTRUCT;
X	bd->options |= 0x00200000;
N	this->badblock_pattern = bd;
N	return 0;
N}
N
N/**
N * nand_default_bbt - [NAND Interface] Select a default bad block table for the device
N * @mtd:	MTD device structure
N *
N * This function selects the default bad block table
N * support for the device and calls the nand_scan_bbt function
N *
N*/
Nint nand_default_bbt(struct mtd_info *mtd)
N{
N	struct nand_chip *this = mtd->priv;
N
N    /* bbt_main_descr */
N    bbt_main_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP;
X    bbt_main_descr.options = 0x00000010|0x00000200|0x00001000|0x00000002|0x00000100|0x00000080;
N	bbt_main_descr.offs = 8;
N	bbt_main_descr.len = 4;
N	bbt_main_descr.veroffs = 12;
N	bbt_main_descr.maxblocks = 4;
N	bbt_main_descr.pattern = bbt_pattern;
N    
N    /* agand_flashbased */
N    agand_flashbased.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES;
X    agand_flashbased.options = 0x00000800 | 0x00000400;
N    agand_flashbased.offs = 0x20;
N    agand_flashbased.len = 6;
N    agand_flashbased.pattern = scan_agand_pattern;
N
N    /* bbt_mirror_descr */
N    bbt_mirror_descr.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP;
X    bbt_mirror_descr.options = 0x00000010 | 0x00000200 | 0x00001000 | 0x00000002 | 0x00000100 | 0x00000080;
N	bbt_mirror_descr.offs =	8;
N	bbt_mirror_descr.len = 4;
N	bbt_mirror_descr.veroffs = 12;
N	bbt_mirror_descr.maxblocks = 4;
N	bbt_mirror_descr.pattern = mirror_pattern;
N
N    /* bbt_main_no_bbt_descr */
N    bbt_main_no_bbt_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP|NAND_BBT_NO_OOB;
X    bbt_main_no_bbt_descr.options = 0x00000010|0x00000200|0x00001000|0x00000002|0x00000100|0x00000080|0x00400000;
N	bbt_main_no_bbt_descr.len = 4;
N	bbt_main_no_bbt_descr.veroffs = 4;
N	bbt_main_no_bbt_descr.maxblocks = 4;
N	bbt_main_no_bbt_descr.pattern = bbt_pattern;
N
N    /* bbt_mirror_no_bbt_descr */
N    bbt_mirror_no_bbt_descr.options = NAND_BBT_LASTBLOCK|NAND_BBT_CREATE|NAND_BBT_WRITE|NAND_BBT_2BIT|NAND_BBT_VERSION|NAND_BBT_PERCHIP|NAND_BBT_NO_OOB;
X    bbt_mirror_no_bbt_descr.options = 0x00000010|0x00000200|0x00001000|0x00000002|0x00000100|0x00000080|0x00400000;
N	bbt_mirror_no_bbt_descr.len = 4;
N	bbt_mirror_no_bbt_descr.veroffs = 4;
N	bbt_mirror_no_bbt_descr.maxblocks = 4;
N	bbt_mirror_no_bbt_descr.pattern = mirror_pattern;
N
N	/* Default for AG-AND. We must use a flash based
N	 * bad block table as the devices have factory marked
N	 * _good_ blocks. Erasing those blocks leads to loss
N	 * of the good / bad information, so we _must_ store
N	 * this information in a good / bad table during
N	 * startup
N	 */
N	if (this->options & NAND_IS_AND) {
X	if (this->options & 0x00000020) {
N		/* Use the default pattern descriptors */
N		if (!this->bbt_td) {
N			this->bbt_td = &bbt_main_descr;
N			this->bbt_md = &bbt_mirror_descr;
N		}
N		this->options |= NAND_USE_FLASH_BBT;
X		this->options |= 0x00010000;
N		return nand_scan_bbt(mtd, &agand_flashbased);
N	}
N
N	/* Is a flash based bad block table requested ? */
N	if (this->options & NAND_USE_FLASH_BBT) {
X	if (this->options & 0x00010000) {
N		/* Use the default pattern descriptors */
N		if (!this->bbt_td) {
N			if (this->options & NAND_USE_FLASH_BBT_NO_OOB) {
X			if (this->options & 0x00800000) {
N				this->bbt_td = &bbt_main_no_bbt_descr;
N				this->bbt_md = &bbt_mirror_no_bbt_descr;
N			} else {
N				this->bbt_td = &bbt_main_descr;
N				this->bbt_md = &bbt_mirror_descr;
N			}
N		}
N	} else {
N		this->bbt_td = NULL;
X		this->bbt_td = ((void *)0);
N		this->bbt_md = NULL;
X		this->bbt_md = ((void *)0);
N	}
N
N	if (!this->badblock_pattern)
N		nand_create_default_bbt_descr(this);
N
N	return nand_scan_bbt(mtd, this->badblock_pattern);
N}
N
N/**
N * nand_isbad_bbt - [NAND Interface] Check if a block is bad
N * @mtd:	MTD device structure
N * @offs:	offset in the device
N * @allowbbt:	allow access to bad block table region
N *
N*/
Nint nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
N{
N	struct nand_chip *this = mtd->priv;
N	int block;
N	uint8_t res;
N
N	/* Get block number * 2 */
N	block = (int)(offs >> (this->bbt_erase_shift - 1));
N	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
N
N	MTDDEBUG(MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
N	      (unsigned int)offs, block >> 1, res);
X	do { if (0) sysprintf("nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n", (unsigned int)offs, block >> 1, res); } while(0);
N
N	switch ((int)res) {
N	case 0x00:
N		return 0;
N	case 0x01:
N		return 1;
N	case 0x02:
N		return allowbbt ? 0 : 1;
N	}
N	return 1;
N}
