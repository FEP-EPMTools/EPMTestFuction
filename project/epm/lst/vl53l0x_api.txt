; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\vl53l0x_api.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vl53l0x_api.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\vl53l0x_api.crf src\UserDrv\vl53l0x\core\src\vl53l0x_api.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  VL53L0X_GetVersion PROC
;;;54     
;;;55     VL53L0X_Error VL53L0X_GetVersion(VL53L0X_Version_t *pVersion)
000000  e1a01000          MOV      r1,r0
;;;56     {
;;;57     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000004  e3a00000          MOV      r0,#0
;;;58     	LOG_FUNCTION_START("");
;;;59     
;;;60     	pVersion->major = VL53L0X_IMPLEMENTATION_VER_MAJOR;
000008  e3a02001          MOV      r2,#1
00000c  e5c12004          STRB     r2,[r1,#4]
;;;61     	pVersion->minor = VL53L0X_IMPLEMENTATION_VER_MINOR;
000010  e3a02000          MOV      r2,#0
000014  e5c12005          STRB     r2,[r1,#5]
;;;62     	pVersion->build = VL53L0X_IMPLEMENTATION_VER_SUB;
000018  e3a02001          MOV      r2,#1
00001c  e5c12006          STRB     r2,[r1,#6]
;;;63     
;;;64     	pVersion->revision = VL53L0X_IMPLEMENTATION_VER_REVISION;
000020  e59f2e5c          LDR      r2,|L1.3716|
000024  e5812000          STR      r2,[r1,#0]
;;;65     
;;;66     	LOG_FUNCTION_END(Status);
;;;67     	return Status;
;;;68     }
000028  e12fff1e          BX       lr
;;;69     
                          ENDP

                  VL53L0X_GetPalSpecVersion PROC
;;;70     VL53L0X_Error VL53L0X_GetPalSpecVersion(VL53L0X_Version_t *pPalSpecVersion)
00002c  e1a01000          MOV      r1,r0
;;;71     {
;;;72     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000030  e3a00000          MOV      r0,#0
;;;73     
;;;74     	LOG_FUNCTION_START("");
;;;75     
;;;76     	pPalSpecVersion->major = VL53L0X_SPECIFICATION_VER_MAJOR;
000034  e3a02001          MOV      r2,#1
000038  e5c12004          STRB     r2,[r1,#4]
;;;77     	pPalSpecVersion->minor = VL53L0X_SPECIFICATION_VER_MINOR;
00003c  e3a02002          MOV      r2,#2
000040  e5c12005          STRB     r2,[r1,#5]
;;;78     	pPalSpecVersion->build = VL53L0X_SPECIFICATION_VER_SUB;
000044  e3a02007          MOV      r2,#7
000048  e5c12006          STRB     r2,[r1,#6]
;;;79     
;;;80     	pPalSpecVersion->revision = VL53L0X_SPECIFICATION_VER_REVISION;
00004c  e3a02e5a          MOV      r2,#0x5a0
000050  e5812000          STR      r2,[r1,#0]
;;;81     
;;;82     	LOG_FUNCTION_END(Status);
;;;83     	return Status;
;;;84     }
000054  e12fff1e          BX       lr
;;;85     
                          ENDP

                  VL53L0X_GetProductRevision PROC
;;;86     VL53L0X_Error VL53L0X_GetProductRevision(VL53L0X_DEV Dev,
000058  e92d40f8          PUSH     {r3-r7,lr}
;;;87     	uint8_t *pProductRevisionMajor, uint8_t *pProductRevisionMinor)
;;;88     {
00005c  e1a06000          MOV      r6,r0
000060  e1a04001          MOV      r4,r1
000064  e1a05002          MOV      r5,r2
;;;89     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000068  e3a07000          MOV      r7,#0
;;;90     	uint8_t revision_id;
;;;91     
;;;92     	LOG_FUNCTION_START("");
;;;93     
;;;94     	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_IDENTIFICATION_REVISION_ID,
00006c  e1a0200d          MOV      r2,sp
000070  e3a010c2          MOV      r1,#0xc2
000074  e1a00006          MOV      r0,r6
000078  ebfffffe          BL       VL53L0X_RdByte
00007c  e1a07000          MOV      r7,r0
;;;95     		&revision_id);
;;;96     	*pProductRevisionMajor = 1;
000080  e3a00001          MOV      r0,#1
000084  e5c40000          STRB     r0,[r4,#0]
;;;97     	*pProductRevisionMinor = (revision_id & 0xF0) >> 4;
000088  e5dd0000          LDRB     r0,[sp,#0]
00008c  e20000f0          AND      r0,r0,#0xf0
000090  e1a00240          ASR      r0,r0,#4
000094  e5c50000          STRB     r0,[r5,#0]
;;;98     
;;;99     	LOG_FUNCTION_END(Status);
;;;100    	return Status;
000098  e1a00007          MOV      r0,r7
;;;101    
;;;102    }
00009c  e8bd80f8          POP      {r3-r7,pc}
;;;103    
                          ENDP

                  VL53L0X_GetDeviceInfo PROC
;;;104    VL53L0X_Error VL53L0X_GetDeviceInfo(VL53L0X_DEV Dev,
0000a0  e92d4070          PUSH     {r4-r6,lr}
;;;105    	VL53L0X_DeviceInfo_t *pVL53L0X_DeviceInfo)
;;;106    {
0000a4  e1a04000          MOV      r4,r0
0000a8  e1a05001          MOV      r5,r1
;;;107    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0000ac  e3a06000          MOV      r6,#0
;;;108    	LOG_FUNCTION_START("");
;;;109    
;;;110    	Status = VL53L0X_get_device_info(Dev, pVL53L0X_DeviceInfo);
0000b0  e1a01005          MOV      r1,r5
0000b4  e1a00004          MOV      r0,r4
0000b8  ebfffffe          BL       VL53L0X_get_device_info
0000bc  e1a06000          MOV      r6,r0
;;;111    
;;;112    	LOG_FUNCTION_END(Status);
;;;113    	return Status;
0000c0  e1a00006          MOV      r0,r6
;;;114    }
0000c4  e8bd8070          POP      {r4-r6,pc}
;;;115    
                          ENDP

                  VL53L0X_GetDeviceErrorStatus PROC
;;;116    VL53L0X_Error VL53L0X_GetDeviceErrorStatus(VL53L0X_DEV Dev,
0000c8  e92d40f8          PUSH     {r3-r7,lr}
;;;117    	VL53L0X_DeviceError *pDeviceErrorStatus)
;;;118    {
0000cc  e1a05000          MOV      r5,r0
0000d0  e1a04001          MOV      r4,r1
;;;119    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0000d4  e3a06000          MOV      r6,#0
;;;120    	uint8_t RangeStatus;
;;;121    
;;;122    	LOG_FUNCTION_START("");
;;;123    
;;;124    	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_RESULT_RANGE_STATUS,
0000d8  e1a0200d          MOV      r2,sp
0000dc  e3a01014          MOV      r1,#0x14
0000e0  e1a00005          MOV      r0,r5
0000e4  ebfffffe          BL       VL53L0X_RdByte
0000e8  e1a06000          MOV      r6,r0
;;;125    		&RangeStatus);
;;;126    
;;;127    	*pDeviceErrorStatus = (VL53L0X_DeviceError)((RangeStatus & 0x78) >> 3);
0000ec  e5dd0000          LDRB     r0,[sp,#0]
0000f0  e2000078          AND      r0,r0,#0x78
0000f4  e1a001c0          ASR      r0,r0,#3
0000f8  e5c40000          STRB     r0,[r4,#0]
;;;128    
;;;129    	LOG_FUNCTION_END(Status);
;;;130    	return Status;
0000fc  e1a00006          MOV      r0,r6
;;;131    }
000100  e8bd80f8          POP      {r3-r7,pc}
;;;132    
                          ENDP

                  VL53L0X_GetDeviceErrorString PROC
;;;133    
;;;134    VL53L0X_Error VL53L0X_GetDeviceErrorString(VL53L0X_DeviceError ErrorCode,
000104  e92d4070          PUSH     {r4-r6,lr}
;;;135    	char *pDeviceErrorString)
;;;136    {
000108  e1a04000          MOV      r4,r0
00010c  e1a05001          MOV      r5,r1
;;;137    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000110  e3a06000          MOV      r6,#0
;;;138    
;;;139    	LOG_FUNCTION_START("");
;;;140    
;;;141    	Status = VL53L0X_get_device_error_string(ErrorCode, pDeviceErrorString);
000114  e1a01005          MOV      r1,r5
000118  e1a00004          MOV      r0,r4
00011c  ebfffffe          BL       VL53L0X_get_device_error_string
000120  e1a06000          MOV      r6,r0
;;;142    
;;;143    	LOG_FUNCTION_END(Status);
;;;144    	return Status;
000124  e1a00006          MOV      r0,r6
;;;145    }
000128  e8bd8070          POP      {r4-r6,pc}
;;;146    
                          ENDP

                  VL53L0X_GetRangeStatusString PROC
;;;147    VL53L0X_Error VL53L0X_GetRangeStatusString(uint8_t RangeStatus,
00012c  e92d4070          PUSH     {r4-r6,lr}
;;;148    	char *pRangeStatusString)
;;;149    {
000130  e1a04000          MOV      r4,r0
000134  e1a05001          MOV      r5,r1
;;;150    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000138  e3a06000          MOV      r6,#0
;;;151    	LOG_FUNCTION_START("");
;;;152    
;;;153    	Status = VL53L0X_get_range_status_string(RangeStatus,
00013c  e1a01005          MOV      r1,r5
000140  e1a00004          MOV      r0,r4
000144  ebfffffe          BL       VL53L0X_get_range_status_string
000148  e1a06000          MOV      r6,r0
;;;154    		pRangeStatusString);
;;;155    
;;;156    	LOG_FUNCTION_END(Status);
;;;157    	return Status;
00014c  e1a00006          MOV      r0,r6
;;;158    }
000150  e8bd8070          POP      {r4-r6,pc}
;;;159    
                          ENDP

                  VL53L0X_GetPalErrorString PROC
;;;160    VL53L0X_Error VL53L0X_GetPalErrorString(VL53L0X_Error PalErrorCode,
000154  e92d4070          PUSH     {r4-r6,lr}
;;;161    	char *pPalErrorString)
;;;162    {
000158  e1a04000          MOV      r4,r0
00015c  e1a05001          MOV      r5,r1
;;;163    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000160  e3a06000          MOV      r6,#0
;;;164    	LOG_FUNCTION_START("");
;;;165    
;;;166    	Status = VL53L0X_get_pal_error_string(PalErrorCode, pPalErrorString);
000164  e1a01005          MOV      r1,r5
000168  e1a00004          MOV      r0,r4
00016c  ebfffffe          BL       VL53L0X_get_pal_error_string
000170  e1a06000          MOV      r6,r0
;;;167    
;;;168    	LOG_FUNCTION_END(Status);
;;;169    	return Status;
000174  e1a00006          MOV      r0,r6
;;;170    }
000178  e8bd8070          POP      {r4-r6,pc}
;;;171    
                          ENDP

                  VL53L0X_GetPalStateString PROC
;;;172    VL53L0X_Error VL53L0X_GetPalStateString(VL53L0X_State PalStateCode,
00017c  e92d4070          PUSH     {r4-r6,lr}
;;;173    	char *pPalStateString)
;;;174    {
000180  e1a04000          MOV      r4,r0
000184  e1a05001          MOV      r5,r1
;;;175    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000188  e3a06000          MOV      r6,#0
;;;176    	LOG_FUNCTION_START("");
;;;177    
;;;178    	Status = VL53L0X_get_pal_state_string(PalStateCode, pPalStateString);
00018c  e1a01005          MOV      r1,r5
000190  e1a00004          MOV      r0,r4
000194  ebfffffe          BL       VL53L0X_get_pal_state_string
000198  e1a06000          MOV      r6,r0
;;;179    
;;;180    	LOG_FUNCTION_END(Status);
;;;181    	return Status;
00019c  e1a00006          MOV      r0,r6
;;;182    }
0001a0  e8bd8070          POP      {r4-r6,pc}
;;;183    
                          ENDP

                  VL53L0X_GetPalState PROC
;;;184    VL53L0X_Error VL53L0X_GetPalState(VL53L0X_DEV Dev, VL53L0X_State *pPalState)
0001a4  e1a02000          MOV      r2,r0
;;;185    {
;;;186    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0001a8  e3a00000          MOV      r0,#0
;;;187    	LOG_FUNCTION_START("");
;;;188    
;;;189    	*pPalState = PALDevDataGet(Dev, PalState);
0001ac  e5d23132          LDRB     r3,[r2,#0x132]
0001b0  e5c13000          STRB     r3,[r1,#0]
;;;190    
;;;191    	LOG_FUNCTION_END(Status);
;;;192    	return Status;
;;;193    }
0001b4  e12fff1e          BX       lr
;;;194    
                          ENDP

                  VL53L0X_GetSequenceStepTimeout PROC
;;;1302   
;;;1303   VL53L0X_Error VL53L0X_GetSequenceStepTimeout(VL53L0X_DEV Dev,
0001b8  e92d43f8          PUSH     {r3-r9,lr}
;;;1304   	VL53L0X_SequenceStepId SequenceStepId, FixPoint1616_t *pTimeOutMilliSecs)
;;;1305   {
0001bc  e1a08000          MOV      r8,r0
0001c0  e1a09001          MOV      r9,r1
0001c4  e1a05002          MOV      r5,r2
;;;1306   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0001c8  e3a06000          MOV      r6,#0
;;;1307   	uint32_t TimeoutMicroSeconds;
;;;1308   	uint32_t WholeNumber_ms = 0;
0001cc  e3a04000          MOV      r4,#0
;;;1309   	uint32_t Fraction_ms = 0;
0001d0  e3a07000          MOV      r7,#0
;;;1310   	LOG_FUNCTION_START("");
;;;1311   
;;;1312   	Status = get_sequence_step_timeout(Dev, SequenceStepId,
0001d4  e1a0200d          MOV      r2,sp
0001d8  e1a01009          MOV      r1,r9
0001dc  e1a00008          MOV      r0,r8
0001e0  ebfffffe          BL       get_sequence_step_timeout
0001e4  e1a06000          MOV      r6,r0
;;;1313   		&TimeoutMicroSeconds);
;;;1314   	if (Status == VL53L0X_ERROR_NONE) {
0001e8  e3560000          CMP      r6,#0
0001ec  1a00000d          BNE      |L1.552|
;;;1315   		WholeNumber_ms = TimeoutMicroSeconds / 1000;
0001f0  e3a01ffa          MOV      r1,#0x3e8
0001f4  e59d0000          LDR      r0,[sp,#0]
0001f8  ebfffffe          BL       __aeabi_uidivmod
0001fc  e1a04000          MOV      r4,r0
;;;1316   		Fraction_ms = TimeoutMicroSeconds - (WholeNumber_ms * 1000);
000200  e0840084          ADD      r0,r4,r4,LSL #1
000204  e0600384          RSB      r0,r0,r4,LSL #7
000208  e59d1000          LDR      r1,[sp,#0]
00020c  e0417180          SUB      r7,r1,r0,LSL #3
;;;1317   		*pTimeOutMilliSecs = (WholeNumber_ms << 16)
000210  e0671807          RSB      r1,r7,r7,LSL #16
000214  e2810f7d          ADD      r0,r1,#0x1f4
000218  e3a01ffa          MOV      r1,#0x3e8
00021c  ebfffffe          BL       __aeabi_uidivmod
000220  e0800804          ADD      r0,r0,r4,LSL #16
000224  e5850000          STR      r0,[r5,#0]
                  |L1.552|
;;;1318   			+ (((Fraction_ms * 0xffff) + 500) / 1000);
;;;1319   	}
;;;1320   
;;;1321   	LOG_FUNCTION_END(Status);
;;;1322   	return Status;
000228  e1a00006          MOV      r0,r6
;;;1323   }
00022c  e8bd83f8          POP      {r3-r9,pc}
;;;1324   
                          ENDP

                  VL53L0X_GetVcselPulsePeriod PROC
;;;1028   
;;;1029   VL53L0X_Error VL53L0X_GetVcselPulsePeriod(VL53L0X_DEV Dev,
000230  e92d41f0          PUSH     {r4-r8,lr}
;;;1030   	VL53L0X_VcselPeriod VcselPeriodType, uint8_t *pVCSELPulsePeriodPCLK)
;;;1031   {
000234  e1a04000          MOV      r4,r0
000238  e1a05001          MOV      r5,r1
00023c  e1a06002          MOV      r6,r2
;;;1032   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000240  e3a07000          MOV      r7,#0
;;;1033   	LOG_FUNCTION_START("");
;;;1034   
;;;1035   	Status = VL53L0X_get_vcsel_pulse_period(Dev, VcselPeriodType,
000244  e1a02006          MOV      r2,r6
000248  e1a01005          MOV      r1,r5
00024c  e1a00004          MOV      r0,r4
000250  ebfffffe          BL       VL53L0X_get_vcsel_pulse_period
000254  e1a07000          MOV      r7,r0
;;;1036   		pVCSELPulsePeriodPCLK);
;;;1037   
;;;1038   	LOG_FUNCTION_END(Status);
;;;1039   	return Status;
000258  e1a00007          MOV      r0,r7
;;;1040   }
00025c  e8bd81f0          POP      {r4-r8,pc}
;;;1041   
                          ENDP

                  VL53L0X_SetMeasurementTimingBudgetMicroSeconds PROC
;;;988    
;;;989    VL53L0X_Error VL53L0X_SetMeasurementTimingBudgetMicroSeconds(VL53L0X_DEV Dev,
000260  e92d4070          PUSH     {r4-r6,lr}
;;;990    	uint32_t MeasurementTimingBudgetMicroSeconds)
;;;991    {
000264  e1a04000          MOV      r4,r0
000268  e1a05001          MOV      r5,r1
;;;992    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00026c  e3a06000          MOV      r6,#0
;;;993    	LOG_FUNCTION_START("");
;;;994    
;;;995    	Status = VL53L0X_set_measurement_timing_budget_micro_seconds(Dev,
000270  e1a01005          MOV      r1,r5
000274  e1a00004          MOV      r0,r4
000278  ebfffffe          BL       VL53L0X_set_measurement_timing_budget_micro_seconds
00027c  e1a06000          MOV      r6,r0
;;;996    		MeasurementTimingBudgetMicroSeconds);
;;;997    
;;;998    	LOG_FUNCTION_END(Status);
;;;999    
;;;1000   	return Status;
000280  e1a00006          MOV      r0,r6
;;;1001   }
000284  e8bd8070          POP      {r4-r6,pc}
;;;1002   
                          ENDP

                  VL53L0X_SetSequenceStepEnable PROC
;;;1041   
;;;1042   VL53L0X_Error VL53L0X_SetSequenceStepEnable(VL53L0X_DEV Dev,
000288  e92d43f8          PUSH     {r3-r9,lr}
;;;1043   	VL53L0X_SequenceStepId SequenceStepId, uint8_t SequenceStepEnabled)
;;;1044   {
00028c  e1a07000          MOV      r7,r0
000290  e1a05001          MOV      r5,r1
000294  e1a08002          MOV      r8,r2
;;;1045   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000298  e3a06000          MOV      r6,#0
;;;1046   	uint8_t SequenceConfig = 0;
00029c  e3a00000          MOV      r0,#0
0002a0  e58d0000          STR      r0,[sp,#0]
;;;1047   	uint8_t SequenceConfigNew = 0;
0002a4  e3a04000          MOV      r4,#0
;;;1048   	uint32_t MeasurementTimingBudgetMicroSeconds;
;;;1049   	LOG_FUNCTION_START("");
;;;1050   
;;;1051   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
0002a8  e1a0200d          MOV      r2,sp
0002ac  e3a01001          MOV      r1,#1
0002b0  e1a00007          MOV      r0,r7
0002b4  ebfffffe          BL       VL53L0X_RdByte
0002b8  e1a06000          MOV      r6,r0
;;;1052   		&SequenceConfig);
;;;1053   
;;;1054   	SequenceConfigNew = SequenceConfig;
0002bc  e5dd4000          LDRB     r4,[sp,#0]
;;;1055   
;;;1056   	if (Status == VL53L0X_ERROR_NONE) {
0002c0  e3560000          CMP      r6,#0
0002c4  1a000037          BNE      |L1.936|
;;;1057   		if (SequenceStepEnabled == 1) {
0002c8  e3580001          CMP      r8,#1
0002cc  1a00001a          BNE      |L1.828|
;;;1058   
;;;1059   			/* Enable requested sequence step
;;;1060   			 */
;;;1061   			switch (SequenceStepId) {
0002d0  e3550005          CMP      r5,#5
0002d4  308ff105          ADDCC    pc,pc,r5,LSL #2
0002d8  ea000013          B        |L1.812|
0002dc  ea000003          B        |L1.752|
0002e0  ea000005          B        |L1.764|
0002e4  ea000007          B        |L1.776|
0002e8  ea000009          B        |L1.788|
0002ec  ea00000b          B        |L1.800|
                  |L1.752|
;;;1062   			case VL53L0X_SEQUENCESTEP_TCC:
0002f0  e1a00000          MOV      r0,r0
;;;1063   				SequenceConfigNew |= 0x10;
0002f4  e3844010          ORR      r4,r4,#0x10
;;;1064   				break;
0002f8  ea00000e          B        |L1.824|
                  |L1.764|
;;;1065   			case VL53L0X_SEQUENCESTEP_DSS:
0002fc  e1a00000          MOV      r0,r0
;;;1066   				SequenceConfigNew |= 0x28;
000300  e3844028          ORR      r4,r4,#0x28
;;;1067   				break;
000304  ea00000b          B        |L1.824|
                  |L1.776|
;;;1068   			case VL53L0X_SEQUENCESTEP_MSRC:
000308  e1a00000          MOV      r0,r0
;;;1069   				SequenceConfigNew |= 0x04;
00030c  e3844004          ORR      r4,r4,#4
;;;1070   				break;
000310  ea000008          B        |L1.824|
                  |L1.788|
;;;1071   			case VL53L0X_SEQUENCESTEP_PRE_RANGE:
000314  e1a00000          MOV      r0,r0
;;;1072   				SequenceConfigNew |= 0x40;
000318  e3844040          ORR      r4,r4,#0x40
;;;1073   				break;
00031c  ea000005          B        |L1.824|
                  |L1.800|
;;;1074   			case VL53L0X_SEQUENCESTEP_FINAL_RANGE:
000320  e1a00000          MOV      r0,r0
;;;1075   				SequenceConfigNew |= 0x80;
000324  e3844080          ORR      r4,r4,#0x80
;;;1076   				break;
000328  ea000002          B        |L1.824|
                  |L1.812|
;;;1077   			default:
00032c  e1a00000          MOV      r0,r0
;;;1078   				Status = VL53L0X_ERROR_INVALID_PARAMS;
000330  e3e06003          MVN      r6,#3
000334  e1a00000          MOV      r0,r0                 ;1061
                  |L1.824|
000338  ea00001a          B        |L1.936|
                  |L1.828|
;;;1079   			}
;;;1080   		} else {
;;;1081   			/* Disable requested sequence step
;;;1082   			 */
;;;1083   			switch (SequenceStepId) {
00033c  e3550005          CMP      r5,#5
000340  308ff105          ADDCC    pc,pc,r5,LSL #2
000344  ea000013          B        |L1.920|
000348  ea000003          B        |L1.860|
00034c  ea000005          B        |L1.872|
000350  ea000007          B        |L1.884|
000354  ea000009          B        |L1.896|
000358  ea00000b          B        |L1.908|
                  |L1.860|
;;;1084   			case VL53L0X_SEQUENCESTEP_TCC:
00035c  e1a00000          MOV      r0,r0
;;;1085   				SequenceConfigNew &= 0xef;
000360  e20440ef          AND      r4,r4,#0xef
;;;1086   				break;
000364  ea00000e          B        |L1.932|
                  |L1.872|
;;;1087   			case VL53L0X_SEQUENCESTEP_DSS:
000368  e1a00000          MOV      r0,r0
;;;1088   				SequenceConfigNew &= 0xd7;
00036c  e20440d7          AND      r4,r4,#0xd7
;;;1089   				break;
000370  ea00000b          B        |L1.932|
                  |L1.884|
;;;1090   			case VL53L0X_SEQUENCESTEP_MSRC:
000374  e1a00000          MOV      r0,r0
;;;1091   				SequenceConfigNew &= 0xfb;
000378  e20440fb          AND      r4,r4,#0xfb
;;;1092   				break;
00037c  ea000008          B        |L1.932|
                  |L1.896|
;;;1093   			case VL53L0X_SEQUENCESTEP_PRE_RANGE:
000380  e1a00000          MOV      r0,r0
;;;1094   				SequenceConfigNew &= 0xbf;
000384  e20440bf          AND      r4,r4,#0xbf
;;;1095   				break;
000388  ea000005          B        |L1.932|
                  |L1.908|
;;;1096   			case VL53L0X_SEQUENCESTEP_FINAL_RANGE:
00038c  e1a00000          MOV      r0,r0
;;;1097   				SequenceConfigNew &= 0x7f;
000390  e204407f          AND      r4,r4,#0x7f
;;;1098   				break;
000394  ea000002          B        |L1.932|
                  |L1.920|
;;;1099   			default:
000398  e1a00000          MOV      r0,r0
;;;1100   				Status = VL53L0X_ERROR_INVALID_PARAMS;
00039c  e3e06003          MVN      r6,#3
0003a0  e1a00000          MOV      r0,r0                 ;1083
                  |L1.932|
0003a4  e1a00000          MOV      r0,r0                 ;1086
                  |L1.936|
;;;1101   			}
;;;1102   		}
;;;1103   	}
;;;1104   
;;;1105   	if (SequenceConfigNew != SequenceConfig) {
0003a8  e5dd0000          LDRB     r0,[sp,#0]
0003ac  e1540000          CMP      r4,r0
0003b0  0a00000f          BEQ      |L1.1012|
;;;1106   		/* Apply New Setting */
;;;1107   		if (Status == VL53L0X_ERROR_NONE) {
0003b4  e3560000          CMP      r6,#0
0003b8  1a000004          BNE      |L1.976|
;;;1108   			Status = VL53L0X_WrByte(Dev,
0003bc  e1a02004          MOV      r2,r4
0003c0  e3a01001          MOV      r1,#1
0003c4  e1a00007          MOV      r0,r7
0003c8  ebfffffe          BL       VL53L0X_WrByte
0003cc  e1a06000          MOV      r6,r0
                  |L1.976|
;;;1109   			VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, SequenceConfigNew);
;;;1110   		}
;;;1111   		if (Status == VL53L0X_ERROR_NONE)
0003d0  e3560000          CMP      r6,#0
0003d4  1a000000          BNE      |L1.988|
;;;1112   			PALDevDataSet(Dev, SequenceConfig, SequenceConfigNew);
0003d8  e5c74130          STRB     r4,[r7,#0x130]
                  |L1.988|
;;;1113   
;;;1114   
;;;1115   		/* Recalculate timing budget */
;;;1116   		if (Status == VL53L0X_ERROR_NONE) {
0003dc  e3560000          CMP      r6,#0
0003e0  1a000003          BNE      |L1.1012|
;;;1117   			VL53L0X_GETPARAMETERFIELD(Dev,
0003e4  e5979014          LDR      r9,[r7,#0x14]
;;;1118   				MeasurementTimingBudgetMicroSeconds,
;;;1119   				MeasurementTimingBudgetMicroSeconds);
;;;1120   
;;;1121   			VL53L0X_SetMeasurementTimingBudgetMicroSeconds(Dev,
0003e8  e1a01009          MOV      r1,r9
0003ec  e1a00007          MOV      r0,r7
0003f0  ebfffffe          BL       VL53L0X_SetMeasurementTimingBudgetMicroSeconds
                  |L1.1012|
;;;1122   				MeasurementTimingBudgetMicroSeconds);
;;;1123   		}
;;;1124   	}
;;;1125   
;;;1126   	LOG_FUNCTION_END(Status);
;;;1127   
;;;1128   	return Status;
0003f4  e1a00006          MOV      r0,r6
;;;1129   }
0003f8  e8bd83f8          POP      {r3-r9,pc}
;;;1130   
                          ENDP

                  VL53L0X_GetFractionEnable PROC
;;;950    
;;;951    VL53L0X_Error VL53L0X_GetFractionEnable(VL53L0X_DEV Dev, uint8_t *pEnabled)
0003fc  e92d4070          PUSH     {r4-r6,lr}
;;;952    {
000400  e1a06000          MOV      r6,r0
000404  e1a04001          MOV      r4,r1
;;;953    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000408  e3a05000          MOV      r5,#0
;;;954    	LOG_FUNCTION_START("");
;;;955    
;;;956    	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_RANGE_CONFIG, pEnabled);
00040c  e1a02004          MOV      r2,r4
000410  e3a01009          MOV      r1,#9
000414  e1a00006          MOV      r0,r6
000418  ebfffffe          BL       VL53L0X_RdByte
00041c  e1a05000          MOV      r5,r0
;;;957    
;;;958    	if (Status == VL53L0X_ERROR_NONE)
000420  e3550000          CMP      r5,#0
000424  1a000002          BNE      |L1.1076|
;;;959    		*pEnabled = (*pEnabled & 1);
000428  e5d40000          LDRB     r0,[r4,#0]
00042c  e2000001          AND      r0,r0,#1
000430  e5c40000          STRB     r0,[r4,#0]
                  |L1.1076|
;;;960    
;;;961    	LOG_FUNCTION_END(Status);
;;;962    	return Status;
000434  e1a00005          MOV      r0,r5
;;;963    }
000438  e8bd8070          POP      {r4-r6,pc}
;;;964    
                          ENDP

                  VL53L0X_GetMeasurementTimingBudgetMicroSeconds PROC
;;;1002   
;;;1003   VL53L0X_Error VL53L0X_GetMeasurementTimingBudgetMicroSeconds(VL53L0X_DEV Dev,
00043c  e92d4070          PUSH     {r4-r6,lr}
;;;1004   	uint32_t *pMeasurementTimingBudgetMicroSeconds)
;;;1005   {
000440  e1a04000          MOV      r4,r0
000444  e1a05001          MOV      r5,r1
;;;1006   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000448  e3a06000          MOV      r6,#0
;;;1007   	LOG_FUNCTION_START("");
;;;1008   
;;;1009   	Status = VL53L0X_get_measurement_timing_budget_micro_seconds(Dev,
00044c  e1a01005          MOV      r1,r5
000450  e1a00004          MOV      r0,r4
000454  ebfffffe          BL       VL53L0X_get_measurement_timing_budget_micro_seconds
000458  e1a06000          MOV      r6,r0
;;;1010   		pMeasurementTimingBudgetMicroSeconds);
;;;1011   
;;;1012   	LOG_FUNCTION_END(Status);
;;;1013   	return Status;
00045c  e1a00006          MOV      r0,r6
;;;1014   }
000460  e8bd8070          POP      {r4-r6,pc}
;;;1015   
                          ENDP

                  VL53L0X_GetWrapAroundCheckEnable PROC
;;;1989   
;;;1990   VL53L0X_Error VL53L0X_GetWrapAroundCheckEnable(VL53L0X_DEV Dev,
000464  e92d40f8          PUSH     {r3-r7,lr}
;;;1991   	uint8_t *pWrapAroundCheckEnable)
;;;1992   {
000468  e1a05000          MOV      r5,r0
00046c  e1a04001          MOV      r4,r1
;;;1993   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000470  e3a06000          MOV      r6,#0
;;;1994   	uint8_t data;
;;;1995   
;;;1996   	LOG_FUNCTION_START("");
;;;1997   
;;;1998   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, &data);
000474  e1a0200d          MOV      r2,sp
000478  e3a01001          MOV      r1,#1
00047c  e1a00005          MOV      r0,r5
000480  ebfffffe          BL       VL53L0X_RdByte
000484  e1a06000          MOV      r6,r0
;;;1999   	if (Status == VL53L0X_ERROR_NONE) {
000488  e3560000          CMP      r6,#0
00048c  1a000009          BNE      |L1.1208|
;;;2000   		PALDevDataSet(Dev, SequenceConfig, data);
000490  e5dd0000          LDRB     r0,[sp,#0]
000494  e5c50130          STRB     r0,[r5,#0x130]
;;;2001   		if (data & (0x01 << 7))
000498  e5dd0000          LDRB     r0,[sp,#0]
00049c  e3100080          TST      r0,#0x80
0004a0  0a000002          BEQ      |L1.1200|
;;;2002   			*pWrapAroundCheckEnable = 0x01;
0004a4  e3a00001          MOV      r0,#1
0004a8  e5c40000          STRB     r0,[r4,#0]
0004ac  ea000001          B        |L1.1208|
                  |L1.1200|
;;;2003   		else
;;;2004   			*pWrapAroundCheckEnable = 0x00;
0004b0  e3a00000          MOV      r0,#0
0004b4  e5c40000          STRB     r0,[r4,#0]
                  |L1.1208|
;;;2005   	}
;;;2006   	if (Status == VL53L0X_ERROR_NONE) {
0004b8  e3560000          CMP      r6,#0
0004bc  1a000001          BNE      |L1.1224|
;;;2007   		VL53L0X_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
0004c0  e5d40000          LDRB     r0,[r4,#0]
0004c4  e5c5004c          STRB     r0,[r5,#0x4c]
                  |L1.1224|
;;;2008   			*pWrapAroundCheckEnable);
;;;2009   	}
;;;2010   
;;;2011   	LOG_FUNCTION_END(Status);
;;;2012   	return Status;
0004c8  e1a00006          MOV      r0,r6
;;;2013   }
0004cc  e8bd80f8          POP      {r3-r7,pc}
;;;2014   
                          ENDP

                  VL53L0X_GetLimitCheckEnable PROC
;;;1694   
;;;1695   VL53L0X_Error VL53L0X_GetLimitCheckEnable(VL53L0X_DEV Dev, uint16_t LimitCheckId,
0004d0  e92d4010          PUSH     {r4,lr}
;;;1696   	uint8_t *pLimitCheckEnable)
;;;1697   {
0004d4  e1a03000          MOV      r3,r0
;;;1698   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0004d8  e3a00000          MOV      r0,#0
;;;1699   	uint8_t Temp8;
;;;1700   
;;;1701   	LOG_FUNCTION_START("");
;;;1702   
;;;1703   	if (LimitCheckId >= VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS) {
0004dc  e3510006          CMP      r1,#6
0004e0  ba000003          BLT      |L1.1268|
;;;1704   		Status = VL53L0X_ERROR_INVALID_PARAMS;
0004e4  e3e00003          MVN      r0,#3
;;;1705   		*pLimitCheckEnable = 0;
0004e8  e3a04000          MOV      r4,#0
0004ec  e5c24000          STRB     r4,[r2,#0]
0004f0  ea000002          B        |L1.1280|
                  |L1.1268|
;;;1706   	} else {
;;;1707   		VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
0004f4  e2834028          ADD      r4,r3,#0x28
0004f8  e7d4c001          LDRB     r12,[r4,r1]
;;;1708   			LimitCheckId, Temp8);
;;;1709   		*pLimitCheckEnable = Temp8;
0004fc  e5c2c000          STRB     r12,[r2,#0]
                  |L1.1280|
;;;1710   	}
;;;1711   
;;;1712   	LOG_FUNCTION_END(Status);
;;;1713   	return Status;
;;;1714   }
000500  e8bd8010          POP      {r4,pc}
;;;1715   
                          ENDP

                  VL53L0X_GetLimitCheckValue PROC
;;;1792   
;;;1793   VL53L0X_Error VL53L0X_GetLimitCheckValue(VL53L0X_DEV Dev, uint16_t LimitCheckId,
000504  e92d43f8          PUSH     {r3-r9,lr}
;;;1794   	FixPoint1616_t *pLimitCheckValue)
;;;1795   {
000508  e1a05000          MOV      r5,r0
00050c  e1a06001          MOV      r6,r1
000510  e1a07002          MOV      r7,r2
;;;1796   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000514  e3a08000          MOV      r8,#0
;;;1797   	uint8_t EnableZeroValue = 0;
000518  e3a09000          MOV      r9,#0
;;;1798   	uint16_t Temp16;
;;;1799   	FixPoint1616_t TempFix1616;
;;;1800   
;;;1801   	LOG_FUNCTION_START("");
;;;1802   
;;;1803   	switch (LimitCheckId) {
00051c  e3560006          CMP      r6,#6
000520  308ff106          ADDCC    pc,pc,r6,LSL #2
000524  ea00002a          B        |L1.1492|
000528  ea000004          B        |L1.1344|
00052c  ea000007          B        |L1.1360|
000530  ea000012          B        |L1.1408|
000534  ea000015          B        |L1.1424|
000538  ea000018          B        |L1.1440|
00053c  ea000019          B        |L1.1448|
                  |L1.1344|
;;;1804   
;;;1805   	case VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE:
000540  e1a00000          MOV      r0,r0
;;;1806   		/* internal computation: */
;;;1807   		VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
000544  e5954034          LDR      r4,[r5,#0x34]
;;;1808   			VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, TempFix1616);
;;;1809   		EnableZeroValue = 0;
000548  e3a09000          MOV      r9,#0
;;;1810   		break;
00054c  ea000023          B        |L1.1504|
                  |L1.1360|
;;;1811   
;;;1812   	case VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
000550  e1a00000          MOV      r0,r0
;;;1813   		Status = VL53L0X_RdWord(Dev,
000554  e1a0200d          MOV      r2,sp
000558  e3a01044          MOV      r1,#0x44
00055c  e1a00005          MOV      r0,r5
000560  ebfffffe          BL       VL53L0X_RdWord
000564  e1a08000          MOV      r8,r0
;;;1814   		VL53L0X_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
;;;1815   			&Temp16);
;;;1816   		if (Status == VL53L0X_ERROR_NONE)
000568  e3580000          CMP      r8,#0
00056c  1a000001          BNE      |L1.1400|
;;;1817   			TempFix1616 = VL53L0X_FIXPOINT97TOFIXPOINT1616(Temp16);
000570  e1dd00b0          LDRH     r0,[sp,#0]
000574  e1a04480          LSL      r4,r0,#9
                  |L1.1400|
;;;1818   
;;;1819   
;;;1820   		EnableZeroValue = 1;
000578  e3a09001          MOV      r9,#1
;;;1821   		break;
00057c  ea000017          B        |L1.1504|
                  |L1.1408|
;;;1822   
;;;1823   	case VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP:
000580  e1a00000          MOV      r0,r0
;;;1824   		/* internal computation: */
;;;1825   		VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
000584  e595403c          LDR      r4,[r5,#0x3c]
;;;1826   			VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP, TempFix1616);
;;;1827   		EnableZeroValue = 0;
000588  e3a09000          MOV      r9,#0
;;;1828   		break;
00058c  ea000013          B        |L1.1504|
                  |L1.1424|
;;;1829   
;;;1830   	case VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD:
000590  e1a00000          MOV      r0,r0
;;;1831   		/* internal computation: */
;;;1832   		VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
000594  e5954040          LDR      r4,[r5,#0x40]
;;;1833   			VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD, TempFix1616);
;;;1834   		EnableZeroValue = 0;
000598  e3a09000          MOV      r9,#0
;;;1835   		break;
00059c  ea00000f          B        |L1.1504|
                  |L1.1440|
;;;1836   
;;;1837   	case VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC:
0005a0  e1a00000          MOV      r0,r0
;;;1838   	case VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE:
0005a4  e1a00000          MOV      r0,r0
                  |L1.1448|
;;;1839   		Status = VL53L0X_RdWord(Dev,
0005a8  e1a0200d          MOV      r2,sp
0005ac  e3a01064          MOV      r1,#0x64
0005b0  e1a00005          MOV      r0,r5
0005b4  ebfffffe          BL       VL53L0X_RdWord
0005b8  e1a08000          MOV      r8,r0
;;;1840   			VL53L0X_REG_PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT,
;;;1841   			&Temp16);
;;;1842   		if (Status == VL53L0X_ERROR_NONE)
0005bc  e3580000          CMP      r8,#0
0005c0  1a000001          BNE      |L1.1484|
;;;1843   			TempFix1616 = VL53L0X_FIXPOINT97TOFIXPOINT1616(Temp16);
0005c4  e1dd00b0          LDRH     r0,[sp,#0]
0005c8  e1a04480          LSL      r4,r0,#9
                  |L1.1484|
;;;1844   
;;;1845   
;;;1846   		EnableZeroValue = 0;
0005cc  e3a09000          MOV      r9,#0
;;;1847   		break;
0005d0  ea000002          B        |L1.1504|
                  |L1.1492|
;;;1848   
;;;1849   	default:
0005d4  e1a00000          MOV      r0,r0
;;;1850   		Status = VL53L0X_ERROR_INVALID_PARAMS;
0005d8  e3e08003          MVN      r8,#3
0005dc  e1a00000          MOV      r0,r0                 ;1803
                  |L1.1504|
0005e0  e1a00000          MOV      r0,r0                 ;1810
;;;1851   
;;;1852   	}
;;;1853   
;;;1854   	if (Status == VL53L0X_ERROR_NONE) {
0005e4  e3580000          CMP      r8,#0
0005e8  1a000012          BNE      |L1.1592|
;;;1855   
;;;1856   		if (EnableZeroValue == 1) {
0005ec  e3590001          CMP      r9,#1
0005f0  1a00000f          BNE      |L1.1588|
;;;1857   
;;;1858   			if (TempFix1616 == 0) {
0005f4  e3540000          CMP      r4,#0
0005f8  1a000006          BNE      |L1.1560|
;;;1859   				/* disabled: return value from memory */
;;;1860   				VL53L0X_GETARRAYPARAMETERFIELD(Dev,
0005fc  e2850034          ADD      r0,r5,#0x34
000600  e7904106          LDR      r4,[r0,r6,LSL #2]
;;;1861   					LimitChecksValue, LimitCheckId,
;;;1862   					TempFix1616);
;;;1863   				*pLimitCheckValue = TempFix1616;
000604  e5874000          STR      r4,[r7,#0]
;;;1864   				VL53L0X_SETARRAYPARAMETERFIELD(Dev,
000608  e3a00000          MOV      r0,#0
00060c  e2851028          ADD      r1,r5,#0x28
000610  e7c10006          STRB     r0,[r1,r6]
000614  ea000007          B        |L1.1592|
                  |L1.1560|
;;;1865   					LimitChecksEnable, LimitCheckId, 0);
;;;1866   			} else {
;;;1867   				*pLimitCheckValue = TempFix1616;
000618  e5874000          STR      r4,[r7,#0]
;;;1868   				VL53L0X_SETARRAYPARAMETERFIELD(Dev,
00061c  e2850034          ADD      r0,r5,#0x34
000620  e7804106          STR      r4,[r0,r6,LSL #2]
;;;1869   					LimitChecksValue, LimitCheckId,
;;;1870   					TempFix1616);
;;;1871   				VL53L0X_SETARRAYPARAMETERFIELD(Dev,
000624  e3a00001          MOV      r0,#1
000628  e2851028          ADD      r1,r5,#0x28
00062c  e7c10006          STRB     r0,[r1,r6]
000630  ea000000          B        |L1.1592|
                  |L1.1588|
;;;1872   					LimitChecksEnable, LimitCheckId, 1);
;;;1873   			}
;;;1874   		} else {
;;;1875   			*pLimitCheckValue = TempFix1616;
000634  e5874000          STR      r4,[r7,#0]
                  |L1.1592|
;;;1876   		}
;;;1877   	}
;;;1878   
;;;1879   	LOG_FUNCTION_END(Status);
;;;1880   	return Status;
000638  e1a00008          MOV      r0,r8
;;;1881   
;;;1882   }
00063c  e8bd83f8          POP      {r3-r9,pc}
;;;1883   
                          ENDP

                  VL53L0X_GetOffsetCalibrationDataMicroMeter PROC
;;;265    
;;;266    VL53L0X_Error VL53L0X_GetOffsetCalibrationDataMicroMeter(VL53L0X_DEV Dev,
000640  e92d4070          PUSH     {r4-r6,lr}
;;;267    	int32_t *pOffsetCalibrationDataMicroMeter)
;;;268    {
000644  e1a04000          MOV      r4,r0
000648  e1a05001          MOV      r5,r1
;;;269    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00064c  e3a06000          MOV      r6,#0
;;;270    	LOG_FUNCTION_START("");
;;;271    
;;;272    	Status = VL53L0X_get_offset_calibration_data_micro_meter(Dev,
000650  e1a01005          MOV      r1,r5
000654  e1a00004          MOV      r0,r4
000658  ebfffffe          BL       VL53L0X_get_offset_calibration_data_micro_meter
00065c  e1a06000          MOV      r6,r0
;;;273    		pOffsetCalibrationDataMicroMeter);
;;;274    
;;;275    	LOG_FUNCTION_END(Status);
;;;276    	return Status;
000660  e1a00006          MOV      r0,r6
;;;277    }
000664  e8bd8070          POP      {r4-r6,pc}
;;;278    
                          ENDP

                  VL53L0X_GetXTalkCompensationRateMegaCps PROC
;;;1482   
;;;1483   VL53L0X_Error VL53L0X_GetXTalkCompensationRateMegaCps(VL53L0X_DEV Dev,
000668  e92d40f8          PUSH     {r3-r7,lr}
;;;1484   	FixPoint1616_t *pXTalkCompensationRateMegaCps)
;;;1485   {
00066c  e1a04000          MOV      r4,r0
000670  e1a06001          MOV      r6,r1
;;;1486   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000674  e3a07000          MOV      r7,#0
;;;1487   	uint16_t Value;
;;;1488   	FixPoint1616_t TempFix1616;
;;;1489   
;;;1490   	LOG_FUNCTION_START("");
;;;1491   
;;;1492   	Status = VL53L0X_RdWord(Dev,
000678  e1a0200d          MOV      r2,sp
00067c  e3a01020          MOV      r1,#0x20
000680  e1a00004          MOV      r0,r4
000684  ebfffffe          BL       VL53L0X_RdWord
000688  e1a07000          MOV      r7,r0
;;;1493   	VL53L0X_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS, (uint16_t *)&Value);
;;;1494   	if (Status == VL53L0X_ERROR_NONE) {
00068c  e3570000          CMP      r7,#0
000690  1a00000d          BNE      |L1.1740|
;;;1495   		if (Value == 0) {
000694  e1dd00b0          LDRH     r0,[sp,#0]
000698  e3500000          CMP      r0,#0
00069c  1a000004          BNE      |L1.1716|
;;;1496   			/* the Xtalk is disabled return value from memory */
;;;1497   			VL53L0X_GETPARAMETERFIELD(Dev,
0006a0  e5945020          LDR      r5,[r4,#0x20]
;;;1498   				XTalkCompensationRateMegaCps, TempFix1616);
;;;1499   			*pXTalkCompensationRateMegaCps = TempFix1616;
0006a4  e5865000          STR      r5,[r6,#0]
;;;1500   			VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
0006a8  e3a00000          MOV      r0,#0
0006ac  e5c4001c          STRB     r0,[r4,#0x1c]
0006b0  ea000005          B        |L1.1740|
                  |L1.1716|
;;;1501   				0);
;;;1502   		} else {
;;;1503   			TempFix1616 = VL53L0X_FIXPOINT313TOFIXPOINT1616(Value);
0006b4  e1dd00b0          LDRH     r0,[sp,#0]
0006b8  e1a05180          LSL      r5,r0,#3
;;;1504   			*pXTalkCompensationRateMegaCps = TempFix1616;
0006bc  e5865000          STR      r5,[r6,#0]
;;;1505   			VL53L0X_SETPARAMETERFIELD(Dev,
0006c0  e5845020          STR      r5,[r4,#0x20]
;;;1506   				XTalkCompensationRateMegaCps, TempFix1616);
;;;1507   			VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
0006c4  e3a00001          MOV      r0,#1
0006c8  e5c4001c          STRB     r0,[r4,#0x1c]
                  |L1.1740|
;;;1508   				1);
;;;1509   		}
;;;1510   	}
;;;1511   
;;;1512   	LOG_FUNCTION_END(Status);
;;;1513   	return Status;
0006cc  e1a00007          MOV      r0,r7
;;;1514   }
0006d0  e8bd80f8          POP      {r3-r7,pc}
;;;1515   
                          ENDP

                  VL53L0X_GetInterMeasurementPeriodMilliSeconds PROC
;;;1360   
;;;1361   VL53L0X_Error VL53L0X_GetInterMeasurementPeriodMilliSeconds(VL53L0X_DEV Dev,
0006d4  e92d407c          PUSH     {r2-r6,lr}
;;;1362   	uint32_t *pInterMeasurementPeriodMilliSeconds)
;;;1363   {
0006d8  e1a06000          MOV      r6,r0
0006dc  e1a04001          MOV      r4,r1
;;;1364   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0006e0  e3a05000          MOV      r5,#0
;;;1365   	uint16_t osc_calibrate_val;
;;;1366   	uint32_t IMPeriodMilliSeconds;
;;;1367   
;;;1368   	LOG_FUNCTION_START("");
;;;1369   
;;;1370   	Status = VL53L0X_RdWord(Dev, VL53L0X_REG_OSC_CALIBRATE_VAL,
0006e4  e28d2004          ADD      r2,sp,#4
0006e8  e3a010f8          MOV      r1,#0xf8
0006ec  e1a00006          MOV      r0,r6
0006f0  ebfffffe          BL       VL53L0X_RdWord
0006f4  e1a05000          MOV      r5,r0
;;;1371   		&osc_calibrate_val);
;;;1372   
;;;1373   	if (Status == VL53L0X_ERROR_NONE) {
0006f8  e3550000          CMP      r5,#0
0006fc  1a000004          BNE      |L1.1812|
;;;1374   		Status = VL53L0X_RdDWord(Dev,
000700  e1a0200d          MOV      r2,sp
000704  e3a01004          MOV      r1,#4
000708  e1a00006          MOV      r0,r6
00070c  ebfffffe          BL       VL53L0X_RdDWord
000710  e1a05000          MOV      r5,r0
                  |L1.1812|
;;;1375   		VL53L0X_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
;;;1376   			&IMPeriodMilliSeconds);
;;;1377   	}
;;;1378   
;;;1379   	if (Status == VL53L0X_ERROR_NONE) {
000714  e3550000          CMP      r5,#0
000718  1a000008          BNE      |L1.1856|
;;;1380   		if (osc_calibrate_val != 0) {
00071c  e1dd00b4          LDRH     r0,[sp,#4]
000720  e3500000          CMP      r0,#0
000724  0a000003          BEQ      |L1.1848|
;;;1381   			*pInterMeasurementPeriodMilliSeconds =
000728  e1dd10b4          LDRH     r1,[sp,#4]
00072c  e59d0000          LDR      r0,[sp,#0]
000730  ebfffffe          BL       __aeabi_uidivmod
000734  e5840000          STR      r0,[r4,#0]
                  |L1.1848|
;;;1382   				IMPeriodMilliSeconds / osc_calibrate_val;
;;;1383   		}
;;;1384   		VL53L0X_SETPARAMETERFIELD(Dev,
000738  e5940000          LDR      r0,[r4,#0]
00073c  e5860018          STR      r0,[r6,#0x18]
                  |L1.1856|
;;;1385   			InterMeasurementPeriodMilliSeconds,
;;;1386   			*pInterMeasurementPeriodMilliSeconds);
;;;1387   	}
;;;1388   
;;;1389   	LOG_FUNCTION_END(Status);
;;;1390   	return Status;
000740  e1a00005          MOV      r0,r5
;;;1391   }
000744  e8bd807c          POP      {r2-r6,pc}
;;;1392   
                          ENDP

                  VL53L0X_GetDeviceMode PROC
;;;923    
;;;924    VL53L0X_Error VL53L0X_GetDeviceMode(VL53L0X_DEV Dev,
000748  e1a02000          MOV      r2,r0
;;;925    	VL53L0X_DeviceModes *pDeviceMode)
;;;926    {
;;;927    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00074c  e3a00000          MOV      r0,#0
;;;928    	LOG_FUNCTION_START("");
;;;929    
;;;930    	VL53L0X_GETPARAMETERFIELD(Dev, DeviceMode, *pDeviceMode);
000750  e5d23010          LDRB     r3,[r2,#0x10]
000754  e5c13000          STRB     r3,[r1,#0]
;;;931    
;;;932    	LOG_FUNCTION_END(Status);
;;;933    	return Status;
;;;934    }
000758  e12fff1e          BX       lr
;;;935    
                          ENDP

                  VL53L0X_GetDeviceParameters PROC
;;;835    
;;;836    VL53L0X_Error VL53L0X_GetDeviceParameters(VL53L0X_DEV Dev,
00075c  e92d41f0          PUSH     {r4-r8,lr}
;;;837    	VL53L0X_DeviceParameters_t *pDeviceParameters)
;;;838    {
000760  e1a07000          MOV      r7,r0
000764  e1a05001          MOV      r5,r1
;;;839    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000768  e3a04000          MOV      r4,#0
;;;840    	int i;
;;;841    
;;;842    	LOG_FUNCTION_START("");
;;;843    
;;;844    	Status = VL53L0X_GetDeviceMode(Dev, &(pDeviceParameters->DeviceMode));
00076c  e1a01005          MOV      r1,r5
000770  e1a00007          MOV      r0,r7
000774  ebfffffe          BL       VL53L0X_GetDeviceMode
000778  e1a04000          MOV      r4,r0
;;;845    
;;;846    	if (Status == VL53L0X_ERROR_NONE)
00077c  e3540000          CMP      r4,#0
000780  1a000003          BNE      |L1.1940|
;;;847    		Status = VL53L0X_GetInterMeasurementPeriodMilliSeconds(Dev,
000784  e2851008          ADD      r1,r5,#8
000788  e1a00007          MOV      r0,r7
00078c  ebfffffe          BL       VL53L0X_GetInterMeasurementPeriodMilliSeconds
000790  e1a04000          MOV      r4,r0
                  |L1.1940|
;;;848    		&(pDeviceParameters->InterMeasurementPeriodMilliSeconds));
;;;849    
;;;850    
;;;851    	if (Status == VL53L0X_ERROR_NONE)
000794  e3540000          CMP      r4,#0
000798  1a000001          BNE      |L1.1956|
;;;852    		pDeviceParameters->XTalkCompensationEnable = 0;
00079c  e3a00000          MOV      r0,#0
0007a0  e5c5000c          STRB     r0,[r5,#0xc]
                  |L1.1956|
;;;853    
;;;854    	if (Status == VL53L0X_ERROR_NONE)
0007a4  e3540000          CMP      r4,#0
0007a8  1a000003          BNE      |L1.1980|
;;;855    		Status = VL53L0X_GetXTalkCompensationRateMegaCps(Dev,
0007ac  e2851010          ADD      r1,r5,#0x10
0007b0  e1a00007          MOV      r0,r7
0007b4  ebfffffe          BL       VL53L0X_GetXTalkCompensationRateMegaCps
0007b8  e1a04000          MOV      r4,r0
                  |L1.1980|
;;;856    			&(pDeviceParameters->XTalkCompensationRateMegaCps));
;;;857    
;;;858    
;;;859    	if (Status == VL53L0X_ERROR_NONE)
0007bc  e3540000          CMP      r4,#0
0007c0  1a000003          BNE      |L1.2004|
;;;860    		Status = VL53L0X_GetOffsetCalibrationDataMicroMeter(Dev,
0007c4  e2851014          ADD      r1,r5,#0x14
0007c8  e1a00007          MOV      r0,r7
0007cc  ebfffffe          BL       VL53L0X_GetOffsetCalibrationDataMicroMeter
0007d0  e1a04000          MOV      r4,r0
                  |L1.2004|
;;;861    			&(pDeviceParameters->RangeOffsetMicroMeters));
;;;862    
;;;863    
;;;864    	if (Status == VL53L0X_ERROR_NONE) {
0007d4  e3540000          CMP      r4,#0
0007d8  1a00001b          BNE      |L1.2124|
;;;865    		for (i = 0; i < VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
0007dc  e3a06000          MOV      r6,#0
0007e0  ea000016          B        |L1.2112|
                  |L1.2020|
;;;866    			/* get first the values, then the enables.
;;;867    			 * VL53L0X_GetLimitCheckValue will modify the enable
;;;868    			 * flags
;;;869    			 */
;;;870    			if (Status == VL53L0X_ERROR_NONE) {
0007e4  e3540000          CMP      r4,#0
0007e8  1a000007          BNE      |L1.2060|
;;;871    				Status |= VL53L0X_GetLimitCheckValue(Dev, i,
0007ec  e2850024          ADD      r0,r5,#0x24
0007f0  e0802106          ADD      r2,r0,r6,LSL #2
0007f4  e1a01806          LSL      r1,r6,#16
0007f8  e1a01821          LSR      r1,r1,#16
0007fc  e1a00007          MOV      r0,r7
000800  ebfffffe          BL       VL53L0X_GetLimitCheckValue
000804  e1844000          ORR      r4,r4,r0
000808  ea000000          B        |L1.2064|
                  |L1.2060|
;;;872    				&(pDeviceParameters->LimitChecksValue[i]));
;;;873    			} else {
;;;874    				break;
00080c  ea00000d          B        |L1.2120|
                  |L1.2064|
;;;875    			}
;;;876    			if (Status == VL53L0X_ERROR_NONE) {
000810  e3540000          CMP      r4,#0
000814  1a000007          BNE      |L1.2104|
;;;877    				Status |= VL53L0X_GetLimitCheckEnable(Dev, i,
000818  e2850018          ADD      r0,r5,#0x18
00081c  e0802006          ADD      r2,r0,r6
000820  e1a01806          LSL      r1,r6,#16
000824  e1a01821          LSR      r1,r1,#16
000828  e1a00007          MOV      r0,r7
00082c  ebfffffe          BL       VL53L0X_GetLimitCheckEnable
000830  e1844000          ORR      r4,r4,r0
000834  ea000000          B        |L1.2108|
                  |L1.2104|
;;;878    				&(pDeviceParameters->LimitChecksEnable[i]));
;;;879    			} else {
;;;880    				break;
000838  ea000002          B        |L1.2120|
                  |L1.2108|
00083c  e2866001          ADD      r6,r6,#1              ;865
                  |L1.2112|
000840  e3560006          CMP      r6,#6                 ;865
000844  baffffe6          BLT      |L1.2020|
                  |L1.2120|
000848  e1a00000          MOV      r0,r0                 ;874
                  |L1.2124|
;;;881    			}
;;;882    		}
;;;883    	}
;;;884    
;;;885    	if (Status == VL53L0X_ERROR_NONE) {
00084c  e3540000          CMP      r4,#0
000850  1a000003          BNE      |L1.2148|
;;;886    		Status = VL53L0X_GetWrapAroundCheckEnable(Dev,
000854  e285103c          ADD      r1,r5,#0x3c
000858  e1a00007          MOV      r0,r7
00085c  ebfffffe          BL       VL53L0X_GetWrapAroundCheckEnable
000860  e1a04000          MOV      r4,r0
                  |L1.2148|
;;;887    			&(pDeviceParameters->WrapAroundCheckEnable));
;;;888    	}
;;;889    
;;;890    	/* Need to be done at the end as it uses VCSELPulsePeriod */
;;;891    	if (Status == VL53L0X_ERROR_NONE) {
000864  e3540000          CMP      r4,#0
000868  1a000003          BNE      |L1.2172|
;;;892    		Status = VL53L0X_GetMeasurementTimingBudgetMicroSeconds(Dev,
00086c  e2851004          ADD      r1,r5,#4
000870  e1a00007          MOV      r0,r7
000874  ebfffffe          BL       VL53L0X_GetMeasurementTimingBudgetMicroSeconds
000878  e1a04000          MOV      r4,r0
                  |L1.2172|
;;;893    		&(pDeviceParameters->MeasurementTimingBudgetMicroSeconds));
;;;894    	}
;;;895    
;;;896    	LOG_FUNCTION_END(Status);
;;;897    	return Status;
00087c  e1a00004          MOV      r0,r4
;;;898    }
000880  e8bd81f0          POP      {r4-r8,pc}
;;;899    
                          ENDP

                  VL53L0X_ClearInterruptMask PROC
;;;2864   /* Group PAL Interrupt Functions */
;;;2865   VL53L0X_Error VL53L0X_ClearInterruptMask(VL53L0X_DEV Dev, uint32_t InterruptMask)
000884  e92d40f8          PUSH     {r3-r7,lr}
;;;2866   {
000888  e1a06000          MOV      r6,r0
00088c  e1a07001          MOV      r7,r1
;;;2867   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000890  e3a04000          MOV      r4,#0
;;;2868   	uint8_t LoopCount;
;;;2869   	uint8_t Byte;
;;;2870   	LOG_FUNCTION_START("");
;;;2871   
;;;2872   	/* clear bit 0 range interrupt, bit 1 error interrupt */
;;;2873   	LoopCount = 0;
000894  e3a05000          MOV      r5,#0
;;;2874   	do {
000898  e1a00000          MOV      r0,r0
                  |L1.2204|
;;;2875   		Status = VL53L0X_WrByte(Dev,
00089c  e3a02001          MOV      r2,#1
0008a0  e3a0100b          MOV      r1,#0xb
0008a4  e1a00006          MOV      r0,r6
0008a8  ebfffffe          BL       VL53L0X_WrByte
0008ac  e1a04000          MOV      r4,r0
;;;2876   			VL53L0X_REG_SYSTEM_INTERRUPT_CLEAR, 0x01);
;;;2877   		Status |= VL53L0X_WrByte(Dev,
0008b0  e3a02000          MOV      r2,#0
0008b4  e3a0100b          MOV      r1,#0xb
0008b8  e1a00006          MOV      r0,r6
0008bc  ebfffffe          BL       VL53L0X_WrByte
0008c0  e1844000          ORR      r4,r4,r0
;;;2878   			VL53L0X_REG_SYSTEM_INTERRUPT_CLEAR, 0x00);
;;;2879   		Status |= VL53L0X_RdByte(Dev,
0008c4  e1a0200d          MOV      r2,sp
0008c8  e3a01013          MOV      r1,#0x13
0008cc  e1a00006          MOV      r0,r6
0008d0  ebfffffe          BL       VL53L0X_RdByte
0008d4  e1844000          ORR      r4,r4,r0
;;;2880   			VL53L0X_REG_RESULT_INTERRUPT_STATUS, &Byte);
;;;2881   		LoopCount++;
0008d8  e2850001          ADD      r0,r5,#1
0008dc  e20050ff          AND      r5,r0,#0xff
;;;2882   	} while (((Byte & 0x07) != 0x00)
0008e0  e5dd0000          LDRB     r0,[sp,#0]
0008e4  e3100007          TST      r0,#7
0008e8  0a000003          BEQ      |L1.2300|
;;;2883   			&& (LoopCount < 3)
0008ec  e3550003          CMP      r5,#3
0008f0  aa000001          BGE      |L1.2300|
;;;2884   			&& (Status == VL53L0X_ERROR_NONE));
0008f4  e3540000          CMP      r4,#0
0008f8  0affffe7          BEQ      |L1.2204|
                  |L1.2300|
;;;2885   
;;;2886   
;;;2887   	if (LoopCount >= 3)
0008fc  e3550003          CMP      r5,#3
000900  ba000000          BLT      |L1.2312|
;;;2888   		Status = VL53L0X_ERROR_INTERRUPT_NOT_CLEARED;
000904  e3e0400b          MVN      r4,#0xb
                  |L1.2312|
;;;2889   
;;;2890   	LOG_FUNCTION_END(Status);
;;;2891   	return Status;
000908  e1a00004          MOV      r0,r4
;;;2892   }
00090c  e8bd80f8          POP      {r3-r7,pc}
;;;2893   
                          ENDP

                  VL53L0X_SetGpioConfig PROC
;;;2615   
;;;2616   VL53L0X_Error VL53L0X_SetGpioConfig(VL53L0X_DEV Dev, uint8_t Pin,
000910  e92d47f0          PUSH     {r4-r10,lr}
;;;2617   	VL53L0X_DeviceModes DeviceMode, VL53L0X_GpioFunctionality Functionality,
;;;2618   	VL53L0X_InterruptPolarity Polarity)
;;;2619   {
000914  e1a08000          MOV      r8,r0
000918  e1a09001          MOV      r9,r1
00091c  e1a07002          MOV      r7,r2
000920  e1a06003          MOV      r6,r3
000924  e59da020          LDR      r10,[sp,#0x20]
;;;2620   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000928  e3a04000          MOV      r4,#0
;;;2621   	uint8_t data;
;;;2622   
;;;2623   	LOG_FUNCTION_START("");
;;;2624   
;;;2625   	if (Pin != 0) {
00092c  e3590000          CMP      r9,#0
000930  0a000001          BEQ      |L1.2364|
;;;2626   		Status = VL53L0X_ERROR_GPIO_NOT_EXISTING;
000934  e3e04009          MVN      r4,#9
000938  ea000094          B        |L1.2960|
                  |L1.2364|
;;;2627   	} else if (DeviceMode == VL53L0X_DEVICEMODE_GPIO_DRIVE) {
00093c  e3570014          CMP      r7,#0x14
000940  1a00000a          BNE      |L1.2416|
;;;2628   		if (Polarity == VL53L0X_INTERRUPTPOLARITY_LOW)
000944  e35a0000          CMP      r10,#0
000948  1a000001          BNE      |L1.2388|
;;;2629   			data = 0x10;
00094c  e3a05010          MOV      r5,#0x10
000950  ea000000          B        |L1.2392|
                  |L1.2388|
;;;2630   		else
;;;2631   			data = 1;
000954  e3a05001          MOV      r5,#1
                  |L1.2392|
;;;2632   
;;;2633   		Status = VL53L0X_WrByte(Dev,
000958  e1a02005          MOV      r2,r5
00095c  e3a01084          MOV      r1,#0x84
000960  e1a00008          MOV      r0,r8
000964  ebfffffe          BL       VL53L0X_WrByte
000968  e1a04000          MOV      r4,r0
00096c  ea000087          B        |L1.2960|
                  |L1.2416|
;;;2634   		VL53L0X_REG_GPIO_HV_MUX_ACTIVE_HIGH, data);
;;;2635   
;;;2636   	} else if (DeviceMode == VL53L0X_DEVICEMODE_GPIO_OSC) {
000970  e3570015          CMP      r7,#0x15
000974  1a00004b          BNE      |L1.2728|
;;;2637   
;;;2638   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
000978  e3a02001          MOV      r2,#1
00097c  e3a010ff          MOV      r1,#0xff
000980  e1a00008          MOV      r0,r8
000984  ebfffffe          BL       VL53L0X_WrByte
000988  e1844000          ORR      r4,r4,r0
;;;2639   		Status |= VL53L0X_WrByte(Dev, 0x00, 0x00);
00098c  e3a02000          MOV      r2,#0
000990  e1a01002          MOV      r1,r2
000994  e1a00008          MOV      r0,r8
000998  ebfffffe          BL       VL53L0X_WrByte
00099c  e1844000          ORR      r4,r4,r0
;;;2640   
;;;2641   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
0009a0  e3a02000          MOV      r2,#0
0009a4  e3a010ff          MOV      r1,#0xff
0009a8  e1a00008          MOV      r0,r8
0009ac  ebfffffe          BL       VL53L0X_WrByte
0009b0  e1844000          ORR      r4,r4,r0
;;;2642   		Status |= VL53L0X_WrByte(Dev, 0x80, 0x01);
0009b4  e3a02001          MOV      r2,#1
0009b8  e3a01080          MOV      r1,#0x80
0009bc  e1a00008          MOV      r0,r8
0009c0  ebfffffe          BL       VL53L0X_WrByte
0009c4  e1844000          ORR      r4,r4,r0
;;;2643   		Status |= VL53L0X_WrByte(Dev, 0x85, 0x02);
0009c8  e3a02002          MOV      r2,#2
0009cc  e3a01085          MOV      r1,#0x85
0009d0  e1a00008          MOV      r0,r8
0009d4  ebfffffe          BL       VL53L0X_WrByte
0009d8  e1844000          ORR      r4,r4,r0
;;;2644   
;;;2645   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x04);
0009dc  e3a02004          MOV      r2,#4
0009e0  e3a010ff          MOV      r1,#0xff
0009e4  e1a00008          MOV      r0,r8
0009e8  ebfffffe          BL       VL53L0X_WrByte
0009ec  e1844000          ORR      r4,r4,r0
;;;2646   		Status |= VL53L0X_WrByte(Dev, 0xcd, 0x00);
0009f0  e3a02000          MOV      r2,#0
0009f4  e3a010cd          MOV      r1,#0xcd
0009f8  e1a00008          MOV      r0,r8
0009fc  ebfffffe          BL       VL53L0X_WrByte
000a00  e1844000          ORR      r4,r4,r0
;;;2647   		Status |= VL53L0X_WrByte(Dev, 0xcc, 0x11);
000a04  e3a02011          MOV      r2,#0x11
000a08  e3a010cc          MOV      r1,#0xcc
000a0c  e1a00008          MOV      r0,r8
000a10  ebfffffe          BL       VL53L0X_WrByte
000a14  e1844000          ORR      r4,r4,r0
;;;2648   
;;;2649   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x07);
000a18  e3a02007          MOV      r2,#7
000a1c  e3a010ff          MOV      r1,#0xff
000a20  e1a00008          MOV      r0,r8
000a24  ebfffffe          BL       VL53L0X_WrByte
000a28  e1844000          ORR      r4,r4,r0
;;;2650   		Status |= VL53L0X_WrByte(Dev, 0xbe, 0x00);
000a2c  e3a02000          MOV      r2,#0
000a30  e3a010be          MOV      r1,#0xbe
000a34  e1a00008          MOV      r0,r8
000a38  ebfffffe          BL       VL53L0X_WrByte
000a3c  e1844000          ORR      r4,r4,r0
;;;2651   
;;;2652   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x06);
000a40  e3a02006          MOV      r2,#6
000a44  e3a010ff          MOV      r1,#0xff
000a48  e1a00008          MOV      r0,r8
000a4c  ebfffffe          BL       VL53L0X_WrByte
000a50  e1844000          ORR      r4,r4,r0
;;;2653   		Status |= VL53L0X_WrByte(Dev, 0xcc, 0x09);
000a54  e3a02009          MOV      r2,#9
000a58  e3a010cc          MOV      r1,#0xcc
000a5c  e1a00008          MOV      r0,r8
000a60  ebfffffe          BL       VL53L0X_WrByte
000a64  e1844000          ORR      r4,r4,r0
;;;2654   
;;;2655   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
000a68  e3a02000          MOV      r2,#0
000a6c  e3a010ff          MOV      r1,#0xff
000a70  e1a00008          MOV      r0,r8
000a74  ebfffffe          BL       VL53L0X_WrByte
000a78  e1844000          ORR      r4,r4,r0
;;;2656   		Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
000a7c  e3a02001          MOV      r2,#1
000a80  e3a010ff          MOV      r1,#0xff
000a84  e1a00008          MOV      r0,r8
000a88  ebfffffe          BL       VL53L0X_WrByte
000a8c  e1844000          ORR      r4,r4,r0
;;;2657   		Status |= VL53L0X_WrByte(Dev, 0x00, 0x00);
000a90  e3a02000          MOV      r2,#0
000a94  e1a01002          MOV      r1,r2
000a98  e1a00008          MOV      r0,r8
000a9c  ebfffffe          BL       VL53L0X_WrByte
000aa0  e1844000          ORR      r4,r4,r0
000aa4  ea000039          B        |L1.2960|
                  |L1.2728|
;;;2658   
;;;2659   	} else {
;;;2660   
;;;2661   		if (Status == VL53L0X_ERROR_NONE) {
000aa8  e3540000          CMP      r4,#0
000aac  1a00001a          BNE      |L1.2844|
;;;2662   			switch (Functionality) {
000ab0  e3560005          CMP      r6,#5
000ab4  308ff106          ADDCC    pc,pc,r6,LSL #2
000ab8  ea000013          B        |L1.2828|
000abc  ea000003          B        |L1.2768|
000ac0  ea000005          B        |L1.2780|
000ac4  ea000007          B        |L1.2792|
000ac8  ea000009          B        |L1.2804|
000acc  ea00000b          B        |L1.2816|
                  |L1.2768|
;;;2663   			case VL53L0X_GPIOFUNCTIONALITY_OFF:
000ad0  e1a00000          MOV      r0,r0
;;;2664   				data = 0x00;
000ad4  e3a05000          MOV      r5,#0
;;;2665   				break;
000ad8  ea00000e          B        |L1.2840|
                  |L1.2780|
;;;2666   			case VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW:
000adc  e1a00000          MOV      r0,r0
;;;2667   				data = 0x01;
000ae0  e3a05001          MOV      r5,#1
;;;2668   				break;
000ae4  ea00000b          B        |L1.2840|
                  |L1.2792|
;;;2669   			case VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH:
000ae8  e1a00000          MOV      r0,r0
;;;2670   				data = 0x02;
000aec  e3a05002          MOV      r5,#2
;;;2671   				break;
000af0  ea000008          B        |L1.2840|
                  |L1.2804|
;;;2672   			case VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT:
000af4  e1a00000          MOV      r0,r0
;;;2673   				data = 0x03;
000af8  e3a05003          MOV      r5,#3
;;;2674   				break;
000afc  ea000005          B        |L1.2840|
                  |L1.2816|
;;;2675   			case VL53L0X_GPIOFUNCTIONALITY_NEW_MEASURE_READY:
000b00  e1a00000          MOV      r0,r0
;;;2676   				data = 0x04;
000b04  e3a05004          MOV      r5,#4
;;;2677   				break;
000b08  ea000002          B        |L1.2840|
                  |L1.2828|
;;;2678   			default:
000b0c  e1a00000          MOV      r0,r0
;;;2679   				Status =
000b10  e3e0400a          MVN      r4,#0xa
000b14  e1a00000          MOV      r0,r0                 ;2662
                  |L1.2840|
000b18  e1a00000          MOV      r0,r0                 ;2665
                  |L1.2844|
;;;2680   				VL53L0X_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
;;;2681   			}
;;;2682   		}
;;;2683   
;;;2684   		if (Status == VL53L0X_ERROR_NONE)
000b1c  e3540000          CMP      r4,#0
000b20  1a000004          BNE      |L1.2872|
;;;2685   			Status = VL53L0X_WrByte(Dev,
000b24  e1a02005          MOV      r2,r5
000b28  e3a0100a          MOV      r1,#0xa
000b2c  e1a00008          MOV      r0,r8
000b30  ebfffffe          BL       VL53L0X_WrByte
000b34  e1a04000          MOV      r4,r0
                  |L1.2872|
;;;2686   			VL53L0X_REG_SYSTEM_INTERRUPT_CONFIG_GPIO, data);
;;;2687   
;;;2688   		if (Status == VL53L0X_ERROR_NONE) {
000b38  e3540000          CMP      r4,#0
000b3c  1a00000a          BNE      |L1.2924|
;;;2689   			if (Polarity == VL53L0X_INTERRUPTPOLARITY_LOW)
000b40  e35a0000          CMP      r10,#0
000b44  1a000001          BNE      |L1.2896|
;;;2690   				data = 0;
000b48  e3a05000          MOV      r5,#0
000b4c  ea000000          B        |L1.2900|
                  |L1.2896|
;;;2691   			else
;;;2692   				data = (uint8_t)(1 << 4);
000b50  e3a05010          MOV      r5,#0x10
                  |L1.2900|
;;;2693   
;;;2694   			Status = VL53L0X_UpdateByte(Dev,
000b54  e1a03005          MOV      r3,r5
000b58  e3a020ef          MOV      r2,#0xef
000b5c  e3a01084          MOV      r1,#0x84
000b60  e1a00008          MOV      r0,r8
000b64  ebfffffe          BL       VL53L0X_UpdateByte
000b68  e1a04000          MOV      r4,r0
                  |L1.2924|
;;;2695   			VL53L0X_REG_GPIO_HV_MUX_ACTIVE_HIGH, 0xEF, data);
;;;2696   		}
;;;2697   
;;;2698   		if (Status == VL53L0X_ERROR_NONE)
000b6c  e3540000          CMP      r4,#0
000b70  1a000000          BNE      |L1.2936|
;;;2699   			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000b74  e5c860da          STRB     r6,[r8,#0xda]
                  |L1.2936|
;;;2700   				Pin0GpioFunctionality, Functionality);
;;;2701   
;;;2702   		if (Status == VL53L0X_ERROR_NONE)
000b78  e3540000          CMP      r4,#0
000b7c  1a000003          BNE      |L1.2960|
;;;2703   			Status = VL53L0X_ClearInterruptMask(Dev, 0);
000b80  e3a01000          MOV      r1,#0
000b84  e1a00008          MOV      r0,r8
000b88  ebfffffe          BL       VL53L0X_ClearInterruptMask
000b8c  e1a04000          MOV      r4,r0
                  |L1.2960|
;;;2704   
;;;2705   	}
;;;2706   
;;;2707   	LOG_FUNCTION_END(Status);
;;;2708   	return Status;
000b90  e1a00004          MOV      r0,r4
;;;2709   }
000b94  e8bd87f0          POP      {r4-r10,pc}
;;;2710   
                          ENDP

                  VL53L0X_StaticInit PROC
;;;553    
;;;554    VL53L0X_Error VL53L0X_StaticInit(VL53L0X_DEV Dev)
000b98  e92d43f0          PUSH     {r4-r9,lr}
;;;555    {
000b9c  e24dd05c          SUB      sp,sp,#0x5c
000ba0  e1a05000          MOV      r5,r0
;;;556    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000ba4  e3a04000          MOV      r4,#0
;;;557    	VL53L0X_DeviceParameters_t CurrentParameters = {0};
000ba8  e3a01040          MOV      r1,#0x40
000bac  e28d001c          ADD      r0,sp,#0x1c
000bb0  ebfffffe          BL       __aeabi_memclr4
;;;558    	uint8_t *pTuningSettingBuffer;
;;;559    	uint16_t tempword = 0;
000bb4  e3a00000          MOV      r0,#0
000bb8  e58d0018          STR      r0,[sp,#0x18]
;;;560    	uint8_t tempbyte = 0;
000bbc  e58d0014          STR      r0,[sp,#0x14]
;;;561    	uint8_t UseInternalTuningSettings = 0;
000bc0  e3a09000          MOV      r9,#0
;;;562    	uint32_t count = 0;
000bc4  e3a07000          MOV      r7,#0
;;;563    	uint8_t isApertureSpads = 0;
000bc8  e58d0010          STR      r0,[sp,#0x10]
;;;564    	uint32_t refSpadCount = 0;
000bcc  e58d000c          STR      r0,[sp,#0xc]
;;;565    	uint8_t ApertureSpads = 0;
000bd0  e3a06000          MOV      r6,#0
;;;566    	uint8_t vcselPulsePeriodPCLK;
;;;567    	FixPoint1616_t seqTimeoutMilliSecs;
;;;568    
;;;569    	LOG_FUNCTION_START("");
;;;570    
;;;571    	Status = VL53L0X_get_info_from_device(Dev, 1);
000bd4  e3a01001          MOV      r1,#1
000bd8  e1a00005          MOV      r0,r5
000bdc  ebfffffe          BL       VL53L0X_get_info_from_device
000be0  e1a04000          MOV      r4,r0
;;;572    
;;;573    	/* set the ref spad from NVM */
;;;574    	count	= (uint32_t)VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
000be4  e5d57113          LDRB     r7,[r5,#0x113]
;;;575    		ReferenceSpadCount);
;;;576    	ApertureSpads = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
000be8  e5d56114          LDRB     r6,[r5,#0x114]
;;;577    		ReferenceSpadType);
;;;578    
;;;579    	/* NVM value invalid */
;;;580    	if ((ApertureSpads > 1) ||
000bec  e3560001          CMP      r6,#1
000bf0  ca000007          BGT      |L1.3092|
;;;581    		((ApertureSpads == 1) && (count > 32)) ||
000bf4  e3560001          CMP      r6,#1
000bf8  1a000001          BNE      |L1.3076|
000bfc  e3570020          CMP      r7,#0x20
000c00  8a000003          BHI      |L1.3092|
                  |L1.3076|
;;;582    		((ApertureSpads == 0) && (count > 12)))
000c04  e3560000          CMP      r6,#0
000c08  1a000007          BNE      |L1.3116|
000c0c  e357000c          CMP      r7,#0xc
000c10  9a000005          BLS      |L1.3116|
                  |L1.3092|
;;;583    		Status = VL53L0X_perform_ref_spad_management(Dev, &refSpadCount,
000c14  e28d2010          ADD      r2,sp,#0x10
000c18  e28d100c          ADD      r1,sp,#0xc
000c1c  e1a00005          MOV      r0,r5
000c20  ebfffffe          BL       VL53L0X_perform_ref_spad_management
000c24  e1a04000          MOV      r4,r0
000c28  ea000004          B        |L1.3136|
                  |L1.3116|
;;;584    			&isApertureSpads);
;;;585    	else
;;;586    		Status = VL53L0X_set_reference_spads(Dev, count, ApertureSpads);
000c2c  e1a02006          MOV      r2,r6
000c30  e1a01007          MOV      r1,r7
000c34  e1a00005          MOV      r0,r5
000c38  ebfffffe          BL       VL53L0X_set_reference_spads
000c3c  e1a04000          MOV      r4,r0
                  |L1.3136|
;;;587    
;;;588    
;;;589    	/* Initialize tuning settings buffer to prevent compiler warning. */
;;;590    	pTuningSettingBuffer = DefaultTuningSettings;
000c40  e59f8240          LDR      r8,|L1.3720|
;;;591    
;;;592    	if (Status == VL53L0X_ERROR_NONE) {
000c44  e3540000          CMP      r4,#0
000c48  1a000005          BNE      |L1.3172|
;;;593    		UseInternalTuningSettings = PALDevDataGet(Dev,
000c4c  e5d59150          LDRB     r9,[r5,#0x150]
;;;594    			UseInternalTuningSettings);
;;;595    
;;;596    		if (UseInternalTuningSettings == 0)
000c50  e3590000          CMP      r9,#0
000c54  1a000001          BNE      |L1.3168|
;;;597    			pTuningSettingBuffer = PALDevDataGet(Dev,
000c58  e595814c          LDR      r8,[r5,#0x14c]
000c5c  ea000000          B        |L1.3172|
                  |L1.3168|
;;;598    				pTuningSettingsPointer);
;;;599    		else
;;;600    			pTuningSettingBuffer = DefaultTuningSettings;
000c60  e59f8220          LDR      r8,|L1.3720|
                  |L1.3172|
;;;601    
;;;602    	}
;;;603    
;;;604    	if (Status == VL53L0X_ERROR_NONE)
000c64  e3540000          CMP      r4,#0
000c68  1a000003          BNE      |L1.3196|
;;;605    		Status = VL53L0X_load_tuning_settings(Dev, pTuningSettingBuffer);
000c6c  e1a01008          MOV      r1,r8
000c70  e1a00005          MOV      r0,r5
000c74  ebfffffe          BL       VL53L0X_load_tuning_settings
000c78  e1a04000          MOV      r4,r0
                  |L1.3196|
;;;606    
;;;607    
;;;608    	/* Set interrupt config to new sample ready */
;;;609    	if (Status == VL53L0X_ERROR_NONE) {
000c7c  e3540000          CMP      r4,#0
000c80  1a000007          BNE      |L1.3236|
;;;610    		Status = VL53L0X_SetGpioConfig(Dev, 0, 0,
000c84  e3a00000          MOV      r0,#0
000c88  e3a03004          MOV      r3,#4
000c8c  e58d0000          STR      r0,[sp,#0]
000c90  e1a02000          MOV      r2,r0
000c94  e1a01000          MOV      r1,r0
000c98  e1a00005          MOV      r0,r5
000c9c  ebfffffe          BL       VL53L0X_SetGpioConfig
000ca0  e1a04000          MOV      r4,r0
                  |L1.3236|
;;;611    		VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY,
;;;612    		VL53L0X_INTERRUPTPOLARITY_LOW);
;;;613    	}
;;;614    
;;;615    	if (Status == VL53L0X_ERROR_NONE) {
000ca4  e3540000          CMP      r4,#0
000ca8  1a00000e          BNE      |L1.3304|
;;;616    		Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
000cac  e3a02001          MOV      r2,#1
000cb0  e3a010ff          MOV      r1,#0xff
000cb4  e1a00005          MOV      r0,r5
000cb8  ebfffffe          BL       VL53L0X_WrByte
000cbc  e1a04000          MOV      r4,r0
;;;617    		Status |= VL53L0X_RdWord(Dev, 0x84, &tempword);
000cc0  e28d2018          ADD      r2,sp,#0x18
000cc4  e3a01084          MOV      r1,#0x84
000cc8  e1a00005          MOV      r0,r5
000ccc  ebfffffe          BL       VL53L0X_RdWord
000cd0  e1844000          ORR      r4,r4,r0
;;;618    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
000cd4  e3a02000          MOV      r2,#0
000cd8  e3a010ff          MOV      r1,#0xff
000cdc  e1a00005          MOV      r0,r5
000ce0  ebfffffe          BL       VL53L0X_WrByte
000ce4  e1844000          ORR      r4,r4,r0
                  |L1.3304|
;;;619    	}
;;;620    
;;;621    	if (Status == VL53L0X_ERROR_NONE) {
000ce8  e3540000          CMP      r4,#0
000cec  1a000002          BNE      |L1.3324|
;;;622    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz,
000cf0  e1dd01b8          LDRH     r0,[sp,#0x18]
000cf4  e1a00200          LSL      r0,r0,#4
000cf8  e58500d4          STR      r0,[r5,#0xd4]
                  |L1.3324|
;;;623    			VL53L0X_FIXPOINT412TOFIXPOINT1616(tempword));
;;;624    	}
;;;625    
;;;626    	/* After static init, some device parameters may be changed,
;;;627    	 * so update them */
;;;628    	if (Status == VL53L0X_ERROR_NONE)
000cfc  e3540000          CMP      r4,#0
000d00  1a000003          BNE      |L1.3348|
;;;629    		Status = VL53L0X_GetDeviceParameters(Dev, &CurrentParameters);
000d04  e28d101c          ADD      r1,sp,#0x1c
000d08  e1a00005          MOV      r0,r5
000d0c  ebfffffe          BL       VL53L0X_GetDeviceParameters
000d10  e1a04000          MOV      r4,r0
                  |L1.3348|
;;;630    
;;;631    
;;;632    	if (Status == VL53L0X_ERROR_NONE) {
000d14  e3540000          CMP      r4,#0
000d18  1a000007          BNE      |L1.3388|
;;;633    		Status = VL53L0X_GetFractionEnable(Dev, &tempbyte);
000d1c  e28d1014          ADD      r1,sp,#0x14
000d20  e1a00005          MOV      r0,r5
000d24  ebfffffe          BL       VL53L0X_GetFractionEnable
000d28  e1a04000          MOV      r4,r0
;;;634    		if (Status == VL53L0X_ERROR_NONE)
000d2c  e3540000          CMP      r4,#0
000d30  1a000001          BNE      |L1.3388|
;;;635    			PALDevDataSet(Dev, RangeFractionalEnable, tempbyte);
000d34  e5dd0014          LDRB     r0,[sp,#0x14]
000d38  e5c50131          STRB     r0,[r5,#0x131]
                  |L1.3388|
;;;636    
;;;637    	}
;;;638    
;;;639    	if (Status == VL53L0X_ERROR_NONE)
000d3c  e3540000          CMP      r4,#0
000d40  1a000003          BNE      |L1.3412|
;;;640    		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
000d44  e3a02040          MOV      r2,#0x40
000d48  e28d101c          ADD      r1,sp,#0x1c
000d4c  e2850010          ADD      r0,r5,#0x10
000d50  ebfffffe          BL       __aeabi_memcpy4
                  |L1.3412|
;;;641    
;;;642    
;;;643    	/* read the sequence config and save it */
;;;644    	if (Status == VL53L0X_ERROR_NONE) {
000d54  e3540000          CMP      r4,#0
000d58  1a000008          BNE      |L1.3456|
;;;645    		Status = VL53L0X_RdByte(Dev,
000d5c  e28d2014          ADD      r2,sp,#0x14
000d60  e3a01001          MOV      r1,#1
000d64  e1a00005          MOV      r0,r5
000d68  ebfffffe          BL       VL53L0X_RdByte
000d6c  e1a04000          MOV      r4,r0
;;;646    		VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, &tempbyte);
;;;647    		if (Status == VL53L0X_ERROR_NONE)
000d70  e3540000          CMP      r4,#0
000d74  1a000001          BNE      |L1.3456|
;;;648    			PALDevDataSet(Dev, SequenceConfig, tempbyte);
000d78  e5dd0014          LDRB     r0,[sp,#0x14]
000d7c  e5c50130          STRB     r0,[r5,#0x130]
                  |L1.3456|
;;;649    
;;;650    	}
;;;651    
;;;652    	/* Disable MSRC and TCC by default */
;;;653    	if (Status == VL53L0X_ERROR_NONE)
000d80  e3540000          CMP      r4,#0
000d84  1a000004          BNE      |L1.3484|
;;;654    		Status = VL53L0X_SetSequenceStepEnable(Dev,
000d88  e3a02000          MOV      r2,#0
000d8c  e1a01002          MOV      r1,r2
000d90  e1a00005          MOV      r0,r5
000d94  ebfffffe          BL       VL53L0X_SetSequenceStepEnable
000d98  e1a04000          MOV      r4,r0
                  |L1.3484|
;;;655    					VL53L0X_SEQUENCESTEP_TCC, 0);
;;;656    
;;;657    
;;;658    	if (Status == VL53L0X_ERROR_NONE)
000d9c  e3540000          CMP      r4,#0
000da0  1a000004          BNE      |L1.3512|
;;;659    		Status = VL53L0X_SetSequenceStepEnable(Dev,
000da4  e3a02000          MOV      r2,#0
000da8  e3a01002          MOV      r1,#2
000dac  e1a00005          MOV      r0,r5
000db0  ebfffffe          BL       VL53L0X_SetSequenceStepEnable
000db4  e1a04000          MOV      r4,r0
                  |L1.3512|
;;;660    		VL53L0X_SEQUENCESTEP_MSRC, 0);
;;;661    
;;;662    
;;;663    	/* Set PAL State to standby */
;;;664    	if (Status == VL53L0X_ERROR_NONE)
000db8  e3540000          CMP      r4,#0
000dbc  1a000001          BNE      |L1.3528|
;;;665    		PALDevDataSet(Dev, PalState, VL53L0X_STATE_IDLE);
000dc0  e3a00003          MOV      r0,#3
000dc4  e5c50132          STRB     r0,[r5,#0x132]
                  |L1.3528|
;;;666    
;;;667    
;;;668    
;;;669    	/* Store pre-range vcsel period */
;;;670    	if (Status == VL53L0X_ERROR_NONE) {
000dc8  e3540000          CMP      r4,#0
000dcc  1a000004          BNE      |L1.3556|
;;;671    		Status = VL53L0X_GetVcselPulsePeriod(
000dd0  e28d2008          ADD      r2,sp,#8
000dd4  e3a01000          MOV      r1,#0
000dd8  e1a00005          MOV      r0,r5
000ddc  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000de0  e1a04000          MOV      r4,r0
                  |L1.3556|
;;;672    			Dev,
;;;673    			VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;674    			&vcselPulsePeriodPCLK);
;;;675    	}
;;;676    
;;;677    	if (Status == VL53L0X_ERROR_NONE) {
000de4  e3540000          CMP      r4,#0
000de8  1a000001          BNE      |L1.3572|
;;;678    			VL53L0X_SETDEVICESPECIFICPARAMETER(
000dec  e5dd0008          LDRB     r0,[sp,#8]
000df0  e5c500e8          STRB     r0,[r5,#0xe8]
                  |L1.3572|
;;;679    				Dev,
;;;680    				PreRangeVcselPulsePeriod,
;;;681    				vcselPulsePeriodPCLK);
;;;682    	}
;;;683    
;;;684    	/* Store final-range vcsel period */
;;;685    	if (Status == VL53L0X_ERROR_NONE) {
000df4  e3540000          CMP      r4,#0
000df8  1a000004          BNE      |L1.3600|
;;;686    		Status = VL53L0X_GetVcselPulsePeriod(
000dfc  e28d2008          ADD      r2,sp,#8
000e00  e3a01001          MOV      r1,#1
000e04  e1a00005          MOV      r0,r5
000e08  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000e0c  e1a04000          MOV      r4,r0
                  |L1.3600|
;;;687    			Dev,
;;;688    			VL53L0X_VCSEL_PERIOD_FINAL_RANGE,
;;;689    			&vcselPulsePeriodPCLK);
;;;690    	}
;;;691    
;;;692    	if (Status == VL53L0X_ERROR_NONE) {
000e10  e3540000          CMP      r4,#0
000e14  1a000001          BNE      |L1.3616|
;;;693    			VL53L0X_SETDEVICESPECIFICPARAMETER(
000e18  e5dd0008          LDRB     r0,[sp,#8]
000e1c  e5c500e0          STRB     r0,[r5,#0xe0]
                  |L1.3616|
;;;694    				Dev,
;;;695    				FinalRangeVcselPulsePeriod,
;;;696    				vcselPulsePeriodPCLK);
;;;697    	}
;;;698    
;;;699    	/* Store pre-range timeout */
;;;700    	if (Status == VL53L0X_ERROR_NONE) {
000e20  e3540000          CMP      r4,#0
000e24  1a000004          BNE      |L1.3644|
;;;701    		Status = VL53L0X_GetSequenceStepTimeout(
000e28  e28d2004          ADD      r2,sp,#4
000e2c  e3a01003          MOV      r1,#3
000e30  e1a00005          MOV      r0,r5
000e34  ebfffffe          BL       VL53L0X_GetSequenceStepTimeout
000e38  e1a04000          MOV      r4,r0
                  |L1.3644|
;;;702    			Dev,
;;;703    			VL53L0X_SEQUENCESTEP_PRE_RANGE,
;;;704    			&seqTimeoutMilliSecs);
;;;705    	}
;;;706    
;;;707    	if (Status == VL53L0X_ERROR_NONE) {
000e3c  e3540000          CMP      r4,#0
000e40  1a000001          BNE      |L1.3660|
;;;708    		VL53L0X_SETDEVICESPECIFICPARAMETER(
000e44  e59d0004          LDR      r0,[sp,#4]
000e48  e58500e4          STR      r0,[r5,#0xe4]
                  |L1.3660|
;;;709    			Dev,
;;;710    			PreRangeTimeoutMicroSecs,
;;;711    			seqTimeoutMilliSecs);
;;;712    	}
;;;713    
;;;714    	/* Store final-range timeout */
;;;715    	if (Status == VL53L0X_ERROR_NONE) {
000e4c  e3540000          CMP      r4,#0
000e50  1a000004          BNE      |L1.3688|
;;;716    		Status = VL53L0X_GetSequenceStepTimeout(
000e54  e28d2004          ADD      r2,sp,#4
000e58  e3a01004          MOV      r1,#4
000e5c  e1a00005          MOV      r0,r5
000e60  ebfffffe          BL       VL53L0X_GetSequenceStepTimeout
000e64  e1a04000          MOV      r4,r0
                  |L1.3688|
;;;717    			Dev,
;;;718    			VL53L0X_SEQUENCESTEP_FINAL_RANGE,
;;;719    			&seqTimeoutMilliSecs);
;;;720    	}
;;;721    
;;;722    	if (Status == VL53L0X_ERROR_NONE) {
000e68  e3540000          CMP      r4,#0
000e6c  1a000001          BNE      |L1.3704|
;;;723    		VL53L0X_SETDEVICESPECIFICPARAMETER(
000e70  e59d0004          LDR      r0,[sp,#4]
000e74  e58500dc          STR      r0,[r5,#0xdc]
                  |L1.3704|
;;;724    			Dev,
;;;725    			FinalRangeTimeoutMicroSecs,
;;;726    			seqTimeoutMilliSecs);
;;;727    	}
;;;728    
;;;729    	LOG_FUNCTION_END(Status);
;;;730    	return Status;
000e78  e1a00004          MOV      r0,r4
000e7c  e28dd05c          ADD      sp,sp,#0x5c
;;;731    }
000e80  e8bd83f0          POP      {r4-r9,pc}
                  |L1.3716|
                          DCD      0x000011fe
                  |L1.3720|
                          DCD      DefaultTuningSettings
                          ENDP

                  VL53L0X_SetPowerMode PROC
;;;194    
;;;195    VL53L0X_Error VL53L0X_SetPowerMode(VL53L0X_DEV Dev, VL53L0X_PowerModes PowerMode)
000e8c  e92d4070          PUSH     {r4-r6,lr}
;;;196    {
000e90  e1a04000          MOV      r4,r0
000e94  e1a05001          MOV      r5,r1
;;;197    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000e98  e3a06000          MOV      r6,#0
;;;198    	LOG_FUNCTION_START("");
;;;199    
;;;200    	/* Only level1 of Power mode exists */
;;;201    	if ((PowerMode != VL53L0X_POWERMODE_STANDBY_LEVEL1)
000e9c  e3550000          CMP      r5,#0
000ea0  0a000003          BEQ      |L1.3764|
;;;202    		&& (PowerMode != VL53L0X_POWERMODE_IDLE_LEVEL1)) {
000ea4  e3550002          CMP      r5,#2
000ea8  0a000001          BEQ      |L1.3764|
;;;203    		Status = VL53L0X_ERROR_MODE_NOT_SUPPORTED;
000eac  e3e06007          MVN      r6,#7
000eb0  ea00001b          B        |L1.3876|
                  |L1.3764|
;;;204    	} else if (PowerMode == VL53L0X_POWERMODE_STANDBY_LEVEL1) {
000eb4  e3550000          CMP      r5,#0
000eb8  1a00000b          BNE      |L1.3820|
;;;205    		/* set the standby level1 of power mode */
;;;206    		Status = VL53L0X_WrByte(Dev, 0x80, 0x00);
000ebc  e3a02000          MOV      r2,#0
000ec0  e3a01080          MOV      r1,#0x80
000ec4  e1a00004          MOV      r0,r4
000ec8  ebfffffe          BL       VL53L0X_WrByte
000ecc  e1a06000          MOV      r6,r0
;;;207    		if (Status == VL53L0X_ERROR_NONE) {
000ed0  e3560000          CMP      r6,#0
000ed4  1a000012          BNE      |L1.3876|
;;;208    			/* Set PAL State to standby */
;;;209    			PALDevDataSet(Dev, PalState, VL53L0X_STATE_STANDBY);
000ed8  e3a00002          MOV      r0,#2
000edc  e5c40132          STRB     r0,[r4,#0x132]
;;;210    			PALDevDataSet(Dev, PowerMode,
000ee0  e3a00000          MOV      r0,#0
000ee4  e5c40133          STRB     r0,[r4,#0x133]
000ee8  ea00000d          B        |L1.3876|
                  |L1.3820|
;;;211    				VL53L0X_POWERMODE_STANDBY_LEVEL1);
;;;212    		}
;;;213    
;;;214    	} else {
;;;215    		/* VL53L0X_POWERMODE_IDLE_LEVEL1 */
;;;216    		Status = VL53L0X_WrByte(Dev, 0x80, 0x00);
000eec  e3a02000          MOV      r2,#0
000ef0  e3a01080          MOV      r1,#0x80
000ef4  e1a00004          MOV      r0,r4
000ef8  ebfffffe          BL       VL53L0X_WrByte
000efc  e1a06000          MOV      r6,r0
;;;217    		if (Status == VL53L0X_ERROR_NONE)
000f00  e3560000          CMP      r6,#0
000f04  1a000002          BNE      |L1.3860|
;;;218    			Status = VL53L0X_StaticInit(Dev);
000f08  e1a00004          MOV      r0,r4
000f0c  ebfffffe          BL       VL53L0X_StaticInit
000f10  e1a06000          MOV      r6,r0
                  |L1.3860|
;;;219    
;;;220    		if (Status == VL53L0X_ERROR_NONE)
000f14  e3560000          CMP      r6,#0
000f18  1a000001          BNE      |L1.3876|
;;;221    			PALDevDataSet(Dev, PowerMode,
000f1c  e3a00002          MOV      r0,#2
000f20  e5c40133          STRB     r0,[r4,#0x133]
                  |L1.3876|
;;;222    				VL53L0X_POWERMODE_IDLE_LEVEL1);
;;;223    
;;;224    	}
;;;225    
;;;226    	LOG_FUNCTION_END(Status);
;;;227    	return Status;
000f24  e1a00006          MOV      r0,r6
;;;228    }
000f28  e8bd8070          POP      {r4-r6,pc}
;;;229    
                          ENDP

                  VL53L0X_GetPowerMode PROC
;;;230    VL53L0X_Error VL53L0X_GetPowerMode(VL53L0X_DEV Dev, VL53L0X_PowerModes *pPowerMode)
000f2c  e92d40f8          PUSH     {r3-r7,lr}
;;;231    {
000f30  e1a04000          MOV      r4,r0
000f34  e1a06001          MOV      r6,r1
;;;232    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000f38  e3a05000          MOV      r5,#0
;;;233    	uint8_t Byte;
;;;234    	LOG_FUNCTION_START("");
;;;235    
;;;236    	/* Only level1 of Power mode exists */
;;;237    	Status = VL53L0X_RdByte(Dev, 0x80, &Byte);
000f3c  e1a0200d          MOV      r2,sp
000f40  e3a01080          MOV      r1,#0x80
000f44  e1a00004          MOV      r0,r4
000f48  ebfffffe          BL       VL53L0X_RdByte
000f4c  e1a05000          MOV      r5,r0
;;;238    
;;;239    	if (Status == VL53L0X_ERROR_NONE) {
000f50  e3550000          CMP      r5,#0
000f54  1a000007          BNE      |L1.3960|
;;;240    		if (Byte == 1) {
000f58  e5dd0000          LDRB     r0,[sp,#0]
000f5c  e3500001          CMP      r0,#1
000f60  1a000002          BNE      |L1.3952|
;;;241    			PALDevDataSet(Dev, PowerMode,
000f64  e3a00002          MOV      r0,#2
000f68  e5c40133          STRB     r0,[r4,#0x133]
000f6c  ea000001          B        |L1.3960|
                  |L1.3952|
;;;242    				VL53L0X_POWERMODE_IDLE_LEVEL1);
;;;243    		} else {
;;;244    			PALDevDataSet(Dev, PowerMode,
000f70  e3a00000          MOV      r0,#0
000f74  e5c40133          STRB     r0,[r4,#0x133]
                  |L1.3960|
;;;245    				VL53L0X_POWERMODE_STANDBY_LEVEL1);
;;;246    		}
;;;247    	}
;;;248    
;;;249    	LOG_FUNCTION_END(Status);
;;;250    	return Status;
000f78  e1a00005          MOV      r0,r5
;;;251    }
000f7c  e8bd80f8          POP      {r3-r7,pc}
;;;252    
                          ENDP

                  VL53L0X_SetOffsetCalibrationDataMicroMeter PROC
;;;253    VL53L0X_Error VL53L0X_SetOffsetCalibrationDataMicroMeter(VL53L0X_DEV Dev,
000f80  e92d4070          PUSH     {r4-r6,lr}
;;;254    	int32_t OffsetCalibrationDataMicroMeter)
;;;255    {
000f84  e1a04000          MOV      r4,r0
000f88  e1a05001          MOV      r5,r1
;;;256    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000f8c  e3a06000          MOV      r6,#0
;;;257    	LOG_FUNCTION_START("");
;;;258    
;;;259    	Status = VL53L0X_set_offset_calibration_data_micro_meter(Dev,
000f90  e1a01005          MOV      r1,r5
000f94  e1a00004          MOV      r0,r4
000f98  ebfffffe          BL       VL53L0X_set_offset_calibration_data_micro_meter
000f9c  e1a06000          MOV      r6,r0
;;;260    		OffsetCalibrationDataMicroMeter);
;;;261    
;;;262    	LOG_FUNCTION_END(Status);
;;;263    	return Status;
000fa0  e1a00006          MOV      r0,r6
;;;264    }
000fa4  e8bd8070          POP      {r4-r6,pc}
;;;265    
                          ENDP

                  VL53L0X_SetLinearityCorrectiveGain PROC
;;;278    
;;;279    VL53L0X_Error VL53L0X_SetLinearityCorrectiveGain(VL53L0X_DEV Dev,
000fa8  e92d4070          PUSH     {r4-r6,lr}
;;;280    	int16_t LinearityCorrectiveGain)
;;;281    {
000fac  e1a05000          MOV      r5,r0
000fb0  e1a04001          MOV      r4,r1
;;;282    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000fb4  e3a06000          MOV      r6,#0
;;;283    	LOG_FUNCTION_START("");
;;;284    
;;;285    	if ((LinearityCorrectiveGain < 0) || (LinearityCorrectiveGain > 1000))
000fb8  e3540000          CMP      r4,#0
000fbc  ba000001          BLT      |L1.4040|
000fc0  e3540ffa          CMP      r4,#0x3e8
000fc4  da000001          BLE      |L1.4048|
                  |L1.4040|
;;;286    		Status = VL53L0X_ERROR_INVALID_PARAMS;
000fc8  e3e06003          MVN      r6,#3
000fcc  ea000008          B        |L1.4084|
                  |L1.4048|
;;;287    	else {
;;;288    		PALDevDataSet(Dev, LinearityCorrectiveGain,
000fd0  e59f1de4          LDR      r1,|L1.7612|
000fd4  e18140b5          STRH     r4,[r1,r5]
;;;289    			LinearityCorrectiveGain);
;;;290    
;;;291    		if (LinearityCorrectiveGain != 1000) {
000fd8  e3540ffa          CMP      r4,#0x3e8
000fdc  0a000004          BEQ      |L1.4084|
;;;292    			/* Disable FW Xtalk */
;;;293    			Status = VL53L0X_WrWord(Dev,
000fe0  e3a02000          MOV      r2,#0
000fe4  e3a01020          MOV      r1,#0x20
000fe8  e1a00005          MOV      r0,r5
000fec  ebfffffe          BL       VL53L0X_WrWord
000ff0  e1a06000          MOV      r6,r0
                  |L1.4084|
;;;294    			VL53L0X_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS, 0);
;;;295    		}
;;;296    	}
;;;297    
;;;298    	LOG_FUNCTION_END(Status);
;;;299    	return Status;
000ff4  e1a00006          MOV      r0,r6
;;;300    }
000ff8  e8bd8070          POP      {r4-r6,pc}
;;;301    
                          ENDP

                  VL53L0X_GetLinearityCorrectiveGain PROC
;;;302    VL53L0X_Error VL53L0X_GetLinearityCorrectiveGain(VL53L0X_DEV Dev,
000ffc  e1a02000          MOV      r2,r0
;;;303    	uint16_t *pLinearityCorrectiveGain)
;;;304    {
;;;305    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001000  e3a00000          MOV      r0,#0
;;;306    	LOG_FUNCTION_START("");
;;;307    
;;;308    	*pLinearityCorrectiveGain = PALDevDataGet(Dev, LinearityCorrectiveGain);
001004  e59f3db0          LDR      r3,|L1.7612|
001008  e19330b2          LDRH     r3,[r3,r2]
00100c  e1c130b0          STRH     r3,[r1,#0]
;;;309    
;;;310    	LOG_FUNCTION_END(Status);
;;;311    	return Status;
;;;312    }
001010  e12fff1e          BX       lr
;;;313    
                          ENDP

                  VL53L0X_SetGroupParamHold PROC
;;;314    VL53L0X_Error VL53L0X_SetGroupParamHold(VL53L0X_DEV Dev, uint8_t GroupParamHold)
001014  e1a02000          MOV      r2,r0
;;;315    {
;;;316    	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
001018  e3e00062          MVN      r0,#0x62
;;;317    	LOG_FUNCTION_START("");
;;;318    
;;;319    	/* not implemented on VL53L0X */
;;;320    
;;;321    	LOG_FUNCTION_END(Status);
;;;322    	return Status;
;;;323    }
00101c  e12fff1e          BX       lr
;;;324    
                          ENDP

                  VL53L0X_GetUpperLimitMilliMeter PROC
;;;325    VL53L0X_Error VL53L0X_GetUpperLimitMilliMeter(VL53L0X_DEV Dev,
001020  e1a02000          MOV      r2,r0
;;;326    	uint16_t *pUpperLimitMilliMeter)
;;;327    {
;;;328    	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
001024  e3e00062          MVN      r0,#0x62
;;;329    	LOG_FUNCTION_START("");
;;;330    
;;;331    	/* not implemented on VL53L0X */
;;;332    
;;;333    	LOG_FUNCTION_END(Status);
;;;334    	return Status;
;;;335    }
001028  e12fff1e          BX       lr
;;;336    
                          ENDP

                  VL53L0X_GetTotalSignalRate PROC
;;;337    VL53L0X_Error VL53L0X_GetTotalSignalRate(VL53L0X_DEV Dev,
00102c  e92d4070          PUSH     {r4-r6,lr}
;;;338    	FixPoint1616_t *pTotalSignalRate)
;;;339    {
001030  e24dd020          SUB      sp,sp,#0x20
001034  e1a04000          MOV      r4,r0
001038  e1a05001          MOV      r5,r1
;;;340    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00103c  e3a06000          MOV      r6,#0
;;;341    	VL53L0X_RangingMeasurementData_t LastRangeDataBuffer;
;;;342    
;;;343    	LOG_FUNCTION_START("");
;;;344    
;;;345    	LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
001040  e3a0201c          MOV      r2,#0x1c
001044  e2841050          ADD      r1,r4,#0x50
001048  e28d0004          ADD      r0,sp,#4
00104c  ebfffffe          BL       __aeabi_memcpy4
;;;346    
;;;347    	Status = VL53L0X_get_total_signal_rate(
001050  e1a02005          MOV      r2,r5
001054  e28d1004          ADD      r1,sp,#4
001058  e1a00004          MOV      r0,r4
00105c  ebfffffe          BL       VL53L0X_get_total_signal_rate
001060  e1a06000          MOV      r6,r0
;;;348    		Dev, &LastRangeDataBuffer, pTotalSignalRate);
;;;349    
;;;350    	LOG_FUNCTION_END(Status);
;;;351    	return Status;
001064  e1a00006          MOV      r0,r6
001068  e28dd020          ADD      sp,sp,#0x20
;;;352    }
00106c  e8bd8070          POP      {r4-r6,pc}
;;;353    
                          ENDP

                  VL53L0X_SetDeviceAddress PROC
;;;356    /* Group PAL Init Functions */
;;;357    VL53L0X_Error VL53L0X_SetDeviceAddress(VL53L0X_DEV Dev, uint8_t DeviceAddress)
001070  e92d4070          PUSH     {r4-r6,lr}
;;;358    {
001074  e1a05000          MOV      r5,r0
001078  e1a04001          MOV      r4,r1
;;;359    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00107c  e3a06000          MOV      r6,#0
;;;360    	LOG_FUNCTION_START("");
;;;361        //by sam
;;;362    	//Status = VL53L0X_WrByte(Dev, VL53L0X_REG_I2C_SLAVE_DEVICE_ADDRESS,
;;;363    	//	DeviceAddress / 2);
;;;364    	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_I2C_SLAVE_DEVICE_ADDRESS,
001080  e1a02004          MOV      r2,r4
001084  e3a0108a          MOV      r1,#0x8a
001088  e1a00005          MOV      r0,r5
00108c  ebfffffe          BL       VL53L0X_WrByte
001090  e1a06000          MOV      r6,r0
;;;365    		DeviceAddress);
;;;366    	LOG_FUNCTION_END(Status);
;;;367    	return Status;
001094  e1a00006          MOV      r0,r6
;;;368    }
001098  e8bd8070          POP      {r4-r6,pc}
;;;369    
                          ENDP

                  VL53L0X_SetLimitCheckValue PROC
;;;1715   
;;;1716   VL53L0X_Error VL53L0X_SetLimitCheckValue(VL53L0X_DEV Dev, uint16_t LimitCheckId,
00109c  e92d41f0          PUSH     {r4-r8,lr}
;;;1717   	FixPoint1616_t LimitCheckValue)
;;;1718   {
0010a0  e1a05000          MOV      r5,r0
0010a4  e1a06001          MOV      r6,r1
0010a8  e1a04002          MOV      r4,r2
;;;1719   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0010ac  e3a07000          MOV      r7,#0
;;;1720   	uint8_t Temp8;
;;;1721   
;;;1722   	LOG_FUNCTION_START("");
;;;1723   
;;;1724   	VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksEnable, LimitCheckId,
0010b0  e2850028          ADD      r0,r5,#0x28
0010b4  e7d08006          LDRB     r8,[r0,r6]
;;;1725   		Temp8);
;;;1726   
;;;1727   	if (Temp8 == 0) { /* disabled write only internal value */
0010b8  e3580000          CMP      r8,#0
0010bc  1a000002          BNE      |L1.4300|
;;;1728   		VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
0010c0  e2850034          ADD      r0,r5,#0x34
0010c4  e7804106          STR      r4,[r0,r6,LSL #2]
0010c8  ea00002a          B        |L1.4472|
                  |L1.4300|
;;;1729   			LimitCheckId, LimitCheckValue);
;;;1730   	} else {
;;;1731   
;;;1732   		switch (LimitCheckId) {
0010cc  e3560006          CMP      r6,#6
0010d0  308ff106          ADDCC    pc,pc,r6,LSL #2
0010d4  ea00001f          B        |L1.4440|
0010d8  ea000004          B        |L1.4336|
0010dc  ea000006          B        |L1.4348|
0010e0  ea00000d          B        |L1.4380|
0010e4  ea00000f          B        |L1.4392|
0010e8  ea000011          B        |L1.4404|
0010ec  ea000012          B        |L1.4412|
                  |L1.4336|
;;;1733   
;;;1734   		case VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE:
0010f0  e1a00000          MOV      r0,r0
;;;1735   			/* internal computation: */
;;;1736   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
0010f4  e5854034          STR      r4,[r5,#0x34]
;;;1737   				VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE,
;;;1738   				LimitCheckValue);
;;;1739   			break;
0010f8  ea000019          B        |L1.4452|
                  |L1.4348|
;;;1740   
;;;1741   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
0010fc  e1a00000          MOV      r0,r0
;;;1742   
;;;1743   			Status = VL53L0X_WrWord(Dev,
001100  e59f0cb8          LDR      r0,|L1.7616|
001104  e00024a4          AND      r2,r0,r4,LSR #9
001108  e3a01044          MOV      r1,#0x44
00110c  e1a00005          MOV      r0,r5
001110  ebfffffe          BL       VL53L0X_WrWord
001114  e1a07000          MOV      r7,r0
;;;1744   			VL53L0X_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
;;;1745   				VL53L0X_FIXPOINT1616TOFIXPOINT97(
;;;1746   					LimitCheckValue));
;;;1747   
;;;1748   			break;
001118  ea000011          B        |L1.4452|
                  |L1.4380|
;;;1749   
;;;1750   		case VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP:
00111c  e1a00000          MOV      r0,r0
;;;1751   
;;;1752   			/* internal computation: */
;;;1753   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
001120  e585403c          STR      r4,[r5,#0x3c]
;;;1754   				VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP,
;;;1755   				LimitCheckValue);
;;;1756   
;;;1757   			break;
001124  ea00000e          B        |L1.4452|
                  |L1.4392|
;;;1758   
;;;1759   		case VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD:
001128  e1a00000          MOV      r0,r0
;;;1760   
;;;1761   			/* internal computation: */
;;;1762   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
00112c  e5854040          STR      r4,[r5,#0x40]
;;;1763   				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;1764   				LimitCheckValue);
;;;1765   
;;;1766   			break;
001130  ea00000b          B        |L1.4452|
                  |L1.4404|
;;;1767   
;;;1768   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC:
001134  e1a00000          MOV      r0,r0
;;;1769   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE:
001138  e1a00000          MOV      r0,r0
                  |L1.4412|
;;;1770   
;;;1771   			Status = VL53L0X_WrWord(Dev,
00113c  e59f0c7c          LDR      r0,|L1.7616|
001140  e00024a4          AND      r2,r0,r4,LSR #9
001144  e3a01064          MOV      r1,#0x64
001148  e1a00005          MOV      r0,r5
00114c  ebfffffe          BL       VL53L0X_WrWord
001150  e1a07000          MOV      r7,r0
;;;1772   				VL53L0X_REG_PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT,
;;;1773   				VL53L0X_FIXPOINT1616TOFIXPOINT97(
;;;1774   					LimitCheckValue));
;;;1775   
;;;1776   			break;
001154  ea000002          B        |L1.4452|
                  |L1.4440|
;;;1777   
;;;1778   		default:
001158  e1a00000          MOV      r0,r0
;;;1779   			Status = VL53L0X_ERROR_INVALID_PARAMS;
00115c  e3e07003          MVN      r7,#3
001160  e1a00000          MOV      r0,r0                 ;1732
                  |L1.4452|
001164  e1a00000          MOV      r0,r0                 ;1739
;;;1780   
;;;1781   		}
;;;1782   
;;;1783   		if (Status == VL53L0X_ERROR_NONE) {
001168  e3570000          CMP      r7,#0
00116c  1a000001          BNE      |L1.4472|
;;;1784   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
001170  e2850034          ADD      r0,r5,#0x34
001174  e7804106          STR      r4,[r0,r6,LSL #2]
                  |L1.4472|
;;;1785   				LimitCheckId, LimitCheckValue);
;;;1786   		}
;;;1787   	}
;;;1788   
;;;1789   	LOG_FUNCTION_END(Status);
;;;1790   	return Status;
001178  e1a00007          MOV      r0,r7
;;;1791   }
00117c  e8bd81f0          POP      {r4-r8,pc}
;;;1792   
                          ENDP

                  VL53L0X_SetLimitCheckEnable PROC
;;;1591   
;;;1592   VL53L0X_Error VL53L0X_SetLimitCheckEnable(VL53L0X_DEV Dev, uint16_t LimitCheckId,
001180  e92d5ff0          PUSH     {r4-r12,lr}
;;;1593   	uint8_t LimitCheckEnable)
;;;1594   {
001184  e1a04000          MOV      r4,r0
001188  e1a05001          MOV      r5,r1
00118c  e1a06002          MOV      r6,r2
;;;1595   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001190  e3a09000          MOV      r9,#0
;;;1596   	FixPoint1616_t TempFix1616 = 0;
001194  e3a0b000          MOV      r11,#0
;;;1597   	uint8_t LimitCheckEnableInt = 0;
001198  e3a07000          MOV      r7,#0
;;;1598   	uint8_t LimitCheckDisable = 0;
00119c  e3a0a000          MOV      r10,#0
;;;1599   	uint8_t Temp8;
;;;1600   
;;;1601   	LOG_FUNCTION_START("");
;;;1602   
;;;1603   	if (LimitCheckId >= VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS) {
0011a0  e3550006          CMP      r5,#6
0011a4  ba000001          BLT      |L1.4528|
;;;1604   		Status = VL53L0X_ERROR_INVALID_PARAMS;
0011a8  e3e09003          MVN      r9,#3
0011ac  ea00003b          B        |L1.4768|
                  |L1.4528|
;;;1605   	} else {
;;;1606   		if (LimitCheckEnable == 0) {
0011b0  e3560000          CMP      r6,#0
0011b4  1a000003          BNE      |L1.4552|
;;;1607   			TempFix1616 = 0;
0011b8  e3a0b000          MOV      r11,#0
;;;1608   			LimitCheckEnableInt = 0;
0011bc  e3a07000          MOV      r7,#0
;;;1609   			LimitCheckDisable = 1;
0011c0  e3a0a001          MOV      r10,#1
0011c4  ea000003          B        |L1.4568|
                  |L1.4552|
;;;1610   
;;;1611   		} else {
;;;1612   			VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksValue,
0011c8  e2840034          ADD      r0,r4,#0x34
0011cc  e790b105          LDR      r11,[r0,r5,LSL #2]
;;;1613   				LimitCheckId, TempFix1616);
;;;1614   			LimitCheckDisable = 0;
0011d0  e3a0a000          MOV      r10,#0
;;;1615   			/* this to be sure to have either 0 or 1 */
;;;1616   			LimitCheckEnableInt = 1;
0011d4  e3a07001          MOV      r7,#1
                  |L1.4568|
;;;1617   		}
;;;1618   
;;;1619   		switch (LimitCheckId) {
0011d8  e3550006          CMP      r5,#6
0011dc  308ff105          ADDCC    pc,pc,r5,LSL #2
0011e0  ea00002a          B        |L1.4752|
0011e4  ea000004          B        |L1.4604|
0011e8  ea000006          B        |L1.4616|
0011ec  ea00000d          B        |L1.4648|
0011f0  ea00000f          B        |L1.4660|
0011f4  ea000011          B        |L1.4672|
0011f8  ea00001a          B        |L1.4712|
                  |L1.4604|
;;;1620   
;;;1621   		case VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE:
0011fc  e1a00000          MOV      r0,r0
;;;1622   			/* internal computation: */
;;;1623   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
001200  e5c47028          STRB     r7,[r4,#0x28]
;;;1624   				VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE,
;;;1625   				LimitCheckEnableInt);
;;;1626   
;;;1627   			break;
001204  ea000024          B        |L1.4764|
                  |L1.4616|
;;;1628   
;;;1629   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
001208  e1a00000          MOV      r0,r0
;;;1630   
;;;1631   			Status = VL53L0X_WrWord(Dev,
00120c  e59f0bac          LDR      r0,|L1.7616|
001210  e00024ab          AND      r2,r0,r11,LSR #9
001214  e3a01044          MOV      r1,#0x44
001218  e1a00004          MOV      r0,r4
00121c  ebfffffe          BL       VL53L0X_WrWord
001220  e1a09000          MOV      r9,r0
;;;1632   			VL53L0X_REG_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT,
;;;1633   				VL53L0X_FIXPOINT1616TOFIXPOINT97(TempFix1616));
;;;1634   
;;;1635   			break;
001224  ea00001c          B        |L1.4764|
                  |L1.4648|
;;;1636   
;;;1637   		case VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP:
001228  e1a00000          MOV      r0,r0
;;;1638   
;;;1639   			/* internal computation: */
;;;1640   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
00122c  e5c4702a          STRB     r7,[r4,#0x2a]
;;;1641   				VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP,
;;;1642   				LimitCheckEnableInt);
;;;1643   
;;;1644   			break;
001230  ea000019          B        |L1.4764|
                  |L1.4660|
;;;1645   
;;;1646   		case VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD:
001234  e1a00000          MOV      r0,r0
;;;1647   
;;;1648   			/* internal computation: */
;;;1649   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
001238  e5c4702b          STRB     r7,[r4,#0x2b]
;;;1650   				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;1651   				LimitCheckEnableInt);
;;;1652   
;;;1653   			break;
00123c  ea000016          B        |L1.4764|
                  |L1.4672|
;;;1654   
;;;1655   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC:
001240  e1a00000          MOV      r0,r0
;;;1656   
;;;1657   			Temp8 = (uint8_t)(LimitCheckDisable << 1);
001244  e1a00c8a          LSL      r0,r10,#25
001248  e1a08c20          LSR      r8,r0,#24
;;;1658   			Status = VL53L0X_UpdateByte(Dev,
00124c  e1a03008          MOV      r3,r8
001250  e3a020fe          MOV      r2,#0xfe
001254  e3a01060          MOV      r1,#0x60
001258  e1a00004          MOV      r0,r4
00125c  ebfffffe          BL       VL53L0X_UpdateByte
001260  e1a09000          MOV      r9,r0
;;;1659   				VL53L0X_REG_MSRC_CONFIG_CONTROL,
;;;1660   				0xFE, Temp8);
;;;1661   
;;;1662   			break;
001264  ea00000c          B        |L1.4764|
                  |L1.4712|
;;;1663   
;;;1664   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE:
001268  e1a00000          MOV      r0,r0
;;;1665   
;;;1666   			Temp8 = (uint8_t)(LimitCheckDisable << 4);
00126c  e1a00e0a          LSL      r0,r10,#28
001270  e1a08c20          LSR      r8,r0,#24
;;;1667   			Status = VL53L0X_UpdateByte(Dev,
001274  e1a03008          MOV      r3,r8
001278  e3a020ef          MOV      r2,#0xef
00127c  e3a01060          MOV      r1,#0x60
001280  e1a00004          MOV      r0,r4
001284  ebfffffe          BL       VL53L0X_UpdateByte
001288  e1a09000          MOV      r9,r0
;;;1668   				VL53L0X_REG_MSRC_CONFIG_CONTROL,
;;;1669   				0xEF, Temp8);
;;;1670   
;;;1671   			break;
00128c  ea000002          B        |L1.4764|
                  |L1.4752|
;;;1672   
;;;1673   
;;;1674   		default:
001290  e1a00000          MOV      r0,r0
;;;1675   			Status = VL53L0X_ERROR_INVALID_PARAMS;
001294  e3e09003          MVN      r9,#3
001298  e1a00000          MOV      r0,r0                 ;1619
                  |L1.4764|
00129c  e1a00000          MOV      r0,r0                 ;1627
                  |L1.4768|
;;;1676   
;;;1677   		}
;;;1678   
;;;1679   	}
;;;1680   
;;;1681   	if (Status == VL53L0X_ERROR_NONE) {
0012a0  e3590000          CMP      r9,#0
0012a4  1a000008          BNE      |L1.4812|
;;;1682   		if (LimitCheckEnable == 0) {
0012a8  e3560000          CMP      r6,#0
0012ac  1a000003          BNE      |L1.4800|
;;;1683   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
0012b0  e3a00000          MOV      r0,#0
0012b4  e2841028          ADD      r1,r4,#0x28
0012b8  e7c10005          STRB     r0,[r1,r5]
0012bc  ea000002          B        |L1.4812|
                  |L1.4800|
;;;1684   				LimitCheckId, 0);
;;;1685   		} else {
;;;1686   			VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksEnable,
0012c0  e3a00001          MOV      r0,#1
0012c4  e2841028          ADD      r1,r4,#0x28
0012c8  e7c10005          STRB     r0,[r1,r5]
                  |L1.4812|
;;;1687   				LimitCheckId, 1);
;;;1688   		}
;;;1689   	}
;;;1690   
;;;1691   	LOG_FUNCTION_END(Status);
;;;1692   	return Status;
0012cc  e1a00009          MOV      r0,r9
;;;1693   }
0012d0  e8bd9ff0          POP      {r4-r12,pc}
;;;1694   
                          ENDP

                  VL53L0X_DataInit PROC
;;;369    
;;;370    VL53L0X_Error VL53L0X_DataInit(VL53L0X_DEV Dev)
0012d4  e92d4070          PUSH     {r4-r6,lr}
;;;371    {
0012d8  e24dd048          SUB      sp,sp,#0x48
0012dc  e1a05000          MOV      r5,r0
;;;372    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0012e0  e3a04000          MOV      r4,#0
;;;373    	VL53L0X_DeviceParameters_t CurrentParameters;
;;;374    	int i;
;;;375    	uint8_t StopVariable;
;;;376    
;;;377    	LOG_FUNCTION_START("");
;;;378    
;;;379    	/* by default the I2C is running at 1V8 if you want to change it you
;;;380    	 * need to include this define at compilation level. */
;;;381    #ifdef USE_I2C_2V8
;;;382        #error
;;;383    	Status = VL53L0X_UpdateByte(Dev,
;;;384    		VL53L0X_REG_VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV,
;;;385    		0xFE,
;;;386    		0x01);
;;;387    #endif
;;;388    
;;;389    	/* Set I2C standard mode */
;;;390    	if (Status == VL53L0X_ERROR_NONE)
0012e4  e3540000          CMP      r4,#0
0012e8  1a000004          BNE      |L1.4864|
;;;391    		Status = VL53L0X_WrByte(Dev, 0x88, 0x00);
0012ec  e3a02000          MOV      r2,#0
0012f0  e3a01088          MOV      r1,#0x88
0012f4  e1a00005          MOV      r0,r5
0012f8  ebfffffe          BL       VL53L0X_WrByte
0012fc  e1a04000          MOV      r4,r0
                  |L1.4864|
;;;392    
;;;393    	VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, ReadDataFromDeviceDone, 0);
001300  e3a00000          MOV      r0,#0
001304  e5c500f0          STRB     r0,[r5,#0xf0]
;;;394    
;;;395    #ifdef USE_IQC_STATION
;;;396    	if (Status == VL53L0X_ERROR_NONE)
;;;397    		Status = VL53L0X_apply_offset_adjustment(Dev);
;;;398    #endif
;;;399    
;;;400    	/* Default value is 1000 for Linearity Corrective Gain */
;;;401    	PALDevDataSet(Dev, LinearityCorrectiveGain, 1000);
001308  e3a00ffa          MOV      r0,#0x3e8
00130c  e59f1aa8          LDR      r1,|L1.7612|
001310  e18100b5          STRH     r0,[r1,r5]
;;;402    
;;;403    	/* Dmax default Parameter */
;;;404    	PALDevDataSet(Dev, DmaxCalRangeMilliMeter, 400);
001314  e3a00e19          MOV      r0,#0x190
001318  e3a01f55          MOV      r1,#0x154
00131c  e18100b5          STRH     r0,[r1,r5]
;;;405    	PALDevDataSet(Dev, DmaxCalSignalRateRtnMegaCps,
001320  e59f0a9c          LDR      r0,|L1.7620|
001324  e5850158          STR      r0,[r5,#0x158]
;;;406    		(FixPoint1616_t)((0x00016B85))); /* 1.42 No Cover Glass*/
;;;407    
;;;408    	/* Set Default static parameters
;;;409    	 *set first temporary values 9.44MHz * 65536 = 618660 */
;;;410    	VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, OscFrequencyMHz, 618660);
001328  e59f0a98          LDR      r0,|L1.7624|
00132c  e58500d4          STR      r0,[r5,#0xd4]
;;;411    
;;;412    	/* Set Default XTalkCompensationRateMegaCps to 0  */
;;;413    	VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps, 0);
001330  e3a00000          MOV      r0,#0
001334  e5850020          STR      r0,[r5,#0x20]
;;;414    
;;;415    	/* Get default parameters */
;;;416    	Status = VL53L0X_GetDeviceParameters(Dev, &CurrentParameters);
001338  e28d1008          ADD      r1,sp,#8
00133c  e1a00005          MOV      r0,r5
001340  ebfffffe          BL       VL53L0X_GetDeviceParameters
001344  e1a04000          MOV      r4,r0
;;;417    	if (Status == VL53L0X_ERROR_NONE) {
001348  e3540000          CMP      r4,#0
00134c  1a000006          BNE      |L1.4972|
;;;418    		/* initialize PAL values */
;;;419    		CurrentParameters.DeviceMode = VL53L0X_DEVICEMODE_SINGLE_RANGING;
001350  e3a00000          MOV      r0,#0
001354  e5cd0008          STRB     r0,[sp,#8]
;;;420    		CurrentParameters.HistogramMode = VL53L0X_HISTOGRAMMODE_DISABLED;
001358  e5cd0009          STRB     r0,[sp,#9]
;;;421    		PALDevDataSet(Dev, CurrentParameters, CurrentParameters);
00135c  e3a02040          MOV      r2,#0x40
001360  e28d1008          ADD      r1,sp,#8
001364  e2850010          ADD      r0,r5,#0x10
001368  ebfffffe          BL       __aeabi_memcpy4
                  |L1.4972|
;;;422    	}
;;;423    
;;;424    	/* Sigma estimator variable */
;;;425    	PALDevDataSet(Dev, SigmaEstRefArray, 100);
00136c  e3a00064          MOV      r0,#0x64
001370  e3a01f4d          MOV      r1,#0x134
001374  e18100b5          STRH     r0,[r1,r5]
;;;426    	PALDevDataSet(Dev, SigmaEstEffPulseWidth, 900);
001378  e3a00fe1          MOV      r0,#0x384
00137c  e18111c1          ORR      r1,r1,r1,ASR #3
001380  e18100b5          STRH     r0,[r1,r5]
;;;427    	PALDevDataSet(Dev, SigmaEstEffAmbWidth, 500);
001384  e3a00f7d          MOV      r0,#0x1f4
001388  e3a01f4e          MOV      r1,#0x138
00138c  e18100b5          STRH     r0,[r1,r5]
;;;428    	PALDevDataSet(Dev, targetRefRate, 0x0A00); /* 20 MCPS in 9:7 format */
001390  e3a00c0a          MOV      r0,#0xa00
001394  e3a01f4f          MOV      r1,#0x13c
001398  e18100b5          STRH     r0,[r1,r5]
;;;429    
;;;430    	/* Use internal default settings */
;;;431    	PALDevDataSet(Dev, UseInternalTuningSettings, 1);
00139c  e3a00001          MOV      r0,#1
0013a0  e5c50150          STRB     r0,[r5,#0x150]
;;;432    
;;;433    	Status |= VL53L0X_WrByte(Dev, 0x80, 0x01);
0013a4  e3a02001          MOV      r2,#1
0013a8  e3a01080          MOV      r1,#0x80
0013ac  e1a00005          MOV      r0,r5
0013b0  ebfffffe          BL       VL53L0X_WrByte
0013b4  e1844000          ORR      r4,r4,r0
;;;434    	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x01);
0013b8  e3a02001          MOV      r2,#1
0013bc  e3a010ff          MOV      r1,#0xff
0013c0  e1a00005          MOV      r0,r5
0013c4  ebfffffe          BL       VL53L0X_WrByte
0013c8  e1844000          ORR      r4,r4,r0
;;;435    	Status |= VL53L0X_WrByte(Dev, 0x00, 0x00);
0013cc  e3a02000          MOV      r2,#0
0013d0  e1a01002          MOV      r1,r2
0013d4  e1a00005          MOV      r0,r5
0013d8  ebfffffe          BL       VL53L0X_WrByte
0013dc  e1844000          ORR      r4,r4,r0
;;;436    	Status |= VL53L0X_RdByte(Dev, 0x91, &StopVariable);
0013e0  e28d2004          ADD      r2,sp,#4
0013e4  e3a01091          MOV      r1,#0x91
0013e8  e1a00005          MOV      r0,r5
0013ec  ebfffffe          BL       VL53L0X_RdByte
0013f0  e1844000          ORR      r4,r4,r0
;;;437    	PALDevDataSet(Dev, StopVariable, StopVariable);
0013f4  e5dd0004          LDRB     r0,[sp,#4]
0013f8  e5c5013a          STRB     r0,[r5,#0x13a]
;;;438    	Status |= VL53L0X_WrByte(Dev, 0x00, 0x01);
0013fc  e3a02001          MOV      r2,#1
001400  e3a01000          MOV      r1,#0
001404  e1a00005          MOV      r0,r5
001408  ebfffffe          BL       VL53L0X_WrByte
00140c  e1844000          ORR      r4,r4,r0
;;;439    	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
001410  e3a02000          MOV      r2,#0
001414  e3a010ff          MOV      r1,#0xff
001418  e1a00005          MOV      r0,r5
00141c  ebfffffe          BL       VL53L0X_WrByte
001420  e1844000          ORR      r4,r4,r0
;;;440    	Status |= VL53L0X_WrByte(Dev, 0x80, 0x00);
001424  e3a02000          MOV      r2,#0
001428  e3a01080          MOV      r1,#0x80
00142c  e1a00005          MOV      r0,r5
001430  ebfffffe          BL       VL53L0X_WrByte
001434  e1844000          ORR      r4,r4,r0
;;;441    
;;;442    	/* Enable all check */
;;;443    	for (i = 0; i < VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
001438  e3a06000          MOV      r6,#0
00143c  ea00000a          B        |L1.5228|
                  |L1.5184|
;;;444    		if (Status == VL53L0X_ERROR_NONE)
001440  e3540000          CMP      r4,#0
001444  1a000006          BNE      |L1.5220|
;;;445    			Status |= VL53L0X_SetLimitCheckEnable(Dev, i, 1);
001448  e1a01806          LSL      r1,r6,#16
00144c  e1a01821          LSR      r1,r1,#16
001450  e3a02001          MOV      r2,#1
001454  e1a00005          MOV      r0,r5
001458  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
00145c  e1844000          ORR      r4,r4,r0
001460  ea000000          B        |L1.5224|
                  |L1.5220|
;;;446    		else
;;;447    			break;
001464  ea000002          B        |L1.5236|
                  |L1.5224|
001468  e2866001          ADD      r6,r6,#1              ;443
                  |L1.5228|
00146c  e3560006          CMP      r6,#6                 ;443
001470  bafffff2          BLT      |L1.5184|
                  |L1.5236|
001474  e1a00000          MOV      r0,r0
;;;448    
;;;449    	}
;;;450    
;;;451    	/* Disable the following checks */
;;;452    	if (Status == VL53L0X_ERROR_NONE)
001478  e3540000          CMP      r4,#0
00147c  1a000004          BNE      |L1.5268|
;;;453    		Status = VL53L0X_SetLimitCheckEnable(Dev,
001480  e3a02000          MOV      r2,#0
001484  e3a01002          MOV      r1,#2
001488  e1a00005          MOV      r0,r5
00148c  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
001490  e1a04000          MOV      r4,r0
                  |L1.5268|
;;;454    			VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP, 0);
;;;455    
;;;456    	if (Status == VL53L0X_ERROR_NONE)
001494  e3540000          CMP      r4,#0
001498  1a000004          BNE      |L1.5296|
;;;457    		Status = VL53L0X_SetLimitCheckEnable(Dev,
00149c  e3a02000          MOV      r2,#0
0014a0  e3a01003          MOV      r1,#3
0014a4  e1a00005          MOV      r0,r5
0014a8  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
0014ac  e1a04000          MOV      r4,r0
                  |L1.5296|
;;;458    			VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD, 0);
;;;459    
;;;460    	if (Status == VL53L0X_ERROR_NONE)
0014b0  e3540000          CMP      r4,#0
0014b4  1a000004          BNE      |L1.5324|
;;;461    		Status = VL53L0X_SetLimitCheckEnable(Dev,
0014b8  e3a02000          MOV      r2,#0
0014bc  e3a01004          MOV      r1,#4
0014c0  e1a00005          MOV      r0,r5
0014c4  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
0014c8  e1a04000          MOV      r4,r0
                  |L1.5324|
;;;462    			VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC, 0);
;;;463    
;;;464    	if (Status == VL53L0X_ERROR_NONE)
0014cc  e3540000          CMP      r4,#0
0014d0  1a000004          BNE      |L1.5352|
;;;465    		Status = VL53L0X_SetLimitCheckEnable(Dev,
0014d4  e3a02000          MOV      r2,#0
0014d8  e3a01005          MOV      r1,#5
0014dc  e1a00005          MOV      r0,r5
0014e0  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
0014e4  e1a04000          MOV      r4,r0
                  |L1.5352|
;;;466    			VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE, 0);
;;;467    
;;;468    	/* Limit default values */
;;;469    	if (Status == VL53L0X_ERROR_NONE) {
0014e8  e3540000          CMP      r4,#0
0014ec  1a000004          BNE      |L1.5380|
;;;470    		Status = VL53L0X_SetLimitCheckValue(Dev,
0014f0  e3a02812          MOV      r2,#0x120000
0014f4  e3a01000          MOV      r1,#0
0014f8  e1a00005          MOV      r0,r5
0014fc  ebfffffe          BL       VL53L0X_SetLimitCheckValue
001500  e1a04000          MOV      r4,r0
                  |L1.5380|
;;;471    			VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE,
;;;472    				(FixPoint1616_t)(18 * 65536));
;;;473    	}
;;;474    	if (Status == VL53L0X_ERROR_NONE) {
001504  e3540000          CMP      r4,#0
001508  1a000004          BNE      |L1.5408|
;;;475    		Status = VL53L0X_SetLimitCheckValue(Dev,
00150c  e3a02901          MOV      r2,#0x4000
001510  e3a01001          MOV      r1,#1
001514  e1a00005          MOV      r0,r5
001518  ebfffffe          BL       VL53L0X_SetLimitCheckValue
00151c  e1a04000          MOV      r4,r0
                  |L1.5408|
;;;476    			VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
;;;477    				(FixPoint1616_t)(25 * 65536 / 100));
;;;478    				/* 0.25 * 65536 */
;;;479    	}
;;;480    
;;;481    	if (Status == VL53L0X_ERROR_NONE) {
001520  e3540000          CMP      r4,#0
001524  1a000004          BNE      |L1.5436|
;;;482    		Status = VL53L0X_SetLimitCheckValue(Dev,
001528  e3a02823          MOV      r2,#0x230000
00152c  e3a01002          MOV      r1,#2
001530  e1a00005          MOV      r0,r5
001534  ebfffffe          BL       VL53L0X_SetLimitCheckValue
001538  e1a04000          MOV      r4,r0
                  |L1.5436|
;;;483    			VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP,
;;;484    				(FixPoint1616_t)(35 * 65536));
;;;485    	}
;;;486    
;;;487    	if (Status == VL53L0X_ERROR_NONE) {
00153c  e3540000          CMP      r4,#0
001540  1a000004          BNE      |L1.5464|
;;;488    		Status = VL53L0X_SetLimitCheckValue(Dev,
001544  e3a02000          MOV      r2,#0
001548  e3a01003          MOV      r1,#3
00154c  e1a00005          MOV      r0,r5
001550  ebfffffe          BL       VL53L0X_SetLimitCheckValue
001554  e1a04000          MOV      r4,r0
                  |L1.5464|
;;;489    			VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;490    				(FixPoint1616_t)(0 * 65536));
;;;491    	}
;;;492    
;;;493    	if (Status == VL53L0X_ERROR_NONE) {
001558  e3540000          CMP      r4,#0
00155c  1a000008          BNE      |L1.5508|
;;;494    
;;;495    		PALDevDataSet(Dev, SequenceConfig, 0xFF);
001560  e3a000ff          MOV      r0,#0xff
001564  e5c50130          STRB     r0,[r5,#0x130]
;;;496    		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
001568  e3a020ff          MOV      r2,#0xff
00156c  e3a01001          MOV      r1,#1
001570  e1a00005          MOV      r0,r5
001574  ebfffffe          BL       VL53L0X_WrByte
001578  e1a04000          MOV      r4,r0
;;;497    			0xFF);
;;;498    
;;;499    		/* Set PAL state to tell that we are waiting for call to
;;;500    		 * VL53L0X_StaticInit */
;;;501    		PALDevDataSet(Dev, PalState, VL53L0X_STATE_WAIT_STATICINIT);
00157c  e3a00001          MOV      r0,#1
001580  e5c50132          STRB     r0,[r5,#0x132]
                  |L1.5508|
;;;502    	}
;;;503    
;;;504    	if (Status == VL53L0X_ERROR_NONE)
001584  e3540000          CMP      r4,#0
001588  1a000001          BNE      |L1.5524|
;;;505    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, RefSpadsInitialised, 0);
00158c  e3a00000          MOV      r0,#0
001590  e5c50115          STRB     r0,[r5,#0x115]
                  |L1.5524|
;;;506    
;;;507    
;;;508    	LOG_FUNCTION_END(Status);
;;;509    	return Status;
001594  e1a00004          MOV      r0,r4
001598  e28dd048          ADD      sp,sp,#0x48
;;;510    }
00159c  e8bd8070          POP      {r4-r6,pc}
;;;511    
                          ENDP

                  VL53L0X_SetTuningSettingBuffer PROC
;;;512    VL53L0X_Error VL53L0X_SetTuningSettingBuffer(VL53L0X_DEV Dev,
0015a0  e1a03000          MOV      r3,r0
;;;513    	uint8_t *pTuningSettingBuffer, uint8_t UseInternalTuningSettings)
;;;514    {
;;;515    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0015a4  e3a00000          MOV      r0,#0
;;;516    
;;;517    	LOG_FUNCTION_START("");
;;;518    
;;;519    	if (UseInternalTuningSettings == 1) {
0015a8  e3520001          CMP      r2,#1
0015ac  1a000002          BNE      |L1.5564|
;;;520    		/* Force use internal settings */
;;;521    		PALDevDataSet(Dev, UseInternalTuningSettings, 1);
0015b0  e3a0c001          MOV      r12,#1
0015b4  e5c3c150          STRB     r12,[r3,#0x150]
0015b8  ea000007          B        |L1.5596|
                  |L1.5564|
;;;522    	} else {
;;;523    
;;;524    		/* check that the first byte is not 0 */
;;;525    		if (*pTuningSettingBuffer != 0) {
0015bc  e5d1c000          LDRB     r12,[r1,#0]
0015c0  e35c0000          CMP      r12,#0
0015c4  0a000003          BEQ      |L1.5592|
;;;526    			PALDevDataSet(Dev, pTuningSettingsPointer,
0015c8  e583114c          STR      r1,[r3,#0x14c]
;;;527    				pTuningSettingBuffer);
;;;528    			PALDevDataSet(Dev, UseInternalTuningSettings, 0);
0015cc  e3a0c000          MOV      r12,#0
0015d0  e5c3c150          STRB     r12,[r3,#0x150]
0015d4  ea000000          B        |L1.5596|
                  |L1.5592|
;;;529    
;;;530    		} else {
;;;531    			Status = VL53L0X_ERROR_INVALID_PARAMS;
0015d8  e3e00003          MVN      r0,#3
                  |L1.5596|
;;;532    		}
;;;533    	}
;;;534    
;;;535    	LOG_FUNCTION_END(Status);
;;;536    	return Status;
;;;537    }
0015dc  e12fff1e          BX       lr
;;;538    
                          ENDP

                  VL53L0X_GetTuningSettingBuffer PROC
;;;539    VL53L0X_Error VL53L0X_GetTuningSettingBuffer(VL53L0X_DEV Dev,
0015e0  e1a03000          MOV      r3,r0
;;;540    	uint8_t **ppTuningSettingBuffer, uint8_t *pUseInternalTuningSettings)
;;;541    {
;;;542    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0015e4  e3a00000          MOV      r0,#0
;;;543    
;;;544    	LOG_FUNCTION_START("");
;;;545    
;;;546    	*ppTuningSettingBuffer = PALDevDataGet(Dev, pTuningSettingsPointer);
0015e8  e593c14c          LDR      r12,[r3,#0x14c]
0015ec  e581c000          STR      r12,[r1,#0]
;;;547    	*pUseInternalTuningSettings = PALDevDataGet(Dev,
0015f0  e5d3c150          LDRB     r12,[r3,#0x150]
0015f4  e5c2c000          STRB     r12,[r2,#0]
;;;548    		UseInternalTuningSettings);
;;;549    
;;;550    	LOG_FUNCTION_END(Status);
;;;551    	return Status;
;;;552    }
0015f8  e12fff1e          BX       lr
;;;553    
                          ENDP

                  VL53L0X_WaitDeviceBooted PROC
;;;732    
;;;733    VL53L0X_Error VL53L0X_WaitDeviceBooted(VL53L0X_DEV Dev)
0015fc  e1a01000          MOV      r1,r0
;;;734    {
;;;735    	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
001600  e3e00062          MVN      r0,#0x62
;;;736    	LOG_FUNCTION_START("");
;;;737    
;;;738    	/* not implemented on VL53L0X */
;;;739    
;;;740    	LOG_FUNCTION_END(Status);
;;;741    	return Status;
;;;742    }
001604  e12fff1e          BX       lr
;;;743    
                          ENDP

                  VL53L0X_ResetDevice PROC
;;;744    VL53L0X_Error VL53L0X_ResetDevice(VL53L0X_DEV Dev)
001608  e92d4038          PUSH     {r3-r5,lr}
;;;745    {
00160c  e1a05000          MOV      r5,r0
;;;746    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001610  e3a04000          MOV      r4,#0
;;;747    	uint8_t Byte;
;;;748    	LOG_FUNCTION_START("");
;;;749    
;;;750    	/* Set reset bit */
;;;751    	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SOFT_RESET_GO2_SOFT_RESET_N,
001614  e3a02000          MOV      r2,#0
001618  e3a010bf          MOV      r1,#0xbf
00161c  e1a00005          MOV      r0,r5
001620  ebfffffe          BL       VL53L0X_WrByte
001624  e1a04000          MOV      r4,r0
;;;752    		0x00);
;;;753    
;;;754    	/* Wait for some time */
;;;755    	if (Status == VL53L0X_ERROR_NONE) {
001628  e3540000          CMP      r4,#0
00162c  1a000008          BNE      |L1.5716|
;;;756    		do {
001630  e1a00000          MOV      r0,r0
                  |L1.5684|
;;;757    			Status = VL53L0X_RdByte(Dev,
001634  e1a0200d          MOV      r2,sp
001638  e3a010c0          MOV      r1,#0xc0
00163c  e1a00005          MOV      r0,r5
001640  ebfffffe          BL       VL53L0X_RdByte
001644  e1a04000          MOV      r4,r0
;;;758    			VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Byte);
;;;759    		} while (Byte != 0x00);
001648  e5dd0000          LDRB     r0,[sp,#0]
00164c  e3500000          CMP      r0,#0
001650  1afffff7          BNE      |L1.5684|
                  |L1.5716|
;;;760    	}
;;;761    
;;;762    	/* Release reset */
;;;763    	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SOFT_RESET_GO2_SOFT_RESET_N,
001654  e3a02001          MOV      r2,#1
001658  e3a010bf          MOV      r1,#0xbf
00165c  e1a00005          MOV      r0,r5
001660  ebfffffe          BL       VL53L0X_WrByte
001664  e1a04000          MOV      r4,r0
;;;764    		0x01);
;;;765    
;;;766    	/* Wait until correct boot-up of the device */
;;;767    	if (Status == VL53L0X_ERROR_NONE) {
001668  e3540000          CMP      r4,#0
00166c  1a000008          BNE      |L1.5780|
;;;768    		do {
001670  e1a00000          MOV      r0,r0
                  |L1.5748|
;;;769    			Status = VL53L0X_RdByte(Dev,
001674  e1a0200d          MOV      r2,sp
001678  e3a010c0          MOV      r1,#0xc0
00167c  e1a00005          MOV      r0,r5
001680  ebfffffe          BL       VL53L0X_RdByte
001684  e1a04000          MOV      r4,r0
;;;770    			VL53L0X_REG_IDENTIFICATION_MODEL_ID, &Byte);
;;;771    		} while (Byte == 0x00);
001688  e5dd0000          LDRB     r0,[sp,#0]
00168c  e3500000          CMP      r0,#0
001690  0afffff7          BEQ      |L1.5748|
                  |L1.5780|
;;;772    	}
;;;773    
;;;774    	/* Set PAL State to VL53L0X_STATE_POWERDOWN */
;;;775    	if (Status == VL53L0X_ERROR_NONE)
001694  e3540000          CMP      r4,#0
001698  1a000001          BNE      |L1.5796|
;;;776    		PALDevDataSet(Dev, PalState, VL53L0X_STATE_POWERDOWN);
00169c  e3a00000          MOV      r0,#0
0016a0  e5c50132          STRB     r0,[r5,#0x132]
                  |L1.5796|
;;;777    
;;;778    
;;;779    	LOG_FUNCTION_END(Status);
;;;780    	return Status;
0016a4  e1a00004          MOV      r0,r4
;;;781    }
0016a8  e8bd8038          POP      {r3-r5,pc}
;;;782    /* End Group PAL Init Functions */
                          ENDP

                  VL53L0X_SetWrapAroundCheckEnable PROC
;;;1957    */
;;;1958   VL53L0X_Error VL53L0X_SetWrapAroundCheckEnable(VL53L0X_DEV Dev,
0016ac  e92d40f8          PUSH     {r3-r7,lr}
;;;1959   	uint8_t WrapAroundCheckEnable)
;;;1960   {
0016b0  e1a04000          MOV      r4,r0
0016b4  e1a06001          MOV      r6,r1
;;;1961   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0016b8  e3a07000          MOV      r7,#0
;;;1962   	uint8_t Byte;
;;;1963   	uint8_t WrapAroundCheckEnableInt;
;;;1964   
;;;1965   	LOG_FUNCTION_START("");
;;;1966   
;;;1967   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, &Byte);
0016bc  e1a0200d          MOV      r2,sp
0016c0  e3a01001          MOV      r1,#1
0016c4  e1a00004          MOV      r0,r4
0016c8  ebfffffe          BL       VL53L0X_RdByte
0016cc  e1a07000          MOV      r7,r0
;;;1968   	if (WrapAroundCheckEnable == 0) {
0016d0  e3560000          CMP      r6,#0
0016d4  1a000004          BNE      |L1.5868|
;;;1969   		/* Disable wraparound */
;;;1970   		Byte = Byte & 0x7F;
0016d8  e5dd0000          LDRB     r0,[sp,#0]
0016dc  e200007f          AND      r0,r0,#0x7f
0016e0  e58d0000          STR      r0,[sp,#0]
;;;1971   		WrapAroundCheckEnableInt = 0;
0016e4  e3a05000          MOV      r5,#0
0016e8  ea000003          B        |L1.5884|
                  |L1.5868|
;;;1972   	} else {
;;;1973   		/*Enable wraparound */
;;;1974   		Byte = Byte | 0x80;
0016ec  e5dd0000          LDRB     r0,[sp,#0]
0016f0  e3800080          ORR      r0,r0,#0x80
0016f4  e58d0000          STR      r0,[sp,#0]
;;;1975   		WrapAroundCheckEnableInt = 1;
0016f8  e3a05001          MOV      r5,#1
                  |L1.5884|
;;;1976   	}
;;;1977   
;;;1978   	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, Byte);
0016fc  e5dd2000          LDRB     r2,[sp,#0]
001700  e3a01001          MOV      r1,#1
001704  e1a00004          MOV      r0,r4
001708  ebfffffe          BL       VL53L0X_WrByte
00170c  e1a07000          MOV      r7,r0
;;;1979   
;;;1980   	if (Status == VL53L0X_ERROR_NONE) {
001710  e3570000          CMP      r7,#0
001714  1a000002          BNE      |L1.5924|
;;;1981   		PALDevDataSet(Dev, SequenceConfig, Byte);
001718  e5dd0000          LDRB     r0,[sp,#0]
00171c  e5c40130          STRB     r0,[r4,#0x130]
;;;1982   		VL53L0X_SETPARAMETERFIELD(Dev, WrapAroundCheckEnable,
001720  e5c4504c          STRB     r5,[r4,#0x4c]
                  |L1.5924|
;;;1983   			WrapAroundCheckEnableInt);
;;;1984   	}
;;;1985   
;;;1986   	LOG_FUNCTION_END(Status);
;;;1987   	return Status;
001724  e1a00007          MOV      r0,r7
;;;1988   }
001728  e8bd80f8          POP      {r3-r7,pc}
;;;1989   
                          ENDP

                  VL53L0X_SetXTalkCompensationRateMegaCps PROC
;;;1444   
;;;1445   VL53L0X_Error VL53L0X_SetXTalkCompensationRateMegaCps(VL53L0X_DEV Dev,
00172c  e92d47f0          PUSH     {r4-r10,lr}
;;;1446   	FixPoint1616_t XTalkCompensationRateMegaCps)
;;;1447   {
001730  e1a04000          MOV      r4,r0
001734  e1a05001          MOV      r5,r1
;;;1448   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001738  e3a07000          MOV      r7,#0
;;;1449   	uint8_t Temp8;
;;;1450   	uint16_t LinearityCorrectiveGain;
;;;1451   	uint16_t data;
;;;1452   	LOG_FUNCTION_START("");
;;;1453   
;;;1454   	VL53L0X_GETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp8);
00173c  e5d4801c          LDRB     r8,[r4,#0x1c]
;;;1455   	LinearityCorrectiveGain = PALDevDataGet(Dev, LinearityCorrectiveGain);
001740  e59f0674          LDR      r0,|L1.7612|
001744  e19090b4          LDRH     r9,[r0,r4]
;;;1456   
;;;1457   	if (Temp8 == 0) { /* disabled write only internal value */
001748  e3580000          CMP      r8,#0
00174c  1a000001          BNE      |L1.5976|
;;;1458   		VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
001750  e5845020          STR      r5,[r4,#0x20]
001754  ea00000d          B        |L1.6032|
                  |L1.5976|
;;;1459   			XTalkCompensationRateMegaCps);
;;;1460   	} else {
;;;1461   		/* the following register has a format 3.13 */
;;;1462   		if (LinearityCorrectiveGain == 1000) {
001758  e3590ffa          CMP      r9,#0x3e8
00175c  1a000002          BNE      |L1.5996|
;;;1463   			data = VL53L0X_FIXPOINT1616TOFIXPOINT313(
001760  e59f0658          LDR      r0,|L1.7616|
001764  e00061a5          AND      r6,r0,r5,LSR #3
001768  ea000000          B        |L1.6000|
                  |L1.5996|
;;;1464   				XTalkCompensationRateMegaCps);
;;;1465   		} else {
;;;1466   			data = 0;
00176c  e3a06000          MOV      r6,#0
                  |L1.6000|
;;;1467   		}
;;;1468   
;;;1469   		Status = VL53L0X_WrWord(Dev,
001770  e1a02006          MOV      r2,r6
001774  e3a01020          MOV      r1,#0x20
001778  e1a00004          MOV      r0,r4
00177c  ebfffffe          BL       VL53L0X_WrWord
001780  e1a07000          MOV      r7,r0
;;;1470   		VL53L0X_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS, data);
;;;1471   
;;;1472   		if (Status == VL53L0X_ERROR_NONE) {
001784  e3570000          CMP      r7,#0
001788  1a000000          BNE      |L1.6032|
;;;1473   			VL53L0X_SETPARAMETERFIELD(Dev,
00178c  e5845020          STR      r5,[r4,#0x20]
                  |L1.6032|
;;;1474   				XTalkCompensationRateMegaCps,
;;;1475   				XTalkCompensationRateMegaCps);
;;;1476   		}
;;;1477   	}
;;;1478   
;;;1479   	LOG_FUNCTION_END(Status);
;;;1480   	return Status;
001790  e1a00007          MOV      r0,r7
;;;1481   }
001794  e8bd87f0          POP      {r4-r10,pc}
;;;1482   
                          ENDP

                  VL53L0X_SetInterMeasurementPeriodMilliSeconds PROC
;;;1324   
;;;1325   VL53L0X_Error VL53L0X_SetInterMeasurementPeriodMilliSeconds(VL53L0X_DEV Dev,
001798  e92d40f8          PUSH     {r3-r7,lr}
;;;1326   	uint32_t InterMeasurementPeriodMilliSeconds)
;;;1327   {
00179c  e1a07000          MOV      r7,r0
0017a0  e1a04001          MOV      r4,r1
;;;1328   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0017a4  e3a05000          MOV      r5,#0
;;;1329   	uint16_t osc_calibrate_val;
;;;1330   	uint32_t IMPeriodMilliSeconds;
;;;1331   
;;;1332   	LOG_FUNCTION_START("");
;;;1333   
;;;1334   	Status = VL53L0X_RdWord(Dev, VL53L0X_REG_OSC_CALIBRATE_VAL,
0017a8  e1a0200d          MOV      r2,sp
0017ac  e3a010f8          MOV      r1,#0xf8
0017b0  e1a00007          MOV      r0,r7
0017b4  ebfffffe          BL       VL53L0X_RdWord
0017b8  e1a05000          MOV      r5,r0
;;;1335   		&osc_calibrate_val);
;;;1336   
;;;1337   	if (Status == VL53L0X_ERROR_NONE) {
0017bc  e3550000          CMP      r5,#0
0017c0  1a00000b          BNE      |L1.6132|
;;;1338   		if (osc_calibrate_val != 0) {
0017c4  e1dd00b0          LDRH     r0,[sp,#0]
0017c8  e3500000          CMP      r0,#0
0017cc  0a000002          BEQ      |L1.6108|
;;;1339   			IMPeriodMilliSeconds =
0017d0  e1dd00b0          LDRH     r0,[sp,#0]
0017d4  e0060094          MUL      r6,r4,r0
0017d8  ea000000          B        |L1.6112|
                  |L1.6108|
;;;1340   				InterMeasurementPeriodMilliSeconds
;;;1341   					* osc_calibrate_val;
;;;1342   		} else {
;;;1343   			IMPeriodMilliSeconds =
0017dc  e1a06004          MOV      r6,r4
                  |L1.6112|
;;;1344   				InterMeasurementPeriodMilliSeconds;
;;;1345   		}
;;;1346   		Status = VL53L0X_WrDWord(Dev,
0017e0  e1a02006          MOV      r2,r6
0017e4  e3a01004          MOV      r1,#4
0017e8  e1a00007          MOV      r0,r7
0017ec  ebfffffe          BL       VL53L0X_WrDWord
0017f0  e1a05000          MOV      r5,r0
                  |L1.6132|
;;;1347   		VL53L0X_REG_SYSTEM_INTERMEASUREMENT_PERIOD,
;;;1348   			IMPeriodMilliSeconds);
;;;1349   	}
;;;1350   
;;;1351   	if (Status == VL53L0X_ERROR_NONE) {
0017f4  e3550000          CMP      r5,#0
0017f8  1a000000          BNE      |L1.6144|
;;;1352   		VL53L0X_SETPARAMETERFIELD(Dev,
0017fc  e5874018          STR      r4,[r7,#0x18]
                  |L1.6144|
;;;1353   			InterMeasurementPeriodMilliSeconds,
;;;1354   			InterMeasurementPeriodMilliSeconds);
;;;1355   	}
;;;1356   
;;;1357   	LOG_FUNCTION_END(Status);
;;;1358   	return Status;
001800  e1a00005          MOV      r0,r5
;;;1359   }
001804  e8bd80f8          POP      {r3-r7,pc}
;;;1360   
                          ENDP

                  VL53L0X_SetDeviceMode PROC
;;;899    
;;;900    VL53L0X_Error VL53L0X_SetDeviceMode(VL53L0X_DEV Dev, VL53L0X_DeviceModes DeviceMode)
001808  e1a02000          MOV      r2,r0
;;;901    {
;;;902    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00180c  e3a00000          MOV      r0,#0
;;;903    
;;;904    	LOG_FUNCTION_START("%d", (int)DeviceMode);
;;;905    
;;;906    	switch (DeviceMode) {
001810  e3510003          CMP      r1,#3
001814  0a00000d          BEQ      |L1.6224|
001818  ca000004          BGT      |L1.6192|
00181c  e3510000          CMP      r1,#0
001820  0a000007          BEQ      |L1.6212|
001824  e3510001          CMP      r1,#1
001828  1a00000c          BNE      |L1.6240|
00182c  ea000006          B        |L1.6220|
                  |L1.6192|
001830  e3510014          CMP      r1,#0x14
001834  0a000006          BEQ      |L1.6228|
001838  e3510015          CMP      r1,#0x15
00183c  1a000007          BNE      |L1.6240|
001840  ea000004          B        |L1.6232|
                  |L1.6212|
;;;907    	case VL53L0X_DEVICEMODE_SINGLE_RANGING:
001844  e1a00000          MOV      r0,r0
;;;908    	case VL53L0X_DEVICEMODE_CONTINUOUS_RANGING:
001848  e1a00000          MOV      r0,r0
                  |L1.6220|
;;;909    	case VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
00184c  e1a00000          MOV      r0,r0
                  |L1.6224|
;;;910    	case VL53L0X_DEVICEMODE_GPIO_DRIVE:
001850  e1a00000          MOV      r0,r0
                  |L1.6228|
;;;911    	case VL53L0X_DEVICEMODE_GPIO_OSC:
001854  e1a00000          MOV      r0,r0
                  |L1.6232|
;;;912    		/* Supported modes */
;;;913    		VL53L0X_SETPARAMETERFIELD(Dev, DeviceMode, DeviceMode);
001858  e5c21010          STRB     r1,[r2,#0x10]
;;;914    		break;
00185c  ea000002          B        |L1.6252|
                  |L1.6240|
;;;915    	default:
001860  e1a00000          MOV      r0,r0
;;;916    		/* Unsupported mode */
;;;917    		Status = VL53L0X_ERROR_MODE_NOT_SUPPORTED;
001864  e3e00007          MVN      r0,#7
001868  e1a00000          MOV      r0,r0                 ;906
                  |L1.6252|
00186c  e1a00000          MOV      r0,r0                 ;914
;;;918    	}
;;;919    
;;;920    	LOG_FUNCTION_END(Status);
;;;921    	return Status;
;;;922    }
001870  e12fff1e          BX       lr
;;;923    
                          ENDP

                  VL53L0X_SetDeviceParameters PROC
;;;784    /* Group PAL Parameters Functions */
;;;785    VL53L0X_Error VL53L0X_SetDeviceParameters(VL53L0X_DEV Dev,
001874  e92d41f0          PUSH     {r4-r8,lr}
;;;786    	const VL53L0X_DeviceParameters_t *pDeviceParameters)
;;;787    {
001878  e1a07000          MOV      r7,r0
00187c  e1a05001          MOV      r5,r1
;;;788    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001880  e3a04000          MOV      r4,#0
;;;789    	int i;
;;;790    	LOG_FUNCTION_START("");
;;;791    	Status = VL53L0X_SetDeviceMode(Dev, pDeviceParameters->DeviceMode);
001884  e5d51000          LDRB     r1,[r5,#0]
001888  e1a00007          MOV      r0,r7
00188c  ebfffffe          BL       VL53L0X_SetDeviceMode
001890  e1a04000          MOV      r4,r0
;;;792    
;;;793    	if (Status == VL53L0X_ERROR_NONE)
001894  e3540000          CMP      r4,#0
001898  1a000003          BNE      |L1.6316|
;;;794    		Status = VL53L0X_SetInterMeasurementPeriodMilliSeconds(Dev,
00189c  e1a00007          MOV      r0,r7
0018a0  e5951008          LDR      r1,[r5,#8]
0018a4  ebfffffe          BL       VL53L0X_SetInterMeasurementPeriodMilliSeconds
0018a8  e1a04000          MOV      r4,r0
                  |L1.6316|
;;;795    			pDeviceParameters->InterMeasurementPeriodMilliSeconds);
;;;796    
;;;797    
;;;798    	if (Status == VL53L0X_ERROR_NONE)
0018ac  e3540000          CMP      r4,#0
0018b0  1a000003          BNE      |L1.6340|
;;;799    		Status = VL53L0X_SetXTalkCompensationRateMegaCps(Dev,
0018b4  e1a00007          MOV      r0,r7
0018b8  e5951010          LDR      r1,[r5,#0x10]
0018bc  ebfffffe          BL       VL53L0X_SetXTalkCompensationRateMegaCps
0018c0  e1a04000          MOV      r4,r0
                  |L1.6340|
;;;800    			pDeviceParameters->XTalkCompensationRateMegaCps);
;;;801    
;;;802    
;;;803    	if (Status == VL53L0X_ERROR_NONE)
0018c4  e3540000          CMP      r4,#0
0018c8  1a000003          BNE      |L1.6364|
;;;804    		Status = VL53L0X_SetOffsetCalibrationDataMicroMeter(Dev,
0018cc  e1a00007          MOV      r0,r7
0018d0  e5951014          LDR      r1,[r5,#0x14]
0018d4  ebfffffe          BL       VL53L0X_SetOffsetCalibrationDataMicroMeter
0018d8  e1a04000          MOV      r4,r0
                  |L1.6364|
;;;805    			pDeviceParameters->RangeOffsetMicroMeters);
;;;806    
;;;807    
;;;808    	for (i = 0; i < VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS; i++) {
0018dc  e3a06000          MOV      r6,#0
0018e0  ea000016          B        |L1.6464|
                  |L1.6372|
;;;809    		if (Status == VL53L0X_ERROR_NONE)
0018e4  e3540000          CMP      r4,#0
0018e8  1a000007          BNE      |L1.6412|
;;;810    			Status |= VL53L0X_SetLimitCheckEnable(Dev, i,
0018ec  e2850018          ADD      r0,r5,#0x18
0018f0  e7d02006          LDRB     r2,[r0,r6]
0018f4  e1a01806          LSL      r1,r6,#16
0018f8  e1a01821          LSR      r1,r1,#16
0018fc  e1a00007          MOV      r0,r7
001900  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
001904  e1844000          ORR      r4,r4,r0
001908  ea000000          B        |L1.6416|
                  |L1.6412|
;;;811    				pDeviceParameters->LimitChecksEnable[i]);
;;;812    		else
;;;813    			break;
00190c  ea00000d          B        |L1.6472|
                  |L1.6416|
;;;814    
;;;815    		if (Status == VL53L0X_ERROR_NONE)
001910  e3540000          CMP      r4,#0
001914  1a000007          BNE      |L1.6456|
;;;816    			Status |= VL53L0X_SetLimitCheckValue(Dev, i,
001918  e2850024          ADD      r0,r5,#0x24
00191c  e7902106          LDR      r2,[r0,r6,LSL #2]
001920  e1a01806          LSL      r1,r6,#16
001924  e1a01821          LSR      r1,r1,#16
001928  e1a00007          MOV      r0,r7
00192c  ebfffffe          BL       VL53L0X_SetLimitCheckValue
001930  e1844000          ORR      r4,r4,r0
001934  ea000000          B        |L1.6460|
                  |L1.6456|
;;;817    				pDeviceParameters->LimitChecksValue[i]);
;;;818    		else
;;;819    			break;
001938  ea000002          B        |L1.6472|
                  |L1.6460|
00193c  e2866001          ADD      r6,r6,#1              ;808
                  |L1.6464|
001940  e3560006          CMP      r6,#6                 ;808
001944  baffffe6          BLT      |L1.6372|
                  |L1.6472|
001948  e1a00000          MOV      r0,r0                 ;813
;;;820    
;;;821    	}
;;;822    
;;;823    	if (Status == VL53L0X_ERROR_NONE)
00194c  e3540000          CMP      r4,#0
001950  1a000003          BNE      |L1.6500|
;;;824    		Status = VL53L0X_SetWrapAroundCheckEnable(Dev,
001954  e5d5103c          LDRB     r1,[r5,#0x3c]
001958  e1a00007          MOV      r0,r7
00195c  ebfffffe          BL       VL53L0X_SetWrapAroundCheckEnable
001960  e1a04000          MOV      r4,r0
                  |L1.6500|
;;;825    			pDeviceParameters->WrapAroundCheckEnable);
;;;826    
;;;827    	if (Status == VL53L0X_ERROR_NONE)
001964  e3540000          CMP      r4,#0
001968  1a000003          BNE      |L1.6524|
;;;828    		Status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(Dev,
00196c  e1a00007          MOV      r0,r7
001970  e5951004          LDR      r1,[r5,#4]
001974  ebfffffe          BL       VL53L0X_SetMeasurementTimingBudgetMicroSeconds
001978  e1a04000          MOV      r4,r0
                  |L1.6524|
;;;829    			pDeviceParameters->MeasurementTimingBudgetMicroSeconds);
;;;830    
;;;831    
;;;832    	LOG_FUNCTION_END(Status);
;;;833    	return Status;
00197c  e1a00004          MOV      r0,r4
;;;834    }
001980  e8bd81f0          POP      {r4-r8,pc}
;;;835    
                          ENDP

                  VL53L0X_SetRangeFractionEnable PROC
;;;935    
;;;936    VL53L0X_Error VL53L0X_SetRangeFractionEnable(VL53L0X_DEV Dev,	uint8_t Enable)
001984  e92d4070          PUSH     {r4-r6,lr}
;;;937    {
001988  e1a05000          MOV      r5,r0
00198c  e1a04001          MOV      r4,r1
;;;938    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001990  e3a06000          MOV      r6,#0
;;;939    
;;;940    	LOG_FUNCTION_START("%d", (int)Enable);
;;;941    
;;;942    	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_RANGE_CONFIG, Enable);
001994  e1a02004          MOV      r2,r4
001998  e3a01009          MOV      r1,#9
00199c  e1a00005          MOV      r0,r5
0019a0  ebfffffe          BL       VL53L0X_WrByte
0019a4  e1a06000          MOV      r6,r0
;;;943    
;;;944    	if (Status == VL53L0X_ERROR_NONE)
0019a8  e3560000          CMP      r6,#0
0019ac  1a000000          BNE      |L1.6580|
;;;945    		PALDevDataSet(Dev, RangeFractionalEnable, Enable);
0019b0  e5c54131          STRB     r4,[r5,#0x131]
                  |L1.6580|
;;;946    
;;;947    	LOG_FUNCTION_END(Status);
;;;948    	return Status;
0019b4  e1a00006          MOV      r0,r6
;;;949    }
0019b8  e8bd8070          POP      {r4-r6,pc}
;;;950    
                          ENDP

                  VL53L0X_SetHistogramMode PROC
;;;964    
;;;965    VL53L0X_Error VL53L0X_SetHistogramMode(VL53L0X_DEV Dev,
0019bc  e1a02000          MOV      r2,r0
;;;966    	VL53L0X_HistogramModes HistogramMode)
;;;967    {
;;;968    	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
0019c0  e3e00062          MVN      r0,#0x62
;;;969    	LOG_FUNCTION_START("");
;;;970    
;;;971    	/* not implemented on VL53L0X */
;;;972    
;;;973    	LOG_FUNCTION_END(Status);
;;;974    	return Status;
;;;975    }
0019c4  e12fff1e          BX       lr
;;;976    
                          ENDP

                  VL53L0X_GetHistogramMode PROC
;;;977    VL53L0X_Error VL53L0X_GetHistogramMode(VL53L0X_DEV Dev,
0019c8  e1a02000          MOV      r2,r0
;;;978    	VL53L0X_HistogramModes *pHistogramMode)
;;;979    {
;;;980    	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
0019cc  e3e00062          MVN      r0,#0x62
;;;981    	LOG_FUNCTION_START("");
;;;982    
;;;983    	/* not implemented on VL53L0X */
;;;984    
;;;985    	LOG_FUNCTION_END(Status);
;;;986    	return Status;
;;;987    }
0019d0  e12fff1e          BX       lr
;;;988    
                          ENDP

                  VL53L0X_SetVcselPulsePeriod PROC
;;;1015   
;;;1016   VL53L0X_Error VL53L0X_SetVcselPulsePeriod(VL53L0X_DEV Dev,
0019d4  e92d41f0          PUSH     {r4-r8,lr}
;;;1017   	VL53L0X_VcselPeriod VcselPeriodType, uint8_t VCSELPulsePeriodPCLK)
;;;1018   {
0019d8  e1a04000          MOV      r4,r0
0019dc  e1a05001          MOV      r5,r1
0019e0  e1a06002          MOV      r6,r2
;;;1019   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0019e4  e3a07000          MOV      r7,#0
;;;1020   	LOG_FUNCTION_START("");
;;;1021   
;;;1022   	Status = VL53L0X_set_vcsel_pulse_period(Dev, VcselPeriodType,
0019e8  e1a02006          MOV      r2,r6
0019ec  e1a01005          MOV      r1,r5
0019f0  e1a00004          MOV      r0,r4
0019f4  ebfffffe          BL       VL53L0X_set_vcsel_pulse_period
0019f8  e1a07000          MOV      r7,r0
;;;1023   		VCSELPulsePeriodPCLK);
;;;1024   
;;;1025   	LOG_FUNCTION_END(Status);
;;;1026   	return Status;
0019fc  e1a00007          MOV      r0,r7
;;;1027   }
001a00  e8bd81f0          POP      {r4-r8,pc}
;;;1028   
                          ENDP

                  sequence_step_enabled PROC
;;;1130   
;;;1131   VL53L0X_Error sequence_step_enabled(VL53L0X_DEV Dev,
001a04  e92d4010          PUSH     {r4,lr}
;;;1132   	VL53L0X_SequenceStepId SequenceStepId, uint8_t SequenceConfig,
;;;1133   	uint8_t *pSequenceStepEnabled)
;;;1134   {
001a08  e1a0c000          MOV      r12,r0
;;;1135   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001a0c  e3a00000          MOV      r0,#0
;;;1136   	*pSequenceStepEnabled = 0;
001a10  e3a04000          MOV      r4,#0
001a14  e5c34000          STRB     r4,[r3,#0]
;;;1137   	LOG_FUNCTION_START("");
;;;1138   
;;;1139   	switch (SequenceStepId) {
001a18  e3510005          CMP      r1,#5
001a1c  308ff101          ADDCC    pc,pc,r1,LSL #2
001a20  ea00001d          B        |L1.6812|
001a24  ea000003          B        |L1.6712|
001a28  ea000007          B        |L1.6732|
001a2c  ea00000b          B        |L1.6752|
001a30  ea00000f          B        |L1.6772|
001a34  ea000013          B        |L1.6792|
                  |L1.6712|
;;;1140   	case VL53L0X_SEQUENCESTEP_TCC:
001a38  e1a00000          MOV      r0,r0
;;;1141   		*pSequenceStepEnabled = (SequenceConfig & 0x10) >> 4;
001a3c  e2024010          AND      r4,r2,#0x10
001a40  e1a04244          ASR      r4,r4,#4
001a44  e5c34000          STRB     r4,[r3,#0]
;;;1142   		break;
001a48  ea000016          B        |L1.6824|
                  |L1.6732|
;;;1143   	case VL53L0X_SEQUENCESTEP_DSS:
001a4c  e1a00000          MOV      r0,r0
;;;1144   		*pSequenceStepEnabled = (SequenceConfig & 0x08) >> 3;
001a50  e2024008          AND      r4,r2,#8
001a54  e1a041c4          ASR      r4,r4,#3
001a58  e5c34000          STRB     r4,[r3,#0]
;;;1145   		break;
001a5c  ea000011          B        |L1.6824|
                  |L1.6752|
;;;1146   	case VL53L0X_SEQUENCESTEP_MSRC:
001a60  e1a00000          MOV      r0,r0
;;;1147   		*pSequenceStepEnabled = (SequenceConfig & 0x04) >> 2;
001a64  e2024004          AND      r4,r2,#4
001a68  e1a04144          ASR      r4,r4,#2
001a6c  e5c34000          STRB     r4,[r3,#0]
;;;1148   		break;
001a70  ea00000c          B        |L1.6824|
                  |L1.6772|
;;;1149   	case VL53L0X_SEQUENCESTEP_PRE_RANGE:
001a74  e1a00000          MOV      r0,r0
;;;1150   		*pSequenceStepEnabled = (SequenceConfig & 0x40) >> 6;
001a78  e2024040          AND      r4,r2,#0x40
001a7c  e1a04344          ASR      r4,r4,#6
001a80  e5c34000          STRB     r4,[r3,#0]
;;;1151   		break;
001a84  ea000007          B        |L1.6824|
                  |L1.6792|
;;;1152   	case VL53L0X_SEQUENCESTEP_FINAL_RANGE:
001a88  e1a00000          MOV      r0,r0
;;;1153   		*pSequenceStepEnabled = (SequenceConfig & 0x80) >> 7;
001a8c  e2024080          AND      r4,r2,#0x80
001a90  e1a043c4          ASR      r4,r4,#7
001a94  e5c34000          STRB     r4,[r3,#0]
;;;1154   		break;
001a98  ea000002          B        |L1.6824|
                  |L1.6812|
;;;1155   	default:
001a9c  e1a00000          MOV      r0,r0
;;;1156   		Status = VL53L0X_ERROR_INVALID_PARAMS;
001aa0  e3e00003          MVN      r0,#3
001aa4  e1a00000          MOV      r0,r0                 ;1139
                  |L1.6824|
001aa8  e1a00000          MOV      r0,r0                 ;1142
;;;1157   	}
;;;1158   
;;;1159   	LOG_FUNCTION_END(Status);
;;;1160   	return Status;
;;;1161   }
001aac  e8bd8010          POP      {r4,pc}
;;;1162   
                          ENDP

                  VL53L0X_GetSequenceStepEnable PROC
;;;1163   VL53L0X_Error VL53L0X_GetSequenceStepEnable(VL53L0X_DEV Dev,
001ab0  e92d40f8          PUSH     {r3-r7,lr}
;;;1164   	VL53L0X_SequenceStepId SequenceStepId, uint8_t *pSequenceStepEnabled)
;;;1165   {
001ab4  e1a06000          MOV      r6,r0
001ab8  e1a07001          MOV      r7,r1
001abc  e1a04002          MOV      r4,r2
;;;1166   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001ac0  e3a05000          MOV      r5,#0
;;;1167   	uint8_t SequenceConfig = 0;
001ac4  e3a00000          MOV      r0,#0
001ac8  e58d0000          STR      r0,[sp,#0]
;;;1168   	LOG_FUNCTION_START("");
;;;1169   
;;;1170   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
001acc  e1a0200d          MOV      r2,sp
001ad0  e3a01001          MOV      r1,#1
001ad4  e1a00006          MOV      r0,r6
001ad8  ebfffffe          BL       VL53L0X_RdByte
001adc  e1a05000          MOV      r5,r0
;;;1171   		&SequenceConfig);
;;;1172   
;;;1173   	if (Status == VL53L0X_ERROR_NONE) {
001ae0  e3550000          CMP      r5,#0
001ae4  1a000005          BNE      |L1.6912|
;;;1174   		Status = sequence_step_enabled(Dev, SequenceStepId,
001ae8  e1a03004          MOV      r3,r4
001aec  e5dd2000          LDRB     r2,[sp,#0]
001af0  e1a01007          MOV      r1,r7
001af4  e1a00006          MOV      r0,r6
001af8  ebfffffe          BL       sequence_step_enabled
001afc  e1a05000          MOV      r5,r0
                  |L1.6912|
;;;1175   			SequenceConfig, pSequenceStepEnabled);
;;;1176   	}
;;;1177   
;;;1178   	LOG_FUNCTION_END(Status);
;;;1179   	return Status;
001b00  e1a00005          MOV      r0,r5
;;;1180   }
001b04  e8bd80f8          POP      {r3-r7,pc}
;;;1181   
                          ENDP

                  VL53L0X_GetSequenceStepEnables PROC
;;;1182   VL53L0X_Error VL53L0X_GetSequenceStepEnables(VL53L0X_DEV Dev,
001b08  e92d40f8          PUSH     {r3-r7,lr}
;;;1183   	VL53L0X_SchedulerSequenceSteps_t *pSchedulerSequenceSteps)
;;;1184   {
001b0c  e1a06000          MOV      r6,r0
001b10  e1a04001          MOV      r4,r1
;;;1185   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001b14  e3a05000          MOV      r5,#0
;;;1186   	uint8_t SequenceConfig = 0;
001b18  e3a00000          MOV      r0,#0
001b1c  e58d0000          STR      r0,[sp,#0]
;;;1187   	LOG_FUNCTION_START("");
;;;1188   
;;;1189   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
001b20  e1a0200d          MOV      r2,sp
001b24  e3a01001          MOV      r1,#1
001b28  e1a00006          MOV      r0,r6
001b2c  ebfffffe          BL       VL53L0X_RdByte
001b30  e1a05000          MOV      r5,r0
;;;1190   		&SequenceConfig);
;;;1191   
;;;1192   	if (Status == VL53L0X_ERROR_NONE) {
001b34  e3550000          CMP      r5,#0
001b38  1a000005          BNE      |L1.6996|
;;;1193   		Status = sequence_step_enabled(Dev,
001b3c  e1a03004          MOV      r3,r4
001b40  e5dd2000          LDRB     r2,[sp,#0]
001b44  e3a01000          MOV      r1,#0
001b48  e1a00006          MOV      r0,r6
001b4c  ebfffffe          BL       sequence_step_enabled
001b50  e1a05000          MOV      r5,r0
                  |L1.6996|
;;;1194   		VL53L0X_SEQUENCESTEP_TCC, SequenceConfig,
;;;1195   			&pSchedulerSequenceSteps->TccOn);
;;;1196   	}
;;;1197   	if (Status == VL53L0X_ERROR_NONE) {
001b54  e3550000          CMP      r5,#0
001b58  1a000005          BNE      |L1.7028|
;;;1198   		Status = sequence_step_enabled(Dev,
001b5c  e2843002          ADD      r3,r4,#2
001b60  e5dd2000          LDRB     r2,[sp,#0]
001b64  e3a01001          MOV      r1,#1
001b68  e1a00006          MOV      r0,r6
001b6c  ebfffffe          BL       sequence_step_enabled
001b70  e1a05000          MOV      r5,r0
                  |L1.7028|
;;;1199   		VL53L0X_SEQUENCESTEP_DSS, SequenceConfig,
;;;1200   			&pSchedulerSequenceSteps->DssOn);
;;;1201   	}
;;;1202   	if (Status == VL53L0X_ERROR_NONE) {
001b74  e3550000          CMP      r5,#0
001b78  1a000005          BNE      |L1.7060|
;;;1203   		Status = sequence_step_enabled(Dev,
001b7c  e2843001          ADD      r3,r4,#1
001b80  e5dd2000          LDRB     r2,[sp,#0]
001b84  e3a01002          MOV      r1,#2
001b88  e1a00006          MOV      r0,r6
001b8c  ebfffffe          BL       sequence_step_enabled
001b90  e1a05000          MOV      r5,r0
                  |L1.7060|
;;;1204   		VL53L0X_SEQUENCESTEP_MSRC, SequenceConfig,
;;;1205   			&pSchedulerSequenceSteps->MsrcOn);
;;;1206   	}
;;;1207   	if (Status == VL53L0X_ERROR_NONE) {
001b94  e3550000          CMP      r5,#0
001b98  1a000005          BNE      |L1.7092|
;;;1208   		Status = sequence_step_enabled(Dev,
001b9c  e2843003          ADD      r3,r4,#3
001ba0  e5dd2000          LDRB     r2,[sp,#0]
001ba4  e3a01003          MOV      r1,#3
001ba8  e1a00006          MOV      r0,r6
001bac  ebfffffe          BL       sequence_step_enabled
001bb0  e1a05000          MOV      r5,r0
                  |L1.7092|
;;;1209   		VL53L0X_SEQUENCESTEP_PRE_RANGE, SequenceConfig,
;;;1210   			&pSchedulerSequenceSteps->PreRangeOn);
;;;1211   	}
;;;1212   	if (Status == VL53L0X_ERROR_NONE) {
001bb4  e3550000          CMP      r5,#0
001bb8  1a000005          BNE      |L1.7124|
;;;1213   		Status = sequence_step_enabled(Dev,
001bbc  e2843004          ADD      r3,r4,#4
001bc0  e5dd2000          LDRB     r2,[sp,#0]
001bc4  e3a01004          MOV      r1,#4
001bc8  e1a00006          MOV      r0,r6
001bcc  ebfffffe          BL       sequence_step_enabled
001bd0  e1a05000          MOV      r5,r0
                  |L1.7124|
;;;1214   		VL53L0X_SEQUENCESTEP_FINAL_RANGE, SequenceConfig,
;;;1215   			&pSchedulerSequenceSteps->FinalRangeOn);
;;;1216   	}
;;;1217   
;;;1218   	LOG_FUNCTION_END(Status);
;;;1219   	return Status;
001bd4  e1a00005          MOV      r0,r5
;;;1220   }
001bd8  e8bd80f8          POP      {r3-r7,pc}
;;;1221   
                          ENDP

                  VL53L0X_GetNumberOfSequenceSteps PROC
;;;1222   VL53L0X_Error VL53L0X_GetNumberOfSequenceSteps(VL53L0X_DEV Dev,
001bdc  e1a02000          MOV      r2,r0
;;;1223   	uint8_t *pNumberOfSequenceSteps)
;;;1224   {
;;;1225   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001be0  e3a00000          MOV      r0,#0
;;;1226   	LOG_FUNCTION_START("");
;;;1227   
;;;1228   	*pNumberOfSequenceSteps = VL53L0X_SEQUENCESTEP_NUMBER_OF_CHECKS;
001be4  e3a03005          MOV      r3,#5
001be8  e5c13000          STRB     r3,[r1,#0]
;;;1229   
;;;1230   	LOG_FUNCTION_END(Status);
;;;1231   	return Status;
;;;1232   }
001bec  e12fff1e          BX       lr
;;;1233   
                          ENDP

                  VL53L0X_GetSequenceStepsInfo PROC
;;;1234   VL53L0X_Error VL53L0X_GetSequenceStepsInfo(VL53L0X_SequenceStepId SequenceStepId,
001bf0  e92d4070          PUSH     {r4-r6,lr}
;;;1235   	char *pSequenceStepsString)
;;;1236   {
001bf4  e1a04000          MOV      r4,r0
001bf8  e1a05001          MOV      r5,r1
;;;1237   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001bfc  e3a06000          MOV      r6,#0
;;;1238   	LOG_FUNCTION_START("");
;;;1239   
;;;1240   	Status = VL53L0X_get_sequence_steps_info(
001c00  e1a01005          MOV      r1,r5
001c04  e1a00004          MOV      r0,r4
001c08  ebfffffe          BL       VL53L0X_get_sequence_steps_info
001c0c  e1a06000          MOV      r6,r0
;;;1241   			SequenceStepId,
;;;1242   			pSequenceStepsString);
;;;1243   
;;;1244   	LOG_FUNCTION_END(Status);
;;;1245   
;;;1246   	return Status;
001c10  e1a00006          MOV      r0,r6
;;;1247   }
001c14  e8bd8070          POP      {r4-r6,pc}
;;;1248   
                          ENDP

                  VL53L0X_SetSequenceStepTimeout PROC
;;;1249   VL53L0X_Error VL53L0X_SetSequenceStepTimeout(VL53L0X_DEV Dev,
001c18  e92d4ff8          PUSH     {r3-r11,lr}
;;;1250   	VL53L0X_SequenceStepId SequenceStepId, FixPoint1616_t TimeOutMilliSecs)
;;;1251   {
001c1c  e1a05000          MOV      r5,r0
001c20  e1a09001          MOV      r9,r1
001c24  e1a06002          MOV      r6,r2
;;;1252   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001c28  e1a00000          MOV      r0,r0
;;;1253   	VL53L0X_Error Status1 = VL53L0X_ERROR_NONE;
001c2c  e3a07000          MOV      r7,#0
;;;1254   	uint32_t TimeoutMicroSeconds = ((TimeOutMilliSecs * 1000) + 0x8000)
001c30  e0860086          ADD      r0,r6,r6,LSL #1
001c34  e0600386          RSB      r0,r0,r6,LSL #7
001c38  e3a01902          MOV      r1,#0x8000
001c3c  e0810180          ADD      r0,r1,r0,LSL #3
001c40  e1a0a820          LSR      r10,r0,#16
;;;1255   		>> 16;
;;;1256   	uint32_t MeasurementTimingBudgetMicroSeconds;
;;;1257   	FixPoint1616_t OldTimeOutMicroSeconds;
;;;1258   
;;;1259   	LOG_FUNCTION_START("");
;;;1260   
;;;1261   	/* Read back the current value in case we need to revert back to this.
;;;1262   	 */
;;;1263   	Status = get_sequence_step_timeout(Dev, SequenceStepId,
001c44  e1a0200d          MOV      r2,sp
001c48  e1a01009          MOV      r1,r9
001c4c  e1a00005          MOV      r0,r5
001c50  ebfffffe          BL       get_sequence_step_timeout
001c54  e1a04000          MOV      r4,r0
;;;1264   		&OldTimeOutMicroSeconds);
;;;1265   
;;;1266   	if (Status == VL53L0X_ERROR_NONE) {
001c58  e3540000          CMP      r4,#0
001c5c  1a000004          BNE      |L1.7284|
;;;1267   		Status = set_sequence_step_timeout(Dev, SequenceStepId,
001c60  e1a0200a          MOV      r2,r10
001c64  e1a01009          MOV      r1,r9
001c68  e1a00005          MOV      r0,r5
001c6c  ebfffffe          BL       set_sequence_step_timeout
001c70  e1a04000          MOV      r4,r0
                  |L1.7284|
;;;1268   			TimeoutMicroSeconds);
;;;1269   	}
;;;1270   
;;;1271   	if (Status == VL53L0X_ERROR_NONE) {
001c74  e3540000          CMP      r4,#0
001c78  1a000012          BNE      |L1.7368|
;;;1272   		VL53L0X_GETPARAMETERFIELD(Dev,
001c7c  e5958014          LDR      r8,[r5,#0x14]
;;;1273   			MeasurementTimingBudgetMicroSeconds,
;;;1274   			MeasurementTimingBudgetMicroSeconds);
;;;1275   
;;;1276   		/* At this point we don't know if the requested value is valid,
;;;1277   		 therefore proceed to update the entire timing budget and
;;;1278   		 if this fails, revert back to the previous value.
;;;1279   		 */
;;;1280   		Status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(Dev,
001c80  e1a01008          MOV      r1,r8
001c84  e1a00005          MOV      r0,r5
001c88  ebfffffe          BL       VL53L0X_SetMeasurementTimingBudgetMicroSeconds
001c8c  e1a04000          MOV      r4,r0
;;;1281   			MeasurementTimingBudgetMicroSeconds);
;;;1282   
;;;1283   		if (Status != VL53L0X_ERROR_NONE) {
001c90  e3540000          CMP      r4,#0
001c94  0a00000b          BEQ      |L1.7368|
;;;1284   			Status1 = set_sequence_step_timeout(Dev, SequenceStepId,
001c98  e1a01009          MOV      r1,r9
001c9c  e1a00005          MOV      r0,r5
001ca0  e59d2000          LDR      r2,[sp,#0]
001ca4  ebfffffe          BL       set_sequence_step_timeout
001ca8  e1a07000          MOV      r7,r0
;;;1285   				OldTimeOutMicroSeconds);
;;;1286   
;;;1287   			if (Status1 == VL53L0X_ERROR_NONE) {
001cac  e3570000          CMP      r7,#0
001cb0  1a000003          BNE      |L1.7364|
;;;1288   				Status1 =
001cb4  e1a01008          MOV      r1,r8
001cb8  e1a00005          MOV      r0,r5
001cbc  ebfffffe          BL       VL53L0X_SetMeasurementTimingBudgetMicroSeconds
001cc0  e1a07000          MOV      r7,r0
                  |L1.7364|
;;;1289   				VL53L0X_SetMeasurementTimingBudgetMicroSeconds(
;;;1290   					Dev,
;;;1291   					MeasurementTimingBudgetMicroSeconds);
;;;1292   			}
;;;1293   
;;;1294   			Status = Status1;
001cc4  e1a04007          MOV      r4,r7
                  |L1.7368|
;;;1295   		}
;;;1296   	}
;;;1297   
;;;1298   	LOG_FUNCTION_END(Status);
;;;1299   
;;;1300   	return Status;
001cc8  e1a00004          MOV      r0,r4
;;;1301   }
001ccc  e8bd8ff8          POP      {r3-r11,pc}
;;;1302   
                          ENDP

                  VL53L0X_SetXTalkCompensationEnable PROC
;;;1392   
;;;1393   VL53L0X_Error VL53L0X_SetXTalkCompensationEnable(VL53L0X_DEV Dev,
001cd0  e92d41f0          PUSH     {r4-r8,lr}
;;;1394   	uint8_t XTalkCompensationEnable)
;;;1395   {
001cd4  e1a04000          MOV      r4,r0
001cd8  e1a05001          MOV      r5,r1
;;;1396   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001cdc  e3a07000          MOV      r7,#0
;;;1397   	FixPoint1616_t TempFix1616;
;;;1398   	uint16_t LinearityCorrectiveGain;
;;;1399   
;;;1400   	LOG_FUNCTION_START("");
;;;1401   
;;;1402   	LinearityCorrectiveGain = PALDevDataGet(Dev, LinearityCorrectiveGain);
001ce0  e59f00d4          LDR      r0,|L1.7612|
001ce4  e19080b4          LDRH     r8,[r0,r4]
;;;1403   
;;;1404   	if ((XTalkCompensationEnable == 0)
001ce8  e3550000          CMP      r5,#0
001cec  0a000001          BEQ      |L1.7416|
;;;1405   		|| (LinearityCorrectiveGain != 1000)) {
001cf0  e3580ffa          CMP      r8,#0x3e8
001cf4  0a000001          BEQ      |L1.7424|
                  |L1.7416|
;;;1406   		TempFix1616 = 0;
001cf8  e3a06000          MOV      r6,#0
001cfc  ea000000          B        |L1.7428|
                  |L1.7424|
;;;1407   	} else {
;;;1408   		VL53L0X_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
001d00  e5946020          LDR      r6,[r4,#0x20]
                  |L1.7428|
;;;1409   			TempFix1616);
;;;1410   	}
;;;1411   
;;;1412   	/* the following register has a format 3.13 */
;;;1413   	Status = VL53L0X_WrWord(Dev,
001d04  e59f00b4          LDR      r0,|L1.7616|
001d08  e00021a6          AND      r2,r0,r6,LSR #3
001d0c  e3a01020          MOV      r1,#0x20
001d10  e1a00004          MOV      r0,r4
001d14  ebfffffe          BL       VL53L0X_WrWord
001d18  e1a07000          MOV      r7,r0
;;;1414   	VL53L0X_REG_CROSSTALK_COMPENSATION_PEAK_RATE_MCPS,
;;;1415   		VL53L0X_FIXPOINT1616TOFIXPOINT313(TempFix1616));
;;;1416   
;;;1417   	if (Status == VL53L0X_ERROR_NONE) {
001d1c  e3570000          CMP      r7,#0
001d20  1a000006          BNE      |L1.7488|
;;;1418   		if (XTalkCompensationEnable == 0) {
001d24  e3550000          CMP      r5,#0
001d28  1a000002          BNE      |L1.7480|
;;;1419   			VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
001d2c  e3a00000          MOV      r0,#0
001d30  e5c4001c          STRB     r0,[r4,#0x1c]
001d34  ea000001          B        |L1.7488|
                  |L1.7480|
;;;1420   				0);
;;;1421   		} else {
;;;1422   			VL53L0X_SETPARAMETERFIELD(Dev, XTalkCompensationEnable,
001d38  e3a00001          MOV      r0,#1
001d3c  e5c4001c          STRB     r0,[r4,#0x1c]
                  |L1.7488|
;;;1423   				1);
;;;1424   		}
;;;1425   	}
;;;1426   
;;;1427   	LOG_FUNCTION_END(Status);
;;;1428   	return Status;
001d40  e1a00007          MOV      r0,r7
;;;1429   }
001d44  e8bd81f0          POP      {r4-r8,pc}
;;;1430   
                          ENDP

                  VL53L0X_GetXTalkCompensationEnable PROC
;;;1431   VL53L0X_Error VL53L0X_GetXTalkCompensationEnable(VL53L0X_DEV Dev,
001d48  e1a02000          MOV      r2,r0
;;;1432   	uint8_t *pXTalkCompensationEnable)
;;;1433   {
;;;1434   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001d4c  e3a00000          MOV      r0,#0
;;;1435   	uint8_t Temp8;
;;;1436   	LOG_FUNCTION_START("");
;;;1437   
;;;1438   	VL53L0X_GETPARAMETERFIELD(Dev, XTalkCompensationEnable, Temp8);
001d50  e5d2301c          LDRB     r3,[r2,#0x1c]
;;;1439   	*pXTalkCompensationEnable = Temp8;
001d54  e5c13000          STRB     r3,[r1,#0]
;;;1440   
;;;1441   	LOG_FUNCTION_END(Status);
;;;1442   	return Status;
;;;1443   }
001d58  e12fff1e          BX       lr
;;;1444   
                          ENDP

                  VL53L0X_SetRefCalibration PROC
;;;1515   
;;;1516   VL53L0X_Error VL53L0X_SetRefCalibration(VL53L0X_DEV Dev, uint8_t VhvSettings,
001d5c  e92d41f0          PUSH     {r4-r8,lr}
;;;1517   	uint8_t PhaseCal)
;;;1518   {
001d60  e1a04000          MOV      r4,r0
001d64  e1a05001          MOV      r5,r1
001d68  e1a06002          MOV      r6,r2
;;;1519   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001d6c  e3a07000          MOV      r7,#0
;;;1520   	LOG_FUNCTION_START("");
;;;1521   
;;;1522   	Status = VL53L0X_set_ref_calibration(Dev, VhvSettings, PhaseCal);
001d70  e1a02006          MOV      r2,r6
001d74  e1a01005          MOV      r1,r5
001d78  e1a00004          MOV      r0,r4
001d7c  ebfffffe          BL       VL53L0X_set_ref_calibration
001d80  e1a07000          MOV      r7,r0
;;;1523   
;;;1524   	LOG_FUNCTION_END(Status);
;;;1525   	return Status;
001d84  e1a00007          MOV      r0,r7
;;;1526   }
001d88  e8bd81f0          POP      {r4-r8,pc}
;;;1527   
                          ENDP

                  VL53L0X_GetRefCalibration PROC
;;;1528   VL53L0X_Error VL53L0X_GetRefCalibration(VL53L0X_DEV Dev, uint8_t *pVhvSettings,
001d8c  e92d41f0          PUSH     {r4-r8,lr}
;;;1529   	uint8_t *pPhaseCal)
;;;1530   {
001d90  e1a04000          MOV      r4,r0
001d94  e1a05001          MOV      r5,r1
001d98  e1a06002          MOV      r6,r2
;;;1531   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001d9c  e3a07000          MOV      r7,#0
;;;1532   	LOG_FUNCTION_START("");
;;;1533   
;;;1534   	Status = VL53L0X_get_ref_calibration(Dev, pVhvSettings, pPhaseCal);
001da0  e1a02006          MOV      r2,r6
001da4  e1a01005          MOV      r1,r5
001da8  e1a00004          MOV      r0,r4
001dac  ebfffffe          BL       VL53L0X_get_ref_calibration
001db0  e1a07000          MOV      r7,r0
;;;1535   
;;;1536   	LOG_FUNCTION_END(Status);
;;;1537   	return Status;
001db4  e1a00007          MOV      r0,r7
;;;1538   }
001db8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7612|
                          DCD      0x00000152
                  |L1.7616|
                          DCD      0x0000ffff
                  |L1.7620|
                          DCD      0x00016b85
                  |L1.7624|
                          DCD      0x000970a4
                          ENDP

                  VL53L0X_GetNumberOfLimitCheck PROC
;;;1543   
;;;1544   VL53L0X_Error VL53L0X_GetNumberOfLimitCheck(uint16_t *pNumberOfLimitCheck)
001dcc  e1a01000          MOV      r1,r0
;;;1545   {
;;;1546   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001dd0  e3a00000          MOV      r0,#0
;;;1547   	LOG_FUNCTION_START("");
;;;1548   
;;;1549   	*pNumberOfLimitCheck = VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS;
001dd4  e3a02006          MOV      r2,#6
001dd8  e1c120b0          STRH     r2,[r1,#0]
;;;1550   
;;;1551   	LOG_FUNCTION_END(Status);
;;;1552   	return Status;
;;;1553   }
001ddc  e12fff1e          BX       lr
;;;1554   
                          ENDP

                  VL53L0X_GetLimitCheckInfo PROC
;;;1555   VL53L0X_Error VL53L0X_GetLimitCheckInfo(VL53L0X_DEV Dev, uint16_t LimitCheckId,
001de0  e92d41f0          PUSH     {r4-r8,lr}
;;;1556   	char *pLimitCheckString)
;;;1557   {
001de4  e1a04000          MOV      r4,r0
001de8  e1a05001          MOV      r5,r1
001dec  e1a06002          MOV      r6,r2
;;;1558   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001df0  e3a07000          MOV      r7,#0
;;;1559   
;;;1560   	LOG_FUNCTION_START("");
;;;1561   
;;;1562   	Status = VL53L0X_get_limit_check_info(Dev, LimitCheckId,
001df4  e1a02006          MOV      r2,r6
001df8  e1a01005          MOV      r1,r5
001dfc  e1a00004          MOV      r0,r4
001e00  ebfffffe          BL       VL53L0X_get_limit_check_info
001e04  e1a07000          MOV      r7,r0
;;;1563   		pLimitCheckString);
;;;1564   
;;;1565   	LOG_FUNCTION_END(Status);
;;;1566   	return Status;
001e08  e1a00007          MOV      r0,r7
;;;1567   }
001e0c  e8bd81f0          POP      {r4-r8,pc}
;;;1568   
                          ENDP

                  VL53L0X_GetLimitCheckStatus PROC
;;;1569   VL53L0X_Error VL53L0X_GetLimitCheckStatus(VL53L0X_DEV Dev, uint16_t LimitCheckId,
001e10  e92d4010          PUSH     {r4,lr}
;;;1570   	uint8_t *pLimitCheckStatus)
;;;1571   {
001e14  e1a03000          MOV      r3,r0
;;;1572   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001e18  e3a00000          MOV      r0,#0
;;;1573   	uint8_t Temp8;
;;;1574   
;;;1575   	LOG_FUNCTION_START("");
;;;1576   
;;;1577   	if (LimitCheckId >= VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS) {
001e1c  e3510006          CMP      r1,#6
001e20  ba000001          BLT      |L1.7724|
;;;1578   		Status = VL53L0X_ERROR_INVALID_PARAMS;
001e24  e3e00003          MVN      r0,#3
001e28  ea000002          B        |L1.7736|
                  |L1.7724|
;;;1579   	} else {
;;;1580   
;;;1581   		VL53L0X_GETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
001e2c  e283402e          ADD      r4,r3,#0x2e
001e30  e7d4c001          LDRB     r12,[r4,r1]
;;;1582   			LimitCheckId, Temp8);
;;;1583   
;;;1584   		*pLimitCheckStatus = Temp8;
001e34  e5c2c000          STRB     r12,[r2,#0]
                  |L1.7736|
;;;1585   
;;;1586   	}
;;;1587   
;;;1588   	LOG_FUNCTION_END(Status);
;;;1589   	return Status;
;;;1590   }
001e38  e8bd8010          POP      {r4,pc}
;;;1591   
                          ENDP

                  VL53L0X_GetLimitCheckCurrent PROC
;;;1883   
;;;1884   VL53L0X_Error VL53L0X_GetLimitCheckCurrent(VL53L0X_DEV Dev, uint16_t LimitCheckId,
001e3c  e92d40f0          PUSH     {r4-r7,lr}
;;;1885   	FixPoint1616_t *pLimitCheckCurrent)
;;;1886   {
001e40  e24dd01c          SUB      sp,sp,#0x1c
001e44  e1a04000          MOV      r4,r0
001e48  e1a06001          MOV      r6,r1
001e4c  e1a05002          MOV      r5,r2
;;;1887   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001e50  e3a07000          MOV      r7,#0
;;;1888   	VL53L0X_RangingMeasurementData_t LastRangeDataBuffer;
;;;1889   
;;;1890   	LOG_FUNCTION_START("");
;;;1891   
;;;1892   	if (LimitCheckId >= VL53L0X_CHECKENABLE_NUMBER_OF_CHECKS) {
001e54  e3560006          CMP      r6,#6
001e58  ba000001          BLT      |L1.7780|
;;;1893   		Status = VL53L0X_ERROR_INVALID_PARAMS;
001e5c  e3e07003          MVN      r7,#3
001e60  ea000034          B        |L1.7992|
                  |L1.7780|
;;;1894   	} else {
;;;1895   		switch (LimitCheckId) {
001e64  e3560006          CMP      r6,#6
001e68  308ff106          ADDCC    pc,pc,r6,LSL #2
001e6c  ea00002d          B        |L1.7976|
001e70  ea000004          B        |L1.7816|
001e74  ea000007          B        |L1.7832|
001e78  ea00000e          B        |L1.7864|
001e7c  ea000011          B        |L1.7880|
001e80  ea000018          B        |L1.7912|
001e84  ea00001f          B        |L1.7944|
                  |L1.7816|
;;;1896   		case VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE:
001e88  e1a00000          MOV      r0,r0
;;;1897   			/* Need to run a ranging to have the latest values */
;;;1898   			*pLimitCheckCurrent = PALDevDataGet(Dev, SigmaEstimate);
001e8c  e5940140          LDR      r0,[r4,#0x140]
001e90  e5850000          STR      r0,[r5,#0]
;;;1899   
;;;1900   			break;
001e94  ea000026          B        |L1.7988|
                  |L1.7832|
;;;1901   
;;;1902   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE:
001e98  e1a00000          MOV      r0,r0
;;;1903   			/* Need to run a ranging to have the latest values */
;;;1904   			LastRangeDataBuffer = PALDevDataGet(Dev,
001e9c  e3a0201c          MOV      r2,#0x1c
001ea0  e2841050          ADD      r1,r4,#0x50
001ea4  e1a0000d          MOV      r0,sp
001ea8  ebfffffe          BL       __aeabi_memcpy4
;;;1905   				LastRangeMeasure);
;;;1906   			*pLimitCheckCurrent =
001eac  e59d000c          LDR      r0,[sp,#0xc]
001eb0  e5850000          STR      r0,[r5,#0]
;;;1907   				LastRangeDataBuffer.SignalRateRtnMegaCps;
;;;1908   
;;;1909   			break;
001eb4  ea00001e          B        |L1.7988|
                  |L1.7864|
;;;1910   
;;;1911   		case VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP:
001eb8  e1a00000          MOV      r0,r0
;;;1912   			/* Need to run a ranging to have the latest values */
;;;1913   			*pLimitCheckCurrent = PALDevDataGet(Dev,
001ebc  e5940148          LDR      r0,[r4,#0x148]
001ec0  e5850000          STR      r0,[r5,#0]
;;;1914   				LastSignalRefMcps);
;;;1915   
;;;1916   			break;
001ec4  ea00001a          B        |L1.7988|
                  |L1.7880|
;;;1917   
;;;1918   		case VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD:
001ec8  e1a00000          MOV      r0,r0
;;;1919   			/* Need to run a ranging to have the latest values */
;;;1920   			LastRangeDataBuffer = PALDevDataGet(Dev,
001ecc  e3a0201c          MOV      r2,#0x1c
001ed0  e2841050          ADD      r1,r4,#0x50
001ed4  e1a0000d          MOV      r0,sp
001ed8  ebfffffe          BL       __aeabi_memcpy4
;;;1921   				LastRangeMeasure);
;;;1922   			*pLimitCheckCurrent =
001edc  e59d000c          LDR      r0,[sp,#0xc]
001ee0  e5850000          STR      r0,[r5,#0]
;;;1923   				LastRangeDataBuffer.SignalRateRtnMegaCps;
;;;1924   
;;;1925   			break;
001ee4  ea000012          B        |L1.7988|
                  |L1.7912|
;;;1926   
;;;1927   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_MSRC:
001ee8  e1a00000          MOV      r0,r0
;;;1928   			/* Need to run a ranging to have the latest values */
;;;1929   			LastRangeDataBuffer = PALDevDataGet(Dev,
001eec  e3a0201c          MOV      r2,#0x1c
001ef0  e2841050          ADD      r1,r4,#0x50
001ef4  e1a0000d          MOV      r0,sp
001ef8  ebfffffe          BL       __aeabi_memcpy4
;;;1930   				LastRangeMeasure);
;;;1931   			*pLimitCheckCurrent =
001efc  e59d000c          LDR      r0,[sp,#0xc]
001f00  e5850000          STR      r0,[r5,#0]
;;;1932   				LastRangeDataBuffer.SignalRateRtnMegaCps;
;;;1933   
;;;1934   			break;
001f04  ea00000a          B        |L1.7988|
                  |L1.7944|
;;;1935   
;;;1936   		case VL53L0X_CHECKENABLE_SIGNAL_RATE_PRE_RANGE:
001f08  e1a00000          MOV      r0,r0
;;;1937   			/* Need to run a ranging to have the latest values */
;;;1938   			LastRangeDataBuffer = PALDevDataGet(Dev,
001f0c  e3a0201c          MOV      r2,#0x1c
001f10  e2841050          ADD      r1,r4,#0x50
001f14  e1a0000d          MOV      r0,sp
001f18  ebfffffe          BL       __aeabi_memcpy4
;;;1939   				LastRangeMeasure);
;;;1940   			*pLimitCheckCurrent =
001f1c  e59d000c          LDR      r0,[sp,#0xc]
001f20  e5850000          STR      r0,[r5,#0]
;;;1941   				LastRangeDataBuffer.SignalRateRtnMegaCps;
;;;1942   
;;;1943   			break;
001f24  ea000002          B        |L1.7988|
                  |L1.7976|
;;;1944   
;;;1945   		default:
001f28  e1a00000          MOV      r0,r0
;;;1946   			Status = VL53L0X_ERROR_INVALID_PARAMS;
001f2c  e3e07003          MVN      r7,#3
001f30  e1a00000          MOV      r0,r0                 ;1895
                  |L1.7988|
001f34  e1a00000          MOV      r0,r0                 ;1900
                  |L1.7992|
;;;1947   		}
;;;1948   	}
;;;1949   
;;;1950   	LOG_FUNCTION_END(Status);
;;;1951   	return Status;
001f38  e1a00007          MOV      r0,r7
001f3c  e28dd01c          ADD      sp,sp,#0x1c
;;;1952   
;;;1953   }
001f40  e8bd80f0          POP      {r4-r7,pc}
;;;1954   
                          ENDP

                  VL53L0X_SetDmaxCalParameters PROC
;;;2014   
;;;2015   VL53L0X_Error VL53L0X_SetDmaxCalParameters(VL53L0X_DEV Dev,
001f44  e92d41f0          PUSH     {r4-r8,lr}
;;;2016   	uint16_t RangeMilliMeter, FixPoint1616_t SignalRateRtnMegaCps)
;;;2017   {
001f48  e1a04000          MOV      r4,r0
001f4c  e1a05001          MOV      r5,r1
001f50  e1a06002          MOV      r6,r2
;;;2018   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001f54  e3a07000          MOV      r7,#0
;;;2019   	FixPoint1616_t SignalRateRtnMegaCpsTemp = 0;
001f58  e3a08000          MOV      r8,#0
;;;2020   
;;;2021   	LOG_FUNCTION_START("");
;;;2022   
;;;2023   	/* Check if one of input parameter is zero, in that case the
;;;2024   	 * value are get from NVM */
;;;2025   	if ((RangeMilliMeter == 0) || (SignalRateRtnMegaCps == 0)) {
001f5c  e3550000          CMP      r5,#0
001f60  0a000001          BEQ      |L1.8044|
001f64  e3560000          CMP      r6,#0
001f68  1a000008          BNE      |L1.8080|
                  |L1.8044|
;;;2026   		/* NVM parameters */
;;;2027   		/* Run VL53L0X_get_info_from_device wit option 4 to get
;;;2028   		 * signal rate at 400 mm if the value have been already
;;;2029   		 * get this function will return with no access to device */
;;;2030   		VL53L0X_get_info_from_device(Dev, 4);
001f6c  e3a01004          MOV      r1,#4
001f70  e1a00004          MOV      r0,r4
001f74  ebfffffe          BL       VL53L0X_get_info_from_device
;;;2031   
;;;2032   		SignalRateRtnMegaCpsTemp = VL53L0X_GETDEVICESPECIFICPARAMETER(
001f78  e5948120          LDR      r8,[r4,#0x120]
;;;2033   			Dev, SignalRateMeasFixed400mm);
;;;2034   
;;;2035   		PALDevDataSet(Dev, DmaxCalRangeMilliMeter, 400);
001f7c  e3a00e19          MOV      r0,#0x190
001f80  e3a01f55          MOV      r1,#0x154
001f84  e18100b4          STRH     r0,[r1,r4]
;;;2036   		PALDevDataSet(Dev, DmaxCalSignalRateRtnMegaCps,
001f88  e5848158          STR      r8,[r4,#0x158]
001f8c  ea000002          B        |L1.8092|
                  |L1.8080|
;;;2037   			SignalRateRtnMegaCpsTemp);
;;;2038   	} else {
;;;2039   		/* User parameters */
;;;2040   		PALDevDataSet(Dev, DmaxCalRangeMilliMeter, RangeMilliMeter);
001f90  e3a00f55          MOV      r0,#0x154
001f94  e18050b4          STRH     r5,[r0,r4]
;;;2041   		PALDevDataSet(Dev, DmaxCalSignalRateRtnMegaCps,
001f98  e5846158          STR      r6,[r4,#0x158]
                  |L1.8092|
;;;2042   			SignalRateRtnMegaCps);
;;;2043   	}
;;;2044   
;;;2045   	LOG_FUNCTION_END(Status);
;;;2046   	return Status;
001f9c  e1a00007          MOV      r0,r7
;;;2047   }
001fa0  e8bd81f0          POP      {r4-r8,pc}
;;;2048   
                          ENDP

                  VL53L0X_GetDmaxCalParameters PROC
;;;2049   VL53L0X_Error VL53L0X_GetDmaxCalParameters(VL53L0X_DEV Dev,
001fa4  e1a03000          MOV      r3,r0
;;;2050   	uint16_t *pRangeMilliMeter, FixPoint1616_t *pSignalRateRtnMegaCps)
;;;2051   {
;;;2052   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001fa8  e3a00000          MOV      r0,#0
;;;2053   
;;;2054   	LOG_FUNCTION_START("");
;;;2055   
;;;2056   	*pRangeMilliMeter = PALDevDataGet(Dev, DmaxCalRangeMilliMeter);
001fac  e3a0cf55          MOV      r12,#0x154
001fb0  e19cc0b3          LDRH     r12,[r12,r3]
001fb4  e1c1c0b0          STRH     r12,[r1,#0]
;;;2057   	*pSignalRateRtnMegaCps = PALDevDataGet(Dev,
001fb8  e593c158          LDR      r12,[r3,#0x158]
001fbc  e582c000          STR      r12,[r2,#0]
;;;2058   		DmaxCalSignalRateRtnMegaCps);
;;;2059   
;;;2060   	LOG_FUNCTION_END(Status);
;;;2061   	return Status;
;;;2062   }
001fc0  e12fff1e          BX       lr
;;;2063   
                          ENDP

                  VL53L0X_GetInterruptThresholds PROC
;;;2805   
;;;2806   VL53L0X_Error VL53L0X_GetInterruptThresholds(VL53L0X_DEV Dev,
001fc4  e92d43f8          PUSH     {r3-r9,lr}
;;;2807   	VL53L0X_DeviceModes DeviceMode, FixPoint1616_t *pThresholdLow,
;;;2808   	FixPoint1616_t *pThresholdHigh)
;;;2809   {
001fc8  e1a07000          MOV      r7,r0
001fcc  e1a08001          MOV      r8,r1
001fd0  e1a04002          MOV      r4,r2
001fd4  e1a05003          MOV      r5,r3
;;;2810   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001fd8  e3a06000          MOV      r6,#0
;;;2811   	uint16_t Threshold16;
;;;2812   	LOG_FUNCTION_START("");
;;;2813   
;;;2814   	/* no dependency on DeviceMode for Ewok */
;;;2815   
;;;2816   	Status = VL53L0X_RdWord(Dev, VL53L0X_REG_SYSTEM_THRESH_LOW, &Threshold16);
001fdc  e1a0200d          MOV      r2,sp
001fe0  e3a0100e          MOV      r1,#0xe
001fe4  e1a00007          MOV      r0,r7
001fe8  ebfffffe          BL       VL53L0X_RdWord
001fec  e1a06000          MOV      r6,r0
;;;2817   	/* Need to multiply by 2 because the FW will apply a x2 */
;;;2818   	*pThresholdLow = (FixPoint1616_t)((0x00fff & Threshold16) << 17);
001ff0  e1dd00b0          LDRH     r0,[sp,#0]
001ff4  e3c00a0f          BIC      r0,r0,#0xf000
001ff8  e1a00880          LSL      r0,r0,#17
001ffc  e5840000          STR      r0,[r4,#0]
;;;2819   
;;;2820   	if (Status == VL53L0X_ERROR_NONE) {
002000  e3560000          CMP      r6,#0
002004  1a000008          BNE      |L1.8236|
;;;2821   		Status = VL53L0X_RdWord(Dev, VL53L0X_REG_SYSTEM_THRESH_HIGH,
002008  e1a0200d          MOV      r2,sp
00200c  e3a0100c          MOV      r1,#0xc
002010  e1a00007          MOV      r0,r7
002014  ebfffffe          BL       VL53L0X_RdWord
002018  e1a06000          MOV      r6,r0
;;;2822   			&Threshold16);
;;;2823   		/* Need to multiply by 2 because the FW will apply a x2 */
;;;2824   		*pThresholdHigh =
00201c  e1dd00b0          LDRH     r0,[sp,#0]
002020  e3c00a0f          BIC      r0,r0,#0xf000
002024  e1a00880          LSL      r0,r0,#17
002028  e5850000          STR      r0,[r5,#0]
                  |L1.8236|
;;;2825   			(FixPoint1616_t)((0x00fff & Threshold16) << 17);
;;;2826   	}
;;;2827   
;;;2828   	LOG_FUNCTION_END(Status);
;;;2829   	return Status;
00202c  e1a00006          MOV      r0,r6
;;;2830   }
002030  e8bd83f8          POP      {r3-r9,pc}
;;;2831   
                          ENDP

                  VL53L0X_CheckAndLoadInterruptSettings PROC
;;;2162   
;;;2163   VL53L0X_Error VL53L0X_CheckAndLoadInterruptSettings(VL53L0X_DEV Dev,
002034  e92d41fc          PUSH     {r2-r8,lr}
;;;2164   	uint8_t StartNotStopFlag)
;;;2165   {
002038  e1a06000          MOV      r6,r0
00203c  e1a07001          MOV      r7,r1
;;;2166   	uint8_t InterruptConfig;
;;;2167   	FixPoint1616_t ThresholdLow;
;;;2168   	FixPoint1616_t ThresholdHigh;
;;;2169   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002040  e3a04000          MOV      r4,#0
;;;2170   
;;;2171   	InterruptConfig = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
002044  e5d650da          LDRB     r5,[r6,#0xda]
;;;2172   		Pin0GpioFunctionality);
;;;2173   
;;;2174   	if ((InterruptConfig ==
002048  e3550001          CMP      r5,#1
00204c  0a000003          BEQ      |L1.8288|
;;;2175   		VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW) ||
;;;2176   		(InterruptConfig ==
002050  e3550002          CMP      r5,#2
002054  0a000001          BEQ      |L1.8288|
;;;2177   		VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH) ||
;;;2178   		(InterruptConfig ==
002058  e3550003          CMP      r5,#3
00205c  1a000028          BNE      |L1.8452|
                  |L1.8288|
;;;2179   		VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT)) {
;;;2180   
;;;2181   		Status = VL53L0X_GetInterruptThresholds(Dev,
002060  e1a0300d          MOV      r3,sp
002064  e28d2004          ADD      r2,sp,#4
002068  e3a01001          MOV      r1,#1
00206c  e1a00006          MOV      r0,r6
002070  ebfffffe          BL       VL53L0X_GetInterruptThresholds
002074  e1a04000          MOV      r4,r0
;;;2182   			VL53L0X_DEVICEMODE_CONTINUOUS_RANGING,
;;;2183   			&ThresholdLow, &ThresholdHigh);
;;;2184   
;;;2185   		if (((ThresholdLow > 255*65536) ||
002078  e59d0004          LDR      r0,[sp,#4]
00207c  e35008ff          CMP      r0,#0xff0000
002080  8a000002          BHI      |L1.8336|
;;;2186   			(ThresholdHigh > 255*65536)) &&
002084  e59d0000          LDR      r0,[sp,#0]
002088  e35008ff          CMP      r0,#0xff0000
00208c  9a00001c          BLS      |L1.8452|
                  |L1.8336|
;;;2187   			(Status == VL53L0X_ERROR_NONE)) {
002090  e3540000          CMP      r4,#0
002094  1a00001a          BNE      |L1.8452|
;;;2188   
;;;2189   			if (StartNotStopFlag != 0) {
002098  e3570000          CMP      r7,#0
00209c  0a000004          BEQ      |L1.8372|
;;;2190   				Status = VL53L0X_load_tuning_settings(Dev,
0020a0  e59f1c8c          LDR      r1,|L1.11572|
0020a4  e1a00006          MOV      r0,r6
0020a8  ebfffffe          BL       VL53L0X_load_tuning_settings
0020ac  e1a04000          MOV      r4,r0
0020b0  ea000013          B        |L1.8452|
                  |L1.8372|
;;;2191   					InterruptThresholdSettings);
;;;2192   			} else {
;;;2193   				Status |= VL53L0X_WrByte(Dev, 0xFF, 0x04);
0020b4  e3a02004          MOV      r2,#4
0020b8  e3a010ff          MOV      r1,#0xff
0020bc  e1a00006          MOV      r0,r6
0020c0  ebfffffe          BL       VL53L0X_WrByte
0020c4  e1844000          ORR      r4,r4,r0
;;;2194   				Status |= VL53L0X_WrByte(Dev, 0x70, 0x00);
0020c8  e3a02000          MOV      r2,#0
0020cc  e3a01070          MOV      r1,#0x70
0020d0  e1a00006          MOV      r0,r6
0020d4  ebfffffe          BL       VL53L0X_WrByte
0020d8  e1844000          ORR      r4,r4,r0
;;;2195   				Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
0020dc  e3a02000          MOV      r2,#0
0020e0  e3a010ff          MOV      r1,#0xff
0020e4  e1a00006          MOV      r0,r6
0020e8  ebfffffe          BL       VL53L0X_WrByte
0020ec  e1844000          ORR      r4,r4,r0
;;;2196   				Status |= VL53L0X_WrByte(Dev, 0x80, 0x00);
0020f0  e3a02000          MOV      r2,#0
0020f4  e3a01080          MOV      r1,#0x80
0020f8  e1a00006          MOV      r0,r6
0020fc  ebfffffe          BL       VL53L0X_WrByte
002100  e1844000          ORR      r4,r4,r0
                  |L1.8452|
;;;2197   			}
;;;2198   
;;;2199   		}
;;;2200   
;;;2201   
;;;2202   	}
;;;2203   
;;;2204   	return Status;
002104  e1a00004          MOV      r0,r4
;;;2205   
;;;2206   }
002108  e8bd81fc          POP      {r2-r8,pc}
;;;2207   
                          ENDP

                  VL53L0X_StartMeasurement PROC
;;;2208   
;;;2209   VL53L0X_Error VL53L0X_StartMeasurement(VL53L0X_DEV Dev)
00210c  e92d41fc          PUSH     {r2-r8,lr}
;;;2210   {
002110  e1a06000          MOV      r6,r0
;;;2211   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002114  e3a04000          MOV      r4,#0
;;;2212   	VL53L0X_DeviceModes DeviceMode;
;;;2213   	uint8_t Byte;
;;;2214   	uint8_t StartStopByte = VL53L0X_REG_SYSRANGE_MODE_START_STOP;
002118  e3a07001          MOV      r7,#1
;;;2215   	uint32_t LoopNb;
;;;2216   	LOG_FUNCTION_START("");
;;;2217   
;;;2218   	/* Get Current DeviceMode */
;;;2219   	VL53L0X_GetDeviceMode(Dev, &DeviceMode);
00211c  e28d1004          ADD      r1,sp,#4
002120  e1a00006          MOV      r0,r6
002124  ebfffffe          BL       VL53L0X_GetDeviceMode
;;;2220   
;;;2221   	Status = VL53L0X_WrByte(Dev, 0x80, 0x01);
002128  e3a02001          MOV      r2,#1
00212c  e3a01080          MOV      r1,#0x80
002130  e1a00006          MOV      r0,r6
002134  ebfffffe          BL       VL53L0X_WrByte
002138  e1a04000          MOV      r4,r0
;;;2222   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
00213c  e3a02001          MOV      r2,#1
002140  e3a010ff          MOV      r1,#0xff
002144  e1a00006          MOV      r0,r6
002148  ebfffffe          BL       VL53L0X_WrByte
00214c  e1a04000          MOV      r4,r0
;;;2223   	Status = VL53L0X_WrByte(Dev, 0x00, 0x00);
002150  e3a02000          MOV      r2,#0
002154  e1a01002          MOV      r1,r2
002158  e1a00006          MOV      r0,r6
00215c  ebfffffe          BL       VL53L0X_WrByte
002160  e1a04000          MOV      r4,r0
;;;2224   	Status = VL53L0X_WrByte(Dev, 0x91, PALDevDataGet(Dev, StopVariable));
002164  e5d6213a          LDRB     r2,[r6,#0x13a]
002168  e3a01091          MOV      r1,#0x91
00216c  e1a00006          MOV      r0,r6
002170  ebfffffe          BL       VL53L0X_WrByte
002174  e1a04000          MOV      r4,r0
;;;2225   	Status = VL53L0X_WrByte(Dev, 0x00, 0x01);
002178  e3a02001          MOV      r2,#1
00217c  e3a01000          MOV      r1,#0
002180  e1a00006          MOV      r0,r6
002184  ebfffffe          BL       VL53L0X_WrByte
002188  e1a04000          MOV      r4,r0
;;;2226   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
00218c  e3a02000          MOV      r2,#0
002190  e3a010ff          MOV      r1,#0xff
002194  e1a00006          MOV      r0,r6
002198  ebfffffe          BL       VL53L0X_WrByte
00219c  e1a04000          MOV      r4,r0
;;;2227   	Status = VL53L0X_WrByte(Dev, 0x80, 0x00);
0021a0  e3a02000          MOV      r2,#0
0021a4  e3a01080          MOV      r1,#0x80
0021a8  e1a00006          MOV      r0,r6
0021ac  ebfffffe          BL       VL53L0X_WrByte
0021b0  e1a04000          MOV      r4,r0
;;;2228   
;;;2229   	switch (DeviceMode) {
0021b4  e5dd0004          LDRB     r0,[sp,#4]
0021b8  e3500000          CMP      r0,#0
0021bc  0a000004          BEQ      |L1.8660|
0021c0  e3500001          CMP      r0,#1
0021c4  0a000021          BEQ      |L1.8784|
0021c8  e3500003          CMP      r0,#3
0021cc  1a000041          BNE      |L1.8920|
0021d0  ea00002f          B        |L1.8852|
                  |L1.8660|
;;;2230   	case VL53L0X_DEVICEMODE_SINGLE_RANGING:
0021d4  e1a00000          MOV      r0,r0
;;;2231   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSRANGE_START, 0x01);
0021d8  e3a02001          MOV      r2,#1
0021dc  e3a01000          MOV      r1,#0
0021e0  e1a00006          MOV      r0,r6
0021e4  ebfffffe          BL       VL53L0X_WrByte
0021e8  e1a04000          MOV      r4,r0
;;;2232   
;;;2233   		Byte = StartStopByte;
0021ec  e58d7000          STR      r7,[sp,#0]
;;;2234   		if (Status == VL53L0X_ERROR_NONE) {
0021f0  e3540000          CMP      r4,#0
0021f4  1a000014          BNE      |L1.8780|
;;;2235   			/* Wait until start bit has been cleared */
;;;2236   			LoopNb = 0;
0021f8  e3a05000          MOV      r5,#0
;;;2237   			do {
0021fc  e1a00000          MOV      r0,r0
                  |L1.8704|
;;;2238   				if (LoopNb > 0)
002200  e3550000          CMP      r5,#0
002204  0a000004          BEQ      |L1.8732|
;;;2239   					Status = VL53L0X_RdByte(Dev,
002208  e1a0200d          MOV      r2,sp
00220c  e3a01000          MOV      r1,#0
002210  e1a00006          MOV      r0,r6
002214  ebfffffe          BL       VL53L0X_RdByte
002218  e1a04000          MOV      r4,r0
                  |L1.8732|
;;;2240   					VL53L0X_REG_SYSRANGE_START, &Byte);
;;;2241   				LoopNb = LoopNb + 1;
00221c  e2855001          ADD      r5,r5,#1
;;;2242   			} while (((Byte & StartStopByte) == StartStopByte)
002220  e5dd0000          LDRB     r0,[sp,#0]
002224  e0000007          AND      r0,r0,r7
002228  e1500007          CMP      r0,r7
00222c  1a000003          BNE      |L1.8768|
;;;2243   				&& (Status == VL53L0X_ERROR_NONE)
002230  e3540000          CMP      r4,#0
002234  1a000001          BNE      |L1.8768|
;;;2244   				&& (LoopNb < VL53L0X_DEFAULT_MAX_LOOP));
002238  e3550019          CMP      r5,#0x19
00223c  3affffef          BCC      |L1.8704|
                  |L1.8768|
;;;2245   
;;;2246   			if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP)
002240  e3550019          CMP      r5,#0x19
002244  3a000000          BCC      |L1.8780|
;;;2247   				Status = VL53L0X_ERROR_TIME_OUT;
002248  e3e04006          MVN      r4,#6
                  |L1.8780|
;;;2248   
;;;2249   		}
;;;2250   
;;;2251   		break;
00224c  ea000024          B        |L1.8932|
                  |L1.8784|
;;;2252   	case VL53L0X_DEVICEMODE_CONTINUOUS_RANGING:
002250  e1a00000          MOV      r0,r0
;;;2253   		/* Back-to-back mode */
;;;2254   
;;;2255   		/* Check if need to apply interrupt settings */
;;;2256   		if (Status == VL53L0X_ERROR_NONE)
002254  e3540000          CMP      r4,#0
002258  1a000003          BNE      |L1.8812|
;;;2257   			Status = VL53L0X_CheckAndLoadInterruptSettings(Dev, 1);
00225c  e3a01001          MOV      r1,#1
002260  e1a00006          MOV      r0,r6
002264  ebfffffe          BL       VL53L0X_CheckAndLoadInterruptSettings
002268  e1a04000          MOV      r4,r0
                  |L1.8812|
;;;2258   
;;;2259   		Status = VL53L0X_WrByte(Dev,
00226c  e3a02002          MOV      r2,#2
002270  e3a01000          MOV      r1,#0
002274  e1a00006          MOV      r0,r6
002278  ebfffffe          BL       VL53L0X_WrByte
00227c  e1a04000          MOV      r4,r0
;;;2260   		VL53L0X_REG_SYSRANGE_START,
;;;2261   		VL53L0X_REG_SYSRANGE_MODE_BACKTOBACK);
;;;2262   		if (Status == VL53L0X_ERROR_NONE) {
002280  e3540000          CMP      r4,#0
002284  1a000001          BNE      |L1.8848|
;;;2263   			/* Set PAL State to Running */
;;;2264   			PALDevDataSet(Dev, PalState, VL53L0X_STATE_RUNNING);
002288  e3a00004          MOV      r0,#4
00228c  e5c60132          STRB     r0,[r6,#0x132]
                  |L1.8848|
;;;2265   		}
;;;2266   		break;
002290  ea000013          B        |L1.8932|
                  |L1.8852|
;;;2267   	case VL53L0X_DEVICEMODE_CONTINUOUS_TIMED_RANGING:
002294  e1a00000          MOV      r0,r0
;;;2268   		/* Continuous mode */
;;;2269   		/* Check if need to apply interrupt settings */
;;;2270   		if (Status == VL53L0X_ERROR_NONE)
002298  e3540000          CMP      r4,#0
00229c  1a000003          BNE      |L1.8880|
;;;2271   			Status = VL53L0X_CheckAndLoadInterruptSettings(Dev, 1);
0022a0  e3a01001          MOV      r1,#1
0022a4  e1a00006          MOV      r0,r6
0022a8  ebfffffe          BL       VL53L0X_CheckAndLoadInterruptSettings
0022ac  e1a04000          MOV      r4,r0
                  |L1.8880|
;;;2272   
;;;2273   		Status = VL53L0X_WrByte(Dev,
0022b0  e3a02004          MOV      r2,#4
0022b4  e3a01000          MOV      r1,#0
0022b8  e1a00006          MOV      r0,r6
0022bc  ebfffffe          BL       VL53L0X_WrByte
0022c0  e1a04000          MOV      r4,r0
;;;2274   		VL53L0X_REG_SYSRANGE_START,
;;;2275   		VL53L0X_REG_SYSRANGE_MODE_TIMED);
;;;2276   
;;;2277   		if (Status == VL53L0X_ERROR_NONE) {
0022c4  e3540000          CMP      r4,#0
0022c8  1a000001          BNE      |L1.8916|
;;;2278   			/* Set PAL State to Running */
;;;2279   			PALDevDataSet(Dev, PalState, VL53L0X_STATE_RUNNING);
0022cc  e3a00004          MOV      r0,#4
0022d0  e5c60132          STRB     r0,[r6,#0x132]
                  |L1.8916|
;;;2280   		}
;;;2281   		break;
0022d4  ea000002          B        |L1.8932|
                  |L1.8920|
;;;2282   	default:
0022d8  e1a00000          MOV      r0,r0
;;;2283   		/* Selected mode not supported */
;;;2284   		Status = VL53L0X_ERROR_MODE_NOT_SUPPORTED;
0022dc  e3e04007          MVN      r4,#7
0022e0  e1a00000          MOV      r0,r0                 ;2229
                  |L1.8932|
0022e4  e1a00000          MOV      r0,r0                 ;2251
;;;2285   	}
;;;2286   
;;;2287   
;;;2288   	LOG_FUNCTION_END(Status);
;;;2289   	return Status;
0022e8  e1a00004          MOV      r0,r4
;;;2290   }
0022ec  e8bd81fc          POP      {r2-r8,pc}
;;;2291   
                          ENDP

                  VL53L0X_PerformSingleMeasurement PROC
;;;2066   /* Group PAL Measurement Functions */
;;;2067   VL53L0X_Error VL53L0X_PerformSingleMeasurement(VL53L0X_DEV Dev)
0022f0  e92d4038          PUSH     {r3-r5,lr}
;;;2068   {
0022f4  e1a05000          MOV      r5,r0
;;;2069   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0022f8  e3a04000          MOV      r4,#0
;;;2070   	VL53L0X_DeviceModes DeviceMode;
;;;2071   
;;;2072   	LOG_FUNCTION_START("");
;;;2073   
;;;2074   	/* Get Current DeviceMode */
;;;2075   	Status = VL53L0X_GetDeviceMode(Dev, &DeviceMode);
0022fc  e1a0100d          MOV      r1,sp
002300  e1a00005          MOV      r0,r5
002304  ebfffffe          BL       VL53L0X_GetDeviceMode
002308  e1a04000          MOV      r4,r0
;;;2076   
;;;2077   	/* Start immediately to run a single ranging measurement in case of
;;;2078   	 * single ranging or single histogram */
;;;2079   	if (Status == VL53L0X_ERROR_NONE
00230c  e3540000          CMP      r4,#0
002310  1a000005          BNE      |L1.9004|
;;;2080   		&& DeviceMode == VL53L0X_DEVICEMODE_SINGLE_RANGING)
002314  e5dd0000          LDRB     r0,[sp,#0]
002318  e3500000          CMP      r0,#0
00231c  1a000002          BNE      |L1.9004|
;;;2081   		Status = VL53L0X_StartMeasurement(Dev);
002320  e1a00005          MOV      r0,r5
002324  ebfffffe          BL       VL53L0X_StartMeasurement
002328  e1a04000          MOV      r4,r0
                  |L1.9004|
;;;2082   
;;;2083   
;;;2084   	if (Status == VL53L0X_ERROR_NONE)
00232c  e3540000          CMP      r4,#0
002330  1a000002          BNE      |L1.9024|
;;;2085   		Status = VL53L0X_measurement_poll_for_completion(Dev);
002334  e1a00005          MOV      r0,r5
002338  ebfffffe          BL       VL53L0X_measurement_poll_for_completion
00233c  e1a04000          MOV      r4,r0
                  |L1.9024|
;;;2086   
;;;2087   
;;;2088   	/* Change PAL State in case of single ranging or single histogram */
;;;2089   	if (Status == VL53L0X_ERROR_NONE
002340  e3540000          CMP      r4,#0
002344  1a000004          BNE      |L1.9052|
;;;2090   		&& DeviceMode == VL53L0X_DEVICEMODE_SINGLE_RANGING)
002348  e5dd0000          LDRB     r0,[sp,#0]
00234c  e3500000          CMP      r0,#0
002350  1a000001          BNE      |L1.9052|
;;;2091   		PALDevDataSet(Dev, PalState, VL53L0X_STATE_IDLE);
002354  e3a00003          MOV      r0,#3
002358  e5c50132          STRB     r0,[r5,#0x132]
                  |L1.9052|
;;;2092   
;;;2093   
;;;2094   	LOG_FUNCTION_END(Status);
;;;2095   	return Status;
00235c  e1a00004          MOV      r0,r4
;;;2096   }
002360  e8bd8038          POP      {r3-r5,pc}
;;;2097   
                          ENDP

                  VL53L0X_PerformSingleHistogramMeasurement PROC
;;;2098   VL53L0X_Error VL53L0X_PerformSingleHistogramMeasurement(VL53L0X_DEV Dev,
002364  e1a02000          MOV      r2,r0
;;;2099   	VL53L0X_HistogramMeasurementData_t *pHistogramMeasurementData)
;;;2100   {
;;;2101   	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
002368  e3e00062          MVN      r0,#0x62
;;;2102   	LOG_FUNCTION_START("");
;;;2103   
;;;2104   	/* not implemented on VL53L0X */
;;;2105   
;;;2106   	LOG_FUNCTION_END(Status);
;;;2107   	return Status;
;;;2108   }
00236c  e12fff1e          BX       lr
;;;2109   
                          ENDP

                  VL53L0X_PerformRefCalibration PROC
;;;2110   VL53L0X_Error VL53L0X_PerformRefCalibration(VL53L0X_DEV Dev, uint8_t *pVhvSettings,
002370  e92d41f0          PUSH     {r4-r8,lr}
;;;2111   	uint8_t *pPhaseCal)
;;;2112   {
002374  e1a04000          MOV      r4,r0
002378  e1a05001          MOV      r5,r1
00237c  e1a06002          MOV      r6,r2
;;;2113   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002380  e3a07000          MOV      r7,#0
;;;2114   	LOG_FUNCTION_START("");
;;;2115   
;;;2116   	Status = VL53L0X_perform_ref_calibration(Dev, pVhvSettings,
002384  e3a03001          MOV      r3,#1
002388  e1a02006          MOV      r2,r6
00238c  e1a01005          MOV      r1,r5
002390  e1a00004          MOV      r0,r4
002394  ebfffffe          BL       VL53L0X_perform_ref_calibration
002398  e1a07000          MOV      r7,r0
;;;2117   		pPhaseCal, 1);
;;;2118   
;;;2119   	LOG_FUNCTION_END(Status);
;;;2120   	return Status;
00239c  e1a00007          MOV      r0,r7
;;;2121   }
0023a0  e8bd81f0          POP      {r4-r8,pc}
;;;2122   
                          ENDP

                  VL53L0X_PerformXTalkMeasurement PROC
;;;2123   VL53L0X_Error VL53L0X_PerformXTalkMeasurement(VL53L0X_DEV Dev,
0023a4  e92d4010          PUSH     {r4,lr}
;;;2124   	uint32_t TimeoutMs, FixPoint1616_t *pXtalkPerSpad,
;;;2125   	uint8_t *pAmbientTooHigh)
;;;2126   {
0023a8  e1a0c000          MOV      r12,r0
;;;2127   	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
0023ac  e3e00062          MVN      r0,#0x62
;;;2128   	LOG_FUNCTION_START("");
;;;2129   
;;;2130   	/* not implemented on VL53L0X */
;;;2131   
;;;2132   	LOG_FUNCTION_END(Status);
;;;2133   	return Status;
;;;2134   }
0023b0  e8bd8010          POP      {r4,pc}
;;;2135   
                          ENDP

                  VL53L0X_PerformXTalkCalibration PROC
;;;2136   VL53L0X_Error VL53L0X_PerformXTalkCalibration(VL53L0X_DEV Dev,
0023b4  e92d41f0          PUSH     {r4-r8,lr}
;;;2137   	FixPoint1616_t XTalkCalDistance,
;;;2138   	FixPoint1616_t *pXTalkCompensationRateMegaCps)
;;;2139   {
0023b8  e1a04000          MOV      r4,r0
0023bc  e1a05001          MOV      r5,r1
0023c0  e1a06002          MOV      r6,r2
;;;2140   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0023c4  e3a07000          MOV      r7,#0
;;;2141   	LOG_FUNCTION_START("");
;;;2142   
;;;2143   	Status = VL53L0X_perform_xtalk_calibration(Dev, XTalkCalDistance,
0023c8  e1a02006          MOV      r2,r6
0023cc  e1a01005          MOV      r1,r5
0023d0  e1a00004          MOV      r0,r4
0023d4  ebfffffe          BL       VL53L0X_perform_xtalk_calibration
0023d8  e1a07000          MOV      r7,r0
;;;2144   		pXTalkCompensationRateMegaCps);
;;;2145   
;;;2146   	LOG_FUNCTION_END(Status);
;;;2147   	return Status;
0023dc  e1a00007          MOV      r0,r7
;;;2148   }
0023e0  e8bd81f0          POP      {r4-r8,pc}
;;;2149   
                          ENDP

                  VL53L0X_PerformOffsetCalibration PROC
;;;2150   VL53L0X_Error VL53L0X_PerformOffsetCalibration(VL53L0X_DEV Dev,
0023e4  e92d41f0          PUSH     {r4-r8,lr}
;;;2151   	FixPoint1616_t CalDistanceMilliMeter, int32_t *pOffsetMicroMeter)
;;;2152   {
0023e8  e1a04000          MOV      r4,r0
0023ec  e1a05001          MOV      r5,r1
0023f0  e1a06002          MOV      r6,r2
;;;2153   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0023f4  e3a07000          MOV      r7,#0
;;;2154   	LOG_FUNCTION_START("");
;;;2155   
;;;2156   	Status = VL53L0X_perform_offset_calibration(Dev, CalDistanceMilliMeter,
0023f8  e1a02006          MOV      r2,r6
0023fc  e1a01005          MOV      r1,r5
002400  e1a00004          MOV      r0,r4
002404  ebfffffe          BL       VL53L0X_perform_offset_calibration
002408  e1a07000          MOV      r7,r0
;;;2157   		pOffsetMicroMeter);
;;;2158   
;;;2159   	LOG_FUNCTION_END(Status);
;;;2160   	return Status;
00240c  e1a00007          MOV      r0,r7
;;;2161   }
002410  e8bd81f0          POP      {r4-r8,pc}
;;;2162   
                          ENDP

                  VL53L0X_StopMeasurement PROC
;;;2291   
;;;2292   VL53L0X_Error VL53L0X_StopMeasurement(VL53L0X_DEV Dev)
002414  e92d4070          PUSH     {r4-r6,lr}
;;;2293   {
002418  e1a05000          MOV      r5,r0
;;;2294   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00241c  e3a04000          MOV      r4,#0
;;;2295   	LOG_FUNCTION_START("");
;;;2296   
;;;2297   	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSRANGE_START,
002420  e3a02000          MOV      r2,#0
002424  e1a01002          MOV      r1,r2
002428  e1a00005          MOV      r0,r5
00242c  ebfffffe          BL       VL53L0X_WrByte
002430  e1a04000          MOV      r4,r0
;;;2298   	VL53L0X_REG_SYSRANGE_MODE_SINGLESHOT);
;;;2299   
;;;2300   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002434  e3a02001          MOV      r2,#1
002438  e3a010ff          MOV      r1,#0xff
00243c  e1a00005          MOV      r0,r5
002440  ebfffffe          BL       VL53L0X_WrByte
002444  e1a04000          MOV      r4,r0
;;;2301   	Status = VL53L0X_WrByte(Dev, 0x00, 0x00);
002448  e3a02000          MOV      r2,#0
00244c  e1a01002          MOV      r1,r2
002450  e1a00005          MOV      r0,r5
002454  ebfffffe          BL       VL53L0X_WrByte
002458  e1a04000          MOV      r4,r0
;;;2302   	Status = VL53L0X_WrByte(Dev, 0x91, 0x00);
00245c  e3a02000          MOV      r2,#0
002460  e3a01091          MOV      r1,#0x91
002464  e1a00005          MOV      r0,r5
002468  ebfffffe          BL       VL53L0X_WrByte
00246c  e1a04000          MOV      r4,r0
;;;2303   	Status = VL53L0X_WrByte(Dev, 0x00, 0x01);
002470  e3a02001          MOV      r2,#1
002474  e3a01000          MOV      r1,#0
002478  e1a00005          MOV      r0,r5
00247c  ebfffffe          BL       VL53L0X_WrByte
002480  e1a04000          MOV      r4,r0
;;;2304   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
002484  e3a02000          MOV      r2,#0
002488  e3a010ff          MOV      r1,#0xff
00248c  e1a00005          MOV      r0,r5
002490  ebfffffe          BL       VL53L0X_WrByte
002494  e1a04000          MOV      r4,r0
;;;2305   
;;;2306   	if (Status == VL53L0X_ERROR_NONE) {
002498  e3540000          CMP      r4,#0
00249c  1a000001          BNE      |L1.9384|
;;;2307   		/* Set PAL State to Idle */
;;;2308   		PALDevDataSet(Dev, PalState, VL53L0X_STATE_IDLE);
0024a0  e3a00003          MOV      r0,#3
0024a4  e5c50132          STRB     r0,[r5,#0x132]
                  |L1.9384|
;;;2309   	}
;;;2310   
;;;2311   	/* Check if need to apply interrupt settings */
;;;2312   	if (Status == VL53L0X_ERROR_NONE)
0024a8  e3540000          CMP      r4,#0
0024ac  1a000003          BNE      |L1.9408|
;;;2313   		Status = VL53L0X_CheckAndLoadInterruptSettings(Dev, 0);
0024b0  e3a01000          MOV      r1,#0
0024b4  e1a00005          MOV      r0,r5
0024b8  ebfffffe          BL       VL53L0X_CheckAndLoadInterruptSettings
0024bc  e1a04000          MOV      r4,r0
                  |L1.9408|
;;;2314   
;;;2315   	LOG_FUNCTION_END(Status);
;;;2316   	return Status;
0024c0  e1a00004          MOV      r0,r4
;;;2317   }
0024c4  e8bd8070          POP      {r4-r6,pc}
;;;2318   
                          ENDP

                  VL53L0X_GetInterruptMaskStatus PROC
;;;2893   
;;;2894   VL53L0X_Error VL53L0X_GetInterruptMaskStatus(VL53L0X_DEV Dev,
0024c8  e92d40f8          PUSH     {r3-r7,lr}
;;;2895   	uint32_t *pInterruptMaskStatus)
;;;2896   {
0024cc  e1a05000          MOV      r5,r0
0024d0  e1a04001          MOV      r4,r1
;;;2897   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0024d4  e3a06000          MOV      r6,#0
;;;2898   	uint8_t Byte;
;;;2899   	LOG_FUNCTION_START("");
;;;2900   
;;;2901   	Status = VL53L0X_RdByte(Dev, VL53L0X_REG_RESULT_INTERRUPT_STATUS, &Byte);
0024d8  e1a0200d          MOV      r2,sp
0024dc  e3a01013          MOV      r1,#0x13
0024e0  e1a00005          MOV      r0,r5
0024e4  ebfffffe          BL       VL53L0X_RdByte
0024e8  e1a06000          MOV      r6,r0
;;;2902   	*pInterruptMaskStatus = Byte & 0x07;
0024ec  e5dd0000          LDRB     r0,[sp,#0]
0024f0  e2000007          AND      r0,r0,#7
0024f4  e5840000          STR      r0,[r4,#0]
;;;2903   
;;;2904   	if (Byte & 0x18)
0024f8  e5dd0000          LDRB     r0,[sp,#0]
0024fc  e3100018          TST      r0,#0x18
002500  0a000000          BEQ      |L1.9480|
;;;2905   		Status = VL53L0X_ERROR_RANGE_ERROR;
002504  e3e06005          MVN      r6,#5
                  |L1.9480|
;;;2906   
;;;2907   	LOG_FUNCTION_END(Status);
;;;2908   	return Status;
002508  e1a00006          MOV      r0,r6
;;;2909   }
00250c  e8bd80f8          POP      {r3-r7,pc}
;;;2910   
                          ENDP

                  VL53L0X_GetMeasurementDataReady PROC
;;;2318   
;;;2319   VL53L0X_Error VL53L0X_GetMeasurementDataReady(VL53L0X_DEV Dev,
002510  e92d41fc          PUSH     {r2-r8,lr}
;;;2320   	uint8_t *pMeasurementDataReady)
;;;2321   {
002514  e1a05000          MOV      r5,r0
002518  e1a04001          MOV      r4,r1
;;;2322   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00251c  e3a06000          MOV      r6,#0
;;;2323   	uint8_t SysRangeStatusRegister;
;;;2324   	uint8_t InterruptConfig;
;;;2325   	uint32_t InterruptMask;
;;;2326   	LOG_FUNCTION_START("");
;;;2327   
;;;2328   	InterruptConfig = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
002520  e5d570da          LDRB     r7,[r5,#0xda]
;;;2329   		Pin0GpioFunctionality);
;;;2330   
;;;2331   	if (InterruptConfig ==
002524  e3570004          CMP      r7,#4
002528  1a00000c          BNE      |L1.9568|
;;;2332   		VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY) {
;;;2333   		Status = VL53L0X_GetInterruptMaskStatus(Dev, &InterruptMask);
00252c  e1a0100d          MOV      r1,sp
002530  e1a00005          MOV      r0,r5
002534  ebfffffe          BL       VL53L0X_GetInterruptMaskStatus
002538  e1a06000          MOV      r6,r0
;;;2334   		if (InterruptMask ==
00253c  e59d0000          LDR      r0,[sp,#0]
002540  e3500004          CMP      r0,#4
002544  1a000002          BNE      |L1.9556|
;;;2335   		VL53L0X_REG_SYSTEM_INTERRUPT_GPIO_NEW_SAMPLE_READY)
;;;2336   			*pMeasurementDataReady = 1;
002548  e3a00001          MOV      r0,#1
00254c  e5c40000          STRB     r0,[r4,#0]
002550  ea000011          B        |L1.9628|
                  |L1.9556|
;;;2337   		else
;;;2338   			*pMeasurementDataReady = 0;
002554  e3a00000          MOV      r0,#0
002558  e5c40000          STRB     r0,[r4,#0]
00255c  ea00000e          B        |L1.9628|
                  |L1.9568|
;;;2339   	} else {
;;;2340   		Status = VL53L0X_RdByte(Dev, VL53L0X_REG_RESULT_RANGE_STATUS,
002560  e28d2004          ADD      r2,sp,#4
002564  e3a01014          MOV      r1,#0x14
002568  e1a00005          MOV      r0,r5
00256c  ebfffffe          BL       VL53L0X_RdByte
002570  e1a06000          MOV      r6,r0
;;;2341   			&SysRangeStatusRegister);
;;;2342   		if (Status == VL53L0X_ERROR_NONE) {
002574  e3560000          CMP      r6,#0
002578  1a000007          BNE      |L1.9628|
;;;2343   			if (SysRangeStatusRegister & 0x01)
00257c  e5dd0004          LDRB     r0,[sp,#4]
002580  e3100001          TST      r0,#1
002584  0a000002          BEQ      |L1.9620|
;;;2344   				*pMeasurementDataReady = 1;
002588  e3a00001          MOV      r0,#1
00258c  e5c40000          STRB     r0,[r4,#0]
002590  ea000001          B        |L1.9628|
                  |L1.9620|
;;;2345   			else
;;;2346   				*pMeasurementDataReady = 0;
002594  e3a00000          MOV      r0,#0
002598  e5c40000          STRB     r0,[r4,#0]
                  |L1.9628|
;;;2347   		}
;;;2348   	}
;;;2349   
;;;2350   	LOG_FUNCTION_END(Status);
;;;2351   	return Status;
00259c  e1a00006          MOV      r0,r6
;;;2352   }
0025a0  e8bd81fc          POP      {r2-r8,pc}
;;;2353   
                          ENDP

                  VL53L0X_WaitDeviceReadyForNewMeasurement PROC
;;;2354   VL53L0X_Error VL53L0X_WaitDeviceReadyForNewMeasurement(VL53L0X_DEV Dev,
0025a4  e1a02000          MOV      r2,r0
;;;2355   	uint32_t MaxLoop)
;;;2356   {
;;;2357   	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
0025a8  e3e00062          MVN      r0,#0x62
;;;2358   	LOG_FUNCTION_START("");
;;;2359   
;;;2360   	/* not implemented for VL53L0X */
;;;2361   
;;;2362   	LOG_FUNCTION_END(Status);
;;;2363   	return Status;
;;;2364   }
0025ac  e12fff1e          BX       lr
;;;2365   
                          ENDP

                  VL53L0X_GetRangingMeasurementData PROC
;;;2366   
;;;2367   VL53L0X_Error VL53L0X_GetRangingMeasurementData(VL53L0X_DEV Dev,
0025b0  e92d4ff0          PUSH     {r4-r11,lr}
;;;2368   	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData)
;;;2369   {
0025b4  e24dd04c          SUB      sp,sp,#0x4c
0025b8  e1a05000          MOV      r5,r0
0025bc  e1a04001          MOV      r4,r1
;;;2370   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0025c0  e3a08000          MOV      r8,#0
;;;2371   	uint8_t DeviceRangeStatus;
;;;2372   	uint8_t RangeFractionalEnable;
;;;2373   	uint8_t PalRangeStatus;
;;;2374   	uint8_t XTalkCompensationEnable;
;;;2375   	uint16_t AmbientRate;
;;;2376   	FixPoint1616_t SignalRate;
;;;2377   	uint16_t XTalkCompensationRateMegaCps;
;;;2378   	uint16_t EffectiveSpadRtnCount;
;;;2379   	uint16_t tmpuint16;
;;;2380   	uint16_t XtalkRangeMilliMeter;
;;;2381   	uint16_t LinearityCorrectiveGain;
;;;2382   	uint8_t localBuffer[12];
;;;2383   	VL53L0X_RangingMeasurementData_t LastRangeDataBuffer;
;;;2384   
;;;2385   	LOG_FUNCTION_START("");
;;;2386   
;;;2387   	/*
;;;2388   	 * use multi read even if some registers are not useful, result will
;;;2389   	 * be more efficient
;;;2390   	 * start reading at 0x14 dec20
;;;2391   	 * end reading at 0x21 dec33 total 14 bytes to read
;;;2392   	 */
;;;2393   	Status = VL53L0X_ReadMulti(Dev, 0x14, localBuffer, 12);
0025c4  e3a0300c          MOV      r3,#0xc
0025c8  e28d2028          ADD      r2,sp,#0x28
0025cc  e3a01014          MOV      r1,#0x14
0025d0  e1a00005          MOV      r0,r5
0025d4  ebfffffe          BL       VL53L0X_ReadMulti
0025d8  e1a08000          MOV      r8,r0
;;;2394   
;;;2395   	if (Status == VL53L0X_ERROR_NONE) {
0025dc  e3580000          CMP      r8,#0
0025e0  1a00005e          BNE      |L1.10080|
;;;2396   
;;;2397   		pRangingMeasurementData->ZoneId = 0; /* Only one zone */
0025e4  e3a00000          MOV      r0,#0
0025e8  e5c40016          STRB     r0,[r4,#0x16]
;;;2398   		pRangingMeasurementData->TimeStamp = 0; /* Not Implemented */
0025ec  e5840000          STR      r0,[r4,#0]
;;;2399   
;;;2400   		tmpuint16 = VL53L0X_MAKEUINT16(localBuffer[11], localBuffer[10]);
0025f0  e5dd0033          LDRB     r0,[sp,#0x33]
0025f4  e5dd1032          LDRB     r1,[sp,#0x32]
0025f8  e0800401          ADD      r0,r0,r1,LSL #8
0025fc  e3c07801          BIC      r7,r0,#0x10000
;;;2401   		/* cut1.1 if SYSTEM__RANGE_CONFIG if 1 range is 2bits fractional
;;;2402   		 *(format 11.2) else no fractional
;;;2403   		 */
;;;2404   
;;;2405   		pRangingMeasurementData->MeasurementTimeUsec = 0;
002600  e3a00000          MOV      r0,#0
002604  e5840004          STR      r0,[r4,#4]
;;;2406   
;;;2407   		SignalRate = VL53L0X_FIXPOINT97TOFIXPOINT1616(
002608  e5dd002f          LDRB     r0,[sp,#0x2f]
00260c  e5dd102e          LDRB     r1,[sp,#0x2e]
002610  e0800401          ADD      r0,r0,r1,LSL #8
002614  e3c00801          BIC      r0,r0,#0x10000
002618  e1a06480          LSL      r6,r0,#9
;;;2408   			VL53L0X_MAKEUINT16(localBuffer[7], localBuffer[6]));
;;;2409   		/* peak_signal_count_rate_rtn_mcps */
;;;2410   		pRangingMeasurementData->SignalRateRtnMegaCps = SignalRate;
00261c  e584600c          STR      r6,[r4,#0xc]
;;;2411   
;;;2412   		AmbientRate = VL53L0X_MAKEUINT16(localBuffer[9], localBuffer[8]);
002620  e5dd0031          LDRB     r0,[sp,#0x31]
002624  e5dd1030          LDRB     r1,[sp,#0x30]
002628  e0800401          ADD      r0,r0,r1,LSL #8
00262c  e3c00801          BIC      r0,r0,#0x10000
002630  e58d003c          STR      r0,[sp,#0x3c]
;;;2413   		pRangingMeasurementData->AmbientRateRtnMegaCps =
002634  e59d003c          LDR      r0,[sp,#0x3c]
002638  e1a00480          LSL      r0,r0,#9
00263c  e5840010          STR      r0,[r4,#0x10]
;;;2414   			VL53L0X_FIXPOINT97TOFIXPOINT1616(AmbientRate);
;;;2415   
;;;2416   		EffectiveSpadRtnCount = VL53L0X_MAKEUINT16(localBuffer[3],
002640  e5dd002b          LDRB     r0,[sp,#0x2b]
002644  e5dd102a          LDRB     r1,[sp,#0x2a]
002648  e0800401          ADD      r0,r0,r1,LSL #8
00264c  e3c09801          BIC      r9,r0,#0x10000
;;;2417   			localBuffer[2]);
;;;2418   		/* EffectiveSpadRtnCount is 8.8 format */
;;;2419   		pRangingMeasurementData->EffectiveSpadRtnCount =
002650  e1c491b4          STRH     r9,[r4,#0x14]
;;;2420   			EffectiveSpadRtnCount;
;;;2421   
;;;2422   		DeviceRangeStatus = localBuffer[0];
002654  e5dd0028          LDRB     r0,[sp,#0x28]
002658  e58d0048          STR      r0,[sp,#0x48]
;;;2423   
;;;2424   		/* Get Linearity Corrective Gain */
;;;2425   		LinearityCorrectiveGain = PALDevDataGet(Dev,
00265c  e51f08a8          LDR      r0,|L1.7612|
002660  e19000b5          LDRH     r0,[r0,r5]
002664  e58d0034          STR      r0,[sp,#0x34]
;;;2426   			LinearityCorrectiveGain);
;;;2427   
;;;2428   		/* Get ranging configuration */
;;;2429   		RangeFractionalEnable = PALDevDataGet(Dev,
002668  e5d5b131          LDRB     r11,[r5,#0x131]
;;;2430   			RangeFractionalEnable);
;;;2431   
;;;2432   		if (LinearityCorrectiveGain != 1000) {
00266c  e59d0034          LDR      r0,[sp,#0x34]
002670  e3500ffa          CMP      r0,#0x3e8
002674  0a000021          BEQ      |L1.9984|
;;;2433   
;;;2434   			tmpuint16 = (uint16_t)((LinearityCorrectiveGain
002678  e59d1034          LDR      r1,[sp,#0x34]
00267c  e0010197          MUL      r1,r7,r1
002680  e2810f7d          ADD      r0,r1,#0x1f4
002684  e3a01ffa          MOV      r1,#0x3e8
002688  ebfffffe          BL       __aeabi_idivmod
00268c  e1a07800          LSL      r7,r0,#16
002690  e1a07827          LSR      r7,r7,#16
;;;2435   				* tmpuint16 + 500) / 1000);
;;;2436   
;;;2437   			/* Implement Xtalk */
;;;2438   			VL53L0X_GETPARAMETERFIELD(Dev,
002694  e1d502b0          LDRH     r0,[r5,#0x20]
002698  e1a00800          LSL      r0,r0,#16
00269c  e1a00820          LSR      r0,r0,#16
0026a0  e58d0038          STR      r0,[sp,#0x38]
;;;2439   				XTalkCompensationRateMegaCps,
;;;2440   				XTalkCompensationRateMegaCps);
;;;2441   			VL53L0X_GETPARAMETERFIELD(Dev, XTalkCompensationEnable,
0026a4  e5d5001c          LDRB     r0,[r5,#0x1c]
0026a8  e58d0040          STR      r0,[sp,#0x40]
;;;2442   				XTalkCompensationEnable);
;;;2443   
;;;2444   			if (XTalkCompensationEnable) {
0026ac  e59d0040          LDR      r0,[sp,#0x40]
0026b0  e3500000          CMP      r0,#0
0026b4  0a000011          BEQ      |L1.9984|
;;;2445   
;;;2446   				if ((SignalRate
0026b8  e59d0038          LDR      r0,[sp,#0x38]
0026bc  e0000099          MUL      r0,r9,r0
0026c0  e0560440          SUBS     r0,r6,r0,ASR #8
0026c4  1a000005          BNE      |L1.9952|
;;;2447   					- ((XTalkCompensationRateMegaCps
;;;2448   					* EffectiveSpadRtnCount) >> 8))
;;;2449   					<= 0) {
;;;2450   					if (RangeFractionalEnable)
0026c8  e35b0000          CMP      r11,#0
0026cc  0a000001          BEQ      |L1.9944|
;;;2451   						XtalkRangeMilliMeter = 8888;
0026d0  e59fa660          LDR      r10,|L1.11576|
0026d4  ea000008          B        |L1.9980|
                  |L1.9944|
;;;2452   					else
;;;2453   						XtalkRangeMilliMeter = 8888
0026d8  e59fa65c          LDR      r10,|L1.11580|
0026dc  ea000006          B        |L1.9980|
                  |L1.9952|
;;;2454   							<< 2;
;;;2455   				} else {
;;;2456   					XtalkRangeMilliMeter =
0026e0  e59d2038          LDR      r2,[sp,#0x38]
0026e4  e0020299          MUL      r2,r9,r2
0026e8  e0461442          SUB      r1,r6,r2,ASR #8
0026ec  e0000697          MUL      r0,r7,r6
0026f0  ebfffffe          BL       __aeabi_uidivmod
0026f4  e1a0a800          LSL      r10,r0,#16
0026f8  e1a0a82a          LSR      r10,r10,#16
                  |L1.9980|
;;;2457   					(tmpuint16 * SignalRate)
;;;2458   						/ (SignalRate
;;;2459   						- ((XTalkCompensationRateMegaCps
;;;2460   						* EffectiveSpadRtnCount)
;;;2461   						>> 8));
;;;2462   				}
;;;2463   
;;;2464   				tmpuint16 = XtalkRangeMilliMeter;
0026fc  e1a0700a          MOV      r7,r10
                  |L1.9984|
;;;2465   			}
;;;2466   
;;;2467   		}
;;;2468   
;;;2469   		if (RangeFractionalEnable) {
002700  e35b0000          CMP      r11,#0
002704  0a000005          BEQ      |L1.10016|
;;;2470   			pRangingMeasurementData->RangeMilliMeter =
002708  e1a00147          ASR      r0,r7,#2
00270c  e1c400b8          STRH     r0,[r4,#8]
;;;2471   				(uint16_t)((tmpuint16) >> 2);
;;;2472   			pRangingMeasurementData->RangeFractionalPart =
002710  e1a00f07          LSL      r0,r7,#30
002714  e1a00c20          LSR      r0,r0,#24
002718  e5c40017          STRB     r0,[r4,#0x17]
00271c  ea000002          B        |L1.10028|
                  |L1.10016|
;;;2473   				(uint8_t)((tmpuint16 & 0x03) << 6);
;;;2474   		} else {
;;;2475   			pRangingMeasurementData->RangeMilliMeter = tmpuint16;
002720  e1c470b8          STRH     r7,[r4,#8]
;;;2476   			pRangingMeasurementData->RangeFractionalPart = 0;
002724  e3a00000          MOV      r0,#0
002728  e5c40017          STRB     r0,[r4,#0x17]
                  |L1.10028|
;;;2477   		}
;;;2478   
;;;2479   		/*
;;;2480   		 * For a standard definition of RangeStatus, this should
;;;2481   		 * return 0 in case of good result after a ranging
;;;2482   		 * The range status depends on the device so call a device
;;;2483   		 * specific function to obtain the right Status.
;;;2484   		 */
;;;2485   		Status |= VL53L0X_get_pal_range_status(Dev, DeviceRangeStatus,
00272c  e28d0044          ADD      r0,sp,#0x44
002730  e1a03009          MOV      r3,r9
002734  e1a02006          MOV      r2,r6
002738  e58d0004          STR      r0,[sp,#4]
00273c  e58d4000          STR      r4,[sp,#0]
002740  e1a00005          MOV      r0,r5
002744  e59d1048          LDR      r1,[sp,#0x48]
002748  ebfffffe          BL       VL53L0X_get_pal_range_status
00274c  e1888000          ORR      r8,r8,r0
;;;2486   			SignalRate, EffectiveSpadRtnCount,
;;;2487   			pRangingMeasurementData, &PalRangeStatus);
;;;2488   
;;;2489   		if (Status == VL53L0X_ERROR_NONE)
002750  e3580000          CMP      r8,#0
002754  1a000001          BNE      |L1.10080|
;;;2490   			pRangingMeasurementData->RangeStatus = PalRangeStatus;
002758  e5dd0044          LDRB     r0,[sp,#0x44]
00275c  e5c40018          STRB     r0,[r4,#0x18]
                  |L1.10080|
;;;2491   
;;;2492   	}
;;;2493   
;;;2494   	if (Status == VL53L0X_ERROR_NONE) {
002760  e3580000          CMP      r8,#0
002764  1a000017          BNE      |L1.10184|
;;;2495   		/* Copy last read data into Dev buffer */
;;;2496   		LastRangeDataBuffer = PALDevDataGet(Dev, LastRangeMeasure);
002768  e3a0201c          MOV      r2,#0x1c
00276c  e2851050          ADD      r1,r5,#0x50
002770  e28d000c          ADD      r0,sp,#0xc
002774  ebfffffe          BL       __aeabi_memcpy4
;;;2497   
;;;2498   		LastRangeDataBuffer.RangeMilliMeter =
002778  e1d400b8          LDRH     r0,[r4,#8]
00277c  e1cd01b4          STRH     r0,[sp,#0x14]
;;;2499   			pRangingMeasurementData->RangeMilliMeter;
;;;2500   		LastRangeDataBuffer.RangeFractionalPart =
002780  e5d40017          LDRB     r0,[r4,#0x17]
002784  e5cd0023          STRB     r0,[sp,#0x23]
;;;2501   			pRangingMeasurementData->RangeFractionalPart;
;;;2502   		LastRangeDataBuffer.RangeDMaxMilliMeter =
002788  e1d400ba          LDRH     r0,[r4,#0xa]
00278c  e1cd01b6          STRH     r0,[sp,#0x16]
;;;2503   			pRangingMeasurementData->RangeDMaxMilliMeter;
;;;2504   		LastRangeDataBuffer.MeasurementTimeUsec =
002790  e5940004          LDR      r0,[r4,#4]
002794  e58d0010          STR      r0,[sp,#0x10]
;;;2505   			pRangingMeasurementData->MeasurementTimeUsec;
;;;2506   		LastRangeDataBuffer.SignalRateRtnMegaCps =
002798  e594000c          LDR      r0,[r4,#0xc]
00279c  e58d0018          STR      r0,[sp,#0x18]
;;;2507   			pRangingMeasurementData->SignalRateRtnMegaCps;
;;;2508   		LastRangeDataBuffer.AmbientRateRtnMegaCps =
0027a0  e5940010          LDR      r0,[r4,#0x10]
0027a4  e58d001c          STR      r0,[sp,#0x1c]
;;;2509   			pRangingMeasurementData->AmbientRateRtnMegaCps;
;;;2510   		LastRangeDataBuffer.EffectiveSpadRtnCount =
0027a8  e1d401b4          LDRH     r0,[r4,#0x14]
0027ac  e1cd02b0          STRH     r0,[sp,#0x20]
;;;2511   			pRangingMeasurementData->EffectiveSpadRtnCount;
;;;2512   		LastRangeDataBuffer.RangeStatus =
0027b0  e5d40018          LDRB     r0,[r4,#0x18]
0027b4  e5cd0024          STRB     r0,[sp,#0x24]
;;;2513   			pRangingMeasurementData->RangeStatus;
;;;2514   
;;;2515   		PALDevDataSet(Dev, LastRangeMeasure, LastRangeDataBuffer);
0027b8  e3a0201c          MOV      r2,#0x1c
0027bc  e28d100c          ADD      r1,sp,#0xc
0027c0  e2850050          ADD      r0,r5,#0x50
0027c4  ebfffffe          BL       __aeabi_memcpy4
                  |L1.10184|
;;;2516   	}
;;;2517   
;;;2518   	LOG_FUNCTION_END(Status);
;;;2519   	return Status;
0027c8  e1a00008          MOV      r0,r8
0027cc  e28dd04c          ADD      sp,sp,#0x4c
;;;2520   }
0027d0  e8bd8ff0          POP      {r4-r11,pc}
;;;2521   
                          ENDP

                  VL53L0X_GetMeasurementRefSignal PROC
;;;2522   VL53L0X_Error VL53L0X_GetMeasurementRefSignal(VL53L0X_DEV Dev,
0027d4  e1a02000          MOV      r2,r0
;;;2523   	FixPoint1616_t *pMeasurementRefSignal)
;;;2524   {
;;;2525   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0027d8  e3a00000          MOV      r0,#0
;;;2526   	LOG_FUNCTION_START("");
;;;2527   
;;;2528   	*pMeasurementRefSignal = PALDevDataGet(Dev, LastSignalRefMcps);
0027dc  e5923148          LDR      r3,[r2,#0x148]
0027e0  e5813000          STR      r3,[r1,#0]
;;;2529   
;;;2530   	LOG_FUNCTION_END(Status);
;;;2531   	return Status;
;;;2532   
;;;2533   }
0027e4  e12fff1e          BX       lr
;;;2534   
                          ENDP

                  VL53L0X_GetHistogramMeasurementData PROC
;;;2535   VL53L0X_Error VL53L0X_GetHistogramMeasurementData(VL53L0X_DEV Dev,
0027e8  e1a02000          MOV      r2,r0
;;;2536   	VL53L0X_HistogramMeasurementData_t *pHistogramMeasurementData)
;;;2537   {
;;;2538   	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
0027ec  e3e00062          MVN      r0,#0x62
;;;2539   	LOG_FUNCTION_START("");
;;;2540   
;;;2541   	LOG_FUNCTION_END(Status);
;;;2542   	return Status;
;;;2543   }
0027f0  e12fff1e          BX       lr
;;;2544   
                          ENDP

                  VL53L0X_PerformSingleRangingMeasurement PROC
;;;2545   VL53L0X_Error VL53L0X_PerformSingleRangingMeasurement(VL53L0X_DEV Dev,
0027f4  e92d4070          PUSH     {r4-r6,lr}
;;;2546   	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData)
;;;2547   {
0027f8  e1a05000          MOV      r5,r0
0027fc  e1a06001          MOV      r6,r1
;;;2548   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002800  e3a04000          MOV      r4,#0
;;;2549   
;;;2550   	LOG_FUNCTION_START("");
;;;2551   
;;;2552   	/* This function will do a complete single ranging
;;;2553   	 * Here we fix the mode! */
;;;2554   	Status = VL53L0X_SetDeviceMode(Dev, VL53L0X_DEVICEMODE_SINGLE_RANGING);
002804  e3a01000          MOV      r1,#0
002808  e1a00005          MOV      r0,r5
00280c  ebfffffe          BL       VL53L0X_SetDeviceMode
002810  e1a04000          MOV      r4,r0
;;;2555   
;;;2556   	if (Status == VL53L0X_ERROR_NONE)
002814  e3540000          CMP      r4,#0
002818  1a000002          BNE      |L1.10280|
;;;2557   		Status = VL53L0X_PerformSingleMeasurement(Dev);
00281c  e1a00005          MOV      r0,r5
002820  ebfffffe          BL       VL53L0X_PerformSingleMeasurement
002824  e1a04000          MOV      r4,r0
                  |L1.10280|
;;;2558   
;;;2559   
;;;2560   	if (Status == VL53L0X_ERROR_NONE)
002828  e3540000          CMP      r4,#0
00282c  1a000003          BNE      |L1.10304|
;;;2561   		Status = VL53L0X_GetRangingMeasurementData(Dev,
002830  e1a01006          MOV      r1,r6
002834  e1a00005          MOV      r0,r5
002838  ebfffffe          BL       VL53L0X_GetRangingMeasurementData
00283c  e1a04000          MOV      r4,r0
                  |L1.10304|
;;;2562   			pRangingMeasurementData);
;;;2563   
;;;2564   
;;;2565   	if (Status == VL53L0X_ERROR_NONE)
002840  e3540000          CMP      r4,#0
002844  1a000003          BNE      |L1.10328|
;;;2566   		Status = VL53L0X_ClearInterruptMask(Dev, 0);
002848  e3a01000          MOV      r1,#0
00284c  e1a00005          MOV      r0,r5
002850  ebfffffe          BL       VL53L0X_ClearInterruptMask
002854  e1a04000          MOV      r4,r0
                  |L1.10328|
;;;2567   
;;;2568   
;;;2569   	LOG_FUNCTION_END(Status);
;;;2570   	return Status;
002858  e1a00004          MOV      r0,r4
;;;2571   }
00285c  e8bd8070          POP      {r4-r6,pc}
;;;2572   
                          ENDP

                  VL53L0X_SetNumberOfROIZones PROC
;;;2573   VL53L0X_Error VL53L0X_SetNumberOfROIZones(VL53L0X_DEV Dev,
002860  e1a02000          MOV      r2,r0
;;;2574   	uint8_t NumberOfROIZones)
;;;2575   {
;;;2576   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002864  e3a00000          MOV      r0,#0
;;;2577   
;;;2578   	LOG_FUNCTION_START("");
;;;2579   
;;;2580   	if (NumberOfROIZones != 1)
002868  e3510001          CMP      r1,#1
00286c  0a000000          BEQ      |L1.10356|
;;;2581   		Status = VL53L0X_ERROR_INVALID_PARAMS;
002870  e3e00003          MVN      r0,#3
                  |L1.10356|
;;;2582   
;;;2583   
;;;2584   	LOG_FUNCTION_END(Status);
;;;2585   	return Status;
;;;2586   }
002874  e12fff1e          BX       lr
;;;2587   
                          ENDP

                  VL53L0X_GetNumberOfROIZones PROC
;;;2588   VL53L0X_Error VL53L0X_GetNumberOfROIZones(VL53L0X_DEV Dev,
002878  e1a02000          MOV      r2,r0
;;;2589   	uint8_t *pNumberOfROIZones)
;;;2590   {
;;;2591   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00287c  e3a00000          MOV      r0,#0
;;;2592   
;;;2593   	LOG_FUNCTION_START("");
;;;2594   
;;;2595   	*pNumberOfROIZones = 1;
002880  e3a03001          MOV      r3,#1
002884  e5c13000          STRB     r3,[r1,#0]
;;;2596   
;;;2597   	LOG_FUNCTION_END(Status);
;;;2598   	return Status;
;;;2599   }
002888  e12fff1e          BX       lr
;;;2600   
                          ENDP

                  VL53L0X_GetMaxNumberOfROIZones PROC
;;;2601   VL53L0X_Error VL53L0X_GetMaxNumberOfROIZones(VL53L0X_DEV Dev,
00288c  e1a02000          MOV      r2,r0
;;;2602   	uint8_t *pMaxNumberOfROIZones)
;;;2603   {
;;;2604   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002890  e3a00000          MOV      r0,#0
;;;2605   
;;;2606   	LOG_FUNCTION_START("");
;;;2607   
;;;2608   	*pMaxNumberOfROIZones = 1;
002894  e3a03001          MOV      r3,#1
002898  e5c13000          STRB     r3,[r1,#0]
;;;2609   
;;;2610   	LOG_FUNCTION_END(Status);
;;;2611   	return Status;
;;;2612   }
00289c  e12fff1e          BX       lr
;;;2613   
                          ENDP

                  VL53L0X_GetGpioConfig PROC
;;;2710   
;;;2711   VL53L0X_Error VL53L0X_GetGpioConfig(VL53L0X_DEV Dev, uint8_t Pin,
0028a0  e92d4ff8          PUSH     {r3-r11,lr}
;;;2712   	VL53L0X_DeviceModes *pDeviceMode,
;;;2713   	VL53L0X_GpioFunctionality *pFunctionality,
;;;2714   	VL53L0X_InterruptPolarity *pPolarity)
;;;2715   {
0028a4  e1a06000          MOV      r6,r0
0028a8  e1a07001          MOV      r7,r1
0028ac  e1a08002          MOV      r8,r2
0028b0  e1a09003          MOV      r9,r3
0028b4  e59da028          LDR      r10,[sp,#0x28]
;;;2716   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0028b8  e3a05000          MOV      r5,#0
;;;2717   	VL53L0X_GpioFunctionality GpioFunctionality;
;;;2718   	uint8_t data;
;;;2719   
;;;2720   	LOG_FUNCTION_START("");
;;;2721   
;;;2722   	/* pDeviceMode not managed by Ewok it return the current mode */
;;;2723   
;;;2724   	Status = VL53L0X_GetDeviceMode(Dev, pDeviceMode);
0028bc  e1a01008          MOV      r1,r8
0028c0  e1a00006          MOV      r0,r6
0028c4  ebfffffe          BL       VL53L0X_GetDeviceMode
0028c8  e1a05000          MOV      r5,r0
;;;2725   
;;;2726   	if (Status == VL53L0X_ERROR_NONE) {
0028cc  e3550000          CMP      r5,#0
0028d0  1a000008          BNE      |L1.10488|
;;;2727   		if (Pin != 0) {
0028d4  e3570000          CMP      r7,#0
0028d8  0a000001          BEQ      |L1.10468|
;;;2728   			Status = VL53L0X_ERROR_GPIO_NOT_EXISTING;
0028dc  e3e05009          MVN      r5,#9
0028e0  ea000004          B        |L1.10488|
                  |L1.10468|
;;;2729   		} else {
;;;2730   			Status = VL53L0X_RdByte(Dev,
0028e4  e1a0200d          MOV      r2,sp
0028e8  e3a0100a          MOV      r1,#0xa
0028ec  e1a00006          MOV      r0,r6
0028f0  ebfffffe          BL       VL53L0X_RdByte
0028f4  e1a05000          MOV      r5,r0
                  |L1.10488|
;;;2731   			VL53L0X_REG_SYSTEM_INTERRUPT_CONFIG_GPIO, &data);
;;;2732   		}
;;;2733   	}
;;;2734   
;;;2735   	if (Status == VL53L0X_ERROR_NONE) {
0028f8  e3550000          CMP      r5,#0
0028fc  1a00001c          BNE      |L1.10612|
;;;2736   		switch (data & 0x07) {
002900  e5dd0000          LDRB     r0,[sp,#0]
002904  e2000007          AND      r0,r0,#7
002908  e3500005          CMP      r0,#5
00290c  308ff100          ADDCC    pc,pc,r0,LSL #2
002910  ea000013          B        |L1.10596|
002914  ea000003          B        |L1.10536|
002918  ea000005          B        |L1.10548|
00291c  ea000007          B        |L1.10560|
002920  ea000009          B        |L1.10572|
002924  ea00000b          B        |L1.10584|
                  |L1.10536|
;;;2737   		case 0x00:
002928  e1a00000          MOV      r0,r0
;;;2738   			GpioFunctionality = VL53L0X_GPIOFUNCTIONALITY_OFF;
00292c  e3a04000          MOV      r4,#0
;;;2739   			break;
002930  ea00000e          B        |L1.10608|
                  |L1.10548|
;;;2740   		case 0x01:
002934  e1a00000          MOV      r0,r0
;;;2741   			GpioFunctionality =
002938  e3a04001          MOV      r4,#1
;;;2742   			VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_LOW;
;;;2743   			break;
00293c  ea00000b          B        |L1.10608|
                  |L1.10560|
;;;2744   		case 0x02:
002940  e1a00000          MOV      r0,r0
;;;2745   			GpioFunctionality =
002944  e3a04002          MOV      r4,#2
;;;2746   			VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_HIGH;
;;;2747   			break;
002948  ea000008          B        |L1.10608|
                  |L1.10572|
;;;2748   		case 0x03:
00294c  e1a00000          MOV      r0,r0
;;;2749   			GpioFunctionality =
002950  e3a04003          MOV      r4,#3
;;;2750   			VL53L0X_GPIOFUNCTIONALITY_THRESHOLD_CROSSED_OUT;
;;;2751   			break;
002954  ea000005          B        |L1.10608|
                  |L1.10584|
;;;2752   		case 0x04:
002958  e1a00000          MOV      r0,r0
;;;2753   			GpioFunctionality =
00295c  e3a04004          MOV      r4,#4
;;;2754   			VL53L0X_GPIOFUNCTIONALITY_NEW_MEASURE_READY;
;;;2755   			break;
002960  ea000002          B        |L1.10608|
                  |L1.10596|
;;;2756   		default:
002964  e1a00000          MOV      r0,r0
;;;2757   			Status = VL53L0X_ERROR_GPIO_FUNCTIONALITY_NOT_SUPPORTED;
002968  e3e0500a          MVN      r5,#0xa
00296c  e1a00000          MOV      r0,r0                 ;2736
                  |L1.10608|
002970  e1a00000          MOV      r0,r0                 ;2739
                  |L1.10612|
;;;2758   		}
;;;2759   	}
;;;2760   
;;;2761   	if (Status == VL53L0X_ERROR_NONE)
002974  e3550000          CMP      r5,#0
002978  1a000004          BNE      |L1.10640|
;;;2762   		Status = VL53L0X_RdByte(Dev, VL53L0X_REG_GPIO_HV_MUX_ACTIVE_HIGH,
00297c  e1a0200d          MOV      r2,sp
002980  e3a01084          MOV      r1,#0x84
002984  e1a00006          MOV      r0,r6
002988  ebfffffe          BL       VL53L0X_RdByte
00298c  e1a05000          MOV      r5,r0
                  |L1.10640|
;;;2763   			&data);
;;;2764   
;;;2765   	if (Status == VL53L0X_ERROR_NONE) {
002990  e3550000          CMP      r5,#0
002994  1a000007          BNE      |L1.10680|
;;;2766   		if ((data & (uint8_t)(1 << 4)) == 0)
002998  e5dd0000          LDRB     r0,[sp,#0]
00299c  e3100010          TST      r0,#0x10
0029a0  1a000002          BNE      |L1.10672|
;;;2767   			*pPolarity = VL53L0X_INTERRUPTPOLARITY_LOW;
0029a4  e3a00000          MOV      r0,#0
0029a8  e5ca0000          STRB     r0,[r10,#0]
0029ac  ea000001          B        |L1.10680|
                  |L1.10672|
;;;2768   		else
;;;2769   			*pPolarity = VL53L0X_INTERRUPTPOLARITY_HIGH;
0029b0  e3a00001          MOV      r0,#1
0029b4  e5ca0000          STRB     r0,[r10,#0]
                  |L1.10680|
;;;2770   	}
;;;2771   
;;;2772   	if (Status == VL53L0X_ERROR_NONE) {
0029b8  e3550000          CMP      r5,#0
0029bc  1a000001          BNE      |L1.10696|
;;;2773   		*pFunctionality = GpioFunctionality;
0029c0  e5c94000          STRB     r4,[r9,#0]
;;;2774   		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, Pin0GpioFunctionality,
0029c4  e5c640da          STRB     r4,[r6,#0xda]
                  |L1.10696|
;;;2775   			GpioFunctionality);
;;;2776   	}
;;;2777   
;;;2778   	LOG_FUNCTION_END(Status);
;;;2779   	return Status;
0029c8  e1a00005          MOV      r0,r5
;;;2780   }
0029cc  e8bd8ff8          POP      {r3-r11,pc}
;;;2781   
                          ENDP

                  VL53L0X_SetInterruptThresholds PROC
;;;2782   VL53L0X_Error VL53L0X_SetInterruptThresholds(VL53L0X_DEV Dev,
0029d0  e92d47f0          PUSH     {r4-r10,lr}
;;;2783   	VL53L0X_DeviceModes DeviceMode, FixPoint1616_t ThresholdLow,
;;;2784   	FixPoint1616_t ThresholdHigh)
;;;2785   {
0029d4  e1a07000          MOV      r7,r0
0029d8  e1a09001          MOV      r9,r1
0029dc  e1a04002          MOV      r4,r2
0029e0  e1a05003          MOV      r5,r3
;;;2786   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0029e4  e3a06000          MOV      r6,#0
;;;2787   	uint16_t Threshold16;
;;;2788   	LOG_FUNCTION_START("");
;;;2789   
;;;2790   	/* no dependency on DeviceMode for Ewok */
;;;2791   	/* Need to divide by 2 because the FW will apply a x2 */
;;;2792   	Threshold16 = (uint16_t)((ThresholdLow >> 17) & 0x00fff);
0029e8  e59f0350          LDR      r0,|L1.11584|
0029ec  e00088a4          AND      r8,r0,r4,LSR #17
;;;2793   	Status = VL53L0X_WrWord(Dev, VL53L0X_REG_SYSTEM_THRESH_LOW, Threshold16);
0029f0  e1a02008          MOV      r2,r8
0029f4  e3a0100e          MOV      r1,#0xe
0029f8  e1a00007          MOV      r0,r7
0029fc  ebfffffe          BL       VL53L0X_WrWord
002a00  e1a06000          MOV      r6,r0
;;;2794   
;;;2795   	if (Status == VL53L0X_ERROR_NONE) {
002a04  e3560000          CMP      r6,#0
002a08  1a000006          BNE      |L1.10792|
;;;2796   		/* Need to divide by 2 because the FW will apply a x2 */
;;;2797   		Threshold16 = (uint16_t)((ThresholdHigh >> 17) & 0x00fff);
002a0c  e59f032c          LDR      r0,|L1.11584|
002a10  e00088a5          AND      r8,r0,r5,LSR #17
;;;2798   		Status = VL53L0X_WrWord(Dev, VL53L0X_REG_SYSTEM_THRESH_HIGH,
002a14  e1a02008          MOV      r2,r8
002a18  e3a0100c          MOV      r1,#0xc
002a1c  e1a00007          MOV      r0,r7
002a20  ebfffffe          BL       VL53L0X_WrWord
002a24  e1a06000          MOV      r6,r0
                  |L1.10792|
;;;2799   			Threshold16);
;;;2800   	}
;;;2801   
;;;2802   	LOG_FUNCTION_END(Status);
;;;2803   	return Status;
002a28  e1a00006          MOV      r0,r6
;;;2804   }
002a2c  e8bd87f0          POP      {r4-r10,pc}
;;;2805   
                          ENDP

                  VL53L0X_GetStopCompletedStatus PROC
;;;2831   
;;;2832   VL53L0X_Error VL53L0X_GetStopCompletedStatus(VL53L0X_DEV Dev,
002a30  e92d40f8          PUSH     {r3-r7,lr}
;;;2833   	uint32_t *pStopStatus)
;;;2834   {
002a34  e1a05000          MOV      r5,r0
002a38  e1a06001          MOV      r6,r1
;;;2835   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002a3c  e3a04000          MOV      r4,#0
;;;2836   	uint8_t Byte = 0;
002a40  e3a00000          MOV      r0,#0
002a44  e58d0000          STR      r0,[sp,#0]
;;;2837   	LOG_FUNCTION_START("");
;;;2838   
;;;2839   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002a48  e3a02001          MOV      r2,#1
002a4c  e3a010ff          MOV      r1,#0xff
002a50  e1a00005          MOV      r0,r5
002a54  ebfffffe          BL       VL53L0X_WrByte
002a58  e1a04000          MOV      r4,r0
;;;2840   
;;;2841   	if (Status == VL53L0X_ERROR_NONE)
002a5c  e3540000          CMP      r4,#0
002a60  1a000004          BNE      |L1.10872|
;;;2842   		Status = VL53L0X_RdByte(Dev, 0x04, &Byte);
002a64  e1a0200d          MOV      r2,sp
002a68  e3a01004          MOV      r1,#4
002a6c  e1a00005          MOV      r0,r5
002a70  ebfffffe          BL       VL53L0X_RdByte
002a74  e1a04000          MOV      r4,r0
                  |L1.10872|
;;;2843   
;;;2844   	if (Status == VL53L0X_ERROR_NONE)
002a78  e3540000          CMP      r4,#0
002a7c  1a000004          BNE      |L1.10900|
;;;2845   		Status = VL53L0X_WrByte(Dev, 0xFF, 0x0);
002a80  e3a02000          MOV      r2,#0
002a84  e3a010ff          MOV      r1,#0xff
002a88  e1a00005          MOV      r0,r5
002a8c  ebfffffe          BL       VL53L0X_WrByte
002a90  e1a04000          MOV      r4,r0
                  |L1.10900|
;;;2846   
;;;2847   	*pStopStatus = Byte;
002a94  e5dd0000          LDRB     r0,[sp,#0]
002a98  e5860000          STR      r0,[r6,#0]
;;;2848   	
;;;2849   	if (Byte == 0) {
002a9c  e5dd0000          LDRB     r0,[sp,#0]
002aa0  e3500000          CMP      r0,#0
002aa4  1a000022          BNE      |L1.11060|
;;;2850   		Status = VL53L0X_WrByte(Dev, 0x80, 0x01);
002aa8  e3a02001          MOV      r2,#1
002aac  e3a01080          MOV      r1,#0x80
002ab0  e1a00005          MOV      r0,r5
002ab4  ebfffffe          BL       VL53L0X_WrByte
002ab8  e1a04000          MOV      r4,r0
;;;2851   		Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002abc  e3a02001          MOV      r2,#1
002ac0  e3a010ff          MOV      r1,#0xff
002ac4  e1a00005          MOV      r0,r5
002ac8  ebfffffe          BL       VL53L0X_WrByte
002acc  e1a04000          MOV      r4,r0
;;;2852   		Status = VL53L0X_WrByte(Dev, 0x00, 0x00);
002ad0  e3a02000          MOV      r2,#0
002ad4  e1a01002          MOV      r1,r2
002ad8  e1a00005          MOV      r0,r5
002adc  ebfffffe          BL       VL53L0X_WrByte
002ae0  e1a04000          MOV      r4,r0
;;;2853   		Status = VL53L0X_WrByte(Dev, 0x91,
002ae4  e5d5213a          LDRB     r2,[r5,#0x13a]
002ae8  e3a01091          MOV      r1,#0x91
002aec  e1a00005          MOV      r0,r5
002af0  ebfffffe          BL       VL53L0X_WrByte
002af4  e1a04000          MOV      r4,r0
;;;2854   			PALDevDataGet(Dev, StopVariable));
;;;2855   		Status = VL53L0X_WrByte(Dev, 0x00, 0x01);
002af8  e3a02001          MOV      r2,#1
002afc  e3a01000          MOV      r1,#0
002b00  e1a00005          MOV      r0,r5
002b04  ebfffffe          BL       VL53L0X_WrByte
002b08  e1a04000          MOV      r4,r0
;;;2856   		Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
002b0c  e3a02000          MOV      r2,#0
002b10  e3a010ff          MOV      r1,#0xff
002b14  e1a00005          MOV      r0,r5
002b18  ebfffffe          BL       VL53L0X_WrByte
002b1c  e1a04000          MOV      r4,r0
;;;2857   		Status = VL53L0X_WrByte(Dev, 0x80, 0x00);
002b20  e3a02000          MOV      r2,#0
002b24  e3a01080          MOV      r1,#0x80
002b28  e1a00005          MOV      r0,r5
002b2c  ebfffffe          BL       VL53L0X_WrByte
002b30  e1a04000          MOV      r4,r0
                  |L1.11060|
;;;2858   	}
;;;2859   
;;;2860   	LOG_FUNCTION_END(Status);
;;;2861   	return Status;
002b34  e1a00004          MOV      r0,r4
;;;2862   }
002b38  e8bd80f8          POP      {r3-r7,pc}
;;;2863   
                          ENDP

                  VL53L0X_EnableInterruptMask PROC
;;;2910   
;;;2911   VL53L0X_Error VL53L0X_EnableInterruptMask(VL53L0X_DEV Dev, uint32_t InterruptMask)
002b3c  e1a02000          MOV      r2,r0
;;;2912   {
;;;2913   	VL53L0X_Error Status = VL53L0X_ERROR_NOT_IMPLEMENTED;
002b40  e3e00062          MVN      r0,#0x62
;;;2914   	LOG_FUNCTION_START("");
;;;2915   
;;;2916   	/* not implemented for VL53L0X */
;;;2917   
;;;2918   	LOG_FUNCTION_END(Status);
;;;2919   	return Status;
;;;2920   }
002b44  e12fff1e          BX       lr
;;;2921   
                          ENDP

                  VL53L0X_SetSpadAmbientDamperThreshold PROC
;;;2925   
;;;2926   VL53L0X_Error VL53L0X_SetSpadAmbientDamperThreshold(VL53L0X_DEV Dev,
002b48  e92d4070          PUSH     {r4-r6,lr}
;;;2927   	uint16_t SpadAmbientDamperThreshold)
;;;2928   {
002b4c  e1a06000          MOV      r6,r0
002b50  e1a05001          MOV      r5,r1
;;;2929   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002b54  e3a04000          MOV      r4,#0
;;;2930   	LOG_FUNCTION_START("");
;;;2931   
;;;2932   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002b58  e3a02001          MOV      r2,#1
002b5c  e3a010ff          MOV      r1,#0xff
002b60  e1a00006          MOV      r0,r6
002b64  ebfffffe          BL       VL53L0X_WrByte
002b68  e1a04000          MOV      r4,r0
;;;2933   	Status |= VL53L0X_WrWord(Dev, 0x40, SpadAmbientDamperThreshold);
002b6c  e1a02005          MOV      r2,r5
002b70  e3a01040          MOV      r1,#0x40
002b74  e1a00006          MOV      r0,r6
002b78  ebfffffe          BL       VL53L0X_WrWord
002b7c  e1844000          ORR      r4,r4,r0
;;;2934   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
002b80  e3a02000          MOV      r2,#0
002b84  e3a010ff          MOV      r1,#0xff
002b88  e1a00006          MOV      r0,r6
002b8c  ebfffffe          BL       VL53L0X_WrByte
002b90  e1844000          ORR      r4,r4,r0
;;;2935   
;;;2936   	LOG_FUNCTION_END(Status);
;;;2937   	return Status;
002b94  e1a00004          MOV      r0,r4
;;;2938   }
002b98  e8bd8070          POP      {r4-r6,pc}
;;;2939   
                          ENDP

                  VL53L0X_GetSpadAmbientDamperThreshold PROC
;;;2940   VL53L0X_Error VL53L0X_GetSpadAmbientDamperThreshold(VL53L0X_DEV Dev,
002b9c  e92d4070          PUSH     {r4-r6,lr}
;;;2941   	uint16_t *pSpadAmbientDamperThreshold)
;;;2942   {
002ba0  e1a06000          MOV      r6,r0
002ba4  e1a05001          MOV      r5,r1
;;;2943   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002ba8  e3a04000          MOV      r4,#0
;;;2944   	LOG_FUNCTION_START("");
;;;2945   
;;;2946   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002bac  e3a02001          MOV      r2,#1
002bb0  e3a010ff          MOV      r1,#0xff
002bb4  e1a00006          MOV      r0,r6
002bb8  ebfffffe          BL       VL53L0X_WrByte
002bbc  e1a04000          MOV      r4,r0
;;;2947   	Status |= VL53L0X_RdWord(Dev, 0x40, pSpadAmbientDamperThreshold);
002bc0  e1a02005          MOV      r2,r5
002bc4  e3a01040          MOV      r1,#0x40
002bc8  e1a00006          MOV      r0,r6
002bcc  ebfffffe          BL       VL53L0X_RdWord
002bd0  e1844000          ORR      r4,r4,r0
;;;2948   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
002bd4  e3a02000          MOV      r2,#0
002bd8  e3a010ff          MOV      r1,#0xff
002bdc  e1a00006          MOV      r0,r6
002be0  ebfffffe          BL       VL53L0X_WrByte
002be4  e1844000          ORR      r4,r4,r0
;;;2949   
;;;2950   	LOG_FUNCTION_END(Status);
;;;2951   	return Status;
002be8  e1a00004          MOV      r0,r4
;;;2952   }
002bec  e8bd8070          POP      {r4-r6,pc}
;;;2953   
                          ENDP

                  VL53L0X_SetSpadAmbientDamperFactor PROC
;;;2954   VL53L0X_Error VL53L0X_SetSpadAmbientDamperFactor(VL53L0X_DEV Dev,
002bf0  e92d41f0          PUSH     {r4-r8,lr}
;;;2955   	uint16_t SpadAmbientDamperFactor)
;;;2956   {
002bf4  e1a06000          MOV      r6,r0
002bf8  e1a05001          MOV      r5,r1
;;;2957   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002bfc  e3a04000          MOV      r4,#0
;;;2958   	uint8_t Byte;
;;;2959   	LOG_FUNCTION_START("");
;;;2960   
;;;2961   	Byte = (uint8_t)(SpadAmbientDamperFactor & 0x00FF);
002c00  e20570ff          AND      r7,r5,#0xff
;;;2962   
;;;2963   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002c04  e3a02001          MOV      r2,#1
002c08  e3a010ff          MOV      r1,#0xff
002c0c  e1a00006          MOV      r0,r6
002c10  ebfffffe          BL       VL53L0X_WrByte
002c14  e1a04000          MOV      r4,r0
;;;2964   	Status |= VL53L0X_WrByte(Dev, 0x42, Byte);
002c18  e1a02007          MOV      r2,r7
002c1c  e3a01042          MOV      r1,#0x42
002c20  e1a00006          MOV      r0,r6
002c24  ebfffffe          BL       VL53L0X_WrByte
002c28  e1844000          ORR      r4,r4,r0
;;;2965   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
002c2c  e3a02000          MOV      r2,#0
002c30  e3a010ff          MOV      r1,#0xff
002c34  e1a00006          MOV      r0,r6
002c38  ebfffffe          BL       VL53L0X_WrByte
002c3c  e1844000          ORR      r4,r4,r0
;;;2966   
;;;2967   	LOG_FUNCTION_END(Status);
;;;2968   	return Status;
002c40  e1a00004          MOV      r0,r4
;;;2969   }
002c44  e8bd81f0          POP      {r4-r8,pc}
;;;2970   
                          ENDP

                  VL53L0X_GetSpadAmbientDamperFactor PROC
;;;2971   VL53L0X_Error VL53L0X_GetSpadAmbientDamperFactor(VL53L0X_DEV Dev,
002c48  e92d40f8          PUSH     {r3-r7,lr}
;;;2972   	uint16_t *pSpadAmbientDamperFactor)
;;;2973   {
002c4c  e1a06000          MOV      r6,r0
002c50  e1a05001          MOV      r5,r1
;;;2974   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002c54  e3a04000          MOV      r4,#0
;;;2975   	uint8_t Byte;
;;;2976   	LOG_FUNCTION_START("");
;;;2977   
;;;2978   	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
002c58  e3a02001          MOV      r2,#1
002c5c  e3a010ff          MOV      r1,#0xff
002c60  e1a00006          MOV      r0,r6
002c64  ebfffffe          BL       VL53L0X_WrByte
002c68  e1a04000          MOV      r4,r0
;;;2979   	Status |= VL53L0X_RdByte(Dev, 0x42, &Byte);
002c6c  e1a0200d          MOV      r2,sp
002c70  e3a01042          MOV      r1,#0x42
002c74  e1a00006          MOV      r0,r6
002c78  ebfffffe          BL       VL53L0X_RdByte
002c7c  e1844000          ORR      r4,r4,r0
;;;2980   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
002c80  e3a02000          MOV      r2,#0
002c84  e3a010ff          MOV      r1,#0xff
002c88  e1a00006          MOV      r0,r6
002c8c  ebfffffe          BL       VL53L0X_WrByte
002c90  e1844000          ORR      r4,r4,r0
;;;2981   	*pSpadAmbientDamperFactor = (uint16_t)Byte;
002c94  e5dd0000          LDRB     r0,[sp,#0]
002c98  e1c500b0          STRH     r0,[r5,#0]
;;;2982   
;;;2983   	LOG_FUNCTION_END(Status);
;;;2984   	return Status;
002c9c  e1a00004          MOV      r0,r4
;;;2985   }
002ca0  e8bd80f8          POP      {r3-r7,pc}
;;;2986   
                          ENDP

                  VL53L0X_SetReferenceSpads PROC
;;;2992   
;;;2993   VL53L0X_Error VL53L0X_SetReferenceSpads(VL53L0X_DEV Dev, uint32_t count,
002ca4  e92d41f0          PUSH     {r4-r8,lr}
;;;2994   	uint8_t isApertureSpads)
;;;2995   {
002ca8  e1a04000          MOV      r4,r0
002cac  e1a05001          MOV      r5,r1
002cb0  e1a06002          MOV      r6,r2
;;;2996   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002cb4  e3a07000          MOV      r7,#0
;;;2997   	LOG_FUNCTION_START("");
;;;2998   
;;;2999   	Status = VL53L0X_set_reference_spads(Dev, count, isApertureSpads);
002cb8  e1a02006          MOV      r2,r6
002cbc  e1a01005          MOV      r1,r5
002cc0  e1a00004          MOV      r0,r4
002cc4  ebfffffe          BL       VL53L0X_set_reference_spads
002cc8  e1a07000          MOV      r7,r0
;;;3000   
;;;3001   	LOG_FUNCTION_END(Status);
;;;3002   
;;;3003   	return Status;
002ccc  e1a00007          MOV      r0,r7
;;;3004   }
002cd0  e8bd81f0          POP      {r4-r8,pc}
;;;3005   
                          ENDP

                  VL53L0X_GetReferenceSpads PROC
;;;3006   VL53L0X_Error VL53L0X_GetReferenceSpads(VL53L0X_DEV Dev, uint32_t *pSpadCount,
002cd4  e92d41f0          PUSH     {r4-r8,lr}
;;;3007   	uint8_t *pIsApertureSpads)
;;;3008   {
002cd8  e1a04000          MOV      r4,r0
002cdc  e1a05001          MOV      r5,r1
002ce0  e1a06002          MOV      r6,r2
;;;3009   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002ce4  e3a07000          MOV      r7,#0
;;;3010   	LOG_FUNCTION_START("");
;;;3011   
;;;3012   	Status = VL53L0X_get_reference_spads(Dev, pSpadCount, pIsApertureSpads);
002ce8  e1a02006          MOV      r2,r6
002cec  e1a01005          MOV      r1,r5
002cf0  e1a00004          MOV      r0,r4
002cf4  ebfffffe          BL       VL53L0X_get_reference_spads
002cf8  e1a07000          MOV      r7,r0
;;;3013   
;;;3014   	LOG_FUNCTION_END(Status);
;;;3015   
;;;3016   	return Status;
002cfc  e1a00007          MOV      r0,r7
;;;3017   }
002d00  e8bd81f0          POP      {r4-r8,pc}
;;;3018   
                          ENDP

                  VL53L0X_PerformRefSpadManagement PROC
;;;3019   VL53L0X_Error VL53L0X_PerformRefSpadManagement(VL53L0X_DEV Dev,
002d04  e92d41f0          PUSH     {r4-r8,lr}
;;;3020   	uint32_t *refSpadCount, uint8_t *isApertureSpads)
;;;3021   {
002d08  e1a04000          MOV      r4,r0
002d0c  e1a05001          MOV      r5,r1
002d10  e1a06002          MOV      r6,r2
;;;3022   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002d14  e3a07000          MOV      r7,#0
;;;3023   	LOG_FUNCTION_START("");
;;;3024   
;;;3025   	Status = VL53L0X_perform_ref_spad_management(Dev, refSpadCount,
002d18  e1a02006          MOV      r2,r6
002d1c  e1a01005          MOV      r1,r5
002d20  e1a00004          MOV      r0,r4
002d24  ebfffffe          BL       VL53L0X_perform_ref_spad_management
002d28  e1a07000          MOV      r7,r0
;;;3026   		isApertureSpads);
;;;3027   
;;;3028   	LOG_FUNCTION_END(Status);
;;;3029   
;;;3030   	return Status;
002d2c  e1a00007          MOV      r0,r7
;;;3031   }
002d30  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

                  |L1.11572|
                          DCD      InterruptThresholdSettings
                  |L1.11576|
                          DCD      0x000022b8
                  |L1.11580|
                          DCD      0x00008ae0
                  |L1.11584|
                          DCD      0x00000fff

                          AREA ||.data||, DATA, ALIGN=0

                  DefaultTuningSettings
000000  01ff0101          DCB      0x01,0xff,0x01,0x01
000004  000001ff          DCB      0x00,0x00,0x01,0xff
000008  00010900          DCB      0x00,0x01,0x09,0x00
00000c  01100001          DCB      0x01,0x10,0x00,0x01
000010  11000124          DCB      0x11,0x00,0x01,0x24
000014  010125ff          DCB      0x01,0x01,0x25,0xff
000018  01750001          DCB      0x01,0x75,0x00,0x01
00001c  ff01014e          DCB      0xff,0x01,0x01,0x4e
000020  2c014800          DCB      0x2c,0x01,0x48,0x00
000024  01302001          DCB      0x01,0x30,0x20,0x01
000028  ff000130          DCB      0xff,0x00,0x01,0x30
00002c  09015400          DCB      0x09,0x01,0x54,0x00
000030  01310401          DCB      0x01,0x31,0x04,0x01
000034  32030140          DCB      0x32,0x03,0x01,0x40
000038  83014625          DCB      0x83,0x01,0x46,0x25
00003c  01600001          DCB      0x01,0x60,0x00,0x01
000040  27000150          DCB      0x27,0x00,0x01,0x50
000044  06015100          DCB      0x06,0x01,0x51,0x00
000048  01529601          DCB      0x01,0x52,0x96,0x01
00004c  56080157          DCB      0x56,0x08,0x01,0x57
000050  30016100          DCB      0x30,0x01,0x61,0x00
000054  01620001          DCB      0x01,0x62,0x00,0x01
000058  64000165          DCB      0x64,0x00,0x01,0x65
00005c  000166a0          DCB      0x00,0x01,0x66,0xa0
000060  01ff0101          DCB      0x01,0xff,0x01,0x01
000064  22320147          DCB      0x22,0x32,0x01,0x47
000068  140149ff          DCB      0x14,0x01,0x49,0xff
00006c  014a0001          DCB      0x01,0x4a,0x00,0x01
000070  ff00017a          DCB      0xff,0x00,0x01,0x7a
000074  0a017b00          DCB      0x0a,0x01,0x7b,0x00
000078  01782101          DCB      0x01,0x78,0x21,0x01
00007c  ff010123          DCB      0xff,0x01,0x01,0x23
000080  34014200          DCB      0x34,0x01,0x42,0x00
000084  0144ff01          DCB      0x01,0x44,0xff,0x01
000088  45260146          DCB      0x45,0x26,0x01,0x46
00008c  05014040          DCB      0x05,0x01,0x40,0x40
000090  010e0601          DCB      0x01,0x0e,0x06,0x01
000094  201a0143          DCB      0x20,0x1a,0x01,0x43
000098  4001ff00          DCB      0x40,0x01,0xff,0x00
00009c  01340301          DCB      0x01,0x34,0x03,0x01
0000a0  354401ff          DCB      0x35,0x44,0x01,0xff
0000a4  01013104          DCB      0x01,0x01,0x31,0x04
0000a8  014b0901          DCB      0x01,0x4b,0x09,0x01
0000ac  4c05014d          DCB      0x4c,0x05,0x01,0x4d
0000b0  0401ff00          DCB      0x04,0x01,0xff,0x00
0000b4  01440001          DCB      0x01,0x44,0x00,0x01
0000b8  45200147          DCB      0x45,0x20,0x01,0x47
0000bc  08014828          DCB      0x08,0x01,0x48,0x28
0000c0  01670001          DCB      0x01,0x67,0x00,0x01
0000c4  70040171          DCB      0x70,0x04,0x01,0x71
0000c8  010172fe          DCB      0x01,0x01,0x72,0xfe
0000cc  01760001          DCB      0x01,0x76,0x00,0x01
0000d0  770001ff          DCB      0x77,0x00,0x01,0xff
0000d4  01010d01          DCB      0x01,0x01,0x0d,0x01
0000d8  01ff0001          DCB      0x01,0xff,0x00,0x01
0000dc  80010101          DCB      0x80,0x01,0x01,0x01
0000e0  f801ff01          DCB      0xf8,0x01,0xff,0x01
0000e4  018e0101          DCB      0x01,0x8e,0x01,0x01
0000e8  000101ff          DCB      0x00,0x01,0x01,0xff
0000ec  00018000          DCB      0x00,0x01,0x80,0x00
0000f0  000000            DCB      0x00,0x00,0x00
                  InterruptThresholdSettings
0000f3  01                DCB      0x01
0000f4  ff000180          DCB      0xff,0x00,0x01,0x80
0000f8  0101ff01          DCB      0x01,0x01,0xff,0x01
0000fc  01000001          DCB      0x01,0x00,0x00,0x01
000100  ff01014f          DCB      0xff,0x01,0x01,0x4f
000104  0201ff0e          DCB      0x02,0x01,0xff,0x0e
000108  01000301          DCB      0x01,0x00,0x03,0x01
00010c  01840102          DCB      0x01,0x84,0x01,0x02
000110  0a010303          DCB      0x0a,0x01,0x03,0x03
000114  01040801          DCB      0x01,0x04,0x08,0x01
000118  05c80106          DCB      0x05,0xc8,0x01,0x06
00011c  0301078d          DCB      0x03,0x01,0x07,0x8d
000120  01080801          DCB      0x01,0x08,0x08,0x01
000124  09c6010a          DCB      0x09,0xc6,0x01,0x0a
000128  01010b02          DCB      0x01,0x01,0x0b,0x02
00012c  010c0001          DCB      0x01,0x0c,0x00,0x01
000130  0dd5010e          DCB      0x0d,0xd5,0x01,0x0e
000134  18010f12          DCB      0x18,0x01,0x0f,0x12
000138  01100101          DCB      0x01,0x10,0x01,0x01
00013c  11820112          DCB      0x11,0x82,0x01,0x12
000140  000113d5          DCB      0x00,0x01,0x13,0xd5
000144  01141801          DCB      0x01,0x14,0x18,0x01
000148  15130116          DCB      0x15,0x13,0x01,0x16
00014c  03011786          DCB      0x03,0x01,0x17,0x86
000150  01180a01          DCB      0x01,0x18,0x0a,0x01
000154  1909011a          DCB      0x19,0x09,0x01,0x1a
000158  08011bc2          DCB      0x08,0x01,0x1b,0xc2
00015c  011c0301          DCB      0x01,0x1c,0x03,0x01
000160  1d8f011e          DCB      0x1d,0x8f,0x01,0x1e
000164  0a011f06          DCB      0x0a,0x01,0x1f,0x06
000168  01200101          DCB      0x01,0x20,0x01,0x01
00016c  21020122          DCB      0x21,0x02,0x01,0x22
000170  000123d5          DCB      0x00,0x01,0x23,0xd5
000174  01241801          DCB      0x01,0x24,0x18,0x01
000178  25220126          DCB      0x25,0x22,0x01,0x26
00017c  01012782          DCB      0x01,0x01,0x27,0x82
000180  01280001          DCB      0x01,0x28,0x00,0x01
000184  29d5012a          DCB      0x29,0xd5,0x01,0x2a
000188  18012b0b          DCB      0x18,0x01,0x2b,0x0b
00018c  012c2801          DCB      0x01,0x2c,0x28,0x01
000190  2d78012e          DCB      0x2d,0x78,0x01,0x2e
000194  28012f91          DCB      0x28,0x01,0x2f,0x91
000198  01300001          DCB      0x01,0x30,0x00,0x01
00019c  310b0132          DCB      0x31,0x0b,0x01,0x32
0001a0  0001330b          DCB      0x00,0x01,0x33,0x0b
0001a4  01340001          DCB      0x01,0x34,0x00,0x01
0001a8  35a10136          DCB      0x35,0xa1,0x01,0x36
0001ac  000137a0          DCB      0x00,0x01,0x37,0xa0
0001b0  01380001          DCB      0x01,0x38,0x00,0x01
0001b4  3904013a          DCB      0x39,0x04,0x01,0x3a
0001b8  28013b30          DCB      0x28,0x01,0x3b,0x30
0001bc  013c0c01          DCB      0x01,0x3c,0x0c,0x01
0001c0  3d04013e          DCB      0x3d,0x04,0x01,0x3e
0001c4  0f013f79          DCB      0x0f,0x01,0x3f,0x79
0001c8  01402801          DCB      0x01,0x40,0x28,0x01
0001cc  411e0142          DCB      0x41,0x1e,0x01,0x42
0001d0  2f014387          DCB      0x2f,0x01,0x43,0x87
0001d4  01440001          DCB      0x01,0x44,0x00,0x01
0001d8  450b0146          DCB      0x45,0x0b,0x01,0x46
0001dc  0001470b          DCB      0x00,0x01,0x47,0x0b
0001e0  01480001          DCB      0x01,0x48,0x00,0x01
0001e4  49a7014a          DCB      0x49,0xa7,0x01,0x4a
0001e8  00014ba6          DCB      0x00,0x01,0x4b,0xa6
0001ec  014c0001          DCB      0x01,0x4c,0x00,0x01
0001f0  4d04014e          DCB      0x4d,0x04,0x01,0x4e
0001f4  01014f00          DCB      0x01,0x01,0x4f,0x00
0001f8  01500001          DCB      0x01,0x50,0x00,0x01
0001fc  51800152          DCB      0x51,0x80,0x01,0x52
000200  09015308          DCB      0x09,0x01,0x53,0x08
000204  01540101          DCB      0x01,0x54,0x01,0x01
000208  55000156          DCB      0x55,0x00,0x01,0x56
00020c  0f015779          DCB      0x0f,0x01,0x57,0x79
000210  01580901          DCB      0x01,0x58,0x09,0x01
000214  5905015a          DCB      0x59,0x05,0x01,0x5a
000218  00015b60          DCB      0x00,0x01,0x5b,0x60
00021c  015c0501          DCB      0x01,0x5c,0x05,0x01
000220  5dd1015e          DCB      0x5d,0xd1,0x01,0x5e
000224  0c015f3c          DCB      0x0c,0x01,0x5f,0x3c
000228  01600001          DCB      0x01,0x60,0x00,0x01
00022c  61d00162          DCB      0x61,0xd0,0x01,0x62
000230  0b016303          DCB      0x0b,0x01,0x63,0x03
000234  01642801          DCB      0x01,0x64,0x28,0x01
000238  65100166          DCB      0x65,0x10,0x01,0x66
00023c  2a016739          DCB      0x2a,0x01,0x67,0x39
000240  01680b01          DCB      0x01,0x68,0x0b,0x01
000244  6902016a          DCB      0x69,0x02,0x01,0x6a
000248  28016b10          DCB      0x28,0x01,0x6b,0x10
00024c  016c2a01          DCB      0x01,0x6c,0x2a,0x01
000250  6d61016e          DCB      0x6d,0x61,0x01,0x6e
000254  0c016f00          DCB      0x0c,0x01,0x6f,0x00
000258  01700f01          DCB      0x01,0x70,0x0f,0x01
00025c  71790172          DCB      0x71,0x79,0x01,0x72
000260  0001730b          DCB      0x00,0x01,0x73,0x0b
000264  01740001          DCB      0x01,0x74,0x00,0x01
000268  750b0176          DCB      0x75,0x0b,0x01,0x76
00026c  000177a1          DCB      0x00,0x01,0x77,0xa1
000270  01780001          DCB      0x01,0x78,0x00,0x01
000274  79a0017a          DCB      0x79,0xa0,0x01,0x7a
000278  00017b04          DCB      0x00,0x01,0x7b,0x04
00027c  01ff0401          DCB      0x01,0xff,0x04,0x01
000280  791d017b          DCB      0x79,0x1d,0x01,0x7b
000284  2701960e          DCB      0x27,0x01,0x96,0x0e
000288  0197fe01          DCB      0x01,0x97,0xfe,0x01
00028c  98030199          DCB      0x98,0x03,0x01,0x99
000290  ef019a02          DCB      0xef,0x01,0x9a,0x02
000294  019b4401          DCB      0x01,0x9b,0x44,0x01
000298  73070170          DCB      0x73,0x07,0x01,0x70
00029c  0101ff01          DCB      0x01,0x01,0xff,0x01
0002a0  01000101          DCB      0x01,0x00,0x01,0x01
0002a4  ff000000          DCB      0xff,0x00,0x00,0x00
0002a8  00                DCB      0x00
