; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\adc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\adc.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\adc.crf ..\..\common\src\BSP\Driver\Source\adc.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  adcISR PROC
;;;724     */
;;;725    void adcISR(void)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;726    {
;;;727        unsigned int isr,ier,wkisr,conf;
;;;728        conf=inpw(REG_ADC_CONF);
000004  e59f0edc          LDR      r0,|L1.3816|
000008  e5906004          LDR      r6,[r0,#4]
;;;729        isr=inpw(REG_ADC_ISR);
00000c  e590400c          LDR      r4,[r0,#0xc]
;;;730        ier=inpw(REG_ADC_IER);
000010  e5905008          LDR      r5,[r0,#8]
;;;731        wkisr=inpw(REG_ADC_WKISR);
000014  e5909010          LDR      r9,[r0,#0x10]
;;;732        //sysprintf("ADC_IRQHandler Interrupt(0x%08x): ",isr);
;;;733        DbgPrintf("REG_ADC_CTL=0x%08x\n",inpw(REG_ADC_CTL));
;;;734        DbgPrintf("REG_ADC_IER=0x%08x\n",inpw(REG_ADC_IER));
;;;735        DbgPrintf("REG_ADC_ISR=0x%08x\n",inpw(REG_ADC_ISR));
;;;736        DbgPrintf("REG_ADC_WKISR=0x%08x\n",inpw(REG_ADC_WKISR));
;;;737        DbgPrintf("SYS_WKUPSSR=0x%08x\n",inpw(REG_SYS_WKUPSSR));
;;;738        DbgPrintf("SYS_WKUPSER=0x%08x\n",inpw(REG_SYS_WKUPSER));
;;;739        DbgPrintf("REG_ADC_CONF=0x%08x\n",inpw(REG_ADC_CONF));
;;;740        
;;;741        if(isr & ADC_ISR_SELFTF) {
000018  e3140a02          TST      r4,#0x2000
00001c  0a000002          BEQ      |L1.44|
;;;742            outpw(REG_ADC_ISR,ADC_ISR_SELFTF);
000020  e3a00a02          MOV      r0,#0x2000
000024  e59f1ebc          LDR      r1,|L1.3816|
000028  e581000c          STR      r0,[r1,#0xc]
                  |L1.44|
;;;743            DbgPrintf("menu self-test complete\n");
;;;744        }
;;;745    
;;;746        if(isr & ADC_ISR_TF) {
00002c  e3140c01          TST      r4,#0x100
000030  0a00003a          BEQ      |L1.288|
;;;747            unsigned int value;
;;;748            INT32 tailX, lengthX;
;;;749            INT32 tailY, lengthY;
;;;750            INT16 *fifoX, *fifoY;
;;;751            tailX   = adcHandler.fifoTailX;
000034  e59f0eb0          LDR      r0,|L1.3820|
000038  e590715c          LDR      r7,[r0,#0x15c]  ; adcHandler
;;;752            lengthX = adcHandler.fifoLengthX;
00003c  e590b160          LDR      r11,[r0,#0x160]  ; adcHandler
;;;753            tailY   = adcHandler.fifoTailY;
000040  e5908268          LDR      r8,[r0,#0x268]  ; adcHandler
;;;754            lengthY = adcHandler.fifoLengthY;
000044  e590026c          LDR      r0,[r0,#0x26c]  ; adcHandler
000048  e58d000c          STR      r0,[sp,#0xc]
;;;755            fifoX  = adcHandler.fifoX;
00004c  e59f0e9c          LDR      r0,|L1.3824|
000050  e58d0008          STR      r0,[sp,#8]
;;;756            fifoY  = adcHandler.fifoY;
000054  e2800f43          ADD      r0,r0,#0x10c
000058  e58d0004          STR      r0,[sp,#4]
;;;757            outpw(REG_ADC_ISR,ADC_ISR_TF); //Clear TF flags
00005c  e3a00c01          MOV      r0,#0x100
000060  e59f1e80          LDR      r1,|L1.3816|
000064  e581000c          STR      r0,[r1,#0xc]
;;;758            value = inpw(REG_ADC_XYDATA);
000068  e1c10000          BIC      r0,r1,r0
00006c  e590a020          LDR      r10,[r0,#0x20]
;;;759            if(adcHandler.touch_callback!=NULL)
000070  e59f0e74          LDR      r0,|L1.3820|
000074  e5900000          LDR      r0,[r0,#0]  ; adcHandler
000078  e3500000          CMP      r0,#0
00007c  0a000004          BEQ      |L1.148|
;;;760                adcHandler.touch_callback(value, adcHandler.touch_userData);
000080  e59f0e64          LDR      r0,|L1.3820|
000084  e5901004          LDR      r1,[r0,#4]  ; adcHandler
000088  e5902000          LDR      r2,[r0,#0]  ; adcHandler
00008c  e1a0000a          MOV      r0,r10
000090  e12fff32          BLX      r2
                  |L1.148|
;;;761    
;;;762            if ( (lengthX<ADC_FIFO_LENGTH) && (lengthY<ADC_FIFO_LENGTH)) {
000094  e35b0080          CMP      r11,#0x80
000098  aa000018          BGE      |L1.256|
00009c  e59d000c          LDR      r0,[sp,#0xc]
0000a0  e3500080          CMP      r0,#0x80
0000a4  aa000015          BGE      |L1.256|
;;;763                fifoX[tailX] = value & 0xFFF;
0000a8  e1a01a0a          LSL      r1,r10,#20
0000ac  e1a01a21          LSR      r1,r1,#20
0000b0  e59d0008          LDR      r0,[sp,#8]
0000b4  e0800087          ADD      r0,r0,r7,LSL #1
0000b8  e1c010b0          STRH     r1,[r0,#0]
;;;764                lengthX++;
0000bc  e28bb001          ADD      r11,r11,#1
;;;765                tailX++;
0000c0  e2877001          ADD      r7,r7,#1
;;;766                if (tailX == ADC_FIFO_LENGTH) tailX = 0;
0000c4  e3570080          CMP      r7,#0x80
0000c8  1a000000          BNE      |L1.208|
0000cc  e3a07000          MOV      r7,#0
                  |L1.208|
;;;767    
;;;768                fifoY[tailY] = (value >>16) & 0xFFF;
0000d0  e59f0e1c          LDR      r0,|L1.3828|
0000d4  e000182a          AND      r1,r0,r10,LSR #16
0000d8  e59d0004          LDR      r0,[sp,#4]
0000dc  e0800088          ADD      r0,r0,r8,LSL #1
0000e0  e1c010b0          STRH     r1,[r0,#0]
;;;769                lengthY++;
0000e4  e59d000c          LDR      r0,[sp,#0xc]
0000e8  e2800001          ADD      r0,r0,#1
0000ec  e58d000c          STR      r0,[sp,#0xc]
;;;770                tailY++;
0000f0  e2888001          ADD      r8,r8,#1
;;;771                if (tailY == ADC_FIFO_LENGTH) tailY = 0;
0000f4  e3580080          CMP      r8,#0x80
0000f8  1a000000          BNE      |L1.256|
0000fc  e3a08000          MOV      r8,#0
                  |L1.256|
;;;772            }
;;;773            /* Update FIFO status */
;;;774            adcHandler.fifoTailX = tailX;
000100  e59f0de4          LDR      r0,|L1.3820|
000104  e580715c          STR      r7,[r0,#0x15c]  ; adcHandler
;;;775            adcHandler.fifoLengthX = lengthX;
000108  e580b160          STR      r11,[r0,#0x160]  ; adcHandler
;;;776            adcHandler.fifoTailY = tailY;
00010c  e5808268          STR      r8,[r0,#0x268]  ; adcHandler
;;;777            adcHandler.fifoLengthY = lengthY;
000110  e2801000          ADD      r1,r0,#0
000114  e59d000c          LDR      r0,[sp,#0xc]
000118  e581026c          STR      r0,[r1,#0x26c]  ; adcHandler
;;;778            DbgPrintf("touch detect complete\n");
;;;779        }
00011c  e1a00000          MOV      r0,r0
                  |L1.288|
;;;780    
;;;781        if((isr & ADC_ISR_KPEF) && (ier & ADC_IER_KPEIEN)) {
000120  e3140002          TST      r4,#2
000124  0a00000d          BEQ      |L1.352|
000128  e3150002          TST      r5,#2
00012c  0a00000b          BEQ      |L1.352|
;;;782            outpw(REG_ADC_ISR,ADC_ISR_KPEF);
000130  e3a00002          MOV      r0,#2
000134  e59f1dac          LDR      r1,|L1.3816|
000138  e581000c          STR      r0,[r1,#0xc]
;;;783            if(adcHandler.keypad_press_callback!=NULL)
00013c  e59f0da8          LDR      r0,|L1.3820|
000140  e5900030          LDR      r0,[r0,#0x30]  ; adcHandler
000144  e3500000          CMP      r0,#0
000148  0a000004          BEQ      |L1.352|
;;;784                adcHandler.keypad_press_callback(1, adcHandler.keypad_press_userData);
00014c  e59f0d98          LDR      r0,|L1.3820|
000150  e5901034          LDR      r1,[r0,#0x34]  ; adcHandler
000154  e5902030          LDR      r2,[r0,#0x30]  ; adcHandler
000158  e3a00001          MOV      r0,#1
00015c  e12fff32          BLX      r2
                  |L1.352|
;;;785            DbgPrintf("key press complete\n");
;;;786        }
;;;787    
;;;788        if((isr & ADC_ISR_ZF) && (conf & ADC_CONF_ZEN)) {
000160  e3140c02          TST      r4,#0x200
000164  0a00004d          BEQ      |L1.672|
000168  e3160002          TST      r6,#2
00016c  0a00004b          BEQ      |L1.672|
;;;789            unsigned int value;
;;;790            volatile INT32 tailZ1, lengthZ1;
;;;791            volatile INT32 tailZ2, lengthZ2;
;;;792            volatile INT16 *fifoZ1, *fifoZ2;
;;;793            tailZ1   = adcHandler.fifoTailZ1;
000170  e59f0d74          LDR      r0,|L1.3820|
000174  e5900374          LDR      r0,[r0,#0x374]  ; adcHandler
000178  e58d000c          STR      r0,[sp,#0xc]
;;;794            lengthZ1 = adcHandler.fifoLengthZ1;
00017c  e59f0d68          LDR      r0,|L1.3820|
000180  e5900378          LDR      r0,[r0,#0x378]  ; adcHandler
000184  e58d0008          STR      r0,[sp,#8]
;;;795            tailZ2   = adcHandler.fifoTailZ2;
000188  e59f0d5c          LDR      r0,|L1.3820|
00018c  e5900480          LDR      r0,[r0,#0x480]
000190  e58d0004          STR      r0,[sp,#4]
;;;796            lengthZ2 = adcHandler.fifoLengthZ2;
000194  e59f0d50          LDR      r0,|L1.3820|
000198  e5900484          LDR      r0,[r0,#0x484]
00019c  e58d0000          STR      r0,[sp,#0]
;;;797    
;;;798            fifoZ1  = adcHandler.fifoZ1;
0001a0  e59f8d50          LDR      r8,|L1.3832|
;;;799            fifoZ2  = adcHandler.fifoZ2;
0001a4  e288af43          ADD      r10,r8,#0x10c
;;;800            outpw(REG_ADC_ISR,ADC_ISR_ZF); //clear TF flags
0001a8  e3a00c02          MOV      r0,#0x200
0001ac  e59f1d34          LDR      r1,|L1.3816|
0001b0  e581000c          STR      r0,[r1,#0xc]
;;;801            value = inpw(REG_ADC_ZDATA);
0001b4  e1c10000          BIC      r0,r1,r0
0001b8  e5907024          LDR      r7,[r0,#0x24]
;;;802            if(adcHandler.touchz_callback!=NULL)
0001bc  e24a0fdf          SUB      r0,r10,#0x37c
0001c0  e5900008          LDR      r0,[r0,#8]  ; adcHandler
0001c4  e3500000          CMP      r0,#0
0001c8  0a000004          BEQ      |L1.480|
;;;803                adcHandler.touchz_callback(value, adcHandler.touchz_userData);
0001cc  e24a0fdf          SUB      r0,r10,#0x37c
0001d0  e590100c          LDR      r1,[r0,#0xc]  ; adcHandler
0001d4  e5902008          LDR      r2,[r0,#8]  ; adcHandler
0001d8  e1a00007          MOV      r0,r7
0001dc  e12fff32          BLX      r2
                  |L1.480|
;;;804            if ( (lengthZ1<ADC_FIFO_LENGTH) && (lengthZ2<ADC_FIFO_LENGTH)) {
0001e0  e59d0008          LDR      r0,[sp,#8]
0001e4  e3500080          CMP      r0,#0x80
0001e8  aa000022          BGE      |L1.632|
0001ec  e59d0000          LDR      r0,[sp,#0]
0001f0  e3500080          CMP      r0,#0x80
0001f4  aa00001f          BGE      |L1.632|
;;;805                fifoZ1[tailZ1] = value & 0xFFF;
0001f8  e1a00a07          LSL      r0,r7,#20
0001fc  e1a00a20          LSR      r0,r0,#20
000200  e59d100c          LDR      r1,[sp,#0xc]
000204  e0881081          ADD      r1,r8,r1,LSL #1
000208  e1c100b0          STRH     r0,[r1,#0]
;;;806                lengthZ1++;
00020c  e59d0008          LDR      r0,[sp,#8]
000210  e2800001          ADD      r0,r0,#1
000214  e58d0008          STR      r0,[sp,#8]
;;;807                tailZ1++;
000218  e59d000c          LDR      r0,[sp,#0xc]
00021c  e2800001          ADD      r0,r0,#1
000220  e58d000c          STR      r0,[sp,#0xc]
;;;808                if (tailZ1 == ADC_FIFO_LENGTH) tailZ1 = 0;
000224  e59d000c          LDR      r0,[sp,#0xc]
000228  e3500080          CMP      r0,#0x80
00022c  1a000001          BNE      |L1.568|
000230  e3a00000          MOV      r0,#0
000234  e58d000c          STR      r0,[sp,#0xc]
                  |L1.568|
;;;809    
;;;810                fifoZ2[tailZ2] = (value >>16) & 0xFFF;
000238  e59f0cb4          LDR      r0,|L1.3828|
00023c  e0000827          AND      r0,r0,r7,LSR #16
000240  e59d1004          LDR      r1,[sp,#4]
000244  e08a1081          ADD      r1,r10,r1,LSL #1
000248  e1c100b0          STRH     r0,[r1,#0]
;;;811                lengthZ2++;
00024c  e59d0000          LDR      r0,[sp,#0]
000250  e2800001          ADD      r0,r0,#1
000254  e58d0000          STR      r0,[sp,#0]
;;;812                tailZ2++;
000258  e59d0004          LDR      r0,[sp,#4]
00025c  e2800001          ADD      r0,r0,#1
000260  e58d0004          STR      r0,[sp,#4]
;;;813                if (tailZ2 == ADC_FIFO_LENGTH) tailZ2 = 0;
000264  e59d0004          LDR      r0,[sp,#4]
000268  e3500080          CMP      r0,#0x80
00026c  1a000001          BNE      |L1.632|
000270  e3a00000          MOV      r0,#0
000274  e58d0004          STR      r0,[sp,#4]
                  |L1.632|
;;;814            }
;;;815            /* Update FIFO status */
;;;816            adcHandler.fifoTailZ1 = tailZ1;
000278  e59f1c6c          LDR      r1,|L1.3820|
00027c  e59d000c          LDR      r0,[sp,#0xc]
000280  e5810374          STR      r0,[r1,#0x374]  ; adcHandler
;;;817            adcHandler.fifoLengthZ1 = lengthZ1;
000284  e59d0008          LDR      r0,[sp,#8]
000288  e5810378          STR      r0,[r1,#0x378]  ; adcHandler
;;;818            adcHandler.fifoTailZ2 = tailZ2;
00028c  e59d0004          LDR      r0,[sp,#4]
000290  e5810480          STR      r0,[r1,#0x480]
;;;819            adcHandler.fifoLengthZ2 = lengthZ2;
000294  e59d0000          LDR      r0,[sp,#0]
000298  e5810484          STR      r0,[r1,#0x484]
;;;820            DbgPrintf("z conversion complete\n");
;;;821        }
00029c  e1a00000          MOV      r0,r0
                  |L1.672|
;;;822    
;;;823        if((isr & ADC_ISR_NACF) && (conf & ADC_CONF_NACEN)) {
0002a0  e3140b01          TST      r4,#0x400
0002a4  0a00000f          BEQ      |L1.744|
0002a8  e3160004          TST      r6,#4
0002ac  0a00000d          BEQ      |L1.744|
;;;824            outpw(REG_ADC_ISR,ADC_ISR_NACF);
0002b0  e3a00b01          MOV      r0,#0x400
0002b4  e59f1c2c          LDR      r1,|L1.3816|
0002b8  e581000c          STR      r0,[r1,#0xc]
;;;825            if(adcHandler.normal_callback!=NULL)
0002bc  e59f0c28          LDR      r0,|L1.3820|
0002c0  e5900050          LDR      r0,[r0,#0x50]  ; adcHandler
0002c4  e3500000          CMP      r0,#0
0002c8  0a000006          BEQ      |L1.744|
;;;826                adcHandler.normal_callback(inpw(REG_ADC_DATA), adcHandler.normal_userData);
0002cc  e59f3c18          LDR      r3,|L1.3820|
0002d0  e5931054          LDR      r1,[r3,#0x54]  ; adcHandler
0002d4  e59f3c0c          LDR      r3,|L1.3816|
0002d8  e5930028          LDR      r0,[r3,#0x28]
0002dc  e59f3c08          LDR      r3,|L1.3820|
0002e0  e5932050          LDR      r2,[r3,#0x50]  ; adcHandler
0002e4  e12fff32          BLX      r2
                  |L1.744|
;;;827            DbgPrintf("normal AD conversion complete\n");
;;;828        }
;;;829    
;;;830        if((isr & ADC_ISR_VBF) && (conf & ADC_CONF_VBATEN)) {
0002e8  e3140b02          TST      r4,#0x800
0002ec  0a00000f          BEQ      |L1.816|
0002f0  e3160c01          TST      r6,#0x100
0002f4  0a00000d          BEQ      |L1.816|
;;;831            if(adcHandler.voltage_battery_callback!=NULL)
0002f8  e59f0bec          LDR      r0,|L1.3820|
0002fc  e5900048          LDR      r0,[r0,#0x48]  ; adcHandler
000300  e3500000          CMP      r0,#0
000304  0a000006          BEQ      |L1.804|
;;;832                adcHandler.voltage_battery_callback(inpw(REG_ADC_VBADATA), adcHandler.voltage_battery_userData);
000308  e59f3bdc          LDR      r3,|L1.3820|
00030c  e593104c          LDR      r1,[r3,#0x4c]  ; adcHandler
000310  e59f3bd0          LDR      r3,|L1.3816|
000314  e593002c          LDR      r0,[r3,#0x2c]
000318  e59f3bcc          LDR      r3,|L1.3820|
00031c  e5932048          LDR      r2,[r3,#0x48]  ; adcHandler
000320  e12fff32          BLX      r2
                  |L1.804|
;;;833            outpw(REG_ADC_ISR,ADC_ISR_VBF);
000324  e3a00b02          MOV      r0,#0x800
000328  e59f1bb8          LDR      r1,|L1.3816|
00032c  e581000c          STR      r0,[r1,#0xc]
                  |L1.816|
;;;834            DbgPrintf("bettery volage complete\n");
;;;835        }
;;;836    
;;;837        if((isr & ADC_ISR_KPCF)&& (conf & ADC_CONF_KPCEN)) {
000330  e3140a01          TST      r4,#0x1000
000334  0a000010          BEQ      |L1.892|
000338  e3160c02          TST      r6,#0x200
00033c  0a00000e          BEQ      |L1.892|
;;;838            unsigned int value;
;;;839            outpw(REG_ADC_ISR,ADC_ISR_KPCF);
000340  e3a00a01          MOV      r0,#0x1000
000344  e59f1b9c          LDR      r1,|L1.3816|
000348  e581000c          STR      r0,[r1,#0xc]
;;;840            value=inpw(REG_ADC_KPDATA);
00034c  e1c10000          BIC      r0,r1,r0
000350  e5907030          LDR      r7,[r0,#0x30]
;;;841            if(adcHandler.keypad_conv_callback!=NULL)
000354  e59f0b90          LDR      r0,|L1.3820|
000358  e5900028          LDR      r0,[r0,#0x28]  ; adcHandler
00035c  e3500000          CMP      r0,#0
000360  0a000004          BEQ      |L1.888|
;;;842                adcHandler.keypad_conv_callback(value, adcHandler.keypad_conv_userData);
000364  e59f0b80          LDR      r0,|L1.3820|
000368  e590102c          LDR      r1,[r0,#0x2c]  ; adcHandler
00036c  e5902028          LDR      r2,[r0,#0x28]  ; adcHandler
000370  e1a00007          MOV      r0,r7
000374  e12fff32          BLX      r2
                  |L1.888|
;;;843            DbgPrintf("Menu Keypad Press Conversion Finish\n");
;;;844        }
000378  e1a00000          MOV      r0,r0
                  |L1.892|
;;;845    
;;;846        if((isr & ADC_ISR_KPUEF) && (ier & ADC_IER_KPUEIEN)) {
00037c  e3140008          TST      r4,#8
000380  0a00000d          BEQ      |L1.956|
000384  e3150020          TST      r5,#0x20
000388  0a00000b          BEQ      |L1.956|
;;;847            outpw(REG_ADC_ISR,ADC_ISR_KPUEF);
00038c  e3a00008          MOV      r0,#8
000390  e59f1b50          LDR      r1,|L1.3816|
000394  e581000c          STR      r0,[r1,#0xc]
;;;848            if(adcHandler.keypad_up_callback!=NULL)
000398  e59f0b4c          LDR      r0,|L1.3820|
00039c  e5900038          LDR      r0,[r0,#0x38]  ; adcHandler
0003a0  e3500000          CMP      r0,#0
0003a4  0a000004          BEQ      |L1.956|
;;;849                adcHandler.keypad_up_callback(0, adcHandler.keypad_press_userData);
0003a8  e59f0b3c          LDR      r0,|L1.3820|
0003ac  e5901034          LDR      r1,[r0,#0x34]  ; adcHandler
0003b0  e5902038          LDR      r2,[r0,#0x38]  ; adcHandler
0003b4  e3a00000          MOV      r0,#0
0003b8  e12fff32          BLX      r2
                  |L1.956|
;;;850            DbgPrintf("keypad up\n");
;;;851        }
;;;852    
;;;853        if((isr & ADC_ISR_PEUEF) && (ier & ADC_IER_PEUEIEN)) {
0003bc  e3140010          TST      r4,#0x10
0003c0  0a000005          BEQ      |L1.988|
0003c4  e3150040          TST      r5,#0x40
0003c8  0a000003          BEQ      |L1.988|
;;;854            outpw(REG_ADC_ISR,ADC_ISR_PEUEF | ADC_ISR_PEDEF);
0003cc  e3a00014          MOV      r0,#0x14
0003d0  e59f1b10          LDR      r1,|L1.3816|
0003d4  e581000c          STR      r0,[r1,#0xc]
0003d8  ea00000f          B        |L1.1052|
                  |L1.988|
;;;855            DbgPrintf("menu pen up complete\n");
;;;856        } else if((isr & ADC_ISR_PEDEF) && (isr & ADC_IER_PEDEIEN)) {
0003dc  e3140004          TST      r4,#4
0003e0  0a00000d          BEQ      |L1.1052|
0003e4  e3140004          TST      r4,#4
0003e8  0a00000b          BEQ      |L1.1052|
;;;857            if(adcHandler.pendown_callback!=NULL)
0003ec  e59f0af8          LDR      r0,|L1.3820|
0003f0  e5900018          LDR      r0,[r0,#0x18]  ; adcHandler
0003f4  e3500000          CMP      r0,#0
0003f8  0a000004          BEQ      |L1.1040|
;;;858                adcHandler.pendown_callback(isr, adcHandler.pendown_userData);
0003fc  e59f0ae8          LDR      r0,|L1.3820|
000400  e590101c          LDR      r1,[r0,#0x1c]  ; adcHandler
000404  e5902018          LDR      r2,[r0,#0x18]  ; adcHandler
000408  e1a00004          MOV      r0,r4
00040c  e12fff32          BLX      r2
                  |L1.1040|
;;;859            outpw(REG_ADC_ISR,ADC_ISR_PEUEF | ADC_ISR_PEDEF);
000410  e3a00014          MOV      r0,#0x14
000414  e59f1acc          LDR      r1,|L1.3816|
000418  e581000c          STR      r0,[r1,#0xc]
                  |L1.1052|
;;;860            DbgPrintf("pen down complete\n");
;;;861        }
;;;862    
;;;863        if(isr & ADC_ISR_MF) {
00041c  e3140001          TST      r4,#1
000420  0a000004          BEQ      |L1.1080|
;;;864            outpw(REG_ADC_ISR,ADC_ISR_MF);
000424  e3a00001          MOV      r0,#1
000428  e59f1ab8          LDR      r1,|L1.3816|
00042c  e581000c          STR      r0,[r1,#0xc]
;;;865            mst_complete=1;
000430  e59f1ac4          LDR      r1,|L1.3836|
000434  e5810000          STR      r0,[r1,#0]  ; mst_complete
                  |L1.1080|
;;;866            DbgPrintf("menu complete\n");
;;;867        }
;;;868    
;;;869        if((wkisr & ADC_WKISR_WKPEF) && (ier & ADC_IER_WKPIEN)) {
000438  e3190001          TST      r9,#1
00043c  0a000014          BEQ      |L1.1172|
000440  e3150010          TST      r5,#0x10
000444  0a000012          BEQ      |L1.1172|
;;;870            if(adcHandler.keypad_wakeup_callback!=NULL)
000448  e59f0a9c          LDR      r0,|L1.3820|
00044c  e5900040          LDR      r0,[r0,#0x40]  ; adcHandler
000450  e3500000          CMP      r0,#0
000454  0a000004          BEQ      |L1.1132|
;;;871                adcHandler.keypad_wakeup_callback(wkisr, adcHandler.keypad_wakeup_userData);
000458  e59f0a8c          LDR      r0,|L1.3820|
00045c  e5901044          LDR      r1,[r0,#0x44]  ; adcHandler
000460  e5902040          LDR      r2,[r0,#0x40]  ; adcHandler
000464  e1a00009          MOV      r0,r9
000468  e12fff32          BLX      r2
                  |L1.1132|
;;;872            outpw(REG_ADC_WKISR,ADC_WKISR_WKPEF);
00046c  e3a00001          MOV      r0,#1
000470  e59f1a70          LDR      r1,|L1.3816|
000474  e5810010          STR      r0,[r1,#0x10]
;;;873    
;;;874            if(inpw(REG_SYS_WKUPSSR) & (1<<26))
000478  e3a0020b          MOV      r0,#0xb0000000
00047c  e590005c          LDR      r0,[r0,#0x5c]
000480  e3100301          TST      r0,#0x4000000
000484  0a000002          BEQ      |L1.1172|
;;;875                outpw(REG_SYS_WKUPSSR,(1<<26));
000488  e3a00301          MOV      r0,#0x4000000
00048c  e3a0120b          MOV      r1,#0xb0000000
000490  e581005c          STR      r0,[r1,#0x5c]
                  |L1.1172|
;;;876            DbgPrintf("key press event wakeup\n");
;;;877        }
;;;878    
;;;879        if((wkisr & ADC_WKISR_WPEDEF) && (ier & ADC_IER_WKTIEN) ) {
000494  e3190002          TST      r9,#2
000498  0a000014          BEQ      |L1.1264|
00049c  e3150008          TST      r5,#8
0004a0  0a000012          BEQ      |L1.1264|
;;;880            if(adcHandler.touch_wakeup_callback!=NULL)
0004a4  e59f0a40          LDR      r0,|L1.3820|
0004a8  e5900010          LDR      r0,[r0,#0x10]  ; adcHandler
0004ac  e3500000          CMP      r0,#0
0004b0  0a000004          BEQ      |L1.1224|
;;;881                adcHandler.touch_wakeup_callback(wkisr, adcHandler.touch_wakeup_userData);
0004b4  e59f0a30          LDR      r0,|L1.3820|
0004b8  e5901014          LDR      r1,[r0,#0x14]  ; adcHandler
0004bc  e5902010          LDR      r2,[r0,#0x10]  ; adcHandler
0004c0  e1a00009          MOV      r0,r9
0004c4  e12fff32          BLX      r2
                  |L1.1224|
;;;882            outpw(REG_ADC_WKISR,ADC_WKISR_WPEDEF);
0004c8  e3a00002          MOV      r0,#2
0004cc  e59f1a14          LDR      r1,|L1.3816|
0004d0  e5810010          STR      r0,[r1,#0x10]
;;;883            if(inpw(REG_SYS_WKUPSSR) & (1<<26))
0004d4  e3a0020b          MOV      r0,#0xb0000000
0004d8  e590005c          LDR      r0,[r0,#0x5c]
0004dc  e3100301          TST      r0,#0x4000000
0004e0  0a000002          BEQ      |L1.1264|
;;;884                outpw(REG_SYS_WKUPSSR,(1<<26));
0004e4  e3a00301          MOV      r0,#0x4000000
0004e8  e3a0120b          MOV      r1,#0xb0000000
0004ec  e581005c          STR      r0,[r1,#0x5c]
                  |L1.1264|
;;;885            DbgPrintf("pen down event wakeup\n");
;;;886        }
;;;887    }
0004f0  e8bd9fff          POP      {r0-r12,pc}
;;;888    
                          ENDP

                  adcOpen PROC
;;;97      */
;;;98     INT adcOpen(void)
0004f4  e92d4010          PUSH     {r4,lr}
;;;99     {
;;;100        /* Enable ADC engine clock */
;;;101        outpw(REG_CLK_PCLKEN1, 1<<24);
0004f8  e3a00401          MOV      r0,#0x1000000
0004fc  e3a0120b          MOV      r1,#0xb0000000
000500  e581021c          STR      r0,[r1,#0x21c]
;;;102    
;;;103        /* Reset the ADC IP */
;;;104        outpw(REG_SYS_APBIPRST1, (1<<24));
000504  e5810068          STR      r0,[r1,#0x68]
;;;105        outpw(REG_SYS_APBIPRST1, 0);
000508  e3a00000          MOV      r0,#0
00050c  e5810068          STR      r0,[r1,#0x68]
;;;106    
;;;107        /* ADC Engine Clock is set to 1 MB/S */
;;;108        outpw(REG_CLK_DIVCTL7, inpw(REG_CLK_DIVCTL7) & ~((0x3<<19)|(0x7<<16)));
000510  e3a0020b          MOV      r0,#0xb0000000
000514  e590023c          LDR      r0,[r0,#0x23c]
000518  e3c0081f          BIC      r0,r0,#0x1f0000
00051c  e581023c          STR      r0,[r1,#0x23c]
;;;109        outpw(REG_CLK_DIVCTL7, (0x0<<19)|(11<<16));
000520  e3a0080b          MOV      r0,#0xb0000
000524  e581023c          STR      r0,[r1,#0x23c]
;;;110    
;;;111        /* Enable ADC Power */
;;;112        outpw(REG_ADC_CTL, ADC_CTL_ADEN);
000528  e3a00001          MOV      r0,#1
00052c  e59f19b4          LDR      r1,|L1.3816|
000530  e5810000          STR      r0,[r1,#0]
;;;113    
;;;114        /* Enable ADC to high speed mode */
;;;115        outpw(REG_ADC_CONF, inpw(REG_ADC_CONF)|ADC_CONF_HSPEED);
000534  e1c10000          BIC      r0,r1,r0
000538  e5900004          LDR      r0,[r0,#4]
00053c  e3800501          ORR      r0,r0,#0x400000
000540  e5810004          STR      r0,[r1,#4]
;;;116    
;;;117        /* Set interrupt */
;;;118        sysSetInterruptType(ADC_IRQn, HIGH_LEVEL_SENSITIVE);
000544  e3a01040          MOV      r1,#0x40
000548  e3a00012          MOV      r0,#0x12
00054c  ebfffffe          BL       sysSetInterruptType
;;;119        sysInstallISR(IRQ_LEVEL_7, ADC_IRQn, (PVOID)adcISR);
000550  e59f29a8          LDR      r2,|L1.3840|
000554  e3a01012          MOV      r1,#0x12
000558  e3a00007          MOV      r0,#7
00055c  ebfffffe          BL       sysInstallISR
;;;120        sysSetLocalInterrupt(ENABLE_IRQ);                            /* enable CPSR I bit */
000560  e3a0007f          MOV      r0,#0x7f
000564  ebfffffe          BL       sysSetLocalInterrupt
;;;121        sysEnableInterrupt(ADC_IRQn);
000568  e3a00012          MOV      r0,#0x12
00056c  ebfffffe          BL       sysEnableInterrupt
;;;122    
;;;123        /* Init the FIFO buffer */
;;;124        adcHandler.fifoHeadX = 0;
000570  e3a00000          MOV      r0,#0
000574  e59f1970          LDR      r1,|L1.3820|
000578  e5810158          STR      r0,[r1,#0x158]  ; adcHandler
;;;125        adcHandler.fifoTailX = 0;
00057c  e581015c          STR      r0,[r1,#0x15c]  ; adcHandler
;;;126        adcHandler.fifoLengthX = 0;
000580  e5810160          STR      r0,[r1,#0x160]  ; adcHandler
;;;127        adcHandler.fifoHeadY = 0;
000584  e5810264          STR      r0,[r1,#0x264]  ; adcHandler
;;;128        adcHandler.fifoTailY = 0;
000588  e5810268          STR      r0,[r1,#0x268]  ; adcHandler
;;;129        adcHandler.fifoLengthY = 0;
00058c  e581026c          STR      r0,[r1,#0x26c]  ; adcHandler
;;;130        adcHandler.fifoHeadZ1 = 0;
000590  e5810370          STR      r0,[r1,#0x370]  ; adcHandler
;;;131        adcHandler.fifoTailZ1 = 0;
000594  e5810374          STR      r0,[r1,#0x374]  ; adcHandler
;;;132        adcHandler.fifoLengthZ1 = 0;
000598  e5810378          STR      r0,[r1,#0x378]  ; adcHandler
;;;133        adcHandler.fifoHeadZ2 = 0;
00059c  e581047c          STR      r0,[r1,#0x47c]
;;;134        adcHandler.fifoTailZ2 = 0;
0005a0  e5810480          STR      r0,[r1,#0x480]
;;;135        adcHandler.fifoLengthZ2 = 0;
0005a4  e5810484          STR      r0,[r1,#0x484]
;;;136    
;;;137        adcHandler.touch_callback=NULL;
0005a8  e5810000          STR      r0,[r1,#0]  ; adcHandler
;;;138        adcHandler.touch_userData=NULL;
0005ac  e5810004          STR      r0,[r1,#4]  ; adcHandler
;;;139    
;;;140        adcHandler.touchz_callback=NULL;
0005b0  e5810008          STR      r0,[r1,#8]  ; adcHandler
;;;141        adcHandler.touchz_userData=NULL;
0005b4  e581000c          STR      r0,[r1,#0xc]  ; adcHandler
;;;142    
;;;143        adcHandler.pendown_callback=NULL;
0005b8  e5810018          STR      r0,[r1,#0x18]  ; adcHandler
;;;144        adcHandler.pendown_userData=NULL;
0005bc  e581001c          STR      r0,[r1,#0x1c]  ; adcHandler
;;;145    
;;;146        adcHandler.penup_callback=NULL;
0005c0  e5810020          STR      r0,[r1,#0x20]  ; adcHandler
;;;147        adcHandler.penup_userData=NULL;
0005c4  e5810024          STR      r0,[r1,#0x24]  ; adcHandler
;;;148    
;;;149        adcHandler.keypad_conv_callback=NULL;
0005c8  e5810028          STR      r0,[r1,#0x28]  ; adcHandler
;;;150        adcHandler.keypad_conv_userData=NULL;
0005cc  e581002c          STR      r0,[r1,#0x2c]  ; adcHandler
;;;151    
;;;152        adcHandler.keypad_press_callback=NULL;
0005d0  e5810030          STR      r0,[r1,#0x30]  ; adcHandler
;;;153        adcHandler.keypad_press_userData=NULL;
0005d4  e5810034          STR      r0,[r1,#0x34]  ; adcHandler
;;;154    
;;;155        adcHandler.keypad_up_callback=NULL;
0005d8  e5810038          STR      r0,[r1,#0x38]  ; adcHandler
;;;156        adcHandler.keypad_up_userData=NULL;
0005dc  e581003c          STR      r0,[r1,#0x3c]  ; adcHandler
;;;157    
;;;158        adcHandler.voltage_battery_callback=NULL;
0005e0  e5810048          STR      r0,[r1,#0x48]  ; adcHandler
;;;159        adcHandler.voltage_battery_userData=NULL;
0005e4  e581004c          STR      r0,[r1,#0x4c]  ; adcHandler
;;;160    
;;;161        adcHandler.normal_callback=NULL;
0005e8  e5810050          STR      r0,[r1,#0x50]  ; adcHandler
;;;162        adcHandler.normal_userData=NULL;
0005ec  e5810054          STR      r0,[r1,#0x54]  ; adcHandler
;;;163    
;;;164        return Successful;
;;;165    }
0005f0  e8bd8010          POP      {r4,pc}
;;;166    
                          ENDP

                  adcClose PROC
;;;174     */
;;;175    int adcClose(void)
0005f4  e92d4010          PUSH     {r4,lr}
;;;176    {
;;;177        /* Disable interrupt */
;;;178        sysDisableInterrupt(ADC_IRQn);
0005f8  e3a00012          MOV      r0,#0x12
0005fc  ebfffffe          BL       sysDisableInterrupt
;;;179        sysSetLocalInterrupt(DISABLE_IRQ);   /* Disable CPSR I bit */
000600  e3a00080          MOV      r0,#0x80
000604  ebfffffe          BL       sysSetLocalInterrupt
;;;180    
;;;181        /* Disable ADC Power */
;;;182        outpw(REG_ADC_CTL, inpw(REG_ADC_CTL) & ~ADC_CTL_ADEN);
000608  e59f08d8          LDR      r0,|L1.3816|
00060c  e5900000          LDR      r0,[r0,#0]
000610  e3c00001          BIC      r0,r0,#1
000614  e59f18cc          LDR      r1,|L1.3816|
000618  e5810000          STR      r0,[r1,#0]
;;;183    
;;;184        /* Disable ADC engine clock */
;;;185        outpw(REG_CLK_PCLKEN1, inpw(REG_CLK_PCLKEN1) & ~(1<<24));
00061c  e3a0020b          MOV      r0,#0xb0000000
000620  e590021c          LDR      r0,[r0,#0x21c]
000624  e3c00401          BIC      r0,r0,#0x1000000
000628  e3a0120b          MOV      r1,#0xb0000000
00062c  e581021c          STR      r0,[r1,#0x21c]
;;;186    
;;;187        return Successful;
000630  e3a00000          MOV      r0,#0
;;;188    }
000634  e8bd8010          POP      {r4,pc}
;;;189    
                          ENDP

                  adcReadXY PROC
;;;200     */
;;;201    INT adcReadXY(INT16 *bufX, INT16 *bufY,int dataCnt)
000638  e92d4070          PUSH     {r4-r6,lr}
;;;202    {
00063c  e24dd018          SUB      sp,sp,#0x18
000640  e1a03000          MOV      r3,r0
;;;203        INT32 i;
;;;204        volatile INT16 *fifoX, *fifoY;
;;;205        volatile INT32 headX, headY;
;;;206        volatile INT32 fifoLengthX, readLengthX;
;;;207        volatile INT32 fifoLengthY, readLengthY;
;;;208    
;;;209        fifoX = adcHandler.fifoX;
000644  e59fc8a4          LDR      r12,|L1.3824|
;;;210        fifoY = adcHandler.fifoY;
000648  e28c4f43          ADD      r4,r12,#0x10c
;;;211        headX = adcHandler.fifoHeadX;
00064c  e24c5058          SUB      r5,r12,#0x58
000650  e5955158          LDR      r5,[r5,#0x158]  ; adcHandler
000654  e58d5014          STR      r5,[sp,#0x14]
;;;212        headY = adcHandler.fifoHeadY;
000658  e24c5058          SUB      r5,r12,#0x58
00065c  e5955264          LDR      r5,[r5,#0x264]  ; adcHandler
000660  e58d5010          STR      r5,[sp,#0x10]
;;;213        fifoLengthX = adcHandler.fifoLengthX;
000664  e24c5058          SUB      r5,r12,#0x58
000668  e5955160          LDR      r5,[r5,#0x160]  ; adcHandler
00066c  e58d500c          STR      r5,[sp,#0xc]
;;;214        fifoLengthY = adcHandler.fifoLengthY;
000670  e24c5058          SUB      r5,r12,#0x58
000674  e595526c          LDR      r5,[r5,#0x26c]  ; adcHandler
000678  e58d5004          STR      r5,[sp,#4]
;;;215    
;;;216        readLengthX = 0;
00067c  e3a05000          MOV      r5,#0
000680  e58d5008          STR      r5,[sp,#8]
;;;217        readLengthY = 0;
000684  e58d5000          STR      r5,[sp,#0]
;;;218    
;;;219        for (i = 0; i < dataCnt; i++) {
000688  e3a00000          MOV      r0,#0
00068c  ea000016          B        |L1.1772|
                  |L1.1680|
;;;220            if (fifoLengthX > readLengthX) {
000690  e59d500c          LDR      r5,[sp,#0xc]
000694  e59d6008          LDR      r6,[sp,#8]
000698  e1550006          CMP      r5,r6
00069c  da000010          BLE      |L1.1764|
;;;221                bufX[i] = fifoX[headX];
0006a0  e59d5014          LDR      r5,[sp,#0x14]
0006a4  e08c5085          ADD      r5,r12,r5,LSL #1
0006a8  e1d550b0          LDRH     r5,[r5,#0]
0006ac  e0836080          ADD      r6,r3,r0,LSL #1
0006b0  e1c650b0          STRH     r5,[r6,#0]
;;;222                readLengthX++;
0006b4  e59d5008          LDR      r5,[sp,#8]
0006b8  e2855001          ADD      r5,r5,#1
0006bc  e58d5008          STR      r5,[sp,#8]
;;;223                headX++;
0006c0  e59d5014          LDR      r5,[sp,#0x14]
0006c4  e2855001          ADD      r5,r5,#1
0006c8  e58d5014          STR      r5,[sp,#0x14]
;;;224                if (headX >= ADC_FIFO_LENGTH) {
0006cc  e59d5014          LDR      r5,[sp,#0x14]
0006d0  e3550080          CMP      r5,#0x80
0006d4  ba000003          BLT      |L1.1768|
;;;225                    headX = 0;
0006d8  e3a05000          MOV      r5,#0
0006dc  e58d5014          STR      r5,[sp,#0x14]
0006e0  ea000000          B        |L1.1768|
                  |L1.1764|
;;;226                }
;;;227            } else {
;;;228                /* FIFO is empty, just return */
;;;229                break;
0006e4  ea000002          B        |L1.1780|
                  |L1.1768|
0006e8  e2800001          ADD      r0,r0,#1              ;219
                  |L1.1772|
0006ec  e1500002          CMP      r0,r2                 ;219
0006f0  baffffe6          BLT      |L1.1680|
                  |L1.1780|
0006f4  e1a00000          MOV      r0,r0
;;;230            }
;;;231        }
;;;232    
;;;233        for (i = 0; i < dataCnt; i++) {
0006f8  e3a00000          MOV      r0,#0
0006fc  ea000016          B        |L1.1884|
                  |L1.1792|
;;;234            if (fifoLengthY > readLengthY) {
000700  e59d5004          LDR      r5,[sp,#4]
000704  e59d6000          LDR      r6,[sp,#0]
000708  e1550006          CMP      r5,r6
00070c  da000010          BLE      |L1.1876|
;;;235                bufY[i] = fifoY[headY];
000710  e59d5010          LDR      r5,[sp,#0x10]
000714  e0845085          ADD      r5,r4,r5,LSL #1
000718  e1d550b0          LDRH     r5,[r5,#0]
00071c  e0816080          ADD      r6,r1,r0,LSL #1
000720  e1c650b0          STRH     r5,[r6,#0]
;;;236                readLengthY++;
000724  e59d5000          LDR      r5,[sp,#0]
000728  e2855001          ADD      r5,r5,#1
00072c  e58d5000          STR      r5,[sp,#0]
;;;237                headY++;
000730  e59d5010          LDR      r5,[sp,#0x10]
000734  e2855001          ADD      r5,r5,#1
000738  e58d5010          STR      r5,[sp,#0x10]
;;;238                if (headY >= ADC_FIFO_LENGTH) {
00073c  e59d5010          LDR      r5,[sp,#0x10]
000740  e3550080          CMP      r5,#0x80
000744  ba000003          BLT      |L1.1880|
;;;239                    headY = 0;
000748  e3a05000          MOV      r5,#0
00074c  e58d5010          STR      r5,[sp,#0x10]
000750  ea000000          B        |L1.1880|
                  |L1.1876|
;;;240                }
;;;241            } else {
;;;242                /* FIFO is empty, just return */
;;;243                break;
000754  ea000002          B        |L1.1892|
                  |L1.1880|
000758  e2800001          ADD      r0,r0,#1              ;233
                  |L1.1884|
00075c  e1500002          CMP      r0,r2                 ;233
000760  baffffe6          BLT      |L1.1792|
                  |L1.1892|
000764  e1a00000          MOV      r0,r0
;;;244            }
;;;245        }
;;;246    
;;;247        /* Update FIFO information */
;;;248        adcHandler.fifoHeadX = headX;
000768  e59f677c          LDR      r6,|L1.3820|
00076c  e59d5014          LDR      r5,[sp,#0x14]
000770  e5865158          STR      r5,[r6,#0x158]  ; adcHandler
;;;249        adcHandler.fifoLengthX -= readLengthX;
000774  e2865000          ADD      r5,r6,#0
000778  e5955160          LDR      r5,[r5,#0x160]  ; adcHandler
00077c  e59d6008          LDR      r6,[sp,#8]
000780  e0455006          SUB      r5,r5,r6
000784  e59f6760          LDR      r6,|L1.3820|
000788  e5865160          STR      r5,[r6,#0x160]  ; adcHandler
;;;250        adcHandler.fifoHeadY = headY;
00078c  e59d5010          LDR      r5,[sp,#0x10]
000790  e5865264          STR      r5,[r6,#0x264]  ; adcHandler
;;;251        adcHandler.fifoLengthY -= readLengthY;
000794  e2865000          ADD      r5,r6,#0
000798  e595526c          LDR      r5,[r5,#0x26c]  ; adcHandler
00079c  e59d6000          LDR      r6,[sp,#0]
0007a0  e0455006          SUB      r5,r5,r6
0007a4  e59f6740          LDR      r6,|L1.3820|
0007a8  e586526c          STR      r5,[r6,#0x26c]  ; adcHandler
0007ac  e28dd018          ADD      sp,sp,#0x18
;;;252        return i;
;;;253    }
0007b0  e8bd8070          POP      {r4-r6,pc}
;;;254    
                          ENDP

                  adcReadZ PROC
;;;265     */
;;;266    int adcReadZ(short *bufZ1, short *bufZ2, int dataCnt)
0007b4  e92d4070          PUSH     {r4-r6,lr}
;;;267    {
0007b8  e24dd018          SUB      sp,sp,#0x18
0007bc  e1a03000          MOV      r3,r0
;;;268        INT32 i;
;;;269        volatile INT16 *fifoZ1, *fifoZ2;
;;;270        volatile INT32 headZ1, headZ2;
;;;271        volatile INT32 fifoLengthZ1, readLengthZ1;
;;;272        volatile INT32 fifoLengthZ2, readLengthZ2;
;;;273    
;;;274        fifoZ1 = adcHandler.fifoZ1;
0007c0  e59fc730          LDR      r12,|L1.3832|
;;;275        fifoZ2 = adcHandler.fifoZ2;
0007c4  e28c4f43          ADD      r4,r12,#0x10c
;;;276        headZ1 = adcHandler.fifoHeadZ1;
0007c8  e24c5e27          SUB      r5,r12,#0x270
0007cc  e5955370          LDR      r5,[r5,#0x370]  ; adcHandler
0007d0  e58d5014          STR      r5,[sp,#0x14]
;;;277        headZ2 = adcHandler.fifoHeadZ2;
0007d4  e24c5e27          SUB      r5,r12,#0x270
0007d8  e595547c          LDR      r5,[r5,#0x47c]
0007dc  e58d5010          STR      r5,[sp,#0x10]
;;;278        fifoLengthZ1 = adcHandler.fifoLengthZ1;
0007e0  e24c5e27          SUB      r5,r12,#0x270
0007e4  e5955378          LDR      r5,[r5,#0x378]  ; adcHandler
0007e8  e58d500c          STR      r5,[sp,#0xc]
;;;279        fifoLengthZ2 = adcHandler.fifoLengthZ2;
0007ec  e24c5e27          SUB      r5,r12,#0x270
0007f0  e5955484          LDR      r5,[r5,#0x484]
0007f4  e58d5004          STR      r5,[sp,#4]
;;;280    
;;;281        readLengthZ1 = 0;
0007f8  e3a05000          MOV      r5,#0
0007fc  e58d5008          STR      r5,[sp,#8]
;;;282        readLengthZ2 = 0;
000800  e58d5000          STR      r5,[sp,#0]
;;;283    
;;;284        for (i = 0; i < dataCnt; i++) {
000804  e3a00000          MOV      r0,#0
000808  ea000016          B        |L1.2152|
                  |L1.2060|
;;;285            if (fifoLengthZ1 > readLengthZ1) {
00080c  e59d500c          LDR      r5,[sp,#0xc]
000810  e59d6008          LDR      r6,[sp,#8]
000814  e1550006          CMP      r5,r6
000818  da000010          BLE      |L1.2144|
;;;286                bufZ1[i] = fifoZ1[headZ1];
00081c  e59d5014          LDR      r5,[sp,#0x14]
000820  e08c5085          ADD      r5,r12,r5,LSL #1
000824  e1d550b0          LDRH     r5,[r5,#0]
000828  e0836080          ADD      r6,r3,r0,LSL #1
00082c  e1c650b0          STRH     r5,[r6,#0]
;;;287                readLengthZ1++;
000830  e59d5008          LDR      r5,[sp,#8]
000834  e2855001          ADD      r5,r5,#1
000838  e58d5008          STR      r5,[sp,#8]
;;;288                headZ1++;
00083c  e59d5014          LDR      r5,[sp,#0x14]
000840  e2855001          ADD      r5,r5,#1
000844  e58d5014          STR      r5,[sp,#0x14]
;;;289                if (headZ1 >= ADC_FIFO_LENGTH) {
000848  e59d5014          LDR      r5,[sp,#0x14]
00084c  e3550080          CMP      r5,#0x80
000850  ba000003          BLT      |L1.2148|
;;;290                    headZ1 = 0;
000854  e3a05000          MOV      r5,#0
000858  e58d5014          STR      r5,[sp,#0x14]
00085c  ea000000          B        |L1.2148|
                  |L1.2144|
;;;291                }
;;;292            } else {
;;;293                /* FIFO is empty, just return */
;;;294                break;
000860  ea000002          B        |L1.2160|
                  |L1.2148|
000864  e2800001          ADD      r0,r0,#1              ;284
                  |L1.2152|
000868  e1500002          CMP      r0,r2                 ;284
00086c  baffffe6          BLT      |L1.2060|
                  |L1.2160|
000870  e1a00000          MOV      r0,r0
;;;295            }
;;;296        }
;;;297    
;;;298        for (i = 0; i < dataCnt; i++) {
000874  e3a00000          MOV      r0,#0
000878  ea000016          B        |L1.2264|
                  |L1.2172|
;;;299            if (fifoLengthZ2 > readLengthZ2) {
00087c  e59d5004          LDR      r5,[sp,#4]
000880  e59d6000          LDR      r6,[sp,#0]
000884  e1550006          CMP      r5,r6
000888  da000010          BLE      |L1.2256|
;;;300                bufZ2[i] = fifoZ2[headZ2];
00088c  e59d5010          LDR      r5,[sp,#0x10]
000890  e0845085          ADD      r5,r4,r5,LSL #1
000894  e1d550b0          LDRH     r5,[r5,#0]
000898  e0816080          ADD      r6,r1,r0,LSL #1
00089c  e1c650b0          STRH     r5,[r6,#0]
;;;301                readLengthZ2++;
0008a0  e59d5000          LDR      r5,[sp,#0]
0008a4  e2855001          ADD      r5,r5,#1
0008a8  e58d5000          STR      r5,[sp,#0]
;;;302                headZ2++;
0008ac  e59d5010          LDR      r5,[sp,#0x10]
0008b0  e2855001          ADD      r5,r5,#1
0008b4  e58d5010          STR      r5,[sp,#0x10]
;;;303                if (headZ2 >= ADC_FIFO_LENGTH) {
0008b8  e59d5010          LDR      r5,[sp,#0x10]
0008bc  e3550080          CMP      r5,#0x80
0008c0  ba000003          BLT      |L1.2260|
;;;304                    headZ2 = 0;
0008c4  e3a05000          MOV      r5,#0
0008c8  e58d5010          STR      r5,[sp,#0x10]
0008cc  ea000000          B        |L1.2260|
                  |L1.2256|
;;;305                }
;;;306            } else {
;;;307                /* FIFO is empty, just return */
;;;308                break;
0008d0  ea000002          B        |L1.2272|
                  |L1.2260|
0008d4  e2800001          ADD      r0,r0,#1              ;298
                  |L1.2264|
0008d8  e1500002          CMP      r0,r2                 ;298
0008dc  baffffe6          BLT      |L1.2172|
                  |L1.2272|
0008e0  e1a00000          MOV      r0,r0
;;;309            }
;;;310        }
;;;311    
;;;312        /* Update FIFO information */
;;;313        adcHandler.fifoHeadZ1 = headZ1;
0008e4  e59f6600          LDR      r6,|L1.3820|
0008e8  e59d5014          LDR      r5,[sp,#0x14]
0008ec  e5865370          STR      r5,[r6,#0x370]  ; adcHandler
;;;314        adcHandler.fifoLengthZ1 -= readLengthZ1;
0008f0  e2865000          ADD      r5,r6,#0
0008f4  e5955378          LDR      r5,[r5,#0x378]  ; adcHandler
0008f8  e59d6008          LDR      r6,[sp,#8]
0008fc  e0455006          SUB      r5,r5,r6
000900  e59f65e4          LDR      r6,|L1.3820|
000904  e5865378          STR      r5,[r6,#0x378]  ; adcHandler
;;;315        adcHandler.fifoHeadZ2 = headZ2;
000908  e59d5010          LDR      r5,[sp,#0x10]
00090c  e586547c          STR      r5,[r6,#0x47c]
;;;316        adcHandler.fifoLengthZ2 -= readLengthZ2;
000910  e2865000          ADD      r5,r6,#0
000914  e5955484          LDR      r5,[r5,#0x484]
000918  e59d6000          LDR      r6,[sp,#0]
00091c  e0455006          SUB      r5,r5,r6
000920  e59f65c4          LDR      r6,|L1.3820|
000924  e5865484          STR      r5,[r6,#0x484]
000928  e28dd018          ADD      sp,sp,#0x18
;;;317        return i;
;;;318    }
00092c  e8bd8070          POP      {r4-r6,pc}
;;;319    
                          ENDP

                  adcIoctl PROC
;;;367     */
;;;368    INT adcIoctl(ADC_CMD cmd, INT32 arg1, INT32 arg2)
000930  e92d4030          PUSH     {r4,r5,lr}
;;;369    {
000934  e1a0c000          MOV      r12,r0
000938  e1a03001          MOV      r3,r1
;;;370        UINT32 reg;
;;;371        switch(cmd) {
00093c  e35c0021          CMP      r12,#0x21
000940  308ff10c          ADDCC    pc,pc,r12,LSL #2
000944  ea000191          B        |L1.3984|
000948  ea00001f          B        |L1.2508|
00094c  ea00002f          B        |L1.2576|
000950  ea000034          B        |L1.2600|
000954  ea000157          B        |L1.3768|
000958  ea000169          B        |L1.3844|
00095c  ea000037          B        |L1.2624|
000960  ea00003c          B        |L1.2648|
000964  ea000170          B        |L1.3884|
000968  ea00017e          B        |L1.3944|
00096c  ea000059          B        |L1.2776|
000970  ea000064          B        |L1.2824|
000974  ea00006d          B        |L1.2864|
000978  ea000078          B        |L1.2912|
00097c  ea00003b          B        |L1.2672|
000980  ea00004e          B        |L1.2752|
000984  ea00007f          B        |L1.2952|
000988  ea00008a          B        |L1.3000|
00098c  ea000093          B        |L1.3040|
000990  ea0000a5          B        |L1.3116|
000994  ea0000b5          B        |L1.3184|
000998  ea0000c7          B        |L1.3260|
00099c  ea0000d3          B        |L1.3312|
0009a0  ea0000d8          B        |L1.3336|
0009a4  ea0000dd          B        |L1.3360|
0009a8  ea0000f0          B        |L1.3440|
0009ac  ea0000f9          B        |L1.3480|
0009b0  ea0000fe          B        |L1.3504|
0009b4  ea000103          B        |L1.3528|
0009b8  ea000116          B        |L1.3608|
0009bc  ea00011b          B        |L1.3632|
0009c0  ea000120          B        |L1.3656|
0009c4  ea000125          B        |L1.3680|
0009c8  ea000130          B        |L1.3728|
                  |L1.2508|
;;;372        case START_MST: {           //Menu Start Conversion
0009cc  e1a00000          MOV      r0,r0
;;;373            mst_complete=0;
0009d0  e3a00000          MOV      r0,#0
0009d4  e59f4520          LDR      r4,|L1.3836|
0009d8  e5840000          STR      r0,[r4,#0]  ; mst_complete
;;;374            reg = inpw(REG_ADC_IER);
0009dc  e59f0504          LDR      r0,|L1.3816|
0009e0  e5901008          LDR      r1,[r0,#8]
;;;375            reg = reg | ADC_IER_MIEN;
0009e4  e3811001          ORR      r1,r1,#1
;;;376            outpw(REG_ADC_IER, reg);
0009e8  e5801008          STR      r1,[r0,#8]
;;;377            reg = inpw(REG_ADC_CTL);
0009ec  e5901000          LDR      r1,[r0,#0]
;;;378            reg = reg | ADC_CTL_MST;
0009f0  e3811c01          ORR      r1,r1,#0x100
;;;379            outpw(REG_ADC_CTL, reg);
0009f4  e5801000          STR      r1,[r0,#0]
;;;380            while(!mst_complete);
0009f8  e1a00000          MOV      r0,r0
                  |L1.2556|
0009fc  e59f04f8          LDR      r0,|L1.3836|
000a00  e5900000          LDR      r0,[r0,#0]  ; mst_complete
000a04  e3500000          CMP      r0,#0
000a08  0afffffb          BEQ      |L1.2556|
;;;381        }
;;;382        break;
000a0c  ea000162          B        |L1.3996|
                  |L1.2576|
;;;383        case VBPOWER_ON: {         //Enable ADC Internal Bandgap Power
000a10  e1a00000          MOV      r0,r0
;;;384            reg = inpw(REG_ADC_CTL);
000a14  e59f04cc          LDR      r0,|L1.3816|
000a18  e5901000          LDR      r1,[r0,#0]
;;;385            reg = reg | ADC_CTL_VBGEN;
000a1c  e3811002          ORR      r1,r1,#2
;;;386            outpw(REG_ADC_CTL, reg);
000a20  e5801000          STR      r1,[r0,#0]
;;;387        }
;;;388        break;
000a24  ea00015c          B        |L1.3996|
                  |L1.2600|
;;;389        case VBPOWER_OFF: {        //Disable ADC Internal Bandgap Power
000a28  e1a00000          MOV      r0,r0
;;;390            reg = inpw(REG_ADC_CTL);
000a2c  e59f04b4          LDR      r0,|L1.3816|
000a30  e5901000          LDR      r1,[r0,#0]
;;;391            reg = reg & ~ADC_CTL_VBGEN;
000a34  e3c11002          BIC      r1,r1,#2
;;;392            outpw(REG_ADC_CTL, reg);
000a38  e5801000          STR      r1,[r0,#0]
;;;393        }
;;;394        break;
000a3c  ea000156          B        |L1.3996|
                  |L1.2624|
;;;395        case KPPOWER_ON: {        //Enable ADC Keypad Power
000a40  e1a00000          MOV      r0,r0
;;;396            reg = inpw(REG_ADC_CTL);
000a44  e59f049c          LDR      r0,|L1.3816|
000a48  e5901000          LDR      r1,[r0,#0]
;;;397            reg = reg | ADC_CTL_PWKPEN;
000a4c  e3811004          ORR      r1,r1,#4
;;;398            outpw(REG_ADC_CTL, reg);
000a50  e5801000          STR      r1,[r0,#0]
;;;399        }
;;;400        break;
000a54  ea000150          B        |L1.3996|
                  |L1.2648|
;;;401        case KPPOWER_OFF: {       //Disable ADC Keypad Power
000a58  e1a00000          MOV      r0,r0
;;;402            reg = inpw(REG_ADC_CTL);
000a5c  e59f0484          LDR      r0,|L1.3816|
000a60  e5901000          LDR      r1,[r0,#0]
;;;403            reg = reg & ~ADC_CTL_PWKPEN;
000a64  e3c11004          BIC      r1,r1,#4
;;;404            outpw(REG_ADC_CTL, reg);
000a68  e5801000          STR      r1,[r0,#0]
;;;405        }
;;;406        break;
000a6c  ea00014a          B        |L1.3996|
                  |L1.2672|
;;;407        case PEPOWER_ON: {        //Enable Pen Power
000a70  e1a00000          MOV      r0,r0
;;;408            UINT32 treg;
;;;409            treg = inpw(REG_ADC_IER);
000a74  e59f446c          LDR      r4,|L1.3816|
000a78  e5940008          LDR      r0,[r4,#8]
;;;410            outpw(REG_ADC_IER, treg & ~(ADC_IER_PEDEIEN | ADC_IER_PEUEIEN));
000a7c  e3c04044          BIC      r4,r0,#0x44
000a80  e59f5460          LDR      r5,|L1.3816|
000a84  e5854008          STR      r4,[r5,#8]
;;;411    
;;;412            reg = inpw(REG_ADC_CTL);
000a88  e1a04005          MOV      r4,r5
000a8c  e5941000          LDR      r1,[r4,#0]
;;;413            reg = reg | ADC_CTL_PEDEEN;
000a90  e3811c02          ORR      r1,r1,#0x200
;;;414            outpw(REG_ADC_CTL, reg);
000a94  e5841000          STR      r1,[r4,#0]
;;;415    
;;;416            do {
000a98  e1a00000          MOV      r0,r0
                  |L1.2716|
;;;417                reg = (ADC_ISR_PEDEF | ADC_ISR_PEUEF);
000a9c  e3a01014          MOV      r1,#0x14
;;;418                outpw(REG_ADC_ISR, reg);
000aa0  e59f4440          LDR      r4,|L1.3816|
000aa4  e584100c          STR      r1,[r4,#0xc]
;;;419            } while(inpw(REG_ADC_ISR)&(ADC_ISR_PEDEF | ADC_ISR_PEUEF));
000aa8  e594400c          LDR      r4,[r4,#0xc]
000aac  e3140014          TST      r4,#0x14
000ab0  1afffff9          BNE      |L1.2716|
;;;420    
;;;421            outpw(REG_ADC_IER,treg);
000ab4  e59f442c          LDR      r4,|L1.3816|
000ab8  e5840008          STR      r0,[r4,#8]
;;;422        }
;;;423        break;
000abc  ea000136          B        |L1.3996|
                  |L1.2752|
;;;424        case PEPOWER_OFF: {       //Disable Pen Power
000ac0  e1a00000          MOV      r0,r0
;;;425            reg = inpw(REG_ADC_CTL);
000ac4  e59f041c          LDR      r0,|L1.3816|
000ac8  e5901000          LDR      r1,[r0,#0]
;;;426            reg = reg & ~ADC_CTL_PEDEEN;
000acc  e3c11c02          BIC      r1,r1,#0x200
;;;427            outpw(REG_ADC_CTL, reg);
000ad0  e5801000          STR      r1,[r0,#0]
;;;428        }
;;;429        break;
000ad4  ea000130          B        |L1.3996|
                  |L1.2776|
;;;430        case KPPRESS_ON: {       //Enable Keypad press event
000ad8  e1a00000          MOV      r0,r0
;;;431            ADC_CALLBACK keypad_press_callback;
;;;432            reg = inpw(REG_ADC_IER);
000adc  e59f4404          LDR      r4,|L1.3816|
000ae0  e5941008          LDR      r1,[r4,#8]
;;;433            reg = reg | ADC_IER_KPEIEN;
000ae4  e3811002          ORR      r1,r1,#2
;;;434            outpw(REG_ADC_IER, reg);
000ae8  e5841008          STR      r1,[r4,#8]
;;;435            keypad_press_callback = (ADC_CALLBACK) arg1;
000aec  e1a00003          MOV      r0,r3
;;;436            if (keypad_press_callback != NULL ) {
000af0  e3500000          CMP      r0,#0
000af4  0a000002          BEQ      |L1.2820|
;;;437                adcHandler.keypad_press_callback = keypad_press_callback;
000af8  e59f43ec          LDR      r4,|L1.3820|
000afc  e5840030          STR      r0,[r4,#0x30]  ; adcHandler
;;;438                adcHandler.keypad_press_userData = (UINT32)arg2;
000b00  e5842034          STR      r2,[r4,#0x34]  ; adcHandler
                  |L1.2820|
;;;439            }
;;;440        }
;;;441        break;
000b04  ea000124          B        |L1.3996|
                  |L1.2824|
;;;442        case KPPRESS_OFF: {      //Disable Keypad press event
000b08  e1a00000          MOV      r0,r0
;;;443            reg = inpw(REG_ADC_IER);
000b0c  e59f03d4          LDR      r0,|L1.3816|
000b10  e5901008          LDR      r1,[r0,#8]
;;;444            reg = reg & ~ADC_IER_KPEIEN;
000b14  e3c11002          BIC      r1,r1,#2
;;;445            outpw(REG_ADC_IER, reg);
000b18  e5801008          STR      r1,[r0,#8]
;;;446            adcHandler.keypad_press_callback = NULL;
000b1c  e3a00000          MOV      r0,#0
000b20  e59f43c4          LDR      r4,|L1.3820|
000b24  e5840030          STR      r0,[r4,#0x30]  ; adcHandler
;;;447            adcHandler.keypad_press_userData = NULL;
000b28  e5840034          STR      r0,[r4,#0x34]  ; adcHandler
;;;448        }
;;;449        break;
000b2c  ea00011a          B        |L1.3996|
                  |L1.2864|
;;;450        case KPUP_ON: {         //Enable Keypad up event
000b30  e1a00000          MOV      r0,r0
;;;451            ADC_CALLBACK keypad_up_callback;
;;;452            reg = inpw(REG_ADC_IER);
000b34  e59f43ac          LDR      r4,|L1.3816|
000b38  e5941008          LDR      r1,[r4,#8]
;;;453            reg = reg | ADC_IER_KPUEIEN;
000b3c  e3811020          ORR      r1,r1,#0x20
;;;454            outpw(REG_ADC_IER, reg);
000b40  e5841008          STR      r1,[r4,#8]
;;;455            keypad_up_callback = (ADC_CALLBACK) arg1;
000b44  e1a00003          MOV      r0,r3
;;;456            if (keypad_up_callback != NULL ) {
000b48  e3500000          CMP      r0,#0
000b4c  0a000002          BEQ      |L1.2908|
;;;457                adcHandler.keypad_up_callback = keypad_up_callback;
000b50  e59f4394          LDR      r4,|L1.3820|
000b54  e5840038          STR      r0,[r4,#0x38]  ; adcHandler
;;;458                adcHandler.keypad_up_userData = (UINT32)arg2;
000b58  e584203c          STR      r2,[r4,#0x3c]  ; adcHandler
                  |L1.2908|
;;;459            }
;;;460        }
;;;461        break;
000b5c  ea00010e          B        |L1.3996|
                  |L1.2912|
;;;462        case KPUP_OFF: {       //Disable Keypad up event
000b60  e1a00000          MOV      r0,r0
;;;463            reg = inpw(REG_ADC_IER);
000b64  e59f037c          LDR      r0,|L1.3816|
000b68  e5901008          LDR      r1,[r0,#8]
;;;464            reg = reg & ~ADC_IER_KPUEIEN;
000b6c  e3c11020          BIC      r1,r1,#0x20
;;;465            outpw(REG_ADC_IER, reg);
000b70  e5801008          STR      r1,[r0,#8]
;;;466            adcHandler.keypad_up_callback = NULL;
000b74  e3a00000          MOV      r0,#0
000b78  e59f436c          LDR      r4,|L1.3820|
000b7c  e5840038          STR      r0,[r4,#0x38]  ; adcHandler
;;;467            adcHandler.keypad_up_userData = NULL;
000b80  e584003c          STR      r0,[r4,#0x3c]  ; adcHandler
;;;468        }
;;;469        break;
000b84  ea000104          B        |L1.3996|
                  |L1.2952|
;;;470        case PEDEF_ON: {        //Enable Pen Down Event
000b88  e1a00000          MOV      r0,r0
;;;471            ADC_CALLBACK pendown_callback;
;;;472            reg = inpw(REG_ADC_IER);
000b8c  e59f4354          LDR      r4,|L1.3816|
000b90  e5941008          LDR      r1,[r4,#8]
;;;473            reg = reg | ADC_IER_PEDEIEN;
000b94  e3811004          ORR      r1,r1,#4
;;;474            outpw(REG_ADC_IER, reg);
000b98  e5841008          STR      r1,[r4,#8]
;;;475            pendown_callback = (ADC_CALLBACK) arg1;
000b9c  e1a00003          MOV      r0,r3
;;;476            if (pendown_callback != NULL ) {
000ba0  e3500000          CMP      r0,#0
000ba4  0a000002          BEQ      |L1.2996|
;;;477                adcHandler.pendown_callback = pendown_callback;
000ba8  e59f433c          LDR      r4,|L1.3820|
000bac  e5840018          STR      r0,[r4,#0x18]  ; adcHandler
;;;478                adcHandler.pendown_userData = (UINT32)arg2;
000bb0  e584201c          STR      r2,[r4,#0x1c]  ; adcHandler
                  |L1.2996|
;;;479            }
;;;480        }
;;;481        break;
000bb4  ea0000f8          B        |L1.3996|
                  |L1.3000|
;;;482        case PEDEF_OFF: {       //Disable Pen Down Event
000bb8  e1a00000          MOV      r0,r0
;;;483            reg = inpw(REG_ADC_IER);
000bbc  e59f0324          LDR      r0,|L1.3816|
000bc0  e5901008          LDR      r1,[r0,#8]
;;;484            reg = reg & ~ADC_IER_PEDEIEN;
000bc4  e3c11004          BIC      r1,r1,#4
;;;485            outpw(REG_ADC_IER, reg);
000bc8  e5801008          STR      r1,[r0,#8]
;;;486            adcHandler.pendown_callback = NULL;
000bcc  e3a00000          MOV      r0,#0
000bd0  e59f4314          LDR      r4,|L1.3820|
000bd4  e5840018          STR      r0,[r4,#0x18]  ; adcHandler
;;;487            adcHandler.pendown_userData = NULL;
000bd8  e584001c          STR      r0,[r4,#0x1c]  ; adcHandler
;;;488        }
;;;489        break;
000bdc  ea0000ee          B        |L1.3996|
                  |L1.3040|
;;;490        case WKP_ON: {         //Enable Keypad Press Wake Up
000be0  e1a00000          MOV      r0,r0
;;;491            ADC_CALLBACK keypad_wakeup_callback;
;;;492            reg = inpw(REG_ADC_CTL);
000be4  e59f42fc          LDR      r4,|L1.3816|
000be8  e5941000          LDR      r1,[r4,#0]
;;;493            reg = reg | ADC_CTL_WKPEN;
000bec  e3811b01          ORR      r1,r1,#0x400
;;;494            outpw(REG_ADC_CTL, reg);
000bf0  e5841000          STR      r1,[r4,#0]
;;;495            reg = inpw(REG_ADC_IER);
000bf4  e5941008          LDR      r1,[r4,#8]
;;;496            reg = reg | ADC_IER_WKPIEN;
000bf8  e3811010          ORR      r1,r1,#0x10
;;;497            outpw(REG_ADC_IER, reg);
000bfc  e5841008          STR      r1,[r4,#8]
;;;498            reg=inpw(REG_SYS_WKUPSER);
000c00  e3a0420b          MOV      r4,#0xb0000000
000c04  e5941058          LDR      r1,[r4,#0x58]
;;;499            reg = reg | (1<<26); //Enable ADC Wake System Up.
000c08  e3811301          ORR      r1,r1,#0x4000000
;;;500            outpw(REG_SYS_WKUPSER,reg);
000c0c  e5841058          STR      r1,[r4,#0x58]
;;;501            keypad_wakeup_callback = (ADC_CALLBACK) arg1;
000c10  e1a00003          MOV      r0,r3
;;;502            if (keypad_wakeup_callback != NULL ) {
000c14  e3500000          CMP      r0,#0
000c18  0a000002          BEQ      |L1.3112|
;;;503                adcHandler.keypad_wakeup_callback = keypad_wakeup_callback;
000c1c  e59f42c8          LDR      r4,|L1.3820|
000c20  e5840040          STR      r0,[r4,#0x40]  ; adcHandler
;;;504                adcHandler.keypad_wakeup_userData = (UINT32)arg2;
000c24  e5842044          STR      r2,[r4,#0x44]  ; adcHandler
                  |L1.3112|
;;;505            }
;;;506        }
;;;507        break;
000c28  ea0000db          B        |L1.3996|
                  |L1.3116|
;;;508        case WKP_OFF: {        //Disable Keypad Press Wake Up
000c2c  e1a00000          MOV      r0,r0
;;;509            reg = inpw(REG_ADC_CTL);
000c30  e59f02b0          LDR      r0,|L1.3816|
000c34  e5901000          LDR      r1,[r0,#0]
;;;510            reg = reg & ~ADC_CTL_WKPEN;
000c38  e3c11b01          BIC      r1,r1,#0x400
;;;511            outpw(REG_ADC_CTL, reg);
000c3c  e5801000          STR      r1,[r0,#0]
;;;512            reg = inpw(REG_ADC_IER);
000c40  e5901008          LDR      r1,[r0,#8]
;;;513            reg = reg & ~ADC_IER_WKPIEN;
000c44  e3c11010          BIC      r1,r1,#0x10
;;;514            outpw(REG_ADC_IER, reg);
000c48  e5801008          STR      r1,[r0,#8]
;;;515            reg=inpw(REG_SYS_WKUPSER);
000c4c  e3a0020b          MOV      r0,#0xb0000000
000c50  e5901058          LDR      r1,[r0,#0x58]
;;;516            reg = reg & ~(1<<26); //Enable ADC Wake System Up.
000c54  e3c11301          BIC      r1,r1,#0x4000000
;;;517            outpw(REG_SYS_WKUPSER,reg);
000c58  e5801058          STR      r1,[r0,#0x58]
;;;518            adcHandler.keypad_wakeup_callback = NULL;
000c5c  e3a00000          MOV      r0,#0
000c60  e59f4284          LDR      r4,|L1.3820|
000c64  e5840040          STR      r0,[r4,#0x40]  ; adcHandler
;;;519            adcHandler.keypad_wakeup_userData = NULL;
000c68  e5840044          STR      r0,[r4,#0x44]  ; adcHandler
;;;520        }
;;;521        break;
000c6c  ea0000ca          B        |L1.3996|
                  |L1.3184|
;;;522        case WKT_ON: {         //Enable Touch Wake Up
000c70  e1a00000          MOV      r0,r0
;;;523            ADC_CALLBACK touch_wakeup_callback;
;;;524            reg = inpw(REG_ADC_CTL);
000c74  e59f426c          LDR      r4,|L1.3816|
000c78  e5941000          LDR      r1,[r4,#0]
;;;525            reg = reg | ADC_CTL_WKTEN;
000c7c  e3811b02          ORR      r1,r1,#0x800
;;;526            outpw(REG_ADC_CTL, reg);
000c80  e5841000          STR      r1,[r4,#0]
;;;527            reg = inpw(REG_ADC_IER);
000c84  e5941008          LDR      r1,[r4,#8]
;;;528            reg = reg | ADC_IER_WKTIEN;
000c88  e3811008          ORR      r1,r1,#8
;;;529            outpw(REG_ADC_IER, reg);
000c8c  e5841008          STR      r1,[r4,#8]
;;;530            reg=inpw(REG_SYS_WKUPSER);
000c90  e3a0420b          MOV      r4,#0xb0000000
000c94  e5941058          LDR      r1,[r4,#0x58]
;;;531            reg = reg | (1<<26); //Enable ADC Wake System Up.
000c98  e3811301          ORR      r1,r1,#0x4000000
;;;532            outpw(REG_SYS_WKUPSER,reg);
000c9c  e5841058          STR      r1,[r4,#0x58]
;;;533            touch_wakeup_callback = (ADC_CALLBACK) arg1;
000ca0  e1a00003          MOV      r0,r3
;;;534            if (touch_wakeup_callback != NULL ) {
000ca4  e3500000          CMP      r0,#0
000ca8  0a000002          BEQ      |L1.3256|
;;;535                adcHandler.touch_wakeup_callback = touch_wakeup_callback;
000cac  e59f4238          LDR      r4,|L1.3820|
000cb0  e5840010          STR      r0,[r4,#0x10]  ; adcHandler
;;;536                adcHandler.touch_wakeup_userData = (UINT32)arg2;
000cb4  e5842014          STR      r2,[r4,#0x14]  ; adcHandler
                  |L1.3256|
;;;537            }
;;;538        }
;;;539        break;
000cb8  ea0000b7          B        |L1.3996|
                  |L1.3260|
;;;540        case WKT_OFF: {        //Disable Touch Wake Up
000cbc  e1a00000          MOV      r0,r0
;;;541            reg = inpw(REG_ADC_CTL);
000cc0  e59f0220          LDR      r0,|L1.3816|
000cc4  e5901000          LDR      r1,[r0,#0]
;;;542            reg = reg & ~ADC_CTL_WKTEN;
000cc8  e3c11b02          BIC      r1,r1,#0x800
;;;543            outpw(REG_ADC_CTL, reg);
000ccc  e5801000          STR      r1,[r0,#0]
;;;544            reg = inpw(REG_ADC_IER);
000cd0  e5901008          LDR      r1,[r0,#8]
;;;545            reg = reg & ~ADC_IER_WKTIEN;
000cd4  e3c11008          BIC      r1,r1,#8
;;;546            outpw(REG_ADC_IER, reg);
000cd8  e5801008          STR      r1,[r0,#8]
;;;547            adcHandler.touch_wakeup_callback = NULL;
000cdc  e3a00000          MOV      r0,#0
000ce0  e59f4204          LDR      r4,|L1.3820|
000ce4  e5840010          STR      r0,[r4,#0x10]  ; adcHandler
;;;548            adcHandler.touch_wakeup_userData = NULL;
000ce8  e5840014          STR      r0,[r4,#0x14]  ; adcHandler
;;;549        }
;;;550        break;
000cec  ea0000aa          B        |L1.3996|
                  |L1.3312|
;;;551        case SWITCH_5WIRE_ON: { //Wire Mode Switch to 5-Wire
000cf0  e1a00000          MOV      r0,r0
;;;552            reg = inpw(REG_ADC_CTL);
000cf4  e59f01ec          LDR      r0,|L1.3816|
000cf8  e5901000          LDR      r1,[r0,#0]
;;;553            reg = reg | ADC_CTL_WMSWCH;
000cfc  e3811801          ORR      r1,r1,#0x10000
;;;554            outpw(REG_ADC_CTL, reg);
000d00  e5801000          STR      r1,[r0,#0]
;;;555        }
;;;556        break;
000d04  ea0000a4          B        |L1.3996|
                  |L1.3336|
;;;557        case SWITCH_5WIRE_OFF: { //Wire Mode Switch to 4-Wire
000d08  e1a00000          MOV      r0,r0
;;;558            reg = inpw(REG_ADC_CTL);
000d0c  e59f01d4          LDR      r0,|L1.3816|
000d10  e5901000          LDR      r1,[r0,#0]
;;;559            reg = reg & ~ADC_CTL_WMSWCH;
000d14  e3c11801          BIC      r1,r1,#0x10000
;;;560            outpw(REG_ADC_CTL, reg);
000d18  e5801000          STR      r1,[r0,#0]
;;;561        }
;;;562        break;
000d1c  ea00009e          B        |L1.3996|
                  |L1.3360|
;;;563    
;;;564        case T_ON: { //Enable Touch detection function
000d20  e1a00000          MOV      r0,r0
;;;565            ADC_CALLBACK touch_callback;
;;;566            reg = inpw(REG_ADC_CONF);
000d24  e59f41bc          LDR      r4,|L1.3816|
000d28  e5941004          LDR      r1,[r4,#4]
;;;567            reg = reg | ADC_CONF_TEN;
000d2c  e3811001          ORR      r1,r1,#1
;;;568            outpw(REG_ADC_CONF, reg);
000d30  e5841004          STR      r1,[r4,#4]
;;;569            touch_callback = (ADC_CALLBACK) arg1;
000d34  e1a00003          MOV      r0,r3
;;;570            if (touch_callback != NULL ) {
000d38  e3500000          CMP      r0,#0
000d3c  0a000002          BEQ      |L1.3404|
;;;571                adcHandler.touch_callback = touch_callback;
000d40  e59f41a4          LDR      r4,|L1.3820|
000d44  e5840000          STR      r0,[r4,#0]  ; adcHandler
;;;572                adcHandler.touch_userData = (UINT32)arg2;
000d48  e5842004          STR      r2,[r4,#4]  ; adcHandler
                  |L1.3404|
;;;573            }
;;;574            /* Flush the FIFO */
;;;575            adcHandler.fifoHeadX = 0;
000d4c  e3a04000          MOV      r4,#0
000d50  e59f5194          LDR      r5,|L1.3820|
000d54  e5854158          STR      r4,[r5,#0x158]  ; adcHandler
;;;576            adcHandler.fifoTailX = 0;
000d58  e585415c          STR      r4,[r5,#0x15c]  ; adcHandler
;;;577            adcHandler.fifoLengthX = 0;
000d5c  e5854160          STR      r4,[r5,#0x160]  ; adcHandler
;;;578            adcHandler.fifoHeadY = 0;
000d60  e5854264          STR      r4,[r5,#0x264]  ; adcHandler
;;;579            adcHandler.fifoTailY = 0;
000d64  e5854268          STR      r4,[r5,#0x268]  ; adcHandler
;;;580            adcHandler.fifoLengthY = 0;
000d68  e585426c          STR      r4,[r5,#0x26c]  ; adcHandler
;;;581        }
;;;582        break;
000d6c  ea00008a          B        |L1.3996|
                  |L1.3440|
;;;583        case T_OFF: { //Disable Touch detection function
000d70  e1a00000          MOV      r0,r0
;;;584            reg = inpw(REG_ADC_CONF);
000d74  e59f016c          LDR      r0,|L1.3816|
000d78  e5901004          LDR      r1,[r0,#4]
;;;585            reg = reg & ~ADC_CONF_TEN;
000d7c  e3c11001          BIC      r1,r1,#1
;;;586            outpw(REG_ADC_CONF, reg);
000d80  e5801004          STR      r1,[r0,#4]
;;;587            adcHandler.touch_callback = NULL;
000d84  e3a00000          MOV      r0,#0
000d88  e59f415c          LDR      r4,|L1.3820|
000d8c  e5840000          STR      r0,[r4,#0]  ; adcHandler
;;;588            adcHandler.touch_userData = NULL;
000d90  e5840004          STR      r0,[r4,#4]  ; adcHandler
;;;589        }
;;;590        break;
000d94  ea000080          B        |L1.3996|
                  |L1.3480|
;;;591        case TAVG_ON: { //Enable Touch Mean average for X and Y function
000d98  e1a00000          MOV      r0,r0
;;;592            reg = inpw(REG_ADC_CONF);
000d9c  e59f0144          LDR      r0,|L1.3816|
000da0  e5901004          LDR      r1,[r0,#4]
;;;593            reg = reg | ADC_CONF_DISTMAVEN;
000da4  e3811601          ORR      r1,r1,#0x100000
;;;594            outpw(REG_ADC_CONF, reg);
000da8  e5801004          STR      r1,[r0,#4]
;;;595        }
;;;596        break;
000dac  ea00007a          B        |L1.3996|
                  |L1.3504|
;;;597        case TAVG_OFF: { //Disable Touch Mean average for X and Y function
000db0  e1a00000          MOV      r0,r0
;;;598            reg = inpw(REG_ADC_CONF);
000db4  e59f012c          LDR      r0,|L1.3816|
000db8  e5901004          LDR      r1,[r0,#4]
;;;599            reg = reg & ~ADC_CONF_DISTMAVEN;
000dbc  e3c11601          BIC      r1,r1,#0x100000
;;;600            outpw(REG_ADC_CONF, reg);
000dc0  e5801004          STR      r1,[r0,#4]
;;;601        }
;;;602        break;
000dc4  ea000074          B        |L1.3996|
                  |L1.3528|
;;;603        case Z_ON: { //Enable Press measure function
000dc8  e1a00000          MOV      r0,r0
;;;604            ADC_CALLBACK touchz_callback;
;;;605            reg = inpw(REG_ADC_CONF);
000dcc  e59f4114          LDR      r4,|L1.3816|
000dd0  e5941004          LDR      r1,[r4,#4]
;;;606            reg = reg | ADC_CONF_ZEN;
000dd4  e3811002          ORR      r1,r1,#2
;;;607            outpw(REG_ADC_CONF, reg);
000dd8  e5841004          STR      r1,[r4,#4]
;;;608            touchz_callback = (ADC_CALLBACK) arg1;
000ddc  e1a00003          MOV      r0,r3
;;;609            if (touchz_callback != NULL ) {
000de0  e3500000          CMP      r0,#0
000de4  0a000002          BEQ      |L1.3572|
;;;610                adcHandler.touchz_callback = touchz_callback;
000de8  e59f40fc          LDR      r4,|L1.3820|
000dec  e5840008          STR      r0,[r4,#8]  ; adcHandler
;;;611                adcHandler.touchz_userData = (UINT32)arg2;
000df0  e584200c          STR      r2,[r4,#0xc]  ; adcHandler
                  |L1.3572|
;;;612            }
;;;613            /* Flush the FIFO */
;;;614            adcHandler.fifoHeadZ1 = 0;
000df4  e3a04000          MOV      r4,#0
000df8  e59f50ec          LDR      r5,|L1.3820|
000dfc  e5854370          STR      r4,[r5,#0x370]  ; adcHandler
;;;615            adcHandler.fifoTailZ1 = 0;
000e00  e5854374          STR      r4,[r5,#0x374]  ; adcHandler
;;;616            adcHandler.fifoLengthZ1 = 0;
000e04  e5854378          STR      r4,[r5,#0x378]  ; adcHandler
;;;617            adcHandler.fifoHeadZ2 = 0;
000e08  e585447c          STR      r4,[r5,#0x47c]
;;;618            adcHandler.fifoTailZ2 = 0;
000e0c  e5854480          STR      r4,[r5,#0x480]
;;;619            adcHandler.fifoLengthZ2 = 0;
000e10  e5854484          STR      r4,[r5,#0x484]
;;;620        }
;;;621        break;
000e14  ea000060          B        |L1.3996|
                  |L1.3608|
;;;622        case Z_OFF: { //Disable Press measure function
000e18  e1a00000          MOV      r0,r0
;;;623            reg = inpw(REG_ADC_CONF);
000e1c  e59f00c4          LDR      r0,|L1.3816|
000e20  e5901004          LDR      r1,[r0,#4]
;;;624            reg = reg & ~ADC_CONF_ZEN;
000e24  e3c11002          BIC      r1,r1,#2
;;;625            outpw(REG_ADC_CONF, reg);
000e28  e5801004          STR      r1,[r0,#4]
;;;626        }
;;;627        break;
000e2c  ea00005a          B        |L1.3996|
                  |L1.3632|
;;;628        case TZAVG_ON: { //Enable Pressure Mean average for Z1 and Z2 function
000e30  e1a00000          MOV      r0,r0
;;;629            reg = inpw(REG_ADC_CONF);
000e34  e59f00ac          LDR      r0,|L1.3816|
000e38  e5901004          LDR      r1,[r0,#4]
;;;630            reg = reg | ADC_CONF_DISZMAVEN;
000e3c  e3811602          ORR      r1,r1,#0x200000
;;;631            outpw(REG_ADC_CONF, reg);
000e40  e5801004          STR      r1,[r0,#4]
;;;632        }
;;;633        break;
000e44  ea000054          B        |L1.3996|
                  |L1.3656|
;;;634        case TZAVG_OFF: { //Disable Pressure Mean average for Z1 and Z2 function
000e48  e1a00000          MOV      r0,r0
;;;635            reg = inpw(REG_ADC_CONF);
000e4c  e59f0094          LDR      r0,|L1.3816|
000e50  e5901004          LDR      r1,[r0,#4]
;;;636            reg = reg & ~ADC_CONF_DISZMAVEN;
000e54  e3c11602          BIC      r1,r1,#0x200000
;;;637            outpw(REG_ADC_CONF, reg);
000e58  e5801004          STR      r1,[r0,#4]
;;;638        }
;;;639        break;
000e5c  ea00004e          B        |L1.3996|
                  |L1.3680|
;;;640        case NAC_ON: { //Enable Normal AD Conversion
000e60  e1a00000          MOV      r0,r0
;;;641            ADC_CALLBACK normal_callback;
;;;642            reg = inpw(REG_ADC_CONF);
000e64  e59f407c          LDR      r4,|L1.3816|
000e68  e5941004          LDR      r1,[r4,#4]
;;;643            reg = reg | ADC_CONF_NACEN;
000e6c  e3811004          ORR      r1,r1,#4
;;;644            //reg = reg & ~ADC_CONF_VBATEN;
;;;645            
;;;646            outpw(REG_ADC_CONF, reg);
000e70  e5841004          STR      r1,[r4,#4]
;;;647            normal_callback = (ADC_CALLBACK) arg1;
000e74  e1a00003          MOV      r0,r3
;;;648            if (normal_callback != NULL ) {
000e78  e3500000          CMP      r0,#0
000e7c  0a000002          BEQ      |L1.3724|
;;;649                adcHandler.normal_callback = normal_callback;
000e80  e59f4064          LDR      r4,|L1.3820|
000e84  e5840050          STR      r0,[r4,#0x50]  ; adcHandler
;;;650                adcHandler.normal_userData = (UINT32)arg2;
000e88  e5842054          STR      r2,[r4,#0x54]  ; adcHandler
                  |L1.3724|
;;;651            }
;;;652        }
;;;653        break;
000e8c  ea000042          B        |L1.3996|
                  |L1.3728|
;;;654        case NAC_OFF: { //Disable Normal AD Conversion
000e90  e1a00000          MOV      r0,r0
;;;655            reg = inpw(REG_ADC_CONF);
000e94  e59f004c          LDR      r0,|L1.3816|
000e98  e5901004          LDR      r1,[r0,#4]
;;;656            reg = reg & ~ADC_CONF_NACEN;
000e9c  e3c11004          BIC      r1,r1,#4
;;;657            outpw(REG_ADC_CONF, reg);
000ea0  e5801004          STR      r1,[r0,#4]
;;;658            adcHandler.normal_callback = NULL;
000ea4  e3a00000          MOV      r0,#0
000ea8  e59f403c          LDR      r4,|L1.3820|
000eac  e5840050          STR      r0,[r4,#0x50]  ; adcHandler
;;;659            adcHandler.normal_userData = NULL;
000eb0  e5840054          STR      r0,[r4,#0x54]  ; adcHandler
;;;660        }
;;;661        break;
000eb4  ea000038          B        |L1.3996|
                  |L1.3768|
;;;662        case VBAT_ON: { //Enable Voltage Battery Conversion
000eb8  e1a00000          MOV      r0,r0
;;;663            ADC_CALLBACK voltage_battery_callback;
;;;664            reg = inpw(REG_ADC_CONF);
000ebc  e59f4024          LDR      r4,|L1.3816|
000ec0  e5941004          LDR      r1,[r4,#4]
;;;665            reg = reg | ADC_CONF_VBATEN;
000ec4  e3811c01          ORR      r1,r1,#0x100
;;;666            outpw(REG_ADC_CONF, reg);
000ec8  e5841004          STR      r1,[r4,#4]
;;;667            voltage_battery_callback = (ADC_CALLBACK) arg1;
000ecc  e1a00003          MOV      r0,r3
;;;668            if (voltage_battery_callback != NULL ) {
000ed0  e3500000          CMP      r0,#0
000ed4  0a000002          BEQ      |L1.3812|
;;;669                adcHandler.voltage_battery_callback = voltage_battery_callback;
000ed8  e59f400c          LDR      r4,|L1.3820|
000edc  e5840048          STR      r0,[r4,#0x48]  ; adcHandler
;;;670                adcHandler.voltage_battery_userData = (UINT32)arg2;
000ee0  e584204c          STR      r2,[r4,#0x4c]  ; adcHandler
                  |L1.3812|
;;;671            }
;;;672        }
;;;673        break;
000ee4  ea00002c          B        |L1.3996|
                  |L1.3816|
                          DCD      0xb800a000
                  |L1.3820|
                          DCD      adcHandler
                  |L1.3824|
                          DCD      adcHandler+0x58
                  |L1.3828|
                          DCD      0x00000fff
                  |L1.3832|
                          DCD      adcHandler+0x270
                  |L1.3836|
                          DCD      mst_complete
                  |L1.3840|
                          DCD      adcISR
                  |L1.3844|
;;;674        case VBAT_OFF: { //Disable Voltage Battery
000f04  e1a00000          MOV      r0,r0
;;;675            reg = inpw(REG_ADC_CONF);
000f08  e51f0028          LDR      r0,|L1.3816|
000f0c  e5901004          LDR      r1,[r0,#4]
;;;676            reg = reg & ~ADC_CONF_VBATEN;
000f10  e3c11c01          BIC      r1,r1,#0x100
;;;677            outpw(REG_ADC_CONF, reg);
000f14  e5801004          STR      r1,[r0,#4]
;;;678            adcHandler.voltage_battery_callback = NULL;
000f18  e3a00000          MOV      r0,#0
000f1c  e51f4038          LDR      r4,|L1.3820|
000f20  e5840048          STR      r0,[r4,#0x48]  ; adcHandler
;;;679            adcHandler.voltage_battery_userData = NULL;
000f24  e584004c          STR      r0,[r4,#0x4c]  ; adcHandler
;;;680        }
;;;681        break;
000f28  ea00001b          B        |L1.3996|
                  |L1.3884|
;;;682        case KPCONV_ON: { //Enable Keypad conversion function
000f2c  e1a00000          MOV      r0,r0
;;;683            ADC_CALLBACK keypad_conv_callback;
;;;684            reg = inpw(REG_ADC_CONF);
000f30  e51f4050          LDR      r4,|L1.3816|
000f34  e5941004          LDR      r1,[r4,#4]
;;;685            reg = reg | ADC_CONF_KPCEN;
000f38  e3811c02          ORR      r1,r1,#0x200
;;;686            outpw(REG_ADC_CONF, reg);
000f3c  e5841004          STR      r1,[r4,#4]
;;;687    
;;;688            reg = inpw(REG_ADC_IER);
000f40  e5941008          LDR      r1,[r4,#8]
;;;689            reg = reg | ADC_IER_KPEIEN;
000f44  e3811002          ORR      r1,r1,#2
;;;690            outpw(REG_ADC_IER, reg);
000f48  e5841008          STR      r1,[r4,#8]
;;;691    
;;;692            keypad_conv_callback = (ADC_CALLBACK) arg1;
000f4c  e1a00003          MOV      r0,r3
;;;693            if (keypad_conv_callback != NULL ) {
000f50  e3500000          CMP      r0,#0
000f54  0a000002          BEQ      |L1.3940|
;;;694                adcHandler.keypad_conv_callback = keypad_conv_callback;
000f58  e51f4074          LDR      r4,|L1.3820|
000f5c  e5840028          STR      r0,[r4,#0x28]  ; adcHandler
;;;695                adcHandler.keypad_conv_userData = (UINT32)arg2;
000f60  e584202c          STR      r2,[r4,#0x2c]  ; adcHandler
                  |L1.3940|
;;;696            }
;;;697        }
;;;698        break;
000f64  ea00000c          B        |L1.3996|
                  |L1.3944|
;;;699        case KPCONV_OFF: { //Disable Keypad conversion function
000f68  e1a00000          MOV      r0,r0
;;;700            reg = inpw(REG_ADC_CONF);
000f6c  e51f008c          LDR      r0,|L1.3816|
000f70  e5901004          LDR      r1,[r0,#4]
;;;701            reg = reg & ~ADC_CONF_KPCEN;
000f74  e3c11c02          BIC      r1,r1,#0x200
;;;702            outpw(REG_ADC_CONF, reg);
000f78  e5801004          STR      r1,[r0,#4]
;;;703            adcHandler.keypad_conv_callback = NULL;
000f7c  e3a00000          MOV      r0,#0
000f80  e51f409c          LDR      r4,|L1.3820|
000f84  e5840028          STR      r0,[r4,#0x28]  ; adcHandler
;;;704            adcHandler.keypad_conv_userData = NULL;
000f88  e584002c          STR      r0,[r4,#0x2c]  ; adcHandler
;;;705        }
;;;706        break;
000f8c  ea000002          B        |L1.3996|
                  |L1.3984|
;;;707        default:
000f90  e1a00000          MOV      r0,r0
;;;708            return ADC_ERR_CMD;
000f94  e3a00002          MOV      r0,#2
                  |L1.3992|
;;;709        }
;;;710        return Successful;
;;;711    }
000f98  e8bd8030          POP      {r4,r5,pc}
                  |L1.3996|
000f9c  e1a00000          MOV      r0,r0                 ;382
000fa0  e3a00000          MOV      r0,#0                 ;710
000fa4  eafffffb          B        |L1.3992|
;;;712    
                          ENDP

                  adcChangeChannel PROC
;;;906     */
;;;907    INT adcChangeChannel(int channel)
000fa8  e1a01000          MOV      r1,r0
;;;908    {
;;;909        UINT32 reg;
;;;910        if ((channel>>3) < 0 || (channel>>3) > 7) {
000fac  e1b001c1          ASRS     r0,r1,#3
000fb0  4a000002          BMI      |L1.4032|
000fb4  e3a00007          MOV      r0,#7
000fb8  e15001c1          CMP      r0,r1,ASR #3
000fbc  aa000001          BGE      |L1.4040|
                  |L1.4032|
;;;911            return ADC_ERR_ARGS;
000fc0  e3a00001          MOV      r0,#1
                  |L1.4036|
;;;912        }
;;;913        reg = inpw(REG_ADC_CONF);
;;;914        reg = (reg & ~ADC_CONF_CHSEL_Msk) | channel;
;;;915        outpw(REG_ADC_CONF,reg);
;;;916        return Successful;
;;;917    }
000fc4  e12fff1e          BX       lr
                  |L1.4040|
000fc8  e51f00e8          LDR      r0,|L1.3816|
000fcc  e5902004          LDR      r2,[r0,#4]            ;913
000fd0  e3c20038          BIC      r0,r2,#0x38           ;914
000fd4  e1802001          ORR      r2,r0,r1              ;914
000fd8  e51f00f8          LDR      r0,|L1.3816|
000fdc  e5802004          STR      r2,[r0,#4]            ;915
000fe0  e3a00000          MOV      r0,#0                 ;916
000fe4  eafffff6          B        |L1.4036|
;;;918    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  adcHandler
                          %        1160

                          AREA ||.data||, DATA, ALIGN=2

                  mst_complete
                          DCD      0x00000000
