; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\system_nuc970.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_nuc970.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\system_nuc970.crf ..\..\common\src\BSP\Driver\Source\system_nuc970.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sysGetCacheState PROC
;;;385    
;;;386    BOOL sysGetCacheState()
000000  e59f0900          LDR      r0,|L1.2312|
;;;387    {
;;;388        return _sys_IsCacheOn;
000004  e5d00000          LDRB     r0,[r0,#0]  ; _sys_IsCacheOn
;;;389    }
000008  e12fff1e          BX       lr
;;;390    
                          ENDP

                  sysGetPhyPageAddr PROC
;;;39     
;;;40     unsigned int sysGetPhyPageAddr(unsigned int vaddr)
00000c  e92d41f0          PUSH     {r4-r8,lr}
;;;41     {
000010  e1a01000          MOV      r1,r0
;;;42         int table_num, page_num;
;;;43         unsigned int base_addr, page_base, page_offset, phy_addr;
;;;44         volatile _CTable *PageTabPtr;
;;;45     
;;;46         if (vaddr & 0x80000000)
000014  e3110102          TST      r1,#0x80000000
000018  0a000001          BEQ      |L1.36|
;;;47             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
00001c  e59f28e8          LDR      r2,|L1.2316|
000020  ea000000          B        |L1.40|
                  |L1.36|
;;;48         else
;;;49             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000024  e59f28e4          LDR      r2,|L1.2320|
                  |L1.40|
;;;50     
;;;51         if (sysGetCacheState() == TRUE)
000028  ebfffffe          BL       sysGetCacheState
00002c  e3500001          CMP      r0,#1
000030  1a000000          BNE      |L1.56|
;;;52             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
000034  e3822102          ORR      r2,r2,#0x80000000
                  |L1.56|
;;;53     
;;;54         base_addr = vaddr & 0x7FFFF000;
000038  e3c1313e          BIC      r3,r1,#0x8000000f
00003c  e3c33eff          BIC      r3,r3,#0xff0
;;;55         table_num = base_addr / 0x100000;
000040  e1a04a23          LSR      r4,r3,#20
;;;56         page_num = (base_addr & 0xFF000) >> 12;
000044  e2030aff          AND      r0,r3,#0xff000
000048  e1a05620          LSR      r5,r0,#12
;;;57     
;;;58         page_base = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFF000;
00004c  e0820504          ADD      r0,r2,r4,LSL #10
000050  e7900105          LDR      r0,[r0,r5,LSL #2]
000054  e1a06620          LSR      r6,r0,#12
000058  e1a06606          LSL      r6,r6,#12
;;;59         page_offset = vaddr & 0xFFF;
00005c  e1a07a01          LSL      r7,r1,#20
000060  e1a07a27          LSR      r7,r7,#20
;;;60         phy_addr = page_base + page_offset;
000064  e0868007          ADD      r8,r6,r7
;;;61     
;;;62         return phy_addr;
000068  e1a00008          MOV      r0,r8
;;;63     
;;;64     } /* end sysGetPHYAddr */
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;65     
                          ENDP

                  sysSetCachePages PROC
;;;66     
;;;67     int sysSetCachePages(unsigned int vaddr, int size, int cache_flag)
000070  e92d43fc          PUSH     {r2-r9,lr}
;;;68     {
000074  e1a03000          MOV      r3,r0
000078  e1a06002          MOV      r6,r2
;;;69         int i, cnt, table_num, page_num, cache_mode;
;;;70         unsigned volatile int baseaddr, temp;
;;;71         volatile _CTable *PageTabPtr;
;;;72     
;;;73         if (vaddr & 0x80000000)
00007c  e3130102          TST      r3,#0x80000000
000080  0a000001          BEQ      |L1.140|
;;;74             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000084  e59f4880          LDR      r4,|L1.2316|
000088  ea000000          B        |L1.144|
                  |L1.140|
;;;75         else
;;;76             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
00008c  e59f487c          LDR      r4,|L1.2320|
                  |L1.144|
;;;77     
;;;78         if (sysGetCacheState() == TRUE)
000090  ebfffffe          BL       sysGetCacheState
000094  e3500001          CMP      r0,#1
000098  1a000000          BNE      |L1.160|
;;;79             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
00009c  e3844102          ORR      r4,r4,#0x80000000
                  |L1.160|
;;;80     
;;;81         vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
0000a0  e3c33102          BIC      r3,r3,#0x80000000
;;;82         //if ( _IsInitMMUTable == FALSE ) return -1;
;;;83         if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
0000a4  e0830001          ADD      r0,r3,r1
0000a8  e3500301          CMP      r0,#0x4000000
0000ac  9a000001          BLS      |L1.184|
0000b0  e3e00000          MVN      r0,#0
                  |L1.180|
;;;84     
;;;85         if (vaddr & 0xFFF)  return -1;  /* MUST 4K Boundary */
;;;86         if (size % 4096)    return -1;  /* MUST 4K multiple size */
;;;87     
;;;88         /* for flat mapping address */
;;;89         cnt = size / 4096;
;;;90     
;;;91         if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
;;;92             cache_mode = 0x0C;
;;;93         else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
;;;94             cache_mode = 0x08;
;;;95         else
;;;96             cache_mode = 0; /* Non-cacheable, non-buffered */
;;;97     
;;;98         for (i=0; i<cnt; i++) {
;;;99             baseaddr = vaddr + i * 4096;
;;;100            table_num = baseaddr / 0x100000;
;;;101            page_num =  (baseaddr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;102    
;;;103            temp = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFFFF3;
;;;104            temp |= cache_mode; /* cache mode */
;;;105            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;106        }
;;;107    
;;;108        //sysFlushCache(D_CACHE);
;;;109    
;;;110        return 0;
;;;111    
;;;112    } /* end sysSetCachePages */
0000b4  e8bd83fc          POP      {r2-r9,pc}
                  |L1.184|
0000b8  e1a00a03          LSL      r0,r3,#20             ;85
0000bc  e1b00a20          LSRS     r0,r0,#20             ;85
0000c0  0a000001          BEQ      |L1.204|
0000c4  e3e00000          MVN      r0,#0                 ;85
0000c8  eafffff9          B        |L1.180|
                  |L1.204|
0000cc  e1a0cfc1          ASR      r12,r1,#31            ;86
0000d0  e081ca2c          ADD      r12,r1,r12,LSR #20    ;86
0000d4  e1a0c64c          ASR      r12,r12,#12           ;86
0000d8  e051c60c          SUBS     r12,r1,r12,LSL #12    ;86
0000dc  0a000001          BEQ      |L1.232|
0000e0  e3e00000          MVN      r0,#0                 ;86
0000e4  eafffff2          B        |L1.180|
                  |L1.232|
0000e8  e1a00001          MOV      r0,r1                 ;89
0000ec  e1a0cfc1          ASR      r12,r1,#31            ;89
0000f0  e081ca2c          ADD      r12,r1,r12,LSR #20    ;89
0000f4  e1a0964c          ASR      r9,r12,#12            ;89
0000f8  e3560000          CMP      r6,#0                 ;91
0000fc  1a000001          BNE      |L1.264|
000100  e3a0500c          MOV      r5,#0xc               ;92
000104  ea000004          B        |L1.284|
                  |L1.264|
000108  e3560001          CMP      r6,#1                 ;93
00010c  1a000001          BNE      |L1.280|
000110  e3a05008          MOV      r5,#8                 ;94
000114  ea000000          B        |L1.284|
                  |L1.280|
000118  e3a05000          MOV      r5,#0                 ;96
                  |L1.284|
00011c  e3a02000          MOV      r2,#0                 ;98
000120  ea000011          B        |L1.364|
                  |L1.292|
000124  e0830602          ADD      r0,r3,r2,LSL #12      ;99
000128  e58d0004          STR      r0,[sp,#4]            ;99
00012c  e59d0004          LDR      r0,[sp,#4]            ;100
000130  e1a07a20          LSR      r7,r0,#20             ;100
000134  e59d0004          LDR      r0,[sp,#4]            ;101
000138  e2000aff          AND      r0,r0,#0xff000        ;101
00013c  e1a08620          LSR      r8,r0,#12             ;101
000140  e0840507          ADD      r0,r4,r7,LSL #10      ;103
000144  e7900108          LDR      r0,[r0,r8,LSL #2]     ;103
000148  e3c0000c          BIC      r0,r0,#0xc            ;103
00014c  e58d0000          STR      r0,[sp,#0]            ;103
000150  e59d0000          LDR      r0,[sp,#0]            ;104
000154  e1800005          ORR      r0,r0,r5              ;104
000158  e58d0000          STR      r0,[sp,#0]            ;104
00015c  e084c507          ADD      r12,r4,r7,LSL #10     ;105
000160  e59d0000          LDR      r0,[sp,#0]            ;105
000164  e78c0108          STR      r0,[r12,r8,LSL #2]    ;105
000168  e2822001          ADD      r2,r2,#1              ;98
                  |L1.364|
00016c  e1520009          CMP      r2,r9                 ;98
000170  baffffeb          BLT      |L1.292|
000174  e3a00000          MOV      r0,#0                 ;110
000178  eaffffcd          B        |L1.180|
;;;113    
                          ENDP

                  sysInitPageTable PROC
;;;115    
;;;116    int sysInitPageTable(unsigned int vaddr, unsigned int phy_addr, int size, int cache_flag, int rev_flag)
00017c  e92d4ffe          PUSH     {r1-r11,lr}
;;;117    {
000180  e1a04000          MOV      r4,r0
000184  e1a06001          MOV      r6,r1
000188  e1a07003          MOV      r7,r3
;;;118        int i, cnt, table_num, page_num, cache_mode, addr_offset;
;;;119        unsigned volatile int phy_base_addr, vbase_addr, temp;
;;;120        volatile _CTable *PageTabPtr;
;;;121    
;;;122        if (vaddr & 0x80000000)
00018c  e3140102          TST      r4,#0x80000000
000190  0a000001          BEQ      |L1.412|
;;;123            PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000194  e59f5770          LDR      r5,|L1.2316|
000198  ea000000          B        |L1.416|
                  |L1.412|
;;;124        else
;;;125            PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
00019c  e59f576c          LDR      r5,|L1.2320|
                  |L1.416|
;;;126    
;;;127        if (sysGetCacheState() == TRUE)
0001a0  ebfffffe          BL       sysGetCacheState
0001a4  e3500001          CMP      r0,#1
0001a8  1a000000          BNE      |L1.432|
;;;128            PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
0001ac  e3855102          ORR      r5,r5,#0x80000000
                  |L1.432|
;;;129    
;;;130        //if ( _IsInitMMUTable == FALSE ) return -1;
;;;131        vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
0001b0  e3c44102          BIC      r4,r4,#0x80000000
;;;132        if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
0001b4  e0840002          ADD      r0,r4,r2
0001b8  e3500301          CMP      r0,#0x4000000
0001bc  9a000001          BLS      |L1.456|
0001c0  e3e00000          MVN      r0,#0
                  |L1.452|
;;;133        if (vaddr & 0xFFFFF)    return -1;  /* MUST 1M Boundary */
;;;134        if (size % 4096)        return -1;  /* MUST 4K multiple size */
;;;135    
;;;136        /* Pages count */
;;;137        cnt = size / 4096;
;;;138    
;;;139        if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
;;;140            cache_mode = 0x0C;
;;;141        else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
;;;142            cache_mode = 0x08;
;;;143        else
;;;144            cache_mode = 0; /* Non-cacheable, non-buffered */
;;;145    
;;;146    
;;;147        if (rev_flag == MMU_DIRECT_MAPPING)
;;;148            phy_base_addr = phy_addr;
;;;149        else
;;;150            phy_base_addr = phy_addr + size - 4096;
;;;151    
;;;152        addr_offset = 4096;
;;;153        for (i=0; i<cnt; i++) {
;;;154            vbase_addr = vaddr + i * 4096;
;;;155            table_num = vbase_addr / 0x100000;
;;;156            page_num =  (vbase_addr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;157    
;;;158            temp = phy_base_addr & 0xFFFFF000;
;;;159            temp |= 0xFF0; /* access permission, 11 for read/write */
;;;160            temp |= cache_mode; /* cache mode */
;;;161            temp |= 0x02;  /* small page */
;;;162    
;;;163            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;164    
;;;165            if (rev_flag == MMU_DIRECT_MAPPING)
;;;166                phy_base_addr += addr_offset;
;;;167            else
;;;168                phy_base_addr -= addr_offset;
;;;169        }
;;;170    
;;;171        return 0;
;;;172    
;;;173    } /* end sysInitPageTable */
0001c4  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.456|
0001c8  e1a00604          LSL      r0,r4,#12             ;133
0001cc  e1b00620          LSRS     r0,r0,#12             ;133
0001d0  0a000001          BEQ      |L1.476|
0001d4  e3e00000          MVN      r0,#0                 ;133
0001d8  eafffff9          B        |L1.452|
                  |L1.476|
0001dc  e1a0cfc2          ASR      r12,r2,#31            ;134
0001e0  e082ca2c          ADD      r12,r2,r12,LSR #20    ;134
0001e4  e1a0c64c          ASR      r12,r12,#12           ;134
0001e8  e052c60c          SUBS     r12,r2,r12,LSL #12    ;134
0001ec  0a000001          BEQ      |L1.504|
0001f0  e3e00000          MVN      r0,#0                 ;134
0001f4  eafffff2          B        |L1.452|
                  |L1.504|
0001f8  e1a00002          MOV      r0,r2                 ;137
0001fc  e1a0cfc2          ASR      r12,r2,#31            ;137
000200  e082ca2c          ADD      r12,r2,r12,LSR #20    ;137
000204  e1a0964c          ASR      r9,r12,#12            ;137
000208  e3570000          CMP      r7,#0                 ;139
00020c  1a000001          BNE      |L1.536|
000210  e3a0300c          MOV      r3,#0xc               ;140
000214  ea000004          B        |L1.556|
                  |L1.536|
000218  e3570001          CMP      r7,#1                 ;141
00021c  1a000001          BNE      |L1.552|
000220  e3a03008          MOV      r3,#8                 ;142
000224  ea000000          B        |L1.556|
                  |L1.552|
000228  e3a03000          MOV      r3,#0                 ;144
                  |L1.556|
00022c  e59d0030          LDR      r0,[sp,#0x30]         ;147
000230  e3500000          CMP      r0,#0                 ;147
000234  1a000001          BNE      |L1.576|
000238  e58d6008          STR      r6,[sp,#8]            ;148
00023c  ea000002          B        |L1.588|
                  |L1.576|
000240  e0860002          ADD      r0,r6,r2              ;150
000244  e2400a01          SUB      r0,r0,#0x1000         ;150
000248  e58d0008          STR      r0,[sp,#8]            ;150
                  |L1.588|
00024c  e3a08a01          MOV      r8,#0x1000            ;152
000250  e3a01000          MOV      r1,#0                 ;153
000254  ea000021          B        |L1.736|
                  |L1.600|
000258  e0840601          ADD      r0,r4,r1,LSL #12      ;154
00025c  e58d0004          STR      r0,[sp,#4]            ;154
000260  e59d0004          LDR      r0,[sp,#4]            ;155
000264  e1a0aa20          LSR      r10,r0,#20            ;155
000268  e59d0004          LDR      r0,[sp,#4]            ;156
00026c  e2000aff          AND      r0,r0,#0xff000        ;156
000270  e1a0b620          LSR      r11,r0,#12            ;156
000274  e59d0008          LDR      r0,[sp,#8]            ;158
000278  e1a00620          LSR      r0,r0,#12             ;158
00027c  e1a00600          LSL      r0,r0,#12             ;158
000280  e58d0000          STR      r0,[sp,#0]            ;158
000284  e59d0000          LDR      r0,[sp,#0]            ;159
000288  e3800eff          ORR      r0,r0,#0xff0          ;159
00028c  e58d0000          STR      r0,[sp,#0]            ;159
000290  e59d0000          LDR      r0,[sp,#0]            ;160
000294  e1800003          ORR      r0,r0,r3              ;160
000298  e58d0000          STR      r0,[sp,#0]            ;160
00029c  e59d0000          LDR      r0,[sp,#0]            ;161
0002a0  e3800002          ORR      r0,r0,#2              ;161
0002a4  e58d0000          STR      r0,[sp,#0]            ;161
0002a8  e085c50a          ADD      r12,r5,r10,LSL #10    ;163
0002ac  e59d0000          LDR      r0,[sp,#0]            ;163
0002b0  e78c010b          STR      r0,[r12,r11,LSL #2]   ;163
0002b4  e59d0030          LDR      r0,[sp,#0x30]         ;165
0002b8  e3500000          CMP      r0,#0                 ;165
0002bc  1a000003          BNE      |L1.720|
0002c0  e59d0008          LDR      r0,[sp,#8]            ;166
0002c4  e0800008          ADD      r0,r0,r8              ;166
0002c8  e58d0008          STR      r0,[sp,#8]            ;166
0002cc  ea000002          B        |L1.732|
                  |L1.720|
0002d0  e59d0008          LDR      r0,[sp,#8]            ;168
0002d4  e0400008          SUB      r0,r0,r8              ;168
0002d8  e58d0008          STR      r0,[sp,#8]            ;168
                  |L1.732|
0002dc  e2811001          ADD      r1,r1,#1              ;153
                  |L1.736|
0002e0  e1510009          CMP      r1,r9                 ;153
0002e4  baffffdb          BLT      |L1.600|
0002e8  e3a00000          MOV      r0,#0                 ;171
0002ec  eaffffb4          B        |L1.452|
;;;174    
                          ENDP

                  sysSetMMUMappingMethod PROC
;;;175    
;;;176    int sysSetMMUMappingMethod(int mode)
0002f0  e1a01000          MOV      r1,r0
;;;177    {
;;;178        _MMUMappingMode = mode;
0002f4  e59f0618          LDR      r0,|L1.2324|
0002f8  e5801000          STR      r1,[r0,#0]  ; _MMUMappingMode
;;;179    
;;;180        return 0;
0002fc  e3a00000          MOV      r0,#0
;;;181    
;;;182    } /* end sysSetMMUMappingMethod */
000300  e12fff1e          BX       lr
;;;183    
                          ENDP

                  sysGetSdramSizebyMB PROC
;;;266    
;;;267    INT32 sysGetSdramSizebyMB()
000304  e92d400c          PUSH     {r2,r3,lr}
;;;268    {
;;;269        unsigned int volatile reg, totalsize=0;
000308  e3a00000          MOV      r0,#0
00030c  e58d0000          STR      r0,[sp,#0]
;;;270    
;;;271        reg = inpw(SDIC_BA+0x10) & 0x07;
000310  e59f0600          LDR      r0,|L1.2328|
000314  e5900000          LDR      r0,[r0,#0]
000318  e2000007          AND      r0,r0,#7
00031c  e58d0004          STR      r0,[sp,#4]
;;;272        switch(reg) {
000320  e59d0004          LDR      r0,[sp,#4]
000324  e3500008          CMP      r0,#8
000328  308ff100          ADDCC    pc,pc,r0,LSL #2
00032c  ea00002a          B        |L1.988|
000330  ea000029          B        |L1.988|
000334  ea000005          B        |L1.848|
000338  ea000009          B        |L1.868|
00033c  ea00000d          B        |L1.888|
000340  ea000011          B        |L1.908|
000344  ea000015          B        |L1.928|
000348  ea000019          B        |L1.948|
00034c  ea00001d          B        |L1.968|
                  |L1.848|
;;;273        case 1:
000350  e1a00000          MOV      r0,r0
;;;274            totalsize += 2;
000354  e59d0000          LDR      r0,[sp,#0]
000358  e2800002          ADD      r0,r0,#2
00035c  e58d0000          STR      r0,[sp,#0]
;;;275            break;
000360  ea00001d          B        |L1.988|
                  |L1.868|
;;;276    
;;;277        case 2:
000364  e1a00000          MOV      r0,r0
;;;278            totalsize += 4;
000368  e59d0000          LDR      r0,[sp,#0]
00036c  e2800004          ADD      r0,r0,#4
000370  e58d0000          STR      r0,[sp,#0]
;;;279            break;
000374  ea000018          B        |L1.988|
                  |L1.888|
;;;280    
;;;281        case 3:
000378  e1a00000          MOV      r0,r0
;;;282            totalsize += 8;
00037c  e59d0000          LDR      r0,[sp,#0]
000380  e2800008          ADD      r0,r0,#8
000384  e58d0000          STR      r0,[sp,#0]
;;;283            break;
000388  ea000013          B        |L1.988|
                  |L1.908|
;;;284    
;;;285        case 4:
00038c  e1a00000          MOV      r0,r0
;;;286            totalsize += 16;
000390  e59d0000          LDR      r0,[sp,#0]
000394  e2800010          ADD      r0,r0,#0x10
000398  e58d0000          STR      r0,[sp,#0]
;;;287            break;
00039c  ea00000e          B        |L1.988|
                  |L1.928|
;;;288    
;;;289        case 5:
0003a0  e1a00000          MOV      r0,r0
;;;290            totalsize += 32;
0003a4  e59d0000          LDR      r0,[sp,#0]
0003a8  e2800020          ADD      r0,r0,#0x20
0003ac  e58d0000          STR      r0,[sp,#0]
;;;291            break;
0003b0  ea000009          B        |L1.988|
                  |L1.948|
;;;292    
;;;293        case 6:
0003b4  e1a00000          MOV      r0,r0
;;;294            totalsize += 64;
0003b8  e59d0000          LDR      r0,[sp,#0]
0003bc  e2800040          ADD      r0,r0,#0x40
0003c0  e58d0000          STR      r0,[sp,#0]
;;;295            break;
0003c4  ea000004          B        |L1.988|
                  |L1.968|
;;;296    
;;;297        case 7:
0003c8  e1a00000          MOV      r0,r0
;;;298            totalsize += 128;
0003cc  e59d0000          LDR      r0,[sp,#0]
0003d0  e2800080          ADD      r0,r0,#0x80
0003d4  e58d0000          STR      r0,[sp,#0]
;;;299            break;
0003d8  e1a00000          MOV      r0,r0
                  |L1.988|
0003dc  e1a00000          MOV      r0,r0                 ;275
;;;300        }
;;;301    
;;;302        reg = inpw(SDIC_BA+0x14) & 0x07;
0003e0  e59f0534          LDR      r0,|L1.2332|
0003e4  e5900000          LDR      r0,[r0,#0]
0003e8  e2000007          AND      r0,r0,#7
0003ec  e58d0004          STR      r0,[sp,#4]
;;;303        switch(reg) {
0003f0  e59d0004          LDR      r0,[sp,#4]
0003f4  e3500008          CMP      r0,#8
0003f8  308ff100          ADDCC    pc,pc,r0,LSL #2
0003fc  ea00002a          B        |L1.1196|
000400  ea000029          B        |L1.1196|
000404  ea000005          B        |L1.1056|
000408  ea000009          B        |L1.1076|
00040c  ea00000d          B        |L1.1096|
000410  ea000011          B        |L1.1116|
000414  ea000015          B        |L1.1136|
000418  ea000019          B        |L1.1156|
00041c  ea00001d          B        |L1.1176|
                  |L1.1056|
;;;304        case 1:
000420  e1a00000          MOV      r0,r0
;;;305            totalsize += 2;
000424  e59d0000          LDR      r0,[sp,#0]
000428  e2800002          ADD      r0,r0,#2
00042c  e58d0000          STR      r0,[sp,#0]
;;;306            break;
000430  ea00001d          B        |L1.1196|
                  |L1.1076|
;;;307    
;;;308        case 2:
000434  e1a00000          MOV      r0,r0
;;;309            totalsize += 4;
000438  e59d0000          LDR      r0,[sp,#0]
00043c  e2800004          ADD      r0,r0,#4
000440  e58d0000          STR      r0,[sp,#0]
;;;310            break;
000444  ea000018          B        |L1.1196|
                  |L1.1096|
;;;311    
;;;312        case 3:
000448  e1a00000          MOV      r0,r0
;;;313            totalsize += 8;
00044c  e59d0000          LDR      r0,[sp,#0]
000450  e2800008          ADD      r0,r0,#8
000454  e58d0000          STR      r0,[sp,#0]
;;;314            break;
000458  ea000013          B        |L1.1196|
                  |L1.1116|
;;;315    
;;;316        case 4:
00045c  e1a00000          MOV      r0,r0
;;;317            totalsize += 16;
000460  e59d0000          LDR      r0,[sp,#0]
000464  e2800010          ADD      r0,r0,#0x10
000468  e58d0000          STR      r0,[sp,#0]
;;;318            break;
00046c  ea00000e          B        |L1.1196|
                  |L1.1136|
;;;319    
;;;320        case 5:
000470  e1a00000          MOV      r0,r0
;;;321            totalsize += 32;
000474  e59d0000          LDR      r0,[sp,#0]
000478  e2800020          ADD      r0,r0,#0x20
00047c  e58d0000          STR      r0,[sp,#0]
;;;322            break;
000480  ea000009          B        |L1.1196|
                  |L1.1156|
;;;323    
;;;324        case 6:
000484  e1a00000          MOV      r0,r0
;;;325            totalsize += 64;
000488  e59d0000          LDR      r0,[sp,#0]
00048c  e2800040          ADD      r0,r0,#0x40
000490  e58d0000          STR      r0,[sp,#0]
;;;326            break;
000494  ea000004          B        |L1.1196|
                  |L1.1176|
;;;327    
;;;328        case 7:
000498  e1a00000          MOV      r0,r0
;;;329            totalsize += 128;
00049c  e59d0000          LDR      r0,[sp,#0]
0004a0  e2800080          ADD      r0,r0,#0x80
0004a4  e58d0000          STR      r0,[sp,#0]
;;;330            break;
0004a8  e1a00000          MOV      r0,r0
                  |L1.1196|
0004ac  e1a00000          MOV      r0,r0                 ;306
;;;331        }
;;;332    
;;;333        if (totalsize != 0)
0004b0  e59d0000          LDR      r0,[sp,#0]
0004b4  e3500000          CMP      r0,#0
0004b8  0a000001          BEQ      |L1.1220|
;;;334            return totalsize;
0004bc  e59d0000          LDR      r0,[sp,#0]
                  |L1.1216|
;;;335        else
;;;336            return 1;
;;;337    }
0004c0  e8bd800c          POP      {r2,r3,pc}
                  |L1.1220|
0004c4  e3a00001          MOV      r0,#1                 ;336
0004c8  eafffffc          B        |L1.1216|
;;;338    
                          ENDP

                  sysInitMMUTable PROC
;;;184    
;;;185    int sysInitMMUTable(int cache_mode)
0004cc  e92d41fc          PUSH     {r2-r8,lr}
;;;186    {
0004d0  e1a07000          MOV      r7,r0
;;;187        unsigned volatile int temp;
;;;188        int i, size, ramsize;
;;;189    
;;;190        if (_IsInitMMUTable == FALSE) {
0004d4  e59f0444          LDR      r0,|L1.2336|
0004d8  e5d00000          LDRB     r0,[r0,#0]  ; _IsInitMMUTable
0004dc  e3500000          CMP      r0,#0
0004e0  1a0000a1          BNE      |L1.1900|
;;;191            ramsize = sysGetSdramSizebyMB();
0004e4  ebfffffe          BL       sysGetSdramSizebyMB
0004e8  e1a06000          MOV      r6,r0
;;;192    
;;;193            //flat mapping for 4GB, 4096 section table, each size is 1MB
;;;194            temp = 0xC00;   /* (11:10) access permission, R/W */
0004ec  e3a00b03          MOV      r0,#0xc00
0004f0  e58d0004          STR      r0,[sp,#4]
;;;195            temp |= 0x1E0;  /* (8:5) domain 15 */
0004f4  e59d0004          LDR      r0,[sp,#4]
0004f8  e3800e1e          ORR      r0,r0,#0x1e0
0004fc  e58d0004          STR      r0,[sp,#4]
;;;196            temp |= 0x10;   /* bit 4 must be 1 */
000500  e59d0004          LDR      r0,[sp,#4]
000504  e3800010          ORR      r0,r0,#0x10
000508  e58d0004          STR      r0,[sp,#4]
;;;197            temp |= 0x00;   /* bit 3:2 for cache control bits, cache disabled */
00050c  e59d0004          LDR      r0,[sp,#4]
000510  e58d0004          STR      r0,[sp,#4]
;;;198            temp |= 0x02;   /* set as 1Mb section */
000514  e59d0004          LDR      r0,[sp,#4]
000518  e3800002          ORR      r0,r0,#2
00051c  e58d0004          STR      r0,[sp,#4]
;;;199    
;;;200            for (i=0; i<4096; i++) {
000520  e3a04000          MOV      r4,#0
000524  ea000004          B        |L1.1340|
                  |L1.1320|
;;;201                _mmuSectionTable[i] = (unsigned int)(temp | (i << 20));
000528  e59d0004          LDR      r0,[sp,#4]
00052c  e1800a04          ORR      r0,r0,r4,LSL #20
000530  e59f13ec          LDR      r1,|L1.2340|
000534  e7810104          STR      r0,[r1,r4,LSL #2]
000538  e2844001          ADD      r4,r4,#1              ;200
                  |L1.1340|
00053c  e3540a01          CMP      r4,#0x1000            ;200
000540  bafffff8          BLT      |L1.1320|
;;;202            }
;;;203    
;;;204            //Inside SDRAM, divide each section into 256 small pages, each page size is 4KB
;;;205            if (ramsize > _CoarsePageSize) size = _CoarsePageSize;  //maximum 64MB
000544  e3560040          CMP      r6,#0x40
000548  da000001          BLE      |L1.1364|
00054c  e3a05040          MOV      r5,#0x40
000550  ea000000          B        |L1.1368|
                  |L1.1364|
;;;206            else                           size = ramsize;
000554  e1a05006          MOV      r5,r6
                  |L1.1368|
;;;207    
;;;208            /* first 1M always direct mapping */
;;;209            sysInitPageTable(0, 0, 0x100000, cache_mode, MMU_DIRECT_MAPPING);
000558  e3a00000          MOV      r0,#0
00055c  e1a03007          MOV      r3,r7
000560  e3a02601          MOV      r2,#0x100000
000564  e58d0000          STR      r0,[sp,#0]
000568  e1a01000          MOV      r1,r0
00056c  ebfffffe          BL       sysInitPageTable
;;;210            temp = ((unsigned int)_mmuCoarsePageTable  & 0xFFFFFC00); /*  coarse table base address */
000570  e59f0398          LDR      r0,|L1.2320|
000574  e1a00520          LSR      r0,r0,#10
000578  e1a00500          LSL      r0,r0,#10
00057c  e58d0004          STR      r0,[sp,#4]
;;;211            temp |= 0x1E0;  /* (8:5) domain 15 */
000580  e59d0004          LDR      r0,[sp,#4]
000584  e3800e1e          ORR      r0,r0,#0x1e0
000588  e58d0004          STR      r0,[sp,#4]
;;;212            temp |= 0x10;   /* bit 4 must be 1 */
00058c  e59d0004          LDR      r0,[sp,#4]
000590  e3800010          ORR      r0,r0,#0x10
000594  e58d0004          STR      r0,[sp,#4]
;;;213            temp |= 0x01;   /* Coarse page table */
000598  e59d0004          LDR      r0,[sp,#4]
00059c  e3800001          ORR      r0,r0,#1
0005a0  e58d0004          STR      r0,[sp,#4]
;;;214            _mmuSectionTable[0] = temp;
0005a4  e59f1378          LDR      r1,|L1.2340|
0005a8  e59d0004          LDR      r0,[sp,#4]
0005ac  e5810000          STR      r0,[r1,#0]  ; _mmuSectionTable
;;;215    
;;;216            /* Create a shadow area at 0x80000000 for non-cacheable region */
;;;217            sysInitPageTable(0x80000000, 0x0, 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING);
0005b0  e3a00000          MOV      r0,#0
0005b4  e3e03000          MVN      r3,#0
0005b8  e3a02601          MOV      r2,#0x100000
0005bc  e58d0000          STR      r0,[sp,#0]
0005c0  e1a01000          MOV      r1,r0
0005c4  e3a00102          MOV      r0,#0x80000000
0005c8  ebfffffe          BL       sysInitPageTable
;;;218            temp = ((unsigned int)_mmuCoarsePageTable_NonCache  & 0xFFFFFC00); /*  coarse table base address */
0005cc  e59f0338          LDR      r0,|L1.2316|
0005d0  e1a00520          LSR      r0,r0,#10
0005d4  e1a00500          LSL      r0,r0,#10
0005d8  e58d0004          STR      r0,[sp,#4]
;;;219            temp |= 0x1E0;  /* (8:5) domain 15 */
0005dc  e59d0004          LDR      r0,[sp,#4]
0005e0  e3800e1e          ORR      r0,r0,#0x1e0
0005e4  e58d0004          STR      r0,[sp,#4]
;;;220            temp |= 0x10;   /* bit 4 must be 1 */
0005e8  e59d0004          LDR      r0,[sp,#4]
0005ec  e3800010          ORR      r0,r0,#0x10
0005f0  e58d0004          STR      r0,[sp,#4]
;;;221            temp |= 0x01;   /* Coarse page table */
0005f4  e59d0004          LDR      r0,[sp,#4]
0005f8  e3800001          ORR      r0,r0,#1
0005fc  e58d0004          STR      r0,[sp,#4]
;;;222            _mmuSectionTable[0x800] = temp;
000600  e59f1320          LDR      r1,|L1.2344|
000604  e59d0004          LDR      r0,[sp,#4]
000608  e5810000          STR      r0,[r1,#0]
;;;223    
;;;224            /* Mapping the other memory */
;;;225            for (i=1; i< size; i++) {
00060c  e3a04001          MOV      r4,#1
000610  ea000024          B        |L1.1704|
                  |L1.1556|
;;;226                temp = (((unsigned int)_mmuCoarsePageTable + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
000614  e59f02f4          LDR      r0,|L1.2320|
000618  e0800504          ADD      r0,r0,r4,LSL #10
00061c  e1a00520          LSR      r0,r0,#10
000620  e1a00500          LSL      r0,r0,#10
000624  e58d0004          STR      r0,[sp,#4]
;;;227                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;228                temp |= 0x1E0;  /* (8:5) domain 15 */
000628  e59d0004          LDR      r0,[sp,#4]
00062c  e3800e1e          ORR      r0,r0,#0x1e0
000630  e58d0004          STR      r0,[sp,#4]
;;;229                temp |= 0x10;   /* bit 4 must be 1 */
000634  e59d0004          LDR      r0,[sp,#4]
000638  e3800010          ORR      r0,r0,#0x10
00063c  e58d0004          STR      r0,[sp,#4]
;;;230                temp |= 0x01;   /* Coarse page table */
000640  e59d0004          LDR      r0,[sp,#4]
000644  e3800001          ORR      r0,r0,#1
000648  e58d0004          STR      r0,[sp,#4]
;;;231    
;;;232                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
00064c  e59f02c0          LDR      r0,|L1.2324|
000650  e5900000          LDR      r0,[r0,#0]  ; _MMUMappingMode
000654  e3500000          CMP      r0,#0
000658  1a000007          BNE      |L1.1660|
;;;233                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_DIRECT_MAPPING); /* direct mapping */
00065c  e3a00000          MOV      r0,#0
000660  e1a01a04          LSL      r1,r4,#20
000664  e58d0000          STR      r0,[sp,#0]
000668  e1a00a04          LSL      r0,r4,#20
00066c  e1a03007          MOV      r3,r7
000670  e3a02601          MOV      r2,#0x100000
000674  ebfffffe          BL       sysInitPageTable
000678  ea000006          B        |L1.1688|
                  |L1.1660|
;;;234                else
;;;235                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
00067c  e3a00001          MOV      r0,#1
000680  e1a01a04          LSL      r1,r4,#20
000684  e58d0000          STR      r0,[sp,#0]
000688  e1a00a04          LSL      r0,r4,#20
00068c  e1a03007          MOV      r3,r7
000690  e3a02601          MOV      r2,#0x100000
000694  ebfffffe          BL       sysInitPageTable
                  |L1.1688|
;;;236    
;;;237                _mmuSectionTable[i] = temp;
000698  e59f1284          LDR      r1,|L1.2340|
00069c  e59d0004          LDR      r0,[sp,#4]
0006a0  e7810104          STR      r0,[r1,r4,LSL #2]
0006a4  e2844001          ADD      r4,r4,#1              ;225
                  |L1.1704|
0006a8  e1540005          CMP      r4,r5                 ;225
0006ac  baffffd8          BLT      |L1.1556|
;;;238            }
;;;239    
;;;240            //Create shadow non-cacheabel region
;;;241            for (i=1; i< size; i++) {
0006b0  e3a04001          MOV      r4,#1
0006b4  ea000027          B        |L1.1880|
                  |L1.1720|
;;;242                temp = (((unsigned int)_mmuCoarsePageTable_NonCache + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
0006b8  e59f024c          LDR      r0,|L1.2316|
0006bc  e0800504          ADD      r0,r0,r4,LSL #10
0006c0  e1a00520          LSR      r0,r0,#10
0006c4  e1a00500          LSL      r0,r0,#10
0006c8  e58d0004          STR      r0,[sp,#4]
;;;243                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;244                temp |= 0x1E0;  /* (8:5) domain 15 */
0006cc  e59d0004          LDR      r0,[sp,#4]
0006d0  e3800e1e          ORR      r0,r0,#0x1e0
0006d4  e58d0004          STR      r0,[sp,#4]
;;;245                temp |= 0x10;   /* bit 4 must be 1 */
0006d8  e59d0004          LDR      r0,[sp,#4]
0006dc  e3800010          ORR      r0,r0,#0x10
0006e0  e58d0004          STR      r0,[sp,#4]
;;;246                temp |= 0x01;   /* Coarse page table */
0006e4  e59d0004          LDR      r0,[sp,#4]
0006e8  e3800001          ORR      r0,r0,#1
0006ec  e58d0004          STR      r0,[sp,#4]
;;;247    
;;;248                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
0006f0  e59f021c          LDR      r0,|L1.2324|
0006f4  e5900000          LDR      r0,[r0,#0]  ; _MMUMappingMode
0006f8  e3500000          CMP      r0,#0
0006fc  1a000008          BNE      |L1.1828|
;;;249                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING); /* direct mapping */
000700  e3a00000          MOV      r0,#0
000704  e1a01a04          LSL      r1,r4,#20
000708  e3a02102          MOV      r2,#0x80000000
00070c  e58d0000          STR      r0,[sp,#0]
000710  e1820a04          ORR      r0,r2,r4,LSL #20
000714  e3e03000          MVN      r3,#0
000718  e3a02601          MOV      r2,#0x100000
00071c  ebfffffe          BL       sysInitPageTable
000720  ea000007          B        |L1.1860|
                  |L1.1828|
;;;250                else
;;;251                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
000724  e3a00001          MOV      r0,#1
000728  e1a01a04          LSL      r1,r4,#20
00072c  e3a02102          MOV      r2,#0x80000000
000730  e58d0000          STR      r0,[sp,#0]
000734  e1820a04          ORR      r0,r2,r4,LSL #20
000738  e3e03000          MVN      r3,#0
00073c  e3a02601          MOV      r2,#0x100000
000740  ebfffffe          BL       sysInitPageTable
                  |L1.1860|
;;;252    
;;;253                _mmuSectionTable[0x800+i] = temp;
000744  e2841b02          ADD      r1,r4,#0x800
000748  e59f21d4          LDR      r2,|L1.2340|
00074c  e59d0004          LDR      r0,[sp,#4]
000750  e7820101          STR      r0,[r2,r1,LSL #2]
000754  e2844001          ADD      r4,r4,#1              ;241
                  |L1.1880|
000758  e1540005          CMP      r4,r5                 ;241
00075c  baffffd5          BLT      |L1.1720|
;;;254            }
;;;255    
;;;256            _IsInitMMUTable = TRUE;
000760  e3a00001          MOV      r0,#1
000764  e59f11b4          LDR      r1,|L1.2336|
000768  e5c10000          STRB     r0,[r1,#0]  ; _IsInitMMUTable
                  |L1.1900|
;;;257        }
;;;258    
;;;259        //moved here by cmn [2007/01/27]
;;;260        //set CP15 registers
;;;261        sysSetupCP15((unsigned int)_mmuSectionTable);
00076c  e59f01b0          LDR      r0,|L1.2340|
000770  ebfffffe          BL       sysSetupCP15
;;;262    
;;;263        return 0;
000774  e3a00000          MOV      r0,#0
;;;264    
;;;265    } /* end sysInitMMUTable */
000778  e8bd81fc          POP      {r2-r8,pc}
;;;266    
                          ENDP

                  sysFlushCache PROC
;;;338    
;;;339    void sysFlushCache(INT32 nCacheType)
00077c  e92d4070          PUSH     {r4-r6,lr}
;;;340    {
000780  e1a05000          MOV      r5,r0
;;;341        int temp;
;;;342    
;;;343        switch (nCacheType) {
000784  e3550006          CMP      r5,#6
000788  0a000004          BEQ      |L1.1952|
00078c  e3550007          CMP      r5,#7
000790  0a000006          BEQ      |L1.1968|
000794  e3550008          CMP      r5,#8
000798  1a00000f          BNE      |L1.2012|
00079c  ea000008          B        |L1.1988|
                  |L1.1952|
;;;344        case I_CACHE:
0007a0  e1a00000          MOV      r0,r0
;;;345            __asm {
;;;346                /*----- flush I-cache -----*/
;;;347                MOV temp, 0x0
0007a4  e3a04000          MOV      r4,#0
;;;348                MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
0007a8  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;349            }
;;;350            break;
0007ac  ea00000c          B        |L1.2020|
                  |L1.1968|
;;;351    
;;;352        case D_CACHE:
0007b0  e1a00000          MOV      r0,r0
;;;353                sys_flush_and_clean_dcache();
0007b4  ebfffffe          BL       sys_flush_and_clean_dcache
;;;354            __asm {
;;;355                /*----- flush D-cache & write buffer -----*/
;;;356                MOV temp, 0x0
0007b8  e3a04000          MOV      r4,#0
;;;357                MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
0007bc  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;358            }
;;;359            break;
0007c0  ea000007          B        |L1.2020|
                  |L1.1988|
;;;360    
;;;361        case I_D_CACHE:
0007c4  e1a00000          MOV      r0,r0
;;;362                sys_flush_and_clean_dcache();
0007c8  ebfffffe          BL       sys_flush_and_clean_dcache
;;;363            __asm {
;;;364                /*----- flush I, D cache & write buffer -----*/
;;;365                MOV temp, 0x0
0007cc  e3a04000          MOV      r4,#0
;;;366                MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
0007d0  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;367                MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
0007d4  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;368            }
;;;369            break;
0007d8  ea000001          B        |L1.2020|
                  |L1.2012|
;;;370    
;;;371        default:
0007dc  e1a00000          MOV      r0,r0
0007e0  e1a00000          MOV      r0,r0                 ;343
                  |L1.2020|
0007e4  e1a00000          MOV      r0,r0                 ;350
;;;372                ;
;;;373        }
;;;374    }
0007e8  e8bd8070          POP      {r4-r6,pc}
;;;375    
                          ENDP

                  sysInvalidCache PROC
;;;376    void sysInvalidCache()
0007ec  e3a00000          MOV      r0,#0
;;;377    {
;;;378        int temp;
;;;379    
;;;380        __asm {
;;;381            MOV temp, 0x0
;;;382            MCR p15, 0, temp, c7, c7, 0 /* invalidate I and D cache */
0007f0  ee070f17          MCR      p15,#0x0,r0,c7,c7,#0
;;;383        }
;;;384    }
0007f4  e12fff1e          BX       lr
;;;385    
                          ENDP

                  sysGetCacheMode PROC
;;;391    
;;;392    INT32 sysGetCacheMode()
0007f8  e59f012c          LDR      r0,|L1.2348|
;;;393    {
;;;394        return _sys_CacheMode;
0007fc  e5900000          LDR      r0,[r0,#0]  ; _sys_CacheMode
;;;395    }
000800  e12fff1e          BX       lr
;;;396    
                          ENDP

                  _sysLockCode PROC
;;;397    
;;;398    INT32 _sysLockCode(UINT32 addr, INT32 size)
000804  e92d4030          PUSH     {r4,r5,lr}
;;;399    {
000808  e1a03000          MOV      r3,r0
;;;400        int i, cnt, temp;
;;;401    
;;;402        __asm {
;;;403            /* use way3 to lock instructions */
;;;404            MRC p15, 0, temp, c9, c0, 1 ;
00080c  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;405            ORR temp, temp, 0x07 ;
000810  e3822007          ORR      r2,r2,#7
;;;406            MCR p15, 0, temp, c9, c0, 1 ;
000814  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;407        }
;;;408    
;;;409        if (size % 16)  cnt = (size/16) + 1;
000818  e1a05fc1          ASR      r5,r1,#31
00081c  e0815e25          ADD      r5,r1,r5,LSR #28
000820  e1a05245          ASR      r5,r5,#4
000824  e0515205          SUBS     r5,r1,r5,LSL #4
000828  0a000005          BEQ      |L1.2116|
00082c  e1a00001          MOV      r0,r1
000830  e1a05fc1          ASR      r5,r1,#31
000834  e0815e25          ADD      r5,r1,r5,LSR #28
000838  e1a05245          ASR      r5,r5,#4
00083c  e2854001          ADD      r4,r5,#1
000840  ea000003          B        |L1.2132|
                  |L1.2116|
;;;410        else            cnt = size / 16;
000844  e1a00001          MOV      r0,r1
000848  e1a05fc1          ASR      r5,r1,#31
00084c  e0815e25          ADD      r5,r1,r5,LSR #28
000850  e1a04245          ASR      r4,r5,#4
                  |L1.2132|
;;;411    
;;;412        for (i=0; i<cnt; i++) {
000854  e3a0c000          MOV      r12,#0
000858  ea000002          B        |L1.2152|
                  |L1.2140|
;;;413            __asm {
;;;414                MCR p15, 0, addr, c7, c13, 1;
00085c  ee073f3d          MCR      p15,#0x0,r3,c7,c13,#1
;;;415            }
;;;416    
;;;417            addr += 16;
000860  e2833010          ADD      r3,r3,#0x10
000864  e28cc001          ADD      r12,r12,#1            ;412
                  |L1.2152|
000868  e15c0004          CMP      r12,r4                ;412
00086c  bafffffa          BLT      |L1.2140|
;;;418        }
;;;419    
;;;420    
;;;421        __asm {
;;;422            /* use way3 to lock instructions */
;;;423            MRC p15, 0, temp, c9, c0, 1 ;
000870  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;424            BIC temp, temp, 0x07 ;
000874  e3c22007          BIC      r2,r2,#7
;;;425            ORR temp, temp, 0x08 ;
000878  e3822008          ORR      r2,r2,#8
;;;426            MCR p15, 0, temp, c9, c0, 1 ;
00087c  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;427        }
;;;428    
;;;429        return 0;
000880  e3a00000          MOV      r0,#0
;;;430    
;;;431    }
000884  e8bd8030          POP      {r4,r5,pc}
;;;432    
                          ENDP

                  _sysUnLockCode PROC
;;;433    
;;;434    INT32 _sysUnLockCode()
000888  ee191f30          MRC      p15,#0x0,r1,c9,c0,#1
;;;435    {
;;;436        int temp;
;;;437    
;;;438        /* unlock I-cache way 3 */
;;;439        __asm {
;;;440            MRC p15, 0, temp, c9, c0, 1;
;;;441            BIC temp, temp, 0x08 ;
00088c  e3c11008          BIC      r1,r1,#8
;;;442            MCR p15, 0, temp, c9, c0, 1;
000890  ee091f30          MCR      p15,#0x0,r1,c9,c0,#1
;;;443    
;;;444        }
;;;445    
;;;446        return 0;
000894  e3a00000          MOV      r0,#0
;;;447    }
000898  e12fff1e          BX       lr
;;;448    
                          ENDP

                  sysEnableCache PROC
;;;458     */
;;;459    INT32 sysEnableCache(UINT32 uCacheOpMode)
00089c  e92d4010          PUSH     {r4,lr}
;;;460    {
0008a0  e1a04000          MOV      r4,r0
;;;461        sysInitMMUTable(uCacheOpMode);
0008a4  e1a00004          MOV      r0,r4
0008a8  ebfffffe          BL       sysInitMMUTable
;;;462        _sys_IsCacheOn = TRUE;
0008ac  e3a00001          MOV      r0,#1
0008b0  e59f1050          LDR      r1,|L1.2312|
0008b4  e5c10000          STRB     r0,[r1,#0]  ; _sys_IsCacheOn
;;;463        _sys_CacheMode = uCacheOpMode;
0008b8  e59f006c          LDR      r0,|L1.2348|
0008bc  e5804000          STR      r4,[r0,#0]  ; _sys_CacheMode
;;;464    
;;;465        return 0;
0008c0  e3a00000          MOV      r0,#0
;;;466    }
0008c4  e8bd8010          POP      {r4,pc}
;;;467    
                          ENDP

                  sysDisableCache PROC
;;;472     */
;;;473    void sysDisableCache(void)
0008c8  e92d4010          PUSH     {r4,lr}
;;;474    {
;;;475        int temp;
;;;476    
;;;477        sys_flush_and_clean_dcache();
0008cc  ebfffffe          BL       sys_flush_and_clean_dcache
;;;478        __asm {
;;;479            /*----- flush I, D cache & write buffer -----*/
;;;480            MOV temp, 0x0
0008d0  e3a04000          MOV      r4,#0
;;;481            MCR p15, 0, temp, c7, c5, 0 /* flush I cache */
0008d4  ee074f15          MCR      p15,#0x0,r4,c7,c5,#0
;;;482            MCR p15, 0, temp, c7, c6, 0 /* flush D cache */
0008d8  ee074f16          MCR      p15,#0x0,r4,c7,c6,#0
;;;483            MCR p15, 0, temp, c7, c10,4 /* drain write buffer */
0008dc  ee074f9a          MCR      p15,#0x0,r4,c7,c10,#4
;;;484    
;;;485            /*----- disable Protection Unit -----*/
;;;486            MRC p15, 0, temp, c1, c0, 0     /* read Control register */
0008e0  ee114f10          MRC      p15,#0x0,r4,c1,c0,#0
;;;487            BIC temp, temp, 0x01
0008e4  e3c44001          BIC      r4,r4,#1
;;;488            MCR p15, 0, temp, c1, c0, 0     /* write Control register */
0008e8  ee014f10          MCR      p15,#0x0,r4,c1,c0,#0
;;;489        }
;;;490        _sys_IsCacheOn = FALSE;
0008ec  e3a00000          MOV      r0,#0
0008f0  e59f1010          LDR      r1,|L1.2312|
0008f4  e5c10000          STRB     r0,[r1,#0]  ; _sys_IsCacheOn
;;;491        _sys_CacheMode = CACHE_DISABLE;
0008f8  e3e00000          MVN      r0,#0
0008fc  e59f1028          LDR      r1,|L1.2348|
000900  e5810000          STR      r0,[r1,#0]  ; _sys_CacheMode
;;;492    
;;;493    }
000904  e8bd8010          POP      {r4,pc}
;;;494    
                          ENDP

                  |L1.2312|
                          DCD      _sys_IsCacheOn
                  |L1.2316|
                          DCD      _mmuCoarsePageTable_NonCache
                  |L1.2320|
                          DCD      _mmuCoarsePageTable
                  |L1.2324|
                          DCD      _MMUMappingMode
                  |L1.2328|
                          DCD      0xb0001810
                  |L1.2332|
                          DCD      0xb0001814
                  |L1.2336|
                          DCD      _IsInitMMUTable
                  |L1.2340|
                          DCD      _mmuSectionTable
                  |L1.2344|
                          DCD      _mmuSectionTable+0x2000
                  |L1.2348|
                          DCD      _sys_CacheMode

                          AREA ||.bss||, DATA, NOINIT, ALIGN=14

                  _mmuSectionTable
                          %        16384
                  _mmuCoarsePageTable
                          %        65536
                  _mmuCoarsePageTable_NonCache
                          %        65536

                          AREA ||.data||, DATA, ALIGN=2

                  _sys_IsCacheOn
000000  00                DCB      0x00
                  _IsInitMMUTable
000001  000000            DCB      0x00,0x00,0x00
                  _MMUMappingMode
                          DCD      0x00000000
                  _sys_CacheMode
                          DCD      0x00000000
