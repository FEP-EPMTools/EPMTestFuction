; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\leddrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\leddrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\leddrv.crf src\syshal\leddrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  readCmdAck PROC
;;;169     
;;;170    static BOOL readCmdAck()
000000  e92d4070          PUSH     {r4-r6,lr}
;;;171    {
000004  e24ddf82          SUB      sp,sp,#0x208
;;;172        uint8_t buff[512]; //buff[18];
;;;173        int index = 0;
000008  e3a04000          MOV      r4,#0
;;;174        int headindex = 0;
00000c  e3a00000          MOV      r0,#0
000010  e58d0004          STR      r0,[sp,#4]
;;;175        int counter = 0;
000014  e3a06000          MOV      r6,#0
;;;176        INT32 reVal;
;;;177        vTaskDelay(10/portTICK_RATE_MS);
000018  e3a00001          MOV      r0,#1
00001c  ebfffffe          BL       vTaskDelay
;;;178        memset(buff, 0x0, sizeof(buff));
000020  e3a01c02          MOV      r1,#0x200
000024  e28d0008          ADD      r0,sp,#8
000028  ebfffffe          BL       __aeabi_memclr4
;;;179        while(counter < COUNTER_TIMES)
00002c  ea00003a          B        |L1.284|
                  |L1.48|
;;;180        {
;;;181            short Command_ID;
;;;182            vTaskDelay(10/portTICK_RATE_MS);
000030  e3a00001          MOV      r0,#1
000034  ebfffffe          BL       vTaskDelay
;;;183            reVal = pUartInterface->readFunc(buff + index, sizeof(buff)-index);
000038  e2641c02          RSB      r1,r4,#0x200
00003c  e28d3008          ADD      r3,sp,#8
000040  e0830004          ADD      r0,r3,r4
000044  e59f338c          LDR      r3,|L1.984|
000048  e5933000          LDR      r3,[r3,#0]  ; pUartInterface
00004c  e5932008          LDR      r2,[r3,#8]
000050  e12fff32          BLX      r2
000054  e1a05000          MOV      r5,r0
;;;184            if(reVal > 0)
000058  e3550000          CMP      r5,#0
00005c  da00002a          BLE      |L1.268|
;;;185            {
;;;186                index = index + reVal;
000060  e0844005          ADD      r4,r4,r5
;;;187                /* DEBUG LED *///terninalPrintf("readCmdAck<=");
;;;188                /* DEBUG LED *///for(int i=0;i<index;i++)
;;;189                /* DEBUG LED *///terninalPrintf("%02x ",buff[i]);
;;;190                /* DEBUG LED *///terninalPrintf("\n");
;;;191                if(RUN_Results((char*)buff, index, &Command_ID, &headindex) == COMMAND_SUCCESSFUL)
000064  e20410ff          AND      r1,r4,#0xff
000068  e28d3004          ADD      r3,sp,#4
00006c  e1a0200d          MOV      r2,sp
000070  e28d0008          ADD      r0,sp,#8
000074  ebfffffe          BL       RUN_Results
000078  e3500001          CMP      r0,#1
00007c  1a000022          BNE      |L1.268|
;;;192                {
;;;193                    
;;;194                    /*
;;;195                    terninalPrintf("buff= ");
;;;196                    for(int i=0;i<18;i++)
;;;197                    {
;;;198                        terninalPrintf("%02x ",buff[i]);
;;;199                    }
;;;200                    terninalPrintf(" ");  
;;;201                    */
;;;202                    
;;;203                    if(0x07 == (uint8_t)Command_ID )
000080  e1dd00b0          LDRH     r0,[sp,#0]
000084  e20000ff          AND      r0,r0,#0xff
000088  e3500007          CMP      r0,#7
00008c  1a00001b          BNE      |L1.256|
;;;204                    {
;;;205                        if(QueryMEMSFlag)
000090  e59f0344          LDR      r0,|L1.988|
000094  e5d00000          LDRB     r0,[r0,#0]  ; QueryMEMSFlag
000098  e3500000          CMP      r0,#0
00009c  0a000017          BEQ      |L1.256|
;;;206                        {
;;;207                            QueryMEMSFlag = FALSE;
0000a0  e3a00000          MOV      r0,#0
0000a4  e59f1330          LDR      r1,|L1.988|
0000a8  e5c10000          STRB     r0,[r1,#0]  ; QueryMEMSFlag
;;;208                            xMEMSVal = (buff[6]<<8)  | buff[7];
0000ac  e5dd000f          LDRB     r0,[sp,#0xf]
0000b0  e5dd100e          LDRB     r1,[sp,#0xe]
0000b4  e1800401          ORR      r0,r0,r1,LSL #8
0000b8  e1a00800          LSL      r0,r0,#16
0000bc  e1a00840          ASR      r0,r0,#16
0000c0  e59f1318          LDR      r1,|L1.992|
0000c4  e1c100b0          STRH     r0,[r1,#0]  ; xMEMSVal
;;;209                            yMEMSVal = (buff[8]<<8)  | buff[9];
0000c8  e5dd0011          LDRB     r0,[sp,#0x11]
0000cc  e5dd1010          LDRB     r1,[sp,#0x10]
0000d0  e1800401          ORR      r0,r0,r1,LSL #8
0000d4  e1a00800          LSL      r0,r0,#16
0000d8  e1a00840          ASR      r0,r0,#16
0000dc  e59f1300          LDR      r1,|L1.996|
0000e0  e1c100b0          STRH     r0,[r1,#0]  ; yMEMSVal
;;;210                            zMEMSVal = (buff[10]<<8) | buff[11];
0000e4  e5dd0013          LDRB     r0,[sp,#0x13]
0000e8  e5dd1012          LDRB     r1,[sp,#0x12]
0000ec  e1800401          ORR      r0,r0,r1,LSL #8
0000f0  e1a00800          LSL      r0,r0,#16
0000f4  e1a00840          ASR      r0,r0,#16
0000f8  e59f12e8          LDR      r1,|L1.1000|
0000fc  e1c100b0          STRH     r0,[r1,#0]  ; zMEMSVal
                  |L1.256|
;;;211    
;;;212                        }
;;;213                    }
;;;214                    
;;;215                    
;;;216                    
;;;217                    
;;;218                    return TRUE;
000100  e3a00001          MOV      r0,#1
                  |L1.260|
000104  e28ddf82          ADD      sp,sp,#0x208
;;;219                }
;;;220            }
;;;221            sysprintf(".");        
;;;222            counter++;
;;;223        }
;;;224        return FALSE;
;;;225    }
000108  e8bd8070          POP      {r4-r6,pc}
                  |L1.268|
00010c  e28f0fb6          ADR      r0,|L1.1004|
000110  ebfffffe          BL       sysprintf
000114  e2866001          ADD      r6,r6,#1              ;222
000118  e1a00000          MOV      r0,r0                 ;223
                  |L1.284|
00011c  e356001e          CMP      r6,#0x1e              ;179
000120  baffffc2          BLT      |L1.48|
000124  e3a00000          MOV      r0,#0                 ;224
000128  eafffff5          B        |L1.260|
;;;226    
                          ENDP

                  readCmdStatus PROC
;;;227    static BOOL readCmdStatus()
00012c  e92d4070          PUSH     {r4-r6,lr}
;;;228    {
000130  e24ddf82          SUB      sp,sp,#0x208
;;;229        int index = 0;
000134  e3a04000          MOV      r4,#0
;;;230        int headindex = 0;
000138  e3a00000          MOV      r0,#0
00013c  e58d0204          STR      r0,[sp,#0x204]
;;;231        int counter = 0;
000140  e3a06000          MOV      r6,#0
;;;232        INT32 reVal;
;;;233        uint8_t buff[512];
;;;234        vTaskDelay(10/portTICK_RATE_MS);
000144  e3a00001          MOV      r0,#1
000148  ebfffffe          BL       vTaskDelay
;;;235        memset(buff, 0x0, sizeof(buff));
00014c  e3a01c02          MOV      r1,#0x200
000150  e28d0004          ADD      r0,sp,#4
000154  ebfffffe          BL       __aeabi_memclr4
;;;236        while(counter < COUNTER_TIMES)
000158  ea000058          B        |L1.704|
                  |L1.348|
;;;237        {
;;;238            short Command_ID;
;;;239            vTaskDelay(10/portTICK_RATE_MS);
00015c  e3a00001          MOV      r0,#1
000160  ebfffffe          BL       vTaskDelay
;;;240            reVal = pUartInterface->readFunc(buff + index, sizeof(buff)-index);
000164  e2641c02          RSB      r1,r4,#0x200
000168  e28d3004          ADD      r3,sp,#4
00016c  e0830004          ADD      r0,r3,r4
000170  e59f3260          LDR      r3,|L1.984|
000174  e5933000          LDR      r3,[r3,#0]  ; pUartInterface
000178  e5932008          LDR      r2,[r3,#8]
00017c  e12fff32          BLX      r2
000180  e1a05000          MOV      r5,r0
;;;241            if(reVal > 0)
000184  e3550000          CMP      r5,#0
000188  da000048          BLE      |L1.688|
;;;242            {
;;;243                index = index + reVal;
00018c  e0844005          ADD      r4,r4,r5
;;;244                /* DEBUG LED *///terninalPrintf("readCmdStatus<=");
;;;245                /* DEBUG LED *///for(int i=0;i<index;i++)
;;;246                /* DEBUG LED *///   terninalPrintf("%02x ",buff[i]);
;;;247                /* DEBUG LED *///terninalPrintf("\n");
;;;248                if(RUN_Results((char*)buff, index, &Command_ID, &headindex) == COMMAND_SUCCESSFUL)
000190  e20410ff          AND      r1,r4,#0xff
000194  e28d3f81          ADD      r3,sp,#0x204
000198  e1a0200d          MOV      r2,sp
00019c  e28d0004          ADD      r0,sp,#4
0001a0  ebfffffe          BL       RUN_Results
0001a4  e3500001          CMP      r0,#1
0001a8  1a000040          BNE      |L1.688|
;;;249                {
;;;250                    /*
;;;251                    terninalPrintf("buff= ");
;;;252                    for(int i=0;i<18;i++)
;;;253                    {
;;;254                        terninalPrintf("%02x ",buff[i]);
;;;255                    }
;;;256                    terninalPrintf(" ");  
;;;257                    */
;;;258                    if(0x00 == (uint8_t)Command_ID)
0001ac  e1dd00b0          LDRH     r0,[sp,#0]
0001b0  e31000ff          TST      r0,#0xff
0001b4  1a000002          BNE      |L1.452|
;;;259                        shakeflag = TRUE;
0001b8  e3a00001          MOV      r0,#1
0001bc  e59f122c          LDR      r1,|L1.1008|
0001c0  e5c10000          STRB     r0,[r1,#0]  ; shakeflag
                  |L1.452|
;;;260                    if((0x00 == (uint8_t)Command_ID) || (0x09 == (uint8_t)Command_ID) 
0001c4  e1dd00b0          LDRH     r0,[sp,#0]
0001c8  e31000ff          TST      r0,#0xff
0001cc  0a00000b          BEQ      |L1.512|
0001d0  e1dd00b0          LDRH     r0,[sp,#0]
0001d4  e20000ff          AND      r0,r0,#0xff
0001d8  e3500009          CMP      r0,#9
0001dc  0a000007          BEQ      |L1.512|
;;;261                        || (0x05 == (uint8_t)Command_ID) || (0x30 == (uint8_t)Command_ID))
0001e0  e1dd00b0          LDRH     r0,[sp,#0]
0001e4  e20000ff          AND      r0,r0,#0xff
0001e8  e3500005          CMP      r0,#5
0001ec  0a000003          BEQ      |L1.512|
0001f0  e1dd00b0          LDRH     r0,[sp,#0]
0001f4  e20000ff          AND      r0,r0,#0xff
0001f8  e3500030          CMP      r0,#0x30
0001fc  1a000001          BNE      |L1.520|
                  |L1.512|
;;;262                    {   
;;;263                        index = 0;
000200  e3a04000          MOV      r4,#0
;;;264                        counter = 0;
000204  e3a06000          MOV      r6,#0
                  |L1.520|
;;;265                        
;;;266                    }
;;;267                    
;;;268                    if(0x10 == (uint8_t)Command_ID )
000208  e1dd00b0          LDRH     r0,[sp,#0]
00020c  e20000ff          AND      r0,r0,#0xff
000210  e3500010          CMP      r0,#0x10
000214  1a000025          BNE      |L1.688|
;;;269                    {
;;;270                        //7a a7 (len) 11 10 ff (MEMS_XYZ Temprature 8byte) (status) (check) d3 3d 
;;;271                        //status = buff[6];
;;;272                        status = buff[14];
000218  e5dd0012          LDRB     r0,[sp,#0x12]
00021c  e59f11d0          LDR      r1,|L1.1012|
000220  e5c10000          STRB     r0,[r1,#0]  ; status
;;;273                        reVal = TRUE;
000224  e3a05001          MOV      r5,#1
;;;274                        fReadStatus = TRUE;
000228  e3a00001          MOV      r0,#1
00022c  e59f11c4          LDR      r1,|L1.1016|
000230  e5c10000          STRB     r0,[r1,#0]  ; fReadStatus
;;;275                        //terninalPrintf(" t1 ");
;;;276                        
;;;277                        if(QueryMEMSFlag)
000234  e59f01a0          LDR      r0,|L1.988|
000238  e5d00000          LDRB     r0,[r0,#0]  ; QueryMEMSFlag
00023c  e3500000          CMP      r0,#0
000240  0a000017          BEQ      |L1.676|
;;;278                        {
;;;279                            QueryMEMSFlag = FALSE;
000244  e3a00000          MOV      r0,#0
000248  e59f118c          LDR      r1,|L1.988|
00024c  e5c10000          STRB     r0,[r1,#0]  ; QueryMEMSFlag
;;;280                            xMEMSVal = (buff[6]<<8)  | buff[7];
000250  e5dd000b          LDRB     r0,[sp,#0xb]
000254  e5dd100a          LDRB     r1,[sp,#0xa]
000258  e1800401          ORR      r0,r0,r1,LSL #8
00025c  e1a00800          LSL      r0,r0,#16
000260  e1a00840          ASR      r0,r0,#16
000264  e59f1174          LDR      r1,|L1.992|
000268  e1c100b0          STRH     r0,[r1,#0]  ; xMEMSVal
;;;281                            yMEMSVal = (buff[8]<<8)  | buff[9];
00026c  e5dd000d          LDRB     r0,[sp,#0xd]
000270  e5dd100c          LDRB     r1,[sp,#0xc]
000274  e1800401          ORR      r0,r0,r1,LSL #8
000278  e1a00800          LSL      r0,r0,#16
00027c  e1a00840          ASR      r0,r0,#16
000280  e59f115c          LDR      r1,|L1.996|
000284  e1c100b0          STRH     r0,[r1,#0]  ; yMEMSVal
;;;282                            zMEMSVal = (buff[10]<<8) | buff[11];
000288  e5dd000f          LDRB     r0,[sp,#0xf]
00028c  e5dd100e          LDRB     r1,[sp,#0xe]
000290  e1800401          ORR      r0,r0,r1,LSL #8
000294  e1a00800          LSL      r0,r0,#16
000298  e1a00840          ASR      r0,r0,#16
00029c  e59f1144          LDR      r1,|L1.1000|
0002a0  e1c100b0          STRH     r0,[r1,#0]  ; zMEMSVal
                  |L1.676|
;;;283    
;;;284                        }
;;;285                        
;;;286                        return TRUE;
0002a4  e3a00001          MOV      r0,#1
                  |L1.680|
0002a8  e28ddf82          ADD      sp,sp,#0x208
;;;287                    }
;;;288                }
;;;289            }
;;;290            sysprintf(".");        
;;;291            counter++;
;;;292        }
;;;293        return FALSE;
;;;294    }
0002ac  e8bd8070          POP      {r4-r6,pc}
                  |L1.688|
0002b0  e28f0f4d          ADR      r0,|L1.1004|
0002b4  ebfffffe          BL       sysprintf
0002b8  e2866001          ADD      r6,r6,#1              ;291
0002bc  e1a00000          MOV      r0,r0                 ;292
                  |L1.704|
0002c0  e356001e          CMP      r6,#0x1e              ;236
0002c4  baffffa4          BLT      |L1.348|
0002c8  e3a00000          MOV      r0,#0                 ;293
0002cc  eafffff5          B        |L1.680|
;;;295    
                          ENDP

                  readCmdVersion PROC
;;;296    static BOOL readCmdVersion(uint8_t* VerCode1,uint8_t* VerCode2,uint8_t* VerCode3,uint8_t* YearCode,
0002d0  e92d4ff0          PUSH     {r4-r11,lr}
;;;297    														uint8_t* MonthCode,uint8_t* DayCode,uint8_t* HourCode,uint8_t* MinuteCode)
;;;298    {
0002d4  e24dd03c          SUB      sp,sp,#0x3c
0002d8  e1a06000          MOV      r6,r0
0002dc  e1a07001          MOV      r7,r1
0002e0  e1a08002          MOV      r8,r2
0002e4  e1a09003          MOV      r9,r3
0002e8  e59db060          LDR      r11,[sp,#0x60]
;;;299        int index = 0;
0002ec  e3a04000          MOV      r4,#0
;;;300        int counter = 0;
0002f0  e3a0a000          MOV      r10,#0
;;;301        int headindex = 0;
0002f4  e3a00000          MOV      r0,#0
0002f8  e58d0038          STR      r0,[sp,#0x38]
;;;302        INT32 reVal;
;;;303        uint8_t buff[50]; //buff[17];
;;;304        uint8_t cmd[7];
;;;305        vTaskDelay(10/portTICK_RATE_MS);
0002fc  e3a00001          MOV      r0,#1
000300  ebfffffe          BL       vTaskDelay
;;;306        memset(buff, 0x0, sizeof(buff));
000304  e3a01034          MOV      r1,#0x34
000308  e28d0004          ADD      r0,sp,#4
00030c  ebfffffe          BL       __aeabi_memclr4
;;;307        while(counter < COUNTER_TIMES)
000310  ea00003d          B        |L1.1036|
                  |L1.788|
;;;308        {
;;;309            short Command_ID;
;;;310            vTaskDelay(10/portTICK_RATE_MS);
000314  e3a00001          MOV      r0,#1
000318  ebfffffe          BL       vTaskDelay
;;;311            reVal = pUartInterface->readFunc(buff + index, sizeof(buff)-index);
00031c  e2641032          RSB      r1,r4,#0x32
000320  e28d3004          ADD      r3,sp,#4
000324  e0830004          ADD      r0,r3,r4
000328  e59f30a8          LDR      r3,|L1.984|
00032c  e5933000          LDR      r3,[r3,#0]  ; pUartInterface
000330  e5932008          LDR      r2,[r3,#8]
000334  e12fff32          BLX      r2
000338  e1a05000          MOV      r5,r0
;;;312            if(reVal > 0)
00033c  e3550000          CMP      r5,#0
000340  da00002d          BLE      |L1.1020|
;;;313            {
;;;314                index = index + reVal;
000344  e0844005          ADD      r4,r4,r5
;;;315                /* DEBUG LED *///terninalPrintf("<=");
;;;316                /* DEBUG LED *///for(int i=0;i<index;i++)
;;;317                /* DEBUG LED *///   terninalPrintf("%02x ",buff[i]);
;;;318                /* DEBUG LED *///terninalPrintf("\n");
;;;319                if(RUN_Results((char*)buff, index, &Command_ID, &headindex) == COMMAND_SUCCESSFUL)
000348  e20410ff          AND      r1,r4,#0xff
00034c  e28d3038          ADD      r3,sp,#0x38
000350  e1a0200d          MOV      r2,sp
000354  e28d0004          ADD      r0,sp,#4
000358  ebfffffe          BL       RUN_Results
00035c  e3500001          CMP      r0,#1
000360  1a000025          BNE      |L1.1020|
;;;320                {
;;;321                    if(0x08 == (uint8_t)Command_ID)
000364  e1dd00b0          LDRH     r0,[sp,#0]
000368  e20000ff          AND      r0,r0,#0xff
00036c  e3500008          CMP      r0,#8
000370  1a000021          BNE      |L1.1020|
;;;322                    {
;;;323                        //7a a7 (len) 11 08 ff (VersionCode1) (VersionCode2) (VersionCode3) (YearCode) (MonthCode) (DayCode)
;;;324    									  //(HourCode) (MinuteCode) (check) d3 3d 
;;;325                        
;;;326    									  *VerCode1 	= buff[6];
000374  e5dd000a          LDRB     r0,[sp,#0xa]
000378  e5c60000          STRB     r0,[r6,#0]
;;;327    										*VerCode2 	= buff[7];
00037c  e5dd000b          LDRB     r0,[sp,#0xb]
000380  e5c70000          STRB     r0,[r7,#0]
;;;328    										*VerCode3 	= buff[8];
000384  e5dd000c          LDRB     r0,[sp,#0xc]
000388  e5c80000          STRB     r0,[r8,#0]
;;;329    										*YearCode   = buff[9];
00038c  e5dd000d          LDRB     r0,[sp,#0xd]
000390  e5c90000          STRB     r0,[r9,#0]
;;;330    										*MonthCode  = buff[10];
000394  e5dd000e          LDRB     r0,[sp,#0xe]
000398  e5cb0000          STRB     r0,[r11,#0]
;;;331    										*DayCode    = buff[11];
00039c  e5dd100f          LDRB     r1,[sp,#0xf]
0003a0  e59d0064          LDR      r0,[sp,#0x64]
0003a4  e5c01000          STRB     r1,[r0,#0]
;;;332    										*HourCode   = buff[12];
0003a8  e5dd1010          LDRB     r1,[sp,#0x10]
0003ac  e59d0068          LDR      r0,[sp,#0x68]
0003b0  e5c01000          STRB     r1,[r0,#0]
;;;333    										*MinuteCode = buff[13];
0003b4  e5dd1011          LDRB     r1,[sp,#0x11]
0003b8  e59d006c          LDR      r0,[sp,#0x6c]
0003bc  e5c01000          STRB     r1,[r0,#0]
;;;334    									
;;;335                        reVal = TRUE;
0003c0  e3a05001          MOV      r5,#1
;;;336                        fReadStatus = TRUE;
0003c4  e3a00001          MOV      r0,#1
0003c8  e59f1028          LDR      r1,|L1.1016|
0003cc  e5c10000          STRB     r0,[r1,#0]  ; fReadStatus
                  |L1.976|
;;;337                        return TRUE;
0003d0  e28dd03c          ADD      sp,sp,#0x3c
;;;338                    }
;;;339                }
;;;340            }
;;;341            sysprintf(".");        
;;;342            counter++;
;;;343            
;;;344            
;;;345            
;;;346            
;;;347    
;;;348    
;;;349           // pUartInterface->writeFunc(cmd, VersionQuery((char*)cmd,sizeof(cmd)));
;;;350            
;;;351            
;;;352            
;;;353            
;;;354            
;;;355            
;;;356            
;;;357            
;;;358            
;;;359            
;;;360        }
;;;361        return FALSE;
;;;362    }
0003d4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.984|
                          DCD      pUartInterface
                  |L1.988|
                          DCD      QueryMEMSFlag
                  |L1.992|
                          DCD      xMEMSVal
                  |L1.996|
                          DCD      yMEMSVal
                  |L1.1000|
                          DCD      zMEMSVal
                  |L1.1004|
0003ec  2e00              DCB      ".",0
0003ee  00                DCB      0
0003ef  00                DCB      0
                  |L1.1008|
                          DCD      shakeflag
                  |L1.1012|
                          DCD      status
                  |L1.1016|
                          DCD      fReadStatus
                  |L1.1020|
0003fc  e24f0018          ADR      r0,|L1.1004|
000400  ebfffffe          BL       sysprintf
000404  e28aa001          ADD      r10,r10,#1            ;342
000408  e1a00000          MOV      r0,r0                 ;360
                  |L1.1036|
00040c  e35a001e          CMP      r10,#0x1e             ;307
000410  baffffbf          BLT      |L1.788|
000414  e3a00000          MOV      r0,#0                 ;361
000418  eaffffec          B        |L1.976|
;;;363    
                          ENDP

                  ledBoardWakeuped PROC
;;;390    #endif
;;;391    static BOOL ledBoardWakeuped(void)
00041c  e92d4010          PUSH     {r4,lr}
;;;392    {
;;;393        /* DEBUG LED *///terninalPrintf("%d",GPIO_ReadBit(SENSOR_PORT, SENSOR_PIN));
;;;394        if(GPIO_ReadBit(SENSOR_PORT, SENSOR_PIN))   //READ pin PortH.14
000420  e3a01902          MOV      r1,#0x8000
000424  e3a00d07          MOV      r0,#0x1c0
000428  ebfffffe          BL       GPIO_ReadBit
00042c  e3500000          CMP      r0,#0
000430  0a000001          BEQ      |L1.1084|
;;;395        {
;;;396    //        sysprintf("ledBoardWakeuped TRUE\r\n"); 
;;;397            return TRUE;
000434  e3a00001          MOV      r0,#1
                  |L1.1080|
;;;398        }
;;;399        else
;;;400        {
;;;401    //        sysprintf("ledBoardWakeuped FALSE\r\n"); 
;;;402            return FALSE;
;;;403        }
;;;404    }
000438  e8bd8010          POP      {r4,pc}
                  |L1.1084|
00043c  e3a00000          MOV      r0,#0                 ;402
000440  eafffffc          B        |L1.1080|
;;;405    
                          ENDP

                  setLedBoardWakeup PROC
;;;406    static void setLedBoardWakeup(BOOL flag)
000444  e92d4010          PUSH     {r4,lr}
;;;407    {
000448  e1a04000          MOV      r4,r0
;;;408        if(flag)
00044c  e3540000          CMP      r4,#0
000450  0a000003          BEQ      |L1.1124|
;;;409        {
;;;410    //        sysprintf("wakeup ledBoard\r\n");
;;;411            GPIO_SetBit(WAKEUP_PORT, WAKEUP_PIN);   //wakeup ledBoard PortH.15
000454  e3a01901          MOV      r1,#0x4000
000458  e3a00d07          MOV      r0,#0x1c0
00045c  ebfffffe          BL       GPIO_SetBit
000460  ea000002          B        |L1.1136|
                  |L1.1124|
;;;412        }
;;;413        else
;;;414        {
;;;415    //        sysprintf("shutdown ledBoard\r\n");
;;;416            GPIO_ClrBit(WAKEUP_PORT, WAKEUP_PIN);   //shutdown ledBoard PortH.15
000464  e3a01901          MOV      r1,#0x4000
000468  e3a00d07          MOV      r0,#0x1c0
00046c  ebfffffe          BL       GPIO_ClrBit
                  |L1.1136|
;;;417        }
;;;418        vTaskDelay(10/portTICK_RATE_MS); 
000470  e3a00001          MOV      r0,#1
000474  ebfffffe          BL       vTaskDelay
;;;419    }
000478  e8bd8010          POP      {r4,pc}
;;;420    
                          ENDP

                  wakeupLedBoard PROC
;;;421    static BOOL wakeupLedBoard()
00047c  e92d4010          PUSH     {r4,lr}
;;;422    {
;;;423        /* DEBUG LED *///terninalPrintf("\n -> wakeupLedBoard [");
;;;424        //terninalPrintf("wakeupLedBoard.\r\n");
;;;425        int counter = 0;
000480  e3a04000          MOV      r4,#0
;;;426        if(ledBoardWakeuped()) 
000484  ebfffffe          BL       ledBoardWakeuped
;;;427        {
;;;428            /* DEBUG LED *///terninalPrintf("high] (already wakeup)\r\n");
;;;429        }
;;;430        else
;;;431        {
;;;432            /* DEBUG LED *///terninalPrintf("low] (not wakeup)\r\n");
;;;433        }
;;;434        //Waking up ledBroad
;;;435        setLedBoardWakeup(TRUE);
000488  e3a00001          MOV      r0,#1
00048c  ebfffffe          BL       setLedBoardWakeup
;;;436        while(counter < COUNTER_TIMES)
000490  ea00000a          B        |L1.1216|
                  |L1.1172|
;;;437        {
;;;438            vTaskDelay(10/portTICK_RATE_MS);
000494  e3a00001          MOV      r0,#1
000498  ebfffffe          BL       vTaskDelay
;;;439            if(ledBoardWakeuped())
00049c  ebfffffe          BL       ledBoardWakeuped
0004a0  e3500000          CMP      r0,#0
0004a4  0a000004          BEQ      |L1.1212|
;;;440            {
;;;441                /* DEBUG LED *///terninalPrintf("\n");
;;;442                //terninalPrintf("wakeupLedBoard TRUE.\r\n");
;;;443                //reinitFlag = TRUE;
;;;444                ledBuzyflag = FALSE;
0004a8  e3a00000          MOV      r0,#0
0004ac  e59f1270          LDR      r1,|L1.1828|
0004b0  e5c10000          STRB     r0,[r1,#0]  ; ledBuzyflag
;;;445                return TRUE;
0004b4  e3a00001          MOV      r0,#1
                  |L1.1208|
;;;446            }
;;;447            /* DEBUG LED *///terninalPrintf(".");
;;;448            counter++;
;;;449        }
;;;450        /* DEBUG LED *///terninalPrintf("\r\n");
;;;451        setLedBoardWakeup(FALSE);
;;;452        //terninalPrintf(" -> wakeupLedBoard error\r\n");
;;;453        //terninalPrintf("wakeupLedBoard fail.\r\n");
;;;454        
;;;455        
;;;456        //ClrLedInitFlag();
;;;457        
;;;458        //vSemaphoreDelete(xSemaphoreResponse);
;;;459        //vSemaphoreDelete(xSemaphore);
;;;460        /*
;;;461        if(reinitFlag)
;;;462        {
;;;463            reinitFlag = FALSE;
;;;464            LedDrvInit(TRUE);
;;;465            vTaskDelay(6000/portTICK_RATE_MS);
;;;466        }
;;;467        */
;;;468        
;;;469        //LedDrvInit(TRUE);
;;;470        
;;;471        
;;;472        
;;;473        GPIO_SetBit(RESET_PORT, RESET_PIN);
;;;474        vTaskDelay(500/portTICK_RATE_MS);
;;;475        //vTaskDelay(1000/portTICK_RATE_MS);
;;;476        GPIO_ClrBit(RESET_PORT, RESET_PIN);
;;;477        vTaskDelay(500/portTICK_RATE_MS);
;;;478        //vTaskDelay(1000/portTICK_RATE_MS);
;;;479        GPIO_SetBit(RESET_PORT, RESET_PIN);
;;;480        
;;;481        
;;;482        //vTaskDelay(6000/portTICK_RATE_MS);
;;;483        vTaskDelay(10000/portTICK_RATE_MS);
;;;484        
;;;485        //setLedBoardWakeup(TRUE);
;;;486        
;;;487        //ledBuzyflag = TRUE;
;;;488        ledBuzyflag = FALSE;
;;;489        return FALSE;
;;;490    }
0004b8  e8bd8010          POP      {r4,pc}
                  |L1.1212|
0004bc  e2844001          ADD      r4,r4,#1              ;448
                  |L1.1216|
0004c0  e354001e          CMP      r4,#0x1e              ;436
0004c4  bafffff2          BLT      |L1.1172|
0004c8  e3a00000          MOV      r0,#0                 ;451
0004cc  ebfffffe          BL       setLedBoardWakeup
0004d0  e3a01c02          MOV      r1,#0x200             ;473
0004d4  e3a00d05          MOV      r0,#0x140             ;473
0004d8  ebfffffe          BL       GPIO_SetBit
0004dc  e3a00032          MOV      r0,#0x32              ;474
0004e0  ebfffffe          BL       vTaskDelay
0004e4  e3a01c02          MOV      r1,#0x200             ;476
0004e8  e3a00d05          MOV      r0,#0x140             ;476
0004ec  ebfffffe          BL       GPIO_ClrBit
0004f0  e3a00032          MOV      r0,#0x32              ;477
0004f4  ebfffffe          BL       vTaskDelay
0004f8  e3a01c02          MOV      r1,#0x200             ;479
0004fc  e3a00d05          MOV      r0,#0x140             ;479
000500  ebfffffe          BL       GPIO_SetBit
000504  e3a00ffa          MOV      r0,#0x3e8             ;483
000508  ebfffffe          BL       vTaskDelay
00050c  e3a00000          MOV      r0,#0                 ;488
000510  e59f120c          LDR      r1,|L1.1828|
000514  e5c10000          STRB     r0,[r1,#0]            ;488  ; ledBuzyflag
000518  e1a00000          MOV      r0,r0                 ;489
00051c  eaffffe5          B        |L1.1208|
;;;491    static BOOL shutdownLedBoard()
                          ENDP

                  shutdownLedBoard PROC
000520  e92d4010          PUSH     {r4,lr}
;;;492    {
;;;493        /* DEBUG LED *///terninalPrintf("\n -> shutdownLedBoard [");
;;;494        int counter = 0;
000524  e3a04000          MOV      r4,#0
;;;495    //    sysprintf(" -> shutdownLedBoard\r\n");
;;;496            if(ledBoardWakeuped()) 
000528  ebfffffe          BL       ledBoardWakeuped
;;;497        {
;;;498            /* DEBUG LED *///terninalPrintf("] (not shutdown)\r\n");
;;;499        }
;;;500        else
;;;501        {
;;;502            /* DEBUG LED *///terninalPrintf("] (already shutdown)\r\n");
;;;503        }
;;;504        setLedBoardWakeup(FALSE);   //shutting down LED
00052c  e3a00000          MOV      r0,#0
000530  ebfffffe          BL       setLedBoardWakeup
;;;505        while(counter < COUNTER_TIMES)
000534  ea000007          B        |L1.1368|
                  |L1.1336|
;;;506        {
;;;507            vTaskDelay(100/portTICK_RATE_MS);
000538  e3a0000a          MOV      r0,#0xa
00053c  ebfffffe          BL       vTaskDelay
;;;508            if(!ledBoardWakeuped())          
000540  ebfffffe          BL       ledBoardWakeuped
000544  e3500000          CMP      r0,#0
000548  1a000001          BNE      |L1.1364|
;;;509            {
;;;510                /* DEBUG LED *///terninalPrintf("\n");
;;;511                return TRUE;
00054c  e3a00001          MOV      r0,#1
                  |L1.1360|
;;;512            }
;;;513            //terninalPrintf(".");
;;;514            counter++;
;;;515        }
;;;516        if(readMBtestFunc())
;;;517        {}
;;;518        else
;;;519        {
;;;520            terninalPrintf(" -> shutdownLedBoard error\r\n");
;;;521        }
;;;522        return FALSE;
;;;523            
;;;524    }
000550  e8bd8010          POP      {r4,pc}
                  |L1.1364|
000554  e2844001          ADD      r4,r4,#1              ;514
                  |L1.1368|
000558  e354001e          CMP      r4,#0x1e              ;505
00055c  bafffff5          BLT      |L1.1336|
000560  ebfffffe          BL       readMBtestFunc
000564  e3500000          CMP      r0,#0                 ;516
000568  1a000001          BNE      |L1.1396|
00056c  e28f0f6d          ADR      r0,|L1.1832|
000570  ebfffffe          BL       terninalPrintf
                  |L1.1396|
000574  e3a00000          MOV      r0,#0                 ;522
000578  eafffff4          B        |L1.1360|
;;;525    static BOOL setLedPara(void)
                          ENDP

                  setLedPara PROC
00057c  e92d407f          PUSH     {r0-r6,lr}
;;;526    {
;;;527        BOOL reVal = FALSE;
000580  e3a05000          MOV      r5,#0
;;;528        uint8_t cmd[16];
;;;529        uint8_t cmdRetuemLen;
;;;530        if(wakeupLedBoard() == FALSE)
000584  ebfffffe          BL       wakeupLedBoard
000588  e3500000          CMP      r0,#0
00058c  1a000003          BNE      |L1.1440|
;;;531        {
;;;532            shutdownLedBoard();
000590  ebfffffe          BL       shutdownLedBoard
;;;533            return FALSE;
000594  e3a00000          MOV      r0,#0
                  |L1.1432|
000598  e28dd010          ADD      sp,sp,#0x10
;;;534        }
;;;535        
;;;536        cmdRetuemLen = Bay_light_Command((char*)cmd, sizeof(cmd), LED_FREQ, LED_PERIOD);
;;;537        if(cmdRetuemLen != COMMAND_ERROR)
;;;538        {
;;;539            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;540            if(readCmdAck())
;;;541            {
;;;542                sysprintf("setLedPara (bay): OK...\r\n");  
;;;543                cmdRetuemLen = State_light_Command((char*)cmd, sizeof(cmd), STATUS_LED_FREQ, STATUS_LED_PERIOD);
;;;544                
;;;545                if(cmdRetuemLen != COMMAND_ERROR)
;;;546                {
;;;547                    //printfBuffData("@@ setLedPara @@", cmd, cmdRetuemLen);
;;;548                    pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;549                    if(readCmdAck())
;;;550                    {
;;;551                        sysprintf("setLedPara (status): OK...\r\n");  
;;;552                        reVal = TRUE;
;;;553                    }
;;;554                    else
;;;555                    {
;;;556                        sysprintf("setLedPara (status): ERROR...\r\n");  
;;;557                    }
;;;558                }
;;;559                reVal = TRUE;
;;;560            }
;;;561            else
;;;562            {
;;;563                sysprintf("setLedPara (bay): ERROR...\r\n");  
;;;564            }
;;;565        }
;;;566        shutdownLedBoard();
;;;567        return reVal;
;;;568        
;;;569    }
00059c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1440|
0005a0  e3a0301e          MOV      r3,#0x1e              ;536
0005a4  e3a020ff          MOV      r2,#0xff              ;536
0005a8  e3a01010          MOV      r1,#0x10              ;536
0005ac  e1a0000d          MOV      r0,sp                 ;536
0005b0  ebfffffe          BL       Bay_light_Command
0005b4  e1a04000          MOV      r4,r0                 ;536
0005b8  e3540000          CMP      r4,#0                 ;537
0005bc  0a000025          BEQ      |L1.1624|
0005c0  e51f01f0          LDR      r0,|L1.984|
0005c4  e5900000          LDR      r0,[r0,#0]            ;539  ; pUartInterface
0005c8  e1a01004          MOV      r1,r4                 ;539
0005cc  e5902004          LDR      r2,[r0,#4]            ;539
0005d0  e1a0000d          MOV      r0,sp                 ;539
0005d4  e12fff32          BLX      r2                    ;539
0005d8  ebfffffe          BL       readCmdAck
0005dc  e3500000          CMP      r0,#0                 ;540
0005e0  0a00001a          BEQ      |L1.1616|
0005e4  e28f0f57          ADR      r0,|L1.1864|
0005e8  ebfffffe          BL       sysprintf
0005ec  e3a0300a          MOV      r3,#0xa               ;543
0005f0  e3a02000          MOV      r2,#0                 ;543
0005f4  e3a01010          MOV      r1,#0x10              ;543
0005f8  e1a0000d          MOV      r0,sp                 ;543
0005fc  ebfffffe          BL       State_light_Command
000600  e1a04000          MOV      r4,r0                 ;543
000604  e3540000          CMP      r4,#0                 ;545
000608  0a00000e          BEQ      |L1.1608|
00060c  e51f023c          LDR      r0,|L1.984|
000610  e5900000          LDR      r0,[r0,#0]            ;548  ; pUartInterface
000614  e1a01004          MOV      r1,r4                 ;548
000618  e5902004          LDR      r2,[r0,#4]            ;548
00061c  e1a0000d          MOV      r0,sp                 ;548
000620  e12fff32          BLX      r2                    ;548
000624  ebfffffe          BL       readCmdAck
000628  e3500000          CMP      r0,#0                 ;549
00062c  0a000003          BEQ      |L1.1600|
000630  e28f0f4b          ADR      r0,|L1.1892|
000634  ebfffffe          BL       sysprintf
000638  e3a05001          MOV      r5,#1                 ;552
00063c  ea000001          B        |L1.1608|
                  |L1.1600|
000640  e28f0f4f          ADR      r0,|L1.1924|
000644  ebfffffe          BL       sysprintf
                  |L1.1608|
000648  e3a05001          MOV      r5,#1                 ;559
00064c  ea000001          B        |L1.1624|
                  |L1.1616|
000650  e28f0f53          ADR      r0,|L1.1956|
000654  ebfffffe          BL       sysprintf
                  |L1.1624|
000658  ebfffffe          BL       shutdownLedBoard
00065c  e1a00005          MOV      r0,r5                 ;567
000660  eaffffcc          B        |L1.1432|
;;;570    #if (ENABLE_BURNIN_TESTER)
                          ENDP

                  setColor PROC
;;;572    #endif
;;;573    static BOOL setColor(uint8_t* bayColor, uint8_t statusColor)
000664  e92d41ff          PUSH     {r0-r8,lr}
;;;574    {
000668  e1a05000          MOV      r5,r0
00066c  e1a06001          MOV      r6,r1
;;;575        BOOL reVal = FALSE;
000670  e3a07000          MOV      r7,#0
;;;576        uint8_t cmd[16];
;;;577        uint8_t cmdRetuemLen;
;;;578        if(wakeupLedBoard() == FALSE)
000674  ebfffffe          BL       wakeupLedBoard
000678  e3500000          CMP      r0,#0
00067c  1a000010          BNE      |L1.1732|
;;;579        {
;;;580            terninalPrintf("setColor wakeupLedBoard error\r\n");
000680  e28f0f4f          ADR      r0,|L1.1988|
000684  ebfffffe          BL       terninalPrintf
;;;581    #if (ENABLE_BURNIN_TESTER)
;;;582            if (EnabledBurninTestMode())
000688  ebfffffe          BL       EnabledBurninTestMode
00068c  e3500000          CMP      r0,#0
000690  0a000008          BEQ      |L1.1720|
;;;583            {
;;;584                sprintf(errorMsgBuffer, "setColor ==> wakeupLedBoard error !!\r\n");
000694  e28f1f52          ADR      r1,|L1.2020|
000698  e59f016c          LDR      r0,|L1.2060|
00069c  ebfffffe          BL       __2sprintf
;;;585                AppendBurninErrorLog(errorMsgBuffer, strlen(errorMsgBuffer));
0006a0  e59f0164          LDR      r0,|L1.2060|
0006a4  ebfffffe          BL       strlen
0006a8  e1a08000          MOV      r8,r0
0006ac  e1a01008          MOV      r1,r8
0006b0  e59f0154          LDR      r0,|L1.2060|
0006b4  ebfffffe          BL       AppendBurninErrorLog
                  |L1.1720|
;;;586            }
;;;587    #endif
;;;588            return FALSE;
0006b8  e3a00000          MOV      r0,#0
                  |L1.1724|
0006bc  e28dd010          ADD      sp,sp,#0x10
;;;589        }    
;;;590        #if(0)
;;;591        cmdRetuemLen = Bay_light_Command((char*)cmd, sizeof(cmd), LED_FREQ, LED_PERIOD);
;;;592        if(cmdRetuemLen != COMMAND_ERROR)
;;;593        {
;;;594            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;595            if(readCmdAck())
;;;596            {
;;;597                sysprintf("setLedPara (bay): OK...\r\n");  
;;;598                cmdRetuemLen = State_light_Command((char*)cmd, sizeof(cmd), STATUS_LED_FREQ, STATUS_LED_PERIOD);
;;;599                if(cmdRetuemLen != COMMAND_ERROR)
;;;600                {
;;;601                    //printfBuffData("@@ setColor @@", cmd, cmdRetuemLen);
;;;602                    pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;603                    if(readCmdAck())
;;;604                    {
;;;605                        sysprintf("setLedPara (status): OK...\r\n");  
;;;606                        reVal = TRUE;
;;;607                    }
;;;608                    else
;;;609                    {
;;;610                        sysprintf("setLedPara (status): ERROR...\r\n");  
;;;611                    }
;;;612                }
;;;613                reVal = TRUE;
;;;614            }
;;;615            else
;;;616            {
;;;617                sysprintf("setLedPara (bay): ERROR...\r\n");  
;;;618            }
;;;619        }
;;;620        #endif
;;;621        cmdRetuemLen = Light_Color_Command((char*)cmd, sizeof(cmd), bayColor, statusColor);
;;;622        if(cmdRetuemLen != COMMAND_ERROR)
;;;623        {
;;;624            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;625            if(readCmdAck())
;;;626            {
;;;627                //sysprintf("setColor: OK...\r\n");  
;;;628                //sysprintf("Led Color:[%d, %d, %d, %d, %d, %d, %d, %d: %d]\n\r", bayColor[0], bayColor[1], bayColor[2], bayColor[3], bayColor[4], bayColor[5], bayColor[6], bayColor[7], statusColor);
;;;629                reVal = TRUE;
;;;630            }
;;;631            else
;;;632            {
;;;633                sysprintf("setColor: ERROR...\r\n");
;;;634            }
;;;635        }
;;;636        shutdownLedBoard();
;;;637        return reVal;
;;;638    }
0006c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1732|
0006c4  e1a03006          MOV      r3,r6                 ;621
0006c8  e1a02005          MOV      r2,r5                 ;621
0006cc  e3a01010          MOV      r1,#0x10              ;621
0006d0  e1a0000d          MOV      r0,sp                 ;621
0006d4  ebfffffe          BL       Light_Color_Command
0006d8  e1a04000          MOV      r4,r0                 ;621
0006dc  e3540000          CMP      r4,#0                 ;622
0006e0  0a00000c          BEQ      |L1.1816|
0006e4  e51f0314          LDR      r0,|L1.984|
0006e8  e5900000          LDR      r0,[r0,#0]            ;624  ; pUartInterface
0006ec  e1a01004          MOV      r1,r4                 ;624
0006f0  e5902004          LDR      r2,[r0,#4]            ;624
0006f4  e1a0000d          MOV      r0,sp                 ;624
0006f8  e12fff32          BLX      r2                    ;624
0006fc  ebfffffe          BL       readCmdAck
000700  e3500000          CMP      r0,#0                 ;625
000704  0a000001          BEQ      |L1.1808|
000708  e3a07001          MOV      r7,#1                 ;629
00070c  ea000001          B        |L1.1816|
                  |L1.1808|
000710  e28f00f8          ADR      r0,|L1.2064|
000714  ebfffffe          BL       sysprintf
                  |L1.1816|
000718  ebfffffe          BL       shutdownLedBoard
00071c  e1a00007          MOV      r0,r7                 ;637
000720  eaffffe5          B        |L1.1724|
                  |L1.1828|
                          DCD      ledBuzyflag
                  |L1.1832|
000728  202d3e20          DCB      " -> shutdownLedBoard error\r\n",0
00072c  73687574
000730  646f776e
000734  4c656442
000738  6f617264
00073c  20657272
000740  6f720d0a
000744  00      
000745  00                DCB      0
000746  00                DCB      0
000747  00                DCB      0
                  |L1.1864|
000748  7365744c          DCB      "setLedPara (bay): OK...\r\n",0
00074c  65645061
000750  72612028
000754  62617929
000758  3a204f4b
00075c  2e2e2e0d
000760  0a00    
000762  00                DCB      0
000763  00                DCB      0
                  |L1.1892|
000764  7365744c          DCB      "setLedPara (status): OK...\r\n",0
000768  65645061
00076c  72612028
000770  73746174
000774  7573293a
000778  204f4b2e
00077c  2e2e0d0a
000780  00      
000781  00                DCB      0
000782  00                DCB      0
000783  00                DCB      0
                  |L1.1924|
000784  7365744c          DCB      "setLedPara (status): ERROR...\r\n",0
000788  65645061
00078c  72612028
000790  73746174
000794  7573293a
000798  20455252
00079c  4f522e2e
0007a0  2e0d0a00
                  |L1.1956|
0007a4  7365744c          DCB      "setLedPara (bay): ERROR...\r\n",0
0007a8  65645061
0007ac  72612028
0007b0  62617929
0007b4  3a204552
0007b8  524f522e
0007bc  2e2e0d0a
0007c0  00      
0007c1  00                DCB      0
0007c2  00                DCB      0
0007c3  00                DCB      0
                  |L1.1988|
0007c4  73657443          DCB      "setColor wakeupLedBoard error\r\n",0
0007c8  6f6c6f72
0007cc  2077616b
0007d0  6575704c
0007d4  6564426f
0007d8  61726420
0007dc  6572726f
0007e0  720d0a00
                  |L1.2020|
0007e4  73657443          DCB      "setColor ==> wakeupLedBoard error !!\r\n",0
0007e8  6f6c6f72
0007ec  203d3d3e
0007f0  2077616b
0007f4  6575704c
0007f8  6564426f
0007fc  61726420
000800  6572726f
000804  72202121
000808  0d0a00  
00080b  00                DCB      0
                  |L1.2060|
                          DCD      errorMsgBuffer
                  |L1.2064|
000810  73657443          DCB      "setColor: ERROR...\r\n",0
000814  6f6c6f72
000818  3a204552
00081c  524f522e
000820  2e2e0d0a
000824  00      
000825  00                DCB      0
000826  00                DCB      0
000827  00                DCB      0
                          ENDP

                  sendHeartbeat PROC
;;;666    
;;;667    static BOOL sendHeartbeat(uint8_t DeathMin , int DeathSec)
000828  e92d41ff          PUSH     {r0-r8,lr}
;;;668    {
00082c  e1a05000          MOV      r5,r0
000830  e1a06001          MOV      r6,r1
;;;669        local_DeathMin = DeathMin;
000834  e59f023c          LDR      r0,|L1.2680|
000838  e5c05000          STRB     r5,[r0,#0]  ; local_DeathMin
;;;670        local_DeathSec = DeathSec;
00083c  e59f0238          LDR      r0,|L1.2684|
000840  e5806000          STR      r6,[r0,#0]  ; local_DeathSec
;;;671        BOOL reVal = FALSE;
000844  e3a07000          MOV      r7,#0
;;;672        uint8_t cmd[16];
;;;673        uint8_t cmdRetuemLen;
;;;674        if(wakeupLedBoard() == FALSE)
000848  ebfffffe          BL       wakeupLedBoard
00084c  e3500000          CMP      r0,#0
000850  1a000004          BNE      |L1.2152|
;;;675        {
;;;676            terninalPrintf("sendHeartbeat wakeupLedBoard FALSE.\r\n");
000854  e28f0f89          ADR      r0,|L1.2688|
000858  ebfffffe          BL       terninalPrintf
;;;677            return FALSE;
00085c  e3a00000          MOV      r0,#0
                  |L1.2144|
000860  e28dd010          ADD      sp,sp,#0x10
;;;678        }    
;;;679      
;;;680        cmdRetuemLen = HeartBeatTimeSet((char*)cmd, sizeof(cmd), DeathMin, DeathSec);
;;;681    //    sysprintf("HeartBeatTimeSet: %d[0x%02x, 0x%02x]...\r\n", cmdRetuemLen, cmd[4] , cmd[5]); 
;;;682        if(cmdRetuemLen != COMMAND_ERROR)
;;;683        {
;;;684            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;685            if(readCmdStatus())
;;;686            {           
;;;687                reVal = TRUE;
;;;688            }
;;;689            else
;;;690            {
;;;691                sysprintf("LedSendHeartbeat: ERROR...\r\n");  
;;;692            }
;;;693            
;;;694        }
;;;695        shutdownLedBoard();
;;;696        return reVal;
;;;697    }
000864  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2152|
000868  e20630ff          AND      r3,r6,#0xff           ;680
00086c  e1a02005          MOV      r2,r5                 ;680
000870  e3a01010          MOV      r1,#0x10              ;680
000874  e1a0000d          MOV      r0,sp                 ;680
000878  ebfffffe          BL       HeartBeatTimeSet
00087c  e1a04000          MOV      r4,r0                 ;680
000880  e3540000          CMP      r4,#0                 ;682
000884  0a00000c          BEQ      |L1.2236|
000888  e51f04b8          LDR      r0,|L1.984|
00088c  e5900000          LDR      r0,[r0,#0]            ;684  ; pUartInterface
000890  e1a01004          MOV      r1,r4                 ;684
000894  e5902004          LDR      r2,[r0,#4]            ;684
000898  e1a0000d          MOV      r0,sp                 ;684
00089c  e12fff32          BLX      r2                    ;684
0008a0  ebfffffe          BL       readCmdStatus
0008a4  e3500000          CMP      r0,#0                 ;685
0008a8  0a000001          BEQ      |L1.2228|
0008ac  e3a07001          MOV      r7,#1                 ;687
0008b0  ea000001          B        |L1.2236|
                  |L1.2228|
0008b4  e28f0f7b          ADR      r0,|L1.2728|
0008b8  ebfffffe          BL       sysprintf
                  |L1.2236|
0008bc  ebfffffe          BL       shutdownLedBoard
0008c0  e1a00007          MOV      r0,r7                 ;696
0008c4  eaffffe5          B        |L1.2144|
;;;698    static BOOL memsCalibrationSet(void)
                          ENDP

                  memsCalibrationSet PROC
0008c8  e92d407f          PUSH     {r0-r6,lr}
;;;699    {
;;;700        BOOL reVal = FALSE;
0008cc  e3a05000          MOV      r5,#0
;;;701        uint8_t cmd[16];
;;;702        uint8_t cmdRetuemLen;
;;;703        if(wakeupLedBoard() == FALSE)
0008d0  ebfffffe          BL       wakeupLedBoard
0008d4  e3500000          CMP      r0,#0
0008d8  1a000002          BNE      |L1.2280|
;;;704        {
;;;705            return FALSE;
0008dc  e3a00000          MOV      r0,#0
                  |L1.2272|
0008e0  e28dd010          ADD      sp,sp,#0x10
;;;706        }    
;;;707      
;;;708        cmdRetuemLen = CalibrationSet((char*)cmd,sizeof(cmd));
;;;709    //    sysprintf("HeartBeatTimeSet: %d[0x%02x, 0x%02x]...\r\n", cmdRetuemLen, cmd[4] , cmd[5]); 
;;;710        if(cmdRetuemLen != COMMAND_ERROR)
;;;711        {
;;;712            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;713            if(readCmdAck())
;;;714            {
;;;715    //            sysprintf("LedSendHeartbeat: OK...\r\n");              
;;;716                reVal = TRUE;
;;;717            }
;;;718            else
;;;719            {
;;;720                sysprintf("LedSendHeartbeat: ERROR...\r\n");  
;;;721            }
;;;722        }
;;;723        shutdownLedBoard();
;;;724        return reVal;
;;;725    }
0008e4  e8bd8070          POP      {r4-r6,pc}
                  |L1.2280|
0008e8  e3a01010          MOV      r1,#0x10              ;708
0008ec  e1a0000d          MOV      r0,sp                 ;708
0008f0  ebfffffe          BL       CalibrationSet
0008f4  e1a04000          MOV      r4,r0                 ;708
0008f8  e3540000          CMP      r4,#0                 ;710
0008fc  0a00000c          BEQ      |L1.2356|
000900  e51f0530          LDR      r0,|L1.984|
000904  e5900000          LDR      r0,[r0,#0]            ;712  ; pUartInterface
000908  e1a01004          MOV      r1,r4                 ;712
00090c  e5902004          LDR      r2,[r0,#4]            ;712
000910  e1a0000d          MOV      r0,sp                 ;712
000914  e12fff32          BLX      r2                    ;712
000918  ebfffffe          BL       readCmdAck
00091c  e3500000          CMP      r0,#0                 ;713
000920  0a000001          BEQ      |L1.2348|
000924  e3a05001          MOV      r5,#1                 ;716
000928  ea000001          B        |L1.2356|
                  |L1.2348|
00092c  e28f0f5d          ADR      r0,|L1.2728|
000930  ebfffffe          BL       sysprintf
                  |L1.2356|
000934  ebfffffe          BL       shutdownLedBoard
000938  e1a00005          MOV      r0,r5                 ;724
00093c  eaffffe7          B        |L1.2272|
;;;726    
                          ENDP

                  memsCollisionSet PROC
;;;727    static BOOL memsCollisionSet(void)
000940  e92d4030          PUSH     {r4,r5,lr}
;;;728    {
000944  e24dd01c          SUB      sp,sp,#0x1c
;;;729        BOOL reVal = FALSE;
000948  e3a05000          MOV      r5,#0
;;;730        uint8_t cmd[16];
;;;731        uint8_t cmdRetuemLen;
;;;732        if(wakeupLedBoard() == FALSE)
00094c  ebfffffe          BL       wakeupLedBoard
000950  e3500000          CMP      r0,#0
000954  1a000002          BNE      |L1.2404|
;;;733        {
;;;734            return FALSE;
000958  e3a00000          MOV      r0,#0
                  |L1.2396|
00095c  e28dd01c          ADD      sp,sp,#0x1c
;;;735        }
;;;736        
;;;737        cmdRetuemLen = CollisionSet((char*)cmd,sizeof(cmd),local_bias_degree,local_strength_X,local_strength_Y,local_strength_Z);
;;;738    //    sysprintf("HeartBeatTimeSet: %d[0x%02x, 0x%02x]...\r\n", cmdRetuemLen, cmd[4] , cmd[5]); 
;;;739        if(cmdRetuemLen != COMMAND_ERROR)
;;;740        {
;;;741            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;742            if(readCmdAck())
;;;743            {
;;;744    //            sysprintf("LedSendHeartbeat: OK...\r\n");
;;;745                reVal = TRUE;
;;;746            }
;;;747            else
;;;748            {
;;;749                sysprintf("LedSendHeartbeat: ERROR...\r\n");
;;;750            }
;;;751        }
;;;752        shutdownLedBoard();
;;;753        return reVal;
;;;754    }
000960  e8bd8030          POP      {r4,r5,pc}
                  |L1.2404|
000964  e59f015c          LDR      r0,|L1.2760|
000968  e5d00000          LDRB     r0,[r0,#0]            ;737  ; local_strength_Z
00096c  e59f1158          LDR      r1,|L1.2764|
000970  e5d11000          LDRB     r1,[r1,#0]            ;737  ; local_strength_Y
000974  e58d0004          STR      r0,[sp,#4]            ;737
000978  e59f0150          LDR      r0,|L1.2768|
00097c  e58d1000          STR      r1,[sp,#0]            ;737
000980  e5d03000          LDRB     r3,[r0,#0]            ;737  ; local_strength_X
000984  e59f0148          LDR      r0,|L1.2772|
000988  e5d02000          LDRB     r2,[r0,#0]            ;737  ; local_bias_degree
00098c  e3a01010          MOV      r1,#0x10              ;737
000990  e28d000c          ADD      r0,sp,#0xc            ;737
000994  ebfffffe          BL       CollisionSet
000998  e1a04000          MOV      r4,r0                 ;737
00099c  e3540000          CMP      r4,#0                 ;739
0009a0  0a00000c          BEQ      |L1.2520|
0009a4  e51f05d4          LDR      r0,|L1.984|
0009a8  e5900000          LDR      r0,[r0,#0]            ;741  ; pUartInterface
0009ac  e1a01004          MOV      r1,r4                 ;741
0009b0  e5902004          LDR      r2,[r0,#4]            ;741
0009b4  e28d000c          ADD      r0,sp,#0xc            ;741
0009b8  e12fff32          BLX      r2                    ;741
0009bc  ebfffffe          BL       readCmdAck
0009c0  e3500000          CMP      r0,#0                 ;742
0009c4  0a000001          BEQ      |L1.2512|
0009c8  e3a05001          MOV      r5,#1                 ;745
0009cc  ea000001          B        |L1.2520|
                  |L1.2512|
0009d0  e28f00d0          ADR      r0,|L1.2728|
0009d4  ebfffffe          BL       sysprintf
                  |L1.2520|
0009d8  ebfffffe          BL       shutdownLedBoard
0009dc  e1a00005          MOV      r0,r5                 ;753
0009e0  eaffffdd          B        |L1.2396|
;;;755    
                          ENDP

                  memsCollisionClean PROC
;;;756    static BOOL memsCollisionClean(void)
0009e4  e92d407f          PUSH     {r0-r6,lr}
;;;757    {
;;;758        BOOL reVal = FALSE;
0009e8  e3a05000          MOV      r5,#0
;;;759        uint8_t cmd[16];
;;;760        //uint8_t cmd[7];
;;;761        uint8_t cmdRetuemLen;
;;;762        if(wakeupLedBoard() == FALSE)
0009ec  ebfffffe          BL       wakeupLedBoard
0009f0  e3500000          CMP      r0,#0
0009f4  1a000002          BNE      |L1.2564|
;;;763        {
;;;764            return FALSE;
0009f8  e3a00000          MOV      r0,#0
                  |L1.2556|
0009fc  e28dd010          ADD      sp,sp,#0x10
;;;765        }    
;;;766      
;;;767        cmdRetuemLen = CollisionClean((char*)cmd,sizeof(cmd));
;;;768    //    sysprintf("HeartBeatTimeSet: %d[0x%02x, 0x%02x]...\r\n", cmdRetuemLen, cmd[4] , cmd[5]); 
;;;769        if(cmdRetuemLen != COMMAND_ERROR)
;;;770        {
;;;771            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;772            vTaskDelay(10/portTICK_RATE_MS);
;;;773            if(readCmdAck())
;;;774            {
;;;775    //            sysprintf("LedSendHeartbeat: OK...\r\n");              
;;;776                reVal = TRUE;
;;;777            }
;;;778            else
;;;779            {
;;;780                if(readMBtestFunc())
;;;781                {}
;;;782                else
;;;783                {
;;;784                    terninalPrintf("memsCollisionClean Error...\r\n");
;;;785                }
;;;786                sysprintf("LedSendHeartbeat: ERROR...\r\n");  
;;;787            }
;;;788        }
;;;789        shutdownLedBoard();
;;;790        return reVal;
;;;791    }
000a00  e8bd8070          POP      {r4-r6,pc}
                  |L1.2564|
000a04  e3a01010          MOV      r1,#0x10              ;767
000a08  e1a0000d          MOV      r0,sp                 ;767
000a0c  ebfffffe          BL       CollisionClean
000a10  e1a04000          MOV      r4,r0                 ;767
000a14  e3540000          CMP      r4,#0                 ;769
000a18  0a000013          BEQ      |L1.2668|
000a1c  e51f064c          LDR      r0,|L1.984|
000a20  e5900000          LDR      r0,[r0,#0]            ;771  ; pUartInterface
000a24  e1a01004          MOV      r1,r4                 ;771
000a28  e5902004          LDR      r2,[r0,#4]            ;771
000a2c  e1a0000d          MOV      r0,sp                 ;771
000a30  e12fff32          BLX      r2                    ;771
000a34  e3a00001          MOV      r0,#1                 ;772
000a38  ebfffffe          BL       vTaskDelay
000a3c  ebfffffe          BL       readCmdAck
000a40  e3500000          CMP      r0,#0                 ;773
000a44  0a000001          BEQ      |L1.2640|
000a48  e3a05001          MOV      r5,#1                 ;776
000a4c  ea000006          B        |L1.2668|
                  |L1.2640|
000a50  ebfffffe          BL       readMBtestFunc
000a54  e3500000          CMP      r0,#0                 ;780
000a58  1a000001          BNE      |L1.2660|
000a5c  e28f0074          ADR      r0,|L1.2776|
000a60  ebfffffe          BL       terninalPrintf
                  |L1.2660|
000a64  e28f003c          ADR      r0,|L1.2728|
000a68  ebfffffe          BL       sysprintf
                  |L1.2668|
000a6c  ebfffffe          BL       shutdownLedBoard
000a70  e1a00005          MOV      r0,r5                 ;790
000a74  eaffffe0          B        |L1.2556|
                  |L1.2680|
                          DCD      local_DeathMin
                  |L1.2684|
                          DCD      local_DeathSec
                  |L1.2688|
000a80  73656e64          DCB      "sendHeartbeat wakeupLedBoard FALSE.\r\n",0
000a84  48656172
000a88  74626561
000a8c  74207761
000a90  6b657570
000a94  4c656442
000a98  6f617264
000a9c  2046414c
000aa0  53452e0d
000aa4  0a00    
000aa6  00                DCB      0
000aa7  00                DCB      0
                  |L1.2728|
000aa8  4c656453          DCB      "LedSendHeartbeat: ERROR...\r\n",0
000aac  656e6448
000ab0  65617274
000ab4  62656174
000ab8  3a204552
000abc  524f522e
000ac0  2e2e0d0a
000ac4  00      
000ac5  00                DCB      0
000ac6  00                DCB      0
000ac7  00                DCB      0
                  |L1.2760|
                          DCD      local_strength_Z
                  |L1.2764|
                          DCD      local_strength_Y
                  |L1.2768|
                          DCD      local_strength_X
                  |L1.2772|
                          DCD      local_bias_degree
                  |L1.2776|
000ad8  6d656d73          DCB      "memsCollisionClean Error...\r\n",0
000adc  436f6c6c
000ae0  6973696f
000ae4  6e436c65
000ae8  616e2045
000aec  72726f72
000af0  2e2e2e0d
000af4  0a00    
000af6  00                DCB      0
000af7  00                DCB      0
                          ENDP

                  sendFactoryTest PROC
;;;792    
;;;793    static BOOL sendFactoryTest()
000af8  e92d407c          PUSH     {r2-r6,lr}
;;;794    {
;;;795        BOOL reVal = FALSE;
000afc  e3a05000          MOV      r5,#0
;;;796        //uint8_t cmd[16];
;;;797        uint8_t cmd[7];
;;;798        uint8_t cmdRetuemLen;
;;;799        if(wakeupLedBoard() == FALSE)
000b00  ebfffffe          BL       wakeupLedBoard
000b04  e3500000          CMP      r0,#0
000b08  1a000001          BNE      |L1.2836|
;;;800        {
;;;801            return FALSE;
000b0c  e3a00000          MOV      r0,#0
                  |L1.2832|
;;;802        }    
;;;803        cmdRetuemLen = FactoryTest((char*)cmd, sizeof(cmd));    /*get cmd*/
;;;804        sysprintf("LedSendFactoryTest: %d[0x%02x, 0x%02x]...\r\n", cmdRetuemLen, cmd[4] , cmd[5]); 
;;;805        if(cmdRetuemLen != COMMAND_ERROR)
;;;806        {
;;;807                /* DEBUG LED *///terninalPrintf("cmd=>");
;;;808        /* DEBUG LED *///for(int i=0;i<cmdRetuemLen;i++)
;;;809        /* DEBUG LED */    //terninalPrintf("%02x ",cmd[i]);
;;;810        /* DEBUG LED *///terninalPrintf("\n");
;;;811            //vTaskDelay(1000/portTICK_RATE_MS);
;;;812            pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;813            if(readCmdAck())
;;;814            {
;;;815                sysprintf("LedSendFactoryTest: OK...\r\n");              
;;;816                reVal = TRUE;
;;;817            }
;;;818            else
;;;819            {
;;;820                sysprintf("LedSendFactoryTest: ERROR...\r\n");  
;;;821            }
;;;822        }
;;;823        shutdownLedBoard();
;;;824        return reVal;
;;;825    }
000b10  e8bd807c          POP      {r2-r6,pc}
                  |L1.2836|
000b14  e3a01007          MOV      r1,#7                 ;803
000b18  e1a0000d          MOV      r0,sp                 ;803
000b1c  ebfffffe          BL       FactoryTest
000b20  e20040ff          AND      r4,r0,#0xff           ;803
000b24  e5dd3005          LDRB     r3,[sp,#5]            ;804
000b28  e5dd2004          LDRB     r2,[sp,#4]            ;804
000b2c  e1a01004          MOV      r1,r4                 ;804
000b30  e28f0f6e          ADR      r0,|L1.3312|
000b34  ebfffffe          BL       sysprintf
000b38  e3540000          CMP      r4,#0                 ;805
000b3c  0a00000e          BEQ      |L1.2940|
000b40  e51f0770          LDR      r0,|L1.984|
000b44  e5900000          LDR      r0,[r0,#0]            ;812  ; pUartInterface
000b48  e1a01004          MOV      r1,r4                 ;812
000b4c  e5902004          LDR      r2,[r0,#4]            ;812
000b50  e1a0000d          MOV      r0,sp                 ;812
000b54  e12fff32          BLX      r2                    ;812
000b58  ebfffffe          BL       readCmdAck
000b5c  e3500000          CMP      r0,#0                 ;813
000b60  0a000003          BEQ      |L1.2932|
000b64  e28f0e1b          ADR      r0,|L1.3356|
000b68  ebfffffe          BL       sysprintf
000b6c  e3a05001          MOV      r5,#1                 ;816
000b70  ea000001          B        |L1.2940|
                  |L1.2932|
000b74  e28f0f6f          ADR      r0,|L1.3384|
000b78  ebfffffe          BL       sysprintf
                  |L1.2940|
000b7c  ebfffffe          BL       shutdownLedBoard
000b80  e1a00005          MOV      r0,r5                 ;824
000b84  eaffffe1          B        |L1.2832|
;;;826    
                          ENDP

                  vLedTask PROC
;;;827    static void vLedTask( void *pvParameters )
000b88  e3a05000          MOV      r5,#0
;;;828    {
;;;829        BOOL reTryFlag = FALSE;
;;;830        sysprintf("vLedTask Going...\r\n");
000b8c  e28f0f71          ADR      r0,|L1.3416|
000b90  ebfffffe          BL       sysprintf
;;;831        /* DEBUG LED *///terninalPrintf("vLedTask Going...\r\n");
;;;832        //]Low,pGSOl]pull-upH| high Ol low 8051iJD{
;;;833        setLedBoardWakeup(FALSE);
000b94  e3a00000          MOV      r0,#0
000b98  ebfffffe          BL       setLedBoardWakeup
;;;834        while(ledBoardWakeuped())
000b9c  ea000001          B        |L1.2984|
                  |L1.2976|
;;;835        {
;;;836            vTaskDelay(10/portTICK_RATE_MS);
000ba0  e3a00001          MOV      r0,#1
000ba4  ebfffffe          BL       vTaskDelay
                  |L1.2984|
000ba8  ebfffffe          BL       ledBoardWakeuped
000bac  e3500000          CMP      r0,#0                 ;834
000bb0  1afffffa          BNE      |L1.2976|
;;;837        }
;;;838        int i=0;
000bb4  e3a04000          MOV      r4,#0
;;;839        while(i<200)
000bb8  ea000007          B        |L1.3036|
                  |L1.3004|
;;;840        {
;;;841            vTaskDelay(10/portTICK_RATE_MS);
000bbc  e3a00001          MOV      r0,#1
000bc0  ebfffffe          BL       vTaskDelay
;;;842            if(!ledBoardWakeuped())
000bc4  ebfffffe          BL       ledBoardWakeuped
000bc8  e3500000          CMP      r0,#0
000bcc  1a000001          BNE      |L1.3032|
;;;843            {
;;;844                i++;
000bd0  e2844001          ADD      r4,r4,#1
000bd4  ea000000          B        |L1.3036|
                  |L1.3032|
;;;845            }
;;;846            else
;;;847            {
;;;848                i=0;
000bd8  e3a04000          MOV      r4,#0
                  |L1.3036|
000bdc  e35400c8          CMP      r4,#0xc8              ;839
000be0  bafffff5          BLT      |L1.3004|
;;;849            }
;;;850        }
;;;851        if(sendHeartbeat(LED_HEARTBEAT_SECONDS/60, LED_HEARTBEAT_SECONDS%60)== FALSE)
000be4  e3a01039          MOV      r1,#0x39
000be8  e3a0001b          MOV      r0,#0x1b
000bec  ebfffffe          BL       sendHeartbeat
000bf0  e3500000          CMP      r0,#0
000bf4  1a000004          BNE      |L1.3084|
;;;852        {
;;;853            terninalPrintf("Task initial sendHeartbeat error\r\n");
000bf8  e28f0f5b          ADR      r0,|L1.3436|
000bfc  ebfffffe          BL       terninalPrintf
;;;854            heartSendFlag = TRUE;
000c00  e3a00001          MOV      r0,#1
000c04  e59f1184          LDR      r1,|L1.3472|
000c08  e5c10000          STRB     r0,[r1,#0]  ; heartSendFlag
                  |L1.3084|
;;;855        }
;;;856        //vTaskDelay(1000/portTICK_RATE_MS);
;;;857        
;;;858        if(setLedPara() == FALSE)
000c0c  ebfffffe          BL       setLedPara
000c10  e3500000          CMP      r0,#0
000c14  1a000004          BNE      |L1.3116|
;;;859        {
;;;860            terninalPrintf("LED Task initial (setLedPara) error\r\n");
000c18  e28f0f5d          ADR      r0,|L1.3476|
000c1c  ebfffffe          BL       terninalPrintf
;;;861            paraSetFlag=TRUE;
000c20  e3a00001          MOV      r0,#1
000c24  e59f1190          LDR      r1,|L1.3516|
000c28  e5c10000          STRB     r0,[r1,#0]  ; paraSetFlag
                  |L1.3116|
;;;862        }
;;;863        
;;;864        if(setColor(bayColorTmp, statusColorTmp) == FALSE)
000c2c  e59f018c          LDR      r0,|L1.3520|
000c30  e5d01000          LDRB     r1,[r0,#0]  ; statusColorTmp
000c34  e59f0188          LDR      r0,|L1.3524|
000c38  ebfffffe          BL       setColor
000c3c  e3500000          CMP      r0,#0
000c40  1a000004          BNE      |L1.3160|
;;;865        {
;;;866            terninalPrintf("LED Task (setColor) error\r\n");
000c44  e28f0f5f          ADR      r0,|L1.3528|
000c48  ebfffffe          BL       terninalPrintf
;;;867            ledSetFlag=TRUE;
000c4c  e3a00001          MOV      r0,#1
000c50  e59f118c          LDR      r1,|L1.3556|
000c54  e5c10000          STRB     r0,[r1,#0]  ; ledSetFlag
                  |L1.3160|
;;;868        }
;;;869        
;;;870        if(memsCollisionSet() == FALSE)
000c58  ebfffffe          BL       memsCollisionSet
000c5c  e3500000          CMP      r0,#0
000c60  1a000004          BNE      |L1.3192|
;;;871        {
;;;872            terninalPrintf("LED Task (setCollision) error\r\n");
000c64  e28f0f5f          ADR      r0,|L1.3560|
000c68  ebfffffe          BL       terninalPrintf
;;;873            collisionSetFlag=TRUE;
000c6c  e3a00001          MOV      r0,#1
000c70  e59f1190          LDR      r1,|L1.3592|
000c74  e5c10000          STRB     r0,[r1,#0]  ; collisionSetFlag
                  |L1.3192|
;;;874        }
;;;875        if(memsCollisionClean() == FALSE)
000c78  ebfffffe          BL       memsCollisionClean
000c7c  e3500000          CMP      r0,#0
000c80  1a000004          BNE      |L1.3224|
;;;876        {
;;;877            terninalPrintf("LED Task(cleanCollision)error\r\n");
000c84  e28f0f60          ADD      r0,pc,#0x60, 30 ; #0x180
000c88  ebfffffe          BL       terninalPrintf
;;;878            collisionCleanFlag=TRUE;
000c8c  e3a00001          MOV      r0,#1
000c90  e59f1194          LDR      r1,|L1.3628|
000c94  e5c10000          STRB     r0,[r1,#0]  ; collisionCleanFlag
                  |L1.3224|
;;;879        }
;;;880        
;;;881        for(;;)
000c98  e1a00000          MOV      r0,r0
                  |L1.3228|
;;;882        {
;;;883            BaseType_t reval = xSemaphoreTake(xSemaphore, threadWaitTime);
000c9c  e3a03000          MOV      r3,#0
000ca0  e59f0188          LDR      r0,|L1.3632|
000ca4  e1a01003          MOV      r1,r3
000ca8  e5902000          LDR      r2,[r0,#0]  ; threadWaitTime
000cac  e59f0180          LDR      r0,|L1.3636|
000cb0  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
000cb4  ebfffffe          BL       xQueueGenericReceive
000cb8  e1a06000          MOV      r6,r0
;;;884            reTryFlag = FALSE; 
000cbc  e3a05000          MOV      r5,#0
;;;885            if(reval == pdTRUE)
;;;886            {
;;;887                
;;;888            }
;;;889            else
;;;890            {//heartbeat timeout
;;;891                //heartSendFlag = TRUE;
;;;892            }
;;;893            if(ledSetFlag)
000cc0  e59f011c          LDR      r0,|L1.3556|
000cc4  e5d00000          LDRB     r0,[r0,#0]  ; ledSetFlag
000cc8  e3500000          CMP      r0,#0
000ccc  0a00005c          BEQ      |L1.3652|
;;;894            {
;;;895                if(setColor(bayColorTmp, statusColorTmp) == FALSE)
000cd0  e59f00e8          LDR      r0,|L1.3520|
000cd4  e5d01000          LDRB     r1,[r0,#0]  ; statusColorTmp
000cd8  e59f00e4          LDR      r0,|L1.3524|
000cdc  ebfffffe          BL       setColor
000ce0  e3500000          CMP      r0,#0
000ce4  1a000053          BNE      |L1.3640|
;;;896                    reTryFlag = TRUE;
000ce8  e3a05001          MOV      r5,#1
000cec  ea000054          B        |L1.3652|
                  |L1.3312|
000cf0  4c656453          DCB      "LedSendFactoryTest: %d[0x%02x, 0x%02x]...\r\n",0
000cf4  656e6446
000cf8  6163746f
000cfc  72795465
000d00  73743a20
000d04  25645b30
000d08  78253032
000d0c  782c2030
000d10  78253032
000d14  785d2e2e
000d18  2e0d0a00
                  |L1.3356|
000d1c  4c656453          DCB      "LedSendFactoryTest: OK...\r\n",0
000d20  656e6446
000d24  6163746f
000d28  72795465
000d2c  73743a20
000d30  4f4b2e2e
000d34  2e0d0a00
                  |L1.3384|
000d38  4c656453          DCB      "LedSendFactoryTest: ERROR...\r\n",0
000d3c  656e6446
000d40  6163746f
000d44  72795465
000d48  73743a20
000d4c  4552524f
000d50  522e2e2e
000d54  0d0a00  
000d57  00                DCB      0
                  |L1.3416|
000d58  764c6564          DCB      "vLedTask Going...\r\n",0
000d5c  5461736b
000d60  20476f69
000d64  6e672e2e
000d68  2e0d0a00
                  |L1.3436|
000d6c  5461736b          DCB      "Task initial sendHeartbeat error\r\n",0
000d70  20696e69
000d74  7469616c
000d78  2073656e
000d7c  64486561
000d80  72746265
000d84  61742065
000d88  72726f72
000d8c  0d0a00  
000d8f  00                DCB      0
                  |L1.3472|
                          DCD      heartSendFlag
                  |L1.3476|
000d94  4c454420          DCB      "LED Task initial (setLedPara) error\r\n",0
000d98  5461736b
000d9c  20696e69
000da0  7469616c
000da4  20287365
000da8  744c6564
000dac  50617261
000db0  29206572
000db4  726f720d
000db8  0a00    
000dba  00                DCB      0
000dbb  00                DCB      0
                  |L1.3516|
                          DCD      paraSetFlag
                  |L1.3520|
                          DCD      statusColorTmp
                  |L1.3524|
                          DCD      bayColorTmp
                  |L1.3528|
000dc8  4c454420          DCB      "LED Task (setColor) error\r\n",0
000dcc  5461736b
000dd0  20287365
000dd4  74436f6c
000dd8  6f722920
000ddc  6572726f
000de0  720d0a00
                  |L1.3556|
                          DCD      ledSetFlag
                  |L1.3560|
000de8  4c454420          DCB      "LED Task (setCollision) error\r\n",0
000dec  5461736b
000df0  20287365
000df4  74436f6c
000df8  6c697369
000dfc  6f6e2920
000e00  6572726f
000e04  720d0a00
                  |L1.3592|
                          DCD      collisionSetFlag
000e0c  4c454420          DCB      "LED Task(cleanCollision)error\r\n",0
000e10  5461736b
000e14  28636c65
000e18  616e436f
000e1c  6c6c6973
000e20  696f6e29
000e24  6572726f
000e28  720d0a00
                  |L1.3628|
                          DCD      collisionCleanFlag
                  |L1.3632|
                          DCD      threadWaitTime
                  |L1.3636|
                          DCD      xSemaphore
                  |L1.3640|
;;;897                else
;;;898                    ledSetFlag = FALSE;
000e38  e3a00000          MOV      r0,#0
000e3c  e51f1060          LDR      r1,|L1.3556|
000e40  e5c10000          STRB     r0,[r1,#0]  ; ledSetFlag
                  |L1.3652|
;;;899            }
;;;900            if(paraSetFlag)
000e44  e51f0090          LDR      r0,|L1.3516|
000e48  e5d00000          LDRB     r0,[r0,#0]  ; paraSetFlag
000e4c  e3500000          CMP      r0,#0
000e50  0a000007          BEQ      |L1.3700|
;;;901            {
;;;902                if(setLedPara() == FALSE)
000e54  ebfffffe          BL       setLedPara
000e58  e3500000          CMP      r0,#0
000e5c  1a000001          BNE      |L1.3688|
;;;903                    reTryFlag = TRUE;
000e60  e3a05001          MOV      r5,#1
000e64  ea000002          B        |L1.3700|
                  |L1.3688|
;;;904                else
;;;905                    paraSetFlag = FALSE;
000e68  e3a00000          MOV      r0,#0
000e6c  e51f10b8          LDR      r1,|L1.3516|
000e70  e5c10000          STRB     r0,[r1,#0]  ; paraSetFlag
                  |L1.3700|
;;;906            }
;;;907            if(heartSendFlag)
000e74  e51f00ec          LDR      r0,|L1.3472|
000e78  e5d00000          LDRB     r0,[r0,#0]  ; heartSendFlag
000e7c  e3500000          CMP      r0,#0
000e80  0a000012          BEQ      |L1.3792|
;;;908            {
;;;909                if(sendHeartbeat(LED_HEARTBEAT_SECONDS/60, LED_HEARTBEAT_SECONDS%60)== FALSE) 
000e84  e3a01039          MOV      r1,#0x39
000e88  e3a0001b          MOV      r0,#0x1b
000e8c  ebfffffe          BL       sendHeartbeat
000e90  e3500000          CMP      r0,#0
000e94  1a000004          BNE      |L1.3756|
;;;910                {
;;;911                    //reTryFlag = TRUE;
;;;912                    reTryFlag = FALSE;
000e98  e3a05000          MOV      r5,#0
;;;913                    heartSendFlag = FALSE;
000e9c  e3a00000          MOV      r0,#0
000ea0  e51f1118          LDR      r1,|L1.3472|
000ea4  e5c10000          STRB     r0,[r1,#0]  ; heartSendFlag
000ea8  ea000002          B        |L1.3768|
                  |L1.3756|
;;;914                }
;;;915                else
;;;916                    heartSendFlag = FALSE;
000eac  e3a00000          MOV      r0,#0
000eb0  e51f1128          LDR      r1,|L1.3472|
000eb4  e5c10000          STRB     r0,[r1,#0]  ; heartSendFlag
                  |L1.3768|
;;;917                //terninalPrintf(" t4 \r\n");
;;;918                xSemaphoreGive(xSemaphoreResponse);
000eb8  e3a03000          MOV      r3,#0
000ebc  e1a02003          MOV      r2,r3
000ec0  e1a01003          MOV      r1,r3
000ec4  e59f044c          LDR      r0,|L1.4888|
000ec8  e5900000          LDR      r0,[r0,#0]  ; xSemaphoreResponse
000ecc  ebfffffe          BL       xQueueGenericSend
                  |L1.3792|
;;;919            }
;;;920            if(factoryTestSendFlag)
000ed0  e59f0444          LDR      r0,|L1.4892|
000ed4  e5d00000          LDRB     r0,[r0,#0]  ; factoryTestSendFlag
000ed8  e3500000          CMP      r0,#0
000edc  0a000007          BEQ      |L1.3840|
;;;921            {
;;;922                if(sendFactoryTest()== FALSE)
000ee0  ebfffffe          BL       sendFactoryTest
000ee4  e3500000          CMP      r0,#0
000ee8  1a000001          BNE      |L1.3828|
;;;923                    reTryFlag = TRUE;
000eec  e3a05001          MOV      r5,#1
000ef0  ea000002          B        |L1.3840|
                  |L1.3828|
;;;924                else
;;;925                    factoryTestSendFlag = FALSE;
000ef4  e3a00000          MOV      r0,#0
000ef8  e59f141c          LDR      r1,|L1.4892|
000efc  e5c10000          STRB     r0,[r1,#0]  ; factoryTestSendFlag
                  |L1.3840|
;;;926            }
;;;927            if(calibrationSetFlag)
000f00  e59f0418          LDR      r0,|L1.4896|
000f04  e5d00000          LDRB     r0,[r0,#0]  ; calibrationSetFlag
000f08  e3500000          CMP      r0,#0
000f0c  0a00000d          BEQ      |L1.3912|
;;;928            {
;;;929                if(memsCalibrationSet()== FALSE)
000f10  ebfffffe          BL       memsCalibrationSet
000f14  e3500000          CMP      r0,#0
000f18  1a000001          BNE      |L1.3876|
;;;930                    reTryFlag = TRUE;
000f1c  e3a05001          MOV      r5,#1
000f20  ea000002          B        |L1.3888|
                  |L1.3876|
;;;931                else
;;;932                    calibrationSetFlag = FALSE;
000f24  e3a00000          MOV      r0,#0
000f28  e59f13f0          LDR      r1,|L1.4896|
000f2c  e5c10000          STRB     r0,[r1,#0]  ; calibrationSetFlag
                  |L1.3888|
;;;933                xSemaphoreGive(xSemaphoreResponse);
000f30  e3a03000          MOV      r3,#0
000f34  e1a02003          MOV      r2,r3
000f38  e1a01003          MOV      r1,r3
000f3c  e59f03d4          LDR      r0,|L1.4888|
000f40  e5900000          LDR      r0,[r0,#0]  ; xSemaphoreResponse
000f44  ebfffffe          BL       xQueueGenericSend
                  |L1.3912|
;;;934            }
;;;935            if(collisionSetFlag)
000f48  e51f0148          LDR      r0,|L1.3592|
000f4c  e5d00000          LDRB     r0,[r0,#0]  ; collisionSetFlag
000f50  e3500000          CMP      r0,#0
000f54  0a000007          BEQ      |L1.3960|
;;;936            {
;;;937                if(memsCollisionSet()== FALSE)
000f58  ebfffffe          BL       memsCollisionSet
000f5c  e3500000          CMP      r0,#0
000f60  1a000001          BNE      |L1.3948|
;;;938                    reTryFlag = TRUE;
000f64  e3a05001          MOV      r5,#1
000f68  ea000002          B        |L1.3960|
                  |L1.3948|
;;;939                else
;;;940                    collisionSetFlag = FALSE;
000f6c  e3a00000          MOV      r0,#0
000f70  e51f1170          LDR      r1,|L1.3592|
000f74  e5c10000          STRB     r0,[r1,#0]  ; collisionSetFlag
                  |L1.3960|
;;;941            }
;;;942            if(collisionCleanFlag)
000f78  e51f0154          LDR      r0,|L1.3628|
000f7c  e5d00000          LDRB     r0,[r0,#0]  ; collisionCleanFlag
000f80  e3500000          CMP      r0,#0
000f84  0a000007          BEQ      |L1.4008|
;;;943            {
;;;944                if(memsCollisionClean()== FALSE)
000f88  ebfffffe          BL       memsCollisionClean
000f8c  e3500000          CMP      r0,#0
000f90  1a000001          BNE      |L1.3996|
;;;945                    reTryFlag = TRUE;
000f94  e3a05001          MOV      r5,#1
000f98  ea000002          B        |L1.4008|
                  |L1.3996|
;;;946                else
;;;947                    collisionCleanFlag = FALSE;
000f9c  e3a00000          MOV      r0,#0
000fa0  e51f117c          LDR      r1,|L1.3628|
000fa4  e5c10000          STRB     r0,[r1,#0]  ; collisionCleanFlag
                  |L1.4008|
;;;948            }
;;;949            if(reTryFlag)
000fa8  e3550000          CMP      r5,#0
000fac  0a000003          BEQ      |L1.4032|
;;;950            {
;;;951                threadWaitTime = 2000/portTICK_RATE_MS;
000fb0  e3a000c8          MOV      r0,#0xc8
000fb4  e51f118c          LDR      r1,|L1.3632|
000fb8  e5810000          STR      r0,[r1,#0]  ; threadWaitTime
000fbc  ea000002          B        |L1.4044|
                  |L1.4032|
;;;952                //threadWaitTime = 4000/portTICK_RATE_MS;
;;;953            }
;;;954            else
;;;955            {
;;;956                threadWaitTime = portMAX_DELAY;
000fc0  e3e00000          MVN      r0,#0
000fc4  e51f119c          LDR      r1,|L1.3632|
000fc8  e5810000          STR      r0,[r1,#0]  ; threadWaitTime
                  |L1.4044|
;;;957            }
;;;958        }
000fcc  eaffff32          B        |L1.3228|
;;;959    }
;;;960    static BOOL hwInit(void)
                          ENDP

                  hwInit PROC
000fd0  e92d4010          PUSH     {r4,lr}
;;;961    {
;;;962        //wakeup pin H15
;;;963        outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xFu<<28)) | (0x0u<<28));
000fd4  e3a0020b          MOV      r0,#0xb0000000
000fd8  e59000ac          LDR      r0,[r0,#0xac]
000fdc  e3c0020f          BIC      r0,r0,#0xf0000000
000fe0  e3a0120b          MOV      r1,#0xb0000000
000fe4  e58100ac          STR      r0,[r1,#0xac]
;;;964        GPIO_OpenBit(WAKEUP_PORT, WAKEUP_PIN, DIR_OUTPUT, NO_PULL_UP); 
000fe8  e3a03000          MOV      r3,#0
000fec  e3a02001          MOV      r2,#1
000ff0  e3a01901          MOV      r1,#0x4000
000ff4  e3a00d07          MOV      r0,#0x1c0
000ff8  ebfffffe          BL       GPIO_OpenBit
;;;965        GPIO_SetBit(WAKEUP_PORT, WAKEUP_PIN);
000ffc  e3a01901          MOV      r1,#0x4000
001000  e3a00d07          MOV      r0,#0x1c0
001004  ebfffffe          BL       GPIO_SetBit
;;;966        
;;;967        //sensor pin H14
;;;968        outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xFu<<24)) | (0x0u<<24));
001008  e3a0020b          MOV      r0,#0xb0000000
00100c  e59000ac          LDR      r0,[r0,#0xac]
001010  e3c0040f          BIC      r0,r0,#0xf000000
001014  e3a0120b          MOV      r1,#0xb0000000
001018  e58100ac          STR      r0,[r1,#0xac]
;;;969        GPIO_OpenBit(SENSOR_PORT, SENSOR_PIN, DIR_INPUT, PULL_UP);  
00101c  e3a03001          MOV      r3,#1
001020  e3a02000          MOV      r2,#0
001024  e3a01902          MOV      r1,#0x8000
001028  e3a00d07          MOV      r0,#0x1c0
00102c  ebfffffe          BL       GPIO_OpenBit
;;;970        
;;;971        //Reset pin F9
;;;972        outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<4)) | (0x0<<4));
001030  e3a0020b          MOV      r0,#0xb0000000
001034  e590009c          LDR      r0,[r0,#0x9c]
001038  e3c000f0          BIC      r0,r0,#0xf0
00103c  e3a0120b          MOV      r1,#0xb0000000
001040  e581009c          STR      r0,[r1,#0x9c]
;;;973        GPIO_OpenBit(RESET_PORT, RESET_PIN, DIR_OUTPUT, NO_PULL_UP);
001044  e3a03000          MOV      r3,#0
001048  e3a02001          MOV      r2,#1
00104c  e3a01c02          MOV      r1,#0x200
001050  e3a00d05          MOV      r0,#0x140
001054  ebfffffe          BL       GPIO_OpenBit
;;;974        GPIO_SetBit(RESET_PORT, RESET_PIN);
001058  e3a01c02          MOV      r1,#0x200
00105c  e3a00d05          MOV      r0,#0x140
001060  ebfffffe          BL       GPIO_SetBit
;;;975        return TRUE;
001064  e3a00001          MOV      r0,#1
;;;976    }
001068  e8bd8010          POP      {r4,pc}
;;;977    
                          ENDP

                  swInit PROC
;;;978    static BOOL swInit(void)
00106c  e92d401c          PUSH     {r2-r4,lr}
;;;979    {
;;;980        xSemaphore = xSemaphoreCreateBinary(); 
001070  e3a02003          MOV      r2,#3
001074  e3a01000          MOV      r1,#0
001078  e3a00001          MOV      r0,#1
00107c  ebfffffe          BL       xQueueGenericCreate
001080  e51f1254          LDR      r1,|L1.3636|
001084  e5810000          STR      r0,[r1,#0]  ; xSemaphore
;;;981        xSemaphoreResponse = xSemaphoreCreateBinary(); 
001088  e3a02003          MOV      r2,#3
00108c  e3a01000          MOV      r1,#0
001090  e3a00001          MOV      r0,#1
001094  ebfffffe          BL       xQueueGenericCreate
001098  e59f1278          LDR      r1,|L1.4888|
00109c  e5810000          STR      r0,[r1,#0]  ; xSemaphoreResponse
;;;982        if(xSemaphore == NULL) 
0010a0  e51f0274          LDR      r0,|L1.3636|
0010a4  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
0010a8  e3500000          CMP      r0,#0
0010ac  1a000001          BNE      |L1.4280|
;;;983            return FALSE;
0010b0  e3a00000          MOV      r0,#0
                  |L1.4276|
;;;984        //#warning just temp
;;;985        xTaskCreate( vLedTask, "vLedTask", 1024, NULL, LED_THREAD_PROI, NULL );
;;;986        return TRUE;
;;;987    }
0010b4  e8bd801c          POP      {r2-r4,pc}
                  |L1.4280|
0010b8  e3a00000          MOV      r0,#0                 ;985
0010bc  e3a01001          MOV      r1,#1                 ;985
0010c0  e58d0004          STR      r0,[sp,#4]            ;985
0010c4  e1a03000          MOV      r3,r0                 ;985
0010c8  e3a02b01          MOV      r2,#0x400             ;985
0010cc  e58d1000          STR      r1,[sp,#0]            ;985
0010d0  e28f1f93          ADR      r1,|L1.4900|
0010d4  e59f0254          LDR      r0,|L1.4912|
0010d8  ebfffffe          BL       xTaskCreate
0010dc  e3a00001          MOV      r0,#1                 ;986
0010e0  eafffff3          B        |L1.4276|
;;;988    
                          ENDP

                  ClrLedInitFlag PROC
;;;993    
;;;994    BOOL ClrLedInitFlag(void)
0010e4  e3a00000          MOV      r0,#0
;;;995    {
;;;996        initFlag = FALSE;
0010e8  e59f1244          LDR      r1,|L1.4916|
0010ec  e5c10000          STRB     r0,[r1,#0]  ; initFlag
;;;997        return TRUE;
0010f0  e3a00001          MOV      r0,#1
;;;998    }
0010f4  e12fff1e          BX       lr
;;;999    
                          ENDP

                  LedDrvInit PROC
;;;1001   
;;;1002   BOOL LedDrvInit(BOOL testMode)
0010f8  e92d4010          PUSH     {r4,lr}
;;;1003   {
0010fc  e1a04000          MOV      r4,r0
;;;1004       if(testMode == SPECIAL)
001100  e3540002          CMP      r4,#2
001104  1a000009          BNE      |L1.4400|
;;;1005       {
;;;1006           sendHeartbeat(LED_HEARTBEAT_SECONDS/60, LED_HEARTBEAT_SECONDS%60);
001108  e3a01039          MOV      r1,#0x39
00110c  e3a0001b          MOV      r0,#0x1b
001110  ebfffffe          BL       sendHeartbeat
;;;1007           setLedPara();
001114  ebfffffe          BL       setLedPara
;;;1008           setColor(bayColorTmp, statusColorTmp);
001118  e51f0360          LDR      r0,|L1.3520|
00111c  e5d01000          LDRB     r1,[r0,#0]  ; statusColorTmp
001120  e51f0364          LDR      r0,|L1.3524|
001124  ebfffffe          BL       setColor
;;;1009           memsCollisionSet();
001128  ebfffffe          BL       memsCollisionSet
;;;1010           memsCollisionClean();
00112c  ebfffffe          BL       memsCollisionClean
                  |L1.4400|
;;;1011       }
;;;1012       if(initFlag)
001130  e59f01fc          LDR      r0,|L1.4916|
001134  e5d00000          LDRB     r0,[r0,#0]  ; initFlag
001138  e3500000          CMP      r0,#0
00113c  0a000001          BEQ      |L1.4424|
;;;1013       {
;;;1014           return TRUE;
001140  e3a00001          MOV      r0,#1
                  |L1.4420|
;;;1015       }
;;;1016       //terninalPrintf("LedDrvInit!!\n");
;;;1017       sysprintf("LedDrvInit!!\n");
;;;1018       pUartInterface = UartGetInterface(LED_DRV_UART);
;;;1019       if(pUartInterface == NULL)
;;;1020       {
;;;1021           sysprintf("LedDrvInit ERROR (pUartInterface == NULL)!!\n");
;;;1022           return FALSE;
;;;1023       }
;;;1024       if(pUartInterface->initFunc(9600) == FALSE)
;;;1025       {
;;;1026           sysprintf("LedDrvInit ERROR (pUartInterface->initFunc false)!!\n");
;;;1027           return FALSE;
;;;1028       }    
;;;1029       pUartInterface->setPowerFunc(TRUE);
;;;1030       if(hwInit() == FALSE)
;;;1031       {
;;;1032           sysprintf("LedDrvInit ERROR (hwInit false)!!\n");
;;;1033           return FALSE;
;;;1034       }
;;;1035       /*  reset   slave   */
;;;1036       GPIO_SetBit(RESET_PORT, RESET_PIN);
;;;1037       vTaskDelay(500/portTICK_RATE_MS);
;;;1038       //vTaskDelay(1000/portTICK_RATE_MS);
;;;1039       GPIO_ClrBit(RESET_PORT, RESET_PIN);
;;;1040       vTaskDelay(500/portTICK_RATE_MS);
;;;1041       //vTaskDelay(1000/portTICK_RATE_MS);
;;;1042       GPIO_SetBit(RESET_PORT, RESET_PIN);
;;;1043       
;;;1044       
;;;1045       if(firstinitFlag)
;;;1046       {
;;;1047           if(swInit() == FALSE)
;;;1048           {
;;;1049               sysprintf("LedDrvInit ERROR (swInit false)!!\n");
;;;1050               return FALSE;
;;;1051           }
;;;1052           firstinitFlag = FALSE;
;;;1053       }
;;;1054       //RingFifoPtr = &RingFifo;
;;;1055       sysprintf("LedDrvInit OK!!\n");
;;;1056       //terninalPrintf("LedDrvInit OK!!\r\n");
;;;1057       initFlag = TRUE;
;;;1058       return TRUE;
;;;1059   }
001144  e8bd8010          POP      {r4,pc}
                  |L1.4424|
001148  e28f0f7a          ADR      r0,|L1.4920|
00114c  ebfffffe          BL       sysprintf
001150  e3a00005          MOV      r0,#5                 ;1018
001154  ebfffffe          BL       UartGetInterface
001158  e51f1d88          LDR      r1,|L1.984|
00115c  e5810000          STR      r0,[r1,#0]            ;1018  ; pUartInterface
001160  e2810000          ADD      r0,r1,#0              ;1019
001164  e5900000          LDR      r0,[r0,#0]            ;1019  ; pUartInterface
001168  e3500000          CMP      r0,#0                 ;1019
00116c  1a000003          BNE      |L1.4480|
001170  e28f0e1d          ADR      r0,|L1.4936|
001174  ebfffffe          BL       sysprintf
001178  e3a00000          MOV      r0,#0                 ;1022
00117c  eafffff0          B        |L1.4420|
                  |L1.4480|
001180  e51f0db0          LDR      r0,|L1.984|
001184  e5900000          LDR      r0,[r0,#0]            ;1024  ; pUartInterface
001188  e5901000          LDR      r1,[r0,#0]            ;1024
00118c  e3a00d96          MOV      r0,#0x2580            ;1024
001190  e12fff31          BLX      r1                    ;1024
001194  e3500000          CMP      r0,#0                 ;1024
001198  1a000003          BNE      |L1.4524|
00119c  e28f0f75          ADR      r0,|L1.4984|
0011a0  ebfffffe          BL       sysprintf
0011a4  e3a00000          MOV      r0,#0                 ;1027
0011a8  eaffffe5          B        |L1.4420|
                  |L1.4524|
0011ac  e51f0ddc          LDR      r0,|L1.984|
0011b0  e5900000          LDR      r0,[r0,#0]            ;1029  ; pUartInterface
0011b4  e5901010          LDR      r1,[r0,#0x10]         ;1029
0011b8  e3a00001          MOV      r0,#1                 ;1029
0011bc  e12fff31          BLX      r1                    ;1029
0011c0  ebfffffe          BL       hwInit
0011c4  e3500000          CMP      r0,#0                 ;1030
0011c8  1a000003          BNE      |L1.4572|
0011cc  e28f0f77          ADR      r0,|L1.5040|
0011d0  ebfffffe          BL       sysprintf
0011d4  e3a00000          MOV      r0,#0                 ;1033
0011d8  eaffffd9          B        |L1.4420|
                  |L1.4572|
0011dc  e3a01c02          MOV      r1,#0x200             ;1036
0011e0  e3a00d05          MOV      r0,#0x140             ;1036
0011e4  ebfffffe          BL       GPIO_SetBit
0011e8  e3a00032          MOV      r0,#0x32              ;1037
0011ec  ebfffffe          BL       vTaskDelay
0011f0  e3a01c02          MOV      r1,#0x200             ;1039
0011f4  e3a00d05          MOV      r0,#0x140             ;1039
0011f8  ebfffffe          BL       GPIO_ClrBit
0011fc  e3a00032          MOV      r0,#0x32              ;1040
001200  ebfffffe          BL       vTaskDelay
001204  e3a01c02          MOV      r1,#0x200             ;1042
001208  e3a00d05          MOV      r0,#0x140             ;1042
00120c  ebfffffe          BL       GPIO_SetBit
001210  e59f01bc          LDR      r0,|L1.5076|
001214  e5d00000          LDRB     r0,[r0,#0]            ;1045  ; firstinitFlag
001218  e3500000          CMP      r0,#0                 ;1045
00121c  0a000009          BEQ      |L1.4680|
001220  ebfffffe          BL       swInit
001224  e3500000          CMP      r0,#0                 ;1047
001228  1a000003          BNE      |L1.4668|
00122c  e28f0f69          ADR      r0,|L1.5080|
001230  ebfffffe          BL       sysprintf
001234  e3a00000          MOV      r0,#0                 ;1050
001238  eaffffc1          B        |L1.4420|
                  |L1.4668|
00123c  e3a00000          MOV      r0,#0                 ;1052
001240  e59f118c          LDR      r1,|L1.5076|
001244  e5c10000          STRB     r0,[r1,#0]            ;1052  ; firstinitFlag
                  |L1.4680|
001248  e28f0f6b          ADR      r0,|L1.5116|
00124c  ebfffffe          BL       sysprintf
001250  e3a00001          MOV      r0,#1                 ;1057
001254  e59f10d8          LDR      r1,|L1.4916|
001258  e5c10000          STRB     r0,[r1,#0]            ;1057  ; initFlag
00125c  e1a00000          MOV      r0,r0                 ;1058
001260  eaffffb7          B        |L1.4420|
;;;1060   
                          ENDP

                  LedSetStatus PROC
;;;1061   BOOL LedSetStatus(void)
001264  e92d4010          PUSH     {r4,lr}
;;;1062   {
;;;1063       return setLedPara();
001268  ebfffffe          BL       setLedPara
;;;1064   }
00126c  e8bd8010          POP      {r4,pc}
;;;1065   
                          ENDP

                  LedSetColor PROC
;;;1066   BOOL LedSetColor(uint8_t* bayColor, uint8_t statusColor, BOOL checkFlag)
001270  e92d41f0          PUSH     {r4-r8,lr}
;;;1067   {
001274  e1a05000          MOV      r5,r0
001278  e1a04001          MOV      r4,r1
00127c  e1a06002          MOV      r6,r2
;;;1068       BOOL reVal = FALSE;
001280  e3a07000          MOV      r7,#0
;;;1069       if(checkFlag)
001284  e3560000          CMP      r6,#0
001288  0a000015          BEQ      |L1.4836|
;;;1070       {
;;;1071           if((bayColor != NULL) && (memcmp(bayColorTmp, bayColor, sizeof(bayColorTmp)) != 0))
00128c  e3550000          CMP      r5,#0
001290  0a00000a          BEQ      |L1.4800|
001294  e3a02008          MOV      r2,#8
001298  e1a01005          MOV      r1,r5
00129c  e51f04e0          LDR      r0,|L1.3524|
0012a0  ebfffffe          BL       memcmp
0012a4  e3500000          CMP      r0,#0
0012a8  0a000004          BEQ      |L1.4800|
;;;1072           {
;;;1073               memcpy(bayColorTmp, bayColor, sizeof(bayColorTmp));
0012ac  e3a02008          MOV      r2,#8
0012b0  e1a01005          MOV      r1,r5
0012b4  e51f04f8          LDR      r0,|L1.3524|
0012b8  ebfffffe          BL       __aeabi_memcpy
;;;1074               reVal = TRUE;
0012bc  e3a07001          MOV      r7,#1
                  |L1.4800|
;;;1075           }
;;;1076           if( (statusColor != LIGHT_COLOR_IGNORE) && (statusColorTmp != statusColor))
0012c0  e35400ff          CMP      r4,#0xff
0012c4  0a000006          BEQ      |L1.4836|
0012c8  e51f0510          LDR      r0,|L1.3520|
0012cc  e5d00000          LDRB     r0,[r0,#0]  ; statusColorTmp
0012d0  e1500004          CMP      r0,r4
0012d4  0a000002          BEQ      |L1.4836|
;;;1077           {
;;;1078               statusColorTmp = statusColor;
0012d8  e51f0520          LDR      r0,|L1.3520|
0012dc  e5c04000          STRB     r4,[r0,#0]  ; statusColorTmp
;;;1079               reVal = TRUE;
0012e0  e3a07001          MOV      r7,#1
                  |L1.4836|
;;;1080           }
;;;1081       }
;;;1082       if(reVal)
0012e4  e3570000          CMP      r7,#0
0012e8  0a000008          BEQ      |L1.4880|
;;;1083       {
;;;1084           ledSetFlag = TRUE;
0012ec  e3a00001          MOV      r0,#1
0012f0  e51f1514          LDR      r1,|L1.3556|
0012f4  e5c10000          STRB     r0,[r1,#0]  ; ledSetFlag
;;;1085           xSemaphoreGive(xSemaphore);
0012f8  e3a03000          MOV      r3,#0
0012fc  e1a02003          MOV      r2,r3
001300  e1a01003          MOV      r1,r3
001304  e51f04d8          LDR      r0,|L1.3636|
001308  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
00130c  ebfffffe          BL       xQueueGenericSend
                  |L1.4880|
;;;1086       }
;;;1087       return reVal;
001310  e1a00007          MOV      r0,r7
;;;1088   }
001314  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4888|
                          DCD      xSemaphoreResponse
                  |L1.4892|
                          DCD      factoryTestSendFlag
                  |L1.4896|
                          DCD      calibrationSetFlag
                  |L1.4900|
001324  764c6564          DCB      "vLedTask",0
001328  5461736b
00132c  00      
00132d  00                DCB      0
00132e  00                DCB      0
00132f  00                DCB      0
                  |L1.4912|
                          DCD      vLedTask
                  |L1.4916|
                          DCD      initFlag
                  |L1.4920|
001338  4c656444          DCB      "LedDrvInit!!\n",0
00133c  7276496e
001340  69742121
001344  0a00    
001346  00                DCB      0
001347  00                DCB      0
                  |L1.4936|
001348  4c656444          DCB      "LedDrvInit ERROR (pUartInterface == NULL)!!\n",0
00134c  7276496e
001350  69742045
001354  52524f52
001358  20287055
00135c  61727449
001360  6e746572
001364  66616365
001368  203d3d20
00136c  4e554c4c
001370  2921210a
001374  00      
001375  00                DCB      0
001376  00                DCB      0
001377  00                DCB      0
                  |L1.4984|
001378  4c656444          DCB      "LedDrvInit ERROR (pUartInterface->initFunc false)!!\n",0
00137c  7276496e
001380  69742045
001384  52524f52
001388  20287055
00138c  61727449
001390  6e746572
001394  66616365
001398  2d3e696e
00139c  69744675
0013a0  6e632066
0013a4  616c7365
0013a8  2921210a
0013ac  00      
0013ad  00                DCB      0
0013ae  00                DCB      0
0013af  00                DCB      0
                  |L1.5040|
0013b0  4c656444          DCB      "LedDrvInit ERROR (hwInit false)!!\n",0
0013b4  7276496e
0013b8  69742045
0013bc  52524f52
0013c0  20286877
0013c4  496e6974
0013c8  2066616c
0013cc  73652921
0013d0  210a00  
0013d3  00                DCB      0
                  |L1.5076|
                          DCD      firstinitFlag
                  |L1.5080|
0013d8  4c656444          DCB      "LedDrvInit ERROR (swInit false)!!\n",0
0013dc  7276496e
0013e0  69742045
0013e4  52524f52
0013e8  20287377
0013ec  496e6974
0013f0  2066616c
0013f4  73652921
0013f8  210a00  
0013fb  00                DCB      0
                  |L1.5116|
0013fc  4c656444          DCB      "LedDrvInit OK!!\n",0
001400  7276496e
001404  6974204f
001408  4b21210a
00140c  00      
00140d  00                DCB      0
00140e  00                DCB      0
00140f  00                DCB      0
                          ENDP

                  LedSetMode PROC
;;;1089   
;;;1090   void LedSetMode(uint8_t mode)
001410  e12fff1e          BX       lr
;;;1091   {
;;;1092       //ledMode = mode;
;;;1093   }
;;;1094   /*
                          ENDP

                  LedSetAliveStatusLightFlush PROC
;;;1103   
;;;1104   BOOL LedSetAliveStatusLightFlush(uint8_t LED_freq,uint8_t LED_period)
001414  e92d41ff          PUSH     {r0-r8,lr}
;;;1105   {
001418  e1a05000          MOV      r5,r0
00141c  e1a06001          MOV      r6,r1
;;;1106       BOOL reVal = FALSE;
001420  e3a07000          MOV      r7,#0
;;;1107       uint8_t cmd[16];
;;;1108       uint8_t cmdRetuemLen;
;;;1109       if(wakeupLedBoard() == FALSE)
001424  ebfffffe          BL       wakeupLedBoard
001428  e3500000          CMP      r0,#0
00142c  1a000003          BNE      |L1.5184|
;;;1110       {
;;;1111           shutdownLedBoard();
001430  ebfffffe          BL       shutdownLedBoard
;;;1112           return FALSE;
001434  e3a00000          MOV      r0,#0
                  |L1.5176|
001438  e28dd010          ADD      sp,sp,#0x10
;;;1113       }
;;;1114       
;;;1115       cmdRetuemLen = Alive_State_light_Command((char*)cmd, sizeof(cmd), LED_freq, LED_period);
;;;1116       
;;;1117       if(cmdRetuemLen != COMMAND_ERROR)
;;;1118       {
;;;1119           pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;1120           if(readCmdAck())
;;;1121           {
;;;1122               sysprintf("setLedPara (status): OK...\r\n");  
;;;1123               reVal = TRUE;
;;;1124           }
;;;1125           else
;;;1126           {
;;;1127               sysprintf("setLedPara (status): ERROR...\r\n");  
;;;1128               reVal = FALSE;
;;;1129           }
;;;1130       }
;;;1131   
;;;1132       
;;;1133       shutdownLedBoard();
;;;1134       return reVal;
;;;1135   
;;;1136   }
00143c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.5184|
001440  e1a03006          MOV      r3,r6                 ;1115
001444  e1a02005          MOV      r2,r5                 ;1115
001448  e3a01010          MOV      r1,#0x10              ;1115
00144c  e1a0000d          MOV      r0,sp                 ;1115
001450  ebfffffe          BL       Alive_State_light_Command
001454  e1a04000          MOV      r4,r0                 ;1115
001458  e3540000          CMP      r4,#0                 ;1117
00145c  0a00000f          BEQ      |L1.5280|
001460  e59f03cc          LDR      r0,|L1.6196|
001464  e5900000          LDR      r0,[r0,#0]            ;1119  ; pUartInterface
001468  e1a01004          MOV      r1,r4                 ;1119
00146c  e5902004          LDR      r2,[r0,#4]            ;1119
001470  e1a0000d          MOV      r0,sp                 ;1119
001474  e12fff32          BLX      r2                    ;1119
001478  ebfffffe          BL       readCmdAck
00147c  e3500000          CMP      r0,#0                 ;1120
001480  0a000003          BEQ      |L1.5268|
001484  e59f03ac          LDR      r0,|L1.6200|
001488  ebfffffe          BL       sysprintf
00148c  e3a07001          MOV      r7,#1                 ;1123
001490  ea000002          B        |L1.5280|
                  |L1.5268|
001494  e59f03a0          LDR      r0,|L1.6204|
001498  ebfffffe          BL       sysprintf
00149c  e3a07000          MOV      r7,#0                 ;1128
                  |L1.5280|
0014a0  ebfffffe          BL       shutdownLedBoard
0014a4  e1a00007          MOV      r0,r7                 ;1134
0014a8  eaffffe2          B        |L1.5176|
;;;1137   
                          ENDP

                  LedSetStatusLightFlush PROC
;;;1138   BOOL LedSetStatusLightFlush(uint8_t LED_freq,uint8_t LED_period)
0014ac  e92d41ff          PUSH     {r0-r8,lr}
;;;1139   {
0014b0  e1a05000          MOV      r5,r0
0014b4  e1a06001          MOV      r6,r1
;;;1140       BOOL reVal = FALSE;
0014b8  e3a07000          MOV      r7,#0
;;;1141       uint8_t cmd[16];
;;;1142       uint8_t cmdRetuemLen;
;;;1143       if(wakeupLedBoard() == FALSE)
0014bc  ebfffffe          BL       wakeupLedBoard
0014c0  e3500000          CMP      r0,#0
0014c4  1a000003          BNE      |L1.5336|
;;;1144       {
;;;1145           shutdownLedBoard();
0014c8  ebfffffe          BL       shutdownLedBoard
;;;1146           return FALSE;
0014cc  e3a00000          MOV      r0,#0
                  |L1.5328|
0014d0  e28dd010          ADD      sp,sp,#0x10
;;;1147       }
;;;1148       
;;;1149       cmdRetuemLen = State_light_Command((char*)cmd, sizeof(cmd), LED_freq, LED_period);
;;;1150       
;;;1151       if(cmdRetuemLen != COMMAND_ERROR)
;;;1152       {
;;;1153           pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;1154           if(readCmdAck())
;;;1155           {
;;;1156               sysprintf("setLedPara (status): OK...\r\n");  
;;;1157               reVal = TRUE;
;;;1158           }
;;;1159           else
;;;1160           {
;;;1161               sysprintf("setLedPara (status): ERROR...\r\n");  
;;;1162               reVal = FALSE;
;;;1163           }
;;;1164       }
;;;1165   
;;;1166       
;;;1167       shutdownLedBoard();
;;;1168       return reVal;
;;;1169   }
0014d4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.5336|
0014d8  e1a03006          MOV      r3,r6                 ;1149
0014dc  e1a02005          MOV      r2,r5                 ;1149
0014e0  e3a01010          MOV      r1,#0x10              ;1149
0014e4  e1a0000d          MOV      r0,sp                 ;1149
0014e8  ebfffffe          BL       State_light_Command
0014ec  e1a04000          MOV      r4,r0                 ;1149
0014f0  e3540000          CMP      r4,#0                 ;1151
0014f4  0a00000f          BEQ      |L1.5432|
0014f8  e59f0334          LDR      r0,|L1.6196|
0014fc  e5900000          LDR      r0,[r0,#0]            ;1153  ; pUartInterface
001500  e1a01004          MOV      r1,r4                 ;1153
001504  e5902004          LDR      r2,[r0,#4]            ;1153
001508  e1a0000d          MOV      r0,sp                 ;1153
00150c  e12fff32          BLX      r2                    ;1153
001510  ebfffffe          BL       readCmdAck
001514  e3500000          CMP      r0,#0                 ;1154
001518  0a000003          BEQ      |L1.5420|
00151c  e59f0314          LDR      r0,|L1.6200|
001520  ebfffffe          BL       sysprintf
001524  e3a07001          MOV      r7,#1                 ;1157
001528  ea000002          B        |L1.5432|
                  |L1.5420|
00152c  e59f0308          LDR      r0,|L1.6204|
001530  ebfffffe          BL       sysprintf
001534  e3a07000          MOV      r7,#0                 ;1162
                  |L1.5432|
001538  ebfffffe          BL       shutdownLedBoard
00153c  e1a00007          MOV      r0,r7                 ;1168
001540  eaffffe2          B        |L1.5328|
;;;1170   
                          ENDP

                  LedSetBayLightFlush PROC
;;;1171   
;;;1172   BOOL LedSetBayLightFlush(uint8_t LED_freq,uint8_t LED_period)
001544  e92d41ff          PUSH     {r0-r8,lr}
;;;1173   {
001548  e1a05000          MOV      r5,r0
00154c  e1a06001          MOV      r6,r1
;;;1174       BOOL reVal = FALSE;
001550  e3a07000          MOV      r7,#0
;;;1175       uint8_t cmd[16];
;;;1176       uint8_t cmdRetuemLen;
;;;1177       if(wakeupLedBoard() == FALSE)
001554  ebfffffe          BL       wakeupLedBoard
001558  e3500000          CMP      r0,#0
00155c  1a000003          BNE      |L1.5488|
;;;1178       {
;;;1179           shutdownLedBoard();
001560  ebfffffe          BL       shutdownLedBoard
;;;1180           return FALSE;
001564  e3a00000          MOV      r0,#0
                  |L1.5480|
001568  e28dd010          ADD      sp,sp,#0x10
;;;1181       }
;;;1182       
;;;1183       cmdRetuemLen = Bay_light_Command((char*)cmd, sizeof(cmd), LED_freq, LED_period);
;;;1184       if(cmdRetuemLen != COMMAND_ERROR)
;;;1185       {
;;;1186           pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;1187           if(readCmdAck())
;;;1188           {
;;;1189   
;;;1190               reVal = TRUE;
;;;1191           }
;;;1192           else
;;;1193           {
;;;1194               reVal = FALSE;  
;;;1195           }
;;;1196       }
;;;1197       shutdownLedBoard();
;;;1198       return reVal;
;;;1199       
;;;1200       
;;;1201   }
00156c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.5488|
001570  e1a03006          MOV      r3,r6                 ;1183
001574  e1a02005          MOV      r2,r5                 ;1183
001578  e3a01010          MOV      r1,#0x10              ;1183
00157c  e1a0000d          MOV      r0,sp                 ;1183
001580  ebfffffe          BL       Bay_light_Command
001584  e1a04000          MOV      r4,r0                 ;1183
001588  e3540000          CMP      r4,#0                 ;1184
00158c  0a00000b          BEQ      |L1.5568|
001590  e59f029c          LDR      r0,|L1.6196|
001594  e5900000          LDR      r0,[r0,#0]            ;1186  ; pUartInterface
001598  e1a01004          MOV      r1,r4                 ;1186
00159c  e5902004          LDR      r2,[r0,#4]            ;1186
0015a0  e1a0000d          MOV      r0,sp                 ;1186
0015a4  e12fff32          BLX      r2                    ;1186
0015a8  ebfffffe          BL       readCmdAck
0015ac  e3500000          CMP      r0,#0                 ;1187
0015b0  0a000001          BEQ      |L1.5564|
0015b4  e3a07001          MOV      r7,#1                 ;1190
0015b8  ea000000          B        |L1.5568|
                  |L1.5564|
0015bc  e3a07000          MOV      r7,#0                 ;1194
                  |L1.5568|
0015c0  ebfffffe          BL       shutdownLedBoard
0015c4  e1a00007          MOV      r0,r7                 ;1198
0015c8  eaffffe6          B        |L1.5480|
;;;1202   BOOL LedReadShake(uint8_t* ret)
                          ENDP

                  LedReadShake PROC
0015cc  e92d4010          PUSH     {r4,lr}
;;;1203   {
0015d0  e1a04000          MOV      r4,r0
;;;1204       //heartSendFlag = TRUE;
;;;1205       //xSemaphoreGive(xSemaphore);
;;;1206       readCmdStatus();
0015d4  ebfffffe          BL       readCmdStatus
;;;1207       *ret = status;
0015d8  e59f0260          LDR      r0,|L1.6208|
0015dc  e5d00000          LDRB     r0,[r0,#0]  ; status
0015e0  e5c40000          STRB     r0,[r4,#0]
;;;1208       //terninalPrintf("status = %02x\r\n",status);
;;;1209       //terninalPrintf("*ret = %02x\r\n",*ret);
;;;1210       if(shakeflag)
0015e4  e59f0258          LDR      r0,|L1.6212|
0015e8  e5d00000          LDRB     r0,[r0,#0]  ; shakeflag
0015ec  e3500000          CMP      r0,#0
0015f0  0a000005          BEQ      |L1.5644|
;;;1211       {
;;;1212           *ret = *ret | 0x01;
0015f4  e5d40000          LDRB     r0,[r4,#0]
0015f8  e3800001          ORR      r0,r0,#1
0015fc  e5c40000          STRB     r0,[r4,#0]
;;;1213           shakeflag = FALSE;
001600  e3a00000          MOV      r0,#0
001604  e59f1238          LDR      r1,|L1.6212|
001608  e5c10000          STRB     r0,[r1,#0]  ; shakeflag
                  |L1.5644|
;;;1214       }
;;;1215       return TRUE;
00160c  e3a00001          MOV      r0,#1
;;;1216   }
001610  e8bd8010          POP      {r4,pc}
;;;1217   
                          ENDP

                  LedSendHeartbeat PROC
;;;1218   
;;;1219   BOOL LedSendHeartbeat(uint8_t* ret)
001614  e92d4070          PUSH     {r4-r6,lr}
;;;1220   {
001618  e1a04000          MOV      r4,r0
;;;1221       BOOL retVal = FALSE;
00161c  e3a05000          MOV      r5,#0
;;;1222       sysprintf("===> LedSendHeartbeat ...\r\n");
001620  e28f0e22          ADR      r0,|L1.6216|
001624  ebfffffe          BL       sysprintf
;;;1223       heartSendFlag = TRUE;
001628  e3a00001          MOV      r0,#1
00162c  e51f18a4          LDR      r1,|L1.3472|
001630  e5c10000          STRB     r0,[r1,#0]  ; heartSendFlag
;;;1224       fReadStatus = FALSE;
001634  e3a00000          MOV      r0,#0
001638  e59f1224          LDR      r1,|L1.6244|
00163c  e5c10000          STRB     r0,[r1,#0]  ; fReadStatus
;;;1225       xSemaphoreGive(xSemaphore);
001640  e3a03000          MOV      r3,#0
001644  e1a02003          MOV      r2,r3
001648  e1a01003          MOV      r1,r3
00164c  e51f0820          LDR      r0,|L1.3636|
001650  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
001654  ebfffffe          BL       xQueueGenericSend
;;;1226       BaseType_t reval = xSemaphoreTake(xSemaphoreResponse, 5000/portTICK_RATE_MS);
001658  e3a03000          MOV      r3,#0
00165c  e3a02f7d          MOV      r2,#0x1f4
001660  e1a01003          MOV      r1,r3
001664  e51f0354          LDR      r0,|L1.4888|
001668  e5900000          LDR      r0,[r0,#0]  ; xSemaphoreResponse
00166c  ebfffffe          BL       xQueueGenericReceive
001670  e1a06000          MOV      r6,r0
;;;1227       //BaseType_t reval = xSemaphoreTake(xSemaphoreResponse, 10000/portTICK_RATE_MS);
;;;1228       if(reval == pdTRUE)
001674  e3560001          CMP      r6,#1
001678  1a000008          BNE      |L1.5792|
;;;1229       {
;;;1230           //terninalPrintf(" t3 ");
;;;1231           if(fReadStatus)
00167c  e59f01e0          LDR      r0,|L1.6244|
001680  e5d00000          LDRB     r0,[r0,#0]  ; fReadStatus
001684  e3500000          CMP      r0,#0
001688  0a000005          BEQ      |L1.5796|
;;;1232           {
;;;1233               //if(shakeflag)
;;;1234               //    status = status | 0x01;
;;;1235               *ret = status;
00168c  e59f01ac          LDR      r0,|L1.6208|
001690  e5d00000          LDRB     r0,[r0,#0]  ; status
001694  e5c40000          STRB     r0,[r4,#0]
;;;1236               //shakeflag = FALSE;
;;;1237               retVal = TRUE;
001698  e3a05001          MOV      r5,#1
00169c  ea000000          B        |L1.5796|
                  |L1.5792|
;;;1238               //terninalPrintf(" t2 ");
;;;1239           }
;;;1240       }
;;;1241       else
;;;1242       {//timeout
;;;1243           //terninalPrintf("===> LedSendHeartbeat Timeout error\r\n");
;;;1244           retVal = FALSE;  
0016a0  e3a05000          MOV      r5,#0
                  |L1.5796|
;;;1245       }
;;;1246       return retVal;  
0016a4  e1a00005          MOV      r0,r5
;;;1247   }
0016a8  e8bd8070          POP      {r4-r6,pc}
;;;1248   
                          ENDP

                  LedSendFactoryTest PROC
;;;1249   BOOL LedSendFactoryTest()
0016ac  e92d4010          PUSH     {r4,lr}
;;;1250   {
;;;1251       sysprintf("===> LedSendFactoryTest ...\r\n"); 
0016b0  e28f0e1b          ADR      r0,|L1.6248|
0016b4  ebfffffe          BL       sysprintf
;;;1252   //sendFactoryTest();    
;;;1253       factoryTestSendFlag = TRUE;
0016b8  e3a00001          MOV      r0,#1
0016bc  e51f13a8          LDR      r1,|L1.4892|
0016c0  e5c10000          STRB     r0,[r1,#0]  ; factoryTestSendFlag
;;;1254       xSemaphoreGive(xSemaphore);   
0016c4  e3a03000          MOV      r3,#0
0016c8  e1a02003          MOV      r2,r3
0016cc  e1a01003          MOV      r1,r3
0016d0  e51f08a4          LDR      r0,|L1.3636|
0016d4  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
0016d8  ebfffffe          BL       xQueueGenericSend
;;;1255       BaseType_t reval = xSemaphoreTake(xSemaphoreResponse, 1000/portTICK_RATE_MS);
0016dc  e3a03000          MOV      r3,#0
0016e0  e3a02064          MOV      r2,#0x64
0016e4  e1a01003          MOV      r1,r3
0016e8  e51f03d8          LDR      r0,|L1.4888|
0016ec  e5900000          LDR      r0,[r0,#0]  ; xSemaphoreResponse
0016f0  ebfffffe          BL       xQueueGenericReceive
0016f4  e1a04000          MOV      r4,r0
;;;1256       //if(reval == pdTRUE)
;;;1257       //{
;;;1258           return TRUE;
0016f8  e3a00001          MOV      r0,#1
;;;1259       //}
;;;1260       //return FALSE;
;;;1261       
;;;1262   }
0016fc  e8bd8010          POP      {r4,pc}
;;;1263   
                          ENDP

                  LedSetPower PROC
;;;1264   void LedSetPower(BOOL flag)
001700  e92d4010          PUSH     {r4,lr}
;;;1265   {
001704  e1a04000          MOV      r4,r0
;;;1266       if(pUartInterface != 0)
001708  e59f0124          LDR      r0,|L1.6196|
00170c  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
001710  e3500000          CMP      r0,#0
001714  0a000004          BEQ      |L1.5932|
;;;1267       {
;;;1268           pUartInterface->setPowerFunc(flag);
001718  e59f0114          LDR      r0,|L1.6196|
00171c  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
001720  e5901010          LDR      r1,[r0,#0x10]
001724  e1a00004          MOV      r0,r4
001728  e12fff31          BLX      r1
                  |L1.5932|
;;;1269       }
;;;1270   }
00172c  e8bd8010          POP      {r4,pc}
;;;1271   
                          ENDP

                  MemsCalibrationSet PROC
;;;1273   
;;;1274   BOOL MemsCalibrationSet(short* MEMSx,short* MEMSy,short* MEMSz)
001730  e92d41f0          PUSH     {r4-r8,lr}
;;;1275   {
001734  e1a04000          MOV      r4,r0
001738  e1a05001          MOV      r5,r1
00173c  e1a06002          MOV      r6,r2
;;;1276       sysprintf("===> SendCalibration ...\r\n");
001740  e28f0d05          ADR      r0,|L1.6280|
001744  ebfffffe          BL       sysprintf
;;;1277   
;;;1278       QueryMEMSFlag = TRUE;
001748  e3a00001          MOV      r0,#1
00174c  e59f1150          LDR      r1,|L1.6308|
001750  e5c10000          STRB     r0,[r1,#0]  ; QueryMEMSFlag
;;;1279       calibrationSetFlag = TRUE;
001754  e51f143c          LDR      r1,|L1.4896|
001758  e5c10000          STRB     r0,[r1,#0]  ; calibrationSetFlag
;;;1280       xSemaphoreGive(xSemaphore);
00175c  e3a03000          MOV      r3,#0
001760  e1a02003          MOV      r2,r3
001764  e1a01003          MOV      r1,r3
001768  e51f093c          LDR      r0,|L1.3636|
00176c  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
001770  ebfffffe          BL       xQueueGenericSend
;;;1281       BaseType_t reval = xSemaphoreTake(xSemaphoreResponse, 1000/portTICK_RATE_MS);
001774  e3a03000          MOV      r3,#0
001778  e3a02064          MOV      r2,#0x64
00177c  e1a01003          MOV      r1,r3
001780  e51f0470          LDR      r0,|L1.4888|
001784  e5900000          LDR      r0,[r0,#0]  ; xSemaphoreResponse
001788  ebfffffe          BL       xQueueGenericReceive
00178c  e1a07000          MOV      r7,r0
;;;1282       if(reval == pdTRUE)
001790  e3570001          CMP      r7,#1
001794  1a00000a          BNE      |L1.6084|
;;;1283       {
;;;1284           
;;;1285           *MEMSx = xMEMSVal;
001798  e59f0108          LDR      r0,|L1.6312|
00179c  e1d000f0          LDRSH    r0,[r0,#0]  ; xMEMSVal
0017a0  e1c400b0          STRH     r0,[r4,#0]
;;;1286           *MEMSy = yMEMSVal;
0017a4  e59f0100          LDR      r0,|L1.6316|
0017a8  e1d000f0          LDRSH    r0,[r0,#0]  ; yMEMSVal
0017ac  e1c500b0          STRH     r0,[r5,#0]
;;;1287           *MEMSz = zMEMSVal;
0017b0  e59f00f8          LDR      r0,|L1.6320|
0017b4  e1d000f0          LDRSH    r0,[r0,#0]  ; zMEMSVal
0017b8  e1c600b0          STRH     r0,[r6,#0]
;;;1288           
;;;1289           return TRUE;
0017bc  e3a00001          MOV      r0,#1
                  |L1.6080|
;;;1290       }
;;;1291       return FALSE;
;;;1292       
;;;1293       
;;;1294       
;;;1295           
;;;1296       //if((LedSendHeartbeat(NULL) == TRUE))
;;;1297       //{
;;;1298           
;;;1299       //}
;;;1300       
;;;1301       
;;;1302   }
0017c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6084|
0017c4  e3a00000          MOV      r0,#0                 ;1291
0017c8  eafffffc          B        |L1.6080|
;;;1303   
                          ENDP

                  MemsCollisionSet PROC
;;;1304   BOOL MemsCollisionSet(uint8_t bias_degree,uint8_t strength_X,uint8_t strength_Y,uint8_t strength_Z)
0017cc  e92d41f0          PUSH     {r4-r8,lr}
;;;1305   {
0017d0  e1a04000          MOV      r4,r0
0017d4  e1a05001          MOV      r5,r1
0017d8  e1a06002          MOV      r6,r2
0017dc  e1a07003          MOV      r7,r3
;;;1306       local_bias_degree= bias_degree;
0017e0  e51f0d14          LDR      r0,|L1.2772|
0017e4  e5c04000          STRB     r4,[r0,#0]  ; local_bias_degree
;;;1307       local_strength_X = strength_X;
0017e8  e51f0d20          LDR      r0,|L1.2768|
0017ec  e5c05000          STRB     r5,[r0,#0]  ; local_strength_X
;;;1308       local_strength_Y = strength_Y;
0017f0  e51f0d2c          LDR      r0,|L1.2764|
0017f4  e5c06000          STRB     r6,[r0,#0]  ; local_strength_Y
;;;1309       local_strength_Z = strength_Z;
0017f8  e51f0d38          LDR      r0,|L1.2760|
0017fc  e5c07000          STRB     r7,[r0,#0]  ; local_strength_Z
;;;1310       sysprintf("===> SendCollision set...\r\n");
001800  e28f00ac          ADR      r0,|L1.6324|
001804  ebfffffe          BL       sysprintf
;;;1311       collisionSetFlag = TRUE;
001808  e3a00001          MOV      r0,#1
00180c  e51f1a0c          LDR      r1,|L1.3592|
001810  e5c10000          STRB     r0,[r1,#0]  ; collisionSetFlag
;;;1312       xSemaphoreGive(xSemaphore);
001814  e3a03000          MOV      r3,#0
001818  e1a02003          MOV      r2,r3
00181c  e1a01003          MOV      r1,r3
001820  e51f09f4          LDR      r0,|L1.3636|
001824  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
001828  ebfffffe          BL       xQueueGenericSend
;;;1313       return TRUE;
00182c  e3a00001          MOV      r0,#1
;;;1314   }
001830  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6196|
                          DCD      pUartInterface
                  |L1.6200|
                          DCD      ||.text||+0x764
                  |L1.6204|
                          DCD      ||.text||+0x784
                  |L1.6208|
                          DCD      status
                  |L1.6212|
                          DCD      shakeflag
                  |L1.6216|
001848  3d3d3d3e          DCB      "===> LedSendHeartbeat ...\r\n",0
00184c  204c6564
001850  53656e64
001854  48656172
001858  74626561
00185c  74202e2e
001860  2e0d0a00
                  |L1.6244|
                          DCD      fReadStatus
                  |L1.6248|
001868  3d3d3d3e          DCB      "===> LedSendFactoryTest ...\r\n",0
00186c  204c6564
001870  53656e64
001874  46616374
001878  6f727954
00187c  65737420
001880  2e2e2e0d
001884  0a00    
001886  00                DCB      0
001887  00                DCB      0
                  |L1.6280|
001888  3d3d3d3e          DCB      "===> SendCalibration ...\r\n",0
00188c  2053656e
001890  6443616c
001894  69627261
001898  74696f6e
00189c  202e2e2e
0018a0  0d0a00  
0018a3  00                DCB      0
                  |L1.6308|
                          DCD      QueryMEMSFlag
                  |L1.6312|
                          DCD      xMEMSVal
                  |L1.6316|
                          DCD      yMEMSVal
                  |L1.6320|
                          DCD      zMEMSVal
                  |L1.6324|
0018b4  3d3d3d3e          DCB      "===> SendCollision set...\r\n",0
0018b8  2053656e
0018bc  64436f6c
0018c0  6c697369
0018c4  6f6e2073
0018c8  65742e2e
0018cc  2e0d0a00
                          ENDP

                  MemsCollisionClean PROC
;;;1315   
;;;1316   BOOL MemsCollisionClean(void)
0018d0  e92d4010          PUSH     {r4,lr}
;;;1317   {
;;;1318       sysprintf("===> SendCollision clean...\r\n");   
0018d4  e28f0e1e          ADR      r0,|L1.6844|
0018d8  ebfffffe          BL       sysprintf
;;;1319       collisionCleanFlag = TRUE;
0018dc  e3a00001          MOV      r0,#1
0018e0  e51f1abc          LDR      r1,|L1.3628|
0018e4  e5c10000          STRB     r0,[r1,#0]  ; collisionCleanFlag
;;;1320       xSemaphoreGive(xSemaphore);   
0018e8  e3a03000          MOV      r3,#0
0018ec  e1a02003          MOV      r2,r3
0018f0  e1a01003          MOV      r1,r3
0018f4  e51f0ac8          LDR      r0,|L1.3636|
0018f8  e5900000          LDR      r0,[r0,#0]  ; xSemaphore
0018fc  ebfffffe          BL       xQueueGenericSend
;;;1321       return TRUE;
001900  e3a00001          MOV      r0,#1
;;;1322   }
001904  e8bd8010          POP      {r4,pc}
;;;1323   
                          ENDP

                  QueryVersion PROC
;;;1324   
;;;1325   BOOL QueryVersion(uint8_t* VerCode1,uint8_t* VerCode2,uint8_t* VerCode3,uint8_t* YearCode,
001908  e92d4fff          PUSH     {r0-r11,lr}
;;;1326   									uint8_t* MonthCode,uint8_t* DayCode,uint8_t* HourCode,uint8_t* MinuteCode)
;;;1327   {
00190c  e24dd01c          SUB      sp,sp,#0x1c
001910  e1a05000          MOV      r5,r0
001914  e1a06001          MOV      r6,r1
001918  e1a07002          MOV      r7,r2
00191c  e1cd85d0          LDRD     r8,r9,[sp,#0x50]
001920  e1cda5d8          LDRD     r10,r11,[sp,#0x58]
;;;1328   	  BOOL reVal = FALSE;
001924  e3a00000          MOV      r0,#0
001928  e58d0018          STR      r0,[sp,#0x18]
;;;1329       uint8_t cmd[7];
;;;1330       uint8_t cmdRetuemLen;
;;;1331       if(wakeupLedBoard() == FALSE)
00192c  ebfffffe          BL       wakeupLedBoard
001930  e3500000          CMP      r0,#0
001934  1a000002          BNE      |L1.6468|
;;;1332       {
;;;1333           return FALSE;
001938  e3a00000          MOV      r0,#0
                  |L1.6460|
00193c  e28dd02c          ADD      sp,sp,#0x2c
;;;1334       }    
;;;1335     
;;;1336       cmdRetuemLen = VersionQuery((char*)cmd,sizeof(cmd));
;;;1337   
;;;1338       pUartInterface->ioctlFunc(UART_IOC_FLUSH_RX_BUFFER, 0, 0);
;;;1339       
;;;1340       if(cmdRetuemLen != COMMAND_ERROR)
;;;1341       {
;;;1342           pUartInterface->writeFunc(cmd, cmdRetuemLen);
;;;1343           if(readCmdVersion(VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode))
;;;1344           {
;;;1345             
;;;1346               reVal = TRUE;
;;;1347               //flushBuffer();
;;;1348               
;;;1349               //pUartInterface->ioctlFunc(UART_IOC_FLUSH_RX_BUFFER, 0, 0);
;;;1350               
;;;1351           }
;;;1352           else
;;;1353           {
;;;1354               sysprintf("LedVersionQuery: ERROR...\r\n");  
;;;1355           }
;;;1356       }
;;;1357       shutdownLedBoard();
;;;1358       return reVal;
;;;1359   	
;;;1360   }
001940  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.6468|
001944  e3a01007          MOV      r1,#7                 ;1336
001948  e28d0010          ADD      r0,sp,#0x10           ;1336
00194c  ebfffffe          BL       VersionQuery
001950  e1a04000          MOV      r4,r0                 ;1336
001954  e51f0128          LDR      r0,|L1.6196|
001958  e5900000          LDR      r0,[r0,#0]            ;1338  ; pUartInterface
00195c  e3a02000          MOV      r2,#0                 ;1338
001960  e1a01002          MOV      r1,r2                 ;1338
001964  e5903018          LDR      r3,[r0,#0x18]         ;1338
001968  e3a00019          MOV      r0,#0x19              ;1338
00196c  e12fff33          BLX      r3                    ;1338
001970  e3540000          CMP      r4,#0                 ;1340
001974  0a000012          BEQ      |L1.6596|
001978  e51f014c          LDR      r0,|L1.6196|
00197c  e5900000          LDR      r0,[r0,#0]            ;1342  ; pUartInterface
001980  e1a01004          MOV      r1,r4                 ;1342
001984  e5902004          LDR      r2,[r0,#4]            ;1342
001988  e28d0010          ADD      r0,sp,#0x10           ;1342
00198c  e12fff32          BLX      r2                    ;1342
001990  e88d0f00          STM      sp,{r8-r11}           ;1343
001994  e1a02007          MOV      r2,r7                 ;1343
001998  e1a01006          MOV      r1,r6                 ;1343
00199c  e1a00005          MOV      r0,r5                 ;1343
0019a0  e59d3028          LDR      r3,[sp,#0x28]         ;1343
0019a4  ebfffffe          BL       readCmdVersion
0019a8  e3500000          CMP      r0,#0                 ;1343
0019ac  0a000002          BEQ      |L1.6588|
0019b0  e3a00001          MOV      r0,#1                 ;1346
0019b4  e58d0018          STR      r0,[sp,#0x18]         ;1346
0019b8  ea000001          B        |L1.6596|
                  |L1.6588|
0019bc  e28f0f46          ADR      r0,|L1.6876|
0019c0  ebfffffe          BL       sysprintf
                  |L1.6596|
0019c4  ebfffffe          BL       shutdownLedBoard
0019c8  e59d0018          LDR      r0,[sp,#0x18]         ;1358
0019cc  eaffffda          B        |L1.6460|
;;;1361   
                          ENDP

                  QueryMEMSValue PROC
;;;1410   
;;;1411   BOOL QueryMEMSValue(short* MEMSx,short* MEMSy,short* MEMSz)
0019d0  e92d4070          PUSH     {r4-r6,lr}
;;;1412   {
0019d4  e1a04000          MOV      r4,r0
0019d8  e1a05001          MOV      r5,r1
0019dc  e1a06002          MOV      r6,r2
;;;1413       QueryMEMSFlag = TRUE;
0019e0  e3a00001          MOV      r0,#1
0019e4  e51f1148          LDR      r1,|L1.6308|
0019e8  e5c10000          STRB     r0,[r1,#0]  ; QueryMEMSFlag
;;;1414       
;;;1415       if(!ledBuzyflag)
0019ec  e59f0104          LDR      r0,|L1.6904|
0019f0  e5d00000          LDRB     r0,[r0,#0]  ; ledBuzyflag
0019f4  e3500000          CMP      r0,#0
0019f8  1a000014          BNE      |L1.6736|
;;;1416       {
;;;1417           queryMEMSWaitCounter = 0;
0019fc  e3a00000          MOV      r0,#0
001a00  e59f10f4          LDR      r1,|L1.6908|
001a04  e5810000          STR      r0,[r1,#0]  ; queryMEMSWaitCounter
;;;1418           ledBuzyflag = TRUE;
001a08  e3a00001          MOV      r0,#1
001a0c  e59f10e4          LDR      r1,|L1.6904|
001a10  e5c10000          STRB     r0,[r1,#0]  ; ledBuzyflag
;;;1419           if((LedSendHeartbeat(NULL) == TRUE))
001a14  e3a00000          MOV      r0,#0
001a18  ebfffffe          BL       LedSendHeartbeat
001a1c  e3500001          CMP      r0,#1
001a20  1a000016          BNE      |L1.6784|
;;;1420           {
;;;1421               *MEMSx = xMEMSVal;
001a24  e51f0184          LDR      r0,|L1.6312|
001a28  e1d000f0          LDRSH    r0,[r0,#0]  ; xMEMSVal
001a2c  e1c400b0          STRH     r0,[r4,#0]
;;;1422               *MEMSy = yMEMSVal;
001a30  e51f018c          LDR      r0,|L1.6316|
001a34  e1d000f0          LDRSH    r0,[r0,#0]  ; yMEMSVal
001a38  e1c500b0          STRH     r0,[r5,#0]
;;;1423               *MEMSz = zMEMSVal;    
001a3c  e51f0194          LDR      r0,|L1.6320|
001a40  e1d000f0          LDRSH    r0,[r0,#0]  ; zMEMSVal
001a44  e1c600b0          STRH     r0,[r6,#0]
;;;1424               return TRUE;
001a48  e3a00001          MOV      r0,#1
                  |L1.6732|
;;;1425           }
;;;1426       }
;;;1427       else
;;;1428       {
;;;1429           queryMEMSWaitCounter++;
;;;1430           if(queryMEMSWaitCounter >=3)
;;;1431               ledBuzyflag = FALSE;
;;;1432       }
;;;1433       return FALSE;
;;;1434   }
001a4c  e8bd8070          POP      {r4-r6,pc}
                  |L1.6736|
001a50  e59f00a4          LDR      r0,|L1.6908|
001a54  e5900000          LDR      r0,[r0,#0]            ;1429  ; queryMEMSWaitCounter
001a58  e2800001          ADD      r0,r0,#1              ;1429
001a5c  e59f1098          LDR      r1,|L1.6908|
001a60  e5810000          STR      r0,[r1,#0]            ;1429  ; queryMEMSWaitCounter
001a64  e2810000          ADD      r0,r1,#0              ;1430
001a68  e5900000          LDR      r0,[r0,#0]            ;1430  ; queryMEMSWaitCounter
001a6c  e3500003          CMP      r0,#3                 ;1430
001a70  ba000002          BLT      |L1.6784|
001a74  e3a00000          MOV      r0,#0                 ;1431
001a78  e59f1078          LDR      r1,|L1.6904|
001a7c  e5c10000          STRB     r0,[r1,#0]            ;1431  ; ledBuzyflag
                  |L1.6784|
001a80  e3a00000          MOV      r0,#0                 ;1433
001a84  eafffff0          B        |L1.6732|
;;;1435   
                          ENDP

                  QueryMEMSValueEx PROC
;;;1436   void QueryMEMSValueEx(short* MEMSx,short* MEMSy,short* MEMSz)
001a88  e3a03001          MOV      r3,#1
;;;1437   {
;;;1438       QueryMEMSFlag = TRUE;
001a8c  e51fc1f0          LDR      r12,|L1.6308|
001a90  e5cc3000          STRB     r3,[r12,#0]  ; QueryMEMSFlag
;;;1439       //if((LedSendHeartbeat(NULL) == TRUE))
;;;1440       //{
;;;1441           *MEMSx = xMEMSVal;
001a94  e51f31f4          LDR      r3,|L1.6312|
001a98  e1d330f0          LDRSH    r3,[r3,#0]  ; xMEMSVal
001a9c  e1c030b0          STRH     r3,[r0,#0]
;;;1442           *MEMSy = yMEMSVal;
001aa0  e51f31fc          LDR      r3,|L1.6316|
001aa4  e1d330f0          LDRSH    r3,[r3,#0]  ; yMEMSVal
001aa8  e1c130b0          STRH     r3,[r1,#0]
;;;1443           *MEMSz = zMEMSVal;        
001aac  e51f3204          LDR      r3,|L1.6320|
001ab0  e1d330f0          LDRSH    r3,[r3,#0]  ; zMEMSVal
001ab4  e1c230b0          STRH     r3,[r2,#0]
;;;1444       //}
;;;1445     
;;;1446   }
001ab8  e12fff1e          BX       lr
                  |L1.6844|
001abc  3d3d3d3e          DCB      "===> SendCollision clean...\r\n",0
001ac0  2053656e
001ac4  64436f6c
001ac8  6c697369
001acc  6f6e2063
001ad0  6c65616e
001ad4  2e2e2e0d
001ad8  0a00    
001ada  00                DCB      0
001adb  00                DCB      0
                  |L1.6876|
001adc  4c656456          DCB      "LedVersionQuery: ERROR...\r\n",0
001ae0  65727369
001ae4  6f6e5175
001ae8  6572793a
001aec  20455252
001af0  4f522e2e
001af4  2e0d0a00
                  |L1.6904|
                          DCD      ledBuzyflag
                  |L1.6908|
                          DCD      queryMEMSWaitCounter
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  errorMsgBuffer
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  pUartInterface
                          DCD      0x00000000
                  threadWaitTime
                          DCD      0xffffffff
                  factoryTestSendFlag
000008  00                DCB      0x00
                  heartSendFlag
000009  00                DCB      0x00
                  ledSetFlag
00000a  00                DCB      0x00
                  paraSetFlag
00000b  00                DCB      0x00
                  calibrationSetFlag
00000c  00                DCB      0x00
                  collisionSetFlag
00000d  00                DCB      0x00
                  collisionCleanFlag
00000e  00                DCB      0x00
                  initFlag
00000f  00                DCB      0x00
                  firstinitFlag
000010  01                DCB      0x01
                  bayColorTmp
000011  000000            DCB      0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
000018  00                DCB      0x00
                  statusColorTmp
000019  00                DCB      0x00
                  local_bias_degree
00001a  1e                DCB      0x1e
                  local_strength_X
00001b  1e                DCB      0x1e
                  local_strength_Y
00001c  1e                DCB      0x1e
                  local_strength_Z
00001d  1e                DCB      0x1e
                  local_DeathMin
00001e  1b00              DCB      0x1b,0x00
                  local_DeathSec
                          DCD      0x00000039
                  status
000024  00                DCB      0x00
                  fReadStatus
000025  00                DCB      0x00
                  QueryMEMSFlag
000026  00                DCB      0x00
                  ledBuzyflag
000027  00                DCB      0x00
                  reinitFlag
000028  01000000          DCB      0x01,0x00,0x00,0x00
                  queryMEMSWaitCounter
                          DCD      0x00000000
                  shakeflag
000030  00000000          DCB      0x00,0x00,0x00,0x00
                  xSemaphore
                          DCD      0x00000000
                  xSemaphoreResponse
                          DCD      0x00000000
                  whatever
                          DCD      0x00000000
                  xMEMSVal
000040  0000              DCB      0x00,0x00
                  yMEMSVal
000042  0000              DCB      0x00,0x00
                  zMEMSVal
000044  0000              DCB      0x00,0x00
