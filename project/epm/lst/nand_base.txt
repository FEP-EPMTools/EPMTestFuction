; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\nand_base.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nand_base.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\nand_base.crf ..\..\common\src\BSP\ThirdParty\yaffs2\nand_base.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  generic_ffs PROC
;;;11     
;;;12     static __inline int generic_ffs(int x)
000000  e1a01000          MOV      r1,r0
;;;13     {
;;;14     	int r = 1;
000004  e3a02001          MOV      r2,#1
;;;15     
;;;16     	if (!x)
000008  e3510000          CMP      r1,#0
00000c  1a000001          BNE      |L1.24|
;;;17     		return 0;
000010  e3a00000          MOV      r0,#0
                  |L1.20|
;;;18     	if (!(x & 0xffff)) {
;;;19     		x >>= 16;
;;;20     		r += 16;
;;;21     	}
;;;22     	if (!(x & 0xff)) {
;;;23     		x >>= 8;
;;;24     		r += 8;
;;;25     	}
;;;26     	if (!(x & 0xf)) {
;;;27     		x >>= 4;
;;;28     		r += 4;
;;;29     	}
;;;30     	if (!(x & 3)) {
;;;31     		x >>= 2;
;;;32     		r += 2;
;;;33     	}
;;;34     	if (!(x & 1)) {
;;;35     		x >>= 1;
;;;36     		r += 1;
;;;37     	}
;;;38     	return r;
;;;39     }
000014  e12fff1e          BX       lr
                  |L1.24|
000018  e1a00801          LSL      r0,r1,#16             ;18
00001c  e1b00820          LSRS     r0,r0,#16             ;18
000020  1a000001          BNE      |L1.44|
000024  e1a01841          ASR      r1,r1,#16             ;19
000028  e2822010          ADD      r2,r2,#0x10           ;20
                  |L1.44|
00002c  e31100ff          TST      r1,#0xff              ;22
000030  1a000001          BNE      |L1.60|
000034  e1a01441          ASR      r1,r1,#8              ;23
000038  e2822008          ADD      r2,r2,#8              ;24
                  |L1.60|
00003c  e311000f          TST      r1,#0xf               ;26
000040  1a000001          BNE      |L1.76|
000044  e1a01241          ASR      r1,r1,#4              ;27
000048  e2822004          ADD      r2,r2,#4              ;28
                  |L1.76|
00004c  e3110003          TST      r1,#3                 ;30
000050  1a000001          BNE      |L1.92|
000054  e1a01141          ASR      r1,r1,#2              ;31
000058  e2822002          ADD      r2,r2,#2              ;32
                  |L1.92|
00005c  e3110001          TST      r1,#1                 ;34
000060  1a000001          BNE      |L1.108|
000064  e1a010c1          ASR      r1,r1,#1              ;35
000068  e2822001          ADD      r2,r2,#1              ;36
                  |L1.108|
00006c  e1a00002          MOV      r0,r2                 ;38
000070  eaffffe7          B        |L1.20|
;;;40     
                          ENDP

                  check_offs_len PROC
;;;88     
;;;89     static int check_offs_len(struct mtd_info *mtd,
000074  e92d47f0          PUSH     {r4-r10,lr}
;;;90     					loff_t ofs, uint64_t len)
;;;91     {
000078  e1a01000          MOV      r1,r0
00007c  e1cd42d0          LDRD     r4,r5,[sp,#0x20]
;;;92     	struct nand_chip *chip = mtd->priv;
000080  e591c094          LDR      r12,[r1,#0x94]
;;;93     	int ret = 0;
000084  e3a00000          MOV      r0,#0
;;;94     
;;;95     	/* Start address must align on block boundary */
;;;96     	if (ofs & ((1 << chip->phys_erase_shift) - 1)) {
000088  e5dc6058          LDRB     r6,[r12,#0x58]
00008c  e3a07001          MOV      r7,#1
000090  e1a06617          LSL      r6,r7,r6
000094  e2466001          SUB      r6,r6,#1
000098  e0067002          AND      r7,r6,r2
00009c  e0038fc6          AND      r8,r3,r6,ASR #31
0000a0  e3a06000          MOV      r6,#0
0000a4  e1a09006          MOV      r9,r6
0000a8  e0266007          EOR      r6,r6,r7
0000ac  e0287009          EOR      r7,r8,r9
0000b0  e1966007          ORRS     r6,r6,r7
0000b4  0a000002          BEQ      |L1.196|
;;;97     		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Unaligned address\n", __func__);
0000b8  e1a00000          MOV      r0,r0
0000bc  e1a00000          MOV      r0,r0
;;;98     		ret = -EINVAL;
0000c0  e3e00015          MVN      r0,#0x15
                  |L1.196|
;;;99     	}
;;;100    
;;;101    	/* Length must align on block boundary */
;;;102    	if (len & ((1 << chip->phys_erase_shift) - 1)) {
0000c4  e5dc6058          LDRB     r6,[r12,#0x58]
0000c8  e3a07001          MOV      r7,#1
0000cc  e1a06617          LSL      r6,r7,r6
0000d0  e2466001          SUB      r6,r6,#1
0000d4  e1a07fc6          ASR      r7,r6,#31
0000d8  e0066004          AND      r6,r6,r4
0000dc  e0079005          AND      r9,r7,r5
0000e0  e3a07000          MOV      r7,#0
0000e4  e0266007          EOR      r6,r6,r7
0000e8  e0277009          EOR      r7,r7,r9
0000ec  e1966007          ORRS     r6,r6,r7
0000f0  0a000002          BEQ      |L1.256|
;;;103    		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Length not block aligned\n",
0000f4  e1a00000          MOV      r0,r0
0000f8  e1a00000          MOV      r0,r0
;;;104    					__func__);
;;;105    		ret = -EINVAL;
0000fc  e3e00015          MVN      r0,#0x15
                  |L1.256|
;;;106    	}
;;;107    
;;;108    	/* Do not allow past end of device */
;;;109    	if (ofs + len > mtd->size) {
000100  e0928004          ADDS     r8,r2,r4
000104  e0a39005          ADC      r9,r3,r5
000108  e1c160d8          LDRD     r6,r7,[r1,#8]
00010c  e0566008          SUBS     r6,r6,r8
000110  e0d76009          SBCS     r6,r7,r9
000114  2a000002          BCS      |L1.292|
;;;110    		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Past end of device\n",
000118  e1a00000          MOV      r0,r0
00011c  e1a00000          MOV      r0,r0
;;;111    					__func__);
;;;112    		ret = -EINVAL;
000120  e3e00015          MVN      r0,#0x15
                  |L1.292|
;;;113    	}
;;;114    
;;;115    	return ret;
;;;116    }
000124  e8bd87f0          POP      {r4-r10,pc}
;;;117    
                          ENDP

                  nand_release_device PROC
;;;123     */
;;;124    static void nand_release_device(struct mtd_info *mtd)
000128  e92d4070          PUSH     {r4-r6,lr}
;;;125    {
00012c  e1a04000          MOV      r4,r0
;;;126    	struct nand_chip *chip = mtd->priv;
000130  e5945094          LDR      r5,[r4,#0x94]
;;;127    
;;;128    	/* De-select the NAND device */
;;;129    	chip->select_chip(mtd, -1);
000134  e3e01000          MVN      r1,#0
000138  e1a00004          MOV      r0,r4
00013c  e595201c          LDR      r2,[r5,#0x1c]
000140  e12fff32          BLX      r2
;;;130    }
000144  e8bd8070          POP      {r4-r6,pc}
;;;131    
                          ENDP

                  nand_read_byte PROC
;;;137     */
;;;138    uint8_t nand_read_byte(struct mtd_info *mtd)
000148  e1a01000          MOV      r1,r0
;;;139    {
;;;140    	struct nand_chip *chip = mtd->priv;
00014c  e5912094          LDR      r2,[r1,#0x94]
;;;141    	return inpb(chip->IO_ADDR_R);
000150  e5920000          LDR      r0,[r2,#0]
000154  e5d00000          LDRB     r0,[r0,#0]
;;;142    }
000158  e12fff1e          BX       lr
;;;143    
                          ENDP

                  nand_read_byte16 PROC
;;;150     */
;;;151    static uint8_t nand_read_byte16(struct mtd_info *mtd)
00015c  e1a01000          MOV      r1,r0
;;;152    {
;;;153    	struct nand_chip *chip = mtd->priv;
000160  e5912094          LDR      r2,[r1,#0x94]
;;;154    	return (uint8_t) (inpw(chip->IO_ADDR_R));
000164  e5920000          LDR      r0,[r2,#0]
000168  e5900000          LDR      r0,[r0,#0]
00016c  e20000ff          AND      r0,r0,#0xff
;;;155    }
000170  e12fff1e          BX       lr
;;;156    
                          ENDP

                  nand_read_word PROC
;;;163     */
;;;164    static u16 nand_read_word(struct mtd_info *mtd)
000174  e1a01000          MOV      r1,r0
;;;165    {
;;;166    	struct nand_chip *chip = mtd->priv;
000178  e5912094          LDR      r2,[r1,#0x94]
;;;167    	return inpw(chip->IO_ADDR_R);
00017c  e5920000          LDR      r0,[r2,#0]
000180  e5900000          LDR      r0,[r0,#0]
000184  e1a00800          LSL      r0,r0,#16
000188  e1a00820          LSR      r0,r0,#16
;;;168    }
00018c  e12fff1e          BX       lr
;;;169    
                          ENDP

                  nand_select_chip PROC
;;;176     */
;;;177    static void nand_select_chip(struct mtd_info *mtd, int chipnr)
000190  e92d4070          PUSH     {r4-r6,lr}
;;;178    {
000194  e1a04000          MOV      r4,r0
000198  e1a05001          MOV      r5,r1
;;;179    	struct nand_chip *chip = mtd->priv;
00019c  e5946094          LDR      r6,[r4,#0x94]
;;;180    
;;;181    	switch (chipnr) {
0001a0  e3750001          CMN      r5,#1
0001a4  0a000002          BEQ      |L1.436|
0001a8  e3550000          CMP      r5,#0
0001ac  1a000009          BNE      |L1.472|
0001b0  ea000006          B        |L1.464|
                  |L1.436|
;;;182    	case -1:
0001b4  e1a00000          MOV      r0,r0
;;;183    		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
0001b8  e3a02080          MOV      r2,#0x80
0001bc  e3e01000          MVN      r1,#0
0001c0  e1a00004          MOV      r0,r4
0001c4  e5963028          LDR      r3,[r6,#0x28]
0001c8  e12fff33          BLX      r3
;;;184    		break;
0001cc  ea000009          B        |L1.504|
                  |L1.464|
;;;185    	case 0:
0001d0  e1a00000          MOV      r0,r0
;;;186    		break;
0001d4  ea000007          B        |L1.504|
                  |L1.472|
;;;187    
;;;188    	default:
0001d8  e1a00000          MOV      r0,r0
;;;189    		BUG();
0001dc  e1a00000          MOV      r0,r0
0001e0  e3a020bd          MOV      r2,#0xbd
0001e4  e28f1fb5          ADR      r1,|L1.1216|
0001e8  e28f0fc1          ADR      r0,|L1.1268|
0001ec  ebfffffe          BL       sysprintf
0001f0  e1a00000          MOV      r0,r0
0001f4  e1a00000          MOV      r0,r0                 ;181
                  |L1.504|
0001f8  e1a00000          MOV      r0,r0                 ;184
;;;190    	}
;;;191    }
0001fc  e8bd8070          POP      {r4-r6,pc}
;;;192    
                          ENDP

                  nand_write_buf PROC
;;;200     */
;;;201    void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
000200  e92d4030          PUSH     {r4,r5,lr}
;;;202    {
000204  e1a03000          MOV      r3,r0
;;;203    	int i;
;;;204    	struct nand_chip *chip = mtd->priv;
000208  e593c094          LDR      r12,[r3,#0x94]
;;;205    
;;;206    	for (i = 0; i < len; i++)
00020c  e3a00000          MOV      r0,#0
000210  ea000003          B        |L1.548|
                  |L1.532|
;;;207    		outpb(chip->IO_ADDR_W, buf[i]);
000214  e7d14000          LDRB     r4,[r1,r0]
000218  e59c5004          LDR      r5,[r12,#4]
00021c  e5c54000          STRB     r4,[r5,#0]
000220  e2800001          ADD      r0,r0,#1              ;206
                  |L1.548|
000224  e1500002          CMP      r0,r2                 ;206
000228  bafffff9          BLT      |L1.532|
;;;208    }
00022c  e8bd8030          POP      {r4,r5,pc}
;;;209    
                          ENDP

                  nand_read_buf PROC
;;;217     */
;;;218    void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
000230  e92d4010          PUSH     {r4,lr}
;;;219    {
000234  e1a03000          MOV      r3,r0
;;;220    	int i;
;;;221    	struct nand_chip *chip = mtd->priv;
000238  e593c094          LDR      r12,[r3,#0x94]
;;;222    
;;;223    	for (i = 0; i < len; i++)
00023c  e3a00000          MOV      r0,#0
000240  ea000003          B        |L1.596|
                  |L1.580|
;;;224    		buf[i] = inpb(chip->IO_ADDR_R);
000244  e59c4000          LDR      r4,[r12,#0]
000248  e5d44000          LDRB     r4,[r4,#0]
00024c  e7c14000          STRB     r4,[r1,r0]
000250  e2800001          ADD      r0,r0,#1              ;223
                  |L1.596|
000254  e1500002          CMP      r0,r2                 ;223
000258  bafffff9          BLT      |L1.580|
;;;225    }
00025c  e8bd8010          POP      {r4,pc}
;;;226    
                          ENDP

                  nand_verify_buf PROC
;;;234     */
;;;235    static int nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
000260  e92d4030          PUSH     {r4,r5,lr}
;;;236    {
000264  e1a03000          MOV      r3,r0
000268  e1a0c001          MOV      r12,r1
;;;237    	int i;
;;;238    	struct nand_chip *chip = mtd->priv;
00026c  e5934094          LDR      r4,[r3,#0x94]
;;;239    
;;;240    	for (i = 0; i < len; i++)
000270  e3a01000          MOV      r1,#0
000274  ea000007          B        |L1.664|
                  |L1.632|
;;;241    		if (buf[i] != inpb(chip->IO_ADDR_R))
000278  e7dc0001          LDRB     r0,[r12,r1]
00027c  e5945000          LDR      r5,[r4,#0]
000280  e5d55000          LDRB     r5,[r5,#0]
000284  e1500005          CMP      r0,r5
000288  0a000001          BEQ      |L1.660|
;;;242    			return -EFAULT;
00028c  e3e0000d          MVN      r0,#0xd
                  |L1.656|
;;;243    	return 0;
;;;244    }
000290  e8bd8030          POP      {r4,r5,pc}
                  |L1.660|
000294  e2811001          ADD      r1,r1,#1              ;240
                  |L1.664|
000298  e1510002          CMP      r1,r2                 ;240
00029c  bafffff5          BLT      |L1.632|
0002a0  e3a00000          MOV      r0,#0                 ;243
0002a4  eafffff9          B        |L1.656|
;;;245    
                          ENDP

                  nand_write_buf16 PROC
;;;253     */
;;;254    void nand_write_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
0002a8  e92d4070          PUSH     {r4-r6,lr}
;;;255    {
0002ac  e1a03000          MOV      r3,r0
;;;256    	int i;
;;;257    	struct nand_chip *chip = mtd->priv;
0002b0  e593c094          LDR      r12,[r3,#0x94]
;;;258    	u16 *p = (u16 *) buf;
0002b4  e1a04001          MOV      r4,r1
;;;259    	len >>= 1;
0002b8  e1a020c2          ASR      r2,r2,#1
;;;260    
;;;261    	for (i = 0; i < len; i++)
0002bc  e3a00000          MOV      r0,#0
0002c0  ea000004          B        |L1.728|
                  |L1.708|
;;;262    		outpw(chip->IO_ADDR_W, p[i]);
0002c4  e0845080          ADD      r5,r4,r0,LSL #1
0002c8  e1d550b0          LDRH     r5,[r5,#0]
0002cc  e59c6004          LDR      r6,[r12,#4]
0002d0  e5865000          STR      r5,[r6,#0]
0002d4  e2800001          ADD      r0,r0,#1              ;261
                  |L1.728|
0002d8  e1500002          CMP      r0,r2                 ;261
0002dc  bafffff8          BLT      |L1.708|
;;;263    
;;;264    }
0002e0  e8bd8070          POP      {r4-r6,pc}
;;;265    
                          ENDP

                  nand_read_buf16 PROC
;;;273     */
;;;274    void nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)
0002e4  e92d4070          PUSH     {r4-r6,lr}
;;;275    {
0002e8  e1a03000          MOV      r3,r0
;;;276    	int i;
;;;277    	struct nand_chip *chip = mtd->priv;
0002ec  e593c094          LDR      r12,[r3,#0x94]
;;;278    	u16 *p = (u16 *) buf;
0002f0  e1a04001          MOV      r4,r1
;;;279    	len >>= 1;
0002f4  e1a020c2          ASR      r2,r2,#1
;;;280    
;;;281    	for (i = 0; i < len; i++)
0002f8  e3a00000          MOV      r0,#0
0002fc  ea000004          B        |L1.788|
                  |L1.768|
;;;282    		p[i] = inpw(chip->IO_ADDR_R);
000300  e59c5000          LDR      r5,[r12,#0]
000304  e5955000          LDR      r5,[r5,#0]
000308  e0846080          ADD      r6,r4,r0,LSL #1
00030c  e1c650b0          STRH     r5,[r6,#0]
000310  e2800001          ADD      r0,r0,#1              ;281
                  |L1.788|
000314  e1500002          CMP      r0,r2                 ;281
000318  bafffff8          BLT      |L1.768|
;;;283    }
00031c  e8bd8070          POP      {r4-r6,pc}
;;;284    
                          ENDP

                  nand_verify_buf16 PROC
;;;292     */
;;;293    static int nand_verify_buf16(struct mtd_info *mtd, const uint8_t *buf, int len)
000320  e92d4070          PUSH     {r4-r6,lr}
;;;294    {
000324  e1a03000          MOV      r3,r0
000328  e1a0c001          MOV      r12,r1
;;;295    	int i;
;;;296    	struct nand_chip *chip = mtd->priv;
00032c  e5934094          LDR      r4,[r3,#0x94]
;;;297    	u16 *p = (u16 *) buf;
000330  e1a0500c          MOV      r5,r12
;;;298    	len >>= 1;
000334  e1a020c2          ASR      r2,r2,#1
;;;299    
;;;300    	for (i = 0; i < len; i++)
000338  e3a01000          MOV      r1,#0
00033c  ea000008          B        |L1.868|
                  |L1.832|
;;;301    		if (p[i] != inpw(chip->IO_ADDR_R))
000340  e0850081          ADD      r0,r5,r1,LSL #1
000344  e1d000b0          LDRH     r0,[r0,#0]
000348  e5946000          LDR      r6,[r4,#0]
00034c  e5966000          LDR      r6,[r6,#0]
000350  e1500006          CMP      r0,r6
000354  0a000001          BEQ      |L1.864|
;;;302    			return -EFAULT;
000358  e3e0000d          MVN      r0,#0xd
                  |L1.860|
;;;303    
;;;304    	return 0;
;;;305    }
00035c  e8bd8070          POP      {r4-r6,pc}
                  |L1.864|
000360  e2811001          ADD      r1,r1,#1              ;300
                  |L1.868|
000364  e1510002          CMP      r1,r2                 ;300
000368  bafffff4          BLT      |L1.832|
00036c  e3a00000          MOV      r0,#0                 ;304
000370  eafffff9          B        |L1.860|
;;;306    
                          ENDP

                  nand_get_device PROC
;;;720    static int
;;;721    nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
000374  e1a03000          MOV      r3,r0
;;;722    {
;;;723    	chip->state = new_state;
000378  e583208c          STR      r2,[r3,#0x8c]
;;;724    	return 0;
00037c  e3a00000          MOV      r0,#0
;;;725    }
000380  e12fff1e          BX       lr
;;;726    
                          ENDP

                  nand_block_bad PROC
;;;314     */
;;;315    static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
000384  e92d5fff          PUSH     {r0-r12,lr}
;;;316    {
000388  e1a08000          MOV      r8,r0
00038c  e1a06002          MOV      r6,r2
000390  e1a07003          MOV      r7,r3
;;;317    	int page, chipnr, res = 0;
000394  e3a00000          MOV      r0,#0
000398  e58d0000          STR      r0,[sp,#0]
;;;318    	struct nand_chip *chip = mtd->priv;
00039c  e5984094          LDR      r4,[r8,#0x94]
;;;319    	u16 bad;
;;;320    
;;;321    	if (chip->options & NAND_BBT_SCANLASTPAGE)
0003a0  e1d405b0          LDRH     r0,[r4,#0x50]
0003a4  e3100902          TST      r0,#0x8000
0003a8  0a000003          BEQ      |L1.956|
;;;322    		ofs += mtd->erasesize - mtd->writesize;
0003ac  e1c801d0          LDRD     r0,r1,[r8,#0x10]
0003b0  e0400001          SUB      r0,r0,r1
0003b4  e0966000          ADDS     r6,r6,r0
0003b8  e2a77000          ADC      r7,r7,#0
                  |L1.956|
;;;323    
;;;324    	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
0003bc  e1a09006          MOV      r9,r6
0003c0  e1a0a007          MOV      r10,r7
0003c4  e1a00009          MOV      r0,r9
0003c8  e1a0100a          MOV      r1,r10
0003cc  e5942054          LDR      r2,[r4,#0x54]
0003d0  ebfffffe          BL       __aeabi_lasr
0003d4  e5941070          LDR      r1,[r4,#0x70]
0003d8  e0000001          AND      r0,r0,r1
0003dc  e58d0008          STR      r0,[sp,#8]
;;;325    
;;;326    	if (getchip) {
0003e0  e59d0038          LDR      r0,[sp,#0x38]
0003e4  e3500000          CMP      r0,#0
0003e8  0a00000e          BEQ      |L1.1064|
;;;327    		chipnr = (int)(ofs >> chip->chip_shift);
0003ec  e1a0b006          MOV      r11,r6
0003f0  e5942060          LDR      r2,[r4,#0x60]
0003f4  e1a0000b          MOV      r0,r11
0003f8  e58d700c          STR      r7,[sp,#0xc]
0003fc  e1a01007          MOV      r1,r7
000400  ebfffffe          BL       __aeabi_lasr
000404  e58d0004          STR      r0,[sp,#4]
;;;328    
;;;329    		nand_get_device(chip, mtd, FL_READING);
000408  e3a02001          MOV      r2,#1
00040c  e1a01008          MOV      r1,r8
000410  e1a00004          MOV      r0,r4
000414  ebfffffe          BL       nand_get_device
;;;330    
;;;331    		/* Select the NAND device */
;;;332    		chip->select_chip(mtd, chipnr);
000418  e594201c          LDR      r2,[r4,#0x1c]
00041c  e1a00008          MOV      r0,r8
000420  e59d1004          LDR      r1,[sp,#4]
000424  e12fff32          BLX      r2
                  |L1.1064|
;;;333    	}
;;;334    
;;;335    	if (chip->options & NAND_BUSWIDTH_16) {
000428  e5d40050          LDRB     r0,[r4,#0x50]
00042c  e3100002          TST      r0,#2
000430  0a000011          BEQ      |L1.1148|
;;;336    		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos & 0xFE,
000434  e5d40080          LDRB     r0,[r4,#0x80]
000438  e20020fe          AND      r2,r0,#0xfe
00043c  e594c034          LDR      r12,[r4,#0x34]
000440  e3a01050          MOV      r1,#0x50
000444  e1a00008          MOV      r0,r8
000448  e59d3008          LDR      r3,[sp,#8]
00044c  e12fff3c          BLX      r12
;;;337    			      page);
;;;338    		bad = (chip->read_word(mtd));
000450  e1a00008          MOV      r0,r8
000454  e594100c          LDR      r1,[r4,#0xc]
000458  e12fff31          BLX      r1
00045c  e1a05000          MOV      r5,r0
;;;339    		if (chip->badblockpos & 0x1)
000460  e5d40080          LDRB     r0,[r4,#0x80]
000464  e3100001          TST      r0,#1
000468  0a000001          BEQ      |L1.1140|
;;;340    			bad >>= 8;
00046c  e1a05445          ASR      r5,r5,#8
000470  ea00000b          B        |L1.1188|
                  |L1.1140|
;;;341    		else
;;;342    			bad &= 0xFF;
000474  e20550ff          AND      r5,r5,#0xff
000478  ea000009          B        |L1.1188|
                  |L1.1148|
;;;343    	} else {
;;;344    		chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos, page);
00047c  e5942080          LDR      r2,[r4,#0x80]
000480  e594c034          LDR      r12,[r4,#0x34]
000484  e3a01050          MOV      r1,#0x50
000488  e1a00008          MOV      r0,r8
00048c  e59d3008          LDR      r3,[sp,#8]
000490  e12fff3c          BLX      r12
;;;345    		bad = chip->read_byte(mtd);
000494  e1a00008          MOV      r0,r8
000498  e5941008          LDR      r1,[r4,#8]
00049c  e12fff31          BLX      r1
0004a0  e1a05000          MOV      r5,r0
                  |L1.1188|
;;;346    	}
;;;347    
;;;348    	if (chip->badblockbits == 8)
0004a4  e5940084          LDR      r0,[r4,#0x84]
0004a8  e3500008          CMP      r0,#8
0004ac  1a000019          BNE      |L1.1304|
;;;349    		res = bad != 0xFF;
0004b0  e35500ff          CMP      r5,#0xff
0004b4  0a000014          BEQ      |L1.1292|
0004b8  e3a00001          MOV      r0,#1
0004bc  ea000013          B        |L1.1296|
                  |L1.1216|
0004c0  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\nand_base"
0004c4  2e5c636f
0004c8  6d6d6f6e
0004cc  5c737263
0004d0  5c425350
0004d4  5c546869
0004d8  72645061
0004dc  7274795c
0004e0  79616666
0004e4  73325c6e
0004e8  616e645f
0004ec  62617365
0004f0  2e6300            DCB      ".c",0
0004f3  00                DCB      0
                  |L1.1268|
0004f4  552d426f          DCB      "U-Boot BUG at %s:%d!\n",0
0004f8  6f742042
0004fc  55472061
000500  74202573
000504  3a256421
000508  0a00    
00050a  00                DCB      0
00050b  00                DCB      0
                  |L1.1292|
00050c  e3a00000          MOV      r0,#0
                  |L1.1296|
000510  e58d0000          STR      r0,[sp,#0]
000514  ea000013          B        |L1.1384|
                  |L1.1304|
;;;350    	else
;;;351    		res = hweight8(bad) < chip->badblockbits;
000518  e1a00000          MOV      r0,r0
00051c  e2051055          AND      r1,r5,#0x55
000520  e3a02055          MOV      r2,#0x55
000524  e00220a5          AND      r2,r2,r5,LSR #1
000528  e0810002          ADD      r0,r1,r2
00052c  e2001033          AND      r1,r0,#0x33
000530  e3a02033          MOV      r2,#0x33
000534  e0022120          AND      r2,r2,r0,LSR #2
000538  e0810002          ADD      r0,r1,r2
00053c  e200100f          AND      r1,r0,#0xf
000540  e3a0200f          MOV      r2,#0xf
000544  e0022220          AND      r2,r2,r0,LSR #4
000548  e0811002          ADD      r1,r1,r2
00054c  e5940084          LDR      r0,[r4,#0x84]
000550  e1510000          CMP      r1,r0
000554  2a000001          BCS      |L1.1376|
000558  e3a00001          MOV      r0,#1
00055c  ea000000          B        |L1.1380|
                  |L1.1376|
000560  e3a00000          MOV      r0,#0
                  |L1.1380|
000564  e58d0000          STR      r0,[sp,#0]
                  |L1.1384|
;;;352    
;;;353    	if (getchip)
000568  e59d0038          LDR      r0,[sp,#0x38]
00056c  e3500000          CMP      r0,#0
000570  0a000001          BEQ      |L1.1404|
;;;354    		nand_release_device(mtd);
000574  e1a00008          MOV      r0,r8
000578  ebfffffe          BL       nand_release_device
                  |L1.1404|
;;;355    
;;;356    	return res;
00057c  e59d0000          LDR      r0,[sp,#0]
000580  e28dd010          ADD      sp,sp,#0x10
;;;357    }
000584  e8bd9ff0          POP      {r4-r12,pc}
;;;358    
                          ENDP

                  nand_fill_oob PROC
;;;1830    */
;;;1831   static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,
000588  e92d5ff0          PUSH     {r4-r12,lr}
;;;1832   						struct mtd_oob_ops *ops)
;;;1833   {
00058c  e1a07000          MOV      r7,r0
000590  e1a08001          MOV      r8,r1
000594  e1a05002          MOV      r5,r2
000598  e1a09003          MOV      r9,r3
;;;1834   	switch (ops->mode) {
00059c  e5d90000          LDRB     r0,[r9,#0]
0005a0  e3500000          CMP      r0,#0
0005a4  0a000004          BEQ      |L1.1468|
0005a8  e3500001          CMP      r0,#1
0005ac  0a00000c          BEQ      |L1.1508|
0005b0  e3500002          CMP      r0,#2
0005b4  1a00003e          BNE      |L1.1716|
0005b8  ea000001          B        |L1.1476|
                  |L1.1468|
;;;1835   
;;;1836   	case MTD_OOB_PLACE:
0005bc  e1a00000          MOV      r0,r0
;;;1837   	case MTD_OOB_RAW:
0005c0  e1a00000          MOV      r0,r0
                  |L1.1476|
;;;1838   		memcpy(chip->oob_poi + ops->ooboffs, oob, len);
0005c4  e5971090          LDR      r1,[r7,#0x90]
0005c8  e5992014          LDR      r2,[r9,#0x14]
0005cc  e0810002          ADD      r0,r1,r2
0005d0  e1a02005          MOV      r2,r5
0005d4  e1a01008          MOV      r1,r8
0005d8  ebfffffe          BL       __aeabi_memcpy
;;;1839   		return oob + len;
0005dc  e0880005          ADD      r0,r8,r5
                  |L1.1504|
;;;1840   
;;;1841   	case MTD_OOB_AUTO: {
;;;1842   		struct nand_oobfree *free = chip->ecc.layout->oobfree;
;;;1843   		uint32_t boffs = 0, woffs = ops->ooboffs;
;;;1844   		size_t bytes = 0;
;;;1845   
;;;1846   		for (; free->length && len; free++, len -= bytes) {
;;;1847   			/* Write request not from offset 0 ? */
;;;1848   			if (woffs) {
;;;1849   				if (woffs >= free->length) {
;;;1850   					woffs -= free->length;
;;;1851   					continue;
;;;1852   				}
;;;1853   				boffs = free->offset + woffs;
;;;1854   				bytes = min_t(size_t, len,
;;;1855   					      (free->length - woffs));
;;;1856   				woffs = 0;
;;;1857   			} else {
;;;1858   				bytes = min_t(size_t, len, free->length);
;;;1859   				boffs = free->offset;
;;;1860   			}
;;;1861   			memcpy(chip->oob_poi + boffs, oob, bytes);
;;;1862   			oob += bytes;
;;;1863   		}
;;;1864   		return oob;
;;;1865   	}
;;;1866   	default:
;;;1867   		BUG();
;;;1868   	}
;;;1869   	return NULL;
;;;1870   }
0005e0  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.1508|
0005e4  e1a00000          MOV      r0,r0                 ;1841
0005e8  e59700b8          LDR      r0,[r7,#0xb8]         ;1842
0005ec  e2804f82          ADD      r4,r0,#0x208          ;1842
0005f0  e3a0b000          MOV      r11,#0                ;1843
0005f4  e5996014          LDR      r6,[r9,#0x14]         ;1843
0005f8  e3a0a000          MOV      r10,#0                ;1844
0005fc  ea000025          B        |L1.1688|
                  |L1.1536|
000600  e3560000          CMP      r6,#0                 ;1848
000604  0a000012          BEQ      |L1.1620|
000608  e5940004          LDR      r0,[r4,#4]            ;1849
00060c  e1500006          CMP      r0,r6                 ;1849
000610  8a000002          BHI      |L1.1568|
000614  e5940004          LDR      r0,[r4,#4]            ;1850
000618  e0466000          SUB      r6,r6,r0              ;1850
00061c  ea00001b          B        |L1.1680|
                  |L1.1568|
000620  e5940000          LDR      r0,[r4,#0]            ;1853
000624  e080b006          ADD      r11,r0,r6             ;1853
000628  e5940004          LDR      r0,[r4,#4]            ;1854
00062c  e0400006          SUB      r0,r0,r6              ;1854
000630  e1500005          CMP      r0,r5                 ;1854
000634  9a000001          BLS      |L1.1600|
000638  e1a00005          MOV      r0,r5                 ;1854
00063c  ea000001          B        |L1.1608|
                  |L1.1600|
000640  e5940004          LDR      r0,[r4,#4]            ;1854
000644  e0400006          SUB      r0,r0,r6              ;1854
                  |L1.1608|
000648  e1a0a000          MOV      r10,r0                ;1854
00064c  e3a06000          MOV      r6,#0                 ;1856
000650  ea000007          B        |L1.1652|
                  |L1.1620|
000654  e5940004          LDR      r0,[r4,#4]            ;1858
000658  e1500005          CMP      r0,r5                 ;1858
00065c  9a000001          BLS      |L1.1640|
000660  e1a00005          MOV      r0,r5                 ;1858
000664  ea000000          B        |L1.1644|
                  |L1.1640|
000668  e5940004          LDR      r0,[r4,#4]            ;1858
                  |L1.1644|
00066c  e1a0a000          MOV      r10,r0                ;1858
000670  e594b000          LDR      r11,[r4,#0]           ;1859
                  |L1.1652|
000674  e5971090          LDR      r1,[r7,#0x90]         ;1861
000678  e081000b          ADD      r0,r1,r11             ;1861
00067c  e1a0200a          MOV      r2,r10                ;1861
000680  e1a01008          MOV      r1,r8                 ;1861
000684  ebfffffe          BL       __aeabi_memcpy
000688  e088800a          ADD      r8,r8,r10             ;1862
00068c  e1a00000          MOV      r0,r0                 ;1851
                  |L1.1680|
000690  e2844008          ADD      r4,r4,#8              ;1846
000694  e045500a          SUB      r5,r5,r10             ;1846
                  |L1.1688|
000698  e5940004          LDR      r0,[r4,#4]            ;1846
00069c  e3500000          CMP      r0,#0                 ;1846
0006a0  0a000001          BEQ      |L1.1708|
0006a4  e3550000          CMP      r5,#0                 ;1846
0006a8  1affffd4          BNE      |L1.1536|
                  |L1.1708|
0006ac  e1a00008          MOV      r0,r8                 ;1864
0006b0  eaffffca          B        |L1.1504|
                  |L1.1716|
0006b4  e1a00000          MOV      r0,r0                 ;1866
0006b8  e1a00000          MOV      r0,r0                 ;1867
0006bc  e59f2d70          LDR      r2,|L1.5172|
0006c0  e24f1f82          ADR      r1,|L1.1216|
0006c4  e24f0f76          ADR      r0,|L1.1268|
0006c8  ebfffffe          BL       sysprintf
0006cc  e1a00000          MOV      r0,r0                 ;1867
0006d0  e1a00000          MOV      r0,r0                 ;1834
0006d4  e1a00000          MOV      r0,r0                 ;1834
0006d8  e3a00000          MOV      r0,#0                 ;1869
0006dc  eaffffbf          B        |L1.1504|
;;;1871   
                          ENDP

                  nand_check_wp PROC
;;;424     */
;;;425    static int nand_check_wp(struct mtd_info *mtd)
0006e0  e92d4070          PUSH     {r4-r6,lr}
;;;426    {
0006e4  e1a05000          MOV      r5,r0
;;;427    	struct nand_chip *chip = mtd->priv;
0006e8  e5954094          LDR      r4,[r5,#0x94]
;;;428    
;;;429    	/* broken xD cards report WP despite being writable */
;;;430    	if (chip->options & NAND_BROKEN_XD)
0006ec  e1d405b0          LDRH     r0,[r4,#0x50]
0006f0  e3100b01          TST      r0,#0x400
0006f4  0a000001          BEQ      |L1.1792|
;;;431    		return 0;
0006f8  e3a00000          MOV      r0,#0
                  |L1.1788|
;;;432    
;;;433    	/* Check the WP bit */
;;;434    	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
;;;435    	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
;;;436    }
0006fc  e8bd8070          POP      {r4-r6,pc}
                  |L1.1792|
000700  e3e03000          MVN      r3,#0                 ;434
000704  e1a02003          MOV      r2,r3                 ;434
000708  e3a01070          MOV      r1,#0x70              ;434
00070c  e1a00005          MOV      r0,r5                 ;434
000710  e594c034          LDR      r12,[r4,#0x34]        ;434
000714  e12fff3c          BLX      r12                   ;434
000718  e1a00005          MOV      r0,r5                 ;435
00071c  e5941008          LDR      r1,[r4,#8]            ;435
000720  e12fff31          BLX      r1                    ;435
000724  e3a01001          MOV      r1,#1                 ;435
000728  e1c103a0          BIC      r0,r1,r0,LSR #7       ;435
00072c  eafffff2          B        |L1.1788|
;;;437    
                          ENDP

                  nand_do_write_oob PROC
;;;2026    */
;;;2027   static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
000730  e92d4ff0          PUSH     {r4-r11,lr}
;;;2028   			     struct mtd_oob_ops *ops)
;;;2029   {
000734  e24dd02c          SUB      sp,sp,#0x2c
000738  e1a0a000          MOV      r10,r0
00073c  e1a05002          MOV      r5,r2
000740  e1a06003          MOV      r6,r3
000744  e59d9050          LDR      r9,[sp,#0x50]
;;;2030   	int chipnr, page, status, len;
;;;2031   	struct nand_chip *chip = mtd->priv;
000748  e59a4094          LDR      r4,[r10,#0x94]
;;;2032   
;;;2033   	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: to = 0x%08x, len = %i\n",
00074c  e1a00000          MOV      r0,r0
000750  e1a00000          MOV      r0,r0
;;;2034   			 __func__, (unsigned int)to, (int)ops->ooblen);
;;;2035   
;;;2036   	if (ops->mode == MTD_OOB_AUTO)
000754  e5d90000          LDRB     r0,[r9,#0]
000758  e3500001          CMP      r0,#1
00075c  1a000002          BNE      |L1.1900|
;;;2037   		len = chip->ecc.layout->oobavail;
000760  e59400b8          LDR      r0,[r4,#0xb8]
000764  e590b204          LDR      r11,[r0,#0x204]
000768  ea000000          B        |L1.1904|
                  |L1.1900|
;;;2038   	else
;;;2039   		len = mtd->oobsize;
00076c  e59ab018          LDR      r11,[r10,#0x18]
                  |L1.1904|
;;;2040   
;;;2041   	/* Do not allow write past end of page */
;;;2042   	if ((ops->ooboffs + ops->ooblen) > len) {
000770  e5990014          LDR      r0,[r9,#0x14]
000774  e599100c          LDR      r1,[r9,#0xc]
000778  e0800001          ADD      r0,r0,r1
00077c  e150000b          CMP      r0,r11
000780  9a000004          BLS      |L1.1944|
;;;2043   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to write "
000784  e1a00000          MOV      r0,r0
000788  e1a00000          MOV      r0,r0
;;;2044   				"past end of page\n", __func__);
;;;2045   		return -EINVAL;
00078c  e3e00015          MVN      r0,#0x15
                  |L1.1936|
000790  e28dd02c          ADD      sp,sp,#0x2c
;;;2046   	}
;;;2047   
;;;2048   	if (ops->ooboffs >= len) {
;;;2049   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start "
;;;2050   				"write outside oob\n", __func__);
;;;2051   		return -EINVAL;
;;;2052   	}
;;;2053   
;;;2054   	/* Do not allow write past end of device */
;;;2055   	if (to >= mtd->size || ops->ooboffs + ops->ooblen > ((mtd->size >> chip->page_shift) - (to >> chip->page_shift)) * len) {
;;;2056   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
;;;2057   				"end of device\n", __func__);
;;;2058   		return -EINVAL;
;;;2059   	}
;;;2060   
;;;2061   	chipnr = (int)(to >> chip->chip_shift);
;;;2062   	chip->select_chip(mtd, chipnr);
;;;2063   
;;;2064   	/* Shift to get page */
;;;2065   	page = (int)(to >> chip->page_shift);
;;;2066   
;;;2067   	/*
;;;2068   	 * Reset the chip. Some chips (like the Toshiba TC5832DC found in one
;;;2069   	 * of my DiskOnChip 2000 test units) will clear the whole data page too
;;;2070   	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
;;;2071   	 * it in the doc2000 driver in August 1999.  dwmw2.
;;;2072   	 */
;;;2073   	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
;;;2074   
;;;2075   	/* Check, if it is write protected */
;;;2076   	if (nand_check_wp(mtd))
;;;2077   		return -EROFS;
;;;2078   
;;;2079   	/* Invalidate the page cache, if we write to the cached page */
;;;2080   	if (page == chip->pagebuf)
;;;2081   		chip->pagebuf = -1;
;;;2082   
;;;2083   	memset(chip->oob_poi, 0xff, mtd->oobsize);
;;;2084   	nand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);
;;;2085   	status = chip->ecc.write_oob(mtd, chip, page & chip->pagemask);
;;;2086   	memset(chip->oob_poi, 0xff, mtd->oobsize);
;;;2087   
;;;2088   	if (status)
;;;2089   		return status;
;;;2090   
;;;2091   	ops->oobretlen = ops->ooblen;
;;;2092   
;;;2093   	return 0;
;;;2094   }
000794  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1944|
000798  e5990014          LDR      r0,[r9,#0x14]         ;2048
00079c  e150000b          CMP      r0,r11                ;2048
0007a0  3a000003          BCC      |L1.1972|
0007a4  e1a00000          MOV      r0,r0                 ;2049
0007a8  e1a00000          MOV      r0,r0                 ;2049
0007ac  e3e00015          MVN      r0,#0x15              ;2051
0007b0  eafffff6          B        |L1.1936|
                  |L1.1972|
0007b4  e59a1008          LDR      r1,[r10,#8]           ;2055
0007b8  e0551001          SUBS     r1,r5,r1              ;2055
0007bc  e59a000c          LDR      r0,[r10,#0xc]         ;2055
0007c0  e0d60000          SBCS     r0,r6,r0              ;2055
0007c4  2a00001b          BCS      |L1.2104|
0007c8  e59a000c          LDR      r0,[r10,#0xc]         ;2055
0007cc  e59a1008          LDR      r1,[r10,#8]           ;2055
0007d0  e5942054          LDR      r2,[r4,#0x54]         ;2055
0007d4  e58d0014          STR      r0,[sp,#0x14]         ;2055
0007d8  e58d1018          STR      r1,[sp,#0x18]         ;2055
0007dc  e1a00001          MOV      r0,r1                 ;2055
0007e0  e59d1014          LDR      r1,[sp,#0x14]         ;2055
0007e4  ebfffffe          BL       __aeabi_llsr
0007e8  e1a07000          MOV      r7,r0                 ;2055
0007ec  e1a08001          MOV      r8,r1                 ;2055
0007f0  e5942054          LDR      r2,[r4,#0x54]         ;2055
0007f4  e58d5010          STR      r5,[sp,#0x10]         ;2055
0007f8  e1a00005          MOV      r0,r5                 ;2055
0007fc  e58d600c          STR      r6,[sp,#0xc]          ;2055
000800  e1a01006          MOV      r1,r6                 ;2055
000804  ebfffffe          BL       __aeabi_lasr
000808  e0570000          SUBS     r0,r7,r0              ;2055
00080c  e0c82001          SBC      r2,r8,r1              ;2055
000810  e1a03fcb          ASR      r3,r11,#31            ;2055
000814  e08c1b90          UMULL    r1,r12,r0,r11         ;2055
000818  e022c29b          MLA      r2,r11,r2,r12         ;2055
00081c  e0232390          MLA      r3,r0,r3,r2           ;2055
000820  e5990014          LDR      r0,[r9,#0x14]         ;2055
000824  e599200c          LDR      r2,[r9,#0xc]          ;2055
000828  e0800002          ADD      r0,r0,r2              ;2055
00082c  e0510000          SUBS     r0,r1,r0              ;2055
000830  e2d30000          SBCS     r0,r3,#0              ;2055
000834  2a000003          BCS      |L1.2120|
                  |L1.2104|
000838  e1a00000          MOV      r0,r0                 ;2056
00083c  e1a00000          MOV      r0,r0                 ;2056
000840  e3e00015          MVN      r0,#0x15              ;2058
000844  eaffffd1          B        |L1.1936|
                  |L1.2120|
000848  e5942060          LDR      r2,[r4,#0x60]         ;2061
00084c  e58d5028          STR      r5,[sp,#0x28]         ;2061
000850  e1a00005          MOV      r0,r5                 ;2061
000854  e58d6024          STR      r6,[sp,#0x24]         ;2061
000858  e1a01006          MOV      r1,r6                 ;2061
00085c  ebfffffe          BL       __aeabi_lasr
000860  e58d0008          STR      r0,[sp,#8]            ;2061
000864  e594201c          LDR      r2,[r4,#0x1c]         ;2062
000868  e1a0000a          MOV      r0,r10                ;2062
00086c  e59d1008          LDR      r1,[sp,#8]            ;2062
000870  e12fff32          BLX      r2                    ;2062
000874  e5942054          LDR      r2,[r4,#0x54]         ;2065
000878  e58d5020          STR      r5,[sp,#0x20]         ;2065
00087c  e1a00005          MOV      r0,r5                 ;2065
000880  e58d601c          STR      r6,[sp,#0x1c]         ;2065
000884  e1a01006          MOV      r1,r6                 ;2065
000888  ebfffffe          BL       __aeabi_lasr
00088c  e58d0004          STR      r0,[sp,#4]            ;2065
000890  e3e03000          MVN      r3,#0                 ;2073
000894  e1a02003          MOV      r2,r3                 ;2073
000898  e3a010ff          MOV      r1,#0xff              ;2073
00089c  e1a0000a          MOV      r0,r10                ;2073
0008a0  e594c034          LDR      r12,[r4,#0x34]        ;2073
0008a4  e12fff3c          BLX      r12                   ;2073
0008a8  e1a0000a          MOV      r0,r10                ;2076
0008ac  ebfffffe          BL       nand_check_wp
0008b0  e3500000          CMP      r0,#0                 ;2076
0008b4  0a000001          BEQ      |L1.2240|
0008b8  e3e0001d          MVN      r0,#0x1d              ;2077
0008bc  eaffffb3          B        |L1.1936|
                  |L1.2240|
0008c0  e5941074          LDR      r1,[r4,#0x74]         ;2080
0008c4  e59d0004          LDR      r0,[sp,#4]            ;2080
0008c8  e1510000          CMP      r1,r0                 ;2080
0008cc  1a000001          BNE      |L1.2264|
0008d0  e3e00000          MVN      r0,#0                 ;2081
0008d4  e5840074          STR      r0,[r4,#0x74]         ;2081
                  |L1.2264|
0008d8  e59a1018          LDR      r1,[r10,#0x18]        ;2083
0008dc  e3a020ff          MOV      r2,#0xff              ;2083
0008e0  e5940090          LDR      r0,[r4,#0x90]         ;2083
0008e4  ebfffffe          BL       __aeabi_memset
0008e8  e599101c          LDR      r1,[r9,#0x1c]         ;2084
0008ec  e599200c          LDR      r2,[r9,#0xc]          ;2084
0008f0  e1a03009          MOV      r3,r9                 ;2084
0008f4  e1a00004          MOV      r0,r4                 ;2084
0008f8  ebfffffe          BL       nand_fill_oob
0008fc  e5941070          LDR      r1,[r4,#0x70]         ;2085
000900  e59d0004          LDR      r0,[sp,#4]            ;2085
000904  e0012000          AND      r2,r1,r0              ;2085
000908  e59430e4          LDR      r3,[r4,#0xe4]         ;2085
00090c  e1a01004          MOV      r1,r4                 ;2085
000910  e1a0000a          MOV      r0,r10                ;2085
000914  e12fff33          BLX      r3                    ;2085
000918  e58d0000          STR      r0,[sp,#0]            ;2085
00091c  e59a1018          LDR      r1,[r10,#0x18]        ;2086
000920  e3a020ff          MOV      r2,#0xff              ;2086
000924  e5940090          LDR      r0,[r4,#0x90]         ;2086
000928  ebfffffe          BL       __aeabi_memset
00092c  e59d0000          LDR      r0,[sp,#0]            ;2088
000930  e3500000          CMP      r0,#0                 ;2088
000934  0a000001          BEQ      |L1.2368|
000938  e59d0000          LDR      r0,[sp,#0]            ;2089
00093c  eaffff93          B        |L1.1936|
                  |L1.2368|
000940  e599000c          LDR      r0,[r9,#0xc]          ;2091
000944  e5890010          STR      r0,[r9,#0x10]         ;2091
000948  e3a00000          MOV      r0,#0                 ;2093
00094c  eaffff8f          B        |L1.1936|
;;;2095   
                          ENDP

                  nand_default_block_markbad PROC
;;;366    */
;;;367    static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
000950  e92d4ffe          PUSH     {r1-r11,lr}
;;;368    {
000954  e1a05000          MOV      r5,r0
000958  e1a06002          MOV      r6,r2
00095c  e1a07003          MOV      r7,r3
;;;369    	struct nand_chip *chip = mtd->priv;
000960  e5954094          LDR      r4,[r5,#0x94]
;;;370    	uint8_t buf[2] = { 0, 0 };
000964  e3a00000          MOV      r0,#0
000968  e58d0008          STR      r0,[sp,#8]
;;;371    	int block, ret, i = 0;
00096c  e58d0004          STR      r0,[sp,#4]
;;;372    
;;;373    	if (chip->options & NAND_BBT_SCANLASTPAGE)
000970  e1d405b0          LDRH     r0,[r4,#0x50]
000974  e3100902          TST      r0,#0x8000
000978  0a000003          BEQ      |L1.2444|
;;;374    		ofs += mtd->erasesize - mtd->writesize;
00097c  e1c501d0          LDRD     r0,r1,[r5,#0x10]
000980  e0400001          SUB      r0,r0,r1
000984  e0966000          ADDS     r6,r6,r0
000988  e2a77000          ADC      r7,r7,#0
                  |L1.2444|
;;;375    
;;;376    	/* Get block number */
;;;377    	block = (int)(ofs >> chip->bbt_erase_shift);
00098c  e1a0a006          MOV      r10,r6
000990  e1a0b007          MOV      r11,r7
000994  e1a0000a          MOV      r0,r10
000998  e1a0100b          MOV      r1,r11
00099c  e594205c          LDR      r2,[r4,#0x5c]
0009a0  ebfffffe          BL       __aeabi_lasr
0009a4  e1a08000          MOV      r8,r0
;;;378    	if (chip->bbt)
0009a8  e5940110          LDR      r0,[r4,#0x110]
0009ac  e3500000          CMP      r0,#0
0009b0  0a000007          BEQ      |L1.2516|
;;;379    		chip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
0009b4  e5940110          LDR      r0,[r4,#0x110]
0009b8  e7d00148          LDRB     r0,[r0,r8,ASR #2]
0009bc  e1a01f08          LSL      r1,r8,#30
0009c0  e1a01ea1          LSR      r1,r1,#29
0009c4  e3a02001          MOV      r2,#1
0009c8  e1800112          ORR      r0,r0,r2,LSL r1
0009cc  e5941110          LDR      r1,[r4,#0x110]
0009d0  e7c10148          STRB     r0,[r1,r8,ASR #2]
                  |L1.2516|
;;;380    
;;;381    	/* Do we have a flash based bad block table ? */
;;;382    	if (chip->options & NAND_USE_FLASH_BBT)
0009d4  e5940050          LDR      r0,[r4,#0x50]
0009d8  e3100801          TST      r0,#0x10000
0009dc  0a000005          BEQ      |L1.2552|
;;;383    		ret = nand_update_bbt(mtd, ofs);
0009e0  e1a02006          MOV      r2,r6
0009e4  e1a03007          MOV      r3,r7
0009e8  e1a00005          MOV      r0,r5
0009ec  ebfffffe          BL       nand_update_bbt
0009f0  e1a09000          MOV      r9,r0
0009f4  ea000033          B        |L1.2760|
                  |L1.2552|
;;;384    	else {
;;;385    		nand_get_device(chip, mtd, FL_WRITING);
0009f8  e3a02002          MOV      r2,#2
0009fc  e1a01005          MOV      r1,r5
000a00  e1a00004          MOV      r0,r4
000a04  ebfffffe          BL       nand_get_device
;;;386    
;;;387    		/* Write to first two pages and to byte 1 and 6 if necessary.
;;;388    		 * If we write to more than one location, the first error
;;;389    		 * encountered quits the procedure. We write two bytes per
;;;390    		 * location, so we dont have to mess with 16 bit access.
;;;391    		 */
;;;392    		do {
000a08  e1a00000          MOV      r0,r0
                  |L1.2572|
;;;393    			chip->ops.len = chip->ops.ooblen = 2;
000a0c  e3a00002          MOV      r0,#2
000a10  e58400fc          STR      r0,[r4,#0xfc]
000a14  e58400f4          STR      r0,[r4,#0xf4]
;;;394    			chip->ops.datbuf = NULL;
000a18  e3a00000          MOV      r0,#0
000a1c  e5840108          STR      r0,[r4,#0x108]
;;;395    			chip->ops.oobbuf = buf;
000a20  e28d0008          ADD      r0,sp,#8
000a24  e584010c          STR      r0,[r4,#0x10c]
;;;396    			chip->ops.ooboffs = chip->badblockpos & ~0x01;
000a28  e5940080          LDR      r0,[r4,#0x80]
000a2c  e3c00001          BIC      r0,r0,#1
000a30  e5840104          STR      r0,[r4,#0x104]
;;;397    
;;;398    			ret = nand_do_write_oob(mtd, ofs, &chip->ops);
000a34  e28400f0          ADD      r0,r4,#0xf0
000a38  e1a02006          MOV      r2,r6
000a3c  e1a03007          MOV      r3,r7
000a40  e58d0000          STR      r0,[sp,#0]
000a44  e1a00005          MOV      r0,r5
000a48  ebfffffe          BL       nand_do_write_oob
000a4c  e1a09000          MOV      r9,r0
;;;399    
;;;400    			if (!ret && (chip->options & NAND_BBT_SCANBYTE1AND6)) {
000a50  e3590000          CMP      r9,#0
000a54  1a00000b          BNE      |L1.2696|
000a58  e5940050          LDR      r0,[r4,#0x50]
000a5c  e3100601          TST      r0,#0x100000
000a60  0a000008          BEQ      |L1.2696|
;;;401    				chip->ops.ooboffs = NAND_SMALL_BADBLOCK_POS
000a64  e3a00004          MOV      r0,#4
000a68  e5840104          STR      r0,[r4,#0x104]
;;;402    					& ~0x01;
;;;403    				ret = nand_do_write_oob(mtd, ofs, &chip->ops);
000a6c  e28400f0          ADD      r0,r4,#0xf0
000a70  e1a02006          MOV      r2,r6
000a74  e1a03007          MOV      r3,r7
000a78  e58d0000          STR      r0,[sp,#0]
000a7c  e1a00005          MOV      r0,r5
000a80  ebfffffe          BL       nand_do_write_oob
000a84  e1a09000          MOV      r9,r0
                  |L1.2696|
;;;404    			}
;;;405    			i++;
000a88  e59d0004          LDR      r0,[sp,#4]
000a8c  e2800001          ADD      r0,r0,#1
000a90  e58d0004          STR      r0,[sp,#4]
;;;406    			ofs += mtd->writesize;
000a94  e5950014          LDR      r0,[r5,#0x14]
000a98  e0966000          ADDS     r6,r6,r0
000a9c  e2a77000          ADC      r7,r7,#0
;;;407    		} while (!ret && (chip->options & NAND_BBT_SCAN2NDPAGE) &&
000aa0  e3590000          CMP      r9,#0
000aa4  1a000005          BNE      |L1.2752|
000aa8  e1d405b0          LDRH     r0,[r4,#0x50]
000aac  e3100901          TST      r0,#0x4000
000ab0  0a000002          BEQ      |L1.2752|
;;;408    				i < 2);
000ab4  e59d0004          LDR      r0,[sp,#4]
000ab8  e3500002          CMP      r0,#2
000abc  baffffd2          BLT      |L1.2572|
                  |L1.2752|
;;;409    
;;;410    		nand_release_device(mtd);
000ac0  e1a00005          MOV      r0,r5
000ac4  ebfffffe          BL       nand_release_device
                  |L1.2760|
;;;411    	}
;;;412    	if (!ret)
000ac8  e3590000          CMP      r9,#0
000acc  1a000002          BNE      |L1.2780|
;;;413    		mtd->ecc_stats.badblocks++;
000ad0  e5950088          LDR      r0,[r5,#0x88]
000ad4  e2800001          ADD      r0,r0,#1
000ad8  e5850088          STR      r0,[r5,#0x88]
                  |L1.2780|
;;;414    
;;;415    	return ret;
000adc  e1a00009          MOV      r0,r9
;;;416    }
000ae0  e8bd8ffe          POP      {r1-r11,pc}
;;;417    
                          ENDP

                  nand_block_checkbad PROC
;;;447     */
;;;448    static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
000ae4  e92d43f8          PUSH     {r3-r9,lr}
;;;449    			       int allowbbt)
;;;450    {
000ae8  e1a07000          MOV      r7,r0
000aec  e1a05002          MOV      r5,r2
000af0  e1a06003          MOV      r6,r3
000af4  e1cd82d0          LDRD     r8,r9,[sp,#0x20]
;;;451    	struct nand_chip *chip = mtd->priv;
000af8  e5974094          LDR      r4,[r7,#0x94]
;;;452    
;;;453    	if (!(chip->options & NAND_BBT_SCANNED)) {
000afc  e5940050          LDR      r0,[r4,#0x50]
000b00  e3100101          TST      r0,#0x40000000
000b04  1a000005          BNE      |L1.2848|
;;;454    		chip->options |= NAND_BBT_SCANNED;
000b08  e5940050          LDR      r0,[r4,#0x50]
000b0c  e3800101          ORR      r0,r0,#0x40000000
000b10  e5840050          STR      r0,[r4,#0x50]
;;;455    		chip->scan_bbt(mtd);
000b14  e1a00007          MOV      r0,r7
000b18  e5941040          LDR      r1,[r4,#0x40]
000b1c  e12fff31          BLX      r1
                  |L1.2848|
;;;456    	}
;;;457    
;;;458    	if (!chip->bbt)
000b20  e5940110          LDR      r0,[r4,#0x110]
000b24  e3500000          CMP      r0,#0
000b28  1a000006          BNE      |L1.2888|
;;;459    		return chip->block_bad(mtd, ofs, getchip);
000b2c  e58d8000          STR      r8,[sp,#0]
000b30  e1a02005          MOV      r2,r5
000b34  e1a03006          MOV      r3,r6
000b38  e1a00007          MOV      r0,r7
000b3c  e5941020          LDR      r1,[r4,#0x20]
000b40  e12fff31          BLX      r1
                  |L1.2884|
;;;460    
;;;461    	/* Return info from the table */
;;;462    	return nand_isbad_bbt(mtd, ofs, allowbbt);
;;;463    }
000b44  e8bd83f8          POP      {r3-r9,pc}
                  |L1.2888|
000b48  e1a02005          MOV      r2,r5                 ;462
000b4c  e1a03006          MOV      r3,r6                 ;462
000b50  e1a00007          MOV      r0,r7                 ;462
000b54  e58d9000          STR      r9,[sp,#0]            ;462
000b58  ebfffffe          BL       nand_isbad_bbt
000b5c  eafffff8          B        |L1.2884|
;;;464    
                          ENDP

                  nand_wait_ready PROC
;;;468     */
;;;469    void nand_wait_ready(struct mtd_info *mtd)
000b60  e92d41f0          PUSH     {r4-r8,lr}
;;;470    {
000b64  e1a04000          MOV      r4,r0
;;;471    	struct nand_chip *chip = mtd->priv;
000b68  e5945094          LDR      r5,[r4,#0x94]
;;;472    	u32 timeo = (CONFIG_SYS_HZ * 20) / 1000;
000b6c  e3a06014          MOV      r6,#0x14
;;;473    	u32 time_start;
;;;474    
;;;475    	time_start = get_timer(0);
000b70  e3a00000          MOV      r0,#0
000b74  ebfffffe          BL       get_timer
000b78  e1a07000          MOV      r7,r0
;;;476    
;;;477    	/* wait until command is processed or timeout occures */
;;;478    	while (get_timer(time_start) < timeo) {
000b7c  ea000008          B        |L1.2980|
                  |L1.2944|
;;;479    		if (chip->dev_ready)
000b80  e5950030          LDR      r0,[r5,#0x30]
000b84  e3500000          CMP      r0,#0
000b88  0a000005          BEQ      |L1.2980|
;;;480    			if (chip->dev_ready(mtd))
000b8c  e1a00004          MOV      r0,r4
000b90  e5951030          LDR      r1,[r5,#0x30]
000b94  e12fff31          BLX      r1
000b98  e3500000          CMP      r0,#0
000b9c  0a000000          BEQ      |L1.2980|
;;;481    				break;
000ba0  ea000003          B        |L1.2996|
                  |L1.2980|
000ba4  e1a00007          MOV      r0,r7                 ;478
000ba8  ebfffffe          BL       get_timer
000bac  e1500006          CMP      r0,r6                 ;478
000bb0  3afffff2          BCC      |L1.2944|
                  |L1.2996|
000bb4  e1a00000          MOV      r0,r0
;;;482    	}
;;;483    }
000bb8  e8bd81f0          POP      {r4-r8,pc}
;;;484    
                          ENDP

                  nand_command PROC
;;;494     */
;;;495    static void nand_command(struct mtd_info *mtd, unsigned int command,
000bbc  e92d5ff0          PUSH     {r4-r12,lr}
;;;496    			 int column, int page_addr)
;;;497    {
000bc0  e1a07000          MOV      r7,r0
000bc4  e1a0a001          MOV      r10,r1
000bc8  e1a05002          MOV      r5,r2
000bcc  e1a06003          MOV      r6,r3
;;;498    	register struct nand_chip *chip = mtd->priv;
000bd0  e5974094          LDR      r4,[r7,#0x94]
;;;499    	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
000bd4  e3a08083          MOV      r8,#0x83
;;;500    	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
000bd8  e59fb858          LDR      r11,|L1.5176|
;;;501    
;;;502    	/*
;;;503    	 * Write out the command to the device.
;;;504    	 */
;;;505    	if (command == NAND_CMD_SEQIN) {
000bdc  e35a0080          CMP      r10,#0x80
000be0  1a000013          BNE      |L1.3124|
;;;506    		int readcmd;
;;;507    
;;;508    		if (column >= mtd->writesize) {
000be4  e5970014          LDR      r0,[r7,#0x14]
000be8  e1500005          CMP      r0,r5
000bec  8a000003          BHI      |L1.3072|
;;;509    			/* OOB area */
;;;510    			column -= mtd->writesize;
000bf0  e5970014          LDR      r0,[r7,#0x14]
000bf4  e0455000          SUB      r5,r5,r0
;;;511    			readcmd = NAND_CMD_READOOB;
000bf8  e3a09050          MOV      r9,#0x50
000bfc  ea000005          B        |L1.3096|
                  |L1.3072|
;;;512    		} else if (column < 256) {
000c00  e3550c01          CMP      r5,#0x100
000c04  aa000001          BGE      |L1.3088|
;;;513    			/* First 256 bytes --> READ0 */
;;;514    			readcmd = NAND_CMD_READ0;
000c08  e3a09000          MOV      r9,#0
000c0c  ea000001          B        |L1.3096|
                  |L1.3088|
;;;515    		} else {
;;;516    			column -= 256;
000c10  e2455c01          SUB      r5,r5,#0x100
;;;517    			readcmd = NAND_CMD_READ1;
000c14  e3a09001          MOV      r9,#1
                  |L1.3096|
;;;518    		}
;;;519    		chip->cmd_ctrl(mtd, readcmd, ctrl);
000c18  e1a02008          MOV      r2,r8
000c1c  e1a01009          MOV      r1,r9
000c20  e1a00007          MOV      r0,r7
000c24  e5943028          LDR      r3,[r4,#0x28]
000c28  e12fff33          BLX      r3
;;;520    		ctrl &= ~NAND_CTRL_CHANGE;
000c2c  e3c88080          BIC      r8,r8,#0x80
;;;521    	}
000c30  e1a00000          MOV      r0,r0
                  |L1.3124|
;;;522    	chip->cmd_ctrl(mtd, command, ctrl);
000c34  e1a02008          MOV      r2,r8
000c38  e1a0100a          MOV      r1,r10
000c3c  e1a00007          MOV      r0,r7
000c40  e5943028          LDR      r3,[r4,#0x28]
000c44  e12fff33          BLX      r3
;;;523    
;;;524    	/*
;;;525    	 * Address cycle, when necessary
;;;526    	 */
;;;527    	ctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;
000c48  e3a08085          MOV      r8,#0x85
;;;528    	/* Serially input address */
;;;529    	if (column != -1) {
000c4c  e3750001          CMN      r5,#1
000c50  0a000009          BEQ      |L1.3196|
;;;530    		/* Adjust columns for 16 bit buswidth */
;;;531    		if (chip->options & NAND_BUSWIDTH_16)
000c54  e5d40050          LDRB     r0,[r4,#0x50]
000c58  e3100002          TST      r0,#2
000c5c  0a000000          BEQ      |L1.3172|
;;;532    			column >>= 1;
000c60  e1a050c5          ASR      r5,r5,#1
                  |L1.3172|
;;;533    		chip->cmd_ctrl(mtd, column, ctrl);
000c64  e1a02008          MOV      r2,r8
000c68  e1a01005          MOV      r1,r5
000c6c  e1a00007          MOV      r0,r7
000c70  e5943028          LDR      r3,[r4,#0x28]
000c74  e12fff33          BLX      r3
;;;534    		ctrl &= ~NAND_CTRL_CHANGE;
000c78  e3c88080          BIC      r8,r8,#0x80
                  |L1.3196|
;;;535    	}
;;;536    	if (page_addr != -1) {
000c7c  e3760001          CMN      r6,#1
000c80  0a000014          BEQ      |L1.3288|
;;;537    		chip->cmd_ctrl(mtd, page_addr, ctrl);
000c84  e1a02008          MOV      r2,r8
000c88  e1a01006          MOV      r1,r6
000c8c  e1a00007          MOV      r0,r7
000c90  e5943028          LDR      r3,[r4,#0x28]
000c94  e12fff33          BLX      r3
;;;538    		ctrl &= ~NAND_CTRL_CHANGE;
000c98  e3c88080          BIC      r8,r8,#0x80
;;;539    		chip->cmd_ctrl(mtd, page_addr >> 8, ctrl);
000c9c  e1a01446          ASR      r1,r6,#8
000ca0  e1a02008          MOV      r2,r8
000ca4  e1a00007          MOV      r0,r7
000ca8  e5943028          LDR      r3,[r4,#0x28]
000cac  e12fff33          BLX      r3
;;;540    		/* One more address cycle for devices > 32MiB */
;;;541    		if (chip->chipsize > (32 << 20))
000cb0  e5941068          LDR      r1,[r4,#0x68]
000cb4  e594206c          LDR      r2,[r4,#0x6c]
000cb8  e2710402          RSBS     r0,r1,#0x2000000
000cbc  e2f20000          RSCS     r0,r2,#0
000cc0  2a000004          BCS      |L1.3288|
;;;542    			chip->cmd_ctrl(mtd, page_addr >> 16, ctrl);
000cc4  e1a01846          ASR      r1,r6,#16
000cc8  e1a02008          MOV      r2,r8
000ccc  e1a00007          MOV      r0,r7
000cd0  e5943028          LDR      r3,[r4,#0x28]
000cd4  e12fff33          BLX      r3
                  |L1.3288|
;;;543    	}
;;;544    	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
000cd8  e3a02081          MOV      r2,#0x81
000cdc  e3e01000          MVN      r1,#0
000ce0  e1a00007          MOV      r0,r7
000ce4  e5943028          LDR      r3,[r4,#0x28]
000ce8  e12fff33          BLX      r3
;;;545    
;;;546    	/*
;;;547    	 * program and erase have their own busy handlers
;;;548    	 * status and sequential in needs no delay
;;;549    	 */
;;;550    	switch (command) {
000cec  e35a0080          CMP      r10,#0x80
000cf0  0a000010          BEQ      |L1.3384|
000cf4  ca000006          BGT      |L1.3348|
000cf8  e35a0010          CMP      r10,#0x10
000cfc  0a000009          BEQ      |L1.3368|
000d00  e35a0060          CMP      r10,#0x60
000d04  0a000009          BEQ      |L1.3376|
000d08  e35a0070          CMP      r10,#0x70
000d0c  1a000026          BNE      |L1.3500|
000d10  ea000009          B        |L1.3388|
                  |L1.3348|
000d14  e35a00d0          CMP      r10,#0xd0
000d18  0a000005          BEQ      |L1.3380|
000d1c  e35a00ff          CMP      r10,#0xff
000d20  1a000021          BNE      |L1.3500|
000d24  ea000005          B        |L1.3392|
                  |L1.3368|
;;;551    
;;;552    	case NAND_CMD_PAGEPROG:
000d28  e1a00000          MOV      r0,r0
;;;553    	case NAND_CMD_ERASE1:
000d2c  e1a00000          MOV      r0,r0
                  |L1.3376|
;;;554    	case NAND_CMD_ERASE2:
000d30  e1a00000          MOV      r0,r0
                  |L1.3380|
;;;555    	case NAND_CMD_SEQIN:
000d34  e1a00000          MOV      r0,r0
                  |L1.3384|
;;;556    	case NAND_CMD_STATUS:
000d38  e1a00000          MOV      r0,r0
                  |L1.3388|
;;;557    		return;
;;;558    
;;;559    	case NAND_CMD_RESET:
;;;560    		if (chip->dev_ready)
;;;561    			break;
;;;562    		udelay(chip->chip_delay);
;;;563    		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
;;;564    			       NAND_CTRL_CLE | NAND_CTRL_CHANGE);
;;;565    		chip->cmd_ctrl(mtd,
;;;566    			       NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
;;;567    		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
;;;568    			(rst_sts_cnt--));
;;;569    		return;
;;;570    
;;;571    		/* This applies to read commands */
;;;572    	default:
;;;573    		/*
;;;574    		 * If we don't have access to the busy pin, we apply the given
;;;575    		 * command delay
;;;576    		 */
;;;577    		if (!chip->dev_ready) {
;;;578    			udelay(chip->chip_delay);
;;;579    			return;
;;;580    		}
;;;581    	}
;;;582    	/* Apply this short delay always to ensure that we do wait tWB in
;;;583    	 * any case on any machine. */
;;;584    	ndelay(100);
;;;585    
;;;586    	nand_wait_ready(mtd);
;;;587    }
000d3c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.3392|
000d40  e1a00000          MOV      r0,r0                 ;559
000d44  e5940030          LDR      r0,[r4,#0x30]         ;560
000d48  e3500000          CMP      r0,#0                 ;560
000d4c  0a000000          BEQ      |L1.3412|
000d50  ea00001d          B        |L1.3532|
                  |L1.3412|
000d54  e594004c          LDR      r0,[r4,#0x4c]         ;562
000d58  ebfffffe          BL       udelay
000d5c  e3a02083          MOV      r2,#0x83              ;563
000d60  e3a01070          MOV      r1,#0x70              ;563
000d64  e1a00007          MOV      r0,r7                 ;563
000d68  e5943028          LDR      r3,[r4,#0x28]         ;563
000d6c  e12fff33          BLX      r3                    ;563
000d70  e3a02081          MOV      r2,#0x81              ;565
000d74  e3e01000          MVN      r1,#0                 ;565
000d78  e1a00007          MOV      r0,r7                 ;565
000d7c  e5943028          LDR      r3,[r4,#0x28]         ;565
000d80  e12fff33          BLX      r3                    ;565
000d84  e1a00000          MOV      r0,r0                 ;567
                  |L1.3464|
000d88  e1a00007          MOV      r0,r7                 ;567
000d8c  e5941008          LDR      r1,[r4,#8]            ;567
000d90  e12fff31          BLX      r1                    ;567
000d94  e3100040          TST      r0,#0x40              ;567
000d98  1a000002          BNE      |L1.3496|
000d9c  e1b0000b          MOVS     r0,r11                ;568
000da0  e24bb001          SUB      r11,r11,#1            ;568
000da4  1afffff7          BNE      |L1.3464|
                  |L1.3496|
000da8  eaffffe3          B        |L1.3388|
                  |L1.3500|
000dac  e1a00000          MOV      r0,r0                 ;572
000db0  e5940030          LDR      r0,[r4,#0x30]         ;577
000db4  e3500000          CMP      r0,#0                 ;577
000db8  1a000002          BNE      |L1.3528|
000dbc  e594004c          LDR      r0,[r4,#0x4c]         ;578
000dc0  ebfffffe          BL       udelay
000dc4  eaffffdc          B        |L1.3388|
                  |L1.3528|
000dc8  e1a00000          MOV      r0,r0                 ;550
                  |L1.3532|
000dcc  e1a00000          MOV      r0,r0                 ;561
000dd0  e3a00001          MOV      r0,#1                 ;584
000dd4  ebfffffe          BL       udelay
000dd8  e1a00007          MOV      r0,r7                 ;586
000ddc  ebfffffe          BL       nand_wait_ready
000de0  e1a00000          MOV      r0,r0
000de4  eaffffd4          B        |L1.3388|
;;;588    
                          ENDP

                  nand_command_lp PROC
;;;599     */
;;;600    static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
000de8  e92d47f0          PUSH     {r4-r10,lr}
;;;601    			    int column, int page_addr)
;;;602    {
000dec  e1a08000          MOV      r8,r0
000df0  e1a07001          MOV      r7,r1
000df4  e1a05002          MOV      r5,r2
000df8  e1a06003          MOV      r6,r3
;;;603    	register struct nand_chip *chip = mtd->priv;
000dfc  e5984094          LDR      r4,[r8,#0x94]
;;;604    	uint32_t rst_sts_cnt = CONFIG_SYS_NAND_RESET_CNT;
000e00  e59fa630          LDR      r10,|L1.5176|
;;;605    
;;;606    	/* Emulate NAND_CMD_READOOB */
;;;607    	if (command == NAND_CMD_READOOB) {
000e04  e3570050          CMP      r7,#0x50
000e08  1a000002          BNE      |L1.3608|
;;;608    		column += mtd->writesize;
000e0c  e5980014          LDR      r0,[r8,#0x14]
000e10  e0855000          ADD      r5,r5,r0
;;;609    		command = NAND_CMD_READ0;
000e14  e3a07000          MOV      r7,#0
                  |L1.3608|
;;;610    	}
;;;611    
;;;612    	/* Command latch cycle */
;;;613    	chip->cmd_ctrl(mtd, command & 0xff,
000e18  e20710ff          AND      r1,r7,#0xff
000e1c  e3a02083          MOV      r2,#0x83
000e20  e1a00008          MOV      r0,r8
000e24  e5943028          LDR      r3,[r4,#0x28]
000e28  e12fff33          BLX      r3
;;;614    		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
;;;615    
;;;616    	if (column != -1 || page_addr != -1) {
000e2c  e3750001          CMN      r5,#1
000e30  1a000001          BNE      |L1.3644|
000e34  e3760001          CMN      r6,#1
000e38  0a000028          BEQ      |L1.3808|
                  |L1.3644|
;;;617    		int ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;
000e3c  e3a09085          MOV      r9,#0x85
;;;618    
;;;619    		/* Serially input address */
;;;620    		if (column != -1) {
000e40  e3750001          CMN      r5,#1
000e44  0a00000e          BEQ      |L1.3716|
;;;621    			/* Adjust columns for 16 bit buswidth */
;;;622    			if (chip->options & NAND_BUSWIDTH_16)
000e48  e5d40050          LDRB     r0,[r4,#0x50]
000e4c  e3100002          TST      r0,#2
000e50  0a000000          BEQ      |L1.3672|
;;;623    				column >>= 1;
000e54  e1a050c5          ASR      r5,r5,#1
                  |L1.3672|
;;;624    			chip->cmd_ctrl(mtd, column, ctrl);
000e58  e1a02009          MOV      r2,r9
000e5c  e1a01005          MOV      r1,r5
000e60  e1a00008          MOV      r0,r8
000e64  e5943028          LDR      r3,[r4,#0x28]
000e68  e12fff33          BLX      r3
;;;625    			ctrl &= ~NAND_CTRL_CHANGE;
000e6c  e3c99080          BIC      r9,r9,#0x80
;;;626    			chip->cmd_ctrl(mtd, column >> 8, ctrl);
000e70  e1a01445          ASR      r1,r5,#8
000e74  e1a02009          MOV      r2,r9
000e78  e1a00008          MOV      r0,r8
000e7c  e5943028          LDR      r3,[r4,#0x28]
000e80  e12fff33          BLX      r3
                  |L1.3716|
;;;627    		}
;;;628    		if (page_addr != -1) {
000e84  e3760001          CMN      r6,#1
000e88  0a000013          BEQ      |L1.3804|
;;;629    			chip->cmd_ctrl(mtd, page_addr, ctrl);
000e8c  e1a02009          MOV      r2,r9
000e90  e1a01006          MOV      r1,r6
000e94  e1a00008          MOV      r0,r8
000e98  e5943028          LDR      r3,[r4,#0x28]
000e9c  e12fff33          BLX      r3
;;;630    			chip->cmd_ctrl(mtd, page_addr >> 8,
000ea0  e1a01446          ASR      r1,r6,#8
000ea4  e3a02005          MOV      r2,#5
000ea8  e1a00008          MOV      r0,r8
000eac  e5943028          LDR      r3,[r4,#0x28]
000eb0  e12fff33          BLX      r3
;;;631    				       NAND_NCE | NAND_ALE);
;;;632    			/* One more address cycle for devices > 128MiB */
;;;633    			if (chip->chipsize > (128 << 20))
000eb4  e5941068          LDR      r1,[r4,#0x68]
000eb8  e594206c          LDR      r2,[r4,#0x6c]
000ebc  e2710302          RSBS     r0,r1,#0x8000000
000ec0  e2f20000          RSCS     r0,r2,#0
000ec4  2a000004          BCS      |L1.3804|
;;;634    				chip->cmd_ctrl(mtd, page_addr >> 16,
000ec8  e1a01846          ASR      r1,r6,#16
000ecc  e3a02005          MOV      r2,#5
000ed0  e1a00008          MOV      r0,r8
000ed4  e5943028          LDR      r3,[r4,#0x28]
000ed8  e12fff33          BLX      r3
                  |L1.3804|
;;;635    					       NAND_NCE | NAND_ALE);
;;;636    		}
;;;637    	}
000edc  e1a00000          MOV      r0,r0
                  |L1.3808|
;;;638    	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
000ee0  e3a02081          MOV      r2,#0x81
000ee4  e3e01000          MVN      r1,#0
000ee8  e1a00008          MOV      r0,r8
000eec  e5943028          LDR      r3,[r4,#0x28]
000ef0  e12fff33          BLX      r3
;;;639    
;;;640    	/*
;;;641    	 * program and erase have their own busy handlers
;;;642    	 * status, sequential in, and deplete1 need no delay
;;;643    	 */
;;;644    	switch (command) {
000ef4  e3570074          CMP      r7,#0x74
000ef8  0a000030          BEQ      |L1.4032|
000efc  ca000012          BGT      |L1.3916|
000f00  e3570060          CMP      r7,#0x60
000f04  0a000024          BEQ      |L1.3996|
000f08  ca000008          BGT      |L1.3888|
000f0c  e3570000          CMP      r7,#0
000f10  0a000056          BEQ      |L1.4208|
000f14  e3570005          CMP      r7,#5
000f18  0a000048          BEQ      |L1.4160|
000f1c  e3570010          CMP      r7,#0x10
000f20  0a00001c          BEQ      |L1.3992|
000f24  e3570015          CMP      r7,#0x15
000f28  1a00005c          BNE      |L1.4256|
000f2c  ea000017          B        |L1.3984|
                  |L1.3888|
000f30  e3570070          CMP      r7,#0x70
000f34  0a00001c          BEQ      |L1.4012|
000f38  e3570072          CMP      r7,#0x72
000f3c  0a00001c          BEQ      |L1.4020|
000f40  e3570073          CMP      r7,#0x73
000f44  1a000055          BNE      |L1.4256|
000f48  ea00001b          B        |L1.4028|
                  |L1.3916|
000f4c  e3570085          CMP      r7,#0x85
000f50  0a000014          BEQ      |L1.4008|
000f54  ca000006          BGT      |L1.3956|
000f58  e3570075          CMP      r7,#0x75
000f5c  0a000018          BEQ      |L1.4036|
000f60  e3570076          CMP      r7,#0x76
000f64  0a000017          BEQ      |L1.4040|
000f68  e3570080          CMP      r7,#0x80
000f6c  1a00004b          BNE      |L1.4256|
000f70  ea00000b          B        |L1.4004|
                  |L1.3956|
000f74  e35700d0          CMP      r7,#0xd0
000f78  0a000008          BEQ      |L1.4000|
000f7c  e35700ff          CMP      r7,#0xff
000f80  0a000013          BEQ      |L1.4052|
000f84  e3570c01          CMP      r7,#0x100
000f88  1a000044          BNE      |L1.4256|
000f8c  ea000007          B        |L1.4016|
                  |L1.3984|
;;;645    
;;;646    	case NAND_CMD_CACHEDPROG:
000f90  e1a00000          MOV      r0,r0
;;;647    	case NAND_CMD_PAGEPROG:
000f94  e1a00000          MOV      r0,r0
                  |L1.3992|
;;;648    	case NAND_CMD_ERASE1:
000f98  e1a00000          MOV      r0,r0
                  |L1.3996|
;;;649    	case NAND_CMD_ERASE2:
000f9c  e1a00000          MOV      r0,r0
                  |L1.4000|
;;;650    	case NAND_CMD_SEQIN:
000fa0  e1a00000          MOV      r0,r0
                  |L1.4004|
;;;651    	case NAND_CMD_RNDIN:
000fa4  e1a00000          MOV      r0,r0
                  |L1.4008|
;;;652    	case NAND_CMD_STATUS:
000fa8  e1a00000          MOV      r0,r0
                  |L1.4012|
;;;653    	case NAND_CMD_DEPLETE1:
000fac  e1a00000          MOV      r0,r0
                  |L1.4016|
;;;654    		return;
;;;655    
;;;656    		/*
;;;657    		 * read error status commands require only a short delay
;;;658    		 */
;;;659    	case NAND_CMD_STATUS_ERROR:
;;;660    	case NAND_CMD_STATUS_ERROR0:
;;;661    	case NAND_CMD_STATUS_ERROR1:
;;;662    	case NAND_CMD_STATUS_ERROR2:
;;;663    	case NAND_CMD_STATUS_ERROR3:
;;;664    		udelay(chip->chip_delay);
;;;665    		return;
;;;666    
;;;667    	case NAND_CMD_RESET:
;;;668    		if (chip->dev_ready)
;;;669    			break;
;;;670    		udelay(chip->chip_delay);
;;;671    		chip->cmd_ctrl(mtd, NAND_CMD_STATUS,
;;;672    			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
;;;673    		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
;;;674    			       NAND_NCE | NAND_CTRL_CHANGE);
;;;675    		while (!(chip->read_byte(mtd) & NAND_STATUS_READY) &&
;;;676    			(rst_sts_cnt--));
;;;677    		return;
;;;678    
;;;679    	case NAND_CMD_RNDOUT:
;;;680    		/* No ready / busy check necessary */
;;;681    		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
;;;682    			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
;;;683    		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
;;;684    			       NAND_NCE | NAND_CTRL_CHANGE);
;;;685    		return;
;;;686    
;;;687    	case NAND_CMD_READ0:
;;;688    		chip->cmd_ctrl(mtd, NAND_CMD_READSTART,
;;;689    			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
;;;690    		chip->cmd_ctrl(mtd, NAND_CMD_NONE,
;;;691    			       NAND_NCE | NAND_CTRL_CHANGE);
;;;692    
;;;693    		/* This applies to read commands */
;;;694    	default:
;;;695    		/*
;;;696    		 * If we don't have access to the busy pin, we apply the given
;;;697    		 * command delay
;;;698    		 */
;;;699    		if (!chip->dev_ready) {
;;;700    			udelay(chip->chip_delay);
;;;701    			return;
;;;702    		}
;;;703    	}
;;;704    
;;;705    	/* Apply this short delay always to ensure that we do wait tWB in
;;;706    	 * any case on any machine. */
;;;707    	ndelay(100);
;;;708    
;;;709    	nand_wait_ready(mtd);
;;;710    }
000fb0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.4020|
000fb4  e1a00000          MOV      r0,r0                 ;659
000fb8  e1a00000          MOV      r0,r0                 ;660
                  |L1.4028|
000fbc  e1a00000          MOV      r0,r0                 ;661
                  |L1.4032|
000fc0  e1a00000          MOV      r0,r0                 ;662
                  |L1.4036|
000fc4  e1a00000          MOV      r0,r0                 ;663
                  |L1.4040|
000fc8  e594004c          LDR      r0,[r4,#0x4c]         ;664
000fcc  ebfffffe          BL       udelay
000fd0  eafffff6          B        |L1.4016|
                  |L1.4052|
000fd4  e1a00000          MOV      r0,r0                 ;667
000fd8  e5940030          LDR      r0,[r4,#0x30]         ;668
000fdc  e3500000          CMP      r0,#0                 ;668
000fe0  0a000000          BEQ      |L1.4072|
000fe4  ea000034          B        |L1.4284|
                  |L1.4072|
000fe8  e594004c          LDR      r0,[r4,#0x4c]         ;670
000fec  ebfffffe          BL       udelay
000ff0  e3a02083          MOV      r2,#0x83              ;671
000ff4  e3a01070          MOV      r1,#0x70              ;671
000ff8  e1a00008          MOV      r0,r8                 ;671
000ffc  e5943028          LDR      r3,[r4,#0x28]         ;671
001000  e12fff33          BLX      r3                    ;671
001004  e3a02081          MOV      r2,#0x81              ;673
001008  e3e01000          MVN      r1,#0                 ;673
00100c  e1a00008          MOV      r0,r8                 ;673
001010  e5943028          LDR      r3,[r4,#0x28]         ;673
001014  e12fff33          BLX      r3                    ;673
001018  e1a00000          MOV      r0,r0                 ;675
                  |L1.4124|
00101c  e1a00008          MOV      r0,r8                 ;675
001020  e5941008          LDR      r1,[r4,#8]            ;675
001024  e12fff31          BLX      r1                    ;675
001028  e3100040          TST      r0,#0x40              ;675
00102c  1a000002          BNE      |L1.4156|
001030  e1b0000a          MOVS     r0,r10                ;676
001034  e24aa001          SUB      r10,r10,#1            ;676
001038  1afffff7          BNE      |L1.4124|
                  |L1.4156|
00103c  eaffffdb          B        |L1.4016|
                  |L1.4160|
001040  e1a00000          MOV      r0,r0                 ;679
001044  e3a02083          MOV      r2,#0x83              ;681
001048  e3a010e0          MOV      r1,#0xe0              ;681
00104c  e1a00008          MOV      r0,r8                 ;681
001050  e5943028          LDR      r3,[r4,#0x28]         ;681
001054  e12fff33          BLX      r3                    ;681
001058  e3a02081          MOV      r2,#0x81              ;683
00105c  e3e01000          MVN      r1,#0                 ;683
001060  e1a00008          MOV      r0,r8                 ;683
001064  e5943028          LDR      r3,[r4,#0x28]         ;683
001068  e12fff33          BLX      r3                    ;683
00106c  eaffffcf          B        |L1.4016|
                  |L1.4208|
001070  e1a00000          MOV      r0,r0                 ;687
001074  e3a02083          MOV      r2,#0x83              ;688
001078  e3a01030          MOV      r1,#0x30              ;688
00107c  e1a00008          MOV      r0,r8                 ;688
001080  e5943028          LDR      r3,[r4,#0x28]         ;688
001084  e12fff33          BLX      r3                    ;688
001088  e3a02081          MOV      r2,#0x81              ;690
00108c  e3e01000          MVN      r1,#0                 ;690
001090  e1a00008          MOV      r0,r8                 ;690
001094  e5943028          LDR      r3,[r4,#0x28]         ;690
001098  e12fff33          BLX      r3                    ;690
00109c  e1a00000          MOV      r0,r0                 ;694
                  |L1.4256|
0010a0  e5940030          LDR      r0,[r4,#0x30]         ;699
0010a4  e3500000          CMP      r0,#0                 ;699
0010a8  1a000002          BNE      |L1.4280|
0010ac  e594004c          LDR      r0,[r4,#0x4c]         ;700
0010b0  ebfffffe          BL       udelay
0010b4  eaffffbd          B        |L1.4016|
                  |L1.4280|
0010b8  e1a00000          MOV      r0,r0                 ;644
                  |L1.4284|
0010bc  e1a00000          MOV      r0,r0                 ;669
0010c0  e3a00001          MOV      r0,#1                 ;707
0010c4  ebfffffe          BL       udelay
0010c8  e1a00008          MOV      r0,r8                 ;709
0010cc  ebfffffe          BL       nand_wait_ready
0010d0  e1a00000          MOV      r0,r0
0010d4  eaffffb5          B        |L1.4016|
;;;711    
                          ENDP

                  nand_wait PROC
;;;735     */
;;;736    static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
0010d8  e92d41f0          PUSH     {r4-r8,lr}
;;;737    {
0010dc  e1a07000          MOV      r7,r0
0010e0  e1a04001          MOV      r4,r1
;;;738    	unsigned long	timeo;
;;;739    	int state = chip->state;
0010e4  e594608c          LDR      r6,[r4,#0x8c]
;;;740    	u32 time_start;
;;;741    
;;;742    	if (state == FL_ERASING)
0010e8  e3560003          CMP      r6,#3
0010ec  1a000001          BNE      |L1.4344|
;;;743    		timeo = (CONFIG_SYS_HZ * 400) / 1000;
0010f0  e3a05e19          MOV      r5,#0x190
0010f4  ea000000          B        |L1.4348|
                  |L1.4344|
;;;744    	else
;;;745    		timeo = (CONFIG_SYS_HZ * 20) / 1000;
0010f8  e3a05014          MOV      r5,#0x14
                  |L1.4348|
;;;746    
;;;747    	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
0010fc  e3560003          CMP      r6,#3
001100  1a000009          BNE      |L1.4396|
001104  e5d40050          LDRB     r0,[r4,#0x50]
001108  e3100020          TST      r0,#0x20
00110c  0a000006          BEQ      |L1.4396|
;;;748    		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
001110  e3e03000          MVN      r3,#0
001114  e1a02003          MOV      r2,r3
001118  e3a01071          MOV      r1,#0x71
00111c  e1a00007          MOV      r0,r7
001120  e594c034          LDR      r12,[r4,#0x34]
001124  e12fff3c          BLX      r12
001128  ea000005          B        |L1.4420|
                  |L1.4396|
;;;749    	else
;;;750    		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
00112c  e3e03000          MVN      r3,#0
001130  e1a02003          MOV      r2,r3
001134  e3a01070          MOV      r1,#0x70
001138  e1a00007          MOV      r0,r7
00113c  e594c034          LDR      r12,[r4,#0x34]
001140  e12fff3c          BLX      r12
                  |L1.4420|
;;;751    
;;;752    	time_start = get_timer(0);
001144  e3a00000          MOV      r0,#0
001148  ebfffffe          BL       get_timer
00114c  e1a08000          MOV      r8,r0
;;;753    
;;;754    	while (1) {
001150  ea000016          B        |L1.4528|
                  |L1.4436|
;;;755    		if (get_timer(time_start) > timeo) {
001154  e1a00008          MOV      r0,r8
001158  ebfffffe          BL       get_timer
00115c  e1500005          CMP      r0,r5
001160  9a000003          BLS      |L1.4468|
;;;756    			sysprintf("Timeout!");
001164  e28f0e2d          ADR      r0,|L1.5180|
001168  ebfffffe          BL       sysprintf
;;;757    			return 0x01;
00116c  e3a00001          MOV      r0,#1
                  |L1.4464|
;;;758    		}
;;;759    
;;;760    		if (chip->dev_ready) {
;;;761    			if (chip->dev_ready(mtd))
;;;762    				break;
;;;763    		} else {
;;;764    			if (chip->read_byte(mtd) & NAND_STATUS_READY)
;;;765    				break;
;;;766    		}
;;;767    	}
;;;768    #ifdef PPCHAMELON_NAND_TIMER_HACK
;;;769    	time_start = get_timer(0);
;;;770    	while (get_timer(time_start) < 10)
;;;771    		;
;;;772    #endif /*  PPCHAMELON_NAND_TIMER_HACK */
;;;773    
;;;774    	return (int)chip->read_byte(mtd);
;;;775    }
001170  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4468|
001174  e5940030          LDR      r0,[r4,#0x30]         ;760
001178  e3500000          CMP      r0,#0                 ;760
00117c  0a000005          BEQ      |L1.4504|
001180  e1a00007          MOV      r0,r7                 ;761
001184  e5941030          LDR      r1,[r4,#0x30]         ;761
001188  e12fff31          BLX      r1                    ;761
00118c  e3500000          CMP      r0,#0                 ;761
001190  0a000006          BEQ      |L1.4528|
001194  ea000006          B        |L1.4532|
                  |L1.4504|
001198  e1a00007          MOV      r0,r7                 ;764
00119c  e5941008          LDR      r1,[r4,#8]            ;764
0011a0  e12fff31          BLX      r1                    ;764
0011a4  e3100040          TST      r0,#0x40              ;764
0011a8  0a000000          BEQ      |L1.4528|
0011ac  ea000000          B        |L1.4532|
                  |L1.4528|
0011b0  eaffffe7          B        |L1.4436|
                  |L1.4532|
0011b4  e1a00000          MOV      r0,r0                 ;762
0011b8  e1a00007          MOV      r0,r7                 ;774
0011bc  e5941008          LDR      r1,[r4,#8]            ;774
0011c0  e12fff31          BLX      r1                    ;774
0011c4  eaffffe9          B        |L1.4464|
;;;776    
                          ENDP

                  nand_read_page_raw PROC
;;;785     */
;;;786    static int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
0011c8  e92d41f0          PUSH     {r4-r8,lr}
;;;787    			      uint8_t *buf, int page)
;;;788    {
0011cc  e1a05000          MOV      r5,r0
0011d0  e1a04001          MOV      r4,r1
0011d4  e1a06002          MOV      r6,r2
0011d8  e1a07003          MOV      r7,r3
;;;789    	chip->read_buf(mtd, buf, mtd->writesize);
0011dc  e5952014          LDR      r2,[r5,#0x14]
0011e0  e1a01006          MOV      r1,r6
0011e4  e1a00005          MOV      r0,r5
0011e8  e5943014          LDR      r3,[r4,#0x14]
0011ec  e12fff33          BLX      r3
;;;790    	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
0011f0  e5952018          LDR      r2,[r5,#0x18]
0011f4  e1a00005          MOV      r0,r5
0011f8  e5941090          LDR      r1,[r4,#0x90]
0011fc  e5943014          LDR      r3,[r4,#0x14]
001200  e12fff33          BLX      r3
;;;791    	return 0;
001204  e3a00000          MOV      r0,#0
;;;792    }
001208  e8bd81f0          POP      {r4-r8,pc}
;;;793    
                          ENDP

                  nand_read_page_raw_syndrome PROC
;;;802     */
;;;803    static int nand_read_page_raw_syndrome(struct mtd_info *mtd,
00120c  e92d5ff0          PUSH     {r4-r12,lr}
;;;804    					struct nand_chip *chip,
;;;805    					uint8_t *buf, int page)
;;;806    {
001210  e1a08000          MOV      r8,r0
001214  e1a04001          MOV      r4,r1
001218  e1a06002          MOV      r6,r2
;;;807    	int eccsize = chip->ecc.size;
00121c  e59490a4          LDR      r9,[r4,#0xa4]
;;;808    	int eccbytes = chip->ecc.bytes;
001220  e594a0a8          LDR      r10,[r4,#0xa8]
;;;809    	uint8_t *oob = chip->oob_poi;
001224  e5945090          LDR      r5,[r4,#0x90]
;;;810    	int steps, size;
;;;811    
;;;812    	for (steps = chip->ecc.steps; steps > 0; steps--) {
001228  e594b0a0          LDR      r11,[r4,#0xa0]
00122c  ea000020          B        |L1.4788|
                  |L1.4656|
;;;813    		chip->read_buf(mtd, buf, eccsize);
001230  e1a02009          MOV      r2,r9
001234  e1a01006          MOV      r1,r6
001238  e1a00008          MOV      r0,r8
00123c  e5943014          LDR      r3,[r4,#0x14]
001240  e12fff33          BLX      r3
;;;814    		buf += eccsize;
001244  e0866009          ADD      r6,r6,r9
;;;815    
;;;816    		if (chip->ecc.prepad) {
001248  e59400b0          LDR      r0,[r4,#0xb0]
00124c  e3500000          CMP      r0,#0
001250  0a000006          BEQ      |L1.4720|
;;;817    			chip->read_buf(mtd, oob, chip->ecc.prepad);
001254  e1a01005          MOV      r1,r5
001258  e1a00008          MOV      r0,r8
00125c  e59420b0          LDR      r2,[r4,#0xb0]
001260  e5943014          LDR      r3,[r4,#0x14]
001264  e12fff33          BLX      r3
;;;818    			oob += chip->ecc.prepad;
001268  e59400b0          LDR      r0,[r4,#0xb0]
00126c  e0855000          ADD      r5,r5,r0
                  |L1.4720|
;;;819    		}
;;;820    
;;;821    		chip->read_buf(mtd, oob, eccbytes);
001270  e1a0200a          MOV      r2,r10
001274  e1a01005          MOV      r1,r5
001278  e1a00008          MOV      r0,r8
00127c  e5943014          LDR      r3,[r4,#0x14]
001280  e12fff33          BLX      r3
;;;822    		oob += eccbytes;
001284  e085500a          ADD      r5,r5,r10
;;;823    
;;;824    		if (chip->ecc.postpad) {
001288  e59400b4          LDR      r0,[r4,#0xb4]
00128c  e3500000          CMP      r0,#0
001290  0a000006          BEQ      |L1.4784|
;;;825    			chip->read_buf(mtd, oob, chip->ecc.postpad);
001294  e1a01005          MOV      r1,r5
001298  e1a00008          MOV      r0,r8
00129c  e59420b4          LDR      r2,[r4,#0xb4]
0012a0  e5943014          LDR      r3,[r4,#0x14]
0012a4  e12fff33          BLX      r3
;;;826    			oob += chip->ecc.postpad;
0012a8  e59400b4          LDR      r0,[r4,#0xb4]
0012ac  e0855000          ADD      r5,r5,r0
                  |L1.4784|
0012b0  e24bb001          SUB      r11,r11,#1            ;812
                  |L1.4788|
0012b4  e35b0000          CMP      r11,#0                ;812
0012b8  caffffdc          BGT      |L1.4656|
;;;827    		}
;;;828    	}
;;;829    
;;;830    	size = mtd->oobsize - (oob - chip->oob_poi);
0012bc  e5980018          LDR      r0,[r8,#0x18]
0012c0  e5941090          LDR      r1,[r4,#0x90]
0012c4  e0451001          SUB      r1,r5,r1
0012c8  e0407001          SUB      r7,r0,r1
;;;831    	if (size)
0012cc  e3570000          CMP      r7,#0
0012d0  0a000004          BEQ      |L1.4840|
;;;832    		chip->read_buf(mtd, oob, size);
0012d4  e1a02007          MOV      r2,r7
0012d8  e1a01005          MOV      r1,r5
0012dc  e1a00008          MOV      r0,r8
0012e0  e5943014          LDR      r3,[r4,#0x14]
0012e4  e12fff33          BLX      r3
                  |L1.4840|
;;;833    
;;;834    	return 0;
0012e8  e3a00000          MOV      r0,#0
;;;835    }
0012ec  e8bd9ff0          POP      {r4-r12,pc}
;;;836    
                          ENDP

                  nand_read_page_swecc PROC
;;;843     */
;;;844    static int nand_read_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
0012f0  e92d4fff          PUSH     {r0-r11,lr}
;;;845    				uint8_t *buf, int page)
;;;846    {
0012f4  e24dd014          SUB      sp,sp,#0x14
0012f8  e1a06000          MOV      r6,r0
0012fc  e1a04001          MOV      r4,r1
001300  e1a08002          MOV      r8,r2
;;;847    	int i, eccsize = chip->ecc.size;
001304  e594a0a4          LDR      r10,[r4,#0xa4]
;;;848    	int eccbytes = chip->ecc.bytes;
001308  e59400a8          LDR      r0,[r4,#0xa8]
00130c  e58d0010          STR      r0,[sp,#0x10]
;;;849    	int eccsteps = chip->ecc.steps;
001310  e59470a0          LDR      r7,[r4,#0xa0]
;;;850    	uint8_t *p = buf;
001314  e1a09008          MOV      r9,r8
;;;851    	uint8_t *ecc_calc = chip->buffers->ecccalc;
001318  e59400e8          LDR      r0,[r4,#0xe8]
00131c  e58d000c          STR      r0,[sp,#0xc]
;;;852    	uint8_t *ecc_code = chip->buffers->ecccode;
001320  e59400e8          LDR      r0,[r4,#0xe8]
001324  e2800d09          ADD      r0,r0,#0x240
001328  e58d0008          STR      r0,[sp,#8]
;;;853    	uint32_t *eccpos = chip->ecc.layout->eccpos;
00132c  e59400b8          LDR      r0,[r4,#0xb8]
001330  e2800004          ADD      r0,r0,#4
001334  e58d0004          STR      r0,[sp,#4]
;;;854    
;;;855    	chip->ecc.read_page_raw(mtd, chip, buf, page);
001338  e594c0cc          LDR      r12,[r4,#0xcc]
00133c  e1a02008          MOV      r2,r8
001340  e1a01004          MOV      r1,r4
001344  e1a00006          MOV      r0,r6
001348  e59d3020          LDR      r3,[sp,#0x20]
00134c  e12fff3c          BLX      r12
;;;856    
;;;857    	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
001350  e3a05000          MOV      r5,#0
001354  ea000009          B        |L1.4992|
                  |L1.4952|
;;;858    		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
001358  e59d000c          LDR      r0,[sp,#0xc]
00135c  e0802005          ADD      r2,r0,r5
001360  e1a01009          MOV      r1,r9
001364  e1a00006          MOV      r0,r6
001368  e59430c4          LDR      r3,[r4,#0xc4]
00136c  e12fff33          BLX      r3
001370  e2477001          SUB      r7,r7,#1              ;857
001374  e59d0010          LDR      r0,[sp,#0x10]         ;857
001378  e0855000          ADD      r5,r5,r0              ;857
00137c  e089900a          ADD      r9,r9,r10             ;857
                  |L1.4992|
001380  e3570000          CMP      r7,#0                 ;857
001384  1afffff3          BNE      |L1.4952|
;;;859    
;;;860    	for (i = 0; i < chip->ecc.total; i++)
001388  e3a05000          MOV      r5,#0
00138c  ea000006          B        |L1.5036|
                  |L1.5008|
;;;861    		ecc_code[i] = chip->oob_poi[eccpos[i]];
001390  e5941090          LDR      r1,[r4,#0x90]
001394  e59d0004          LDR      r0,[sp,#4]
001398  e7900105          LDR      r0,[r0,r5,LSL #2]
00139c  e7d11000          LDRB     r1,[r1,r0]
0013a0  e59d0008          LDR      r0,[sp,#8]
0013a4  e7c01005          STRB     r1,[r0,r5]
0013a8  e2855001          ADD      r5,r5,#1              ;860
                  |L1.5036|
0013ac  e59400ac          LDR      r0,[r4,#0xac]         ;860
0013b0  e1500005          CMP      r0,r5                 ;860
0013b4  cafffff5          BGT      |L1.5008|
;;;862    
;;;863    	eccsteps = chip->ecc.steps;
0013b8  e59470a0          LDR      r7,[r4,#0xa0]
;;;864    	p = buf;
0013bc  e1a09008          MOV      r9,r8
;;;865    
;;;866    	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
0013c0  e3a05000          MOV      r5,#0
0013c4  ea000015          B        |L1.5152|
                  |L1.5064|
;;;867    		int stat;
;;;868    
;;;869    		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
0013c8  e59d000c          LDR      r0,[sp,#0xc]
0013cc  e0803005          ADD      r3,r0,r5
0013d0  e59d0008          LDR      r0,[sp,#8]
0013d4  e0802005          ADD      r2,r0,r5
0013d8  e1a01009          MOV      r1,r9
0013dc  e1a00006          MOV      r0,r6
0013e0  e594c0c8          LDR      r12,[r4,#0xc8]
0013e4  e12fff3c          BLX      r12
0013e8  e1a0b000          MOV      r11,r0
;;;870    		if (stat < 0)
0013ec  e35b0000          CMP      r11,#0
0013f0  aa000003          BGE      |L1.5124|
;;;871    			mtd->ecc_stats.failed++;
0013f4  e5960084          LDR      r0,[r6,#0x84]
0013f8  e2800001          ADD      r0,r0,#1
0013fc  e5860084          STR      r0,[r6,#0x84]
001400  ea000002          B        |L1.5136|
                  |L1.5124|
;;;872    		else
;;;873    			mtd->ecc_stats.corrected += stat;
001404  e5960080          LDR      r0,[r6,#0x80]
001408  e080000b          ADD      r0,r0,r11
00140c  e5860080          STR      r0,[r6,#0x80]
                  |L1.5136|
001410  e2477001          SUB      r7,r7,#1              ;866
001414  e59d0010          LDR      r0,[sp,#0x10]         ;866
001418  e0855000          ADD      r5,r5,r0              ;866
00141c  e089900a          ADD      r9,r9,r10             ;866
                  |L1.5152|
001420  e3570000          CMP      r7,#0                 ;866
001424  1affffe7          BNE      |L1.5064|
;;;874    	}
;;;875    	return 0;
001428  e3a00000          MOV      r0,#0
00142c  e28dd024          ADD      sp,sp,#0x24
;;;876    }
001430  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5172|
                          DCD      0x0000074b
                  |L1.5176|
                          DCD      0x00030d40
                  |L1.5180|
00143c  54696d65          DCB      "Timeout!",0
001440  6f757421
001444  00      
001445  00                DCB      0
001446  00                DCB      0
001447  00                DCB      0
                          ENDP

                  nand_read_subpage PROC
;;;885     */
;;;886    static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,
001448  e92d4fff          PUSH     {r0-r11,lr}
;;;887    			uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
;;;888    {
00144c  e24dd024          SUB      sp,sp,#0x24
001450  e1a06000          MOV      r6,r0
001454  e1a04001          MOV      r4,r1
;;;889    	int start_step, end_step, num_steps;
;;;890    	uint32_t *eccpos = chip->ecc.layout->eccpos;
001458  e59400b8          LDR      r0,[r4,#0xb8]
00145c  e2808004          ADD      r8,r0,#4
;;;891    	uint8_t *p;
;;;892    	int data_col_addr, i, gaps = 0;
001460  e3a00000          MOV      r0,#0
001464  e58d0014          STR      r0,[sp,#0x14]
;;;893    	int datafrag_len, eccfrag_len, aligned_len, aligned_pos;
;;;894    	int busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;
001468  e5d40050          LDRB     r0,[r4,#0x50]
00146c  e3100002          TST      r0,#2
001470  0a000001          BEQ      |L1.5244|
001474  e3a00002          MOV      r0,#2
001478  ea000000          B        |L1.5248|
                  |L1.5244|
00147c  e3a00001          MOV      r0,#1
                  |L1.5248|
001480  e58d0004          STR      r0,[sp,#4]
;;;895    	int index = 0;
001484  e3a0b000          MOV      r11,#0
;;;896    
;;;897    	/* Column address wihin the page aligned to ECC size (256bytes). */
;;;898    	start_step = data_offs / chip->ecc.size;
001488  e59410a4          LDR      r1,[r4,#0xa4]
00148c  e59d002c          LDR      r0,[sp,#0x2c]
001490  ebfffffe          BL       __aeabi_uidivmod
001494  e1a07000          MOV      r7,r0
;;;899    	end_step = (data_offs + readlen - 1) / chip->ecc.size;
001498  e59410a4          LDR      r1,[r4,#0xa4]
00149c  e59d202c          LDR      r2,[sp,#0x2c]
0014a0  e59d3030          LDR      r3,[sp,#0x30]
0014a4  e0822003          ADD      r2,r2,r3
0014a8  e2420001          SUB      r0,r2,#1
0014ac  ebfffffe          BL       __aeabi_uidivmod
0014b0  e58d0020          STR      r0,[sp,#0x20]
;;;900    	num_steps = end_step - start_step + 1;
0014b4  e59d0020          LDR      r0,[sp,#0x20]
0014b8  e0400007          SUB      r0,r0,r7
0014bc  e2800001          ADD      r0,r0,#1
0014c0  e58d001c          STR      r0,[sp,#0x1c]
;;;901    
;;;902    	/* Data size aligned to ECC ecc.size*/
;;;903    	datafrag_len = num_steps * chip->ecc.size;
0014c4  e59410a4          LDR      r1,[r4,#0xa4]
0014c8  e59d001c          LDR      r0,[sp,#0x1c]
0014cc  e0000091          MUL      r0,r1,r0
0014d0  e58d0010          STR      r0,[sp,#0x10]
;;;904    	eccfrag_len = num_steps * chip->ecc.bytes;
0014d4  e59410a8          LDR      r1,[r4,#0xa8]
0014d8  e59d001c          LDR      r0,[sp,#0x1c]
0014dc  e0090091          MUL      r9,r1,r0
;;;905    
;;;906    	data_col_addr = start_step * chip->ecc.size;
0014e0  e59400a4          LDR      r0,[r4,#0xa4]
0014e4  e00a0790          MUL      r10,r0,r7
;;;907    	/* If we read not a page aligned data */
;;;908    	if (data_col_addr != 0)
0014e8  e35a0000          CMP      r10,#0
0014ec  0a000005          BEQ      |L1.5384|
;;;909    		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
0014f0  e3e03000          MVN      r3,#0
0014f4  e1a0200a          MOV      r2,r10
0014f8  e3a01005          MOV      r1,#5
0014fc  e1a00006          MOV      r0,r6
001500  e594c034          LDR      r12,[r4,#0x34]
001504  e12fff3c          BLX      r12
                  |L1.5384|
;;;910    
;;;911    	p = bufpoi + data_col_addr;
001508  e59d0058          LDR      r0,[sp,#0x58]
00150c  e080000a          ADD      r0,r0,r10
001510  e58d0018          STR      r0,[sp,#0x18]
;;;912    	chip->read_buf(mtd, p, datafrag_len);
001514  e5943014          LDR      r3,[r4,#0x14]
001518  e1a00006          MOV      r0,r6
00151c  e59d1018          LDR      r1,[sp,#0x18]
001520  e59d2010          LDR      r2,[sp,#0x10]
001524  e12fff33          BLX      r3
;;;913    
;;;914    	/* Calculate  ECC */
;;;915    	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)
001528  e3a05000          MOV      r5,#0
00152c  ea00000b          B        |L1.5472|
                  |L1.5424|
;;;916    		chip->ecc.calculate(mtd, p, &chip->buffers->ecccalc[i]);
001530  e59400e8          LDR      r0,[r4,#0xe8]
001534  e0802005          ADD      r2,r0,r5
001538  e59430c4          LDR      r3,[r4,#0xc4]
00153c  e1a00006          MOV      r0,r6
001540  e59d1018          LDR      r1,[sp,#0x18]
001544  e12fff33          BLX      r3
001548  e59400a8          LDR      r0,[r4,#0xa8]         ;915
00154c  e0855000          ADD      r5,r5,r0              ;915
001550  e59d0018          LDR      r0,[sp,#0x18]         ;915
001554  e59410a4          LDR      r1,[r4,#0xa4]         ;915
001558  e0800001          ADD      r0,r0,r1              ;915
00155c  e58d0018          STR      r0,[sp,#0x18]         ;915
                  |L1.5472|
001560  e1550009          CMP      r5,r9                 ;915
001564  bafffff1          BLT      |L1.5424|
;;;917    
;;;918    	/* The performance is faster if to position offsets
;;;919    	   according to ecc.pos. Let make sure here that
;;;920    	   there are no gaps in ecc positions */
;;;921    	for (i = 0; i < eccfrag_len - 1; i++) {
001568  e3a05000          MOV      r5,#0
00156c  ea00000d          B        |L1.5544|
                  |L1.5488|
;;;922    		if (eccpos[i + start_step * chip->ecc.bytes] + 1 !=
001570  e59400a8          LDR      r0,[r4,#0xa8]
001574  e0205097          MLA      r0,r7,r0,r5
001578  e7980100          LDR      r0,[r8,r0,LSL #2]
00157c  e2800001          ADD      r0,r0,#1
001580  e59410a8          LDR      r1,[r4,#0xa8]
001584  e0215197          MLA      r1,r7,r1,r5
001588  e2811001          ADD      r1,r1,#1
00158c  e7981101          LDR      r1,[r8,r1,LSL #2]
001590  e1500001          CMP      r0,r1
001594  0a000002          BEQ      |L1.5540|
;;;923    			eccpos[i + start_step * chip->ecc.bytes + 1]) {
;;;924    			gaps = 1;
001598  e3a00001          MOV      r0,#1
00159c  e58d0014          STR      r0,[sp,#0x14]
;;;925    			break;
0015a0  ea000003          B        |L1.5556|
                  |L1.5540|
0015a4  e2855001          ADD      r5,r5,#1              ;921
                  |L1.5544|
0015a8  e2490001          SUB      r0,r9,#1              ;921
0015ac  e1500005          CMP      r0,r5                 ;921
0015b0  caffffee          BGT      |L1.5488|
                  |L1.5556|
0015b4  e1a00000          MOV      r0,r0
;;;926    		}
;;;927    	}
;;;928    	if (gaps) {
0015b8  e59d0014          LDR      r0,[sp,#0x14]
0015bc  e3500000          CMP      r0,#0
0015c0  0a00000b          BEQ      |L1.5620|
;;;929    		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize, -1);
0015c4  e5962014          LDR      r2,[r6,#0x14]
0015c8  e3e03000          MVN      r3,#0
0015cc  e3a01005          MOV      r1,#5
0015d0  e1a00006          MOV      r0,r6
0015d4  e594c034          LDR      r12,[r4,#0x34]
0015d8  e12fff3c          BLX      r12
;;;930    		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
0015dc  e5962018          LDR      r2,[r6,#0x18]
0015e0  e1a00006          MOV      r0,r6
0015e4  e5941090          LDR      r1,[r4,#0x90]
0015e8  e5943014          LDR      r3,[r4,#0x14]
0015ec  e12fff33          BLX      r3
0015f0  ea000029          B        |L1.5788|
                  |L1.5620|
;;;931    	} else {
;;;932    		/* send the command to read the particular ecc bytes */
;;;933    		/* take care about buswidth alignment in read_buf */
;;;934    		index = start_step * chip->ecc.bytes;
0015f4  e59400a8          LDR      r0,[r4,#0xa8]
0015f8  e00b0790          MUL      r11,r0,r7
;;;935    
;;;936    		aligned_pos = eccpos[index] & ~(busw - 1);
0015fc  e798110b          LDR      r1,[r8,r11,LSL #2]
001600  e59d0004          LDR      r0,[sp,#4]
001604  e2400001          SUB      r0,r0,#1
001608  e1c10000          BIC      r0,r1,r0
00160c  e58d0008          STR      r0,[sp,#8]
;;;937    		aligned_len = eccfrag_len;
001610  e58d900c          STR      r9,[sp,#0xc]
;;;938    		if (eccpos[index] & (busw - 1))
001614  e798110b          LDR      r1,[r8,r11,LSL #2]
001618  e59d0004          LDR      r0,[sp,#4]
00161c  e2400001          SUB      r0,r0,#1
001620  e1100001          TST      r0,r1
001624  0a000002          BEQ      |L1.5684|
;;;939    			aligned_len++;
001628  e59d000c          LDR      r0,[sp,#0xc]
00162c  e2800001          ADD      r0,r0,#1
001630  e58d000c          STR      r0,[sp,#0xc]
                  |L1.5684|
;;;940    		if (eccpos[index + (num_steps * chip->ecc.bytes)] & (busw - 1))
001634  e59410a8          LDR      r1,[r4,#0xa8]
001638  e59d001c          LDR      r0,[sp,#0x1c]
00163c  e020b091          MLA      r0,r1,r0,r11
001640  e7981100          LDR      r1,[r8,r0,LSL #2]
001644  e59d0004          LDR      r0,[sp,#4]
001648  e2400001          SUB      r0,r0,#1
00164c  e1100001          TST      r0,r1
001650  0a000002          BEQ      |L1.5728|
;;;941    			aligned_len++;
001654  e59d000c          LDR      r0,[sp,#0xc]
001658  e2800001          ADD      r0,r0,#1
00165c  e58d000c          STR      r0,[sp,#0xc]
                  |L1.5728|
;;;942    
;;;943    		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
001660  e5961014          LDR      r1,[r6,#0x14]
001664  e59d0008          LDR      r0,[sp,#8]
001668  e0812000          ADD      r2,r1,r0
00166c  e3e03000          MVN      r3,#0
001670  e3a01005          MOV      r1,#5
001674  e1a00006          MOV      r0,r6
001678  e594c034          LDR      r12,[r4,#0x34]
00167c  e12fff3c          BLX      r12
;;;944    					mtd->writesize + aligned_pos, -1);
;;;945    		chip->read_buf(mtd, &chip->oob_poi[aligned_pos], aligned_len);
001680  e5942090          LDR      r2,[r4,#0x90]
001684  e59d0008          LDR      r0,[sp,#8]
001688  e0821000          ADD      r1,r2,r0
00168c  e5943014          LDR      r3,[r4,#0x14]
001690  e1a00006          MOV      r0,r6
001694  e59d200c          LDR      r2,[sp,#0xc]
001698  e12fff33          BLX      r3
                  |L1.5788|
;;;946    	}
;;;947    
;;;948    	for (i = 0; i < eccfrag_len; i++)
00169c  e3a05000          MOV      r5,#0
0016a0  ea000007          B        |L1.5828|
                  |L1.5796|
;;;949    		chip->buffers->ecccode[i] = chip->oob_poi[eccpos[i + index]];
0016a4  e085100b          ADD      r1,r5,r11
0016a8  e5940090          LDR      r0,[r4,#0x90]
0016ac  e7981101          LDR      r1,[r8,r1,LSL #2]
0016b0  e7d00001          LDRB     r0,[r0,r1]
0016b4  e59410e8          LDR      r1,[r4,#0xe8]
0016b8  e2811d09          ADD      r1,r1,#0x240
0016bc  e7c10005          STRB     r0,[r1,r5]
0016c0  e2855001          ADD      r5,r5,#1              ;948
                  |L1.5828|
0016c4  e1550009          CMP      r5,r9                 ;948
0016c8  bafffff5          BLT      |L1.5796|
;;;950    
;;;951    	p = bufpoi + data_col_addr;
0016cc  e59d0058          LDR      r0,[sp,#0x58]
0016d0  e080000a          ADD      r0,r0,r10
0016d4  e58d0018          STR      r0,[sp,#0x18]
;;;952    	for (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {
0016d8  e3a05000          MOV      r5,#0
0016dc  ea000019          B        |L1.5960|
                  |L1.5856|
;;;953    		int stat;
;;;954    
;;;955    		stat = chip->ecc.correct(mtd, p,
0016e0  e59400e8          LDR      r0,[r4,#0xe8]
0016e4  e0803005          ADD      r3,r0,r5
0016e8  e2800d09          ADD      r0,r0,#0x240
0016ec  e0802005          ADD      r2,r0,r5
0016f0  e594c0c8          LDR      r12,[r4,#0xc8]
0016f4  e1a00006          MOV      r0,r6
0016f8  e59d1018          LDR      r1,[sp,#0x18]
0016fc  e12fff3c          BLX      r12
001700  e58d0000          STR      r0,[sp,#0]
;;;956    			&chip->buffers->ecccode[i], &chip->buffers->ecccalc[i]);
;;;957    		if (stat < 0)
001704  e59d0000          LDR      r0,[sp,#0]
001708  e3500000          CMP      r0,#0
00170c  aa000003          BGE      |L1.5920|
;;;958    			mtd->ecc_stats.failed++;
001710  e5960084          LDR      r0,[r6,#0x84]
001714  e2800001          ADD      r0,r0,#1
001718  e5860084          STR      r0,[r6,#0x84]
00171c  ea000003          B        |L1.5936|
                  |L1.5920|
;;;959    		else
;;;960    			mtd->ecc_stats.corrected += stat;
001720  e5961080          LDR      r1,[r6,#0x80]
001724  e59d0000          LDR      r0,[sp,#0]
001728  e0800001          ADD      r0,r0,r1
00172c  e5860080          STR      r0,[r6,#0x80]
                  |L1.5936|
001730  e59400a8          LDR      r0,[r4,#0xa8]         ;952
001734  e0855000          ADD      r5,r5,r0              ;952
001738  e59d0018          LDR      r0,[sp,#0x18]         ;952
00173c  e59410a4          LDR      r1,[r4,#0xa4]         ;952
001740  e0800001          ADD      r0,r0,r1              ;952
001744  e58d0018          STR      r0,[sp,#0x18]         ;952
                  |L1.5960|
001748  e1550009          CMP      r5,r9                 ;952
00174c  baffffe3          BLT      |L1.5856|
;;;961    	}
;;;962    	return 0;
001750  e3a00000          MOV      r0,#0
001754  e28dd034          ADD      sp,sp,#0x34
;;;963    }
001758  e8bd8ff0          POP      {r4-r11,pc}
;;;964    
                          ENDP

                  nand_read_page_hwecc PROC
;;;973     */
;;;974    static int nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
00175c  e92d5fff          PUSH     {r0-r12,lr}
;;;975    				uint8_t *buf, int page)
;;;976    {
001760  e1a06000          MOV      r6,r0
001764  e1a04001          MOV      r4,r1
001768  e1a08002          MOV      r8,r2
;;;977    	int i, eccsize = chip->ecc.size;
00176c  e59490a4          LDR      r9,[r4,#0xa4]
;;;978    	int eccbytes = chip->ecc.bytes;
001770  e594b0a8          LDR      r11,[r4,#0xa8]
;;;979    	int eccsteps = chip->ecc.steps;
001774  e59470a0          LDR      r7,[r4,#0xa0]
;;;980    	uint8_t *p = buf;
001778  e1a0a008          MOV      r10,r8
;;;981    	uint8_t *ecc_calc = chip->buffers->ecccalc;
00177c  e59400e8          LDR      r0,[r4,#0xe8]
001780  e58d000c          STR      r0,[sp,#0xc]
;;;982    	uint8_t *ecc_code = chip->buffers->ecccode;
001784  e59400e8          LDR      r0,[r4,#0xe8]
001788  e2800d09          ADD      r0,r0,#0x240
00178c  e58d0008          STR      r0,[sp,#8]
;;;983    	uint32_t *eccpos = chip->ecc.layout->eccpos;
001790  e59400b8          LDR      r0,[r4,#0xb8]
001794  e2800004          ADD      r0,r0,#4
001798  e58d0004          STR      r0,[sp,#4]
;;;984    
;;;985    	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
00179c  e3a05000          MOV      r5,#0
0017a0  ea000011          B        |L1.6124|
                  |L1.6052|
;;;986    		chip->ecc.hwctl(mtd, NAND_ECC_READ);
0017a4  e3a01000          MOV      r1,#0
0017a8  e1a00006          MOV      r0,r6
0017ac  e59420c0          LDR      r2,[r4,#0xc0]
0017b0  e12fff32          BLX      r2
;;;987    		chip->read_buf(mtd, p, eccsize);
0017b4  e1a02009          MOV      r2,r9
0017b8  e1a0100a          MOV      r1,r10
0017bc  e1a00006          MOV      r0,r6
0017c0  e5943014          LDR      r3,[r4,#0x14]
0017c4  e12fff33          BLX      r3
;;;988    		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
0017c8  e59d000c          LDR      r0,[sp,#0xc]
0017cc  e0802005          ADD      r2,r0,r5
0017d0  e1a0100a          MOV      r1,r10
0017d4  e1a00006          MOV      r0,r6
0017d8  e59430c4          LDR      r3,[r4,#0xc4]
0017dc  e12fff33          BLX      r3
0017e0  e2477001          SUB      r7,r7,#1              ;985
0017e4  e085500b          ADD      r5,r5,r11             ;985
0017e8  e08aa009          ADD      r10,r10,r9            ;985
                  |L1.6124|
0017ec  e3570000          CMP      r7,#0                 ;985
0017f0  1affffeb          BNE      |L1.6052|
;;;989    	}
;;;990    	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
0017f4  e5962018          LDR      r2,[r6,#0x18]
0017f8  e1a00006          MOV      r0,r6
0017fc  e5941090          LDR      r1,[r4,#0x90]
001800  e5943014          LDR      r3,[r4,#0x14]
001804  e12fff33          BLX      r3
;;;991    
;;;992    	for (i = 0; i < chip->ecc.total; i++)
001808  e3a05000          MOV      r5,#0
00180c  ea000006          B        |L1.6188|
                  |L1.6160|
;;;993    		ecc_code[i] = chip->oob_poi[eccpos[i]];
001810  e5941090          LDR      r1,[r4,#0x90]
001814  e59d0004          LDR      r0,[sp,#4]
001818  e7900105          LDR      r0,[r0,r5,LSL #2]
00181c  e7d11000          LDRB     r1,[r1,r0]
001820  e59d0008          LDR      r0,[sp,#8]
001824  e7c01005          STRB     r1,[r0,r5]
001828  e2855001          ADD      r5,r5,#1              ;992
                  |L1.6188|
00182c  e59400ac          LDR      r0,[r4,#0xac]         ;992
001830  e1500005          CMP      r0,r5                 ;992
001834  cafffff5          BGT      |L1.6160|
;;;994    
;;;995    	eccsteps = chip->ecc.steps;
001838  e59470a0          LDR      r7,[r4,#0xa0]
;;;996    	p = buf;
00183c  e1a0a008          MOV      r10,r8
;;;997    
;;;998    	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
001840  e3a05000          MOV      r5,#0
001844  ea000016          B        |L1.6308|
                  |L1.6216|
;;;999    		int stat;
;;;1000   
;;;1001   		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
001848  e59d000c          LDR      r0,[sp,#0xc]
00184c  e0803005          ADD      r3,r0,r5
001850  e59d0008          LDR      r0,[sp,#8]
001854  e0802005          ADD      r2,r0,r5
001858  e1a0100a          MOV      r1,r10
00185c  e1a00006          MOV      r0,r6
001860  e594c0c8          LDR      r12,[r4,#0xc8]
001864  e12fff3c          BLX      r12
001868  e58d0000          STR      r0,[sp,#0]
;;;1002   		if (stat < 0)
00186c  e59d0000          LDR      r0,[sp,#0]
001870  e3500000          CMP      r0,#0
001874  aa000003          BGE      |L1.6280|
;;;1003   			mtd->ecc_stats.failed++;
001878  e5960084          LDR      r0,[r6,#0x84]
00187c  e2800001          ADD      r0,r0,#1
001880  e5860084          STR      r0,[r6,#0x84]
001884  ea000003          B        |L1.6296|
                  |L1.6280|
;;;1004   		else
;;;1005   			mtd->ecc_stats.corrected += stat;
001888  e5961080          LDR      r1,[r6,#0x80]
00188c  e59d0000          LDR      r0,[sp,#0]
001890  e0800001          ADD      r0,r0,r1
001894  e5860080          STR      r0,[r6,#0x80]
                  |L1.6296|
001898  e2477001          SUB      r7,r7,#1              ;998
00189c  e085500b          ADD      r5,r5,r11             ;998
0018a0  e08aa009          ADD      r10,r10,r9            ;998
                  |L1.6308|
0018a4  e3570000          CMP      r7,#0                 ;998
0018a8  1affffe6          BNE      |L1.6216|
;;;1006   	}
;;;1007   	return 0;
0018ac  e3a00000          MOV      r0,#0
0018b0  e28dd010          ADD      sp,sp,#0x10
;;;1008   }
0018b4  e8bd9ff0          POP      {r4-r12,pc}
;;;1009   
                          ENDP

                  nand_read_page_hwecc_oob_first PROC
;;;1023    */
;;;1024   static int nand_read_page_hwecc_oob_first(struct mtd_info *mtd,
0018b8  e92d4fff          PUSH     {r0-r11,lr}
;;;1025   	struct nand_chip *chip, uint8_t *buf, int page)
;;;1026   {
0018bc  e24dd014          SUB      sp,sp,#0x14
0018c0  e1a06000          MOV      r6,r0
0018c4  e1a04001          MOV      r4,r1
0018c8  e1a07002          MOV      r7,r2
;;;1027   	int i, eccsize = chip->ecc.size;
0018cc  e59480a4          LDR      r8,[r4,#0xa4]
;;;1028   	int eccbytes = chip->ecc.bytes;
0018d0  e59400a8          LDR      r0,[r4,#0xa8]
0018d4  e58d0010          STR      r0,[sp,#0x10]
;;;1029   	int eccsteps = chip->ecc.steps;
0018d8  e59490a0          LDR      r9,[r4,#0xa0]
;;;1030   	uint8_t *p = buf;
0018dc  e1a0a007          MOV      r10,r7
;;;1031   	uint8_t *ecc_code = chip->buffers->ecccode;
0018e0  e59400e8          LDR      r0,[r4,#0xe8]
0018e4  e2800d09          ADD      r0,r0,#0x240
0018e8  e58d000c          STR      r0,[sp,#0xc]
;;;1032   	uint32_t *eccpos = chip->ecc.layout->eccpos;
0018ec  e59400b8          LDR      r0,[r4,#0xb8]
0018f0  e2800004          ADD      r0,r0,#4
0018f4  e58d0008          STR      r0,[sp,#8]
;;;1033   	uint8_t *ecc_calc = chip->buffers->ecccalc;
0018f8  e59400e8          LDR      r0,[r4,#0xe8]
0018fc  e58d0004          STR      r0,[sp,#4]
;;;1034   
;;;1035   	/* Read the OOB area first */
;;;1036   	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
001900  e594c034          LDR      r12,[r4,#0x34]
001904  e3a02000          MOV      r2,#0
001908  e3a01050          MOV      r1,#0x50
00190c  e1a00006          MOV      r0,r6
001910  e59d3020          LDR      r3,[sp,#0x20]
001914  e12fff3c          BLX      r12
;;;1037   	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
001918  e5962018          LDR      r2,[r6,#0x18]
00191c  e1a00006          MOV      r0,r6
001920  e5941090          LDR      r1,[r4,#0x90]
001924  e5943014          LDR      r3,[r4,#0x14]
001928  e12fff33          BLX      r3
;;;1038   	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
00192c  e594c034          LDR      r12,[r4,#0x34]
001930  e3a02000          MOV      r2,#0
001934  e1a01002          MOV      r1,r2
001938  e1a00006          MOV      r0,r6
00193c  e59d3020          LDR      r3,[sp,#0x20]
001940  e12fff3c          BLX      r12
;;;1039   
;;;1040   	for (i = 0; i < chip->ecc.total; i++)
001944  e3a05000          MOV      r5,#0
001948  ea000006          B        |L1.6504|
                  |L1.6476|
;;;1041   		ecc_code[i] = chip->oob_poi[eccpos[i]];
00194c  e5941090          LDR      r1,[r4,#0x90]
001950  e59d0008          LDR      r0,[sp,#8]
001954  e7900105          LDR      r0,[r0,r5,LSL #2]
001958  e7d11000          LDRB     r1,[r1,r0]
00195c  e59d000c          LDR      r0,[sp,#0xc]
001960  e7c01005          STRB     r1,[r0,r5]
001964  e2855001          ADD      r5,r5,#1              ;1040
                  |L1.6504|
001968  e59400ac          LDR      r0,[r4,#0xac]         ;1040
00196c  e1500005          CMP      r0,r5                 ;1040
001970  cafffff5          BGT      |L1.6476|
;;;1042   
;;;1043   	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
001974  e3a05000          MOV      r5,#0
001978  ea000023          B        |L1.6668|
                  |L1.6524|
;;;1044   		int stat;
;;;1045   
;;;1046   		chip->ecc.hwctl(mtd, NAND_ECC_READ);
00197c  e3a01000          MOV      r1,#0
001980  e1a00006          MOV      r0,r6
001984  e59420c0          LDR      r2,[r4,#0xc0]
001988  e12fff32          BLX      r2
;;;1047   		chip->read_buf(mtd, p, eccsize);
00198c  e1a02008          MOV      r2,r8
001990  e1a0100a          MOV      r1,r10
001994  e1a00006          MOV      r0,r6
001998  e5943014          LDR      r3,[r4,#0x14]
00199c  e12fff33          BLX      r3
;;;1048   		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
0019a0  e59d0004          LDR      r0,[sp,#4]
0019a4  e0802005          ADD      r2,r0,r5
0019a8  e1a0100a          MOV      r1,r10
0019ac  e1a00006          MOV      r0,r6
0019b0  e59430c4          LDR      r3,[r4,#0xc4]
0019b4  e12fff33          BLX      r3
;;;1049   
;;;1050   		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
0019b8  e59d000c          LDR      r0,[sp,#0xc]
0019bc  e0802005          ADD      r2,r0,r5
0019c0  e3a03000          MOV      r3,#0
0019c4  e1a0100a          MOV      r1,r10
0019c8  e1a00006          MOV      r0,r6
0019cc  e594c0c8          LDR      r12,[r4,#0xc8]
0019d0  e12fff3c          BLX      r12
0019d4  e1a0b000          MOV      r11,r0
;;;1051   		if (stat < 0)
0019d8  e35b0000          CMP      r11,#0
0019dc  aa000003          BGE      |L1.6640|
;;;1052   			mtd->ecc_stats.failed++;
0019e0  e5960084          LDR      r0,[r6,#0x84]
0019e4  e2800001          ADD      r0,r0,#1
0019e8  e5860084          STR      r0,[r6,#0x84]
0019ec  ea000002          B        |L1.6652|
                  |L1.6640|
;;;1053   		else
;;;1054   			mtd->ecc_stats.corrected += stat;
0019f0  e5960080          LDR      r0,[r6,#0x80]
0019f4  e080000b          ADD      r0,r0,r11
0019f8  e5860080          STR      r0,[r6,#0x80]
                  |L1.6652|
0019fc  e2499001          SUB      r9,r9,#1              ;1043
001a00  e59d0010          LDR      r0,[sp,#0x10]         ;1043
001a04  e0855000          ADD      r5,r5,r0              ;1043
001a08  e08aa008          ADD      r10,r10,r8            ;1043
                  |L1.6668|
001a0c  e3590000          CMP      r9,#0                 ;1043
001a10  1affffd9          BNE      |L1.6524|
;;;1055   	}
;;;1056   	return 0;
001a14  e3a00000          MOV      r0,#0
001a18  e28dd024          ADD      sp,sp,#0x24
;;;1057   }
001a1c  e8bd8ff0          POP      {r4-r11,pc}
;;;1058   
                          ENDP

                  nand_read_page_syndrome PROC
;;;1068    */
;;;1069   static int nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
001a20  e92d5ffc          PUSH     {r2-r12,lr}
;;;1070   				   uint8_t *buf, int page)
;;;1071   {
001a24  e1a05000          MOV      r5,r0
001a28  e1a04001          MOV      r4,r1
001a2c  e1a0a002          MOV      r10,r2
;;;1072   	int i, eccsize = chip->ecc.size;
001a30  e594b0a4          LDR      r11,[r4,#0xa4]
;;;1073   	int eccbytes = chip->ecc.bytes;
001a34  e59490a8          LDR      r9,[r4,#0xa8]
;;;1074   	int eccsteps = chip->ecc.steps;
001a38  e59400a0          LDR      r0,[r4,#0xa0]
001a3c  e58d0004          STR      r0,[sp,#4]
;;;1075   	uint8_t *p = buf;
001a40  e58da000          STR      r10,[sp,#0]
;;;1076   	uint8_t *oob = chip->oob_poi;
001a44  e5946090          LDR      r6,[r4,#0x90]
;;;1077   
;;;1078   	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
001a48  e3a08000          MOV      r8,#0
001a4c  ea00003d          B        |L1.6984|
                  |L1.6736|
;;;1079   		int stat;
;;;1080   
;;;1081   		chip->ecc.hwctl(mtd, NAND_ECC_READ);
001a50  e3a01000          MOV      r1,#0
001a54  e1a00005          MOV      r0,r5
001a58  e59420c0          LDR      r2,[r4,#0xc0]
001a5c  e12fff32          BLX      r2
;;;1082   		chip->read_buf(mtd, p, eccsize);
001a60  e1a0200b          MOV      r2,r11
001a64  e5943014          LDR      r3,[r4,#0x14]
001a68  e1a00005          MOV      r0,r5
001a6c  e59d1000          LDR      r1,[sp,#0]
001a70  e12fff33          BLX      r3
;;;1083   
;;;1084   		if (chip->ecc.prepad) {
001a74  e59400b0          LDR      r0,[r4,#0xb0]
001a78  e3500000          CMP      r0,#0
001a7c  0a000006          BEQ      |L1.6812|
;;;1085   			chip->read_buf(mtd, oob, chip->ecc.prepad);
001a80  e1a01006          MOV      r1,r6
001a84  e1a00005          MOV      r0,r5
001a88  e59420b0          LDR      r2,[r4,#0xb0]
001a8c  e5943014          LDR      r3,[r4,#0x14]
001a90  e12fff33          BLX      r3
;;;1086   			oob += chip->ecc.prepad;
001a94  e59400b0          LDR      r0,[r4,#0xb0]
001a98  e0866000          ADD      r6,r6,r0
                  |L1.6812|
;;;1087   		}
;;;1088   
;;;1089   		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
001a9c  e3a01002          MOV      r1,#2
001aa0  e1a00005          MOV      r0,r5
001aa4  e59420c0          LDR      r2,[r4,#0xc0]
001aa8  e12fff32          BLX      r2
;;;1090   		chip->read_buf(mtd, oob, eccbytes);
001aac  e1a02009          MOV      r2,r9
001ab0  e1a01006          MOV      r1,r6
001ab4  e1a00005          MOV      r0,r5
001ab8  e5943014          LDR      r3,[r4,#0x14]
001abc  e12fff33          BLX      r3
;;;1091   		stat = chip->ecc.correct(mtd, p, oob, NULL);
001ac0  e3a03000          MOV      r3,#0
001ac4  e1a02006          MOV      r2,r6
001ac8  e594c0c8          LDR      r12,[r4,#0xc8]
001acc  e1a00005          MOV      r0,r5
001ad0  e59d1000          LDR      r1,[sp,#0]
001ad4  e12fff3c          BLX      r12
001ad8  e1a07000          MOV      r7,r0
;;;1092   
;;;1093   		if (stat < 0)
001adc  e3570000          CMP      r7,#0
001ae0  aa000003          BGE      |L1.6900|
;;;1094   			mtd->ecc_stats.failed++;
001ae4  e5950084          LDR      r0,[r5,#0x84]
001ae8  e2800001          ADD      r0,r0,#1
001aec  e5850084          STR      r0,[r5,#0x84]
001af0  ea000002          B        |L1.6912|
                  |L1.6900|
;;;1095   		else
;;;1096   			mtd->ecc_stats.corrected += stat;
001af4  e5950080          LDR      r0,[r5,#0x80]
001af8  e0800007          ADD      r0,r0,r7
001afc  e5850080          STR      r0,[r5,#0x80]
                  |L1.6912|
;;;1097   
;;;1098   		oob += eccbytes;
001b00  e0866009          ADD      r6,r6,r9
;;;1099   
;;;1100   		if (chip->ecc.postpad) {
001b04  e59400b4          LDR      r0,[r4,#0xb4]
001b08  e3500000          CMP      r0,#0
001b0c  0a000006          BEQ      |L1.6956|
;;;1101   			chip->read_buf(mtd, oob, chip->ecc.postpad);
001b10  e1a01006          MOV      r1,r6
001b14  e1a00005          MOV      r0,r5
001b18  e59420b4          LDR      r2,[r4,#0xb4]
001b1c  e5943014          LDR      r3,[r4,#0x14]
001b20  e12fff33          BLX      r3
;;;1102   			oob += chip->ecc.postpad;
001b24  e59400b4          LDR      r0,[r4,#0xb4]
001b28  e0866000          ADD      r6,r6,r0
                  |L1.6956|
001b2c  e59d0004          LDR      r0,[sp,#4]            ;1078
001b30  e2400001          SUB      r0,r0,#1              ;1078
001b34  e58d0004          STR      r0,[sp,#4]            ;1078
001b38  e0888009          ADD      r8,r8,r9              ;1078
001b3c  e59d0000          LDR      r0,[sp,#0]            ;1078
001b40  e080000b          ADD      r0,r0,r11             ;1078
001b44  e58d0000          STR      r0,[sp,#0]            ;1078
                  |L1.6984|
001b48  e59d0004          LDR      r0,[sp,#4]            ;1078
001b4c  e3500000          CMP      r0,#0                 ;1078
001b50  1affffbe          BNE      |L1.6736|
;;;1103   		}
;;;1104   	}
;;;1105   
;;;1106   	/* Calculate remaining oob bytes */
;;;1107   	i = mtd->oobsize - (oob - chip->oob_poi);
001b54  e5950018          LDR      r0,[r5,#0x18]
001b58  e5941090          LDR      r1,[r4,#0x90]
001b5c  e0461001          SUB      r1,r6,r1
001b60  e0408001          SUB      r8,r0,r1
;;;1108   	if (i)
001b64  e3580000          CMP      r8,#0
001b68  0a000004          BEQ      |L1.7040|
;;;1109   		chip->read_buf(mtd, oob, i);
001b6c  e1a02008          MOV      r2,r8
001b70  e1a01006          MOV      r1,r6
001b74  e1a00005          MOV      r0,r5
001b78  e5943014          LDR      r3,[r4,#0x14]
001b7c  e12fff33          BLX      r3
                  |L1.7040|
;;;1110   
;;;1111   	return 0;
001b80  e3a00000          MOV      r0,#0
;;;1112   }
001b84  e8bd9ffc          POP      {r2-r12,pc}
;;;1113   
                          ENDP

                  nand_transfer_oob PROC
;;;1120    */
;;;1121   static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
001b88  e92d5ff0          PUSH     {r4-r12,lr}
;;;1122   				  struct mtd_oob_ops *ops, size_t len)
;;;1123   {
001b8c  e1a07000          MOV      r7,r0
001b90  e1a08001          MOV      r8,r1
001b94  e1a09002          MOV      r9,r2
001b98  e1a05003          MOV      r5,r3
;;;1124   	switch (ops->mode) {
001b9c  e5d90000          LDRB     r0,[r9,#0]
001ba0  e3500000          CMP      r0,#0
001ba4  0a000004          BEQ      |L1.7100|
001ba8  e3500001          CMP      r0,#1
001bac  0a00000c          BEQ      |L1.7140|
001bb0  e3500002          CMP      r0,#2
001bb4  1a00003e          BNE      |L1.7348|
001bb8  ea000001          B        |L1.7108|
                  |L1.7100|
;;;1125   
;;;1126   	case MTD_OOB_PLACE:
001bbc  e1a00000          MOV      r0,r0
;;;1127   	case MTD_OOB_RAW:
001bc0  e1a00000          MOV      r0,r0
                  |L1.7108|
;;;1128   		memcpy(oob, chip->oob_poi + ops->ooboffs, len);
001bc4  e5970090          LDR      r0,[r7,#0x90]
001bc8  e5992014          LDR      r2,[r9,#0x14]
001bcc  e0801002          ADD      r1,r0,r2
001bd0  e1a02005          MOV      r2,r5
001bd4  e1a00008          MOV      r0,r8
001bd8  ebfffffe          BL       __aeabi_memcpy
;;;1129   		return oob + len;
001bdc  e0880005          ADD      r0,r8,r5
                  |L1.7136|
;;;1130   
;;;1131   	case MTD_OOB_AUTO: {
;;;1132   		struct nand_oobfree *free = chip->ecc.layout->oobfree;
;;;1133   		uint32_t boffs = 0, roffs = ops->ooboffs;
;;;1134   		size_t bytes = 0;
;;;1135   
;;;1136   		for (; free->length && len; free++, len -= bytes) {
;;;1137   			/* Read request not from offset 0 ? */
;;;1138   			if (roffs) {
;;;1139   				if (roffs >= free->length) {
;;;1140   					roffs -= free->length;
;;;1141   					continue;
;;;1142   				}
;;;1143   				boffs = free->offset + roffs;
;;;1144   				bytes = min_t(size_t, len,(free->length - roffs));
;;;1145   				roffs = 0;
;;;1146   			} else {
;;;1147   				bytes = min_t(size_t, len, free->length);
;;;1148   				boffs = free->offset;
;;;1149   			}
;;;1150   			memcpy(oob, chip->oob_poi + boffs, bytes);
;;;1151   			oob += bytes;
;;;1152   		}
;;;1153   		return oob;
;;;1154   	}
;;;1155   	default:
;;;1156   		BUG();
;;;1157   	}
;;;1158   	return NULL;
;;;1159   }
001be0  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.7140|
001be4  e1a00000          MOV      r0,r0                 ;1131
001be8  e59700b8          LDR      r0,[r7,#0xb8]         ;1132
001bec  e2804f82          ADD      r4,r0,#0x208          ;1132
001bf0  e3a0b000          MOV      r11,#0                ;1133
001bf4  e5996014          LDR      r6,[r9,#0x14]         ;1133
001bf8  e3a0a000          MOV      r10,#0                ;1134
001bfc  ea000025          B        |L1.7320|
                  |L1.7168|
001c00  e3560000          CMP      r6,#0                 ;1138
001c04  0a000012          BEQ      |L1.7252|
001c08  e5940004          LDR      r0,[r4,#4]            ;1139
001c0c  e1500006          CMP      r0,r6                 ;1139
001c10  8a000002          BHI      |L1.7200|
001c14  e5940004          LDR      r0,[r4,#4]            ;1140
001c18  e0466000          SUB      r6,r6,r0              ;1140
001c1c  ea00001b          B        |L1.7312|
                  |L1.7200|
001c20  e5940000          LDR      r0,[r4,#0]            ;1143
001c24  e080b006          ADD      r11,r0,r6             ;1143
001c28  e5940004          LDR      r0,[r4,#4]            ;1144
001c2c  e0400006          SUB      r0,r0,r6              ;1144
001c30  e1500005          CMP      r0,r5                 ;1144
001c34  9a000001          BLS      |L1.7232|
001c38  e1a00005          MOV      r0,r5                 ;1144
001c3c  ea000001          B        |L1.7240|
                  |L1.7232|
001c40  e5940004          LDR      r0,[r4,#4]            ;1144
001c44  e0400006          SUB      r0,r0,r6              ;1144
                  |L1.7240|
001c48  e1a0a000          MOV      r10,r0                ;1144
001c4c  e3a06000          MOV      r6,#0                 ;1145
001c50  ea000007          B        |L1.7284|
                  |L1.7252|
001c54  e5940004          LDR      r0,[r4,#4]            ;1147
001c58  e1500005          CMP      r0,r5                 ;1147
001c5c  9a000001          BLS      |L1.7272|
001c60  e1a00005          MOV      r0,r5                 ;1147
001c64  ea000000          B        |L1.7276|
                  |L1.7272|
001c68  e5940004          LDR      r0,[r4,#4]            ;1147
                  |L1.7276|
001c6c  e1a0a000          MOV      r10,r0                ;1147
001c70  e594b000          LDR      r11,[r4,#0]           ;1148
                  |L1.7284|
001c74  e5970090          LDR      r0,[r7,#0x90]         ;1150
001c78  e080100b          ADD      r1,r0,r11             ;1150
001c7c  e1a0200a          MOV      r2,r10                ;1150
001c80  e1a00008          MOV      r0,r8                 ;1150
001c84  ebfffffe          BL       __aeabi_memcpy
001c88  e088800a          ADD      r8,r8,r10             ;1151
001c8c  e1a00000          MOV      r0,r0                 ;1141
                  |L1.7312|
001c90  e2844008          ADD      r4,r4,#8              ;1136
001c94  e045500a          SUB      r5,r5,r10             ;1136
                  |L1.7320|
001c98  e5940004          LDR      r0,[r4,#4]            ;1136
001c9c  e3500000          CMP      r0,#0                 ;1136
001ca0  0a000001          BEQ      |L1.7340|
001ca4  e3550000          CMP      r5,#0                 ;1136
001ca8  1affffd4          BNE      |L1.7168|
                  |L1.7340|
001cac  e1a00008          MOV      r0,r8                 ;1153
001cb0  eaffffca          B        |L1.7136|
                  |L1.7348|
001cb4  e1a00000          MOV      r0,r0                 ;1155
001cb8  e1a00000          MOV      r0,r0                 ;1156
001cbc  e59f2e00          LDR      r2,|L1.10948|
001cc0  e59f1e00          LDR      r1,|L1.10952|
001cc4  e59f0e00          LDR      r0,|L1.10956|
001cc8  ebfffffe          BL       sysprintf
001ccc  e1a00000          MOV      r0,r0                 ;1156
001cd0  e1a00000          MOV      r0,r0                 ;1124
001cd4  e1a00000          MOV      r0,r0                 ;1124
001cd8  e3a00000          MOV      r0,#0                 ;1158
001cdc  eaffffbf          B        |L1.7136|
;;;1160   
                          ENDP

                  nand_do_read_ops PROC
;;;1169    */
;;;1170   static int nand_do_read_ops(struct mtd_info *mtd, loff_t from,
001ce0  e92d4ff0          PUSH     {r4-r11,lr}
;;;1171   			    struct mtd_oob_ops *ops)
;;;1172   {
001ce4  e24dd054          SUB      sp,sp,#0x54
001ce8  e1a05000          MOV      r5,r0
001cec  e1a07002          MOV      r7,r2
001cf0  e1a08003          MOV      r8,r3
001cf4  e59d6078          LDR      r6,[sp,#0x78]
;;;1173   	int chipnr, page, realpage, col, bytes, aligned;
;;;1174   	struct nand_chip *chip = mtd->priv;
001cf8  e5954094          LDR      r4,[r5,#0x94]
;;;1175   	struct mtd_ecc_stats stats;
;;;1176   	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
001cfc  e5d40058          LDRB     r0,[r4,#0x58]
001d00  e5d41054          LDRB     r1,[r4,#0x54]
001d04  e0400001          SUB      r0,r0,r1
001d08  e3a01001          MOV      r1,#1
001d0c  e1a00011          LSL      r0,r1,r0
001d10  e2400001          SUB      r0,r0,#1
001d14  e58d0024          STR      r0,[sp,#0x24]
;;;1177   	int sndcmd = 1;
001d18  e3a00001          MOV      r0,#1
001d1c  e58d0020          STR      r0,[sp,#0x20]
;;;1178   	int ret = 0;
001d20  e3a00000          MOV      r0,#0
001d24  e58d001c          STR      r0,[sp,#0x1c]
;;;1179   	uint32_t readlen = ops->len;
001d28  e5960004          LDR      r0,[r6,#4]
001d2c  e58d0018          STR      r0,[sp,#0x18]
;;;1180   	uint32_t oobreadlen = ops->ooblen;
001d30  e596000c          LDR      r0,[r6,#0xc]
001d34  e58d0014          STR      r0,[sp,#0x14]
;;;1181   	uint32_t max_oobsize = ops->mode == MTD_OOB_AUTO ?
001d38  e5d60000          LDRB     r0,[r6,#0]
001d3c  e3500001          CMP      r0,#1
001d40  1a000001          BNE      |L1.7500|
;;;1182   		mtd->oobavail : mtd->oobsize;
001d44  e595001c          LDR      r0,[r5,#0x1c]
001d48  ea000000          B        |L1.7504|
                  |L1.7500|
001d4c  e5950018          LDR      r0,[r5,#0x18]
                  |L1.7504|
001d50  e58d0010          STR      r0,[sp,#0x10]
;;;1183   
;;;1184   	uint8_t *bufpoi, *oob, *buf;
;;;1185   
;;;1186   	stats = mtd->ecc_stats;
001d54  e1c508d0          LDRD     r0,r1,[r5,#0x80]
001d58  e1c528d8          LDRD     r2,r3,[r5,#0x88]
001d5c  e1cd02f8          STRD     r0,r1,[sp,#0x28]
001d60  e1cd23f0          STRD     r2,r3,[sp,#0x30]
;;;1187   
;;;1188   	chipnr = (int)(from >> chip->chip_shift);
001d64  e5942060          LDR      r2,[r4,#0x60]
001d68  e58d7050          STR      r7,[sp,#0x50]
001d6c  e1a00007          MOV      r0,r7
001d70  e58d804c          STR      r8,[sp,#0x4c]
001d74  e1a01008          MOV      r1,r8
001d78  ebfffffe          BL       __aeabi_lasr
001d7c  e58d0044          STR      r0,[sp,#0x44]
;;;1189   	chip->select_chip(mtd, chipnr);
001d80  e594201c          LDR      r2,[r4,#0x1c]
001d84  e1a00005          MOV      r0,r5
001d88  e59d1044          LDR      r1,[sp,#0x44]
001d8c  e12fff32          BLX      r2
;;;1190   
;;;1191   	realpage = (int)(from >> chip->page_shift);
001d90  e1a0b007          MOV      r11,r7
001d94  e5942054          LDR      r2,[r4,#0x54]
001d98  e1a0000b          MOV      r0,r11
001d9c  e58d8048          STR      r8,[sp,#0x48]
001da0  e1a01008          MOV      r1,r8
001da4  ebfffffe          BL       __aeabi_lasr
001da8  e1a09000          MOV      r9,r0
;;;1192   	page = realpage & chip->pagemask;
001dac  e5941070          LDR      r1,[r4,#0x70]
001db0  e0010009          AND      r0,r1,r9
001db4  e58d0040          STR      r0,[sp,#0x40]
;;;1193   
;;;1194   	col = (int)(from & (mtd->writesize - 1));
001db8  e5950014          LDR      r0,[r5,#0x14]
001dbc  e2400001          SUB      r0,r0,#1
001dc0  e000a007          AND      r10,r0,r7
;;;1195   
;;;1196   	buf = ops->datbuf;
001dc4  e5960018          LDR      r0,[r6,#0x18]
001dc8  e58d0004          STR      r0,[sp,#4]
;;;1197   	oob = ops->oobbuf;
001dcc  e596001c          LDR      r0,[r6,#0x1c]
001dd0  e58d0008          STR      r0,[sp,#8]
;;;1198   
;;;1199   	while (1) {
001dd4  ea0000be          B        |L1.8404|
                  |L1.7640|
;;;1200   		bytes = min(mtd->writesize - col, readlen);
001dd8  e5950014          LDR      r0,[r5,#0x14]
001ddc  e040100a          SUB      r1,r0,r10
001de0  e59d0018          LDR      r0,[sp,#0x18]
001de4  e1510000          CMP      r1,r0
001de8  9a000001          BLS      |L1.7668|
001dec  e59d0018          LDR      r0,[sp,#0x18]
001df0  ea000001          B        |L1.7676|
                  |L1.7668|
001df4  e5950014          LDR      r0,[r5,#0x14]
001df8  e040000a          SUB      r0,r0,r10
                  |L1.7676|
001dfc  e58d003c          STR      r0,[sp,#0x3c]
;;;1201   		aligned = (bytes == mtd->writesize);
001e00  e5951014          LDR      r1,[r5,#0x14]
001e04  e59d003c          LDR      r0,[sp,#0x3c]
001e08  e1510000          CMP      r1,r0
001e0c  1a000001          BNE      |L1.7704|
001e10  e3a00001          MOV      r0,#1
001e14  ea000000          B        |L1.7708|
                  |L1.7704|
001e18  e3a00000          MOV      r0,#0
                  |L1.7708|
001e1c  e58d0038          STR      r0,[sp,#0x38]
;;;1202   
;;;1203   		/* Is the current page in the buffer ? */
;;;1204   		if (realpage != chip->pagebuf || oob) {
001e20  e5940074          LDR      r0,[r4,#0x74]
001e24  e1500009          CMP      r0,r9
001e28  1a000002          BNE      |L1.7736|
001e2c  e59d0008          LDR      r0,[sp,#8]
001e30  e3500000          CMP      r0,#0
001e34  0a000078          BEQ      |L1.8220|
                  |L1.7736|
;;;1205   			bufpoi = aligned ? buf : chip->buffers->databuf;
001e38  e59d0038          LDR      r0,[sp,#0x38]
001e3c  e3500000          CMP      r0,#0
001e40  0a000001          BEQ      |L1.7756|
001e44  e59d0004          LDR      r0,[sp,#4]
001e48  ea000001          B        |L1.7764|
                  |L1.7756|
001e4c  e59400e8          LDR      r0,[r4,#0xe8]
001e50  e2800d12          ADD      r0,r0,#0x480
                  |L1.7764|
001e54  e58d000c          STR      r0,[sp,#0xc]
;;;1206   
;;;1207   			if (sndcmd) {
001e58  e59d0020          LDR      r0,[sp,#0x20]
001e5c  e3500000          CMP      r0,#0
001e60  0a000007          BEQ      |L1.7812|
;;;1208   				chip->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
001e64  e594c034          LDR      r12,[r4,#0x34]
001e68  e3a02000          MOV      r2,#0
001e6c  e1a01002          MOV      r1,r2
001e70  e1a00005          MOV      r0,r5
001e74  e59d3040          LDR      r3,[sp,#0x40]
001e78  e12fff3c          BLX      r12
;;;1209   				sndcmd = 0;
001e7c  e3a00000          MOV      r0,#0
001e80  e58d0020          STR      r0,[sp,#0x20]
                  |L1.7812|
;;;1210   			}
;;;1211   
;;;1212   			/* Now read the page into the buffer */
;;;1213   			if (ops->mode == MTD_OOB_RAW)
001e84  e5d60000          LDRB     r0,[r6,#0]
001e88  e3500002          CMP      r0,#2
001e8c  1a000007          BNE      |L1.7856|
;;;1214   				ret = chip->ecc.read_page_raw(mtd, chip,
001e90  e594c0cc          LDR      r12,[r4,#0xcc]
001e94  e1a01004          MOV      r1,r4
001e98  e1a00005          MOV      r0,r5
001e9c  e59d200c          LDR      r2,[sp,#0xc]
001ea0  e59d3040          LDR      r3,[sp,#0x40]
001ea4  e12fff3c          BLX      r12
001ea8  e58d001c          STR      r0,[sp,#0x1c]
001eac  ea000019          B        |L1.7960|
                  |L1.7856|
;;;1215   							      bufpoi, page);
;;;1216   			else if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&
001eb0  e59d0038          LDR      r0,[sp,#0x38]
001eb4  e3500000          CMP      r0,#0
001eb8  1a00000f          BNE      |L1.7932|
001ebc  e1d405b0          LDRH     r0,[r4,#0x50]
001ec0  e3100a01          TST      r0,#0x1000
001ec4  0a00000c          BEQ      |L1.7932|
;;;1217   			    !oob)
001ec8  e59d0008          LDR      r0,[sp,#8]
001ecc  e3500000          CMP      r0,#0
001ed0  1a000009          BNE      |L1.7932|
;;;1218   				ret = chip->ecc.read_subpage(mtd, chip,
001ed4  e59d000c          LDR      r0,[sp,#0xc]
001ed8  e58d0000          STR      r0,[sp,#0]
001edc  e594c0d8          LDR      r12,[r4,#0xd8]
001ee0  e1a0200a          MOV      r2,r10
001ee4  e1a01004          MOV      r1,r4
001ee8  e1a00005          MOV      r0,r5
001eec  e59d303c          LDR      r3,[sp,#0x3c]
001ef0  e12fff3c          BLX      r12
001ef4  e58d001c          STR      r0,[sp,#0x1c]
001ef8  ea000006          B        |L1.7960|
                  |L1.7932|
;;;1219   							col, bytes, bufpoi);
;;;1220   			else
;;;1221   				ret = chip->ecc.read_page(mtd, chip, bufpoi,
001efc  e594c0d4          LDR      r12,[r4,#0xd4]
001f00  e1a01004          MOV      r1,r4
001f04  e1a00005          MOV      r0,r5
001f08  e59d200c          LDR      r2,[sp,#0xc]
001f0c  e59d3040          LDR      r3,[sp,#0x40]
001f10  e12fff3c          BLX      r12
001f14  e58d001c          STR      r0,[sp,#0x1c]
                  |L1.7960|
;;;1222   							  page);
;;;1223   			if (ret < 0)
001f18  e59d001c          LDR      r0,[sp,#0x1c]
001f1c  e3500000          CMP      r0,#0
001f20  aa000000          BGE      |L1.7976|
;;;1224   				break;
001f24  ea00006b          B        |L1.8408|
                  |L1.7976|
;;;1225   
;;;1226   			/* Transfer not aligned data */
;;;1227   			if (!aligned) {
001f28  e59d0038          LDR      r0,[sp,#0x38]
001f2c  e3500000          CMP      r0,#0
001f30  1a000010          BNE      |L1.8056|
;;;1228   				if (!NAND_HAS_SUBPAGE_READ(chip) && !oob &&
001f34  e1d405b0          LDRH     r0,[r4,#0x50]
001f38  e3100a01          TST      r0,#0x1000
001f3c  1a000007          BNE      |L1.8032|
001f40  e59d0008          LDR      r0,[sp,#8]
001f44  e3500000          CMP      r0,#0
001f48  1a000004          BNE      |L1.8032|
;;;1229   				    !(mtd->ecc_stats.failed - stats.failed))
001f4c  e5950084          LDR      r0,[r5,#0x84]
001f50  e59d102c          LDR      r1,[sp,#0x2c]
001f54  e0500001          SUBS     r0,r0,r1
001f58  1a000000          BNE      |L1.8032|
;;;1230   					chip->pagebuf = realpage;
001f5c  e5849074          STR      r9,[r4,#0x74]
                  |L1.8032|
;;;1231   				memcpy(buf, chip->buffers->databuf + col, bytes);
001f60  e59400e8          LDR      r0,[r4,#0xe8]
001f64  e2800d12          ADD      r0,r0,#0x480
001f68  e080100a          ADD      r1,r0,r10
001f6c  e59d0004          LDR      r0,[sp,#4]
001f70  e59d203c          LDR      r2,[sp,#0x3c]
001f74  ebfffffe          BL       __aeabi_memcpy
                  |L1.8056|
;;;1232   			}
;;;1233   
;;;1234   			buf += bytes;
001f78  e59d0004          LDR      r0,[sp,#4]
001f7c  e59d103c          LDR      r1,[sp,#0x3c]
001f80  e0800001          ADD      r0,r0,r1
001f84  e58d0004          STR      r0,[sp,#4]
;;;1235   
;;;1236   			if (oob) {
001f88  e59d0008          LDR      r0,[sp,#8]
001f8c  e3500000          CMP      r0,#0
001f90  0a000015          BEQ      |L1.8172|
;;;1237   
;;;1238   				int toread = min(oobreadlen, max_oobsize);
001f94  e59d0014          LDR      r0,[sp,#0x14]
001f98  e59d1010          LDR      r1,[sp,#0x10]
001f9c  e1500001          CMP      r0,r1
001fa0  9a000001          BLS      |L1.8108|
001fa4  e59d0010          LDR      r0,[sp,#0x10]
001fa8  ea000000          B        |L1.8112|
                  |L1.8108|
001fac  e59d0014          LDR      r0,[sp,#0x14]
                  |L1.8112|
001fb0  e58d0000          STR      r0,[sp,#0]
;;;1239   
;;;1240   				if (toread) {
001fb4  e59d0000          LDR      r0,[sp,#0]
001fb8  e3500000          CMP      r0,#0
001fbc  0a000009          BEQ      |L1.8168|
;;;1241   					oob = nand_transfer_oob(chip,
001fc0  e1a02006          MOV      r2,r6
001fc4  e1a00004          MOV      r0,r4
001fc8  e59d1008          LDR      r1,[sp,#8]
001fcc  e59d3000          LDR      r3,[sp,#0]
001fd0  ebfffffe          BL       nand_transfer_oob
001fd4  e58d0008          STR      r0,[sp,#8]
;;;1242   						oob, ops, toread);
;;;1243   					oobreadlen -= toread;
001fd8  e59d0014          LDR      r0,[sp,#0x14]
001fdc  e59d1000          LDR      r1,[sp,#0]
001fe0  e0400001          SUB      r0,r0,r1
001fe4  e58d0014          STR      r0,[sp,#0x14]
                  |L1.8168|
;;;1244   				}
;;;1245   			}
001fe8  e1a00000          MOV      r0,r0
                  |L1.8172|
;;;1246   
;;;1247   			if (!(chip->options & NAND_NO_READRDY)) {
001fec  e1d405b0          LDRH     r0,[r4,#0x50]
001ff0  e3100c01          TST      r0,#0x100
001ff4  1a000012          BNE      |L1.8260|
;;;1248   				/*
;;;1249   				 * Apply delay or wait for ready/busy pin. Do
;;;1250   				 * this before the AUTOINCR check, so no
;;;1251   				 * problems arise if a chip which does auto
;;;1252   				 * increment is marked as NOAUTOINCR by the
;;;1253   				 * board driver.
;;;1254   				 */
;;;1255   				if (!chip->dev_ready)
001ff8  e5940030          LDR      r0,[r4,#0x30]
001ffc  e3500000          CMP      r0,#0
002000  1a000002          BNE      |L1.8208|
;;;1256   					udelay(chip->chip_delay);
002004  e594004c          LDR      r0,[r4,#0x4c]
002008  ebfffffe          BL       udelay
00200c  ea00000c          B        |L1.8260|
                  |L1.8208|
;;;1257   				else
;;;1258   					nand_wait_ready(mtd);
002010  e1a00005          MOV      r0,r5
002014  ebfffffe          BL       nand_wait_ready
002018  ea000009          B        |L1.8260|
                  |L1.8220|
;;;1259   			}
;;;1260   		} else {
;;;1261   			memcpy(buf, chip->buffers->databuf + col, bytes);
00201c  e59400e8          LDR      r0,[r4,#0xe8]
002020  e2800d12          ADD      r0,r0,#0x480
002024  e080100a          ADD      r1,r0,r10
002028  e59d0004          LDR      r0,[sp,#4]
00202c  e59d203c          LDR      r2,[sp,#0x3c]
002030  ebfffffe          BL       __aeabi_memcpy
;;;1262   			buf += bytes;
002034  e59d0004          LDR      r0,[sp,#4]
002038  e59d103c          LDR      r1,[sp,#0x3c]
00203c  e0800001          ADD      r0,r0,r1
002040  e58d0004          STR      r0,[sp,#4]
                  |L1.8260|
;;;1263   		}
;;;1264   
;;;1265   		readlen -= bytes;
002044  e59d0018          LDR      r0,[sp,#0x18]
002048  e59d103c          LDR      r1,[sp,#0x3c]
00204c  e0400001          SUB      r0,r0,r1
002050  e58d0018          STR      r0,[sp,#0x18]
;;;1266   
;;;1267   		if (!readlen)
002054  e59d0018          LDR      r0,[sp,#0x18]
002058  e3500000          CMP      r0,#0
00205c  1a000000          BNE      |L1.8292|
;;;1268   			break;
002060  ea00001c          B        |L1.8408|
                  |L1.8292|
;;;1269   
;;;1270   		/* For subsequent reads align to page boundary. */
;;;1271   		col = 0;
002064  e3a0a000          MOV      r10,#0
;;;1272   		/* Increment page address */
;;;1273   		realpage++;
002068  e2899001          ADD      r9,r9,#1
;;;1274   
;;;1275   		page = realpage & chip->pagemask;
00206c  e5940070          LDR      r0,[r4,#0x70]
002070  e0000009          AND      r0,r0,r9
002074  e58d0040          STR      r0,[sp,#0x40]
;;;1276   		/* Check, if we cross a chip boundary */
;;;1277   		if (!page) {
002078  e59d0040          LDR      r0,[sp,#0x40]
00207c  e3500000          CMP      r0,#0
002080  1a00000a          BNE      |L1.8368|
;;;1278   			chipnr++;
002084  e59d0044          LDR      r0,[sp,#0x44]
002088  e2800001          ADD      r0,r0,#1
00208c  e58d0044          STR      r0,[sp,#0x44]
;;;1279   			chip->select_chip(mtd, -1);
002090  e3e01000          MVN      r1,#0
002094  e1a00005          MOV      r0,r5
002098  e594201c          LDR      r2,[r4,#0x1c]
00209c  e12fff32          BLX      r2
;;;1280   			chip->select_chip(mtd, chipnr);
0020a0  e594201c          LDR      r2,[r4,#0x1c]
0020a4  e1a00005          MOV      r0,r5
0020a8  e59d1044          LDR      r1,[sp,#0x44]
0020ac  e12fff32          BLX      r2
                  |L1.8368|
;;;1281   		}
;;;1282   
;;;1283   		/* Check, if the chip supports auto page increment
;;;1284   		 * or if we have hit a block boundary.
;;;1285   		 */
;;;1286   		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
0020b0  e5d40050          LDRB     r0,[r4,#0x50]
0020b4  e3100001          TST      r0,#1
0020b8  1a000003          BNE      |L1.8396|
0020bc  e59d0040          LDR      r0,[sp,#0x40]
0020c0  e59d1024          LDR      r1,[sp,#0x24]
0020c4  e1100001          TST      r0,r1
0020c8  1a000001          BNE      |L1.8404|
                  |L1.8396|
;;;1287   			sndcmd = 1;
0020cc  e3a00001          MOV      r0,#1
0020d0  e58d0020          STR      r0,[sp,#0x20]
                  |L1.8404|
0020d4  eaffff3f          B        |L1.7640|
                  |L1.8408|
0020d8  e1a00000          MOV      r0,r0                 ;1224
;;;1288   	}
;;;1289   
;;;1290   	ops->retlen = ops->len - (size_t) readlen;
0020dc  e5961004          LDR      r1,[r6,#4]
0020e0  e59d0018          LDR      r0,[sp,#0x18]
0020e4  e0410000          SUB      r0,r1,r0
0020e8  e5860008          STR      r0,[r6,#8]
;;;1291   	if (oob)
0020ec  e59d0008          LDR      r0,[sp,#8]
0020f0  e3500000          CMP      r0,#0
0020f4  0a000003          BEQ      |L1.8456|
;;;1292   		ops->oobretlen = ops->ooblen - oobreadlen;
0020f8  e596100c          LDR      r1,[r6,#0xc]
0020fc  e59d0014          LDR      r0,[sp,#0x14]
002100  e0410000          SUB      r0,r1,r0
002104  e5860010          STR      r0,[r6,#0x10]
                  |L1.8456|
;;;1293   
;;;1294   	if (ret)
002108  e59d001c          LDR      r0,[sp,#0x1c]
00210c  e3500000          CMP      r0,#0
002110  0a000002          BEQ      |L1.8480|
;;;1295   		return ret;
002114  e59d001c          LDR      r0,[sp,#0x1c]
                  |L1.8472|
002118  e28dd054          ADD      sp,sp,#0x54
;;;1296   
;;;1297   	if (mtd->ecc_stats.failed - stats.failed)
;;;1298   		return -EBADMSG;
;;;1299   
;;;1300   	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
;;;1301   }
00211c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.8480|
002120  e5950084          LDR      r0,[r5,#0x84]         ;1297
002124  e59d102c          LDR      r1,[sp,#0x2c]         ;1297
002128  e0500001          SUBS     r0,r0,r1              ;1297
00212c  0a000001          BEQ      |L1.8504|
002130  e3e00049          MVN      r0,#0x49              ;1298
002134  eafffff7          B        |L1.8472|
                  |L1.8504|
002138  e5950080          LDR      r0,[r5,#0x80]         ;1300
00213c  e59d1028          LDR      r1,[sp,#0x28]         ;1300
002140  e0500001          SUBS     r0,r0,r1              ;1300
002144  0a000001          BEQ      |L1.8528|
002148  e3e00074          MVN      r0,#0x74              ;1300
00214c  eafffff1          B        |L1.8472|
                  |L1.8528|
002150  e3a00000          MOV      r0,#0                 ;1300
002154  eaffffef          B        |L1.8472|
;;;1302   
                          ENDP

                  nand_read PROC
;;;1312    */
;;;1313   static int nand_read(struct mtd_info *mtd, loff_t from, size_t len,
002158  e92d4ff8          PUSH     {r3-r11,lr}
;;;1314   		     size_t *retlen, uint8_t *buf)
;;;1315   {
00215c  e1a06000          MOV      r6,r0
002160  e1a07002          MOV      r7,r2
002164  e1a08003          MOV      r8,r3
002168  e28db028          ADD      r11,sp,#0x28
00216c  e89b0c20          LDM      r11,{r5,r10,r11}
;;;1316   	struct nand_chip *chip = mtd->priv;
002170  e5964094          LDR      r4,[r6,#0x94]
;;;1317   	int ret;
;;;1318   
;;;1319   	/* Do not allow reads past end of device */
;;;1320   	if ((from + len) > mtd->size)
002174  e0973005          ADDS     r3,r7,r5
002178  e2a82000          ADC      r2,r8,#0
00217c  e1c600d8          LDRD     r0,r1,[r6,#8]
002180  e0500003          SUBS     r0,r0,r3
002184  e0d10002          SBCS     r0,r1,r2
002188  2a000001          BCS      |L1.8596|
;;;1321   		return -EINVAL;
00218c  e3e00015          MVN      r0,#0x15
                  |L1.8592|
;;;1322   	if (!len)
;;;1323   		return 0;
;;;1324   
;;;1325   	nand_get_device(chip, mtd, FL_READING);
;;;1326   
;;;1327   	chip->ops.len = len;
;;;1328   	chip->ops.datbuf = buf;
;;;1329   	chip->ops.oobbuf = NULL;
;;;1330   
;;;1331   	ret = nand_do_read_ops(mtd, from, &chip->ops);
;;;1332   
;;;1333   	*retlen = chip->ops.retlen;
;;;1334   
;;;1335   	nand_release_device(mtd);
;;;1336   
;;;1337   	return ret;
;;;1338   }
002190  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.8596|
002194  e3550000          CMP      r5,#0                 ;1322
002198  1a000001          BNE      |L1.8612|
00219c  e3a00000          MOV      r0,#0                 ;1323
0021a0  eafffffa          B        |L1.8592|
                  |L1.8612|
0021a4  e3a02001          MOV      r2,#1                 ;1325
0021a8  e1a01006          MOV      r1,r6                 ;1325
0021ac  e1a00004          MOV      r0,r4                 ;1325
0021b0  ebfffffe          BL       nand_get_device
0021b4  e58450f4          STR      r5,[r4,#0xf4]         ;1327
0021b8  e584b108          STR      r11,[r4,#0x108]       ;1328
0021bc  e3a00000          MOV      r0,#0                 ;1329
0021c0  e584010c          STR      r0,[r4,#0x10c]        ;1329
0021c4  e28400f0          ADD      r0,r4,#0xf0           ;1331
0021c8  e1a02007          MOV      r2,r7                 ;1331
0021cc  e1a03008          MOV      r3,r8                 ;1331
0021d0  e58d0000          STR      r0,[sp,#0]            ;1331
0021d4  e1a00006          MOV      r0,r6                 ;1331
0021d8  ebfffffe          BL       nand_do_read_ops
0021dc  e1a09000          MOV      r9,r0                 ;1331
0021e0  e59400f8          LDR      r0,[r4,#0xf8]         ;1333
0021e4  e58a0000          STR      r0,[r10,#0]           ;1333
0021e8  e1a00006          MOV      r0,r6                 ;1335
0021ec  ebfffffe          BL       nand_release_device
0021f0  e1a00009          MOV      r0,r9                 ;1337
0021f4  eaffffe5          B        |L1.8592|
;;;1339   
                          ENDP

                  nand_read_oob_std PROC
;;;1346    */
;;;1347   static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
0021f8  e92d41f0          PUSH     {r4-r8,lr}
;;;1348   			     int page, int sndcmd)
;;;1349   {
0021fc  e1a06000          MOV      r6,r0
002200  e1a04001          MOV      r4,r1
002204  e1a07002          MOV      r7,r2
002208  e1a05003          MOV      r5,r3
;;;1350   	if (sndcmd) {
00220c  e3550000          CMP      r5,#0
002210  0a000006          BEQ      |L1.8752|
;;;1351   		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
002214  e1a03007          MOV      r3,r7
002218  e3a02000          MOV      r2,#0
00221c  e3a01050          MOV      r1,#0x50
002220  e1a00006          MOV      r0,r6
002224  e594c034          LDR      r12,[r4,#0x34]
002228  e12fff3c          BLX      r12
;;;1352   		sndcmd = 0;
00222c  e3a05000          MOV      r5,#0
                  |L1.8752|
;;;1353   	}
;;;1354   	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
002230  e5962018          LDR      r2,[r6,#0x18]
002234  e1a00006          MOV      r0,r6
002238  e5941090          LDR      r1,[r4,#0x90]
00223c  e5943014          LDR      r3,[r4,#0x14]
002240  e12fff33          BLX      r3
;;;1355   	return sndcmd;
002244  e1a00005          MOV      r0,r5
;;;1356   }
002248  e8bd81f0          POP      {r4-r8,pc}
;;;1357   
                          ENDP

                  nand_read_oob_syndrome PROC
;;;1365    */
;;;1366   static int nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
00224c  e92d5fff          PUSH     {r0-r12,lr}
;;;1367   				  int page, int sndcmd)
;;;1368   {
002250  e1a06000          MOV      r6,r0
002254  e1a04001          MOV      r4,r1
002258  e1a09002          MOV      r9,r2
;;;1369   	uint8_t *buf = chip->oob_poi;
00225c  e5940090          LDR      r0,[r4,#0x90]
002260  e58d000c          STR      r0,[sp,#0xc]
;;;1370   	int length = mtd->oobsize;
002264  e5965018          LDR      r5,[r6,#0x18]
;;;1371   	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
002268  e59400a8          LDR      r0,[r4,#0xa8]
00226c  e59410b0          LDR      r1,[r4,#0xb0]
002270  e0800001          ADD      r0,r0,r1
002274  e59410b4          LDR      r1,[r4,#0xb4]
002278  e080a001          ADD      r10,r0,r1
;;;1372   	int eccsize = chip->ecc.size;
00227c  e594b0a4          LDR      r11,[r4,#0xa4]
;;;1373   	uint8_t *bufpoi = buf;
002280  e59d000c          LDR      r0,[sp,#0xc]
002284  e58d0008          STR      r0,[sp,#8]
;;;1374   	int i, toread, sndrnd = 0, pos;
002288  e3a00000          MOV      r0,#0
00228c  e58d0004          STR      r0,[sp,#4]
;;;1375   
;;;1376   	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
002290  e1a03009          MOV      r3,r9
002294  e3a01000          MOV      r1,#0
002298  e1a00006          MOV      r0,r6
00229c  e59420a4          LDR      r2,[r4,#0xa4]
0022a0  e594c034          LDR      r12,[r4,#0x34]
0022a4  e12fff3c          BLX      r12
;;;1377   	for (i = 0; i < chip->ecc.steps; i++) {
0022a8  e3a07000          MOV      r7,#0
0022ac  ea000028          B        |L1.9044|
                  |L1.8880|
;;;1378   		if (sndrnd) {
0022b0  e59d0004          LDR      r0,[sp,#4]
0022b4  e3500000          CMP      r0,#0
0022b8  0a000013          BEQ      |L1.8972|
;;;1379   			pos = eccsize + i * (eccsize + chunk);
0022bc  e08b000a          ADD      r0,r11,r10
0022c0  e020b097          MLA      r0,r7,r0,r11
0022c4  e58d0000          STR      r0,[sp,#0]
;;;1380   			if (mtd->writesize > 512)
0022c8  e5960014          LDR      r0,[r6,#0x14]
0022cc  e3500c02          CMP      r0,#0x200
0022d0  9a000006          BLS      |L1.8944|
;;;1381   				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
0022d4  e3e03000          MVN      r3,#0
0022d8  e594c034          LDR      r12,[r4,#0x34]
0022dc  e3a01005          MOV      r1,#5
0022e0  e1a00006          MOV      r0,r6
0022e4  e59d2000          LDR      r2,[sp,#0]
0022e8  e12fff3c          BLX      r12
0022ec  ea000008          B        |L1.8980|
                  |L1.8944|
;;;1382   			else
;;;1383   				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
0022f0  e1a03009          MOV      r3,r9
0022f4  e594c034          LDR      r12,[r4,#0x34]
0022f8  e3a01000          MOV      r1,#0
0022fc  e1a00006          MOV      r0,r6
002300  e59d2000          LDR      r2,[sp,#0]
002304  e12fff3c          BLX      r12
002308  ea000001          B        |L1.8980|
                  |L1.8972|
;;;1384   		} else
;;;1385   			sndrnd = 1;
00230c  e3a00001          MOV      r0,#1
002310  e58d0004          STR      r0,[sp,#4]
                  |L1.8980|
;;;1386   		toread = min_t(int, length, chunk);
002314  e155000a          CMP      r5,r10
002318  aa000001          BGE      |L1.8996|
00231c  e1a00005          MOV      r0,r5
002320  ea000000          B        |L1.9000|
                  |L1.8996|
002324  e1a0000a          MOV      r0,r10
                  |L1.9000|
002328  e1a08000          MOV      r8,r0
;;;1387   		chip->read_buf(mtd, bufpoi, toread);
00232c  e1a02008          MOV      r2,r8
002330  e5943014          LDR      r3,[r4,#0x14]
002334  e1a00006          MOV      r0,r6
002338  e59d1008          LDR      r1,[sp,#8]
00233c  e12fff33          BLX      r3
;;;1388   		bufpoi += toread;
002340  e59d0008          LDR      r0,[sp,#8]
002344  e0800008          ADD      r0,r0,r8
002348  e58d0008          STR      r0,[sp,#8]
;;;1389   		length -= toread;
00234c  e0455008          SUB      r5,r5,r8
002350  e2877001          ADD      r7,r7,#1              ;1377
                  |L1.9044|
002354  e59400a0          LDR      r0,[r4,#0xa0]         ;1377
002358  e1500007          CMP      r0,r7                 ;1377
00235c  caffffd3          BGT      |L1.8880|
;;;1390   	}
;;;1391   	if (length > 0)
002360  e3550000          CMP      r5,#0
002364  da000004          BLE      |L1.9084|
;;;1392   		chip->read_buf(mtd, bufpoi, length);
002368  e1a02005          MOV      r2,r5
00236c  e5943014          LDR      r3,[r4,#0x14]
002370  e1a00006          MOV      r0,r6
002374  e59d1008          LDR      r1,[sp,#8]
002378  e12fff33          BLX      r3
                  |L1.9084|
;;;1393   
;;;1394   	return 1;
00237c  e3a00001          MOV      r0,#1
002380  e28dd010          ADD      sp,sp,#0x10
;;;1395   }
002384  e8bd9ff0          POP      {r4-r12,pc}
;;;1396   
                          ENDP

                  nand_write_oob_std PROC
;;;1402    */
;;;1403   static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
002388  e92d47f0          PUSH     {r4-r10,lr}
;;;1404   			      int page)
;;;1405   {
00238c  e1a05000          MOV      r5,r0
002390  e1a04001          MOV      r4,r1
002394  e1a06002          MOV      r6,r2
;;;1406   	int status = 0;
002398  e3a07000          MOV      r7,#0
;;;1407   	const uint8_t *buf = chip->oob_poi;
00239c  e5948090          LDR      r8,[r4,#0x90]
;;;1408   	int length = mtd->oobsize;
0023a0  e5959018          LDR      r9,[r5,#0x18]
;;;1409   
;;;1410   	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
0023a4  e5952014          LDR      r2,[r5,#0x14]
0023a8  e1a03006          MOV      r3,r6
0023ac  e3a01080          MOV      r1,#0x80
0023b0  e1a00005          MOV      r0,r5
0023b4  e594c034          LDR      r12,[r4,#0x34]
0023b8  e12fff3c          BLX      r12
;;;1411   	chip->write_buf(mtd, buf, length);
0023bc  e1a02009          MOV      r2,r9
0023c0  e1a01008          MOV      r1,r8
0023c4  e1a00005          MOV      r0,r5
0023c8  e5943010          LDR      r3,[r4,#0x10]
0023cc  e12fff33          BLX      r3
;;;1412   	/* Send command to program the OOB data */
;;;1413   	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
0023d0  e3e03000          MVN      r3,#0
0023d4  e1a02003          MOV      r2,r3
0023d8  e3a01010          MOV      r1,#0x10
0023dc  e1a00005          MOV      r0,r5
0023e0  e594c034          LDR      r12,[r4,#0x34]
0023e4  e12fff3c          BLX      r12
;;;1414   
;;;1415   	status = chip->waitfunc(mtd, chip);
0023e8  e5942038          LDR      r2,[r4,#0x38]
0023ec  e1a01004          MOV      r1,r4
0023f0  e1a00005          MOV      r0,r5
0023f4  e12fff32          BLX      r2
0023f8  e1a07000          MOV      r7,r0
;;;1416   
;;;1417   	return status & NAND_STATUS_FAIL ? -EIO : 0;
0023fc  e3170001          TST      r7,#1
002400  0a000001          BEQ      |L1.9228|
002404  e3e00004          MVN      r0,#4
                  |L1.9224|
;;;1418   }
002408  e8bd87f0          POP      {r4-r10,pc}
                  |L1.9228|
00240c  e3a00000          MOV      r0,#0                 ;1417
002410  eafffffc          B        |L1.9224|
;;;1419   
                          ENDP

                  nand_write_oob_syndrome PROC
;;;1426    */
;;;1427   static int nand_write_oob_syndrome(struct mtd_info *mtd,
002414  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1428   				   struct nand_chip *chip, int page)
;;;1429   {
002418  e24dd018          SUB      sp,sp,#0x18
00241c  e1a09000          MOV      r9,r0
002420  e1a04001          MOV      r4,r1
;;;1430   	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
002424  e59400a8          LDR      r0,[r4,#0xa8]
002428  e59410b0          LDR      r1,[r4,#0xb0]
00242c  e0800001          ADD      r0,r0,r1
002430  e59410b4          LDR      r1,[r4,#0xb4]
002434  e080a001          ADD      r10,r0,r1
;;;1431   	int eccsize = chip->ecc.size, length = mtd->oobsize;
002438  e59460a4          LDR      r6,[r4,#0xa4]
00243c  e5997018          LDR      r7,[r9,#0x18]
;;;1432   	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
002440  e3a00000          MOV      r0,#0
002444  e58d0014          STR      r0,[sp,#0x14]
002448  e58d0010          STR      r0,[sp,#0x10]
00244c  e59400a0          LDR      r0,[r4,#0xa0]
002450  e58d000c          STR      r0,[sp,#0xc]
;;;1433   	const uint8_t *bufpoi = chip->oob_poi;
002454  e5940090          LDR      r0,[r4,#0x90]
002458  e58d0008          STR      r0,[sp,#8]
;;;1434   
;;;1435   	/*
;;;1436   	 * data-ecc-data-ecc ... ecc-oob
;;;1437   	 * or
;;;1438   	 * data-pad-ecc-pad-data-pad .... ecc-pad-oob
;;;1439   	 */
;;;1440   	if (!chip->ecc.prepad && !chip->ecc.postpad) {
00245c  e59400b0          LDR      r0,[r4,#0xb0]
002460  e3500000          CMP      r0,#0
002464  1a000008          BNE      |L1.9356|
002468  e59400b4          LDR      r0,[r4,#0xb4]
00246c  e3500000          CMP      r0,#0
002470  1a000005          BNE      |L1.9356|
;;;1441   		pos = steps * (eccsize + chunk);
002474  e086100a          ADD      r1,r6,r10
002478  e59d000c          LDR      r0,[sp,#0xc]
00247c  e00b0091          MUL      r11,r1,r0
;;;1442   		steps = 0;
002480  e3a00000          MOV      r0,#0
002484  e58d000c          STR      r0,[sp,#0xc]
002488  ea000000          B        |L1.9360|
                  |L1.9356|
;;;1443   	} else
;;;1444   		pos = eccsize;
00248c  e1a0b006          MOV      r11,r6
                  |L1.9360|
;;;1445   
;;;1446   	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
002490  e594c034          LDR      r12,[r4,#0x34]
002494  e1a0200b          MOV      r2,r11
002498  e3a01080          MOV      r1,#0x80
00249c  e1a00009          MOV      r0,r9
0024a0  e59d3020          LDR      r3,[sp,#0x20]
0024a4  e12fff3c          BLX      r12
;;;1447   	for (i = 0; i < steps; i++) {
0024a8  e3a08000          MOV      r8,#0
0024ac  ea000035          B        |L1.9608|
                  |L1.9392|
;;;1448   		if (sndcmd) {
0024b0  e59d0010          LDR      r0,[sp,#0x10]
0024b4  e3500000          CMP      r0,#0
0024b8  0a000020          BEQ      |L1.9536|
;;;1449   			if (mtd->writesize <= 512) {
0024bc  e5990014          LDR      r0,[r9,#0x14]
0024c0  e3500c02          CMP      r0,#0x200
0024c4  8a000014          BHI      |L1.9500|
;;;1450   				uint32_t fill = 0xFFFFFFFF;
0024c8  e3e00000          MVN      r0,#0
0024cc  e58d0004          STR      r0,[sp,#4]
;;;1451   
;;;1452   				len = eccsize;
0024d0  e1a05006          MOV      r5,r6
;;;1453   				while (len > 0) {
0024d4  ea00000d          B        |L1.9488|
                  |L1.9432|
;;;1454   					int num = min_t(int, len, 4);
0024d8  e3550004          CMP      r5,#4
0024dc  aa000001          BGE      |L1.9448|
0024e0  e1a00005          MOV      r0,r5
0024e4  ea000000          B        |L1.9452|
                  |L1.9448|
0024e8  e3a00004          MOV      r0,#4
                  |L1.9452|
0024ec  e58d0000          STR      r0,[sp,#0]
;;;1455   					chip->write_buf(mtd, (uint8_t *)&fill,
0024f0  e5943010          LDR      r3,[r4,#0x10]
0024f4  e59d2000          LDR      r2,[sp,#0]
0024f8  e28d1004          ADD      r1,sp,#4
0024fc  e1a00009          MOV      r0,r9
002500  e12fff33          BLX      r3
;;;1456   							num);
;;;1457   					len -= num;
002504  e59d0000          LDR      r0,[sp,#0]
002508  e0455000          SUB      r5,r5,r0
;;;1458   				}
00250c  e1a00000          MOV      r0,r0
                  |L1.9488|
002510  e3550000          CMP      r5,#0                 ;1453
002514  caffffef          BGT      |L1.9432|
;;;1459   			} else {
002518  ea00000a          B        |L1.9544|
                  |L1.9500|
;;;1460   				pos = eccsize + i * (eccsize + chunk);
00251c  e086000a          ADD      r0,r6,r10
002520  e02b6098          MLA      r11,r8,r0,r6
;;;1461   				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
002524  e3e03000          MVN      r3,#0
002528  e1a0200b          MOV      r2,r11
00252c  e3a01085          MOV      r1,#0x85
002530  e1a00009          MOV      r0,r9
002534  e594c034          LDR      r12,[r4,#0x34]
002538  e12fff3c          BLX      r12
00253c  ea000001          B        |L1.9544|
                  |L1.9536|
;;;1462   			}
;;;1463   		} else
;;;1464   			sndcmd = 1;
002540  e3a00001          MOV      r0,#1
002544  e58d0010          STR      r0,[sp,#0x10]
                  |L1.9544|
;;;1465   		len = min_t(int, length, chunk);
002548  e157000a          CMP      r7,r10
00254c  aa000001          BGE      |L1.9560|
002550  e1a00007          MOV      r0,r7
002554  ea000000          B        |L1.9564|
                  |L1.9560|
002558  e1a0000a          MOV      r0,r10
                  |L1.9564|
00255c  e1a05000          MOV      r5,r0
;;;1466   		chip->write_buf(mtd, bufpoi, len);
002560  e1a02005          MOV      r2,r5
002564  e5943010          LDR      r3,[r4,#0x10]
002568  e1a00009          MOV      r0,r9
00256c  e59d1008          LDR      r1,[sp,#8]
002570  e12fff33          BLX      r3
;;;1467   		bufpoi += len;
002574  e59d0008          LDR      r0,[sp,#8]
002578  e0800005          ADD      r0,r0,r5
00257c  e58d0008          STR      r0,[sp,#8]
;;;1468   		length -= len;
002580  e0477005          SUB      r7,r7,r5
002584  e2888001          ADD      r8,r8,#1              ;1447
                  |L1.9608|
002588  e59d000c          LDR      r0,[sp,#0xc]          ;1447
00258c  e1580000          CMP      r8,r0                 ;1447
002590  baffffc6          BLT      |L1.9392|
;;;1469   	}
;;;1470   	if (length > 0)
002594  e3570000          CMP      r7,#0
002598  da000004          BLE      |L1.9648|
;;;1471   		chip->write_buf(mtd, bufpoi, length);
00259c  e1a02007          MOV      r2,r7
0025a0  e5943010          LDR      r3,[r4,#0x10]
0025a4  e1a00009          MOV      r0,r9
0025a8  e59d1008          LDR      r1,[sp,#8]
0025ac  e12fff33          BLX      r3
                  |L1.9648|
;;;1472   
;;;1473   	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
0025b0  e3e03000          MVN      r3,#0
0025b4  e1a02003          MOV      r2,r3
0025b8  e3a01010          MOV      r1,#0x10
0025bc  e1a00009          MOV      r0,r9
0025c0  e594c034          LDR      r12,[r4,#0x34]
0025c4  e12fff3c          BLX      r12
;;;1474   	status = chip->waitfunc(mtd, chip);
0025c8  e5942038          LDR      r2,[r4,#0x38]
0025cc  e1a01004          MOV      r1,r4
0025d0  e1a00009          MOV      r0,r9
0025d4  e12fff32          BLX      r2
0025d8  e58d0014          STR      r0,[sp,#0x14]
;;;1475   
;;;1476   	return status & NAND_STATUS_FAIL ? -EIO : 0;
0025dc  e59d0014          LDR      r0,[sp,#0x14]
0025e0  e3100001          TST      r0,#1
0025e4  0a000002          BEQ      |L1.9716|
0025e8  e3e00004          MVN      r0,#4
                  |L1.9708|
0025ec  e28dd024          ADD      sp,sp,#0x24
;;;1477   }
0025f0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.9716|
0025f4  e3a00000          MOV      r0,#0                 ;1476
0025f8  eafffffb          B        |L1.9708|
;;;1478   
                          ENDP

                  nand_do_read_oob PROC
;;;1486    */
;;;1487   static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
0025fc  e92d4ff0          PUSH     {r4-r11,lr}
;;;1488   			    struct mtd_oob_ops *ops)
;;;1489   {
002600  e24dd03c          SUB      sp,sp,#0x3c
002604  e1a0b000          MOV      r11,r0
002608  e1a05002          MOV      r5,r2
00260c  e1a06003          MOV      r6,r3
002610  e59da060          LDR      r10,[sp,#0x60]
;;;1490   	int page, realpage, chipnr, sndcmd = 1;
002614  e3a00001          MOV      r0,#1
002618  e58d000c          STR      r0,[sp,#0xc]
;;;1491   	struct nand_chip *chip = mtd->priv;
00261c  e59b4094          LDR      r4,[r11,#0x94]
;;;1492   	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
002620  e5d40058          LDRB     r0,[r4,#0x58]
002624  e5d41054          LDRB     r1,[r4,#0x54]
002628  e0400001          SUB      r0,r0,r1
00262c  e3a01001          MOV      r1,#1
002630  e1a00011          LSL      r0,r1,r0
002634  e2400001          SUB      r0,r0,#1
002638  e58d0008          STR      r0,[sp,#8]
;;;1493   	int readlen = ops->ooblen;
00263c  e59a000c          LDR      r0,[r10,#0xc]
002640  e58d0004          STR      r0,[sp,#4]
;;;1494   	int len;
;;;1495   	uint8_t *buf = ops->oobbuf;
002644  e59a001c          LDR      r0,[r10,#0x1c]
002648  e58d0000          STR      r0,[sp,#0]
;;;1496   
;;;1497   	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
00264c  e1a00000          MOV      r0,r0
002650  e1a00000          MOV      r0,r0
;;;1498   			__func__, (unsigned long long)from, readlen);
;;;1499   
;;;1500   	if (ops->mode == MTD_OOB_AUTO)
002654  e5da0000          LDRB     r0,[r10,#0]
002658  e3500001          CMP      r0,#1
00265c  1a000002          BNE      |L1.9836|
;;;1501   		len = chip->ecc.layout->oobavail;
002660  e59400b8          LDR      r0,[r4,#0xb8]
002664  e5909204          LDR      r9,[r0,#0x204]
002668  ea000000          B        |L1.9840|
                  |L1.9836|
;;;1502   	else
;;;1503   		len = mtd->oobsize;
00266c  e59b9018          LDR      r9,[r11,#0x18]
                  |L1.9840|
;;;1504   
;;;1505   	if (ops->ooboffs >= len) {
002670  e59a0014          LDR      r0,[r10,#0x14]
002674  e1500009          CMP      r0,r9
002678  3a000004          BCC      |L1.9872|
;;;1506   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start read "
00267c  e1a00000          MOV      r0,r0
002680  e1a00000          MOV      r0,r0
;;;1507   					"outside oob\n", __func__);
;;;1508   		return -EINVAL;
002684  e3e00015          MVN      r0,#0x15
                  |L1.9864|
002688  e28dd03c          ADD      sp,sp,#0x3c
;;;1509   	}
;;;1510   
;;;1511   	/* Do not allow reads past end of device */
;;;1512   	if (from >= mtd->size || ops->ooboffs + readlen > ((mtd->size >> chip->page_shift) - (from >> chip->page_shift)) * len) {
;;;1513   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "
;;;1514   					"of device\n", __func__);
;;;1515   		return -EINVAL;
;;;1516   	}
;;;1517   
;;;1518   	chipnr = (int)(from >> chip->chip_shift);
;;;1519   	chip->select_chip(mtd, chipnr);
;;;1520   
;;;1521   	/* Shift to get page */
;;;1522   	realpage = (int)(from >> chip->page_shift);
;;;1523   	page = realpage & chip->pagemask;
;;;1524   
;;;1525   	while (1) {
;;;1526   		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
;;;1527   
;;;1528   		len = min(len, readlen);
;;;1529   		buf = nand_transfer_oob(chip, buf, ops, len);
;;;1530   
;;;1531   		if (!(chip->options & NAND_NO_READRDY)) {
;;;1532   			/*
;;;1533   			 * Apply delay or wait for ready/busy pin. Do this
;;;1534   			 * before the AUTOINCR check, so no problems arise if a
;;;1535   			 * chip which does auto increment is marked as
;;;1536   			 * NOAUTOINCR by the board driver.
;;;1537   			 */
;;;1538   			if (!chip->dev_ready)
;;;1539   				udelay(chip->chip_delay);
;;;1540   			else
;;;1541   				nand_wait_ready(mtd);
;;;1542   		}
;;;1543   
;;;1544   		readlen -= len;
;;;1545   		if (!readlen)
;;;1546   			break;
;;;1547   
;;;1548   		/* Increment page address */
;;;1549   		realpage++;
;;;1550   
;;;1551   		page = realpage & chip->pagemask;
;;;1552   		/* Check, if we cross a chip boundary */
;;;1553   		if (!page) {
;;;1554   			chipnr++;
;;;1555   			chip->select_chip(mtd, -1);
;;;1556   			chip->select_chip(mtd, chipnr);
;;;1557   		}
;;;1558   
;;;1559   		/* Check, if the chip supports auto page increment
;;;1560   		 * or if we have hit a block boundary.
;;;1561   		 */
;;;1562   		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
;;;1563   			sndcmd = 1;
;;;1564   	}
;;;1565   
;;;1566   	ops->oobretlen = ops->ooblen;
;;;1567   	return 0;
;;;1568   }
00268c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.9872|
002690  e59b1008          LDR      r1,[r11,#8]           ;1512
002694  e0551001          SUBS     r1,r5,r1              ;1512
002698  e59b000c          LDR      r0,[r11,#0xc]         ;1512
00269c  e0d60000          SBCS     r0,r6,r0              ;1512
0026a0  2a00001b          BCS      |L1.10004|
0026a4  e59b000c          LDR      r0,[r11,#0xc]         ;1512
0026a8  e59b1008          LDR      r1,[r11,#8]           ;1512
0026ac  e5942054          LDR      r2,[r4,#0x54]         ;1512
0026b0  e58d0024          STR      r0,[sp,#0x24]         ;1512
0026b4  e58d1028          STR      r1,[sp,#0x28]         ;1512
0026b8  e1a00001          MOV      r0,r1                 ;1512
0026bc  e59d1024          LDR      r1,[sp,#0x24]         ;1512
0026c0  ebfffffe          BL       __aeabi_llsr
0026c4  e1a07000          MOV      r7,r0                 ;1512
0026c8  e1a08001          MOV      r8,r1                 ;1512
0026cc  e5942054          LDR      r2,[r4,#0x54]         ;1512
0026d0  e58d5020          STR      r5,[sp,#0x20]         ;1512
0026d4  e1a00005          MOV      r0,r5                 ;1512
0026d8  e58d601c          STR      r6,[sp,#0x1c]         ;1512
0026dc  e1a01006          MOV      r1,r6                 ;1512
0026e0  ebfffffe          BL       __aeabi_lasr
0026e4  e0570000          SUBS     r0,r7,r0              ;1512
0026e8  e0c82001          SBC      r2,r8,r1              ;1512
0026ec  e1a03fc9          ASR      r3,r9,#31             ;1512
0026f0  e08c1990          UMULL    r1,r12,r0,r9          ;1512
0026f4  e022c299          MLA      r2,r9,r2,r12          ;1512
0026f8  e0232390          MLA      r3,r0,r3,r2           ;1512
0026fc  e59a2014          LDR      r2,[r10,#0x14]        ;1512
002700  e59d0004          LDR      r0,[sp,#4]            ;1512
002704  e0800002          ADD      r0,r0,r2              ;1512
002708  e0510000          SUBS     r0,r1,r0              ;1512
00270c  e2d30000          SBCS     r0,r3,#0              ;1512
002710  2a000003          BCS      |L1.10020|
                  |L1.10004|
002714  e1a00000          MOV      r0,r0                 ;1513
002718  e1a00000          MOV      r0,r0                 ;1513
00271c  e3e00015          MVN      r0,#0x15              ;1515
002720  eaffffd8          B        |L1.9864|
                  |L1.10020|
002724  e5942060          LDR      r2,[r4,#0x60]         ;1518
002728  e58d5038          STR      r5,[sp,#0x38]         ;1518
00272c  e1a00005          MOV      r0,r5                 ;1518
002730  e58d6034          STR      r6,[sp,#0x34]         ;1518
002734  e1a01006          MOV      r1,r6                 ;1518
002738  ebfffffe          BL       __aeabi_lasr
00273c  e58d0010          STR      r0,[sp,#0x10]         ;1518
002740  e594201c          LDR      r2,[r4,#0x1c]         ;1519
002744  e1a0000b          MOV      r0,r11                ;1519
002748  e59d1010          LDR      r1,[sp,#0x10]         ;1519
00274c  e12fff32          BLX      r2                    ;1519
002750  e5942054          LDR      r2,[r4,#0x54]         ;1522
002754  e58d5030          STR      r5,[sp,#0x30]         ;1522
002758  e1a00005          MOV      r0,r5                 ;1522
00275c  e58d602c          STR      r6,[sp,#0x2c]         ;1522
002760  e1a01006          MOV      r1,r6                 ;1522
002764  ebfffffe          BL       __aeabi_lasr
002768  e58d0014          STR      r0,[sp,#0x14]         ;1522
00276c  e5941070          LDR      r1,[r4,#0x70]         ;1523
002770  e59d0014          LDR      r0,[sp,#0x14]         ;1523
002774  e0000001          AND      r0,r0,r1              ;1523
002778  e58d0018          STR      r0,[sp,#0x18]         ;1523
00277c  ea000043          B        |L1.10384|
                  |L1.10112|
002780  e594c0e0          LDR      r12,[r4,#0xe0]        ;1526
002784  e1a01004          MOV      r1,r4                 ;1526
002788  e1a0000b          MOV      r0,r11                ;1526
00278c  e59d2018          LDR      r2,[sp,#0x18]         ;1526
002790  e59d300c          LDR      r3,[sp,#0xc]          ;1526
002794  e12fff3c          BLX      r12                   ;1526
002798  e58d000c          STR      r0,[sp,#0xc]          ;1526
00279c  e59d0004          LDR      r0,[sp,#4]            ;1528
0027a0  e1590000          CMP      r9,r0                 ;1528
0027a4  da000001          BLE      |L1.10160|
0027a8  e59d0004          LDR      r0,[sp,#4]            ;1528
0027ac  ea000000          B        |L1.10164|
                  |L1.10160|
0027b0  e1a00009          MOV      r0,r9                 ;1528
                  |L1.10164|
0027b4  e1a09000          MOV      r9,r0                 ;1528
0027b8  e1a03009          MOV      r3,r9                 ;1529
0027bc  e1a0200a          MOV      r2,r10                ;1529
0027c0  e1a00004          MOV      r0,r4                 ;1529
0027c4  e59d1000          LDR      r1,[sp,#0]            ;1529
0027c8  ebfffffe          BL       nand_transfer_oob
0027cc  e58d0000          STR      r0,[sp,#0]            ;1529
0027d0  e1d405b0          LDRH     r0,[r4,#0x50]         ;1531
0027d4  e3100c01          TST      r0,#0x100             ;1531
0027d8  1a000007          BNE      |L1.10236|
0027dc  e5940030          LDR      r0,[r4,#0x30]         ;1538
0027e0  e3500000          CMP      r0,#0                 ;1538
0027e4  1a000002          BNE      |L1.10228|
0027e8  e594004c          LDR      r0,[r4,#0x4c]         ;1539
0027ec  ebfffffe          BL       udelay
0027f0  ea000001          B        |L1.10236|
                  |L1.10228|
0027f4  e1a0000b          MOV      r0,r11                ;1541
0027f8  ebfffffe          BL       nand_wait_ready
                  |L1.10236|
0027fc  e59d0004          LDR      r0,[sp,#4]            ;1544
002800  e0400009          SUB      r0,r0,r9              ;1544
002804  e58d0004          STR      r0,[sp,#4]            ;1544
002808  e59d0004          LDR      r0,[sp,#4]            ;1545
00280c  e3500000          CMP      r0,#0                 ;1545
002810  1a000000          BNE      |L1.10264|
002814  ea00001e          B        |L1.10388|
                  |L1.10264|
002818  e59d0014          LDR      r0,[sp,#0x14]         ;1549
00281c  e2800001          ADD      r0,r0,#1              ;1549
002820  e58d0014          STR      r0,[sp,#0x14]         ;1549
002824  e5941070          LDR      r1,[r4,#0x70]         ;1551
002828  e59d0014          LDR      r0,[sp,#0x14]         ;1551
00282c  e0000001          AND      r0,r0,r1              ;1551
002830  e58d0018          STR      r0,[sp,#0x18]         ;1551
002834  e59d0018          LDR      r0,[sp,#0x18]         ;1553
002838  e3500000          CMP      r0,#0                 ;1553
00283c  1a00000a          BNE      |L1.10348|
002840  e59d0010          LDR      r0,[sp,#0x10]         ;1554
002844  e2800001          ADD      r0,r0,#1              ;1554
002848  e58d0010          STR      r0,[sp,#0x10]         ;1554
00284c  e3e01000          MVN      r1,#0                 ;1555
002850  e1a0000b          MOV      r0,r11                ;1555
002854  e594201c          LDR      r2,[r4,#0x1c]         ;1555
002858  e12fff32          BLX      r2                    ;1555
00285c  e594201c          LDR      r2,[r4,#0x1c]         ;1556
002860  e1a0000b          MOV      r0,r11                ;1556
002864  e59d1010          LDR      r1,[sp,#0x10]         ;1556
002868  e12fff32          BLX      r2                    ;1556
                  |L1.10348|
00286c  e5d40050          LDRB     r0,[r4,#0x50]         ;1562
002870  e3100001          TST      r0,#1                 ;1562
002874  1a000003          BNE      |L1.10376|
002878  e59d0018          LDR      r0,[sp,#0x18]         ;1562
00287c  e59d1008          LDR      r1,[sp,#8]            ;1562
002880  e1100001          TST      r0,r1                 ;1562
002884  1a000001          BNE      |L1.10384|
                  |L1.10376|
002888  e3a00001          MOV      r0,#1                 ;1563
00288c  e58d000c          STR      r0,[sp,#0xc]          ;1563
                  |L1.10384|
002890  eaffffba          B        |L1.10112|
                  |L1.10388|
002894  e1a00000          MOV      r0,r0                 ;1546
002898  e59a000c          LDR      r0,[r10,#0xc]         ;1566
00289c  e58a0010          STR      r0,[r10,#0x10]        ;1566
0028a0  e3a00000          MOV      r0,#0                 ;1567
0028a4  eaffff77          B        |L1.9864|
;;;1569   
                          ENDP

                  nand_read_oob PROC
;;;1577    */
;;;1578   static int nand_read_oob(struct mtd_info *mtd, loff_t from,
0028a8  e92d43f8          PUSH     {r3-r9,lr}
;;;1579   			 struct mtd_oob_ops *ops)
;;;1580   {
0028ac  e1a07000          MOV      r7,r0
0028b0  e1a05002          MOV      r5,r2
0028b4  e1a06003          MOV      r6,r3
0028b8  e59d4020          LDR      r4,[sp,#0x20]
;;;1581   	struct nand_chip *chip = mtd->priv;
0028bc  e5978094          LDR      r8,[r7,#0x94]
;;;1582   	int ret = -ENOTSUPP;
0028c0  e59f9208          LDR      r9,|L1.10960|
;;;1583   
;;;1584   	ops->retlen = 0;
0028c4  e3a00000          MOV      r0,#0
0028c8  e5840008          STR      r0,[r4,#8]
;;;1585   
;;;1586   	/* Do not allow reads past end of device */
;;;1587   	if (ops->datbuf && (from + ops->len) > mtd->size) {
0028cc  e5940018          LDR      r0,[r4,#0x18]
0028d0  e3500000          CMP      r0,#0
0028d4  0a00000b          BEQ      |L1.10504|
0028d8  e5971008          LDR      r1,[r7,#8]
0028dc  e597200c          LDR      r2,[r7,#0xc]
0028e0  e5940004          LDR      r0,[r4,#4]
0028e4  e0900005          ADDS     r0,r0,r5
0028e8  e2a63000          ADC      r3,r6,#0
0028ec  e0510000          SUBS     r0,r1,r0
0028f0  e0d20003          SBCS     r0,r2,r3
0028f4  2a000003          BCS      |L1.10504|
;;;1588   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read "
0028f8  e1a00000          MOV      r0,r0
0028fc  e1a00000          MOV      r0,r0
;;;1589   				"beyond end of device\n", __func__);
;;;1590   		return -EINVAL;
002900  e3e00015          MVN      r0,#0x15
                  |L1.10500|
;;;1591   	}
;;;1592   
;;;1593   	nand_get_device(chip, mtd, FL_READING);
;;;1594   
;;;1595   	switch (ops->mode) {
;;;1596   	case MTD_OOB_PLACE:
;;;1597   	case MTD_OOB_AUTO:
;;;1598   	case MTD_OOB_RAW:
;;;1599   		break;
;;;1600   
;;;1601   	default:
;;;1602   		goto out;
;;;1603   	}
;;;1604   
;;;1605   	if (!ops->datbuf)
;;;1606   		ret = nand_do_read_oob(mtd, from, ops);
;;;1607   	else
;;;1608   		ret = nand_do_read_ops(mtd, from, ops);
;;;1609   
;;;1610   out:
;;;1611   	nand_release_device(mtd);
;;;1612   	return ret;
;;;1613   }
002904  e8bd83f8          POP      {r3-r9,pc}
                  |L1.10504|
002908  e3a02001          MOV      r2,#1                 ;1593
00290c  e1a01007          MOV      r1,r7                 ;1593
002910  e1a00008          MOV      r0,r8                 ;1593
002914  ebfffffe          BL       nand_get_device
002918  e5d40000          LDRB     r0,[r4,#0]            ;1595
00291c  e3500000          CMP      r0,#0                 ;1595
002920  0a000004          BEQ      |L1.10552|
002924  e3500001          CMP      r0,#1                 ;1595
002928  0a000004          BEQ      |L1.10560|
00292c  e3500002          CMP      r0,#2                 ;1595
002930  1a000004          BNE      |L1.10568|
002934  ea000002          B        |L1.10564|
                  |L1.10552|
002938  e1a00000          MOV      r0,r0                 ;1596
00293c  e1a00000          MOV      r0,r0                 ;1597
                  |L1.10560|
002940  e1a00000          MOV      r0,r0                 ;1598
                  |L1.10564|
002944  ea000001          B        |L1.10576|
                  |L1.10568|
002948  e1a00000          MOV      r0,r0                 ;1601
00294c  ea000011          B        |L1.10648|
                  |L1.10576|
002950  e1a00000          MOV      r0,r0                 ;1599
002954  e5940018          LDR      r0,[r4,#0x18]         ;1605
002958  e3500000          CMP      r0,#0                 ;1605
00295c  1a000006          BNE      |L1.10620|
002960  e1a02005          MOV      r2,r5                 ;1606
002964  e1a03006          MOV      r3,r6                 ;1606
002968  e1a00007          MOV      r0,r7                 ;1606
00296c  e58d4000          STR      r4,[sp,#0]            ;1606
002970  ebfffffe          BL       nand_do_read_oob
002974  e1a09000          MOV      r9,r0                 ;1606
002978  ea000005          B        |L1.10644|
                  |L1.10620|
00297c  e1a02005          MOV      r2,r5                 ;1608
002980  e1a03006          MOV      r3,r6                 ;1608
002984  e1a00007          MOV      r0,r7                 ;1608
002988  e58d4000          STR      r4,[sp,#0]            ;1608
00298c  ebfffffe          BL       nand_do_read_ops
002990  e1a09000          MOV      r9,r0                 ;1608
                  |L1.10644|
002994  e1a00000          MOV      r0,r0                 ;1610
                  |L1.10648|
002998  e1a00007          MOV      r0,r7                 ;1611
00299c  ebfffffe          BL       nand_release_device
0029a0  e1a00009          MOV      r0,r9                 ;1612
0029a4  eaffffd6          B        |L1.10500|
;;;1614   
                          ENDP

                  nand_write_page_raw PROC
;;;1623    */
;;;1624   static void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
0029a8  e92d4070          PUSH     {r4-r6,lr}
;;;1625   				const uint8_t *buf)
;;;1626   {
0029ac  e1a05000          MOV      r5,r0
0029b0  e1a04001          MOV      r4,r1
0029b4  e1a06002          MOV      r6,r2
;;;1627   	chip->write_buf(mtd, buf, mtd->writesize);
0029b8  e5952014          LDR      r2,[r5,#0x14]
0029bc  e1a01006          MOV      r1,r6
0029c0  e1a00005          MOV      r0,r5
0029c4  e5943010          LDR      r3,[r4,#0x10]
0029c8  e12fff33          BLX      r3
;;;1628   	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
0029cc  e5952018          LDR      r2,[r5,#0x18]
0029d0  e1a00005          MOV      r0,r5
0029d4  e5941090          LDR      r1,[r4,#0x90]
0029d8  e5943010          LDR      r3,[r4,#0x10]
0029dc  e12fff33          BLX      r3
;;;1629   }
0029e0  e8bd8070          POP      {r4-r6,pc}
;;;1630   
                          ENDP

                  nand_write_page_raw_syndrome PROC
;;;1638    */
;;;1639   static void nand_write_page_raw_syndrome(struct mtd_info *mtd,
0029e4  e92d5ff0          PUSH     {r4-r12,lr}
;;;1640   					struct nand_chip *chip,
;;;1641   					const uint8_t *buf)
;;;1642   {
0029e8  e1a08000          MOV      r8,r0
0029ec  e1a04001          MOV      r4,r1
0029f0  e1a06002          MOV      r6,r2
;;;1643   	int eccsize = chip->ecc.size;
0029f4  e59490a4          LDR      r9,[r4,#0xa4]
;;;1644   	int eccbytes = chip->ecc.bytes;
0029f8  e594a0a8          LDR      r10,[r4,#0xa8]
;;;1645   	uint8_t *oob = chip->oob_poi;
0029fc  e5945090          LDR      r5,[r4,#0x90]
;;;1646   	int steps, size;
;;;1647   
;;;1648   	for (steps = chip->ecc.steps; steps > 0; steps--) {
002a00  e594b0a0          LDR      r11,[r4,#0xa0]
002a04  ea000020          B        |L1.10892|
                  |L1.10760|
;;;1649   		chip->write_buf(mtd, buf, eccsize);
002a08  e1a02009          MOV      r2,r9
002a0c  e1a01006          MOV      r1,r6
002a10  e1a00008          MOV      r0,r8
002a14  e5943010          LDR      r3,[r4,#0x10]
002a18  e12fff33          BLX      r3
;;;1650   		buf += eccsize;
002a1c  e0866009          ADD      r6,r6,r9
;;;1651   
;;;1652   		if (chip->ecc.prepad) {
002a20  e59400b0          LDR      r0,[r4,#0xb0]
002a24  e3500000          CMP      r0,#0
002a28  0a000006          BEQ      |L1.10824|
;;;1653   			chip->write_buf(mtd, oob, chip->ecc.prepad);
002a2c  e1a01005          MOV      r1,r5
002a30  e1a00008          MOV      r0,r8
002a34  e59420b0          LDR      r2,[r4,#0xb0]
002a38  e5943010          LDR      r3,[r4,#0x10]
002a3c  e12fff33          BLX      r3
;;;1654   			oob += chip->ecc.prepad;
002a40  e59400b0          LDR      r0,[r4,#0xb0]
002a44  e0855000          ADD      r5,r5,r0
                  |L1.10824|
;;;1655   		}
;;;1656   
;;;1657   		chip->read_buf(mtd, oob, eccbytes);
002a48  e1a0200a          MOV      r2,r10
002a4c  e1a01005          MOV      r1,r5
002a50  e1a00008          MOV      r0,r8
002a54  e5943014          LDR      r3,[r4,#0x14]
002a58  e12fff33          BLX      r3
;;;1658   		oob += eccbytes;
002a5c  e085500a          ADD      r5,r5,r10
;;;1659   
;;;1660   		if (chip->ecc.postpad) {
002a60  e59400b4          LDR      r0,[r4,#0xb4]
002a64  e3500000          CMP      r0,#0
002a68  0a000006          BEQ      |L1.10888|
;;;1661   			chip->write_buf(mtd, oob, chip->ecc.postpad);
002a6c  e1a01005          MOV      r1,r5
002a70  e1a00008          MOV      r0,r8
002a74  e59420b4          LDR      r2,[r4,#0xb4]
002a78  e5943010          LDR      r3,[r4,#0x10]
002a7c  e12fff33          BLX      r3
;;;1662   			oob += chip->ecc.postpad;
002a80  e59400b4          LDR      r0,[r4,#0xb4]
002a84  e0855000          ADD      r5,r5,r0
                  |L1.10888|
002a88  e24bb001          SUB      r11,r11,#1            ;1648
                  |L1.10892|
002a8c  e35b0000          CMP      r11,#0                ;1648
002a90  caffffdc          BGT      |L1.10760|
;;;1663   		}
;;;1664   	}
;;;1665   
;;;1666   	size = mtd->oobsize - (oob - chip->oob_poi);
002a94  e5980018          LDR      r0,[r8,#0x18]
002a98  e5941090          LDR      r1,[r4,#0x90]
002a9c  e0451001          SUB      r1,r5,r1
002aa0  e0407001          SUB      r7,r0,r1
;;;1667   	if (size)
002aa4  e3570000          CMP      r7,#0
002aa8  0a000004          BEQ      |L1.10944|
;;;1668   		chip->write_buf(mtd, oob, size);
002aac  e1a02007          MOV      r2,r7
002ab0  e1a01005          MOV      r1,r5
002ab4  e1a00008          MOV      r0,r8
002ab8  e5943010          LDR      r3,[r4,#0x10]
002abc  e12fff33          BLX      r3
                  |L1.10944|
;;;1669   }
002ac0  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.10948|
                          DCD      0x00000484
                  |L1.10952|
                          DCD      ||.text||+0x4c0
                  |L1.10956|
                          DCD      ||.text||+0x4f4
                  |L1.10960|
                          DCD      0xfffffdf4
                          ENDP

                  nand_write_page_swecc PROC
;;;1675    */
;;;1676   static void nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
002ad4  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1677   				  const uint8_t *buf)
;;;1678   {
002ad8  e24dd008          SUB      sp,sp,#8
002adc  e1a04001          MOV      r4,r1
002ae0  e1a06002          MOV      r6,r2
;;;1679   	int i, eccsize = chip->ecc.size;
002ae4  e594a0a4          LDR      r10,[r4,#0xa4]
;;;1680   	int eccbytes = chip->ecc.bytes;
002ae8  e594b0a8          LDR      r11,[r4,#0xa8]
;;;1681   	int eccsteps = chip->ecc.steps;
002aec  e59470a0          LDR      r7,[r4,#0xa0]
;;;1682   	uint8_t *ecc_calc = chip->buffers->ecccalc;
002af0  e59480e8          LDR      r8,[r4,#0xe8]
;;;1683   	const uint8_t *p = buf;
002af4  e1a09006          MOV      r9,r6
;;;1684   	uint32_t *eccpos = chip->ecc.layout->eccpos;
002af8  e59400b8          LDR      r0,[r4,#0xb8]
002afc  e2800004          ADD      r0,r0,#4
002b00  e58d0004          STR      r0,[sp,#4]
;;;1685   
;;;1686   	/* Software ecc calculation */
;;;1687   	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
002b04  e3a05000          MOV      r5,#0
002b08  ea000007          B        |L1.11052|
                  |L1.11020|
;;;1688   		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
002b0c  e0882005          ADD      r2,r8,r5
002b10  e1a01009          MOV      r1,r9
002b14  e59430c4          LDR      r3,[r4,#0xc4]
002b18  e59d0008          LDR      r0,[sp,#8]
002b1c  e12fff33          BLX      r3
002b20  e2477001          SUB      r7,r7,#1              ;1687
002b24  e085500b          ADD      r5,r5,r11             ;1687
002b28  e089900a          ADD      r9,r9,r10             ;1687
                  |L1.11052|
002b2c  e3570000          CMP      r7,#0                 ;1687
002b30  1afffff5          BNE      |L1.11020|
;;;1689   
;;;1690   	for (i = 0; i < chip->ecc.total; i++)
002b34  e3a05000          MOV      r5,#0
002b38  ea000005          B        |L1.11092|
                  |L1.11068|
;;;1691   		chip->oob_poi[eccpos[i]] = ecc_calc[i];
002b3c  e7d81005          LDRB     r1,[r8,r5]
002b40  e5942090          LDR      r2,[r4,#0x90]
002b44  e59d0004          LDR      r0,[sp,#4]
002b48  e7900105          LDR      r0,[r0,r5,LSL #2]
002b4c  e7c21000          STRB     r1,[r2,r0]
002b50  e2855001          ADD      r5,r5,#1              ;1690
                  |L1.11092|
002b54  e59400ac          LDR      r0,[r4,#0xac]         ;1690
002b58  e1500005          CMP      r0,r5                 ;1690
002b5c  cafffff6          BGT      |L1.11068|
;;;1692   
;;;1693   	chip->ecc.write_page_raw(mtd, chip, buf);
002b60  e1a02006          MOV      r2,r6
002b64  e59430d0          LDR      r3,[r4,#0xd0]
002b68  e1a01004          MOV      r1,r4
002b6c  e59d0008          LDR      r0,[sp,#8]
002b70  e12fff33          BLX      r3
;;;1694   }
002b74  e28dd014          ADD      sp,sp,#0x14
002b78  e8bd8ff0          POP      {r4-r11,pc}
;;;1695   
                          ENDP

                  nand_write_page_hwecc PROC
;;;1701    */
;;;1702   static void nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
002b7c  e92d5ffc          PUSH     {r2-r12,lr}
;;;1703   				  const uint8_t *buf)
;;;1704   {
002b80  e1a06000          MOV      r6,r0
002b84  e1a04001          MOV      r4,r1
002b88  e1a07002          MOV      r7,r2
;;;1705   	int i, eccsize = chip->ecc.size;
002b8c  e59480a4          LDR      r8,[r4,#0xa4]
;;;1706   	int eccbytes = chip->ecc.bytes;
002b90  e59400a8          LDR      r0,[r4,#0xa8]
002b94  e58d0004          STR      r0,[sp,#4]
;;;1707   	int eccsteps = chip->ecc.steps;
002b98  e59490a0          LDR      r9,[r4,#0xa0]
;;;1708   	uint8_t *ecc_calc = chip->buffers->ecccalc;
002b9c  e594a0e8          LDR      r10,[r4,#0xe8]
;;;1709   	const uint8_t *p = buf;
002ba0  e1a0b007          MOV      r11,r7
;;;1710   	uint32_t *eccpos = chip->ecc.layout->eccpos;
002ba4  e59400b8          LDR      r0,[r4,#0xb8]
002ba8  e2800004          ADD      r0,r0,#4
002bac  e58d0000          STR      r0,[sp,#0]
;;;1711   
;;;1712   	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
002bb0  e3a05000          MOV      r5,#0
002bb4  ea000011          B        |L1.11264|
                  |L1.11192|
;;;1713   		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
002bb8  e3a01001          MOV      r1,#1
002bbc  e1a00006          MOV      r0,r6
002bc0  e59420c0          LDR      r2,[r4,#0xc0]
002bc4  e12fff32          BLX      r2
;;;1714   		chip->write_buf(mtd, p, eccsize);
002bc8  e1a02008          MOV      r2,r8
002bcc  e1a0100b          MOV      r1,r11
002bd0  e1a00006          MOV      r0,r6
002bd4  e5943010          LDR      r3,[r4,#0x10]
002bd8  e12fff33          BLX      r3
;;;1715   		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
002bdc  e08a2005          ADD      r2,r10,r5
002be0  e1a0100b          MOV      r1,r11
002be4  e1a00006          MOV      r0,r6
002be8  e59430c4          LDR      r3,[r4,#0xc4]
002bec  e12fff33          BLX      r3
002bf0  e2499001          SUB      r9,r9,#1              ;1712
002bf4  e59d0004          LDR      r0,[sp,#4]            ;1712
002bf8  e0855000          ADD      r5,r5,r0              ;1712
002bfc  e08bb008          ADD      r11,r11,r8            ;1712
                  |L1.11264|
002c00  e3590000          CMP      r9,#0                 ;1712
002c04  1affffeb          BNE      |L1.11192|
;;;1716   	}
;;;1717   
;;;1718   	for (i = 0; i < chip->ecc.total; i++)
002c08  e3a05000          MOV      r5,#0
002c0c  ea000005          B        |L1.11304|
                  |L1.11280|
;;;1719   		chip->oob_poi[eccpos[i]] = ecc_calc[i];
002c10  e7da1005          LDRB     r1,[r10,r5]
002c14  e5942090          LDR      r2,[r4,#0x90]
002c18  e59d0000          LDR      r0,[sp,#0]
002c1c  e7900105          LDR      r0,[r0,r5,LSL #2]
002c20  e7c21000          STRB     r1,[r2,r0]
002c24  e2855001          ADD      r5,r5,#1              ;1718
                  |L1.11304|
002c28  e59400ac          LDR      r0,[r4,#0xac]         ;1718
002c2c  e1500005          CMP      r0,r5                 ;1718
002c30  cafffff6          BGT      |L1.11280|
;;;1720   
;;;1721   	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
002c34  e5962018          LDR      r2,[r6,#0x18]
002c38  e1a00006          MOV      r0,r6
002c3c  e5941090          LDR      r1,[r4,#0x90]
002c40  e5943010          LDR      r3,[r4,#0x10]
002c44  e12fff33          BLX      r3
;;;1722   }
002c48  e8bd9ffc          POP      {r2-r12,pc}
;;;1723   
                          ENDP

                  nand_write_page_syndrome PROC
;;;1732    */
;;;1733   static void nand_write_page_syndrome(struct mtd_info *mtd,
002c4c  e92d4ff8          PUSH     {r3-r11,lr}
;;;1734   				    struct nand_chip *chip, const uint8_t *buf)
;;;1735   {
002c50  e1a08000          MOV      r8,r0
002c54  e1a04001          MOV      r4,r1
002c58  e1a09002          MOV      r9,r2
;;;1736   	int i, eccsize = chip->ecc.size;
002c5c  e594a0a4          LDR      r10,[r4,#0xa4]
;;;1737   	int eccbytes = chip->ecc.bytes;
002c60  e59470a8          LDR      r7,[r4,#0xa8]
;;;1738   	int eccsteps = chip->ecc.steps;
002c64  e594b0a0          LDR      r11,[r4,#0xa0]
;;;1739   	const uint8_t *p = buf;
002c68  e58d9000          STR      r9,[sp,#0]
;;;1740   	uint8_t *oob = chip->oob_poi;
002c6c  e5945090          LDR      r5,[r4,#0x90]
;;;1741   
;;;1742   	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
002c70  e3a06000          MOV      r6,#0
002c74  ea00002c          B        |L1.11564|
                  |L1.11384|
;;;1743   
;;;1744   		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
002c78  e3a01001          MOV      r1,#1
002c7c  e1a00008          MOV      r0,r8
002c80  e59420c0          LDR      r2,[r4,#0xc0]
002c84  e12fff32          BLX      r2
;;;1745   		chip->write_buf(mtd, p, eccsize);
002c88  e1a0200a          MOV      r2,r10
002c8c  e5943010          LDR      r3,[r4,#0x10]
002c90  e1a00008          MOV      r0,r8
002c94  e59d1000          LDR      r1,[sp,#0]
002c98  e12fff33          BLX      r3
;;;1746   
;;;1747   		if (chip->ecc.prepad) {
002c9c  e59400b0          LDR      r0,[r4,#0xb0]
002ca0  e3500000          CMP      r0,#0
002ca4  0a000006          BEQ      |L1.11460|
;;;1748   			chip->write_buf(mtd, oob, chip->ecc.prepad);
002ca8  e1a01005          MOV      r1,r5
002cac  e1a00008          MOV      r0,r8
002cb0  e59420b0          LDR      r2,[r4,#0xb0]
002cb4  e5943010          LDR      r3,[r4,#0x10]
002cb8  e12fff33          BLX      r3
;;;1749   			oob += chip->ecc.prepad;
002cbc  e59400b0          LDR      r0,[r4,#0xb0]
002cc0  e0855000          ADD      r5,r5,r0
                  |L1.11460|
;;;1750   		}
;;;1751   
;;;1752   		chip->ecc.calculate(mtd, p, oob);
002cc4  e1a02005          MOV      r2,r5
002cc8  e59430c4          LDR      r3,[r4,#0xc4]
002ccc  e1a00008          MOV      r0,r8
002cd0  e59d1000          LDR      r1,[sp,#0]
002cd4  e12fff33          BLX      r3
;;;1753   		chip->write_buf(mtd, oob, eccbytes);
002cd8  e1a02007          MOV      r2,r7
002cdc  e1a01005          MOV      r1,r5
002ce0  e1a00008          MOV      r0,r8
002ce4  e5943010          LDR      r3,[r4,#0x10]
002ce8  e12fff33          BLX      r3
;;;1754   		oob += eccbytes;
002cec  e0855007          ADD      r5,r5,r7
;;;1755   
;;;1756   		if (chip->ecc.postpad) {
002cf0  e59400b4          LDR      r0,[r4,#0xb4]
002cf4  e3500000          CMP      r0,#0
002cf8  0a000006          BEQ      |L1.11544|
;;;1757   			chip->write_buf(mtd, oob, chip->ecc.postpad);
002cfc  e1a01005          MOV      r1,r5
002d00  e1a00008          MOV      r0,r8
002d04  e59420b4          LDR      r2,[r4,#0xb4]
002d08  e5943010          LDR      r3,[r4,#0x10]
002d0c  e12fff33          BLX      r3
;;;1758   			oob += chip->ecc.postpad;
002d10  e59400b4          LDR      r0,[r4,#0xb4]
002d14  e0855000          ADD      r5,r5,r0
                  |L1.11544|
002d18  e24bb001          SUB      r11,r11,#1            ;1742
002d1c  e0866007          ADD      r6,r6,r7              ;1742
002d20  e59d0000          LDR      r0,[sp,#0]            ;1742
002d24  e080000a          ADD      r0,r0,r10             ;1742
002d28  e58d0000          STR      r0,[sp,#0]            ;1742
                  |L1.11564|
002d2c  e35b0000          CMP      r11,#0                ;1742
002d30  1affffd0          BNE      |L1.11384|
;;;1759   		}
;;;1760   	}
;;;1761   
;;;1762   	/* Calculate remaining oob bytes */
;;;1763   	i = mtd->oobsize - (oob - chip->oob_poi);
002d34  e5980018          LDR      r0,[r8,#0x18]
002d38  e5941090          LDR      r1,[r4,#0x90]
002d3c  e0451001          SUB      r1,r5,r1
002d40  e0406001          SUB      r6,r0,r1
;;;1764   	if (i)
002d44  e3560000          CMP      r6,#0
002d48  0a000004          BEQ      |L1.11616|
;;;1765   		chip->write_buf(mtd, oob, i);
002d4c  e1a02006          MOV      r2,r6
002d50  e1a01005          MOV      r1,r5
002d54  e1a00008          MOV      r0,r8
002d58  e5943010          LDR      r3,[r4,#0x10]
002d5c  e12fff33          BLX      r3
                  |L1.11616|
;;;1766   }
002d60  e8bd8ff8          POP      {r3-r11,pc}
;;;1767   
                          ENDP

                  nand_write_page PROC
;;;1776    */
;;;1777   static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
002d64  e92d4ff8          PUSH     {r3-r11,lr}
;;;1778   			   const uint8_t *buf, int page, int cached, int raw)
;;;1779   {
002d68  e1a07000          MOV      r7,r0
002d6c  e1a04001          MOV      r4,r1
002d70  e1a08002          MOV      r8,r2
002d74  e1a06003          MOV      r6,r3
002d78  e59d9028          LDR      r9,[sp,#0x28]
002d7c  e59da02c          LDR      r10,[sp,#0x2c]
;;;1780   	int status;
;;;1781   
;;;1782   	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
002d80  e1a03006          MOV      r3,r6
002d84  e3a02000          MOV      r2,#0
002d88  e3a01080          MOV      r1,#0x80
002d8c  e1a00007          MOV      r0,r7
002d90  e594c034          LDR      r12,[r4,#0x34]
002d94  e12fff3c          BLX      r12
;;;1783   
;;;1784   	if (raw)
002d98  e35a0000          CMP      r10,#0
002d9c  0a000005          BEQ      |L1.11704|
;;;1785   		chip->ecc.write_page_raw(mtd, chip, buf);
002da0  e1a02008          MOV      r2,r8
002da4  e59430d0          LDR      r3,[r4,#0xd0]
002da8  e1a01004          MOV      r1,r4
002dac  e1a00007          MOV      r0,r7
002db0  e12fff33          BLX      r3
002db4  ea000004          B        |L1.11724|
                  |L1.11704|
;;;1786   	else
;;;1787   		chip->ecc.write_page(mtd, chip, buf);
002db8  e1a02008          MOV      r2,r8
002dbc  e59430dc          LDR      r3,[r4,#0xdc]
002dc0  e1a01004          MOV      r1,r4
002dc4  e1a00007          MOV      r0,r7
002dc8  e12fff33          BLX      r3
                  |L1.11724|
;;;1788   
;;;1789   	/*
;;;1790   	 * Cached progamming disabled for now, Not sure if its worth the
;;;1791   	 * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
;;;1792   	 */
;;;1793   	cached = 0;
002dcc  e3a09000          MOV      r9,#0
;;;1794   
;;;1795   	if (!cached || !(chip->options & NAND_CACHEPRG)) {
002dd0  e3590000          CMP      r9,#0
002dd4  0a000002          BEQ      |L1.11748|
002dd8  e5d40050          LDRB     r0,[r4,#0x50]
002ddc  e3100008          TST      r0,#8
002de0  1a00001b          BNE      |L1.11860|
                  |L1.11748|
;;;1796   
;;;1797   		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
002de4  e3e03000          MVN      r3,#0
002de8  e1a02003          MOV      r2,r3
002dec  e3a01010          MOV      r1,#0x10
002df0  e1a00007          MOV      r0,r7
002df4  e594c034          LDR      r12,[r4,#0x34]
002df8  e12fff3c          BLX      r12
;;;1798   		status = chip->waitfunc(mtd, chip);
002dfc  e5942038          LDR      r2,[r4,#0x38]
002e00  e1a01004          MOV      r1,r4
002e04  e1a00007          MOV      r0,r7
002e08  e12fff32          BLX      r2
002e0c  e1a05000          MOV      r5,r0
;;;1799   		/*
;;;1800   		 * See if operation failed and additional status checks are
;;;1801   		 * available
;;;1802   		 */
;;;1803   		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
002e10  e3150001          TST      r5,#1
002e14  0a00000a          BEQ      |L1.11844|
002e18  e5940044          LDR      r0,[r4,#0x44]
002e1c  e3500000          CMP      r0,#0
002e20  0a000007          BEQ      |L1.11844|
;;;1804   			status = chip->errstat(mtd, chip, FL_WRITING, status,
002e24  e58d6000          STR      r6,[sp,#0]
002e28  e1a03005          MOV      r3,r5
002e2c  e3a02002          MOV      r2,#2
002e30  e594c044          LDR      r12,[r4,#0x44]
002e34  e1a01004          MOV      r1,r4
002e38  e1a00007          MOV      r0,r7
002e3c  e12fff3c          BLX      r12
002e40  e1a05000          MOV      r5,r0
                  |L1.11844|
;;;1805   					       page);
;;;1806   
;;;1807   		if (status & NAND_STATUS_FAIL)
002e44  e3150001          TST      r5,#1
002e48  0a00000c          BEQ      |L1.11904|
;;;1808   			return -EIO;
002e4c  e3e00004          MVN      r0,#4
                  |L1.11856|
;;;1809   	} else {
;;;1810   		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
;;;1811   		status = chip->waitfunc(mtd, chip);
;;;1812   	}
;;;1813   
;;;1814   #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
;;;1815   	/* Send command to read back the data */
;;;1816   	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
;;;1817   
;;;1818   	if (chip->verify_buf(mtd, buf, mtd->writesize))
;;;1819   		return -EIO;
;;;1820   #endif
;;;1821   	return 0;
;;;1822   }
002e50  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.11860|
002e54  e3e03000          MVN      r3,#0                 ;1810
002e58  e1a02003          MOV      r2,r3                 ;1810
002e5c  e3a01015          MOV      r1,#0x15              ;1810
002e60  e1a00007          MOV      r0,r7                 ;1810
002e64  e594c034          LDR      r12,[r4,#0x34]        ;1810
002e68  e12fff3c          BLX      r12                   ;1810
002e6c  e5942038          LDR      r2,[r4,#0x38]         ;1811
002e70  e1a01004          MOV      r1,r4                 ;1811
002e74  e1a00007          MOV      r0,r7                 ;1811
002e78  e12fff32          BLX      r2                    ;1811
002e7c  e1a05000          MOV      r5,r0                 ;1811
                  |L1.11904|
002e80  e3a00000          MOV      r0,#0                 ;1821
002e84  eafffff1          B        |L1.11856|
;;;1823   
                          ENDP

                  nand_do_write_ops PROC
;;;1881    */
;;;1882   static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,
002e88  e92d4ff0          PUSH     {r4-r11,lr}
;;;1883   			     struct mtd_oob_ops *ops)
;;;1884   {
002e8c  e24dd04c          SUB      sp,sp,#0x4c
002e90  e1a08000          MOV      r8,r0
002e94  e1a06002          MOV      r6,r2
002e98  e1a07003          MOV      r7,r3
002e9c  e59d5070          LDR      r5,[sp,#0x70]
;;;1885   	int chipnr, realpage, page, blockmask, column;
;;;1886   	struct nand_chip *chip = mtd->priv;
002ea0  e5984094          LDR      r4,[r8,#0x94]
;;;1887   	uint32_t writelen = ops->len;
002ea4  e5959004          LDR      r9,[r5,#4]
;;;1888   
;;;1889   	uint32_t oobwritelen = ops->ooblen;
002ea8  e595000c          LDR      r0,[r5,#0xc]
002eac  e58d0028          STR      r0,[sp,#0x28]
;;;1890   	uint32_t oobmaxlen = ops->mode == MTD_OOB_AUTO ?
002eb0  e5d50000          LDRB     r0,[r5,#0]
002eb4  e3500001          CMP      r0,#1
002eb8  1a000001          BNE      |L1.11972|
;;;1891   				mtd->oobavail : mtd->oobsize;
002ebc  e598001c          LDR      r0,[r8,#0x1c]
002ec0  ea000000          B        |L1.11976|
                  |L1.11972|
002ec4  e5980018          LDR      r0,[r8,#0x18]
                  |L1.11976|
002ec8  e58d0024          STR      r0,[sp,#0x24]
;;;1892   
;;;1893   	uint8_t *oob = ops->oobbuf;
002ecc  e595b01c          LDR      r11,[r5,#0x1c]
;;;1894   	uint8_t *buf = ops->datbuf;
002ed0  e5950018          LDR      r0,[r5,#0x18]
002ed4  e58d0020          STR      r0,[sp,#0x20]
;;;1895   	int ret, subpage;
;;;1896   
;;;1897   	ops->retlen = 0;
002ed8  e3a00000          MOV      r0,#0
002edc  e5850008          STR      r0,[r5,#8]
;;;1898   	if (!writelen)
002ee0  e3590000          CMP      r9,#0
002ee4  1a000001          BNE      |L1.12016|
                  |L1.12008|
;;;1899   		return 0;
002ee8  e28dd04c          ADD      sp,sp,#0x4c
;;;1900   
;;;1901   	column = to & (mtd->writesize - 1);
;;;1902   	subpage = column || (writelen & (mtd->writesize - 1));
;;;1903   
;;;1904   	if (subpage && oob)
;;;1905   		return -EINVAL;
;;;1906   
;;;1907   	chipnr = (int)(to >> chip->chip_shift);
;;;1908   	chip->select_chip(mtd, chipnr);
;;;1909   
;;;1910   	/* Check, if it is write protected */
;;;1911   	if (nand_check_wp(mtd)) {
;;;1912   		printk (KERN_NOTICE "nand_do_write_ops: Device is write protected\n");
;;;1913   		return -EIO;
;;;1914   	}
;;;1915   
;;;1916   	realpage = (int)(to >> chip->page_shift);
;;;1917   	page = realpage & chip->pagemask;
;;;1918   	blockmask = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
;;;1919   
;;;1920   	/* Invalidate the page cache, when we write to the cached page */
;;;1921   	if (to <= (chip->pagebuf << chip->page_shift) &&
;;;1922   	    (chip->pagebuf << chip->page_shift) < (to + ops->len))
;;;1923   		chip->pagebuf = -1;
;;;1924   
;;;1925   	/* If we're not given explicit OOB data, let it be 0xFF */
;;;1926   	if (!oob)
;;;1927   		memset(chip->oob_poi, 0xff, mtd->oobsize);
;;;1928   
;;;1929   	/* Don't allow multipage oob writes with offset */
;;;1930   	if (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen))
;;;1931   		return -EINVAL;
;;;1932   
;;;1933   	while (1) {
;;;1934   		int bytes = mtd->writesize;
;;;1935   		int cached = writelen > bytes && page != blockmask;
;;;1936   		uint8_t *wbuf = buf;
;;;1937   
;;;1938   		/* Partial page write ? */
;;;1939   		if (column || writelen < (mtd->writesize - 1)) {
;;;1940   			cached = 0;
;;;1941   			bytes = min_t(int, bytes - column, (int) writelen);
;;;1942   			chip->pagebuf = -1;
;;;1943   			memset(chip->buffers->databuf, 0xff, mtd->writesize);
;;;1944   			memcpy(&chip->buffers->databuf[column], buf, bytes);
;;;1945   			wbuf = chip->buffers->databuf;
;;;1946   		}
;;;1947   
;;;1948   		if (oob) {
;;;1949   			size_t len = min(oobwritelen, oobmaxlen);
;;;1950   			oob = nand_fill_oob(chip, oob, len, ops);
;;;1951   			oobwritelen -= len;
;;;1952   		}
;;;1953   
;;;1954   		ret = chip->write_page(mtd, chip, wbuf, page, cached,
;;;1955   				       (ops->mode == MTD_OOB_RAW));
;;;1956   		if (ret)
;;;1957   			break;
;;;1958   
;;;1959   		writelen -= bytes;
;;;1960   		if (!writelen)
;;;1961   			break;
;;;1962   
;;;1963   		column = 0;
;;;1964   		buf += bytes;
;;;1965   		realpage++;
;;;1966   
;;;1967   		page = realpage & chip->pagemask;
;;;1968   		/* Check, if we cross a chip boundary */
;;;1969   		if (!page) {
;;;1970   			chipnr++;
;;;1971   			chip->select_chip(mtd, -1);
;;;1972   			chip->select_chip(mtd, chipnr);
;;;1973   		}
;;;1974   	}
;;;1975   
;;;1976   	ops->retlen = ops->len - writelen;
;;;1977   	if (oob)
;;;1978   		ops->oobretlen = ops->ooblen;
;;;1979   	return ret;
;;;1980   }
002eec  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.12016|
002ef0  e5980014          LDR      r0,[r8,#0x14]         ;1901
002ef4  e2400001          SUB      r0,r0,#1              ;1901
002ef8  e000a006          AND      r10,r0,r6             ;1901
002efc  e35a0000          CMP      r10,#0                ;1902
002f00  1a000003          BNE      |L1.12052|
002f04  e5980014          LDR      r0,[r8,#0x14]         ;1902
002f08  e2400001          SUB      r0,r0,#1              ;1902
002f0c  e1100009          TST      r0,r9                 ;1902
002f10  0a000001          BEQ      |L1.12060|
                  |L1.12052|
002f14  e3a00001          MOV      r0,#1                 ;1902
002f18  ea000000          B        |L1.12064|
                  |L1.12060|
002f1c  e3a00000          MOV      r0,#0                 ;1902
                  |L1.12064|
002f20  e58d0018          STR      r0,[sp,#0x18]         ;1902
002f24  e59d0018          LDR      r0,[sp,#0x18]         ;1904
002f28  e3500000          CMP      r0,#0                 ;1904
002f2c  0a000003          BEQ      |L1.12096|
002f30  e35b0000          CMP      r11,#0                ;1904
002f34  0a000001          BEQ      |L1.12096|
002f38  e3e00015          MVN      r0,#0x15              ;1905
002f3c  eaffffe9          B        |L1.12008|
                  |L1.12096|
002f40  e5942060          LDR      r2,[r4,#0x60]         ;1907
002f44  e58d6040          STR      r6,[sp,#0x40]         ;1907
002f48  e1a00006          MOV      r0,r6                 ;1907
002f4c  e58d703c          STR      r7,[sp,#0x3c]         ;1907
002f50  e1a01007          MOV      r1,r7                 ;1907
002f54  ebfffffe          BL       __aeabi_lasr
002f58  e58d0038          STR      r0,[sp,#0x38]         ;1907
002f5c  e594201c          LDR      r2,[r4,#0x1c]         ;1908
002f60  e1a00008          MOV      r0,r8                 ;1908
002f64  e59d1038          LDR      r1,[sp,#0x38]         ;1908
002f68  e12fff32          BLX      r2                    ;1908
002f6c  e1a00008          MOV      r0,r8                 ;1911
002f70  ebfffffe          BL       nand_check_wp
002f74  e3500000          CMP      r0,#0                 ;1911
002f78  0a000003          BEQ      |L1.12172|
002f7c  e28f0e2d          ADR      r0,|L1.12884|
002f80  ebfffffe          BL       sysprintf
002f84  e3e00004          MVN      r0,#4                 ;1913
002f88  eaffffd6          B        |L1.12008|
                  |L1.12172|
002f8c  e5942054          LDR      r2,[r4,#0x54]         ;1916
002f90  e58d6048          STR      r6,[sp,#0x48]         ;1916
002f94  e1a00006          MOV      r0,r6                 ;1916
002f98  e58d7044          STR      r7,[sp,#0x44]         ;1916
002f9c  e1a01007          MOV      r1,r7                 ;1916
002fa0  ebfffffe          BL       __aeabi_lasr
002fa4  e58d0034          STR      r0,[sp,#0x34]         ;1916
002fa8  e5941070          LDR      r1,[r4,#0x70]         ;1917
002fac  e59d0034          LDR      r0,[sp,#0x34]         ;1917
002fb0  e0000001          AND      r0,r0,r1              ;1917
002fb4  e58d0030          STR      r0,[sp,#0x30]         ;1917
002fb8  e5d40058          LDRB     r0,[r4,#0x58]         ;1918
002fbc  e5d41054          LDRB     r1,[r4,#0x54]         ;1918
002fc0  e0400001          SUB      r0,r0,r1              ;1918
002fc4  e3a01001          MOV      r1,#1                 ;1918
002fc8  e1a00011          LSL      r0,r1,r0              ;1918
002fcc  e2400001          SUB      r0,r0,#1              ;1918
002fd0  e58d002c          STR      r0,[sp,#0x2c]         ;1918
002fd4  e5940074          LDR      r0,[r4,#0x74]         ;1921
002fd8  e5d41054          LDRB     r1,[r4,#0x54]         ;1921
002fdc  e1a00110          LSL      r0,r0,r1              ;1921
002fe0  e1a01fc0          ASR      r1,r0,#31             ;1921
002fe4  e0500006          SUBS     r0,r0,r6              ;1921
002fe8  e0d10007          SBCS     r0,r1,r7              ;1921
002fec  ba00000b          BLT      |L1.12320|
002ff0  e5940074          LDR      r0,[r4,#0x74]         ;1922
002ff4  e5d41054          LDRB     r1,[r4,#0x54]         ;1922
002ff8  e1a00110          LSL      r0,r0,r1              ;1922
002ffc  e1a02fc0          ASR      r2,r0,#31             ;1922
003000  e5951004          LDR      r1,[r5,#4]            ;1922
003004  e0911006          ADDS     r1,r1,r6              ;1922
003008  e2a73000          ADC      r3,r7,#0              ;1922
00300c  e0500001          SUBS     r0,r0,r1              ;1922
003010  e0d20003          SBCS     r0,r2,r3              ;1922
003014  aa000001          BGE      |L1.12320|
003018  e3e00000          MVN      r0,#0                 ;1923
00301c  e5840074          STR      r0,[r4,#0x74]         ;1923
                  |L1.12320|
003020  e35b0000          CMP      r11,#0                ;1926
003024  1a000003          BNE      |L1.12344|
003028  e5981018          LDR      r1,[r8,#0x18]         ;1927
00302c  e3a020ff          MOV      r2,#0xff              ;1927
003030  e5940090          LDR      r0,[r4,#0x90]         ;1927
003034  ebfffffe          BL       __aeabi_memset
                  |L1.12344|
003038  e35b0000          CMP      r11,#0                ;1930
00303c  0a00000a          BEQ      |L1.12396|
003040  e5950014          LDR      r0,[r5,#0x14]         ;1930
003044  e3500000          CMP      r0,#0                 ;1930
003048  0a000007          BEQ      |L1.12396|
00304c  e5950014          LDR      r0,[r5,#0x14]         ;1930
003050  e595100c          LDR      r1,[r5,#0xc]          ;1930
003054  e0811000          ADD      r1,r1,r0              ;1930
003058  e59d0024          LDR      r0,[sp,#0x24]         ;1930
00305c  e1510000          CMP      r1,r0                 ;1930
003060  9a000001          BLS      |L1.12396|
003064  e3e00015          MVN      r0,#0x15              ;1931
003068  eaffff9e          B        |L1.12008|
                  |L1.12396|
00306c  ea000077          B        |L1.12880|
                  |L1.12400|
003070  e5980014          LDR      r0,[r8,#0x14]         ;1934
003074  e58d0014          STR      r0,[sp,#0x14]         ;1934
003078  e59d0014          LDR      r0,[sp,#0x14]         ;1935
00307c  e1590000          CMP      r9,r0                 ;1935
003080  9a000005          BLS      |L1.12444|
003084  e59d0030          LDR      r0,[sp,#0x30]         ;1935
003088  e59d102c          LDR      r1,[sp,#0x2c]         ;1935
00308c  e1500001          CMP      r0,r1                 ;1935
003090  0a000001          BEQ      |L1.12444|
003094  e3a00001          MOV      r0,#1                 ;1935
003098  ea000000          B        |L1.12448|
                  |L1.12444|
00309c  e3a00000          MOV      r0,#0                 ;1935
                  |L1.12448|
0030a0  e58d0010          STR      r0,[sp,#0x10]         ;1935
0030a4  e59d0020          LDR      r0,[sp,#0x20]         ;1936
0030a8  e58d000c          STR      r0,[sp,#0xc]          ;1936
0030ac  e35a0000          CMP      r10,#0                ;1939
0030b0  1a000003          BNE      |L1.12484|
0030b4  e5980014          LDR      r0,[r8,#0x14]         ;1939
0030b8  e2400001          SUB      r0,r0,#1              ;1939
0030bc  e1500009          CMP      r0,r9                 ;1939
0030c0  9a00001a          BLS      |L1.12592|
                  |L1.12484|
0030c4  e3a00000          MOV      r0,#0                 ;1940
0030c8  e58d0010          STR      r0,[sp,#0x10]         ;1940
0030cc  e59d0014          LDR      r0,[sp,#0x14]         ;1941
0030d0  e040000a          SUB      r0,r0,r10             ;1941
0030d4  e1500009          CMP      r0,r9                 ;1941
0030d8  aa000002          BGE      |L1.12520|
0030dc  e59d0014          LDR      r0,[sp,#0x14]         ;1941
0030e0  e040000a          SUB      r0,r0,r10             ;1941
0030e4  ea000000          B        |L1.12524|
                  |L1.12520|
0030e8  e1a00009          MOV      r0,r9                 ;1941
                  |L1.12524|
0030ec  e58d0014          STR      r0,[sp,#0x14]         ;1941
0030f0  e3e00000          MVN      r0,#0                 ;1942
0030f4  e5840074          STR      r0,[r4,#0x74]         ;1942
0030f8  e5981014          LDR      r1,[r8,#0x14]         ;1943
0030fc  e59420e8          LDR      r2,[r4,#0xe8]         ;1943
003100  e2820d12          ADD      r0,r2,#0x480          ;1943
003104  e3a020ff          MOV      r2,#0xff              ;1943
003108  ebfffffe          BL       __aeabi_memset
00310c  e59410e8          LDR      r1,[r4,#0xe8]         ;1944
003110  e2811d12          ADD      r1,r1,#0x480          ;1944
003114  e081000a          ADD      r0,r1,r10             ;1944
003118  e59d1020          LDR      r1,[sp,#0x20]         ;1944
00311c  e59d2014          LDR      r2,[sp,#0x14]         ;1944
003120  ebfffffe          BL       __aeabi_memcpy
003124  e59400e8          LDR      r0,[r4,#0xe8]         ;1945
003128  e2800d12          ADD      r0,r0,#0x480          ;1945
00312c  e58d000c          STR      r0,[sp,#0xc]          ;1945
                  |L1.12592|
003130  e35b0000          CMP      r11,#0                ;1948
003134  0a000012          BEQ      |L1.12676|
003138  e59d0028          LDR      r0,[sp,#0x28]         ;1949
00313c  e59d1024          LDR      r1,[sp,#0x24]         ;1949
003140  e1500001          CMP      r0,r1                 ;1949
003144  9a000001          BLS      |L1.12624|
003148  e59d0024          LDR      r0,[sp,#0x24]         ;1949
00314c  ea000000          B        |L1.12628|
                  |L1.12624|
003150  e59d0028          LDR      r0,[sp,#0x28]         ;1949
                  |L1.12628|
003154  e58d0008          STR      r0,[sp,#8]            ;1949
003158  e1a03005          MOV      r3,r5                 ;1950
00315c  e1a0100b          MOV      r1,r11                ;1950
003160  e1a00004          MOV      r0,r4                 ;1950
003164  e59d2008          LDR      r2,[sp,#8]            ;1950
003168  ebfffffe          BL       nand_fill_oob
00316c  e1a0b000          MOV      r11,r0                ;1950
003170  e59d0008          LDR      r0,[sp,#8]            ;1951
003174  e59d1028          LDR      r1,[sp,#0x28]         ;1951
003178  e0410000          SUB      r0,r1,r0              ;1951
00317c  e58d0028          STR      r0,[sp,#0x28]         ;1951
003180  e1a00000          MOV      r0,r0                 ;1952
                  |L1.12676|
003184  e5d50000          LDRB     r0,[r5,#0]            ;1954
003188  e3500002          CMP      r0,#2                 ;1954
00318c  1a000001          BNE      |L1.12696|
003190  e3a01001          MOV      r1,#1                 ;1954
003194  ea000000          B        |L1.12700|
                  |L1.12696|
003198  e3a01000          MOV      r1,#0                 ;1954
                  |L1.12700|
00319c  e59d0010          LDR      r0,[sp,#0x10]         ;1954
0031a0  e1cd00f0          STRD     r0,r1,[sp,#0]         ;1954
0031a4  e594c048          LDR      r12,[r4,#0x48]        ;1954
0031a8  e1a01004          MOV      r1,r4                 ;1954
0031ac  e1a00008          MOV      r0,r8                 ;1954
0031b0  e59d200c          LDR      r2,[sp,#0xc]          ;1954
0031b4  e59d3030          LDR      r3,[sp,#0x30]         ;1954
0031b8  e12fff3c          BLX      r12                   ;1954
0031bc  e58d001c          STR      r0,[sp,#0x1c]         ;1954
0031c0  e59d001c          LDR      r0,[sp,#0x1c]         ;1956
0031c4  e3500000          CMP      r0,#0                 ;1956
0031c8  0a000000          BEQ      |L1.12752|
0031cc  ea00002c          B        |L1.12932|
                  |L1.12752|
0031d0  e59d0014          LDR      r0,[sp,#0x14]         ;1959
0031d4  e0499000          SUB      r9,r9,r0              ;1959
0031d8  e3590000          CMP      r9,#0                 ;1960
0031dc  1a000000          BNE      |L1.12772|
0031e0  ea000027          B        |L1.12932|
                  |L1.12772|
0031e4  e3a0a000          MOV      r10,#0                ;1963
0031e8  e59d0020          LDR      r0,[sp,#0x20]         ;1964
0031ec  e59d1014          LDR      r1,[sp,#0x14]         ;1964
0031f0  e0800001          ADD      r0,r0,r1              ;1964
0031f4  e58d0020          STR      r0,[sp,#0x20]         ;1964
0031f8  e59d0034          LDR      r0,[sp,#0x34]         ;1965
0031fc  e2800001          ADD      r0,r0,#1              ;1965
003200  e58d0034          STR      r0,[sp,#0x34]         ;1965
003204  e5941070          LDR      r1,[r4,#0x70]         ;1967
003208  e59d0034          LDR      r0,[sp,#0x34]         ;1967
00320c  e0000001          AND      r0,r0,r1              ;1967
003210  e58d0030          STR      r0,[sp,#0x30]         ;1967
003214  e59d0030          LDR      r0,[sp,#0x30]         ;1969
003218  e3500000          CMP      r0,#0                 ;1969
00321c  1a00000a          BNE      |L1.12876|
003220  e59d0038          LDR      r0,[sp,#0x38]         ;1970
003224  e2800001          ADD      r0,r0,#1              ;1970
003228  e58d0038          STR      r0,[sp,#0x38]         ;1970
00322c  e3e01000          MVN      r1,#0                 ;1971
003230  e1a00008          MOV      r0,r8                 ;1971
003234  e594201c          LDR      r2,[r4,#0x1c]         ;1971
003238  e12fff32          BLX      r2                    ;1971
00323c  e594201c          LDR      r2,[r4,#0x1c]         ;1972
003240  e1a00008          MOV      r0,r8                 ;1972
003244  e59d1038          LDR      r1,[sp,#0x38]         ;1972
003248  e12fff32          BLX      r2                    ;1972
                  |L1.12876|
00324c  e1a00000          MOV      r0,r0                 ;1974
                  |L1.12880|
003250  eaffff86          B        |L1.12400|
                  |L1.12884|
003254  6e616e64          DCB      "nand_do_write_ops: Device is write protected\n",0
003258  5f646f5f
00325c  77726974
003260  655f6f70
003264  733a2044
003268  65766963
00326c  65206973
003270  20777269
003274  74652070
003278  726f7465
00327c  63746564
003280  0a00    
003282  00                DCB      0
003283  00                DCB      0
                  |L1.12932|
003284  e1a00000          MOV      r0,r0                 ;1957
003288  e5950004          LDR      r0,[r5,#4]            ;1976
00328c  e0400009          SUB      r0,r0,r9              ;1976
003290  e5850008          STR      r0,[r5,#8]            ;1976
003294  e35b0000          CMP      r11,#0                ;1977
003298  0a000001          BEQ      |L1.12964|
00329c  e595000c          LDR      r0,[r5,#0xc]          ;1978
0032a0  e5850010          STR      r0,[r5,#0x10]         ;1978
                  |L1.12964|
0032a4  e59d001c          LDR      r0,[sp,#0x1c]         ;1979
0032a8  eaffff0e          B        |L1.12008|
;;;1981   
                          ENDP

                  nand_write PROC
;;;1991    */
;;;1992   static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
0032ac  e92d4ff8          PUSH     {r3-r11,lr}
;;;1993   			  size_t *retlen, const uint8_t *buf)
;;;1994   {
0032b0  e1a06000          MOV      r6,r0
0032b4  e1a07002          MOV      r7,r2
0032b8  e1a08003          MOV      r8,r3
0032bc  e28db028          ADD      r11,sp,#0x28
0032c0  e89b0c20          LDM      r11,{r5,r10,r11}
;;;1995   	struct nand_chip *chip = mtd->priv;
0032c4  e5964094          LDR      r4,[r6,#0x94]
;;;1996   	int ret;
;;;1997   
;;;1998   	/* Do not allow writes past end of device */
;;;1999   	if ((to + len) > mtd->size)
0032c8  e0973005          ADDS     r3,r7,r5
0032cc  e2a82000          ADC      r2,r8,#0
0032d0  e1c600d8          LDRD     r0,r1,[r6,#8]
0032d4  e0500003          SUBS     r0,r0,r3
0032d8  e0d10002          SBCS     r0,r1,r2
0032dc  2a000001          BCS      |L1.13032|
;;;2000   		return -EINVAL;
0032e0  e3e00015          MVN      r0,#0x15
                  |L1.13028|
;;;2001   	if (!len)
;;;2002   		return 0;
;;;2003   
;;;2004   	nand_get_device(chip, mtd, FL_WRITING);
;;;2005   
;;;2006   	chip->ops.len = len;
;;;2007   	chip->ops.datbuf = (uint8_t *)buf;
;;;2008   	chip->ops.oobbuf = NULL;
;;;2009   
;;;2010   	ret = nand_do_write_ops(mtd, to, &chip->ops);
;;;2011   
;;;2012   	*retlen = chip->ops.retlen;
;;;2013   
;;;2014   	nand_release_device(mtd);
;;;2015   
;;;2016   	return ret;
;;;2017   }
0032e4  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.13032|
0032e8  e3550000          CMP      r5,#0                 ;2001
0032ec  1a000001          BNE      |L1.13048|
0032f0  e3a00000          MOV      r0,#0                 ;2002
0032f4  eafffffa          B        |L1.13028|
                  |L1.13048|
0032f8  e3a02002          MOV      r2,#2                 ;2004
0032fc  e1a01006          MOV      r1,r6                 ;2004
003300  e1a00004          MOV      r0,r4                 ;2004
003304  ebfffffe          BL       nand_get_device
003308  e58450f4          STR      r5,[r4,#0xf4]         ;2006
00330c  e584b108          STR      r11,[r4,#0x108]       ;2007
003310  e3a00000          MOV      r0,#0                 ;2008
003314  e584010c          STR      r0,[r4,#0x10c]        ;2008
003318  e28400f0          ADD      r0,r4,#0xf0           ;2010
00331c  e1a02007          MOV      r2,r7                 ;2010
003320  e1a03008          MOV      r3,r8                 ;2010
003324  e58d0000          STR      r0,[sp,#0]            ;2010
003328  e1a00006          MOV      r0,r6                 ;2010
00332c  ebfffffe          BL       nand_do_write_ops
003330  e1a09000          MOV      r9,r0                 ;2010
003334  e59400f8          LDR      r0,[r4,#0xf8]         ;2012
003338  e58a0000          STR      r0,[r10,#0]           ;2012
00333c  e1a00006          MOV      r0,r6                 ;2014
003340  ebfffffe          BL       nand_release_device
003344  e1a00009          MOV      r0,r9                 ;2016
003348  eaffffe5          B        |L1.13028|
;;;2018   
                          ENDP

                  nand_write_oob PROC
;;;2101    */
;;;2102   static int nand_write_oob(struct mtd_info *mtd, loff_t to,
00334c  e92d43f8          PUSH     {r3-r9,lr}
;;;2103   			  struct mtd_oob_ops *ops)
;;;2104   {
003350  e1a07000          MOV      r7,r0
003354  e1a05002          MOV      r5,r2
003358  e1a06003          MOV      r6,r3
00335c  e59d4020          LDR      r4,[sp,#0x20]
;;;2105   	struct nand_chip *chip = mtd->priv;
003360  e5978094          LDR      r8,[r7,#0x94]
;;;2106   	int ret = -ENOTSUPP;
003364  e51f989c          LDR      r9,|L1.10960|
;;;2107   
;;;2108   	ops->retlen = 0;
003368  e3a00000          MOV      r0,#0
00336c  e5840008          STR      r0,[r4,#8]
;;;2109   
;;;2110   	/* Do not allow writes past end of device */
;;;2111   	if (ops->datbuf && (to + ops->len) > mtd->size) {
003370  e5940018          LDR      r0,[r4,#0x18]
003374  e3500000          CMP      r0,#0
003378  0a00000b          BEQ      |L1.13228|
00337c  e5971008          LDR      r1,[r7,#8]
003380  e597200c          LDR      r2,[r7,#0xc]
003384  e5940004          LDR      r0,[r4,#4]
003388  e0900005          ADDS     r0,r0,r5
00338c  e2a63000          ADC      r3,r6,#0
003390  e0510000          SUBS     r0,r1,r0
003394  e0d20003          SBCS     r0,r2,r3
003398  2a000003          BCS      |L1.13228|
;;;2112   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
00339c  e1a00000          MOV      r0,r0
0033a0  e1a00000          MOV      r0,r0
;;;2113   				"end of device\n", __func__);
;;;2114   		return -EINVAL;
0033a4  e3e00015          MVN      r0,#0x15
                  |L1.13224|
;;;2115   	}
;;;2116   
;;;2117   	nand_get_device(chip, mtd, FL_WRITING);
;;;2118   
;;;2119   	switch (ops->mode) {
;;;2120   	case MTD_OOB_PLACE:
;;;2121   	case MTD_OOB_AUTO:
;;;2122   	case MTD_OOB_RAW:
;;;2123   		break;
;;;2124   
;;;2125   	default:
;;;2126   		goto out;
;;;2127   	}
;;;2128   
;;;2129   	if (!ops->datbuf)
;;;2130   		ret = nand_do_write_oob(mtd, to, ops);
;;;2131   	else
;;;2132   		ret = nand_do_write_ops(mtd, to, ops);
;;;2133   
;;;2134   out:
;;;2135   	nand_release_device(mtd);
;;;2136   	return ret;
;;;2137   }
0033a8  e8bd83f8          POP      {r3-r9,pc}
                  |L1.13228|
0033ac  e3a02002          MOV      r2,#2                 ;2117
0033b0  e1a01007          MOV      r1,r7                 ;2117
0033b4  e1a00008          MOV      r0,r8                 ;2117
0033b8  ebfffffe          BL       nand_get_device
0033bc  e5d40000          LDRB     r0,[r4,#0]            ;2119
0033c0  e3500000          CMP      r0,#0                 ;2119
0033c4  0a000004          BEQ      |L1.13276|
0033c8  e3500001          CMP      r0,#1                 ;2119
0033cc  0a000004          BEQ      |L1.13284|
0033d0  e3500002          CMP      r0,#2                 ;2119
0033d4  1a000004          BNE      |L1.13292|
0033d8  ea000002          B        |L1.13288|
                  |L1.13276|
0033dc  e1a00000          MOV      r0,r0                 ;2120
0033e0  e1a00000          MOV      r0,r0                 ;2121
                  |L1.13284|
0033e4  e1a00000          MOV      r0,r0                 ;2122
                  |L1.13288|
0033e8  ea000001          B        |L1.13300|
                  |L1.13292|
0033ec  e1a00000          MOV      r0,r0                 ;2125
0033f0  ea000011          B        |L1.13372|
                  |L1.13300|
0033f4  e1a00000          MOV      r0,r0                 ;2123
0033f8  e5940018          LDR      r0,[r4,#0x18]         ;2129
0033fc  e3500000          CMP      r0,#0                 ;2129
003400  1a000006          BNE      |L1.13344|
003404  e1a02005          MOV      r2,r5                 ;2130
003408  e1a03006          MOV      r3,r6                 ;2130
00340c  e1a00007          MOV      r0,r7                 ;2130
003410  e58d4000          STR      r4,[sp,#0]            ;2130
003414  ebfffffe          BL       nand_do_write_oob
003418  e1a09000          MOV      r9,r0                 ;2130
00341c  ea000005          B        |L1.13368|
                  |L1.13344|
003420  e1a02005          MOV      r2,r5                 ;2132
003424  e1a03006          MOV      r3,r6                 ;2132
003428  e1a00007          MOV      r0,r7                 ;2132
00342c  e58d4000          STR      r4,[sp,#0]            ;2132
003430  ebfffffe          BL       nand_do_write_ops
003434  e1a09000          MOV      r9,r0                 ;2132
                  |L1.13368|
003438  e1a00000          MOV      r0,r0                 ;2134
                  |L1.13372|
00343c  e1a00007          MOV      r0,r7                 ;2135
003440  ebfffffe          BL       nand_release_device
003444  e1a00009          MOV      r0,r9                 ;2136
003448  eaffffd6          B        |L1.13224|
;;;2138   
                          ENDP

                  single_erase_cmd PROC
;;;2145    */
;;;2146   static void single_erase_cmd(struct mtd_info *mtd, int page)
00344c  e92d4070          PUSH     {r4-r6,lr}
;;;2147   {
003450  e1a04000          MOV      r4,r0
003454  e1a05001          MOV      r5,r1
;;;2148   	struct nand_chip *chip = mtd->priv;
003458  e5946094          LDR      r6,[r4,#0x94]
;;;2149   	/* Send commands to erase a block */
;;;2150   	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
00345c  e1a03005          MOV      r3,r5
003460  e3e02000          MVN      r2,#0
003464  e3a01060          MOV      r1,#0x60
003468  e1a00004          MOV      r0,r4
00346c  e596c034          LDR      r12,[r6,#0x34]
003470  e12fff3c          BLX      r12
;;;2151   	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
003474  e3e03000          MVN      r3,#0
003478  e1a02003          MOV      r2,r3
00347c  e3a010d0          MOV      r1,#0xd0
003480  e1a00004          MOV      r0,r4
003484  e596c034          LDR      r12,[r6,#0x34]
003488  e12fff3c          BLX      r12
;;;2152   }
00348c  e8bd8070          POP      {r4-r6,pc}
;;;2153   
                          ENDP

                  multi_erase_cmd PROC
;;;2161    */
;;;2162   static void multi_erase_cmd(struct mtd_info *mtd, int page)
003490  e92d4070          PUSH     {r4-r6,lr}
;;;2163   {
003494  e1a06000          MOV      r6,r0
003498  e1a04001          MOV      r4,r1
;;;2164   	struct nand_chip *chip = mtd->priv;
00349c  e5965094          LDR      r5,[r6,#0x94]
;;;2165   	/* Send commands to erase a block */
;;;2166   	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
0034a0  e1a03004          MOV      r3,r4
0034a4  e2844001          ADD      r4,r4,#1
0034a8  e3e02000          MVN      r2,#0
0034ac  e3a01060          MOV      r1,#0x60
0034b0  e1a00006          MOV      r0,r6
0034b4  e595c034          LDR      r12,[r5,#0x34]
0034b8  e12fff3c          BLX      r12
;;;2167   	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
0034bc  e1a03004          MOV      r3,r4
0034c0  e2844001          ADD      r4,r4,#1
0034c4  e3e02000          MVN      r2,#0
0034c8  e3a01060          MOV      r1,#0x60
0034cc  e1a00006          MOV      r0,r6
0034d0  e595c034          LDR      r12,[r5,#0x34]
0034d4  e12fff3c          BLX      r12
;;;2168   	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page++);
0034d8  e1a03004          MOV      r3,r4
0034dc  e2844001          ADD      r4,r4,#1
0034e0  e3e02000          MVN      r2,#0
0034e4  e3a01060          MOV      r1,#0x60
0034e8  e1a00006          MOV      r0,r6
0034ec  e595c034          LDR      r12,[r5,#0x34]
0034f0  e12fff3c          BLX      r12
;;;2169   	chip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);
0034f4  e1a03004          MOV      r3,r4
0034f8  e3e02000          MVN      r2,#0
0034fc  e3a01060          MOV      r1,#0x60
003500  e1a00006          MOV      r0,r6
003504  e595c034          LDR      r12,[r5,#0x34]
003508  e12fff3c          BLX      r12
;;;2170   	chip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);
00350c  e3e03000          MVN      r3,#0
003510  e1a02003          MOV      r2,r3
003514  e3a010d0          MOV      r1,#0xd0
003518  e1a00006          MOV      r0,r6
00351c  e595c034          LDR      r12,[r5,#0x34]
003520  e12fff3c          BLX      r12
;;;2171   }
003524  e8bd8070          POP      {r4-r6,pc}
;;;2172   
                          ENDP

                  nand_erase_nand PROC
;;;2193    */
;;;2194   int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
003528  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2195   		    int allowbbt)
;;;2196   {
00352c  e24dd048          SUB      sp,sp,#0x48
003530  e1a06001          MOV      r6,r1
;;;2197   	int page, status, pages_per_block, ret, chipnr;
;;;2198   	struct nand_chip *chip = mtd->priv;
003534  e59d0048          LDR      r0,[sp,#0x48]
003538  e5904094          LDR      r4,[r0,#0x94]
;;;2199   	loff_t rewrite_bbt[CONFIG_SYS_NAND_MAX_CHIPS] = {0};
00353c  e3a00000          MOV      r0,#0
003540  e58d0010          STR      r0,[sp,#0x10]
003544  e58d0014          STR      r0,[sp,#0x14]
;;;2200   	unsigned int bbt_masked_page = 0xffffffff;
003548  e3e0a000          MVN      r10,#0
;;;2201   	loff_t len;
;;;2202   
;;;2203   	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: start = 0x%012llx, len = %llu\n",
00354c  e1a00000          MOV      r0,r0
003550  e1a00000          MOV      r0,r0
;;;2204   				__func__, (unsigned long long)instr->addr,
;;;2205   				(unsigned long long)instr->len);
;;;2206   
;;;2207   	if (check_offs_len(mtd, instr->addr, instr->len))
003554  e1c601d0          LDRD     r0,r1,[r6,#0x10]
003558  e1cd00f0          STRD     r0,r1,[sp,#0]
00355c  e1c600d8          LDRD     r0,r1,[r6,#8]
003560  e1cd00f8          STRD     r0,r1,[sp,#8]
003564  e1a02000          MOV      r2,r0
003568  e1a03001          MOV      r3,r1
00356c  e59d0048          LDR      r0,[sp,#0x48]
003570  ebfffffe          BL       check_offs_len
003574  e3500000          CMP      r0,#0
003578  0a000002          BEQ      |L1.13704|
;;;2208   		return -EINVAL;
00357c  e3e00015          MVN      r0,#0x15
                  |L1.13696|
003580  e28dd054          ADD      sp,sp,#0x54
;;;2209   
;;;2210   	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
;;;2211   
;;;2212   	/* Grab the lock and see if the device is available */
;;;2213   	nand_get_device(chip, mtd, FL_ERASING);
;;;2214   
;;;2215   	/* Shift to get first page */
;;;2216   	page = (int)(instr->addr >> chip->page_shift);
;;;2217   	chipnr = (int)(instr->addr >> chip->chip_shift);
;;;2218   
;;;2219   	/* Calculate pages in each block */
;;;2220   	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
;;;2221   
;;;2222   	/* Select the NAND device */
;;;2223   	chip->select_chip(mtd, chipnr);
;;;2224   
;;;2225   	/* Check, if it is write protected */
;;;2226   	if (nand_check_wp(mtd)) {
;;;2227   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Device is write protected!!!\n",
;;;2228   					__func__);
;;;2229   		instr->state = MTD_ERASE_FAILED;
;;;2230   		goto erase_exit;
;;;2231   	}
;;;2232   
;;;2233   	/*
;;;2234   	 * If BBT requires refresh, set the BBT page mask to see if the BBT
;;;2235   	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
;;;2236   	 * can not be matched. This is also done when the bbt is actually
;;;2237   	 * erased to avoid recusrsive updates
;;;2238   	 */
;;;2239   	if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
;;;2240   		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
;;;2241   
;;;2242   	/* Loop through the pages */
;;;2243   	len = instr->len;
;;;2244   
;;;2245   	instr->state = MTD_ERASING;
;;;2246   
;;;2247   	while (len) {
;;;2248   		/*
;;;2249   		 * heck if we have a bad block, we do not erase bad blocks !
;;;2250   		 */
;;;2251   		if (!instr->scrub && nand_block_checkbad(mtd, ((loff_t) page) <<
;;;2252   					chip->page_shift, 0, allowbbt)) {
;;;2253   			printk(KERN_WARNING "%s: attempt to erase a bad block "
;;;2254   					"at page 0x%08x\n", __func__, page);
;;;2255   			instr->state = MTD_ERASE_FAILED;
;;;2256   			goto erase_exit;
;;;2257   		}
;;;2258   
;;;2259   		/*
;;;2260   		 * Invalidate the page cache, if we erase the block which
;;;2261   		 * contains the current cached page
;;;2262   		 */
;;;2263   		if (page <= chip->pagebuf && chip->pagebuf <
;;;2264   		    (page + pages_per_block))
;;;2265   			chip->pagebuf = -1;
;;;2266   
;;;2267   		chip->erase_cmd(mtd, page & chip->pagemask);
;;;2268   
;;;2269   		status = chip->waitfunc(mtd, chip);
;;;2270   
;;;2271   		/*
;;;2272   		 * See if operation failed and additional status checks are
;;;2273   		 * available
;;;2274   		 */
;;;2275   		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
;;;2276   			status = chip->errstat(mtd, chip, FL_ERASING,
;;;2277   					       status, page);
;;;2278   
;;;2279   		/* See if block erase succeeded */
;;;2280   		if (status & NAND_STATUS_FAIL) {
;;;2281   			MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: Failed erase, "
;;;2282   					"page 0x%08x\n", __func__, page);
;;;2283   			instr->state = MTD_ERASE_FAILED;
;;;2284   			instr->fail_addr =
;;;2285   				((loff_t)page << chip->page_shift);
;;;2286   			goto erase_exit;
;;;2287   		}
;;;2288   
;;;2289   		/*
;;;2290   		 * If BBT requires refresh, set the BBT rewrite flag to the
;;;2291   		 * page being erased
;;;2292   		 */
;;;2293   		if (bbt_masked_page != 0xffffffff &&
;;;2294   		    (page & BBT_PAGE_MASK) == bbt_masked_page)
;;;2295   			rewrite_bbt[chipnr] =
;;;2296   				((loff_t)page << chip->page_shift);
;;;2297   
;;;2298   		/* Increment page address and decrement length */
;;;2299   		len -= (1 << chip->phys_erase_shift);
;;;2300   		page += pages_per_block;
;;;2301   
;;;2302   		/* Check, if we cross a chip boundary */
;;;2303   		if (len && !(page & chip->pagemask)) {
;;;2304   			chipnr++;
;;;2305   			chip->select_chip(mtd, -1);
;;;2306   			chip->select_chip(mtd, chipnr);
;;;2307   
;;;2308   			/*
;;;2309   			 * If BBT requires refresh and BBT-PERCHIP, set the BBT
;;;2310   			 * page mask to see if this BBT should be rewritten
;;;2311   			 */
;;;2312   			if (bbt_masked_page != 0xffffffff &&
;;;2313   			    (chip->bbt_td->options & NAND_BBT_PERCHIP))
;;;2314   				bbt_masked_page = chip->bbt_td->pages[chipnr] &
;;;2315   					BBT_PAGE_MASK;
;;;2316   		}
;;;2317   	}
;;;2318   	instr->state = MTD_ERASE_DONE;
;;;2319   
;;;2320   erase_exit:
;;;2321   
;;;2322   	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
;;;2323   
;;;2324   	/* Deselect and wake up anyone waiting on the device */
;;;2325   	nand_release_device(mtd);
;;;2326   
;;;2327   	/* Do call back function */
;;;2328   	if (!ret)
;;;2329   		mtd_erase_callback(instr);
;;;2330   
;;;2331   	/*
;;;2332   	 * If BBT requires refresh and erase was successful, rewrite any
;;;2333   	 * selected bad block tables
;;;2334   	 */
;;;2335   	if (bbt_masked_page == 0xffffffff || ret)
;;;2336   		return ret;
;;;2337   
;;;2338   	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
;;;2339   		if (!rewrite_bbt[chipnr])
;;;2340   			continue;
;;;2341   		/* update the BBT for chip */
;;;2342   		MTDDEBUG(MTD_DEBUG_LEVEL0, "%s: nand_update_bbt "
;;;2343   			"(%d:0x%0llx 0x%0x)\n", __func__, chipnr,
;;;2344   			rewrite_bbt[chipnr], chip->bbt_td->pages[chipnr]);
;;;2345   		nand_update_bbt(mtd, rewrite_bbt[chipnr]);
;;;2346   	}
;;;2347   
;;;2348   	/* Return more or less happy */
;;;2349   	return ret;
;;;2350   }
003584  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.13704|
003588  e3e01000          MVN      r1,#0                 ;2208
00358c  e5861018          STR      r1,[r6,#0x18]         ;2210
003590  e586101c          STR      r1,[r6,#0x1c]         ;2210
003594  e3a02003          MOV      r2,#3                 ;2213
003598  e1a00004          MOV      r0,r4                 ;2213
00359c  e59d1048          LDR      r1,[sp,#0x48]         ;2213
0035a0  ebfffffe          BL       nand_get_device
0035a4  e596000c          LDR      r0,[r6,#0xc]          ;2216
0035a8  e5961008          LDR      r1,[r6,#8]            ;2216
0035ac  e5942054          LDR      r2,[r4,#0x54]         ;2216
0035b0  e58d002c          STR      r0,[sp,#0x2c]         ;2216
0035b4  e58d1030          STR      r1,[sp,#0x30]         ;2216
0035b8  e1a00001          MOV      r0,r1                 ;2216
0035bc  e59d102c          LDR      r1,[sp,#0x2c]         ;2216
0035c0  ebfffffe          BL       __aeabi_llsr
0035c4  e1a05000          MOV      r5,r0                 ;2216
0035c8  e1c600d8          LDRD     r0,r1,[r6,#8]         ;2217
0035cc  e5942060          LDR      r2,[r4,#0x60]         ;2217
0035d0  e58d0028          STR      r0,[sp,#0x28]         ;2217
0035d4  e58d1024          STR      r1,[sp,#0x24]         ;2217
0035d8  ebfffffe          BL       __aeabi_llsr
0035dc  e1a09000          MOV      r9,r0                 ;2217
0035e0  e5d40058          LDRB     r0,[r4,#0x58]         ;2220
0035e4  e5d41054          LDRB     r1,[r4,#0x54]         ;2220
0035e8  e0400001          SUB      r0,r0,r1              ;2220
0035ec  e3a01001          MOV      r1,#1                 ;2220
0035f0  e1a00011          LSL      r0,r1,r0              ;2220
0035f4  e58d001c          STR      r0,[sp,#0x1c]         ;2220
0035f8  e1a01009          MOV      r1,r9                 ;2223
0035fc  e594201c          LDR      r2,[r4,#0x1c]         ;2223
003600  e59d0048          LDR      r0,[sp,#0x48]         ;2223
003604  e12fff32          BLX      r2                    ;2223
003608  e59d0048          LDR      r0,[sp,#0x48]         ;2226
00360c  ebfffffe          BL       nand_check_wp
003610  e3500000          CMP      r0,#0                 ;2226
003614  0a000004          BEQ      |L1.13868|
003618  e1a00000          MOV      r0,r0                 ;2227
00361c  e1a00000          MOV      r0,r0                 ;2227
003620  e3a00010          MOV      r0,#0x10              ;2229
003624  e5c60038          STRB     r0,[r6,#0x38]         ;2229
003628  ea000097          B        |L1.14476|
                  |L1.13868|
00362c  e5d40050          LDRB     r0,[r4,#0x50]         ;2239
003630  e3100080          TST      r0,#0x80              ;2239
003634  0a000006          BEQ      |L1.13908|
003638  e59d0050          LDR      r0,[sp,#0x50]         ;2239
00363c  e3500000          CMP      r0,#0                 ;2239
003640  1a000003          BNE      |L1.13908|
003644  e5940114          LDR      r0,[r4,#0x114]        ;2240
003648  e2800004          ADD      r0,r0,#4              ;2240
00364c  e7900109          LDR      r0,[r0,r9,LSL #2]     ;2240
003650  e3c0a0c0          BIC      r10,r0,#0xc0          ;2240
                  |L1.13908|
003654  e5967010          LDR      r7,[r6,#0x10]         ;2243
003658  e5968014          LDR      r8,[r6,#0x14]         ;2243
00365c  e3a00002          MOV      r0,#2                 ;2245
003660  e5c60038          STRB     r0,[r6,#0x38]         ;2245
003664  ea00007f          B        |L1.14440|
                  |L1.13928|
003668  e5960040          LDR      r0,[r6,#0x40]         ;2251
00366c  e3500000          CMP      r0,#0                 ;2251
003670  1a000018          BNE      |L1.14040|
003674  e3a01000          MOV      r1,#0                 ;2251
003678  e59d0050          LDR      r0,[sp,#0x50]         ;2251
00367c  e58d0004          STR      r0,[sp,#4]            ;2251
003680  e58d1000          STR      r1,[sp,#0]            ;2251
003684  e1a00fc5          ASR      r0,r5,#31             ;2251
003688  e5942054          LDR      r2,[r4,#0x54]         ;2251
00368c  e58d0034          STR      r0,[sp,#0x34]         ;2251
003690  e58d5038          STR      r5,[sp,#0x38]         ;2251
003694  e1a00005          MOV      r0,r5                 ;2251
003698  e59d1034          LDR      r1,[sp,#0x34]         ;2251
00369c  ebfffffe          BL       __aeabi_llsl
0036a0  e1cd00f8          STRD     r0,r1,[sp,#8]         ;2251
0036a4  e1a02000          MOV      r2,r0                 ;2251
0036a8  e1a03001          MOV      r3,r1                 ;2251
0036ac  e59d0048          LDR      r0,[sp,#0x48]         ;2251
0036b0  ebfffffe          BL       nand_block_checkbad
0036b4  e3500000          CMP      r0,#0                 ;2251
0036b8  0a000006          BEQ      |L1.14040|
0036bc  e1a02005          MOV      r2,r5                 ;2253
0036c0  e59f128c          LDR      r1,|L1.14676|
0036c4  e28f0fa3          ADR      r0,|L1.14680|
0036c8  ebfffffe          BL       sysprintf
0036cc  e3a00010          MOV      r0,#0x10              ;2255
0036d0  e5c60038          STRB     r0,[r6,#0x38]         ;2255
0036d4  ea00006c          B        |L1.14476|
                  |L1.14040|
0036d8  e5940074          LDR      r0,[r4,#0x74]         ;2263
0036dc  e1500005          CMP      r0,r5                 ;2263
0036e0  ba000006          BLT      |L1.14080|
0036e4  e5941074          LDR      r1,[r4,#0x74]         ;2263
0036e8  e59d001c          LDR      r0,[sp,#0x1c]         ;2263
0036ec  e0800005          ADD      r0,r0,r5              ;2263
0036f0  e1510000          CMP      r1,r0                 ;2263
0036f4  aa000001          BGE      |L1.14080|
0036f8  e3e00000          MVN      r0,#0                 ;2265
0036fc  e5840074          STR      r0,[r4,#0x74]         ;2265
                  |L1.14080|
003700  e5940070          LDR      r0,[r4,#0x70]         ;2267
003704  e0001005          AND      r1,r0,r5              ;2267
003708  e594203c          LDR      r2,[r4,#0x3c]         ;2267
00370c  e59d0048          LDR      r0,[sp,#0x48]         ;2267
003710  e12fff32          BLX      r2                    ;2267
003714  e5942038          LDR      r2,[r4,#0x38]         ;2269
003718  e1a01004          MOV      r1,r4                 ;2269
00371c  e59d0048          LDR      r0,[sp,#0x48]         ;2269
003720  e12fff32          BLX      r2                    ;2269
003724  e58d0020          STR      r0,[sp,#0x20]         ;2269
003728  e59d0020          LDR      r0,[sp,#0x20]         ;2275
00372c  e3100001          TST      r0,#1                 ;2275
003730  0a00000a          BEQ      |L1.14176|
003734  e5940044          LDR      r0,[r4,#0x44]         ;2275
003738  e3500000          CMP      r0,#0                 ;2275
00373c  0a000007          BEQ      |L1.14176|
003740  e58d5000          STR      r5,[sp,#0]            ;2276
003744  e594c044          LDR      r12,[r4,#0x44]        ;2276
003748  e3a02003          MOV      r2,#3                 ;2276
00374c  e1a01004          MOV      r1,r4                 ;2276
003750  e59d0048          LDR      r0,[sp,#0x48]         ;2276
003754  e59d3020          LDR      r3,[sp,#0x20]         ;2276
003758  e12fff3c          BLX      r12                   ;2276
00375c  e58d0020          STR      r0,[sp,#0x20]         ;2276
                  |L1.14176|
003760  e59d0020          LDR      r0,[sp,#0x20]         ;2280
003764  e3100001          TST      r0,#1                 ;2280
003768  0a00000c          BEQ      |L1.14240|
00376c  e1a00000          MOV      r0,r0                 ;2281
003770  e1a00000          MOV      r0,r0                 ;2281
003774  e3a00010          MOV      r0,#0x10              ;2283
003778  e5c60038          STRB     r0,[r6,#0x38]         ;2283
00377c  e1a00fc5          ASR      r0,r5,#31             ;2284
003780  e1a0b005          MOV      r11,r5                ;2284
003784  e5942054          LDR      r2,[r4,#0x54]         ;2284
003788  e58d003c          STR      r0,[sp,#0x3c]         ;2284
00378c  e1a0000b          MOV      r0,r11                ;2284
003790  e59d103c          LDR      r1,[sp,#0x3c]         ;2284
003794  ebfffffe          BL       __aeabi_llsl
003798  e1c601f8          STRD     r0,r1,[r6,#0x18]      ;2284
00379c  ea00003a          B        |L1.14476|
                  |L1.14240|
0037a0  e37a0001          CMN      r10,#1                ;2293
0037a4  0a00000c          BEQ      |L1.14300|
0037a8  e3c500c0          BIC      r0,r5,#0xc0           ;2294
0037ac  e150000a          CMP      r0,r10                ;2294
0037b0  1a000009          BNE      |L1.14300|
0037b4  e1a00fc5          ASR      r0,r5,#31             ;2295
0037b8  e5942054          LDR      r2,[r4,#0x54]         ;2295
0037bc  e58d0040          STR      r0,[sp,#0x40]         ;2295
0037c0  e58d5044          STR      r5,[sp,#0x44]         ;2295
0037c4  e1a00005          MOV      r0,r5                 ;2295
0037c8  e59d1040          LDR      r1,[sp,#0x40]         ;2295
0037cc  ebfffffe          BL       __aeabi_llsl
0037d0  e28d2010          ADD      r2,sp,#0x10           ;2295
0037d4  e7a20189          STR      r0,[r2,r9,LSL #3]!    ;2295
0037d8  e5821004          STR      r1,[r2,#4]            ;2295
                  |L1.14300|
0037dc  e5d40058          LDRB     r0,[r4,#0x58]         ;2299
0037e0  e3a01001          MOV      r1,#1                 ;2299
0037e4  e1a00011          LSL      r0,r1,r0              ;2299
0037e8  e0577000          SUBS     r7,r7,r0              ;2299
0037ec  e0c88fc0          SBC      r8,r8,r0,ASR #31      ;2299
0037f0  e59d001c          LDR      r0,[sp,#0x1c]         ;2300
0037f4  e0855000          ADD      r5,r5,r0              ;2300
0037f8  e3a01000          MOV      r1,#0                 ;2300
0037fc  e1a00001          MOV      r0,r1                 ;2300
003800  e0211007          EOR      r1,r1,r7              ;2300
003804  e0200008          EOR      r0,r0,r8              ;2300
003808  e1900001          ORRS     r0,r0,r1              ;2303
00380c  0a000015          BEQ      |L1.14440|
003810  e5940070          LDR      r0,[r4,#0x70]         ;2303
003814  e1100005          TST      r0,r5                 ;2303
003818  1a000012          BNE      |L1.14440|
00381c  e2899001          ADD      r9,r9,#1              ;2304
003820  e3e01000          MVN      r1,#0                 ;2305
003824  e594201c          LDR      r2,[r4,#0x1c]         ;2305
003828  e59d0048          LDR      r0,[sp,#0x48]         ;2305
00382c  e12fff32          BLX      r2                    ;2305
003830  e1a01009          MOV      r1,r9                 ;2306
003834  e594201c          LDR      r2,[r4,#0x1c]         ;2306
003838  e59d0048          LDR      r0,[sp,#0x48]         ;2306
00383c  e12fff32          BLX      r2                    ;2306
003840  e37a0001          CMN      r10,#1                ;2312
003844  0a000007          BEQ      |L1.14440|
003848  e5940114          LDR      r0,[r4,#0x114]        ;2313
00384c  e5d00000          LDRB     r0,[r0,#0]            ;2313
003850  e3100080          TST      r0,#0x80              ;2313
003854  0a000003          BEQ      |L1.14440|
003858  e5940114          LDR      r0,[r4,#0x114]        ;2314
00385c  e2800004          ADD      r0,r0,#4              ;2314
003860  e7900109          LDR      r0,[r0,r9,LSL #2]     ;2314
003864  e3c0a0c0          BIC      r10,r0,#0xc0          ;2314
                  |L1.14440|
003868  e3a01000          MOV      r1,#0                 ;2314
00386c  e1a00001          MOV      r0,r1                 ;2314
003870  e0211007          EOR      r1,r1,r7              ;2314
003874  e0200008          EOR      r0,r0,r8              ;2314
003878  e1900001          ORRS     r0,r0,r1              ;2247
00387c  1affff79          BNE      |L1.13928|
003880  e3a00008          MOV      r0,#8                 ;2318
003884  e5c60038          STRB     r0,[r6,#0x38]         ;2318
003888  e1a00000          MOV      r0,r0                 ;2320
                  |L1.14476|
00388c  e5d60038          LDRB     r0,[r6,#0x38]         ;2322
003890  e3500008          CMP      r0,#8                 ;2322
003894  1a000001          BNE      |L1.14496|
003898  e3a00000          MOV      r0,#0                 ;2322
00389c  ea000000          B        |L1.14500|
                  |L1.14496|
0038a0  e3e00004          MVN      r0,#4                 ;2322
                  |L1.14500|
0038a4  e58d0018          STR      r0,[sp,#0x18]         ;2322
0038a8  e59d0048          LDR      r0,[sp,#0x48]         ;2325
0038ac  ebfffffe          BL       nand_release_device
0038b0  e59d0018          LDR      r0,[sp,#0x18]         ;2328
0038b4  e3500000          CMP      r0,#0                 ;2328
0038b8  1a000001          BNE      |L1.14532|
0038bc  e1a00006          MOV      r0,r6                 ;2329
0038c0  ebfffffe          BL       mtd_erase_callback
                  |L1.14532|
0038c4  e37a0001          CMN      r10,#1                ;2335
0038c8  0a000002          BEQ      |L1.14552|
0038cc  e59d0018          LDR      r0,[sp,#0x18]         ;2335
0038d0  e3500000          CMP      r0,#0                 ;2335
0038d4  0a000001          BEQ      |L1.14560|
                  |L1.14552|
0038d8  e59d0018          LDR      r0,[sp,#0x18]         ;2336
0038dc  eaffff27          B        |L1.13696|
                  |L1.14560|
0038e0  e3a09000          MOV      r9,#0                 ;2338
0038e4  ea000015          B        |L1.14656|
                  |L1.14568|
0038e8  e28d0010          ADD      r0,sp,#0x10           ;2339
0038ec  e7b03189          LDR      r3,[r0,r9,LSL #3]!    ;2339
0038f0  e5901004          LDR      r1,[r0,#4]            ;2339
0038f4  e3a00000          MOV      r0,#0                 ;2339
0038f8  e1a02000          MOV      r2,r0                 ;2339
0038fc  e0200003          EOR      r0,r0,r3              ;2339
003900  e0211002          EOR      r1,r1,r2              ;2339
003904  e1900001          ORRS     r0,r0,r1              ;2339
003908  1a000000          BNE      |L1.14608|
00390c  ea00000a          B        |L1.14652|
                  |L1.14608|
003910  e1a00000          MOV      r0,r0                 ;2342
003914  e1a00000          MOV      r0,r0                 ;2342
003918  e28d0010          ADD      r0,sp,#0x10           ;2345
00391c  e0801189          ADD      r1,r0,r9,LSL #3       ;2345
003920  e1c100d0          LDRD     r0,r1,[r1,#0]         ;2345
003924  e1cd00f8          STRD     r0,r1,[sp,#8]         ;2345
003928  e1a02000          MOV      r2,r0                 ;2345
00392c  e1a03001          MOV      r3,r1                 ;2345
003930  e59d0048          LDR      r0,[sp,#0x48]         ;2345
003934  ebfffffe          BL       nand_update_bbt
003938  e1a00000          MOV      r0,r0                 ;2340
                  |L1.14652|
00393c  e2899001          ADD      r9,r9,#1              ;2338
                  |L1.14656|
003940  e5940064          LDR      r0,[r4,#0x64]         ;2338
003944  e1500009          CMP      r0,r9                 ;2338
003948  caffffe6          BGT      |L1.14568|
00394c  e59d0018          LDR      r0,[sp,#0x18]         ;2349
003950  eaffff0a          B        |L1.13696|
                  |L1.14676|
                          DCD      |symbol_number.36|
                  |L1.14680|
003958  25733a20          DCB      "%s: attempt to erase a bad block at page 0x%08x\n",0
00395c  61747465
003960  6d707420
003964  746f2065
003968  72617365
00396c  20612062
003970  61642062
003974  6c6f636b
003978  20617420
00397c  70616765
003980  20307825
003984  3038780a
003988  00      
003989  00                DCB      0
00398a  00                DCB      0
00398b  00                DCB      0
                          ENDP

                  nand_erase PROC
;;;2179    */
;;;2180   static int nand_erase(struct mtd_info *mtd, struct erase_info *instr)
00398c  e92d4070          PUSH     {r4-r6,lr}
;;;2181   {
003990  e1a04000          MOV      r4,r0
003994  e1a05001          MOV      r5,r1
;;;2182   	return nand_erase_nand(mtd, instr, 0);
003998  e3a02000          MOV      r2,#0
00399c  e1a01005          MOV      r1,r5
0039a0  e1a00004          MOV      r0,r4
0039a4  ebfffffe          BL       nand_erase_nand
;;;2183   }
0039a8  e8bd8070          POP      {r4-r6,pc}
;;;2184   
                          ENDP

                  nand_sync PROC
;;;2357    */
;;;2358   static void nand_sync(struct mtd_info *mtd)
0039ac  e92d4070          PUSH     {r4-r6,lr}
;;;2359   {
0039b0  e1a04000          MOV      r4,r0
;;;2360   	struct nand_chip *chip = mtd->priv;
0039b4  e5945094          LDR      r5,[r4,#0x94]
;;;2361   
;;;2362   	MTDDEBUG(MTD_DEBUG_LEVEL3, "%s: called\n", __func__);
0039b8  e1a00000          MOV      r0,r0
0039bc  e1a00000          MOV      r0,r0
;;;2363   
;;;2364   	/* Grab the lock and see if the device is available */
;;;2365   	nand_get_device(chip, mtd, FL_SYNCING);
0039c0  e3a02004          MOV      r2,#4
0039c4  e1a01004          MOV      r1,r4
0039c8  e1a00005          MOV      r0,r5
0039cc  ebfffffe          BL       nand_get_device
;;;2366   	/* Release it and go back */
;;;2367   	nand_release_device(mtd);
0039d0  e1a00004          MOV      r0,r4
0039d4  ebfffffe          BL       nand_release_device
;;;2368   }
0039d8  e8bd8070          POP      {r4-r6,pc}
;;;2369   
                          ENDP

                  nand_block_isbad PROC
;;;2374    */
;;;2375   static int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
0039dc  e92d407c          PUSH     {r2-r6,lr}
;;;2376   {
0039e0  e1a06000          MOV      r6,r0
0039e4  e1a04002          MOV      r4,r2
0039e8  e1a05003          MOV      r5,r3
;;;2377   	/* Check for invalid offset */
;;;2378   	if (offs > mtd->size)
0039ec  e1c600d8          LDRD     r0,r1,[r6,#8]
0039f0  e0500004          SUBS     r0,r0,r4
0039f4  e0d10005          SBCS     r0,r1,r5
0039f8  2a000001          BCS      |L1.14852|
;;;2379   		return -EINVAL;
0039fc  e3e00015          MVN      r0,#0x15
                  |L1.14848|
;;;2380   
;;;2381   	return nand_block_checkbad(mtd, offs, 1, 0);
;;;2382   }
003a00  e8bd807c          POP      {r2-r6,pc}
                  |L1.14852|
003a04  e3a00000          MOV      r0,#0                 ;2381
003a08  e3a01001          MOV      r1,#1                 ;2381
003a0c  e1a02004          MOV      r2,r4                 ;2381
003a10  e1a03005          MOV      r3,r5                 ;2381
003a14  e58d0004          STR      r0,[sp,#4]            ;2381
003a18  e1a00006          MOV      r0,r6                 ;2381
003a1c  e58d1000          STR      r1,[sp,#0]            ;2381
003a20  ebfffffe          BL       nand_block_checkbad
003a24  eafffff5          B        |L1.14848|
;;;2383   
                          ENDP

                  nand_block_markbad PROC
;;;2388    */
;;;2389   static int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
003a28  e92d41f0          PUSH     {r4-r8,lr}
;;;2390   {
003a2c  e1a07000          MOV      r7,r0
003a30  e1a05002          MOV      r5,r2
003a34  e1a06003          MOV      r6,r3
;;;2391   	struct nand_chip *chip = mtd->priv;
003a38  e5978094          LDR      r8,[r7,#0x94]
;;;2392   	int ret;
;;;2393   
;;;2394   	ret = nand_block_isbad(mtd, ofs);
003a3c  e1a02005          MOV      r2,r5
003a40  e1a03006          MOV      r3,r6
003a44  e1a00007          MOV      r0,r7
003a48  ebfffffe          BL       nand_block_isbad
003a4c  e1a04000          MOV      r4,r0
;;;2395   	if (ret) {
003a50  e3540000          CMP      r4,#0
003a54  0a000005          BEQ      |L1.14960|
;;;2396   		/* If it was bad already, return success and do nothing. */
;;;2397   		if (ret > 0)
003a58  e3540000          CMP      r4,#0
003a5c  da000001          BLE      |L1.14952|
;;;2398   			return 0;
003a60  e3a00000          MOV      r0,#0
                  |L1.14948|
;;;2399   		return ret;
;;;2400   	}
;;;2401   
;;;2402   	return chip->block_markbad(mtd, ofs);
;;;2403   }
003a64  e8bd81f0          POP      {r4-r8,pc}
                  |L1.14952|
003a68  e1a00004          MOV      r0,r4                 ;2399
003a6c  eafffffc          B        |L1.14948|
                  |L1.14960|
003a70  e1a02005          MOV      r2,r5                 ;2402
003a74  e1a03006          MOV      r3,r6                 ;2402
003a78  e1a00007          MOV      r0,r7                 ;2402
003a7c  e5981024          LDR      r1,[r8,#0x24]         ;2402
003a80  e12fff31          BLX      r1                    ;2402
003a84  eafffff6          B        |L1.14948|
;;;2404   
                          ENDP

                  nand_set_defaults PROC
;;;2407    */
;;;2408   static void nand_set_defaults(struct nand_chip *chip, int busw)
003a88  e590204c          LDR      r2,[r0,#0x4c]
;;;2409   {
;;;2410   	/* check for proper chip_delay setup, set 20us if not */
;;;2411   	if (!chip->chip_delay)
003a8c  e3520000          CMP      r2,#0
003a90  1a000001          BNE      |L1.15004|
;;;2412   		chip->chip_delay = 20;
003a94  e3a02014          MOV      r2,#0x14
003a98  e580204c          STR      r2,[r0,#0x4c]
                  |L1.15004|
;;;2413   
;;;2414   	/* check, if a user supplied command function given */
;;;2415   	if (chip->cmdfunc == NULL)
003a9c  e5902034          LDR      r2,[r0,#0x34]
003aa0  e3520000          CMP      r2,#0
003aa4  1a000001          BNE      |L1.15024|
;;;2416   		chip->cmdfunc = nand_command;
003aa8  e59f24bc          LDR      r2,|L1.16236|
003aac  e5802034          STR      r2,[r0,#0x34]
                  |L1.15024|
;;;2417   
;;;2418   	/* check, if a user supplied wait function given */
;;;2419   	if (chip->waitfunc == NULL)
003ab0  e5902038          LDR      r2,[r0,#0x38]
003ab4  e3520000          CMP      r2,#0
003ab8  1a000001          BNE      |L1.15044|
;;;2420   		chip->waitfunc = nand_wait;
003abc  e59f24ac          LDR      r2,|L1.16240|
003ac0  e5802038          STR      r2,[r0,#0x38]
                  |L1.15044|
;;;2421   
;;;2422   	if (!chip->select_chip)
003ac4  e590201c          LDR      r2,[r0,#0x1c]
003ac8  e3520000          CMP      r2,#0
003acc  1a000001          BNE      |L1.15064|
;;;2423   		chip->select_chip = nand_select_chip;
003ad0  e59f249c          LDR      r2,|L1.16244|
003ad4  e580201c          STR      r2,[r0,#0x1c]
                  |L1.15064|
;;;2424   	if (!chip->read_byte)
003ad8  e5902008          LDR      r2,[r0,#8]
003adc  e3520000          CMP      r2,#0
003ae0  1a000005          BNE      |L1.15100|
;;;2425   		chip->read_byte = busw ? nand_read_byte16 : nand_read_byte;
003ae4  e3510000          CMP      r1,#0
003ae8  0a000001          BEQ      |L1.15092|
003aec  e59f2484          LDR      r2,|L1.16248|
003af0  ea000000          B        |L1.15096|
                  |L1.15092|
003af4  e59f2480          LDR      r2,|L1.16252|
                  |L1.15096|
003af8  e5802008          STR      r2,[r0,#8]
                  |L1.15100|
;;;2426   	if (!chip->read_word)
003afc  e590200c          LDR      r2,[r0,#0xc]
003b00  e3520000          CMP      r2,#0
003b04  1a000001          BNE      |L1.15120|
;;;2427   		chip->read_word = nand_read_word;
003b08  e59f2470          LDR      r2,|L1.16256|
003b0c  e580200c          STR      r2,[r0,#0xc]
                  |L1.15120|
;;;2428   	if (!chip->block_bad)
003b10  e5902020          LDR      r2,[r0,#0x20]
003b14  e3520000          CMP      r2,#0
003b18  1a000001          BNE      |L1.15140|
;;;2429   		chip->block_bad = nand_block_bad;
003b1c  e59f2460          LDR      r2,|L1.16260|
003b20  e5802020          STR      r2,[r0,#0x20]
                  |L1.15140|
;;;2430   	if (!chip->block_markbad)
003b24  e5902024          LDR      r2,[r0,#0x24]
003b28  e3520000          CMP      r2,#0
003b2c  1a000001          BNE      |L1.15160|
;;;2431   		chip->block_markbad = nand_default_block_markbad;
003b30  e59f2450          LDR      r2,|L1.16264|
003b34  e5802024          STR      r2,[r0,#0x24]
                  |L1.15160|
;;;2432   	if (!chip->write_buf)
003b38  e5902010          LDR      r2,[r0,#0x10]
003b3c  e3520000          CMP      r2,#0
003b40  1a000005          BNE      |L1.15196|
;;;2433   		chip->write_buf = busw ? nand_write_buf16 : nand_write_buf;
003b44  e3510000          CMP      r1,#0
003b48  0a000001          BEQ      |L1.15188|
003b4c  e59f2438          LDR      r2,|L1.16268|
003b50  ea000000          B        |L1.15192|
                  |L1.15188|
003b54  e59f2434          LDR      r2,|L1.16272|
                  |L1.15192|
003b58  e5802010          STR      r2,[r0,#0x10]
                  |L1.15196|
;;;2434   	if (!chip->read_buf)
003b5c  e5902014          LDR      r2,[r0,#0x14]
003b60  e3520000          CMP      r2,#0
003b64  1a000005          BNE      |L1.15232|
;;;2435   		chip->read_buf = busw ? nand_read_buf16 : nand_read_buf;
003b68  e3510000          CMP      r1,#0
003b6c  0a000001          BEQ      |L1.15224|
003b70  e59f241c          LDR      r2,|L1.16276|
003b74  ea000000          B        |L1.15228|
                  |L1.15224|
003b78  e59f2418          LDR      r2,|L1.16280|
                  |L1.15228|
003b7c  e5802014          STR      r2,[r0,#0x14]
                  |L1.15232|
;;;2436   	if (!chip->verify_buf)
003b80  e5902018          LDR      r2,[r0,#0x18]
003b84  e3520000          CMP      r2,#0
003b88  1a000005          BNE      |L1.15268|
;;;2437   		chip->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
003b8c  e3510000          CMP      r1,#0
003b90  0a000001          BEQ      |L1.15260|
003b94  e59f2400          LDR      r2,|L1.16284|
003b98  ea000000          B        |L1.15264|
                  |L1.15260|
003b9c  e59f23fc          LDR      r2,|L1.16288|
                  |L1.15264|
003ba0  e5802018          STR      r2,[r0,#0x18]
                  |L1.15268|
;;;2438   	if (!chip->scan_bbt)
003ba4  e5902040          LDR      r2,[r0,#0x40]
003ba8  e3520000          CMP      r2,#0
003bac  1a000001          BNE      |L1.15288|
;;;2439   		chip->scan_bbt = nand_default_bbt;
003bb0  e59f23ec          LDR      r2,|L1.16292|
003bb4  e5802040          STR      r2,[r0,#0x40]
                  |L1.15288|
;;;2440   	if (!chip->controller)
003bb8  e5902094          LDR      r2,[r0,#0x94]
003bbc  e3520000          CMP      r2,#0
003bc0  1a000001          BNE      |L1.15308|
;;;2441   		chip->controller = &chip->hwcontrol;
003bc4  e28020ec          ADD      r2,r0,#0xec
003bc8  e5802094          STR      r2,[r0,#0x94]
                  |L1.15308|
;;;2442   }
003bcc  e12fff1e          BX       lr
;;;2443   
                          ENDP

                  nand_get_flash_type PROC
;;;2557    */
;;;2558   static const struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
003bd0  e92d4ff0          PUSH     {r4-r11,lr}
;;;2559   						  struct nand_chip *chip,
;;;2560   						  int busw,
;;;2561   						  int *maf_id, int *dev_id,
;;;2562   						  const struct nand_flash_dev *type)
;;;2563   {
003bd4  e24dd024          SUB      sp,sp,#0x24
003bd8  e1a05000          MOV      r5,r0
003bdc  e1a04001          MOV      r4,r1
003be0  e1a09002          MOV      r9,r2
003be4  e1a07003          MOV      r7,r3
003be8  e59d604c          LDR      r6,[sp,#0x4c]
003bec  e59da048          LDR      r10,[sp,#0x48]
;;;2564   	const char *name;
;;;2565   	int i, maf_idx;
;;;2566   	u8 id_data[8];
;;;2567   	int ret;
;;;2568   
;;;2569   	/* Select the device */
;;;2570   	chip->select_chip(mtd, 0);
003bf0  e3a01000          MOV      r1,#0
003bf4  e1a00005          MOV      r0,r5
003bf8  e594201c          LDR      r2,[r4,#0x1c]
003bfc  e12fff32          BLX      r2
;;;2571   
;;;2572   	/*
;;;2573   	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
;;;2574   	 * after power-up
;;;2575   	 */
;;;2576   	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
003c00  e3e03000          MVN      r3,#0
003c04  e1a02003          MOV      r2,r3
003c08  e3a010ff          MOV      r1,#0xff
003c0c  e1a00005          MOV      r0,r5
003c10  e594c034          LDR      r12,[r4,#0x34]
003c14  e12fff3c          BLX      r12
;;;2577   
;;;2578   	/* Send the command for reading device ID */
;;;2579   	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
003c18  e3e03000          MVN      r3,#0
003c1c  e3a02000          MOV      r2,#0
003c20  e3a01090          MOV      r1,#0x90
003c24  e1a00005          MOV      r0,r5
003c28  e594c034          LDR      r12,[r4,#0x34]
003c2c  e12fff3c          BLX      r12
;;;2580   
;;;2581   	/* Read manufacturer and device IDs */
;;;2582   	*maf_id = chip->read_byte(mtd);
003c30  e1a00005          MOV      r0,r5
003c34  e5941008          LDR      r1,[r4,#8]
003c38  e12fff31          BLX      r1
003c3c  e5870000          STR      r0,[r7,#0]
;;;2583   	*dev_id = chip->read_byte(mtd);
003c40  e1a00005          MOV      r0,r5
003c44  e5941008          LDR      r1,[r4,#8]
003c48  e12fff31          BLX      r1
003c4c  e58a0000          STR      r0,[r10,#0]
;;;2584   
;;;2585   	/* Try again to make sure, as some systems the bus-hold or other
;;;2586   	 * interface concerns can cause random data which looks like a
;;;2587   	 * possibly credible NAND flash to appear. If the two results do
;;;2588   	 * not match, ignore the device completely.
;;;2589   	 */
;;;2590   
;;;2591   	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
003c50  e3e03000          MVN      r3,#0
003c54  e3a02000          MOV      r2,#0
003c58  e3a01090          MOV      r1,#0x90
003c5c  e1a00005          MOV      r0,r5
003c60  e594c034          LDR      r12,[r4,#0x34]
003c64  e12fff3c          BLX      r12
;;;2592   
;;;2593   	for (i = 0; i < 2; i++)
003c68  e3a08000          MOV      r8,#0
003c6c  ea000005          B        |L1.15496|
                  |L1.15472|
;;;2594   		id_data[i] = chip->read_byte(mtd);
003c70  e1a00005          MOV      r0,r5
003c74  e5941008          LDR      r1,[r4,#8]
003c78  e12fff31          BLX      r1
003c7c  e28d1010          ADD      r1,sp,#0x10
003c80  e7c10008          STRB     r0,[r1,r8]
003c84  e2888001          ADD      r8,r8,#1              ;2593
                  |L1.15496|
003c88  e3580002          CMP      r8,#2                 ;2593
003c8c  bafffff7          BLT      |L1.15472|
;;;2595   
;;;2596   	if (id_data[0] != *maf_id || id_data[1] != *dev_id) {
003c90  e5dd0010          LDRB     r0,[sp,#0x10]
003c94  e5971000          LDR      r1,[r7,#0]
003c98  e1500001          CMP      r0,r1
003c9c  1a000003          BNE      |L1.15536|
003ca0  e5dd0011          LDRB     r0,[sp,#0x11]
003ca4  e59a1000          LDR      r1,[r10,#0]
003ca8  e1500001          CMP      r0,r1
003cac  0a00000c          BEQ      |L1.15588|
                  |L1.15536|
;;;2597   		printk(KERN_INFO "%s: second ID read did not match "
003cb0  e5dd0011          LDRB     r0,[sp,#0x11]
003cb4  e5dd1010          LDRB     r1,[sp,#0x10]
003cb8  e58d0004          STR      r0,[sp,#4]
003cbc  e58d1000          STR      r1,[sp,#0]
003cc0  e59a3000          LDR      r3,[r10,#0]
003cc4  e59f12dc          LDR      r1,|L1.16296|
003cc8  e28f0fb7          ADR      r0,|L1.16300|
003ccc  e5972000          LDR      r2,[r7,#0]
003cd0  ebfffffe          BL       sysprintf
;;;2598   		       "%02x,%02x against %02x,%02x\n", __func__,
;;;2599   		       *maf_id, *dev_id, id_data[0], id_data[1]);
;;;2600   		return ERR_PTR(-ENODEV);
003cd4  e3e00012          MVN      r0,#0x12
003cd8  e1a00000          MOV      r0,r0
                  |L1.15580|
003cdc  e28dd024          ADD      sp,sp,#0x24
;;;2601   	}
;;;2602   
;;;2603   	if (!type)
;;;2604   		type = nand_flash_ids;
;;;2605   
;;;2606   	for (; type->name != NULL; type++)
;;;2607   		if (*dev_id == type->id)
;;;2608   			break;
;;;2609   
;;;2610   	chip->onfi_version = 0;
;;;2611   	if (!type->name || !type->pagesize) {
;;;2612   		/* Check is chip is ONFI compliant */
;;;2613   		ret = nand_flash_detect_onfi(mtd, chip, &busw);
;;;2614   		if (ret)
;;;2615   			goto ident_done;
;;;2616   	}
;;;2617   
;;;2618   	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
;;;2619   
;;;2620   	/* Read entire ID string */
;;;2621   
;;;2622   	for (i = 0; i < 8; i++)
;;;2623   		id_data[i] = chip->read_byte(mtd);
;;;2624   
;;;2625   	if (!type->name)
;;;2626   		return ERR_PTR(-ENODEV);
;;;2627   
;;;2628   	if (!mtd->name)
;;;2629   		mtd->name = type->name;
;;;2630   
;;;2631   	chip->chipsize = (uint64_t)type->chipsize << 20;
;;;2632   chip->init_size = 0; //CWWeng
;;;2633   	if (!type->pagesize && chip->init_size) {
;;;2634   		/* set the pagesize, oobsize, erasesize by the driver*/
;;;2635   		busw = chip->init_size(mtd, chip, id_data);
;;;2636   	} else if (!type->pagesize) {
;;;2637   		int extid;
;;;2638   		/* The 3rd id byte holds MLC / multichip data */
;;;2639   		chip->cellinfo = id_data[2];
;;;2640   		/* The 4th id byte is the important one */
;;;2641   		extid = id_data[3];
;;;2642   
;;;2643   		/*
;;;2644   		 * Field definitions are in the following datasheets:
;;;2645   		 * Old style (4,5 byte ID): Samsung K9GAG08U0M (p.32)
;;;2646   		 * New style   (6 byte ID): Samsung K9GBG08U0M (p.40)
;;;2647   		 *
;;;2648   		 * Check for wraparound + Samsung ID + nonzero 6th byte
;;;2649   		 * to decide what to do.
;;;2650   		 */
;;;2651   		if (id_data[0] == id_data[6] && id_data[1] == id_data[7] &&
;;;2652   				id_data[0] == NAND_MFR_SAMSUNG &&
;;;2653   				(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
;;;2654   				id_data[5] != 0x00) {
;;;2655   			/* Calc pagesize */
;;;2656   			mtd->writesize = 2048 << (extid & 0x03);
;;;2657   			extid >>= 2;
;;;2658   			/* Calc oobsize */
;;;2659   			switch (extid & 0x03) {
;;;2660   			case 1:
;;;2661   				mtd->oobsize = 128;
;;;2662   				break;
;;;2663   			case 2:
;;;2664   				mtd->oobsize = 218;
;;;2665   				break;
;;;2666   			case 3:
;;;2667   				mtd->oobsize = 400;
;;;2668   				break;
;;;2669   			default:
;;;2670   				mtd->oobsize = 436;
;;;2671   				break;
;;;2672   			}
;;;2673   			extid >>= 2;
;;;2674   			/* Calc blocksize */
;;;2675   			mtd->erasesize = (128 * 1024) <<
;;;2676   				(((extid >> 1) & 0x04) | (extid & 0x03));
;;;2677   			busw = 0;
;;;2678   		} else {
;;;2679   			/* Calc pagesize */
;;;2680   			mtd->writesize = 1024 << (extid & 0x03);
;;;2681   			extid >>= 2;
;;;2682   			/* Calc oobsize */
;;;2683   			mtd->oobsize = (8 << (extid & 0x01)) *
;;;2684   				(mtd->writesize >> 9);
;;;2685   			extid >>= 2;
;;;2686   			/* Calc blocksize. Blocksize is multiples of 64KiB */
;;;2687   			mtd->erasesize = (64 * 1024) << (extid & 0x03);
;;;2688   			extid >>= 2;
;;;2689   			/* Get buswidth information */
;;;2690   			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
;;;2691   		}
;;;2692   	} else {
;;;2693   		/*
;;;2694   		 * Old devices have chip data hardcoded in the device id table
;;;2695   		 */
;;;2696   		mtd->erasesize = type->erasesize;
;;;2697   		mtd->writesize = type->pagesize;
;;;2698   		mtd->oobsize = mtd->writesize / 32;
;;;2699   		busw = type->options & NAND_BUSWIDTH_16;
;;;2700   
;;;2701   		/*
;;;2702   		 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
;;;2703   		 * some Spansion chips have erasesize that conflicts with size
;;;2704   		 * listed in nand_ids table
;;;2705   		 * Data sheet (5 byte ID): Spansion S30ML-P ORNAND (p.39)
;;;2706   		 */
;;;2707   		if (*maf_id == NAND_MFR_AMD && id_data[4] != 0x00 &&
;;;2708   				id_data[5] == 0x00 && id_data[6] == 0x00 &&
;;;2709   				id_data[7] == 0x00 && mtd->writesize == 512) {
;;;2710   			mtd->erasesize = 128 * 1024;
;;;2711   			mtd->erasesize <<= ((id_data[3] & 0x03) << 1);
;;;2712   		}
;;;2713   	}
;;;2714   	/* Get chip options, preserve non chip based options */
;;;2715   	chip->options |= type->options;
;;;2716   
;;;2717   	/* Check if chip is a not a samsung device. Do not clear the
;;;2718   	 * options for chips which are not having an extended id.
;;;2719   	 */
;;;2720   	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
;;;2721   		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
;;;2722   ident_done:
;;;2723   
;;;2724   	/*
;;;2725   	 * Set chip as a default. Board drivers can override it, if necessary
;;;2726   	 */
;;;2727   	chip->options |= NAND_NO_AUTOINCR;
;;;2728   
;;;2729   	/* Try to identify manufacturer */
;;;2730   	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
;;;2731   		if (nand_manuf_ids[maf_idx].id == *maf_id)
;;;2732   			break;
;;;2733   	}
;;;2734   
;;;2735   	/*
;;;2736   	 * Check, if buswidth is correct. Hardware drivers should set
;;;2737   	 * chip correct !
;;;2738   	 */
;;;2739   	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
;;;2740   		printk(KERN_INFO "NAND device: Manufacturer ID:"
;;;2741   		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
;;;2742   		       *dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
;;;2743   		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
;;;2744   		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
;;;2745   		       busw ? 16 : 8);
;;;2746   		return ERR_PTR(-EINVAL);
;;;2747   	}
;;;2748   
;;;2749   	/* Calculate the address shift from the page size */
;;;2750   	chip->page_shift = ffs(mtd->writesize) - 1;
;;;2751   	/* Convert chipsize to number of pages per chip -1. */
;;;2752   	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
;;;2753   
;;;2754   	chip->bbt_erase_shift = chip->phys_erase_shift =
;;;2755   		ffs(mtd->erasesize) - 1;
;;;2756   	if (chip->chipsize & 0xffffffff)
;;;2757   		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
;;;2758   	else {
;;;2759   		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32));
;;;2760   		chip->chip_shift += 32 - 1;
;;;2761   	}
;;;2762   
;;;2763   	chip->badblockbits = 8;
;;;2764   
;;;2765   	/* Set the bad block position */
;;;2766   	if (mtd->writesize > 512 || (busw & NAND_BUSWIDTH_16))
;;;2767   		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
;;;2768   	else
;;;2769   		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
;;;2770   
;;;2771   	/*
;;;2772   	 * Bad block marker is stored in the last page of each block
;;;2773   	 * on Samsung and Hynix MLC devices; stored in first two pages
;;;2774   	 * of each block on Micron devices with 2KiB pages and on
;;;2775   	 * SLC Samsung, Hynix, Toshiba and AMD/Spansion. All others scan
;;;2776   	 * only the first page.
;;;2777   	 */
;;;2778   	if ((chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
;;;2779   			(*maf_id == NAND_MFR_SAMSUNG ||
;;;2780   			 *maf_id == NAND_MFR_HYNIX))
;;;2781   		chip->options |= NAND_BBT_SCANLASTPAGE;
;;;2782   	else if ((!(chip->cellinfo & NAND_CI_CELLTYPE_MSK) &&
;;;2783   				(*maf_id == NAND_MFR_SAMSUNG ||
;;;2784   				 *maf_id == NAND_MFR_HYNIX ||
;;;2785   				 *maf_id == NAND_MFR_TOSHIBA ||
;;;2786   				 *maf_id == NAND_MFR_AMD)) ||
;;;2787   			(mtd->writesize == 2048 &&
;;;2788   			 *maf_id == NAND_MFR_MICRON))
;;;2789   		chip->options |= NAND_BBT_SCAN2NDPAGE;
;;;2790   
;;;2791   	/*
;;;2792   	 * Numonyx/ST 2K pages, x8 bus use BOTH byte 1 and 6
;;;2793   	 */
;;;2794   	if (!(busw & NAND_BUSWIDTH_16) &&
;;;2795   			*maf_id == NAND_MFR_STMICRO &&
;;;2796   			mtd->writesize == 2048) {
;;;2797   		chip->options |= NAND_BBT_SCANBYTE1AND6;
;;;2798   		chip->badblockpos = 0;
;;;2799   	}
;;;2800   
;;;2801   	/* Check for AND chips with 4 page planes */
;;;2802   	if (chip->options & NAND_4PAGE_ARRAY)
;;;2803   		chip->erase_cmd = multi_erase_cmd;
;;;2804   	else
;;;2805   		chip->erase_cmd = single_erase_cmd;
;;;2806   
;;;2807   	/* Do not replace user supplied command function ! */
;;;2808   	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
;;;2809   		chip->cmdfunc = nand_command_lp;
;;;2810   
;;;2811   	/* TODO onfi flash name */
;;;2812   	name = type->name;
;;;2813   #ifdef CONFIG_SYS_NAND_ONFI_DETECTION
;;;2814   	if (chip->onfi_version)
;;;2815   		name = chip->onfi_params.model;
;;;2816   #endif
;;;2817   	MTDDEBUG(MTD_DEBUG_LEVEL0, "NAND device: Manufacturer ID:"
;;;2818   		 " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, *dev_id,
;;;2819   		 nand_manuf_ids[maf_idx].name, name);
;;;2820   
;;;2821   	return type;
;;;2822   }
003ce0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.15588|
003ce4  e3560000          CMP      r6,#0                 ;2603
003ce8  1a000000          BNE      |L1.15600|
003cec  e59f62f8          LDR      r6,|L1.16364|
                  |L1.15600|
003cf0  ea000005          B        |L1.15628|
                  |L1.15604|
003cf4  e59a0000          LDR      r0,[r10,#0]           ;2607
003cf8  e5961004          LDR      r1,[r6,#4]            ;2607
003cfc  e1500001          CMP      r0,r1                 ;2607
003d00  1a000000          BNE      |L1.15624|
003d04  ea000003          B        |L1.15640|
                  |L1.15624|
003d08  e2866018          ADD      r6,r6,#0x18           ;2606
                  |L1.15628|
003d0c  e5960000          LDR      r0,[r6,#0]            ;2606
003d10  e3500000          CMP      r0,#0                 ;2606
003d14  1afffff6          BNE      |L1.15604|
                  |L1.15640|
003d18  e1a00000          MOV      r0,r0                 ;2608
003d1c  e3a00000          MOV      r0,#0                 ;2610
003d20  e5840088          STR      r0,[r4,#0x88]         ;2610
003d24  e5960000          LDR      r0,[r6,#0]            ;2611
003d28  e3500000          CMP      r0,#0                 ;2611
003d2c  0a000002          BEQ      |L1.15676|
003d30  e5960008          LDR      r0,[r6,#8]            ;2611
003d34  e3500000          CMP      r0,#0                 ;2611
003d38  1a000006          BNE      |L1.15704|
                  |L1.15676|
003d3c  e1a00000          MOV      r0,r0                 ;2613
003d40  e3a00000          MOV      r0,#0                 ;2613
003d44  e58d000c          STR      r0,[sp,#0xc]          ;2613
003d48  e59d000c          LDR      r0,[sp,#0xc]          ;2614
003d4c  e3500000          CMP      r0,#0                 ;2614
003d50  0a000000          BEQ      |L1.15704|
003d54  ea0000d9          B        |L1.16576|
                  |L1.15704|
003d58  e3e03000          MVN      r3,#0                 ;2618
003d5c  e3a02000          MOV      r2,#0                 ;2618
003d60  e3a01090          MOV      r1,#0x90              ;2618
003d64  e1a00005          MOV      r0,r5                 ;2618
003d68  e594c034          LDR      r12,[r4,#0x34]        ;2618
003d6c  e12fff3c          BLX      r12                   ;2618
003d70  e3a08000          MOV      r8,#0                 ;2622
003d74  ea000005          B        |L1.15760|
                  |L1.15736|
003d78  e1a00005          MOV      r0,r5                 ;2623
003d7c  e5941008          LDR      r1,[r4,#8]            ;2623
003d80  e12fff31          BLX      r1                    ;2623
003d84  e28d1010          ADD      r1,sp,#0x10           ;2623
003d88  e7c10008          STRB     r0,[r1,r8]            ;2623
003d8c  e2888001          ADD      r8,r8,#1              ;2622
                  |L1.15760|
003d90  e3580008          CMP      r8,#8                 ;2622
003d94  bafffff7          BLT      |L1.15736|
003d98  e5960000          LDR      r0,[r6,#0]            ;2625
003d9c  e3500000          CMP      r0,#0                 ;2625
003da0  1a000002          BNE      |L1.15792|
003da4  e3e00012          MVN      r0,#0x12              ;2626
003da8  e1a00000          MOV      r0,r0                 ;2626
003dac  eaffffca          B        |L1.15580|
                  |L1.15792|
003db0  e5950020          LDR      r0,[r5,#0x20]         ;2628
003db4  e3500000          CMP      r0,#0                 ;2628
003db8  1a000001          BNE      |L1.15812|
003dbc  e5960000          LDR      r0,[r6,#0]            ;2629
003dc0  e5850020          STR      r0,[r5,#0x20]         ;2629
                  |L1.15812|
003dc4  e3a01000          MOV      r1,#0                 ;2631
003dc8  e1a01a01          LSL      r1,r1,#20             ;2631
003dcc  e596000c          LDR      r0,[r6,#0xc]          ;2631
003dd0  e1811620          ORR      r1,r1,r0,LSR #12      ;2631
003dd4  e1a00a00          LSL      r0,r0,#20             ;2631
003dd8  e1c406f8          STRD     r0,r1,[r4,#0x68]      ;2631
003ddc  e3a00000          MOV      r0,#0                 ;2632
003de0  e584002c          STR      r0,[r4,#0x2c]         ;2632
003de4  e5960008          LDR      r0,[r6,#8]            ;2633
003de8  e3500000          CMP      r0,#0                 ;2633
003dec  1a000009          BNE      |L1.15896|
003df0  e594002c          LDR      r0,[r4,#0x2c]         ;2633
003df4  e3500000          CMP      r0,#0                 ;2633
003df8  0a000006          BEQ      |L1.15896|
003dfc  e28d2010          ADD      r2,sp,#0x10           ;2635
003e00  e594302c          LDR      r3,[r4,#0x2c]         ;2635
003e04  e1a01004          MOV      r1,r4                 ;2635
003e08  e1a00005          MOV      r0,r5                 ;2635
003e0c  e12fff33          BLX      r3                    ;2635
003e10  e1a09000          MOV      r9,r0                 ;2635
003e14  ea00009b          B        |L1.16520|
                  |L1.15896|
003e18  e5960008          LDR      r0,[r6,#8]            ;2636
003e1c  e3500000          CMP      r0,#0                 ;2636
003e20  1a000075          BNE      |L1.16380|
003e24  e5dd1012          LDRB     r1,[sp,#0x12]         ;2639
003e28  e5c4107c          STRB     r1,[r4,#0x7c]         ;2639
003e2c  e5dd0013          LDRB     r0,[sp,#0x13]         ;2641
003e30  e5dd1010          LDRB     r1,[sp,#0x10]         ;2651
003e34  e5dd2016          LDRB     r2,[sp,#0x16]         ;2651
003e38  e1510002          CMP      r1,r2                 ;2651
003e3c  1a000034          BNE      |L1.16148|
003e40  e5dd1011          LDRB     r1,[sp,#0x11]         ;2651
003e44  e5dd2017          LDRB     r2,[sp,#0x17]         ;2651
003e48  e1510002          CMP      r1,r2                 ;2651
003e4c  1a000030          BNE      |L1.16148|
003e50  e5dd1010          LDRB     r1,[sp,#0x10]         ;2652
003e54  e35100ec          CMP      r1,#0xec              ;2652
003e58  1a00002d          BNE      |L1.16148|
003e5c  e5d4107c          LDRB     r1,[r4,#0x7c]         ;2653
003e60  e311000c          TST      r1,#0xc               ;2653
003e64  0a00002a          BEQ      |L1.16148|
003e68  e5dd1015          LDRB     r1,[sp,#0x15]         ;2654
003e6c  e3510000          CMP      r1,#0                 ;2654
003e70  0a000027          BEQ      |L1.16148|
003e74  e2001003          AND      r1,r0,#3              ;2656
003e78  e3a02b02          MOV      r2,#0x800             ;2656
003e7c  e1a01112          LSL      r1,r2,r1              ;2656
003e80  e5851014          STR      r1,[r5,#0x14]         ;2656
003e84  e1a00140          ASR      r0,r0,#2              ;2657
003e88  e2001003          AND      r1,r0,#3              ;2659
003e8c  e3510001          CMP      r1,#1                 ;2659
003e90  0a000004          BEQ      |L1.16040|
003e94  e3510002          CMP      r1,#2                 ;2659
003e98  0a000006          BEQ      |L1.16056|
003e9c  e3510003          CMP      r1,#3                 ;2659
003ea0  1a00000c          BNE      |L1.16088|
003ea4  ea000007          B        |L1.16072|
                  |L1.16040|
003ea8  e1a00000          MOV      r0,r0                 ;2660
003eac  e3a01080          MOV      r1,#0x80              ;2661
003eb0  e5851018          STR      r1,[r5,#0x18]         ;2661
003eb4  ea00000b          B        |L1.16104|
                  |L1.16056|
003eb8  e1a00000          MOV      r0,r0                 ;2663
003ebc  e3a010da          MOV      r1,#0xda              ;2664
003ec0  e5851018          STR      r1,[r5,#0x18]         ;2664
003ec4  ea000007          B        |L1.16104|
                  |L1.16072|
003ec8  e1a00000          MOV      r0,r0                 ;2666
003ecc  e3a01e19          MOV      r1,#0x190             ;2667
003ed0  e5851018          STR      r1,[r5,#0x18]         ;2667
003ed4  ea000003          B        |L1.16104|
                  |L1.16088|
003ed8  e1a00000          MOV      r0,r0                 ;2669
003edc  e3a01f6d          MOV      r1,#0x1b4             ;2670
003ee0  e5851018          STR      r1,[r5,#0x18]         ;2670
003ee4  e1a00000          MOV      r0,r0                 ;2671
                  |L1.16104|
003ee8  e1a00000          MOV      r0,r0                 ;2662
003eec  e1a00140          ASR      r0,r0,#2              ;2673
003ef0  e3a01004          MOV      r1,#4                 ;2675
003ef4  e00110c0          AND      r1,r1,r0,ASR #1       ;2675
003ef8  e2002003          AND      r2,r0,#3              ;2675
003efc  e1811002          ORR      r1,r1,r2              ;2675
003f00  e3a02802          MOV      r2,#0x20000           ;2675
003f04  e1a01112          LSL      r1,r2,r1              ;2675
003f08  e5851010          STR      r1,[r5,#0x10]         ;2675
003f0c  e3a09000          MOV      r9,#0                 ;2677
003f10  ea000038          B        |L1.16376|
                  |L1.16148|
003f14  e2001003          AND      r1,r0,#3              ;2680
003f18  e3a02b01          MOV      r2,#0x400             ;2680
003f1c  e1a01112          LSL      r1,r2,r1              ;2680
003f20  e5851014          STR      r1,[r5,#0x14]         ;2680
003f24  e1a00140          ASR      r0,r0,#2              ;2681
003f28  e2001001          AND      r1,r0,#1              ;2683
003f2c  e3a02008          MOV      r2,#8                 ;2683
003f30  e1a01112          LSL      r1,r2,r1              ;2683
003f34  e5952014          LDR      r2,[r5,#0x14]         ;2683
003f38  e1a024a2          LSR      r2,r2,#9              ;2683
003f3c  e0010192          MUL      r1,r2,r1              ;2683
003f40  e5851018          STR      r1,[r5,#0x18]         ;2683
003f44  e1a00140          ASR      r0,r0,#2              ;2685
003f48  e2001003          AND      r1,r0,#3              ;2687
003f4c  e3a02801          MOV      r2,#0x10000           ;2687
003f50  e1a01112          LSL      r1,r2,r1              ;2687
003f54  e5851010          STR      r1,[r5,#0x10]         ;2687
003f58  e1a00140          ASR      r0,r0,#2              ;2688
003f5c  e3100001          TST      r0,#1                 ;2690
003f60  0a000022          BEQ      |L1.16368|
003f64  e3a01002          MOV      r1,#2                 ;2690
003f68  ea000021          B        |L1.16372|
                  |L1.16236|
                          DCD      nand_command
                  |L1.16240|
                          DCD      nand_wait
                  |L1.16244|
                          DCD      nand_select_chip
                  |L1.16248|
                          DCD      nand_read_byte16
                  |L1.16252|
                          DCD      nand_read_byte
                  |L1.16256|
                          DCD      nand_read_word
                  |L1.16260|
                          DCD      nand_block_bad
                  |L1.16264|
                          DCD      nand_default_block_markbad
                  |L1.16268|
                          DCD      nand_write_buf16
                  |L1.16272|
                          DCD      nand_write_buf
                  |L1.16276|
                          DCD      nand_read_buf16
                  |L1.16280|
                          DCD      nand_read_buf
                  |L1.16284|
                          DCD      nand_verify_buf16
                  |L1.16288|
                          DCD      nand_verify_buf
                  |L1.16292|
                          DCD      nand_default_bbt
                  |L1.16296|
                          DCD      |symbol_number.38|
                  |L1.16300|
003fac  25733a20          DCB      "%s: second ID read did not match %02x,%02x against %02x"
003fb0  7365636f
003fb4  6e642049
003fb8  44207265
003fbc  61642064
003fc0  6964206e
003fc4  6f74206d
003fc8  61746368
003fcc  20253032
003fd0  782c2530
003fd4  32782061
003fd8  6761696e
003fdc  73742025
003fe0  303278  
003fe3  2c253032          DCB      ",%02x\n",0
003fe7  780a00  
003fea  00                DCB      0
003feb  00                DCB      0
                  |L1.16364|
                          DCD      nand_flash_ids
                  |L1.16368|
003ff0  e3a01000          MOV      r1,#0                 ;2690
                  |L1.16372|
003ff4  e1a09001          MOV      r9,r1                 ;2690
                  |L1.16376|
003ff8  ea000022          B        |L1.16520|
                  |L1.16380|
003ffc  e5960010          LDR      r0,[r6,#0x10]         ;2696
004000  e5850010          STR      r0,[r5,#0x10]         ;2696
004004  e5960008          LDR      r0,[r6,#8]            ;2697
004008  e5850014          STR      r0,[r5,#0x14]         ;2697
00400c  e5950014          LDR      r0,[r5,#0x14]         ;2698
004010  e1a002a0          LSR      r0,r0,#5              ;2698
004014  e5850018          STR      r0,[r5,#0x18]         ;2698
004018  e5d60014          LDRB     r0,[r6,#0x14]         ;2699
00401c  e2009002          AND      r9,r0,#2              ;2699
004020  e5970000          LDR      r0,[r7,#0]            ;2707
004024  e3500001          CMP      r0,#1                 ;2707
004028  1a000016          BNE      |L1.16520|
00402c  e5dd0014          LDRB     r0,[sp,#0x14]         ;2707
004030  e3500000          CMP      r0,#0                 ;2707
004034  0a000013          BEQ      |L1.16520|
004038  e5dd0015          LDRB     r0,[sp,#0x15]         ;2708
00403c  e3500000          CMP      r0,#0                 ;2708
004040  1a000010          BNE      |L1.16520|
004044  e5dd0016          LDRB     r0,[sp,#0x16]         ;2708
004048  e3500000          CMP      r0,#0                 ;2708
00404c  1a00000d          BNE      |L1.16520|
004050  e5dd0017          LDRB     r0,[sp,#0x17]         ;2709
004054  e3500000          CMP      r0,#0                 ;2709
004058  1a00000a          BNE      |L1.16520|
00405c  e5950014          LDR      r0,[r5,#0x14]         ;2709
004060  e3500c02          CMP      r0,#0x200             ;2709
004064  1a000007          BNE      |L1.16520|
004068  e3a00802          MOV      r0,#0x20000           ;2710
00406c  e5850010          STR      r0,[r5,#0x10]         ;2710
004070  e5950010          LDR      r0,[r5,#0x10]         ;2711
004074  e5dd1013          LDRB     r1,[sp,#0x13]         ;2711
004078  e1a01f01          LSL      r1,r1,#30             ;2711
00407c  e1a01ea1          LSR      r1,r1,#29             ;2711
004080  e1a00110          LSL      r0,r0,r1              ;2711
004084  e5850010          STR      r0,[r5,#0x10]         ;2711
                  |L1.16520|
004088  e5940050          LDR      r0,[r4,#0x50]         ;2715
00408c  e5961014          LDR      r1,[r6,#0x14]         ;2715
004090  e1800001          ORR      r0,r0,r1              ;2715
004094  e5840050          STR      r0,[r4,#0x50]         ;2715
004098  e5970000          LDR      r0,[r7,#0]            ;2720
00409c  e35000ec          CMP      r0,#0xec              ;2720
0040a0  0a000005          BEQ      |L1.16572|
0040a4  e5960008          LDR      r0,[r6,#8]            ;2720
0040a8  e3500000          CMP      r0,#0                 ;2720
0040ac  1a000002          BNE      |L1.16572|
0040b0  e5940050          LDR      r0,[r4,#0x50]         ;2721
0040b4  e3c0001c          BIC      r0,r0,#0x1c           ;2721
0040b8  e5840050          STR      r0,[r4,#0x50]         ;2721
                  |L1.16572|
0040bc  e1a00000          MOV      r0,r0                 ;2722
                  |L1.16576|
0040c0  e5940050          LDR      r0,[r4,#0x50]         ;2727
0040c4  e3800001          ORR      r0,r0,#1              ;2727
0040c8  e5840050          STR      r0,[r4,#0x50]         ;2727
0040cc  e3a0b000          MOV      r11,#0                ;2730
0040d0  ea000006          B        |L1.16624|
                  |L1.16596|
0040d4  e59f0288          LDR      r0,|L1.17252|
0040d8  e790018b          LDR      r0,[r0,r11,LSL #3]    ;2731
0040dc  e5971000          LDR      r1,[r7,#0]            ;2731
0040e0  e1500001          CMP      r0,r1                 ;2731
0040e4  1a000000          BNE      |L1.16620|
0040e8  ea000004          B        |L1.16640|
                  |L1.16620|
0040ec  e28bb001          ADD      r11,r11,#1            ;2730
                  |L1.16624|
0040f0  e59f026c          LDR      r0,|L1.17252|
0040f4  e790018b          LDR      r0,[r0,r11,LSL #3]    ;2730
0040f8  e3500000          CMP      r0,#0                 ;2730
0040fc  1afffff4          BNE      |L1.16596|
                  |L1.16640|
004100  e1a00000          MOV      r0,r0                 ;2732
004104  e5d40050          LDRB     r0,[r4,#0x50]         ;2739
004108  e2000002          AND      r0,r0,#2              ;2739
00410c  e1500009          CMP      r0,r9                 ;2739
004110  0a00001a          BEQ      |L1.16768|
004114  e5950020          LDR      r0,[r5,#0x20]         ;2740
004118  e58d0000          STR      r0,[sp,#0]            ;2740
00411c  e59f0240          LDR      r0,|L1.17252|
004120  e080018b          ADD      r0,r0,r11,LSL #3      ;2740
004124  e5903004          LDR      r3,[r0,#4]            ;2740
004128  e59a2000          LDR      r2,[r10,#0]           ;2740
00412c  e28f0f8d          ADR      r0,|L1.17256|
004130  e5971000          LDR      r1,[r7,#0]            ;2740
004134  ebfffffe          BL       sysprintf
004138  e3590000          CMP      r9,#0                 ;2743
00413c  0a000001          BEQ      |L1.16712|
004140  e3a00010          MOV      r0,#0x10              ;2745
004144  ea000000          B        |L1.16716|
                  |L1.16712|
004148  e3a00008          MOV      r0,#8                 ;2745
                  |L1.16716|
00414c  e1a02000          MOV      r2,r0                 ;2745
004150  e5d40050          LDRB     r0,[r4,#0x50]         ;2745
004154  e3100002          TST      r0,#2                 ;2745
004158  0a000001          BEQ      |L1.16740|
00415c  e3a00010          MOV      r0,#0x10              ;2744
004160  ea000000          B        |L1.16744|
                  |L1.16740|
004164  e3a00008          MOV      r0,#8                 ;2744
                  |L1.16744|
004168  e1a01000          MOV      r1,r0                 ;2744
00416c  e28f0f8d          ADR      r0,|L1.17320|
004170  ebfffffe          BL       sysprintf
004174  e3e00015          MVN      r0,#0x15              ;2746
004178  e1a00000          MOV      r0,r0                 ;2746
00417c  eafffed6          B        |L1.15580|
                  |L1.16768|
004180  e5950014          LDR      r0,[r5,#0x14]         ;2750
004184  ebfffffe          BL       generic_ffs
004188  e2400001          SUB      r0,r0,#1              ;2750
00418c  e5840054          STR      r0,[r4,#0x54]         ;2750
004190  e594006c          LDR      r0,[r4,#0x6c]         ;2752
004194  e5941068          LDR      r1,[r4,#0x68]         ;2752
004198  e5942054          LDR      r2,[r4,#0x54]         ;2752
00419c  e58d001c          STR      r0,[sp,#0x1c]         ;2752
0041a0  e58d1020          STR      r1,[sp,#0x20]         ;2752
0041a4  e1a00001          MOV      r0,r1                 ;2752
0041a8  e59d101c          LDR      r1,[sp,#0x1c]         ;2752
0041ac  ebfffffe          BL       __aeabi_llsr
0041b0  e2500001          SUBS     r0,r0,#1              ;2752
0041b4  e5840070          STR      r0,[r4,#0x70]         ;2752
0041b8  e5950010          LDR      r0,[r5,#0x10]         ;2754
0041bc  ebfffffe          BL       generic_ffs
0041c0  e2400001          SUB      r0,r0,#1              ;2754
0041c4  e5840058          STR      r0,[r4,#0x58]         ;2754
0041c8  e584005c          STR      r0,[r4,#0x5c]         ;2754
0041cc  e3a02000          MOV      r2,#0                 ;2756
0041d0  e1c406d8          LDRD     r0,r1,[r4,#0x68]      ;2756
0041d4  e0200002          EOR      r0,r0,r2              ;2756
0041d8  e0221002          EOR      r1,r2,r2              ;2756
0041dc  e1900001          ORRS     r0,r0,r1              ;2756
0041e0  0a000004          BEQ      |L1.16888|
0041e4  e5940068          LDR      r0,[r4,#0x68]         ;2757
0041e8  ebfffffe          BL       generic_ffs
0041ec  e2400001          SUB      r0,r0,#1              ;2757
0041f0  e5840060          STR      r0,[r4,#0x60]         ;2757
0041f4  ea000005          B        |L1.16912|
                  |L1.16888|
0041f8  e594006c          LDR      r0,[r4,#0x6c]         ;2759
0041fc  ebfffffe          BL       generic_ffs
004200  e5840060          STR      r0,[r4,#0x60]         ;2759
004204  e5940060          LDR      r0,[r4,#0x60]         ;2760
004208  e280001f          ADD      r0,r0,#0x1f           ;2760
00420c  e5840060          STR      r0,[r4,#0x60]         ;2760
                  |L1.16912|
004210  e3a00008          MOV      r0,#8                 ;2763
004214  e5840084          STR      r0,[r4,#0x84]         ;2763
004218  e5950014          LDR      r0,[r5,#0x14]         ;2766
00421c  e3500c02          CMP      r0,#0x200             ;2766
004220  8a000001          BHI      |L1.16940|
004224  e3190002          TST      r9,#2                 ;2766
004228  0a000002          BEQ      |L1.16952|
                  |L1.16940|
00422c  e3a00000          MOV      r0,#0                 ;2767
004230  e5840080          STR      r0,[r4,#0x80]         ;2767
004234  ea000001          B        |L1.16960|
                  |L1.16952|
004238  e3a00005          MOV      r0,#5                 ;2769
00423c  e5840080          STR      r0,[r4,#0x80]         ;2769
                  |L1.16960|
004240  e5d4007c          LDRB     r0,[r4,#0x7c]         ;2778
004244  e310000c          TST      r0,#0xc               ;2778
004248  0a000009          BEQ      |L1.17012|
00424c  e5970000          LDR      r0,[r7,#0]            ;2779
004250  e35000ec          CMP      r0,#0xec              ;2779
004254  0a000002          BEQ      |L1.16996|
004258  e5970000          LDR      r0,[r7,#0]            ;2780
00425c  e35000ad          CMP      r0,#0xad              ;2780
004260  1a000003          BNE      |L1.17012|
                  |L1.16996|
004264  e5940050          LDR      r0,[r4,#0x50]         ;2781
004268  e3800902          ORR      r0,r0,#0x8000         ;2781
00426c  e5840050          STR      r0,[r4,#0x50]         ;2781
004270  ea000017          B        |L1.17108|
                  |L1.17012|
004274  e5d4007c          LDRB     r0,[r4,#0x7c]         ;2782
004278  e310000c          TST      r0,#0xc               ;2782
00427c  1a00000b          BNE      |L1.17072|
004280  e5970000          LDR      r0,[r7,#0]            ;2783
004284  e35000ec          CMP      r0,#0xec              ;2783
004288  0a00000e          BEQ      |L1.17096|
00428c  e5970000          LDR      r0,[r7,#0]            ;2784
004290  e35000ad          CMP      r0,#0xad              ;2784
004294  0a00000b          BEQ      |L1.17096|
004298  e5970000          LDR      r0,[r7,#0]            ;2785
00429c  e3500098          CMP      r0,#0x98              ;2785
0042a0  0a000008          BEQ      |L1.17096|
0042a4  e5970000          LDR      r0,[r7,#0]            ;2786
0042a8  e3500001          CMP      r0,#1                 ;2786
0042ac  0a000005          BEQ      |L1.17096|
                  |L1.17072|
0042b0  e5950014          LDR      r0,[r5,#0x14]         ;2787
0042b4  e3500b02          CMP      r0,#0x800             ;2787
0042b8  1a000005          BNE      |L1.17108|
0042bc  e5970000          LDR      r0,[r7,#0]            ;2788
0042c0  e350002c          CMP      r0,#0x2c              ;2788
0042c4  1a000002          BNE      |L1.17108|
                  |L1.17096|
0042c8  e5940050          LDR      r0,[r4,#0x50]         ;2789
0042cc  e3800901          ORR      r0,r0,#0x4000         ;2789
0042d0  e5840050          STR      r0,[r4,#0x50]         ;2789
                  |L1.17108|
0042d4  e3190002          TST      r9,#2                 ;2794
0042d8  1a00000a          BNE      |L1.17160|
0042dc  e5970000          LDR      r0,[r7,#0]            ;2795
0042e0  e3500020          CMP      r0,#0x20              ;2795
0042e4  1a000007          BNE      |L1.17160|
0042e8  e5950014          LDR      r0,[r5,#0x14]         ;2796
0042ec  e3500b02          CMP      r0,#0x800             ;2796
0042f0  1a000004          BNE      |L1.17160|
0042f4  e5940050          LDR      r0,[r4,#0x50]         ;2797
0042f8  e3800601          ORR      r0,r0,#0x100000       ;2797
0042fc  e5840050          STR      r0,[r4,#0x50]         ;2797
004300  e3a00000          MOV      r0,#0                 ;2798
004304  e5840080          STR      r0,[r4,#0x80]         ;2798
                  |L1.17160|
004308  e5d40050          LDRB     r0,[r4,#0x50]         ;2802
00430c  e3100040          TST      r0,#0x40              ;2802
004310  0a000002          BEQ      |L1.17184|
004314  e59f00b0          LDR      r0,|L1.17356|
004318  e584003c          STR      r0,[r4,#0x3c]         ;2803
00431c  ea000001          B        |L1.17192|
                  |L1.17184|
004320  e59f00a8          LDR      r0,|L1.17360|
004324  e584003c          STR      r0,[r4,#0x3c]         ;2805
                  |L1.17192|
004328  e5950014          LDR      r0,[r5,#0x14]         ;2808
00432c  e3500c02          CMP      r0,#0x200             ;2808
004330  9a000005          BLS      |L1.17228|
004334  e51f13d0          LDR      r1,|L1.16236|
004338  e5940034          LDR      r0,[r4,#0x34]         ;2808
00433c  e1500001          CMP      r0,r1                 ;2808
004340  1a000001          BNE      |L1.17228|
004344  e59f0088          LDR      r0,|L1.17364|
004348  e5840034          STR      r0,[r4,#0x34]         ;2809
                  |L1.17228|
00434c  e5960000          LDR      r0,[r6,#0]            ;2812
004350  e58d0018          STR      r0,[sp,#0x18]         ;2812
004354  e1a00000          MOV      r0,r0                 ;2817
004358  e1a00000          MOV      r0,r0                 ;2817
00435c  e1a00006          MOV      r0,r6                 ;2821
004360  eafffe5d          B        |L1.15580|
                  |L1.17252|
                          DCD      nand_manuf_ids
                  |L1.17256|
004368  4e414e44          DCB      "NAND device: Manufacturer ID: 0x%02x, Chip ID: 0x%02x ("
00436c  20646576
004370  6963653a
004374  204d616e
004378  75666163
00437c  74757265
004380  72204944
004384  3a203078
004388  25303278
00438c  2c204368
004390  69702049
004394  443a2030
004398  78253032
00439c  782028  
00439f  25732025          DCB      "%s %s)\n",0
0043a3  73290a00
0043a7  00                DCB      0
                  |L1.17320|
0043a8  4e414e44          DCB      "NAND bus width %d instead %d bit\n",0
0043ac  20627573
0043b0  20776964
0043b4  74682025
0043b8  6420696e
0043bc  73746561
0043c0  64202564
0043c4  20626974
0043c8  0a00    
0043ca  00                DCB      0
0043cb  00                DCB      0
                  |L1.17356|
                          DCD      multi_erase_cmd
                  |L1.17360|
                          DCD      single_erase_cmd
                  |L1.17364|
                          DCD      nand_command_lp
                          ENDP

                  nand_scan_ident PROC
;;;2834    */
;;;2835   int nand_scan_ident(struct mtd_info *mtd, int maxchips,
0043d8  e92d47ff          PUSH     {r0-r10,lr}
;;;2836   		    const struct nand_flash_dev *table)
;;;2837   {
0043dc  e1a07000          MOV      r7,r0
0043e0  e1a08001          MOV      r8,r1
0043e4  e1a09002          MOV      r9,r2
;;;2838   	int i, busw, nand_maf_id, nand_dev_id;
;;;2839   	struct nand_chip *chip = mtd->priv;
0043e8  e5974094          LDR      r4,[r7,#0x94]
;;;2840   	const struct nand_flash_dev *type;
;;;2841   
;;;2842   	/* Get buswidth to select the correct functions */
;;;2843   	busw = chip->options & NAND_BUSWIDTH_16;
0043ec  e5d40050          LDRB     r0,[r4,#0x50]
0043f0  e200a002          AND      r10,r0,#2
;;;2844   	/* Set the default functions */
;;;2845   	nand_set_defaults(chip, busw);
0043f4  e1a0100a          MOV      r1,r10
0043f8  e1a00004          MOV      r0,r4
0043fc  ebfffffe          BL       nand_set_defaults
;;;2846   
;;;2847   	/* Read the flash type */
;;;2848   	type = nand_get_flash_type(mtd, chip, busw,
004400  e28d0008          ADD      r0,sp,#8
004404  e88d0201          STM      sp,{r0,r9}
004408  e28d300c          ADD      r3,sp,#0xc
00440c  e1a0200a          MOV      r2,r10
004410  e1a01004          MOV      r1,r4
004414  e1a00007          MOV      r0,r7
004418  ebfffffe          BL       nand_get_flash_type
00441c  e1a06000          MOV      r6,r0
;;;2849   				&nand_maf_id, &nand_dev_id, table);
;;;2850   
;;;2851   	//printf("did=0x%x\n",nand_dev_id); //CWWeng
;;;2852   
;;;2853   	if (IS_ERR(type)) {
004420  e1a00006          MOV      r0,r6
004424  e3700a01          CMN      r0,#0x1000
004428  9a000001          BLS      |L1.17460|
00442c  e3a01001          MOV      r1,#1
004430  ea000000          B        |L1.17464|
                  |L1.17460|
004434  e3a01000          MOV      r1,#0
                  |L1.17464|
004438  e3510000          CMP      r1,#0
00443c  0a00000a          BEQ      |L1.17516|
;;;2854   #ifndef CONFIG_SYS_NAND_QUIET_TEST
;;;2855   		printk(KERN_WARNING "No NAND device found!!!\n");
004440  e28f0fb6          ADR      r0,|L1.18208|
004444  ebfffffe          BL       sysprintf
;;;2856   #endif
;;;2857   		chip->select_chip(mtd, -1);
004448  e3e01000          MVN      r1,#0
00444c  e1a00007          MOV      r0,r7
004450  e594201c          LDR      r2,[r4,#0x1c]
004454  e12fff32          BLX      r2
;;;2858   		return PTR_ERR(type);
004458  e1a00000          MOV      r0,r0
00445c  e1a00000          MOV      r0,r0
004460  e1a00006          MOV      r0,r6
                  |L1.17508|
004464  e28dd010          ADD      sp,sp,#0x10
;;;2859   	}
;;;2860   
;;;2861   	/* Check for a chip array */
;;;2862   	for (i = 1; i < maxchips; i++) {
;;;2863   		chip->select_chip(mtd, i);
;;;2864   		/* See comment in nand_get_flash_type for reset */
;;;2865   		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
;;;2866   		/* Send the command for reading device ID */
;;;2867   		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
;;;2868   		/* Read manufacturer and device IDs */
;;;2869   		if (nand_maf_id != chip->read_byte(mtd) ||
;;;2870   		    nand_dev_id != chip->read_byte(mtd))
;;;2871   			break;
;;;2872   	}
;;;2873   #ifdef DEBUG
;;;2874   	if (i > 1)
;;;2875   		printk(KERN_INFO "%d NAND chips detected\n", i);
;;;2876   #endif
;;;2877   
;;;2878   	/* Store the number of chips and calc total size for mtd */
;;;2879   	chip->numchips = i;
;;;2880   	mtd->size = i * chip->chipsize;
;;;2881   
;;;2882   	return 0;
;;;2883   }
004468  e8bd87f0          POP      {r4-r10,pc}
                  |L1.17516|
00446c  e3a05001          MOV      r5,#1                 ;2862
004470  ea00001d          B        |L1.17644|
                  |L1.17524|
004474  e1a01005          MOV      r1,r5                 ;2863
004478  e1a00007          MOV      r0,r7                 ;2863
00447c  e594201c          LDR      r2,[r4,#0x1c]         ;2863
004480  e12fff32          BLX      r2                    ;2863
004484  e3e03000          MVN      r3,#0                 ;2865
004488  e1a02003          MOV      r2,r3                 ;2865
00448c  e3a010ff          MOV      r1,#0xff              ;2865
004490  e1a00007          MOV      r0,r7                 ;2865
004494  e594c034          LDR      r12,[r4,#0x34]        ;2865
004498  e12fff3c          BLX      r12                   ;2865
00449c  e3e03000          MVN      r3,#0                 ;2867
0044a0  e3a02000          MOV      r2,#0                 ;2867
0044a4  e3a01090          MOV      r1,#0x90              ;2867
0044a8  e1a00007          MOV      r0,r7                 ;2867
0044ac  e594c034          LDR      r12,[r4,#0x34]        ;2867
0044b0  e12fff3c          BLX      r12                   ;2867
0044b4  e1a00007          MOV      r0,r7                 ;2869
0044b8  e5941008          LDR      r1,[r4,#8]            ;2869
0044bc  e12fff31          BLX      r1                    ;2869
0044c0  e59d100c          LDR      r1,[sp,#0xc]          ;2869
0044c4  e1500001          CMP      r0,r1                 ;2869
0044c8  1a000005          BNE      |L1.17636|
0044cc  e1a00007          MOV      r0,r7                 ;2870
0044d0  e5941008          LDR      r1,[r4,#8]            ;2870
0044d4  e12fff31          BLX      r1                    ;2870
0044d8  e59d1008          LDR      r1,[sp,#8]            ;2870
0044dc  e1500001          CMP      r0,r1                 ;2870
0044e0  0a000000          BEQ      |L1.17640|
                  |L1.17636|
0044e4  ea000002          B        |L1.17652|
                  |L1.17640|
0044e8  e2855001          ADD      r5,r5,#1              ;2862
                  |L1.17644|
0044ec  e1550008          CMP      r5,r8                 ;2862
0044f0  baffffdf          BLT      |L1.17524|
                  |L1.17652|
0044f4  e1a00000          MOV      r0,r0                 ;2871
0044f8  e5845064          STR      r5,[r4,#0x64]         ;2879
0044fc  e1a03fc5          ASR      r3,r5,#31             ;2880
004500  e5941068          LDR      r1,[r4,#0x68]         ;2880
004504  e594206c          LDR      r2,[r4,#0x6c]         ;2880
004508  e08c0591          UMULL    r0,r12,r1,r5          ;2880
00450c  e022c295          MLA      r2,r5,r2,r12          ;2880
004510  e0212193          MLA      r1,r3,r1,r2           ;2880
004514  e1c700f8          STRD     r0,r1,[r7,#8]         ;2880
004518  e3a00000          MOV      r0,#0                 ;2882
00451c  eaffffd0          B        |L1.17508|
;;;2884   
                          ENDP

                  nand_scan_tail PROC
;;;2893    */
;;;2894   int nand_scan_tail(struct mtd_info *mtd)
004520  e92d4038          PUSH     {r3-r5,lr}
;;;2895   {
004524  e1a05000          MOV      r5,r0
;;;2896   	int volatile i;
;;;2897   	struct nand_chip *chip = mtd->priv;
004528  e5954094          LDR      r4,[r5,#0x94]
;;;2898   
;;;2899   	if (!(chip->options & NAND_OWN_BUFFERS))
00452c  e5940050          LDR      r0,[r4,#0x50]
004530  e3100701          TST      r0,#0x40000
004534  1a000004          BNE      |L1.17740|
;;;2900   	{
;;;2901   		//chip->buffers = memalign(ARCH_DMA_MINALIGN,
;;;2902   		//			 sizeof(*chip->buffers));
;;;2903   		chip->buffers = (struct nand_buffers *)0x1000000; //CWWeng
004538  e3a00401          MOV      r0,#0x1000000
00453c  e58400e8          STR      r0,[r4,#0xe8]
;;;2904   		memset((void*)chip->buffers,0,sizeof(*chip->buffers)); //CWWeng
004540  e3a01d9b          MOV      r1,#0x26c0
004544  e59400e8          LDR      r0,[r4,#0xe8]
004548  ebfffffe          BL       __aeabi_memclr
                  |L1.17740|
;;;2905   	}
;;;2906   
;;;2907   	if (!chip->buffers)
00454c  e59400e8          LDR      r0,[r4,#0xe8]
004550  e3500000          CMP      r0,#0
004554  1a000001          BNE      |L1.17760|
;;;2908   		return -ENOMEM;
004558  e3e0000b          MVN      r0,#0xb
                  |L1.17756|
;;;2909   
;;;2910   	/* Set the internal oob buffer location, just after the page data */
;;;2911   	chip->oob_poi = chip->buffers->databuf + mtd->writesize;
;;;2912   
;;;2913       nand_oob_8.eccbytes = 3;
;;;2914       for (i=0; i<3; i++)
;;;2915           nand_oob_8.eccpos[i] = i;
;;;2916   	nand_oob_8.oobfree[0].offset = 3;
;;;2917       nand_oob_8.oobfree[0].length = 2;
;;;2918   	nand_oob_8.oobfree[1].offset = 6;
;;;2919       nand_oob_8.oobfree[1].length = 2;
;;;2920   
;;;2921       nand_oob_16.eccbytes = 6;
;;;2922       for (i=0; i<4; i++)
;;;2923           nand_oob_16.eccpos[i] = i;
;;;2924       nand_oob_16.eccpos[4] = 6;
;;;2925       nand_oob_16.eccpos[5] = 7;
;;;2926   	nand_oob_16.oobfree[0].offset = 8;
;;;2927       nand_oob_16.oobfree[0].length = 8;
;;;2928   
;;;2929       nand_oob_64.eccbytes = 24;
;;;2930       for (i=0; i<24; i++)
;;;2931           nand_oob_64.eccpos[i] = 40 + i;
;;;2932   	nand_oob_64.oobfree[0].offset = 2;
;;;2933       nand_oob_64.oobfree[0].length = 38;
;;;2934   
;;;2935       nand_oob_128.eccbytes = 48;
;;;2936       for (i=0; i<48; i++)
;;;2937           nand_oob_128.eccpos[i] = 80 + i;
;;;2938     
;;;2939   	nand_oob_128.oobfree[0].offset = 2;
;;;2940   	nand_oob_128.oobfree[0].length = 78;
;;;2941   
;;;2942   
;;;2943   	/*
;;;2944   	 * If no default placement scheme is given, select an appropriate one
;;;2945   	 */
;;;2946   	if (!chip->ecc.layout && (chip->ecc.mode != NAND_ECC_SOFT_BCH)) {
;;;2947   		switch (mtd->oobsize) {
;;;2948   		case 8:
;;;2949   			chip->ecc.layout = &nand_oob_8;
;;;2950   			break;
;;;2951   		case 16:
;;;2952   			chip->ecc.layout = &nand_oob_16;
;;;2953   			break;
;;;2954   		case 64:
;;;2955   			chip->ecc.layout = &nand_oob_64;
;;;2956   			break;
;;;2957   		case 128:
;;;2958   			chip->ecc.layout = &nand_oob_128;
;;;2959   			break;
;;;2960   		default:
;;;2961   			printk(KERN_WARNING "No oob scheme defined for "
;;;2962   			       "oobsize %d\n", mtd->oobsize);
;;;2963   		}
;;;2964   	}
;;;2965   
;;;2966   	if (!chip->write_page)
;;;2967   		chip->write_page = nand_write_page;
;;;2968   
;;;2969   	/*
;;;2970   	 * check ECC mode, default to software if 3byte/512byte hardware ECC is
;;;2971   	 * selected and we have 256 byte pagesize fallback to software ECC
;;;2972   	 */
;;;2973   
;;;2974   	switch (chip->ecc.mode) {
;;;2975   	case NAND_ECC_HW_OOB_FIRST:
;;;2976   		/* Similar to NAND_ECC_HW, but a separate read_page handle */
;;;2977   		if (!chip->ecc.calculate || !chip->ecc.correct ||
;;;2978   		     !chip->ecc.hwctl) {
;;;2979   			printk(KERN_WARNING "No ECC functions supplied; "
;;;2980   			       "Hardware ECC not possible\n");
;;;2981   			BUG();
;;;2982   		}
;;;2983   		if (!chip->ecc.read_page)
;;;2984   			chip->ecc.read_page = nand_read_page_hwecc_oob_first;
;;;2985   
;;;2986   	case NAND_ECC_HW:
;;;2987   		/* Use standard hwecc read page function ? */
;;;2988   		if (!chip->ecc.read_page)
;;;2989   			chip->ecc.read_page = nand_read_page_hwecc;
;;;2990   		if (!chip->ecc.write_page)
;;;2991   			chip->ecc.write_page = nand_write_page_hwecc;
;;;2992   		if (!chip->ecc.read_page_raw)
;;;2993   			chip->ecc.read_page_raw = nand_read_page_raw;
;;;2994   		if (!chip->ecc.write_page_raw)
;;;2995   			chip->ecc.write_page_raw = nand_write_page_raw;
;;;2996   		if (!chip->ecc.read_oob)
;;;2997   			chip->ecc.read_oob = nand_read_oob_std;
;;;2998   		if (!chip->ecc.write_oob)
;;;2999   			chip->ecc.write_oob = nand_write_oob_std;
;;;3000   
;;;3001   	case NAND_ECC_HW_SYNDROME:
;;;3002   		if ((!chip->ecc.calculate || !chip->ecc.correct ||
;;;3003   		     !chip->ecc.hwctl) &&
;;;3004   		    (!chip->ecc.read_page ||
;;;3005   		     chip->ecc.read_page == nand_read_page_hwecc ||
;;;3006   		     !chip->ecc.write_page ||
;;;3007   		     chip->ecc.write_page == nand_write_page_hwecc)) {
;;;3008   			printk(KERN_WARNING "No ECC functions supplied; "
;;;3009   			       "Hardware ECC not possible\n");
;;;3010   			BUG();
;;;3011   		}
;;;3012   		/* Use standard syndrome read/write page function ? */
;;;3013   		if (!chip->ecc.read_page)
;;;3014   			chip->ecc.read_page = nand_read_page_syndrome;
;;;3015   		if (!chip->ecc.write_page)
;;;3016   			chip->ecc.write_page = nand_write_page_syndrome;
;;;3017   		if (!chip->ecc.read_page_raw)
;;;3018   			chip->ecc.read_page_raw = nand_read_page_raw_syndrome;
;;;3019   		if (!chip->ecc.write_page_raw)
;;;3020   			chip->ecc.write_page_raw = nand_write_page_raw_syndrome;
;;;3021   		if (!chip->ecc.read_oob)
;;;3022   			chip->ecc.read_oob = nand_read_oob_syndrome;
;;;3023   		if (!chip->ecc.write_oob)
;;;3024   			chip->ecc.write_oob = nand_write_oob_syndrome;
;;;3025   
;;;3026   		if (mtd->writesize >= chip->ecc.size)
;;;3027   			break;
;;;3028   		printk(KERN_WARNING "%d byte HW ECC not possible on "
;;;3029   		       "%d byte page size, fallback to SW ECC\n",
;;;3030   		       chip->ecc.size, mtd->writesize);
;;;3031   		chip->ecc.mode = NAND_ECC_SOFT;
;;;3032   
;;;3033   	case NAND_ECC_SOFT:
;;;3034   		//chip->ecc.calculate = nand_calculate_ecc; //CWWeng temp mark it
;;;3035   		//chip->ecc.correct = nand_correct_data;
;;;3036   		chip->ecc.read_page = nand_read_page_swecc;
;;;3037   		chip->ecc.read_subpage = nand_read_subpage;
;;;3038   		chip->ecc.write_page = nand_write_page_swecc;
;;;3039   		chip->ecc.read_page_raw = nand_read_page_raw;
;;;3040   		chip->ecc.write_page_raw = nand_write_page_raw;
;;;3041   		chip->ecc.read_oob = nand_read_oob_std;
;;;3042   		chip->ecc.write_oob = nand_write_oob_std;
;;;3043   		if (!chip->ecc.size)
;;;3044   			chip->ecc.size = 256;
;;;3045   		chip->ecc.bytes = 3;
;;;3046   		break;
;;;3047   
;;;3048   	case NAND_ECC_SOFT_BCH:
;;;3049   		if (!mtd_nand_has_bch()) {
;;;3050   			printk(KERN_WARNING "CONFIG_MTD_ECC_BCH not enabled\n");
;;;3051   			return -EINVAL;
;;;3052   		}
;;;3053   		chip->ecc.calculate = nand_bch_calculate_ecc;
;;;3054   		chip->ecc.correct = nand_bch_correct_data;
;;;3055   		chip->ecc.read_page = nand_read_page_swecc;
;;;3056   		chip->ecc.read_subpage = nand_read_subpage;
;;;3057   		chip->ecc.write_page = nand_write_page_swecc;
;;;3058   		chip->ecc.read_page_raw = nand_read_page_raw;
;;;3059   		chip->ecc.write_page_raw = nand_write_page_raw;
;;;3060   		chip->ecc.read_oob = nand_read_oob_std;
;;;3061   		chip->ecc.write_oob = nand_write_oob_std;
;;;3062   		/*
;;;3063   		 * Board driver should supply ecc.size and ecc.bytes values to
;;;3064   		 * select how many bits are correctable; see nand_bch_init()
;;;3065   		 * for details.
;;;3066   		 * Otherwise, default to 4 bits for large page devices
;;;3067   		 */
;;;3068   		if (!chip->ecc.size && (mtd->oobsize >= 64)) {
;;;3069   			chip->ecc.size = 512;
;;;3070   			chip->ecc.bytes = 7;
;;;3071   		}
;;;3072   		chip->ecc.priv = nand_bch_init(mtd,
;;;3073   					       chip->ecc.size,
;;;3074   					       chip->ecc.bytes,
;;;3075   					       &chip->ecc.layout);
;;;3076   		if (!chip->ecc.priv)
;;;3077   			printk(KERN_WARNING "BCH ECC initialization failed!\n");
;;;3078   
;;;3079   		break;
;;;3080   
;;;3081   	case NAND_ECC_NONE:
;;;3082   		printk(KERN_WARNING "NAND_ECC_NONE selected by board driver. "
;;;3083   		       "This is not recommended !!\n");
;;;3084   		chip->ecc.read_page = nand_read_page_raw;
;;;3085   		chip->ecc.write_page = nand_write_page_raw;
;;;3086   		chip->ecc.read_oob = nand_read_oob_std;
;;;3087   		chip->ecc.read_page_raw = nand_read_page_raw;
;;;3088   		chip->ecc.write_page_raw = nand_write_page_raw;
;;;3089   		chip->ecc.write_oob = nand_write_oob_std;
;;;3090   		chip->ecc.size = mtd->writesize;
;;;3091   		chip->ecc.bytes = 0;
;;;3092   		break;
;;;3093   
;;;3094   	default:
;;;3095   		printk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",
;;;3096   		       chip->ecc.mode);
;;;3097   		BUG();
;;;3098   	}
;;;3099   
;;;3100   	/*
;;;3101   	 * The number of bytes available for a client to place data into
;;;3102   	 * the out of band area
;;;3103   	 */
;;;3104   	chip->ecc.layout->oobavail = 0;
;;;3105   	for (i = 0; chip->ecc.layout->oobfree[i].length
;;;3106   			&& i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)
;;;3107   		chip->ecc.layout->oobavail +=
;;;3108   			chip->ecc.layout->oobfree[i].length;
;;;3109   	mtd->oobavail = chip->ecc.layout->oobavail;
;;;3110   
;;;3111   	/*
;;;3112   	 * Set the number of read / write steps for one page depending on ECC
;;;3113   	 * mode
;;;3114   	 */
;;;3115   	chip->ecc.steps = mtd->writesize / chip->ecc.size;
;;;3116   	if (chip->ecc.steps * chip->ecc.size != mtd->writesize) {
;;;3117   		printk(KERN_WARNING "Invalid ecc parameters\n");
;;;3118   		BUG();
;;;3119   	}
;;;3120   	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
;;;3121   
;;;3122   	/*
;;;3123   	 * Allow subpage writes up to ecc.steps. Not possible for MLC
;;;3124   	 * FLASH.
;;;3125   	 */
;;;3126   	if (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&
;;;3127   	    !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
;;;3128   		switch (chip->ecc.steps) {
;;;3129   		case 2:
;;;3130   			mtd->subpage_sft = 1;
;;;3131   			break;
;;;3132   		case 4:
;;;3133   		case 8:
;;;3134   		case 16:
;;;3135   			mtd->subpage_sft = 2;
;;;3136   			break;
;;;3137   		}
;;;3138   	}
;;;3139   	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
;;;3140   
;;;3141   	/* Initialize state */
;;;3142   	chip->state = FL_READY;
;;;3143   
;;;3144   	/* De-select the device */
;;;3145   	chip->select_chip(mtd, -1);
;;;3146   
;;;3147   	/* Invalidate the pagebuffer reference */
;;;3148   	chip->pagebuf = -1;
;;;3149   
;;;3150   	/* Large page NAND with SOFT_ECC should support subpage reads */
;;;3151   	if ((chip->ecc.mode == NAND_ECC_SOFT) && (chip->page_shift > 9))
;;;3152   		chip->options |= NAND_SUBPAGE_READ;
;;;3153   
;;;3154   	/* Fill in remaining MTD driver data */
;;;3155   	mtd->type = MTD_NANDFLASH;
;;;3156   	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
;;;3157   						MTD_CAP_NANDFLASH;
;;;3158   	mtd->erase = nand_erase;
;;;3159   	mtd->point = NULL;
;;;3160   	mtd->unpoint = NULL;
;;;3161   	mtd->read = nand_read;
;;;3162   	mtd->write = nand_write;
;;;3163   	mtd->read_oob = nand_read_oob;
;;;3164   	mtd->write_oob = nand_write_oob;
;;;3165   	mtd->sync = nand_sync;
;;;3166   	mtd->lock = NULL;
;;;3167   	mtd->unlock = NULL;
;;;3168   	mtd->block_isbad = nand_block_isbad;
;;;3169   	mtd->block_markbad = nand_block_markbad;
;;;3170   
;;;3171   	/* propagate ecc.layout to mtd_info */
;;;3172   	mtd->ecclayout = chip->ecc.layout;
;;;3173   
;;;3174   	/* Check, if we should skip the bad block table scan */
;;;3175   	if (chip->options & NAND_SKIP_BBTSCAN)
;;;3176   		chip->options |= NAND_BBT_SCANNED;
;;;3177   
;;;3178   	return 0;
;;;3179   }
00455c  e8bd8038          POP      {r3-r5,pc}
                  |L1.17760|
004560  e59400e8          LDR      r0,[r4,#0xe8]         ;2911
004564  e2800d12          ADD      r0,r0,#0x480          ;2911
004568  e5951014          LDR      r1,[r5,#0x14]         ;2911
00456c  e0800001          ADD      r0,r0,r1              ;2911
004570  e5840090          STR      r0,[r4,#0x90]         ;2911
004574  e3a00003          MOV      r0,#3                 ;2913
004578  e59f11bc          LDR      r1,|L1.18236|
00457c  e5810000          STR      r0,[r1,#0]            ;2913  ; nand_oob_8
004580  e3a00000          MOV      r0,#0                 ;2914
004584  e58d0000          STR      r0,[sp,#0]            ;2914
004588  ea000005          B        |L1.17828|
                  |L1.17804|
00458c  e59f11ac          LDR      r1,|L1.18240|
004590  e59d0000          LDR      r0,[sp,#0]            ;2915
004594  e7810100          STR      r0,[r1,r0,LSL #2]     ;2915
004598  e59d0000          LDR      r0,[sp,#0]            ;2914
00459c  e2800001          ADD      r0,r0,#1              ;2914
0045a0  e58d0000          STR      r0,[sp,#0]            ;2914
                  |L1.17828|
0045a4  e59d0000          LDR      r0,[sp,#0]            ;2914
0045a8  e3500003          CMP      r0,#3                 ;2914
0045ac  bafffff6          BLT      |L1.17804|
0045b0  e3a00003          MOV      r0,#3                 ;2916
0045b4  e59f1180          LDR      r1,|L1.18236|
0045b8  e5810208          STR      r0,[r1,#0x208]        ;2916  ; nand_oob_8
0045bc  e3a00002          MOV      r0,#2                 ;2917
0045c0  e581020c          STR      r0,[r1,#0x20c]        ;2917
0045c4  e3a00006          MOV      r0,#6                 ;2918
0045c8  e5810210          STR      r0,[r1,#0x210]        ;2918
0045cc  e3a00002          MOV      r0,#2                 ;2919
0045d0  e5810214          STR      r0,[r1,#0x214]        ;2919
0045d4  e3a00006          MOV      r0,#6                 ;2921
0045d8  e59f1164          LDR      r1,|L1.18244|
0045dc  e5810000          STR      r0,[r1,#0]            ;2921  ; nand_oob_16
0045e0  e3a00000          MOV      r0,#0                 ;2922
0045e4  e58d0000          STR      r0,[sp,#0]            ;2922
0045e8  ea000005          B        |L1.17924|
                  |L1.17900|
0045ec  e59f1154          LDR      r1,|L1.18248|
0045f0  e59d0000          LDR      r0,[sp,#0]            ;2923
0045f4  e7810100          STR      r0,[r1,r0,LSL #2]     ;2923
0045f8  e59d0000          LDR      r0,[sp,#0]            ;2922
0045fc  e2800001          ADD      r0,r0,#1              ;2922
004600  e58d0000          STR      r0,[sp,#0]            ;2922
                  |L1.17924|
004604  e59d0000          LDR      r0,[sp,#0]            ;2922
004608  e3500004          CMP      r0,#4                 ;2922
00460c  bafffff6          BLT      |L1.17900|
004610  e3a00006          MOV      r0,#6                 ;2924
004614  e59f1128          LDR      r1,|L1.18244|
004618  e5810014          STR      r0,[r1,#0x14]         ;2924
00461c  e3a00007          MOV      r0,#7                 ;2925
004620  e5810018          STR      r0,[r1,#0x18]         ;2925
004624  e3a00008          MOV      r0,#8                 ;2926
004628  e5810208          STR      r0,[r1,#0x208]        ;2926  ; nand_oob_16
00462c  e581020c          STR      r0,[r1,#0x20c]        ;2927
004630  e3a00018          MOV      r0,#0x18              ;2929
004634  e59f1110          LDR      r1,|L1.18252|
004638  e5810000          STR      r0,[r1,#0]            ;2929  ; nand_oob_64
00463c  e3a00000          MOV      r0,#0                 ;2930
004640  e58d0000          STR      r0,[sp,#0]            ;2930
004644  ea000007          B        |L1.18024|
                  |L1.17992|
004648  e59d0000          LDR      r0,[sp,#0]            ;2931
00464c  e2800028          ADD      r0,r0,#0x28           ;2931
004650  e59f10f8          LDR      r1,|L1.18256|
004654  e59d2000          LDR      r2,[sp,#0]            ;2931
004658  e7810102          STR      r0,[r1,r2,LSL #2]     ;2931
00465c  e59d0000          LDR      r0,[sp,#0]            ;2930
004660  e2800001          ADD      r0,r0,#1              ;2930
004664  e58d0000          STR      r0,[sp,#0]            ;2930
                  |L1.18024|
004668  e59d0000          LDR      r0,[sp,#0]            ;2930
00466c  e3500018          CMP      r0,#0x18              ;2930
004670  bafffff4          BLT      |L1.17992|
004674  e3a00002          MOV      r0,#2                 ;2932
004678  e59f10cc          LDR      r1,|L1.18252|
00467c  e5810208          STR      r0,[r1,#0x208]        ;2932  ; nand_oob_64
004680  e3a00026          MOV      r0,#0x26              ;2933
004684  e581020c          STR      r0,[r1,#0x20c]        ;2933
004688  e3a00030          MOV      r0,#0x30              ;2935
00468c  e59f10c0          LDR      r1,|L1.18260|
004690  e5810000          STR      r0,[r1,#0]            ;2935  ; nand_oob_128
004694  e3a00000          MOV      r0,#0                 ;2936
004698  e58d0000          STR      r0,[sp,#0]            ;2936
00469c  ea000007          B        |L1.18112|
                  |L1.18080|
0046a0  e59d0000          LDR      r0,[sp,#0]            ;2937
0046a4  e2800050          ADD      r0,r0,#0x50           ;2937
0046a8  e59f10a8          LDR      r1,|L1.18264|
0046ac  e59d2000          LDR      r2,[sp,#0]            ;2937
0046b0  e7810102          STR      r0,[r1,r2,LSL #2]     ;2937
0046b4  e59d0000          LDR      r0,[sp,#0]            ;2936
0046b8  e2800001          ADD      r0,r0,#1              ;2936
0046bc  e58d0000          STR      r0,[sp,#0]            ;2936
                  |L1.18112|
0046c0  e59d0000          LDR      r0,[sp,#0]            ;2936
0046c4  e3500030          CMP      r0,#0x30              ;2936
0046c8  bafffff4          BLT      |L1.18080|
0046cc  e3a00002          MOV      r0,#2                 ;2939
0046d0  e59f107c          LDR      r1,|L1.18260|
0046d4  e5810208          STR      r0,[r1,#0x208]        ;2939  ; nand_oob_128
0046d8  e3a0004e          MOV      r0,#0x4e              ;2940
0046dc  e581020c          STR      r0,[r1,#0x20c]        ;2940
0046e0  e59400b8          LDR      r0,[r4,#0xb8]         ;2946
0046e4  e3500000          CMP      r0,#0                 ;2946
0046e8  1a000031          BNE      |L1.18356|
0046ec  e5d4009c          LDRB     r0,[r4,#0x9c]         ;2946
0046f0  e3500005          CMP      r0,#5                 ;2946
0046f4  0a00002e          BEQ      |L1.18356|
0046f8  e5950018          LDR      r0,[r5,#0x18]         ;2947
0046fc  e3500008          CMP      r0,#8                 ;2947
004700  0a000015          BEQ      |L1.18268|
004704  e3500010          CMP      r0,#0x10              ;2947
004708  0a000017          BEQ      |L1.18284|
00470c  e3500040          CMP      r0,#0x40              ;2947
004710  0a000019          BEQ      |L1.18300|
004714  e3500080          CMP      r0,#0x80              ;2947
004718  1a00001f          BNE      |L1.18332|
00471c  ea00001a          B        |L1.18316|
                  |L1.18208|
004720  4e6f204e          DCB      "No NAND device found!!!\n",0
004724  414e4420
004728  64657669
00472c  63652066
004730  6f756e64
004734  2121210a
004738  00      
004739  00                DCB      0
00473a  00                DCB      0
00473b  00                DCB      0
                  |L1.18236|
                          DCD      nand_oob_8
                  |L1.18240|
                          DCD      nand_oob_8+0x4
                  |L1.18244|
                          DCD      nand_oob_16
                  |L1.18248|
                          DCD      nand_oob_16+0x4
                  |L1.18252|
                          DCD      nand_oob_64
                  |L1.18256|
                          DCD      nand_oob_64+0x4
                  |L1.18260|
                          DCD      nand_oob_128
                  |L1.18264|
                          DCD      nand_oob_128+0x4
                  |L1.18268|
00475c  e1a00000          MOV      r0,r0                 ;2948
004760  e51f002c          LDR      r0,|L1.18236|
004764  e58400b8          STR      r0,[r4,#0xb8]         ;2949
004768  ea000010          B        |L1.18352|
                  |L1.18284|
00476c  e1a00000          MOV      r0,r0                 ;2951
004770  e51f0034          LDR      r0,|L1.18244|
004774  e58400b8          STR      r0,[r4,#0xb8]         ;2952
004778  ea00000c          B        |L1.18352|
                  |L1.18300|
00477c  e1a00000          MOV      r0,r0                 ;2954
004780  e51f003c          LDR      r0,|L1.18252|
004784  e58400b8          STR      r0,[r4,#0xb8]         ;2955
004788  ea000008          B        |L1.18352|
                  |L1.18316|
00478c  e1a00000          MOV      r0,r0                 ;2957
004790  e51f0044          LDR      r0,|L1.18260|
004794  e58400b8          STR      r0,[r4,#0xb8]         ;2958
004798  ea000004          B        |L1.18352|
                  |L1.18332|
00479c  e1a00000          MOV      r0,r0                 ;2960
0047a0  e28f0e36          ADR      r0,|L1.19208|
0047a4  e5951018          LDR      r1,[r5,#0x18]         ;2961
0047a8  ebfffffe          BL       sysprintf
0047ac  e1a00000          MOV      r0,r0                 ;2947
                  |L1.18352|
0047b0  e1a00000          MOV      r0,r0                 ;2950
                  |L1.18356|
0047b4  e5940048          LDR      r0,[r4,#0x48]         ;2966
0047b8  e3500000          CMP      r0,#0                 ;2966
0047bc  1a000001          BNE      |L1.18376|
0047c0  e59f0368          LDR      r0,|L1.19248|
0047c4  e5840048          STR      r0,[r4,#0x48]         ;2967
                  |L1.18376|
0047c8  e5d4009c          LDRB     r0,[r4,#0x9c]         ;2974
0047cc  e3500006          CMP      r0,#6                 ;2974
0047d0  308ff100          ADDCC    pc,pc,r0,LSL #2       ;2974
0047d4  ea00011f          B        |L1.19544|
0047d8  ea00010a          B        |L1.19464|
0047dc  ea000083          B        |L1.18928|
0047e0  ea00001a          B        |L1.18512|
0047e4  ea000038          B        |L1.18636|
0047e8  ea000000          B        |L1.18416|
0047ec  ea000095          B        |L1.19016|
                  |L1.18416|
0047f0  e1a00000          MOV      r0,r0                 ;2975
0047f4  e59400c4          LDR      r0,[r4,#0xc4]         ;2977
0047f8  e3500000          CMP      r0,#0                 ;2977
0047fc  0a000005          BEQ      |L1.18456|
004800  e59400c8          LDR      r0,[r4,#0xc8]         ;2977
004804  e3500000          CMP      r0,#0                 ;2977
004808  0a000002          BEQ      |L1.18456|
00480c  e59400c0          LDR      r0,[r4,#0xc0]         ;2978
004810  e3500000          CMP      r0,#0                 ;2978
004814  1a000007          BNE      |L1.18488|
                  |L1.18456|
004818  e28f0fc5          ADR      r0,|L1.19252|
00481c  ebfffffe          BL       sysprintf
004820  e1a00000          MOV      r0,r0                 ;2981
004824  e59f2340          LDR      r2,|L1.19308|
004828  e59f1340          LDR      r1,|L1.19312|
00482c  e59f0340          LDR      r0,|L1.19316|
004830  ebfffffe          BL       sysprintf
004834  e1a00000          MOV      r0,r0                 ;2981
                  |L1.18488|
004838  e59400d4          LDR      r0,[r4,#0xd4]         ;2983
00483c  e3500000          CMP      r0,#0                 ;2983
004840  1a000001          BNE      |L1.18508|
004844  e59f032c          LDR      r0,|L1.19320|
004848  e58400d4          STR      r0,[r4,#0xd4]         ;2984
                  |L1.18508|
00484c  e1a00000          MOV      r0,r0                 ;2986
                  |L1.18512|
004850  e59400d4          LDR      r0,[r4,#0xd4]         ;2988
004854  e3500000          CMP      r0,#0                 ;2988
004858  1a000001          BNE      |L1.18532|
00485c  e59f0318          LDR      r0,|L1.19324|
004860  e58400d4          STR      r0,[r4,#0xd4]         ;2989
                  |L1.18532|
004864  e59400dc          LDR      r0,[r4,#0xdc]         ;2990
004868  e3500000          CMP      r0,#0                 ;2990
00486c  1a000001          BNE      |L1.18552|
004870  e59f0308          LDR      r0,|L1.19328|
004874  e58400dc          STR      r0,[r4,#0xdc]         ;2991
                  |L1.18552|
004878  e59400cc          LDR      r0,[r4,#0xcc]         ;2992
00487c  e3500000          CMP      r0,#0                 ;2992
004880  1a000001          BNE      |L1.18572|
004884  e59f02f8          LDR      r0,|L1.19332|
004888  e58400cc          STR      r0,[r4,#0xcc]         ;2993
                  |L1.18572|
00488c  e59400d0          LDR      r0,[r4,#0xd0]         ;2994
004890  e3500000          CMP      r0,#0                 ;2994
004894  1a000001          BNE      |L1.18592|
004898  e59f02e8          LDR      r0,|L1.19336|
00489c  e58400d0          STR      r0,[r4,#0xd0]         ;2995
                  |L1.18592|
0048a0  e59400e0          LDR      r0,[r4,#0xe0]         ;2996
0048a4  e3500000          CMP      r0,#0                 ;2996
0048a8  1a000001          BNE      |L1.18612|
0048ac  e59f02d8          LDR      r0,|L1.19340|
0048b0  e58400e0          STR      r0,[r4,#0xe0]         ;2997
                  |L1.18612|
0048b4  e59400e4          LDR      r0,[r4,#0xe4]         ;2998
0048b8  e3500000          CMP      r0,#0                 ;2998
0048bc  1a000001          BNE      |L1.18632|
0048c0  e59f02c8          LDR      r0,|L1.19344|
0048c4  e58400e4          STR      r0,[r4,#0xe4]         ;2999
                  |L1.18632|
0048c8  e1a00000          MOV      r0,r0                 ;3001
                  |L1.18636|
0048cc  e59400c4          LDR      r0,[r4,#0xc4]         ;3002
0048d0  e3500000          CMP      r0,#0                 ;3002
0048d4  0a000005          BEQ      |L1.18672|
0048d8  e59400c8          LDR      r0,[r4,#0xc8]         ;3002
0048dc  e3500000          CMP      r0,#0                 ;3002
0048e0  0a000002          BEQ      |L1.18672|
0048e4  e59400c0          LDR      r0,[r4,#0xc0]         ;3003
0048e8  e3500000          CMP      r0,#0                 ;3003
0048ec  1a000015          BNE      |L1.18760|
                  |L1.18672|
0048f0  e59400d4          LDR      r0,[r4,#0xd4]         ;3004
0048f4  e3500000          CMP      r0,#0                 ;3004
0048f8  0a00000a          BEQ      |L1.18728|
0048fc  e59f1278          LDR      r1,|L1.19324|
004900  e59400d4          LDR      r0,[r4,#0xd4]         ;3005
004904  e1500001          CMP      r0,r1                 ;3005
004908  0a000006          BEQ      |L1.18728|
00490c  e59400dc          LDR      r0,[r4,#0xdc]         ;3006
004910  e3500000          CMP      r0,#0                 ;3006
004914  0a000003          BEQ      |L1.18728|
004918  e59f1260          LDR      r1,|L1.19328|
00491c  e59400dc          LDR      r0,[r4,#0xdc]         ;3007
004920  e1500001          CMP      r0,r1                 ;3007
004924  1a000007          BNE      |L1.18760|
                  |L1.18728|
004928  e28f0f81          ADR      r0,|L1.19252|
00492c  ebfffffe          BL       sysprintf
004930  e1a00000          MOV      r0,r0                 ;3010
004934  e59f2258          LDR      r2,|L1.19348|
004938  e59f1230          LDR      r1,|L1.19312|
00493c  e59f0230          LDR      r0,|L1.19316|
004940  ebfffffe          BL       sysprintf
004944  e1a00000          MOV      r0,r0                 ;3010
                  |L1.18760|
004948  e59400d4          LDR      r0,[r4,#0xd4]         ;3013
00494c  e3500000          CMP      r0,#0                 ;3013
004950  1a000001          BNE      |L1.18780|
004954  e59f023c          LDR      r0,|L1.19352|
004958  e58400d4          STR      r0,[r4,#0xd4]         ;3014
                  |L1.18780|
00495c  e59400dc          LDR      r0,[r4,#0xdc]         ;3015
004960  e3500000          CMP      r0,#0                 ;3015
004964  1a000001          BNE      |L1.18800|
004968  e59f022c          LDR      r0,|L1.19356|
00496c  e58400dc          STR      r0,[r4,#0xdc]         ;3016
                  |L1.18800|
004970  e59400cc          LDR      r0,[r4,#0xcc]         ;3017
004974  e3500000          CMP      r0,#0                 ;3017
004978  1a000001          BNE      |L1.18820|
00497c  e59f021c          LDR      r0,|L1.19360|
004980  e58400cc          STR      r0,[r4,#0xcc]         ;3018
                  |L1.18820|
004984  e59400d0          LDR      r0,[r4,#0xd0]         ;3019
004988  e3500000          CMP      r0,#0                 ;3019
00498c  1a000001          BNE      |L1.18840|
004990  e59f020c          LDR      r0,|L1.19364|
004994  e58400d0          STR      r0,[r4,#0xd0]         ;3020
                  |L1.18840|
004998  e59400e0          LDR      r0,[r4,#0xe0]         ;3021
00499c  e3500000          CMP      r0,#0                 ;3021
0049a0  1a000001          BNE      |L1.18860|
0049a4  e59f01fc          LDR      r0,|L1.19368|
0049a8  e58400e0          STR      r0,[r4,#0xe0]         ;3022
                  |L1.18860|
0049ac  e59400e4          LDR      r0,[r4,#0xe4]         ;3023
0049b0  e3500000          CMP      r0,#0                 ;3023
0049b4  1a000001          BNE      |L1.18880|
0049b8  e59f01ec          LDR      r0,|L1.19372|
0049bc  e58400e4          STR      r0,[r4,#0xe4]         ;3024
                  |L1.18880|
0049c0  e5950014          LDR      r0,[r5,#0x14]         ;3026
0049c4  e59410a4          LDR      r1,[r4,#0xa4]         ;3026
0049c8  e1500001          CMP      r0,r1                 ;3026
0049cc  3a000000          BCC      |L1.18900|
0049d0  ea0000ab          B        |L1.19588|
                  |L1.18900|
0049d4  e5952014          LDR      r2,[r5,#0x14]         ;3028
0049d8  e59f01d0          LDR      r0,|L1.19376|
0049dc  e59410a4          LDR      r1,[r4,#0xa4]         ;3028
0049e0  ebfffffe          BL       sysprintf
0049e4  e3a00001          MOV      r0,#1                 ;3031
0049e8  e5c4009c          STRB     r0,[r4,#0x9c]         ;3031
0049ec  e1a00000          MOV      r0,r0                 ;3033
                  |L1.18928|
0049f0  e59f01bc          LDR      r0,|L1.19380|
0049f4  e58400d4          STR      r0,[r4,#0xd4]         ;3036
0049f8  e59f01b8          LDR      r0,|L1.19384|
0049fc  e58400d8          STR      r0,[r4,#0xd8]         ;3037
004a00  e59f01b4          LDR      r0,|L1.19388|
004a04  e58400dc          STR      r0,[r4,#0xdc]         ;3038
004a08  e59f0174          LDR      r0,|L1.19332|
004a0c  e58400cc          STR      r0,[r4,#0xcc]         ;3039
004a10  e59f0170          LDR      r0,|L1.19336|
004a14  e58400d0          STR      r0,[r4,#0xd0]         ;3040
004a18  e59f016c          LDR      r0,|L1.19340|
004a1c  e58400e0          STR      r0,[r4,#0xe0]         ;3041
004a20  e59f0168          LDR      r0,|L1.19344|
004a24  e58400e4          STR      r0,[r4,#0xe4]         ;3042
004a28  e59400a4          LDR      r0,[r4,#0xa4]         ;3043
004a2c  e3500000          CMP      r0,#0                 ;3043
004a30  1a000001          BNE      |L1.19004|
004a34  e3a00c01          MOV      r0,#0x100             ;3044
004a38  e58400a4          STR      r0,[r4,#0xa4]         ;3044
                  |L1.19004|
004a3c  e3a00003          MOV      r0,#3                 ;3045
004a40  e58400a8          STR      r0,[r4,#0xa8]         ;3045
004a44  ea00008e          B        |L1.19588|
                  |L1.19016|
004a48  e1a00000          MOV      r0,r0                 ;3048
004a4c  e1a00000          MOV      r0,r0                 ;3049
004a50  e3a00000          MOV      r0,#0                 ;3049
004a54  e3500000          CMP      r0,#0                 ;3049
004a58  1a000003          BNE      |L1.19052|
004a5c  e28f0f57          ADR      r0,|L1.19392|
004a60  ebfffffe          BL       sysprintf
004a64  e3e00015          MVN      r0,#0x15              ;3051
004a68  eafffebb          B        |L1.17756|
                  |L1.19052|
004a6c  e59f016c          LDR      r0,|L1.19424|
004a70  e58400c4          STR      r0,[r4,#0xc4]         ;3053
004a74  e59f0168          LDR      r0,|L1.19428|
004a78  e58400c8          STR      r0,[r4,#0xc8]         ;3054
004a7c  e59f0130          LDR      r0,|L1.19380|
004a80  e58400d4          STR      r0,[r4,#0xd4]         ;3055
004a84  e59f012c          LDR      r0,|L1.19384|
004a88  e58400d8          STR      r0,[r4,#0xd8]         ;3056
004a8c  e59f0128          LDR      r0,|L1.19388|
004a90  e58400dc          STR      r0,[r4,#0xdc]         ;3057
004a94  e59f00e8          LDR      r0,|L1.19332|
004a98  e58400cc          STR      r0,[r4,#0xcc]         ;3058
004a9c  e59f00e4          LDR      r0,|L1.19336|
004aa0  e58400d0          STR      r0,[r4,#0xd0]         ;3059
004aa4  e59f00e0          LDR      r0,|L1.19340|
004aa8  e58400e0          STR      r0,[r4,#0xe0]         ;3060
004aac  e59f00dc          LDR      r0,|L1.19344|
004ab0  e58400e4          STR      r0,[r4,#0xe4]         ;3061
004ab4  e59400a4          LDR      r0,[r4,#0xa4]         ;3068
004ab8  e3500000          CMP      r0,#0                 ;3068
004abc  1a000006          BNE      |L1.19164|
004ac0  e5950018          LDR      r0,[r5,#0x18]         ;3068
004ac4  e3500040          CMP      r0,#0x40              ;3068
004ac8  3a000003          BCC      |L1.19164|
004acc  e3a00c02          MOV      r0,#0x200             ;3069
004ad0  e58400a4          STR      r0,[r4,#0xa4]         ;3069
004ad4  e3a00007          MOV      r0,#7                 ;3070
004ad8  e58400a8          STR      r0,[r4,#0xa8]         ;3070
                  |L1.19164|
004adc  e59400a4          LDR      r0,[r4,#0xa4]         ;3072
004ae0  e59410a8          LDR      r1,[r4,#0xa8]         ;3072
004ae4  e28420b8          ADD      r2,r4,#0xb8           ;3072
004ae8  e3a03000          MOV      r3,#0                 ;3072
004aec  e58430bc          STR      r3,[r4,#0xbc]         ;3072
004af0  e59400bc          LDR      r0,[r4,#0xbc]         ;3076
004af4  e3500000          CMP      r0,#0                 ;3076
004af8  1a000001          BNE      |L1.19204|
004afc  e28f00e4          ADR      r0,|L1.19432|
004b00  ebfffffe          BL       sysprintf
                  |L1.19204|
004b04  ea00005e          B        |L1.19588|
                  |L1.19208|
004b08  4e6f206f          DCB      "No oob scheme defined for oobsize %d\n",0
004b0c  6f622073
004b10  6368656d
004b14  65206465
004b18  66696e65
004b1c  6420666f
004b20  72206f6f
004b24  6273697a
004b28  65202564
004b2c  0a00    
004b2e  00                DCB      0
004b2f  00                DCB      0
                  |L1.19248|
                          DCD      nand_write_page
                  |L1.19252|
004b34  4e6f2045          DCB      "No ECC functions supplied; Hardware ECC not possible\n",0
004b38  43432066
004b3c  756e6374
004b40  696f6e73
004b44  20737570
004b48  706c6965
004b4c  643b2048
004b50  61726477
004b54  61726520
004b58  45434320
004b5c  6e6f7420
004b60  706f7373
004b64  69626c65
004b68  0a00    
004b6a  00                DCB      0
004b6b  00                DCB      0
                  |L1.19308|
                          DCD      0x00000ba5
                  |L1.19312|
                          DCD      ||.text||+0x4c0
                  |L1.19316|
                          DCD      ||.text||+0x4f4
                  |L1.19320|
                          DCD      nand_read_page_hwecc_oob_first
                  |L1.19324|
                          DCD      nand_read_page_hwecc
                  |L1.19328|
                          DCD      nand_write_page_hwecc
                  |L1.19332|
                          DCD      nand_read_page_raw
                  |L1.19336|
                          DCD      nand_write_page_raw
                  |L1.19340|
                          DCD      nand_read_oob_std
                  |L1.19344|
                          DCD      nand_write_oob_std
                  |L1.19348|
                          DCD      0x00000bc2
                  |L1.19352|
                          DCD      nand_read_page_syndrome
                  |L1.19356|
                          DCD      nand_write_page_syndrome
                  |L1.19360|
                          DCD      nand_read_page_raw_syndrome
                  |L1.19364|
                          DCD      nand_write_page_raw_syndrome
                  |L1.19368|
                          DCD      nand_read_oob_syndrome
                  |L1.19372|
                          DCD      nand_write_oob_syndrome
                  |L1.19376|
                          DCD      ||.constdata||+0x80
                  |L1.19380|
                          DCD      nand_read_page_swecc
                  |L1.19384|
                          DCD      nand_read_subpage
                  |L1.19388|
                          DCD      nand_write_page_swecc
                  |L1.19392|
004bc0  434f4e46          DCB      "CONFIG_MTD_ECC_BCH not enabled\n",0
004bc4  49475f4d
004bc8  54445f45
004bcc  43435f42
004bd0  4348206e
004bd4  6f742065
004bd8  6e61626c
004bdc  65640a00
                  |L1.19424|
                          DCD      nand_bch_calculate_ecc
                  |L1.19428|
                          DCD      nand_bch_correct_data
                  |L1.19432|
004be8  42434820          DCB      "BCH ECC initialization failed!\n",0
004bec  45434320
004bf0  696e6974
004bf4  69616c69
004bf8  7a617469
004bfc  6f6e2066
004c00  61696c65
004c04  64210a00
                  |L1.19464|
004c08  e1a00000          MOV      r0,r0                 ;3081
004c0c  e59f02ac          LDR      r0,|L1.20160|
004c10  ebfffffe          BL       sysprintf
004c14  e51f0098          LDR      r0,|L1.19332|
004c18  e58400d4          STR      r0,[r4,#0xd4]         ;3084
004c1c  e51f009c          LDR      r0,|L1.19336|
004c20  e58400dc          STR      r0,[r4,#0xdc]         ;3085
004c24  e51f00a0          LDR      r0,|L1.19340|
004c28  e58400e0          STR      r0,[r4,#0xe0]         ;3086
004c2c  e51f00b0          LDR      r0,|L1.19332|
004c30  e58400cc          STR      r0,[r4,#0xcc]         ;3087
004c34  e51f00b4          LDR      r0,|L1.19336|
004c38  e58400d0          STR      r0,[r4,#0xd0]         ;3088
004c3c  e51f00b4          LDR      r0,|L1.19344|
004c40  e58400e4          STR      r0,[r4,#0xe4]         ;3089
004c44  e5950014          LDR      r0,[r5,#0x14]         ;3090
004c48  e58400a4          STR      r0,[r4,#0xa4]         ;3090
004c4c  e3a00000          MOV      r0,#0                 ;3091
004c50  e58400a8          STR      r0,[r4,#0xa8]         ;3091
004c54  ea00000a          B        |L1.19588|
                  |L1.19544|
004c58  e1a00000          MOV      r0,r0                 ;3094
004c5c  e5d4109c          LDRB     r1,[r4,#0x9c]         ;3095
004c60  e28f0f97          ADR      r0,|L1.20164|
004c64  ebfffffe          BL       sysprintf
004c68  e1a00000          MOV      r0,r0                 ;3097
004c6c  e59f226c          LDR      r2,|L1.20192|
004c70  e51f1108          LDR      r1,|L1.19312|
004c74  e51f0108          LDR      r0,|L1.19316|
004c78  ebfffffe          BL       sysprintf
004c7c  e1a00000          MOV      r0,r0                 ;3097
004c80  e1a00000          MOV      r0,r0                 ;2974
                  |L1.19588|
004c84  e1a00000          MOV      r0,r0                 ;3027
004c88  e3a00000          MOV      r0,#0                 ;3104
004c8c  e59410b8          LDR      r1,[r4,#0xb8]         ;3104
004c90  e5810204          STR      r0,[r1,#0x204]        ;3104
004c94  e58d0000          STR      r0,[sp,#0]            ;3105
004c98  ea00000c          B        |L1.19664|
                  |L1.19612|
004c9c  e59400b8          LDR      r0,[r4,#0xb8]         ;3107
004ca0  e2800f82          ADD      r0,r0,#0x208          ;3107
004ca4  e59d1000          LDR      r1,[sp,#0]            ;3107
004ca8  e0800181          ADD      r0,r0,r1,LSL #3       ;3107
004cac  e5900004          LDR      r0,[r0,#4]            ;3107
004cb0  e59410b8          LDR      r1,[r4,#0xb8]         ;3107
004cb4  e5911204          LDR      r1,[r1,#0x204]        ;3107
004cb8  e0800001          ADD      r0,r0,r1              ;3107
004cbc  e59410b8          LDR      r1,[r4,#0xb8]         ;3107
004cc0  e5810204          STR      r0,[r1,#0x204]        ;3107
004cc4  e59d0000          LDR      r0,[sp,#0]            ;3106
004cc8  e2800001          ADD      r0,r0,#1              ;3106
004ccc  e58d0000          STR      r0,[sp,#0]            ;3106
                  |L1.19664|
004cd0  e59400b8          LDR      r0,[r4,#0xb8]         ;3105
004cd4  e2800f82          ADD      r0,r0,#0x208          ;3105
004cd8  e59d1000          LDR      r1,[sp,#0]            ;3105
004cdc  e0800181          ADD      r0,r0,r1,LSL #3       ;3105
004ce0  e5900004          LDR      r0,[r0,#4]            ;3105
004ce4  e3500000          CMP      r0,#0                 ;3105
004ce8  0a000002          BEQ      |L1.19704|
004cec  e59d0000          LDR      r0,[sp,#0]            ;3106
004cf0  e3500008          CMP      r0,#8                 ;3106
004cf4  3affffe8          BCC      |L1.19612|
                  |L1.19704|
004cf8  e59400b8          LDR      r0,[r4,#0xb8]         ;3109
004cfc  e5900204          LDR      r0,[r0,#0x204]        ;3109
004d00  e585001c          STR      r0,[r5,#0x1c]         ;3109
004d04  e59410a4          LDR      r1,[r4,#0xa4]         ;3115
004d08  e5950014          LDR      r0,[r5,#0x14]         ;3115
004d0c  ebfffffe          BL       __aeabi_uidivmod
004d10  e58400a0          STR      r0,[r4,#0xa0]         ;3115
004d14  e59400a0          LDR      r0,[r4,#0xa0]         ;3116
004d18  e59410a4          LDR      r1,[r4,#0xa4]         ;3116
004d1c  e0000091          MUL      r0,r1,r0              ;3116
004d20  e5951014          LDR      r1,[r5,#0x14]         ;3116
004d24  e1500001          CMP      r0,r1                 ;3116
004d28  0a000007          BEQ      |L1.19788|
004d2c  e28f0e1b          ADR      r0,|L1.20196|
004d30  ebfffffe          BL       sysprintf
004d34  e1a00000          MOV      r0,r0                 ;3118
004d38  e59f21bc          LDR      r2,|L1.20220|
004d3c  e51f11d4          LDR      r1,|L1.19312|
004d40  e51f01d4          LDR      r0,|L1.19316|
004d44  ebfffffe          BL       sysprintf
004d48  e1a00000          MOV      r0,r0                 ;3118
                  |L1.19788|
004d4c  e59400a0          LDR      r0,[r4,#0xa0]         ;3120
004d50  e59410a8          LDR      r1,[r4,#0xa8]         ;3120
004d54  e0000091          MUL      r0,r1,r0              ;3120
004d58  e58400ac          STR      r0,[r4,#0xac]         ;3120
004d5c  e1d405b0          LDRH     r0,[r4,#0x50]         ;3126
004d60  e3100c02          TST      r0,#0x200             ;3126
004d64  1a000017          BNE      |L1.19912|
004d68  e5d4007c          LDRB     r0,[r4,#0x7c]         ;3127
004d6c  e310000c          TST      r0,#0xc               ;3127
004d70  1a000014          BNE      |L1.19912|
004d74  e59400a0          LDR      r0,[r4,#0xa0]         ;3128
004d78  e3500002          CMP      r0,#2                 ;3128
004d7c  0a000006          BEQ      |L1.19868|
004d80  e3500004          CMP      r0,#4                 ;3128
004d84  0a000008          BEQ      |L1.19884|
004d88  e3500008          CMP      r0,#8                 ;3128
004d8c  0a000008          BEQ      |L1.19892|
004d90  e3500010          CMP      r0,#0x10              ;3128
004d94  1a00000a          BNE      |L1.19908|
004d98  ea000006          B        |L1.19896|
                  |L1.19868|
004d9c  e1a00000          MOV      r0,r0                 ;3129
004da0  e3a00001          MOV      r0,#1                 ;3130
004da4  e5850090          STR      r0,[r5,#0x90]         ;3130
004da8  ea000005          B        |L1.19908|
                  |L1.19884|
004dac  e1a00000          MOV      r0,r0                 ;3132
004db0  e1a00000          MOV      r0,r0                 ;3133
                  |L1.19892|
004db4  e1a00000          MOV      r0,r0                 ;3134
                  |L1.19896|
004db8  e3a00002          MOV      r0,#2                 ;3135
004dbc  e5850090          STR      r0,[r5,#0x90]         ;3135
004dc0  e1a00000          MOV      r0,r0                 ;3136
                  |L1.19908|
004dc4  e1a00000          MOV      r0,r0                 ;3131
                  |L1.19912|
004dc8  e5950014          LDR      r0,[r5,#0x14]         ;3139
004dcc  e5d51090          LDRB     r1,[r5,#0x90]         ;3139
004dd0  e1a00130          LSR      r0,r0,r1              ;3139
004dd4  e5840078          STR      r0,[r4,#0x78]         ;3139
004dd8  e3a00000          MOV      r0,#0                 ;3142
004ddc  e584008c          STR      r0,[r4,#0x8c]         ;3142
004de0  e3e01000          MVN      r1,#0                 ;3145
004de4  e1a00005          MOV      r0,r5                 ;3145
004de8  e594201c          LDR      r2,[r4,#0x1c]         ;3145
004dec  e12fff32          BLX      r2                    ;3145
004df0  e3e00000          MVN      r0,#0                 ;3148
004df4  e5840074          STR      r0,[r4,#0x74]         ;3148
004df8  e5d4009c          LDRB     r0,[r4,#0x9c]         ;3151
004dfc  e3500001          CMP      r0,#1                 ;3151
004e00  1a000005          BNE      |L1.19996|
004e04  e5940054          LDR      r0,[r4,#0x54]         ;3151
004e08  e3500009          CMP      r0,#9                 ;3151
004e0c  da000002          BLE      |L1.19996|
004e10  e5940050          LDR      r0,[r4,#0x50]         ;3152
004e14  e3800a01          ORR      r0,r0,#0x1000         ;3152
004e18  e5840050          STR      r0,[r4,#0x50]         ;3152
                  |L1.19996|
004e1c  e3a00004          MOV      r0,#4                 ;3155
004e20  e5c50000          STRB     r0,[r5,#0]            ;3155
004e24  e1d405b0          LDRH     r0,[r4,#0x50]         ;3156
004e28  e3100b02          TST      r0,#0x800             ;3156
004e2c  0a000001          BEQ      |L1.20024|
004e30  e3a00000          MOV      r0,#0                 ;3156
004e34  ea000000          B        |L1.20028|
                  |L1.20024|
004e38  e3a00b01          MOV      r0,#0x400             ;3157
                  |L1.20028|
004e3c  e5850004          STR      r0,[r5,#4]            ;3157
004e40  e59f00b8          LDR      r0,|L1.20224|
004e44  e5850034          STR      r0,[r5,#0x34]         ;3158
004e48  e3a00000          MOV      r0,#0                 ;3159
004e4c  e5850038          STR      r0,[r5,#0x38]         ;3159
004e50  e585003c          STR      r0,[r5,#0x3c]         ;3160
004e54  e59f00a8          LDR      r0,|L1.20228|
004e58  e5850040          STR      r0,[r5,#0x40]         ;3161
004e5c  e59f00a4          LDR      r0,|L1.20232|
004e60  e5850044          STR      r0,[r5,#0x44]         ;3162
004e64  e59f00a0          LDR      r0,|L1.20236|
004e68  e585004c          STR      r0,[r5,#0x4c]         ;3163
004e6c  e59f009c          LDR      r0,|L1.20240|
004e70  e5850050          STR      r0,[r5,#0x50]         ;3164
004e74  e59f0098          LDR      r0,|L1.20244|
004e78  e585006c          STR      r0,[r5,#0x6c]         ;3165
004e7c  e3a00000          MOV      r0,#0                 ;3166
004e80  e5850070          STR      r0,[r5,#0x70]         ;3166
004e84  e5850074          STR      r0,[r5,#0x74]         ;3167
004e88  e59f0088          LDR      r0,|L1.20248|
004e8c  e5850078          STR      r0,[r5,#0x78]         ;3168
004e90  e59f0084          LDR      r0,|L1.20252|
004e94  e585007c          STR      r0,[r5,#0x7c]         ;3169
004e98  e59400b8          LDR      r0,[r4,#0xb8]         ;3172
004e9c  e5850028          STR      r0,[r5,#0x28]         ;3172
004ea0  e5940050          LDR      r0,[r4,#0x50]         ;3175
004ea4  e3100802          TST      r0,#0x20000           ;3175
004ea8  0a000002          BEQ      |L1.20152|
004eac  e5940050          LDR      r0,[r4,#0x50]         ;3176
004eb0  e3800101          ORR      r0,r0,#0x40000000     ;3176
004eb4  e5840050          STR      r0,[r4,#0x50]         ;3176
                  |L1.20152|
004eb8  e3a00000          MOV      r0,#0                 ;3178
004ebc  eafffda6          B        |L1.17756|
                  |L1.20160|
                          DCD      ||.constdata||+0xc8
                  |L1.20164|
004ec4  496e7661          DCB      "Invalid NAND_ECC_MODE %d\n",0
004ec8  6c696420
004ecc  4e414e44
004ed0  5f454343
004ed4  5f4d4f44
004ed8  45202564
004edc  0a00    
004ede  00                DCB      0
004edf  00                DCB      0
                  |L1.20192|
                          DCD      0x00000c19
                  |L1.20196|
004ee4  496e7661          DCB      "Invalid ecc parameters\n",0
004ee8  6c696420
004eec  65636320
004ef0  70617261
004ef4  6d657465
004ef8  72730a00
                  |L1.20220|
                          DCD      0x00000c2e
                  |L1.20224|
                          DCD      nand_erase
                  |L1.20228|
                          DCD      nand_read
                  |L1.20232|
                          DCD      nand_write
                  |L1.20236|
                          DCD      nand_read_oob
                  |L1.20240|
                          DCD      nand_write_oob
                  |L1.20244|
                          DCD      nand_sync
                  |L1.20248|
                          DCD      nand_block_isbad
                  |L1.20252|
                          DCD      nand_block_markbad
                          ENDP

                  nand_scan PROC
;;;3192    */
;;;3193   int nand_scan(struct mtd_info *mtd, int maxchips)
004f20  e92d4070          PUSH     {r4-r6,lr}
;;;3194   {
004f24  e1a05000          MOV      r5,r0
004f28  e1a06001          MOV      r6,r1
;;;3195   	int ret;
;;;3196   
;;;3197   	ret = nand_scan_ident(mtd, maxchips, NULL);
004f2c  e3a02000          MOV      r2,#0
004f30  e1a01006          MOV      r1,r6
004f34  e1a00005          MOV      r0,r5
004f38  ebfffffe          BL       nand_scan_ident
004f3c  e1a04000          MOV      r4,r0
;;;3198   	if (!ret)
004f40  e3540000          CMP      r4,#0
004f44  1a000002          BNE      |L1.20308|
;;;3199   		ret = nand_scan_tail(mtd);
004f48  e1a00005          MOV      r0,r5
004f4c  ebfffffe          BL       nand_scan_tail
004f50  e1a04000          MOV      r4,r0
                  |L1.20308|
;;;3200   	return ret;
004f54  e1a00004          MOV      r0,r4
;;;3201   }
004f58  e8bd8070          POP      {r4-r6,pc}
;;;3202   
                          ENDP

                  nand_release PROC
;;;3206   */
;;;3207   void nand_release(struct mtd_info *mtd)
004f5c  e92d4070          PUSH     {r4-r6,lr}
;;;3208   {
004f60  e1a05000          MOV      r5,r0
;;;3209   	struct nand_chip *chip = mtd->priv;
004f64  e5954094          LDR      r4,[r5,#0x94]
;;;3210   
;;;3211   	if (chip->ecc.mode == NAND_ECC_SOFT_BCH)
004f68  e5d4009c          LDRB     r0,[r4,#0x9c]
004f6c  e3500005          CMP      r0,#5
004f70  1a000002          BNE      |L1.20352|
;;;3212   		nand_bch_free((struct nand_bch_control *)chip->ecc.priv);
004f74  e59400bc          LDR      r0,[r4,#0xbc]
004f78  e1a00000          MOV      r0,r0
004f7c  e1a00000          MOV      r0,r0
                  |L1.20352|
;;;3213   
;;;3214   	/* Deregister partitions */
;;;3215   	del_mtd_partitions(mtd);
004f80  e1a00005          MOV      r0,r5
004f84  ebfffffe          BL       del_mtd_partitions
;;;3216   
;;;3217   	/* Free bad block table memory */
;;;3218   	yaffs_free(chip->bbt);
004f88  e5940110          LDR      r0,[r4,#0x110]
004f8c  ebfffffe          BL       yaffs_free
;;;3219   	if (!(chip->options & NAND_OWN_BUFFERS))
004f90  e5940050          LDR      r0,[r4,#0x50]
004f94  e3100701          TST      r0,#0x40000
004f98  1a000001          BNE      |L1.20388|
;;;3220   		yaffs_free(chip->buffers);
004f9c  e59400e8          LDR      r0,[r4,#0xe8]
004fa0  ebfffffe          BL       yaffs_free
                  |L1.20388|
;;;3221   
;;;3222   	/* Free bad block descriptor memory */
;;;3223   	if (chip->badblock_pattern && chip->badblock_pattern->options
004fa4  e594011c          LDR      r0,[r4,#0x11c]
004fa8  e3500000          CMP      r0,#0
004fac  0a000005          BEQ      |L1.20424|
004fb0  e594011c          LDR      r0,[r4,#0x11c]
004fb4  e5900000          LDR      r0,[r0,#0]
004fb8  e3100602          TST      r0,#0x200000
004fbc  0a000001          BEQ      |L1.20424|
;;;3224   			& NAND_BBT_DYNAMICSTRUCT)
;;;3225   		yaffs_free(chip->badblock_pattern);
004fc0  e594011c          LDR      r0,[r4,#0x11c]
004fc4  ebfffffe          BL       yaffs_free
                  |L1.20424|
;;;3226   }
004fc8  e8bd8070          POP      {r4-r6,pc}
                          ENDP

                  nand_bch_calculate_ecc PROC
;;;47     static __inline int
;;;48     nand_bch_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
004fcc  e1a03000          MOV      r3,r0
;;;49     		       u_char *ecc_code)
;;;50     {
;;;51     	return -1;
004fd0  e3e00000          MVN      r0,#0
;;;52     }
004fd4  e12fff1e          BX       lr
;;;53     
                          ENDP

                  nand_bch_correct_data PROC
;;;54     static __inline int
;;;55     nand_bch_correct_data(struct mtd_info *mtd, unsigned char *buf,
004fd8  e1a0c000          MOV      r12,r0
;;;56     		      unsigned char *read_ecc, unsigned char *calc_ecc)
;;;57     {
;;;58     	return -1;
004fdc  e3e00000          MVN      r0,#0
;;;59     }
004fe0  e12fff1e          BX       lr
;;;60     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  nand_oob_8
                          %        584
                  nand_oob_16
                          %        584
                  nand_oob_64
                          %        584
                  nand_oob_128
                          %        584

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  __func__
000000  63686563          DCB      0x63,0x68,0x65,0x63
000004  6b5f6f66          DCB      0x6b,0x5f,0x6f,0x66
000008  66735f6c          DCB      0x66,0x73,0x5f,0x6c
00000c  656e00            DCB      0x65,0x6e,0x00
                  |symbol_number.32|
00000f  6e                DCB      0x6e
000010  616e645f          DCB      0x61,0x6e,0x64,0x5f
000014  646f5f72          DCB      0x64,0x6f,0x5f,0x72
000018  6561645f          DCB      0x65,0x61,0x64,0x5f
00001c  6f6f6200          DCB      0x6f,0x6f,0x62,0x00
                  |symbol_number.33|
000020  6e616e64          DCB      0x6e,0x61,0x6e,0x64
000024  5f726561          DCB      0x5f,0x72,0x65,0x61
000028  645f6f6f          DCB      0x64,0x5f,0x6f,0x6f
00002c  6200              DCB      0x62,0x00
                  |symbol_number.34|
00002e  6e61              DCB      0x6e,0x61
000030  6e645f64          DCB      0x6e,0x64,0x5f,0x64
000034  6f5f7772          DCB      0x6f,0x5f,0x77,0x72
000038  6974655f          DCB      0x69,0x74,0x65,0x5f
00003c  6f6f6200          DCB      0x6f,0x6f,0x62,0x00
                  |symbol_number.35|
000040  6e616e64          DCB      0x6e,0x61,0x6e,0x64
000044  5f777269          DCB      0x5f,0x77,0x72,0x69
000048  74655f6f          DCB      0x74,0x65,0x5f,0x6f
00004c  6f6200            DCB      0x6f,0x62,0x00
                  |symbol_number.36|
00004f  6e                DCB      0x6e
000050  616e645f          DCB      0x61,0x6e,0x64,0x5f
000054  65726173          DCB      0x65,0x72,0x61,0x73
000058  655f6e61          DCB      0x65,0x5f,0x6e,0x61
00005c  6e6400            DCB      0x6e,0x64,0x00
                  |symbol_number.37|
00005f  6e                DCB      0x6e
000060  616e645f          DCB      0x61,0x6e,0x64,0x5f
000064  73796e63          DCB      0x73,0x79,0x6e,0x63
000068  00                DCB      0x00
                  |symbol_number.38|
000069  6e616e            DCB      0x6e,0x61,0x6e
00006c  645f6765          DCB      0x64,0x5f,0x67,0x65
000070  745f666c          DCB      0x74,0x5f,0x66,0x6c
000074  6173685f          DCB      0x61,0x73,0x68,0x5f
000078  74797065          DCB      0x74,0x79,0x70,0x65
00007c  00000000          DCB      0x00,0x00,0x00,0x00
000080  25642062          DCB      0x25,0x64,0x20,0x62
000084  79746520          DCB      0x79,0x74,0x65,0x20
000088  48572045          DCB      0x48,0x57,0x20,0x45
00008c  4343206e          DCB      0x43,0x43,0x20,0x6e
000090  6f742070          DCB      0x6f,0x74,0x20,0x70
000094  6f737369          DCB      0x6f,0x73,0x73,0x69
000098  626c6520          DCB      0x62,0x6c,0x65,0x20
00009c  6f6e2025          DCB      0x6f,0x6e,0x20,0x25
0000a0  64206279          DCB      0x64,0x20,0x62,0x79
0000a4  74652070          DCB      0x74,0x65,0x20,0x70
0000a8  61676520          DCB      0x61,0x67,0x65,0x20
0000ac  73697a65          DCB      0x73,0x69,0x7a,0x65
0000b0  2c206661          DCB      0x2c,0x20,0x66,0x61
0000b4  6c6c6261          DCB      0x6c,0x6c,0x62,0x61
0000b8  636b2074          DCB      0x63,0x6b,0x20,0x74
0000bc  6f205357          DCB      0x6f,0x20,0x53,0x57
0000c0  20454343          DCB      0x20,0x45,0x43,0x43
0000c4  0a000000          DCB      0x0a,0x00,0x00,0x00
0000c8  4e414e44          DCB      0x4e,0x41,0x4e,0x44
0000cc  5f454343          DCB      0x5f,0x45,0x43,0x43
0000d0  5f4e4f4e          DCB      0x5f,0x4e,0x4f,0x4e
0000d4  45207365          DCB      0x45,0x20,0x73,0x65
0000d8  6c656374          DCB      0x6c,0x65,0x63,0x74
0000dc  65642062          DCB      0x65,0x64,0x20,0x62
0000e0  7920626f          DCB      0x79,0x20,0x62,0x6f
0000e4  61726420          DCB      0x61,0x72,0x64,0x20
0000e8  64726976          DCB      0x64,0x72,0x69,0x76
0000ec  65722e20          DCB      0x65,0x72,0x2e,0x20
0000f0  54686973          DCB      0x54,0x68,0x69,0x73
0000f4  20697320          DCB      0x20,0x69,0x73,0x20
0000f8  6e6f7420          DCB      0x6e,0x6f,0x74,0x20
0000fc  7265636f          DCB      0x72,0x65,0x63,0x6f
000100  6d6d656e          DCB      0x6d,0x6d,0x65,0x6e
000104  64656420          DCB      0x64,0x65,0x64,0x20
000108  21210a00          DCB      0x21,0x21,0x0a,0x00
