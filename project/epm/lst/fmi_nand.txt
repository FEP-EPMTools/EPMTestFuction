; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\fmi_nand.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\fmi_nand.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\fmi_nand.crf ..\..\common\src\BSP\ThirdParty\yaffs2\platform\fmi_nand.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  udelay PROC
;;;79     
;;;80     void udelay(unsigned int tick)
000000  e92d4038          PUSH     {r3-r5,lr}
;;;81     {
000004  e1a04000          MOV      r4,r0
;;;82         int volatile start;
;;;83         start = sysGetTicks(TIMER0);
000008  e3a00000          MOV      r0,#0
00000c  ebfffffe          BL       sysGetTicks
000010  e58d0000          STR      r0,[sp,#0]
;;;84         while(1)
000014  ea000006          B        |L1.52|
                  |L1.24|
;;;85             if ((sysGetTicks(TIMER0) - start) > tick)
000018  e3a00000          MOV      r0,#0
00001c  ebfffffe          BL       sysGetTicks
000020  e59d1000          LDR      r1,[sp,#0]
000024  e0400001          SUB      r0,r0,r1
000028  e1500004          CMP      r0,r4
00002c  9a000000          BLS      |L1.52|
;;;86                 break;
000030  ea000000          B        |L1.56|
                  |L1.52|
000034  eafffff7          B        |L1.24|
                  |L1.56|
000038  e1a00000          MOV      r0,r0
;;;87     }
00003c  e8bd8038          POP      {r3-r5,pc}
;;;88     
                          ENDP

                  get_timer PROC
;;;89     unsigned int get_timer(unsigned int tick)
000040  e92d4010          PUSH     {r4,lr}
;;;90     {
000044  e1a04000          MOV      r4,r0
;;;91         return (sysGetTicks(TIMER0) - tick);
000048  e3a00000          MOV      r0,#0
00004c  ebfffffe          BL       sysGetTicks
000050  e0400004          SUB      r0,r0,r4
;;;92     }
000054  e8bd8010          POP      {r4,pc}
;;;93     
                          ENDP

                  nuc970_layout_oob_table PROC
;;;94     static void nuc970_layout_oob_table ( struct nand_ecclayout* pNandOOBTbl, int oobsize , int eccbytes )
000058  e5802000          STR      r2,[r0,#0]
;;;95     {
;;;96         pNandOOBTbl->eccbytes = eccbytes;
;;;97     
;;;98         pNandOOBTbl->oobavail = oobsize - 4 - eccbytes ;
00005c  e2413004          SUB      r3,r1,#4
000060  e0433002          SUB      r3,r3,r2
000064  e5803204          STR      r3,[r0,#0x204]
;;;99     
;;;100        pNandOOBTbl->oobfree[0].offset = 4;  // Bad block marker size
000068  e3a03004          MOV      r3,#4
00006c  e5803208          STR      r3,[r0,#0x208]
;;;101    
;;;102        pNandOOBTbl->oobfree[0].length = oobsize - eccbytes - pNandOOBTbl->oobfree[0].offset ;
000070  e0413002          SUB      r3,r1,r2
000074  e590c208          LDR      r12,[r0,#0x208]
000078  e043300c          SUB      r3,r3,r12
00007c  e580320c          STR      r3,[r0,#0x20c]
;;;103    }
000080  e12fff1e          BX       lr
;;;104    
                          ENDP

                  nuc970_hwcontrol PROC
;;;105    
;;;106    static void nuc970_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
000084  e92d4010          PUSH     {r4,lr}
;;;107    {
;;;108        struct nand_chip *chip = mtd->priv;
000088  e5903094          LDR      r3,[r0,#0x94]
;;;109    
;;;110        if (ctrl & NAND_CTRL_CHANGE) {
00008c  e3120080          TST      r2,#0x80
000090  0a000008          BEQ      |L1.184|
;;;111            ulong IO_ADDR_W = (ulong)REG_NANDDATA;
000094  e59fcef0          LDR      r12,|L1.3980|
;;;112    
;;;113            if ((ctrl & NAND_CLE))
000098  e3120002          TST      r2,#2
00009c  0a000000          BEQ      |L1.164|
;;;114                IO_ADDR_W = REG_NANDCMD;
0000a0  e24cc008          SUB      r12,r12,#8
                  |L1.164|
;;;115            if ((ctrl & NAND_ALE))
0000a4  e3120004          TST      r2,#4
0000a8  0a000000          BEQ      |L1.176|
;;;116                IO_ADDR_W = REG_NANDADDR;
0000ac  e59fcedc          LDR      r12,|L1.3984|
                  |L1.176|
;;;117    
;;;118            chip->IO_ADDR_W = (void *)IO_ADDR_W;
0000b0  e583c004          STR      r12,[r3,#4]
;;;119        }
0000b4  e1a00000          MOV      r0,r0
                  |L1.184|
;;;120    
;;;121        if (cmd != NAND_CMD_NONE)
0000b8  e3710001          CMN      r1,#1
0000bc  0a000001          BEQ      |L1.200|
;;;122            outpb(chip->IO_ADDR_W, cmd);
0000c0  e5934004          LDR      r4,[r3,#4]
0000c4  e5c41000          STRB     r1,[r4,#0]
                  |L1.200|
;;;123    }
0000c8  e8bd8010          POP      {r4,pc}
;;;124    
                          ENDP

                  nuc970_nand_select_chip PROC
;;;126    /* select chip */
;;;127    static void nuc970_nand_select_chip(struct mtd_info *mtd, int chip)
0000cc  e59f2ec0          LDR      r2,|L1.3988|
;;;128    {
;;;129        outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
0000d0  e5922000          LDR      r2,[r2,#0]
0000d4  e3c22406          BIC      r2,r2,#0x6000000
0000d8  e3822301          ORR      r2,r2,#0x4000000
0000dc  e59f3eb0          LDR      r3,|L1.3988|
0000e0  e5832000          STR      r2,[r3,#0]
;;;130    }
0000e4  e12fff1e          BX       lr
;;;131    
                          ENDP

                  nuc970_dev_ready PROC
;;;132    
;;;133    static int nuc970_dev_ready(struct mtd_info *mtd)
0000e8  e1a01000          MOV      r1,r0
;;;134    {
;;;135        return ((inpw(REG_NANDINTSTS) & READYBUSY) ? 1 : 0);
0000ec  e59f0ea4          LDR      r0,|L1.3992|
0000f0  e5900000          LDR      r0,[r0,#0]
0000f4  e2000701          AND      r0,r0,#0x40000
0000f8  e1a00920          LSR      r0,r0,#18
;;;136    }
0000fc  e12fff1e          BX       lr
;;;137    
                          ENDP

                  nuc970_nand_command PROC
;;;138    
;;;139    static void nuc970_nand_command(struct mtd_info *mtd, unsigned int command, int column, int page_addr)
000100  e92d40f8          PUSH     {r3-r7,lr}
;;;140    {
000104  e1a0c000          MOV      r12,r0
;;;141        register struct nand_chip *chip = mtd->priv;
000108  e59c0094          LDR      r0,[r12,#0x94]
;;;142        int volatile i;
;;;143    
;;;144        if (command == NAND_CMD_READOOB) {
00010c  e3510050          CMP      r1,#0x50
000110  1a000002          BNE      |L1.288|
;;;145            column += mtd->writesize;
000114  e59c4014          LDR      r4,[r12,#0x14]
000118  e0822004          ADD      r2,r2,r4
;;;146            command = NAND_CMD_READ0;
00011c  e3a01000          MOV      r1,#0
                  |L1.288|
;;;147        }
;;;148    
;;;149        outpw(REG_NANDCMD, command & 0xff);
000120  e20140ff          AND      r4,r1,#0xff
000124  e59f5e70          LDR      r5,|L1.3996|
000128  e5854000          STR      r4,[r5,#0]
;;;150    
;;;151        if (column != -1 || page_addr != -1) {
00012c  e3720001          CMN      r2,#1
000130  1a000001          BNE      |L1.316|
000134  e3730001          CMN      r3,#1
000138  0a000024          BEQ      |L1.464|
                  |L1.316|
;;;152            if (column != -1) {
00013c  e3720001          CMN      r2,#1
000140  0a00000b          BEQ      |L1.372|
;;;153                outpw(REG_NANDADDR, column&0xff);
000144  e20240ff          AND      r4,r2,#0xff
000148  e59f5e40          LDR      r5,|L1.3984|
00014c  e5854000          STR      r4,[r5,#0]
;;;154                if ( page_addr != -1 )
000150  e3730001          CMN      r3,#1
000154  0a000002          BEQ      |L1.356|
;;;155                    outpw(REG_NANDADDR, column >> 8);
000158  e1a04442          ASR      r4,r2,#8
00015c  e5854000          STR      r4,[r5,#0]
000160  ea000003          B        |L1.372|
                  |L1.356|
;;;156                else
;;;157                    outpw(REG_NANDADDR, (column >> 8) | ENDADDR);
000164  e3a04102          MOV      r4,#0x80000000
000168  e1844442          ORR      r4,r4,r2,ASR #8
00016c  e59f5e1c          LDR      r5,|L1.3984|
000170  e5854000          STR      r4,[r5,#0]
                  |L1.372|
;;;158            }
;;;159    
;;;160            if (page_addr != -1) {
000174  e3730001          CMN      r3,#1
000178  0a000014          BEQ      |L1.464|
;;;161                outpw(REG_NANDADDR, page_addr&0xFF);
00017c  e20340ff          AND      r4,r3,#0xff
000180  e59f5e08          LDR      r5,|L1.3984|
000184  e5854000          STR      r4,[r5,#0]
;;;162    
;;;163                if ( chip->chipsize > (128 << 20) ) {
000188  e1c046d8          LDRD     r4,r5,[r0,#0x68]
00018c  e2744302          RSBS     r4,r4,#0x8000000
000190  e2f54000          RSCS     r4,r5,#0
000194  2a000008          BCS      |L1.444|
;;;164                    outpw(REG_NANDADDR, (page_addr >> 8)&0xFF);
000198  e1a04803          LSL      r4,r3,#16
00019c  e1a04c24          LSR      r4,r4,#24
0001a0  e59f5de8          LDR      r5,|L1.3984|
0001a4  e5854000          STR      r4,[r5,#0]
;;;165                    outpw(REG_NANDADDR, ((page_addr >> 16)&0xFF)|ENDADDR);
0001a8  e1a04403          LSL      r4,r3,#8
0001ac  e1a04c24          LSR      r4,r4,#24
0001b0  e3844102          ORR      r4,r4,#0x80000000
0001b4  e5854000          STR      r4,[r5,#0]
0001b8  ea000004          B        |L1.464|
                  |L1.444|
;;;166                } else {
;;;167                    outpw(REG_NANDADDR, ((page_addr >> 8)&0xFF)|ENDADDR);
0001bc  e1a04803          LSL      r4,r3,#16
0001c0  e1a04c24          LSR      r4,r4,#24
0001c4  e3844102          ORR      r4,r4,#0x80000000
0001c8  e59f5dc0          LDR      r5,|L1.3984|
0001cc  e5854000          STR      r4,[r5,#0]
                  |L1.464|
;;;168                }
;;;169            }
;;;170        }
;;;171    
;;;172        switch (command) {
0001d0  e3510070          CMP      r1,#0x70
0001d4  0a00001d          BEQ      |L1.592|
0001d8  ca00000c          BGT      |L1.528|
0001dc  e3510010          CMP      r1,#0x10
0001e0  0a000015          BEQ      |L1.572|
0001e4  ca000004          BGT      |L1.508|
0001e8  e3510000          CMP      r1,#0
0001ec  0a000043          BEQ      |L1.768|
0001f0  e3510005          CMP      r1,#5
0001f4  1a000046          BNE      |L1.788|
0001f8  ea000032          B        |L1.712|
                  |L1.508|
0001fc  e3510015          CMP      r1,#0x15
000200  0a00000b          BEQ      |L1.564|
000204  e3510060          CMP      r1,#0x60
000208  1a000041          BNE      |L1.788|
00020c  ea00000b          B        |L1.576|
                  |L1.528|
000210  e3510080          CMP      r1,#0x80
000214  0a00000b          BEQ      |L1.584|
000218  e3510085          CMP      r1,#0x85
00021c  0a00000a          BEQ      |L1.588|
000220  e35100d0          CMP      r1,#0xd0
000224  0a000006          BEQ      |L1.580|
000228  e35100ff          CMP      r1,#0xff
00022c  1a000038          BNE      |L1.788|
000230  ea000007          B        |L1.596|
                  |L1.564|
;;;173        case NAND_CMD_CACHEDPROG:
000234  e1a00000          MOV      r0,r0
;;;174        case NAND_CMD_PAGEPROG:
000238  e1a00000          MOV      r0,r0
                  |L1.572|
;;;175        case NAND_CMD_ERASE1:
00023c  e1a00000          MOV      r0,r0
                  |L1.576|
;;;176        case NAND_CMD_ERASE2:
000240  e1a00000          MOV      r0,r0
                  |L1.580|
;;;177        case NAND_CMD_SEQIN:
000244  e1a00000          MOV      r0,r0
                  |L1.584|
;;;178        case NAND_CMD_RNDIN:
000248  e1a00000          MOV      r0,r0
                  |L1.588|
;;;179        case NAND_CMD_STATUS:
00024c  e1a00000          MOV      r0,r0
                  |L1.592|
;;;180            return;
;;;181    
;;;182        case NAND_CMD_RESET:
;;;183            if (chip->dev_ready)
;;;184                break;
;;;185    
;;;186            if ( chip->chip_delay )
;;;187                for (i=0; i<chip->chip_delay; i++);
;;;188    
;;;189            outpw(REG_NANDCMD, NAND_CMD_STATUS);
;;;190            outpw(REG_NANDCMD, command);
;;;191    
;;;192            while (!(inpw(REG_NANDINTSTS) & READYBUSY));
;;;193            return;
;;;194    
;;;195        case NAND_CMD_RNDOUT:
;;;196            outpw(REG_NANDCMD, NAND_CMD_RNDOUTSTART);
;;;197            for (i=0; i<10; i++);
;;;198            return;
;;;199    
;;;200        case NAND_CMD_READ0:
;;;201            outpw(REG_NANDCMD, NAND_CMD_READSTART);
;;;202            break;
;;;203        default:
;;;204            if (!chip->dev_ready) {
;;;205                if ( chip->chip_delay )
;;;206                    for (i=0; i<chip->chip_delay; i++);
;;;207                return;
;;;208            }
;;;209        }
;;;210    
;;;211        while (!(inpw(REG_NANDINTSTS) & READYBUSY)) ;
;;;212    
;;;213    }
000250  e8bd80f8          POP      {r3-r7,pc}
                  |L1.596|
000254  e1a00000          MOV      r0,r0                 ;182
000258  e5904030          LDR      r4,[r0,#0x30]         ;183
00025c  e3540000          CMP      r4,#0                 ;183
000260  0a000000          BEQ      |L1.616|
000264  ea00003d          B        |L1.864|
                  |L1.616|
000268  e590404c          LDR      r4,[r0,#0x4c]         ;186
00026c  e3540000          CMP      r4,#0                 ;186
000270  0a000009          BEQ      |L1.668|
000274  e3a04000          MOV      r4,#0                 ;187
000278  e58d4000          STR      r4,[sp,#0]            ;187
00027c  ea000002          B        |L1.652|
                  |L1.640|
000280  e59d4000          LDR      r4,[sp,#0]            ;187
000284  e2844001          ADD      r4,r4,#1              ;187
000288  e58d4000          STR      r4,[sp,#0]            ;187
                  |L1.652|
00028c  e590404c          LDR      r4,[r0,#0x4c]         ;187
000290  e59d5000          LDR      r5,[sp,#0]            ;187
000294  e1540005          CMP      r4,r5                 ;187
000298  cafffff8          BGT      |L1.640|
                  |L1.668|
00029c  e3a04070          MOV      r4,#0x70              ;189
0002a0  e59f5cf4          LDR      r5,|L1.3996|
0002a4  e5854000          STR      r4,[r5,#0]            ;189
0002a8  e1c541c4          BIC      r4,r5,r4,ASR #3       ;190
0002ac  e5841000          STR      r1,[r4,#0]            ;190
0002b0  e1a00000          MOV      r0,r0                 ;192
                  |L1.692|
0002b4  e59f4cdc          LDR      r4,|L1.3992|
0002b8  e5944000          LDR      r4,[r4,#0]            ;192
0002bc  e3140701          TST      r4,#0x40000           ;192
0002c0  0afffffb          BEQ      |L1.692|
0002c4  eaffffe1          B        |L1.592|
                  |L1.712|
0002c8  e1a00000          MOV      r0,r0                 ;195
0002cc  e3a040e0          MOV      r4,#0xe0              ;196
0002d0  e59f5cc4          LDR      r5,|L1.3996|
0002d4  e5854000          STR      r4,[r5,#0]            ;196
0002d8  e3a04000          MOV      r4,#0                 ;197
0002dc  e58d4000          STR      r4,[sp,#0]            ;197
0002e0  ea000002          B        |L1.752|
                  |L1.740|
0002e4  e59d4000          LDR      r4,[sp,#0]            ;197
0002e8  e2844001          ADD      r4,r4,#1              ;197
0002ec  e58d4000          STR      r4,[sp,#0]            ;197
                  |L1.752|
0002f0  e59d4000          LDR      r4,[sp,#0]            ;197
0002f4  e354000a          CMP      r4,#0xa               ;197
0002f8  bafffff9          BLT      |L1.740|
0002fc  eaffffd3          B        |L1.592|
                  |L1.768|
000300  e1a00000          MOV      r0,r0                 ;200
000304  e3a04030          MOV      r4,#0x30              ;201
000308  e59f5c8c          LDR      r5,|L1.3996|
00030c  e5854000          STR      r4,[r5,#0]            ;201
000310  ea000012          B        |L1.864|
                  |L1.788|
000314  e1a00000          MOV      r0,r0                 ;203
000318  e5904030          LDR      r4,[r0,#0x30]         ;204
00031c  e3540000          CMP      r4,#0                 ;204
000320  1a00000d          BNE      |L1.860|
000324  e590404c          LDR      r4,[r0,#0x4c]         ;205
000328  e3540000          CMP      r4,#0                 ;205
00032c  0a000009          BEQ      |L1.856|
000330  e3a04000          MOV      r4,#0                 ;206
000334  e58d4000          STR      r4,[sp,#0]            ;206
000338  ea000002          B        |L1.840|
                  |L1.828|
00033c  e59d4000          LDR      r4,[sp,#0]            ;206
000340  e2844001          ADD      r4,r4,#1              ;206
000344  e58d4000          STR      r4,[sp,#0]            ;206
                  |L1.840|
000348  e590404c          LDR      r4,[r0,#0x4c]         ;206
00034c  e59d5000          LDR      r5,[sp,#0]            ;206
000350  e1540005          CMP      r4,r5                 ;206
000354  cafffff8          BGT      |L1.828|
                  |L1.856|
000358  eaffffbc          B        |L1.592|
                  |L1.860|
00035c  e1a00000          MOV      r0,r0                 ;172
                  |L1.864|
000360  e1a00000          MOV      r0,r0                 ;184
000364  e1a00000          MOV      r0,r0                 ;211
                  |L1.872|
000368  e59f4c28          LDR      r4,|L1.3992|
00036c  e5944000          LDR      r4,[r4,#0]            ;211
000370  e3140701          TST      r4,#0x40000           ;211
000374  0afffffb          BEQ      |L1.872|
000378  e1a00000          MOV      r0,r0
00037c  eaffffb3          B        |L1.592|
;;;214    
                          ENDP

                  nuc970_nand_read_byte PROC
;;;218     */
;;;219    static unsigned char nuc970_nand_read_byte(struct mtd_info *mtd)
000380  e1a01000          MOV      r1,r0
;;;220    {
;;;221        return ((unsigned char)inpw(REG_NANDDATA));
000384  e59f0c00          LDR      r0,|L1.3980|
000388  e5900000          LDR      r0,[r0,#0]
00038c  e20000ff          AND      r0,r0,#0xff
;;;222    }
000390  e12fff1e          BX       lr
;;;223    
                          ENDP

                  nuc970_nand_write_buf PROC
;;;230    
;;;231    static void nuc970_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
000394  e92d4010          PUSH     {r4,lr}
;;;232    {
000398  e1a03000          MOV      r3,r0
;;;233        int i;
;;;234    
;;;235        for (i = 0; i < len; i++)
00039c  e3a00000          MOV      r0,#0
0003a0  ea000003          B        |L1.948|
                  |L1.932|
;;;236            outpw(REG_NANDDATA, buf[i]);
0003a4  e7d1c000          LDRB     r12,[r1,r0]
0003a8  e59f4bdc          LDR      r4,|L1.3980|
0003ac  e584c000          STR      r12,[r4,#0]
0003b0  e2800001          ADD      r0,r0,#1              ;235
                  |L1.948|
0003b4  e1500002          CMP      r0,r2                 ;235
0003b8  bafffff9          BLT      |L1.932|
;;;237    }
0003bc  e8bd8010          POP      {r4,pc}
;;;238    
                          ENDP

                  nuc970_nand_read_buf PROC
;;;244     */
;;;245    static void nuc970_nand_read_buf(struct mtd_info *mtd, unsigned char *buf, int len)
0003c0  e1a03000          MOV      r3,r0
;;;246    {
;;;247        int i;
;;;248    
;;;249        for (i = 0; i < len; i++)
0003c4  e3a00000          MOV      r0,#0
0003c8  ea000003          B        |L1.988|
                  |L1.972|
;;;250            buf[i] = (unsigned char)inpw(REG_NANDDATA);
0003cc  e59fcbb8          LDR      r12,|L1.3980|
0003d0  e59cc000          LDR      r12,[r12,#0]
0003d4  e7c1c000          STRB     r12,[r1,r0]
0003d8  e2800001          ADD      r0,r0,#1              ;249
                  |L1.988|
0003dc  e1500002          CMP      r0,r2                 ;249
0003e0  bafffff9          BLT      |L1.972|
;;;251    }
0003e4  e12fff1e          BX       lr
;;;252    
                          ENDP

                  nuc970_nand_enable_hwecc PROC
;;;256     */
;;;257    void nuc970_nand_enable_hwecc(struct mtd_info *mtd, int mode)
0003e8  e12fff1e          BX       lr
;;;258    {
;;;259    }
;;;260    
                          ENDP

                  nuc970_nand_calculate_ecc PROC
;;;267     */
;;;268    static int nuc970_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
0003ec  e1a03000          MOV      r3,r0
;;;269    {
;;;270        return 0;
0003f0  e3a00000          MOV      r0,#0
;;;271    }
0003f4  e12fff1e          BX       lr
;;;272    
                          ENDP

                  nuc970_nand_correct_data PROC
;;;280     */
;;;281    static int nuc970_nand_correct_data(struct mtd_info *mtd, u_char *dat,
0003f8  e1a0c000          MOV      r12,r0
;;;282                         u_char *read_ecc, u_char *calc_ecc)
;;;283    {
;;;284        return 0;
0003fc  e3a00000          MOV      r0,#0
;;;285    }
000400  e12fff1e          BX       lr
;;;286    
                          ENDP

                  fmiSM_CorrectData_BCH PROC
;;;291     *---------------------------------------------------------------------------*/
;;;292    void fmiSM_CorrectData_BCH(u8 ucFieidIndex, u8 ucErrorCnt, u8* pDAddr)
000404  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;293    {
000408  e24dd0d8          SUB      sp,sp,#0xd8
00040c  e1a0b000          MOV      r11,r0
000410  e1a07001          MOV      r7,r1
;;;294        u32 uaData[24], uaAddr[24];
;;;295        u32 uaErrorData[4];
;;;296        u8  ii, jj;
;;;297        u32 uPageSize;
;;;298        u32 field_len, padding_len, parity_len;
;;;299        u32 total_field_num;
;;;300        u8  *smra_index;
;;;301    
;;;302        //--- assign some parameters for different BCH and page size
;;;303        switch (inpw(REG_NANDCTL) & 0x007C0000)
000414  e59f0b78          LDR      r0,|L1.3988|
000418  e5900000          LDR      r0,[r0,#0]
00041c  e200071f          AND      r0,r0,#0x7c0000
000420  e3500601          CMP      r0,#0x100000
000424  0a000019          BEQ      |L1.1168|
000428  ca000004          BGT      |L1.1088|
00042c  e3500701          CMP      r0,#0x40000
000430  0a000007          BEQ      |L1.1108|
000434  e3500702          CMP      r0,#0x80000
000438  1a00001e          BNE      |L1.1208|
00043c  ea000018          B        |L1.1188|
                  |L1.1088|
000440  e3500602          CMP      r0,#0x200000
000444  0a00000c          BEQ      |L1.1148|
000448  e3500501          CMP      r0,#0x400000
00044c  1a000019          BNE      |L1.1208|
000450  ea000004          B        |L1.1128|
                  |L1.1108|
;;;304        {
;;;305            case BCH_T24:
000454  e1a00000          MOV      r0,r0
;;;306                field_len   = 1024;
000458  e3a05b01          MOV      r5,#0x400
;;;307                padding_len = BCH_PADDING_LEN_1024;
00045c  e3a09040          MOV      r9,#0x40
;;;308                parity_len  = BCH_PARITY_LEN_T24;
000460  e3a0602d          MOV      r6,#0x2d
;;;309                break;
000464  ea000016          B        |L1.1220|
                  |L1.1128|
;;;310            case BCH_T15:
000468  e1a00000          MOV      r0,r0
;;;311                field_len   = 512;
00046c  e3a05c02          MOV      r5,#0x200
;;;312                padding_len = BCH_PADDING_LEN_512;
000470  e3a09020          MOV      r9,#0x20
;;;313                parity_len  = BCH_PARITY_LEN_T15;
000474  e3a0601d          MOV      r6,#0x1d
;;;314                break;
000478  ea000011          B        |L1.1220|
                  |L1.1148|
;;;315            case BCH_T12:
00047c  e1a00000          MOV      r0,r0
;;;316                field_len   = 512;
000480  e3a05c02          MOV      r5,#0x200
;;;317                padding_len = BCH_PADDING_LEN_512;
000484  e3a09020          MOV      r9,#0x20
;;;318                parity_len  = BCH_PARITY_LEN_T12;
000488  e3a06017          MOV      r6,#0x17
;;;319                break;
00048c  ea00000c          B        |L1.1220|
                  |L1.1168|
;;;320            case BCH_T8:
000490  e1a00000          MOV      r0,r0
;;;321                field_len   = 512;
000494  e3a05c02          MOV      r5,#0x200
;;;322                padding_len = BCH_PADDING_LEN_512;
000498  e3a09020          MOV      r9,#0x20
;;;323                parity_len  = BCH_PARITY_LEN_T8;
00049c  e3a0600f          MOV      r6,#0xf
;;;324                break;
0004a0  ea000007          B        |L1.1220|
                  |L1.1188|
;;;325            case BCH_T4:
0004a4  e1a00000          MOV      r0,r0
;;;326                field_len   = 512;
0004a8  e3a05c02          MOV      r5,#0x200
;;;327                padding_len = BCH_PADDING_LEN_512;
0004ac  e3a09020          MOV      r9,#0x20
;;;328                parity_len  = BCH_PARITY_LEN_T4;
0004b0  e3a06008          MOV      r6,#8
;;;329                break;
0004b4  ea000002          B        |L1.1220|
                  |L1.1208|
;;;330            default:
0004b8  e1a00000          MOV      r0,r0
                  |L1.1212|
;;;331                return;
;;;332        }
;;;333    
;;;334        uPageSize = inpw(REG_NANDCTL) & 0x00030000;
;;;335        switch (uPageSize)
;;;336        {
;;;337            case 0x30000: total_field_num = 8192 / field_len; break;
;;;338            case 0x20000: total_field_num = 4096 / field_len; break;
;;;339            case 0x10000: total_field_num = 2048 / field_len; break;
;;;340            case 0x00000: total_field_num =  512 / field_len; break;
;;;341            default:
;;;342                return;
;;;343        }
;;;344    
;;;345        //--- got valid BCH_ECC_DATAx and parse them to uaData[]
;;;346        // got the valid register number of BCH_ECC_DATAx since one register include 4 error bytes
;;;347        jj = ucErrorCnt/4;
;;;348        jj ++;
;;;349        if (jj > 6)
;;;350            jj = 6;     // there are 6 BCH_ECC_DATAx registers to support BCH T24
;;;351    
;;;352        for(ii=0; ii<jj; ii++)
;;;353        {
;;;354            uaErrorData[ii] = inpw(REG_NANDECCED0 + ii*4);
;;;355        }
;;;356    
;;;357        for(ii=0; ii<jj; ii++)
;;;358        {
;;;359            uaData[ii*4+0] = uaErrorData[ii] & 0xff;
;;;360            uaData[ii*4+1] = (uaErrorData[ii]>>8) & 0xff;
;;;361            uaData[ii*4+2] = (uaErrorData[ii]>>16) & 0xff;
;;;362            uaData[ii*4+3] = (uaErrorData[ii]>>24) & 0xff;
;;;363        }
;;;364    
;;;365        //--- got valid REG_BCH_ECC_ADDRx and parse them to uaAddr[]
;;;366        // got the valid register number of REG_BCH_ECC_ADDRx since one register include 2 error addresses
;;;367        jj = ucErrorCnt/2;
;;;368        jj ++;
;;;369        if (jj > 12)
;;;370            jj = 12;    // there are 12 REG_BCH_ECC_ADDRx registers to support BCH T24
;;;371    
;;;372        for(ii=0; ii<jj; ii++)
;;;373        {
;;;374            uaAddr[ii*2+0] = inpw(REG_NANDECCEA0 + ii*4) & 0x07ff;   // 11 bits for error address
;;;375            uaAddr[ii*2+1] = (inpw(REG_NANDECCEA0 + ii*4)>>16) & 0x07ff;
;;;376        }
;;;377    
;;;378        //--- pointer to begin address of field that with data error
;;;379        pDAddr += (ucFieidIndex-1) * field_len;
;;;380    
;;;381        //--- correct each error bytes
;;;382        for(ii=0; ii<ucErrorCnt; ii++)
;;;383        {
;;;384            // for wrong data in field
;;;385            if (uaAddr[ii] < field_len)
;;;386            {
;;;387                *(pDAddr+uaAddr[ii]) ^= uaData[ii];
;;;388            }
;;;389            // for wrong first-3-bytes in redundancy area
;;;390            else if (uaAddr[ii] < (field_len+3))
;;;391            {
;;;392                uaAddr[ii] -= field_len;
;;;393                uaAddr[ii] += (parity_len*(ucFieidIndex-1));    // field offset
;;;394                *((u8 *)REG_NANDRA0 + uaAddr[ii]) ^= uaData[ii];
;;;395            }
;;;396            // for wrong parity code in redundancy area
;;;397            else
;;;398            {
;;;399                // BCH_ERR_ADDRx = [data in field] + [3 bytes] + [xx] + [parity code]
;;;400                //                                   |<--     padding bytes      -->|
;;;401                // The BCH_ERR_ADDRx for last parity code always = field size + padding size.
;;;402                // So, the first parity code = field size + padding size - parity code length.
;;;403                // For example, for BCH T12, the first parity code = 512 + 32 - 23 = 521.
;;;404                // That is, error byte address offset within field is
;;;405                uaAddr[ii] = uaAddr[ii] - (field_len + padding_len - parity_len);
;;;406    
;;;407                // smra_index point to the first parity code of first field in register SMRA0~n
;;;408                smra_index = (u8 *)
;;;409                             (REG_NANDRA0 + (inpw(REG_NANDRACTL) & 0x1ff) - // bottom of all parity code -
;;;410                              (parity_len * total_field_num)                             // byte count of all parity code
;;;411                             );
;;;412    
;;;413                // final address = first parity code of first field +
;;;414                //                 offset of fields +
;;;415                //                 offset within field
;;;416                *((u8 *)smra_index + (parity_len * (ucFieidIndex-1)) + uaAddr[ii]) ^= uaData[ii];
;;;417            }
;;;418        }   // end of for (ii<ucErrorCnt)
;;;419    }
0004bc  e28dd0e4          ADD      sp,sp,#0xe4
0004c0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1220|
0004c4  e1a00000          MOV      r0,r0                 ;309
0004c8  e59f0ac4          LDR      r0,|L1.3988|
0004cc  e5900000          LDR      r0,[r0,#0]            ;334
0004d0  e2000803          AND      r0,r0,#0x30000        ;334
0004d4  e58d0004          STR      r0,[sp,#4]            ;334
0004d8  e59d0004          LDR      r0,[sp,#4]            ;335
0004dc  e3500000          CMP      r0,#0                 ;335
0004e0  0a000016          BEQ      |L1.1344|
0004e4  e3500801          CMP      r0,#0x10000           ;335
0004e8  0a00000e          BEQ      |L1.1320|
0004ec  e3500802          CMP      r0,#0x20000           ;335
0004f0  0a000006          BEQ      |L1.1296|
0004f4  e3500803          CMP      r0,#0x30000           ;335
0004f8  1a000016          BNE      |L1.1368|
0004fc  e1a01005          MOV      r1,r5                 ;337
000500  e3a00a02          MOV      r0,#0x2000            ;337
000504  ebfffffe          BL       __aeabi_uidivmod
000508  e1a0a000          MOV      r10,r0                ;337
00050c  ea000013          B        |L1.1376|
                  |L1.1296|
000510  e1a00000          MOV      r0,r0                 ;338
000514  e1a01005          MOV      r1,r5                 ;338
000518  e3a00a01          MOV      r0,#0x1000            ;338
00051c  ebfffffe          BL       __aeabi_uidivmod
000520  e1a0a000          MOV      r10,r0                ;338
000524  ea00000d          B        |L1.1376|
                  |L1.1320|
000528  e1a00000          MOV      r0,r0                 ;339
00052c  e1a01005          MOV      r1,r5                 ;339
000530  e3a00b02          MOV      r0,#0x800             ;339
000534  ebfffffe          BL       __aeabi_uidivmod
000538  e1a0a000          MOV      r10,r0                ;339
00053c  ea000007          B        |L1.1376|
                  |L1.1344|
000540  e1a00000          MOV      r0,r0                 ;340
000544  e1a01005          MOV      r1,r5                 ;340
000548  e3a00c02          MOV      r0,#0x200             ;340
00054c  ebfffffe          BL       __aeabi_uidivmod
000550  e1a0a000          MOV      r10,r0                ;340
000554  ea000001          B        |L1.1376|
                  |L1.1368|
000558  e1a00000          MOV      r0,r0                 ;341
00055c  eaffffd6          B        |L1.1212|
                  |L1.1376|
000560  e1a00000          MOV      r0,r0                 ;337
000564  e1a00007          MOV      r0,r7                 ;347
000568  e1a01fc7          ASR      r1,r7,#31             ;347
00056c  e0871f21          ADD      r1,r7,r1,LSR #30      ;347
000570  e1a01b01          LSL      r1,r1,#22             ;347
000574  e1a08c21          LSR      r8,r1,#24             ;347
000578  e2880001          ADD      r0,r8,#1              ;348
00057c  e20080ff          AND      r8,r0,#0xff           ;348
000580  e3580006          CMP      r8,#6                 ;349
000584  da000000          BLE      |L1.1420|
000588  e3a08006          MOV      r8,#6                 ;350
                  |L1.1420|
00058c  e3a04000          MOV      r4,#0                 ;352
000590  ea000005          B        |L1.1452|
                  |L1.1428|
000594  e59f0a04          LDR      r0,|L1.4000|
000598  e7900104          LDR      r0,[r0,r4,LSL #2]     ;354
00059c  e28d1008          ADD      r1,sp,#8              ;354
0005a0  e7810104          STR      r0,[r1,r4,LSL #2]     ;354
0005a4  e2840001          ADD      r0,r4,#1              ;352
0005a8  e20040ff          AND      r4,r0,#0xff           ;352
                  |L1.1452|
0005ac  e1540008          CMP      r4,r8                 ;352
0005b0  bafffff7          BLT      |L1.1428|
0005b4  e3a04000          MOV      r4,#0                 ;357
0005b8  ea00001e          B        |L1.1592|
                  |L1.1468|
0005bc  e28d0008          ADD      r0,sp,#8              ;359
0005c0  e7d00104          LDRB     r0,[r0,r4,LSL #2]     ;359
0005c4  e3a01000          MOV      r1,#0                 ;359
0005c8  e0811104          ADD      r1,r1,r4,LSL #2       ;359
0005cc  e28d2078          ADD      r2,sp,#0x78           ;359
0005d0  e7820101          STR      r0,[r2,r1,LSL #2]     ;359
0005d4  e28d0008          ADD      r0,sp,#8              ;360
0005d8  e7900104          LDR      r0,[r0,r4,LSL #2]     ;360
0005dc  e1a00800          LSL      r0,r0,#16             ;360
0005e0  e1a00c20          LSR      r0,r0,#24             ;360
0005e4  e3a01001          MOV      r1,#1                 ;360
0005e8  e0811104          ADD      r1,r1,r4,LSL #2       ;360
0005ec  e28d2078          ADD      r2,sp,#0x78           ;360
0005f0  e7820101          STR      r0,[r2,r1,LSL #2]     ;360
0005f4  e28d0008          ADD      r0,sp,#8              ;361
0005f8  e7900104          LDR      r0,[r0,r4,LSL #2]     ;361
0005fc  e1a00400          LSL      r0,r0,#8              ;361
000600  e1a00c20          LSR      r0,r0,#24             ;361
000604  e3a01002          MOV      r1,#2                 ;361
000608  e0811104          ADD      r1,r1,r4,LSL #2       ;361
00060c  e28d2078          ADD      r2,sp,#0x78           ;361
000610  e7820101          STR      r0,[r2,r1,LSL #2]     ;361
000614  e28d0008          ADD      r0,sp,#8              ;362
000618  e7900104          LDR      r0,[r0,r4,LSL #2]     ;362
00061c  e1a00c20          LSR      r0,r0,#24             ;362
000620  e3a01003          MOV      r1,#3                 ;362
000624  e0811104          ADD      r1,r1,r4,LSL #2       ;362
000628  e28d2078          ADD      r2,sp,#0x78           ;362
00062c  e7820101          STR      r0,[r2,r1,LSL #2]     ;362
000630  e2840001          ADD      r0,r4,#1              ;357
000634  e20040ff          AND      r4,r0,#0xff           ;357
                  |L1.1592|
000638  e1540008          CMP      r4,r8                 ;357
00063c  baffffde          BLT      |L1.1468|
000640  e1a00007          MOV      r0,r7                 ;367
000644  e0871fa0          ADD      r1,r7,r0,LSR #31      ;367
000648  e1a01b81          LSL      r1,r1,#23             ;367
00064c  e1a08c21          LSR      r8,r1,#24             ;367
000650  e2880001          ADD      r0,r8,#1              ;368
000654  e20080ff          AND      r8,r0,#0xff           ;368
000658  e358000c          CMP      r8,#0xc               ;369
00065c  da000000          BLE      |L1.1636|
000660  e3a0800c          MOV      r8,#0xc               ;370
                  |L1.1636|
000664  e3a04000          MOV      r4,#0                 ;372
000668  ea000011          B        |L1.1716|
                  |L1.1644|
00066c  e59f0930          LDR      r0,|L1.4004|
000670  e7900104          LDR      r0,[r0,r4,LSL #2]     ;374
000674  e1a00a80          LSL      r0,r0,#21             ;374
000678  e1a00aa0          LSR      r0,r0,#21             ;374
00067c  e3a01000          MOV      r1,#0                 ;374
000680  e0811084          ADD      r1,r1,r4,LSL #1       ;374
000684  e28d2018          ADD      r2,sp,#0x18           ;374
000688  e7820101          STR      r0,[r2,r1,LSL #2]     ;374
00068c  e59f0910          LDR      r0,|L1.4004|
000690  e7900104          LDR      r0,[r0,r4,LSL #2]     ;375
000694  e59f190c          LDR      r1,|L1.4008|
000698  e0010820          AND      r0,r1,r0,LSR #16      ;375
00069c  e3a01001          MOV      r1,#1                 ;375
0006a0  e0811084          ADD      r1,r1,r4,LSL #1       ;375
0006a4  e28d2018          ADD      r2,sp,#0x18           ;375
0006a8  e7820101          STR      r0,[r2,r1,LSL #2]     ;375
0006ac  e2840001          ADD      r0,r4,#1              ;372
0006b0  e20040ff          AND      r4,r0,#0xff           ;372
                  |L1.1716|
0006b4  e1540008          CMP      r4,r8                 ;372
0006b8  baffffeb          BLT      |L1.1644|
0006bc  e24b1001          SUB      r1,r11,#1             ;379
0006c0  e59d00e0          LDR      r0,[sp,#0xe0]         ;379
0006c4  e0200591          MLA      r0,r1,r5,r0           ;379
0006c8  e58d00e0          STR      r0,[sp,#0xe0]         ;379
0006cc  e3a04000          MOV      r4,#0                 ;382
0006d0  ea00004e          B        |L1.2064|
                  |L1.1748|
0006d4  e28d0018          ADD      r0,sp,#0x18           ;385
0006d8  e7900104          LDR      r0,[r0,r4,LSL #2]     ;385
0006dc  e1500005          CMP      r0,r5                 ;385
0006e0  2a00000c          BCS      |L1.1816|
0006e4  e28d0018          ADD      r0,sp,#0x18           ;387
0006e8  e7901104          LDR      r1,[r0,r4,LSL #2]     ;387
0006ec  e59d00e0          LDR      r0,[sp,#0xe0]         ;387
0006f0  e7d00001          LDRB     r0,[r0,r1]            ;387
0006f4  e28d1078          ADD      r1,sp,#0x78           ;387
0006f8  e7d11104          LDRB     r1,[r1,r4,LSL #2]     ;387
0006fc  e0200001          EOR      r0,r0,r1              ;387
000700  e20010ff          AND      r1,r0,#0xff           ;387
000704  e28d0018          ADD      r0,sp,#0x18           ;387
000708  e7902104          LDR      r2,[r0,r4,LSL #2]     ;387
00070c  e59d00e0          LDR      r0,[sp,#0xe0]         ;387
000710  e7c01002          STRB     r1,[r0,r2]            ;387
000714  ea00003b          B        |L1.2056|
                  |L1.1816|
000718  e28d0018          ADD      r0,sp,#0x18           ;390
00071c  e7900104          LDR      r0,[r0,r4,LSL #2]     ;390
000720  e2851003          ADD      r1,r5,#3              ;390
000724  e1500001          CMP      r0,r1                 ;390
000728  2a000016          BCS      |L1.1928|
00072c  e28d0018          ADD      r0,sp,#0x18           ;392
000730  e7900104          LDR      r0,[r0,r4,LSL #2]     ;392
000734  e0400005          SUB      r0,r0,r5              ;392
000738  e28d1018          ADD      r1,sp,#0x18           ;392
00073c  e7810104          STR      r0,[r1,r4,LSL #2]     ;392
000740  e28d0018          ADD      r0,sp,#0x18           ;393
000744  e7900104          LDR      r0,[r0,r4,LSL #2]     ;393
000748  e24b1001          SUB      r1,r11,#1             ;393
00074c  e0200196          MLA      r0,r6,r1,r0           ;393
000750  e28d1018          ADD      r1,sp,#0x18           ;393
000754  e7810104          STR      r0,[r1,r4,LSL #2]     ;393
000758  e28d0018          ADD      r0,sp,#0x18           ;394
00075c  e7900104          LDR      r0,[r0,r4,LSL #2]     ;394
000760  e59f1844          LDR      r1,|L1.4012|
000764  e7d00001          LDRB     r0,[r0,r1]            ;394
000768  e28d1078          ADD      r1,sp,#0x78           ;394
00076c  e7d11104          LDRB     r1,[r1,r4,LSL #2]     ;394
000770  e0200001          EOR      r0,r0,r1              ;394
000774  e28d1018          ADD      r1,sp,#0x18           ;394
000778  e7911104          LDR      r1,[r1,r4,LSL #2]     ;394
00077c  e59f2828          LDR      r2,|L1.4012|
000780  e7c10002          STRB     r0,[r1,r2]            ;394
000784  ea00001f          B        |L1.2056|
                  |L1.1928|
000788  e28d0018          ADD      r0,sp,#0x18           ;405
00078c  e7900104          LDR      r0,[r0,r4,LSL #2]     ;405
000790  e0851009          ADD      r1,r5,r9              ;405
000794  e0411006          SUB      r1,r1,r6              ;405
000798  e0400001          SUB      r0,r0,r1              ;405
00079c  e28d1018          ADD      r1,sp,#0x18           ;405
0007a0  e7810104          STR      r0,[r1,r4,LSL #2]     ;405
0007a4  e59f0804          LDR      r0,|L1.4016|
0007a8  e5900000          LDR      r0,[r0,#0]            ;408
0007ac  e1a00b80          LSL      r0,r0,#23             ;408
0007b0  e1a00ba0          LSR      r0,r0,#23             ;408
0007b4  e59f17f0          LDR      r1,|L1.4012|
0007b8  e0800001          ADD      r0,r0,r1              ;408
0007bc  e0010a96          MUL      r1,r6,r10             ;408
0007c0  e0400001          SUB      r0,r0,r1              ;408
0007c4  e58d0000          STR      r0,[sp,#0]            ;408
0007c8  e24b1001          SUB      r1,r11,#1             ;416
0007cc  e59d0000          LDR      r0,[sp,#0]            ;416
0007d0  e0200196          MLA      r0,r6,r1,r0           ;416
0007d4  e28d1018          ADD      r1,sp,#0x18           ;416
0007d8  e7911104          LDR      r1,[r1,r4,LSL #2]     ;416
0007dc  e7d00001          LDRB     r0,[r0,r1]            ;416
0007e0  e28d1078          ADD      r1,sp,#0x78           ;416
0007e4  e7d11104          LDRB     r1,[r1,r4,LSL #2]     ;416
0007e8  e0200001          EOR      r0,r0,r1              ;416
0007ec  e20010ff          AND      r1,r0,#0xff           ;416
0007f0  e24b2001          SUB      r2,r11,#1             ;416
0007f4  e59d0000          LDR      r0,[sp,#0]            ;416
0007f8  e0200296          MLA      r0,r6,r2,r0           ;416
0007fc  e28d2018          ADD      r2,sp,#0x18           ;416
000800  e7922104          LDR      r2,[r2,r4,LSL #2]     ;416
000804  e7c01002          STRB     r1,[r0,r2]            ;416
                  |L1.2056|
000808  e2840001          ADD      r0,r4,#1              ;382
00080c  e20040ff          AND      r4,r0,#0xff           ;382
                  |L1.2064|
000810  e1540007          CMP      r4,r7                 ;382
000814  baffffae          BLT      |L1.1748|
000818  e1a00000          MOV      r0,r0
00081c  eaffff26          B        |L1.1212|
;;;420    
                          ENDP

                  fmiSMCorrectData PROC
;;;421    int fmiSMCorrectData (struct mtd_info *mtd, unsigned long uDAddr )
000820  e92d43f8          PUSH     {r3-r9,lr}
;;;422    {
000824  e1a07000          MOV      r7,r0
000828  e1a09001          MOV      r9,r1
;;;423        int uStatus, ii, jj, i32FieldNum=0;
00082c  e3a06000          MOV      r6,#0
;;;424        volatile int uErrorCnt = 0;
000830  e3a00000          MOV      r0,#0
000834  e58d0000          STR      r0,[sp,#0]
;;;425    
;;;426        if ( inpw ( REG_NANDINTSTS ) & 0x4 )
000838  e59f0758          LDR      r0,|L1.3992|
00083c  e5900000          LDR      r0,[r0,#0]
000840  e3100004          TST      r0,#4
000844  0a000036          BEQ      |L1.2340|
;;;427        {
;;;428            if ( ( inpw(REG_NANDCTL) & 0x7C0000) == BCH_T24 )
000848  e59f0744          LDR      r0,|L1.3988|
00084c  e5900000          LDR      r0,[r0,#0]
000850  e200071f          AND      r0,r0,#0x7c0000
000854  e3500701          CMP      r0,#0x40000
000858  1a000002          BNE      |L1.2152|
;;;429                i32FieldNum = mtd->writesize / 1024;    // Block=1024 for BCH
00085c  e5970014          LDR      r0,[r7,#0x14]
000860  e1a06520          LSR      r6,r0,#10
000864  ea000001          B        |L1.2160|
                  |L1.2152|
;;;430            else
;;;431                i32FieldNum = mtd->writesize / 512;
000868  e5970014          LDR      r0,[r7,#0x14]
00086c  e1a064a0          LSR      r6,r0,#9
                  |L1.2160|
;;;432    
;;;433            if ( i32FieldNum < 4 )
000870  e3560004          CMP      r6,#4
000874  aa000001          BGE      |L1.2176|
;;;434                i32FieldNum  = 1;
000878  e3a06001          MOV      r6,#1
00087c  ea000003          B        |L1.2192|
                  |L1.2176|
;;;435            else
;;;436                i32FieldNum /= 4;
000880  e1a00006          MOV      r0,r6
000884  e1a01fc6          ASR      r1,r6,#31
000888  e0861f21          ADD      r1,r6,r1,LSR #30
00088c  e1a06141          ASR      r6,r1,#2
                  |L1.2192|
;;;437    
;;;438            for ( jj=0; jj<i32FieldNum; jj++ )
000890  e3a04000          MOV      r4,#0
000894  ea000020          B        |L1.2332|
                  |L1.2200|
;;;439            {
;;;440                uStatus = inpw ( REG_NANDECCES0+jj*4 );
000898  e59f0714          LDR      r0,|L1.4020|
00089c  e7905104          LDR      r5,[r0,r4,LSL #2]
;;;441                if ( !uStatus )
0008a0  e3550000          CMP      r5,#0
0008a4  1a000000          BNE      |L1.2220|
;;;442                    continue;
0008a8  ea00001a          B        |L1.2328|
                  |L1.2220|
;;;443    
;;;444                for ( ii=1; ii<5; ii++ )
0008ac  e3a08001          MOV      r8,#1
0008b0  ea000014          B        |L1.2312|
                  |L1.2228|
;;;445                {
;;;446                    if ( !(uStatus & 0x03) ) { // No error
0008b4  e3150003          TST      r5,#3
0008b8  1a000001          BNE      |L1.2244|
;;;447    
;;;448                        uStatus >>= 8;
0008bc  e1a05445          ASR      r5,r5,#8
;;;449                        continue;
0008c0  ea00000e          B        |L1.2304|
                  |L1.2244|
;;;450    
;;;451                    } else if ( (uStatus & 0x03)==0x01 ) { // Correctable error
0008c4  e2050003          AND      r0,r5,#3
0008c8  e3500001          CMP      r0,#1
0008cc  1a000009          BNE      |L1.2296|
;;;452    
;;;453                        uErrorCnt = (uStatus >> 2) & 0x1F;
0008d0  e3a0001f          MOV      r0,#0x1f
0008d4  e0000145          AND      r0,r0,r5,ASR #2
0008d8  e58d0000          STR      r0,[sp,#0]
;;;454                        fmiSM_CorrectData_BCH(jj*4+ii, uErrorCnt, (u8 *)uDAddr);
0008dc  e59d2000          LDR      r2,[sp,#0]
0008e0  e20210ff          AND      r1,r2,#0xff
0008e4  e0882104          ADD      r2,r8,r4,LSL #2
0008e8  e20200ff          AND      r0,r2,#0xff
0008ec  e1a02009          MOV      r2,r9
0008f0  ebfffffe          BL       fmiSM_CorrectData_BCH
;;;455    
;;;456                        break;
0008f4  ea000005          B        |L1.2320|
                  |L1.2296|
;;;457                    } else // uncorrectable error or ECC error
;;;458                    {
;;;459                        return -1;
0008f8  e3e00000          MVN      r0,#0
                  |L1.2300|
;;;460                    }
;;;461                }
;;;462            } //jj
;;;463        }
;;;464        return uErrorCnt;
;;;465    }
0008fc  e8bd83f8          POP      {r3-r9,pc}
                  |L1.2304|
000900  e1a00000          MOV      r0,r0                 ;449
000904  e2888001          ADD      r8,r8,#1              ;444
                  |L1.2312|
000908  e3580005          CMP      r8,#5                 ;444
00090c  baffffe8          BLT      |L1.2228|
                  |L1.2320|
000910  e1a00000          MOV      r0,r0                 ;456
000914  e1a00000          MOV      r0,r0                 ;442
                  |L1.2328|
000918  e2844001          ADD      r4,r4,#1              ;438
                  |L1.2332|
00091c  e1540006          CMP      r4,r6                 ;438
000920  baffffdc          BLT      |L1.2200|
                  |L1.2340|
000924  e59d0000          LDR      r0,[sp,#0]            ;464
000928  eafffff3          B        |L1.2300|
;;;466    
                          ENDP

                  _nuc970_nand_dma_transfer PROC
;;;467    
;;;468    static __inline int _nuc970_nand_dma_transfer(struct mtd_info *mtd, const u_char *addr, unsigned int len, int is_write)
00092c  e92d47f0          PUSH     {r4-r10,lr}
;;;469    {
000930  e1a04000          MOV      r4,r0
000934  e1a06001          MOV      r6,r1
000938  e1a09002          MOV      r9,r2
00093c  e1a07003          MOV      r7,r3
;;;470        struct nuc970_nand_info *nand = nuc970_nand;
000940  e59f0670          LDR      r0,|L1.4024|
000944  e5905000          LDR      r5,[r0,#0]  ; nuc970_nand
;;;471    
;;;472        // For save, wait DMAC to ready
;;;473        while ( inpw(REG_FMI_DMACTL) & 0x200 );
000948  e1a00000          MOV      r0,r0
                  |L1.2380|
00094c  e59f0668          LDR      r0,|L1.4028|
000950  e5900000          LDR      r0,[r0,#0]
000954  e3100c02          TST      r0,#0x200
000958  1afffffb          BNE      |L1.2380|
;;;474    
;;;475        // Reinitial dmac
;;;476        // DMAC enable
;;;477        outpw(REG_FMI_DMACTL, inpw(REG_FMI_DMACTL) | 0x3);
00095c  e59f0658          LDR      r0,|L1.4028|
000960  e5900000          LDR      r0,[r0,#0]
000964  e3800003          ORR      r0,r0,#3
000968  e59f164c          LDR      r1,|L1.4028|
00096c  e5810000          STR      r0,[r1,#0]
;;;478        while (inpw(REG_FMI_DMACTL) & 0x2);
000970  e1a00000          MOV      r0,r0
                  |L1.2420|
000974  e59f0640          LDR      r0,|L1.4028|
000978  e5900000          LDR      r0,[r0,#0]
00097c  e3100002          TST      r0,#2
000980  1afffffb          BNE      |L1.2420|
;;;479    
;;;480        // Clear DMA finished flag
;;;481        outpw(REG_NANDINTSTS, inpw(REG_NANDINTSTS) | 0x1);
000984  e59f060c          LDR      r0,|L1.3992|
000988  e5900000          LDR      r0,[r0,#0]
00098c  e3800001          ORR      r0,r0,#1
000990  e59f1600          LDR      r1,|L1.3992|
000994  e5810000          STR      r0,[r1,#0]
;;;482    
;;;483        // Disable Interrupt
;;;484        outpw(REG_NANDINTEN, inpw(REG_NANDINTEN) & ~(0x1));
000998  e2410004          SUB      r0,r1,#4
00099c  e5900000          LDR      r0,[r0,#0]
0009a0  e3c00001          BIC      r0,r0,#1
0009a4  e2411004          SUB      r1,r1,#4
0009a8  e5810000          STR      r0,[r1,#0]
;;;485    
;;;486        // Fill dma_addr
;;;487        outpw(REG_FMI_DMASA, (unsigned long)addr);
0009ac  e2410e4a          SUB      r0,r1,#0x4a0
0009b0  e5806000          STR      r6,[r0,#0]
;;;488    
;;;489        // Enable target abort interrupt generation during DMA transfer.
;;;490        outpw(REG_FMI_DMAINTEN, 0x1);
0009b4  e3a00001          MOV      r0,#1
0009b8  e59f1600          LDR      r1,|L1.4032|
0009bc  e5810000          STR      r0,[r1,#0]
;;;491    
;;;492        // Clear Ready/Busy 0 Rising edge detect flag
;;;493        outpw(REG_NANDINTSTS, 0x400);
0009c0  e3a00b01          MOV      r0,#0x400
0009c4  e59f15cc          LDR      r1,|L1.3992|
0009c8  e5810000          STR      r0,[r1,#0]
;;;494    
;;;495        // Set which BCH algorithm
;;;496        if ( nand->eBCHAlgo >= 0 ) {
0009cc  e59501e0          LDR      r0,[r5,#0x1e0]
0009d0  e3500000          CMP      r0,#0
0009d4  ba00000e          BLT      |L1.2580|
;;;497            // Set BCH algorithm
;;;498            outpw(REG_NANDCTL, (inpw(REG_NANDCTL) & (~0x7C0000)) | g_i32BCHAlgoIdx[nand->eBCHAlgo]);
0009d8  e241000c          SUB      r0,r1,#0xc
0009dc  e5900000          LDR      r0,[r0,#0]
0009e0  e3c0071f          BIC      r0,r0,#0x7c0000
0009e4  e59f25d8          LDR      r2,|L1.4036|
0009e8  e59511e0          LDR      r1,[r5,#0x1e0]
0009ec  e7921101          LDR      r1,[r2,r1,LSL #2]
0009f0  e1800001          ORR      r0,r0,r1
0009f4  e59f1598          LDR      r1,|L1.3988|
0009f8  e5810000          STR      r0,[r1,#0]
;;;499            // Enable H/W ECC, ECC parity check enable bit during read page
;;;500            outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x00800080);
0009fc  e1a00001          MOV      r0,r1
000a00  e5900000          LDR      r0,[r0,#0]
000a04  e3800502          ORR      r0,r0,#0x800000
000a08  e3800080          ORR      r0,r0,#0x80
000a0c  e5810000          STR      r0,[r1,#0]
000a10  ea000005          B        |L1.2604|
                  |L1.2580|
;;;501        } else  {
;;;502            // Disable H/W ECC / ECC parity check enable bit during read page
;;;503            outpw(REG_NANDCTL, inpw(REG_NANDCTL) & (~0x00800080));
000a14  e59f0578          LDR      r0,|L1.3988|
000a18  e5900000          LDR      r0,[r0,#0]
000a1c  e3c00502          BIC      r0,r0,#0x800000
000a20  e3c00080          BIC      r0,r0,#0x80
000a24  e59f1568          LDR      r1,|L1.3988|
000a28  e5810000          STR      r0,[r1,#0]
                  |L1.2604|
;;;504        }
;;;505    
;;;506        outpw(REG_NANDRACTL, nand->m_i32SMRASize);
000a2c  e59501e4          LDR      r0,[r5,#0x1e4]
000a30  e59f1578          LDR      r1,|L1.4016|
000a34  e5810000          STR      r0,[r1,#0]
;;;507    
;;;508        outpw(REG_NANDINTEN, inpw(REG_NANDINTEN) & (~0x4));
000a38  e2410014          SUB      r0,r1,#0x14
000a3c  e5900000          LDR      r0,[r0,#0]
000a40  e3c00004          BIC      r0,r0,#4
000a44  e2411014          SUB      r1,r1,#0x14
000a48  e5810000          STR      r0,[r1,#0]
;;;509    
;;;510        outpw(REG_NANDINTSTS, 0x4);
000a4c  e3a00004          MOV      r0,#4
000a50  e1811000          ORR      r1,r1,r0
000a54  e5810000          STR      r0,[r1,#0]
;;;511    
;;;512        // Enable SM_CS0
;;;513        outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
000a58  e241000c          SUB      r0,r1,#0xc
000a5c  e5900000          LDR      r0,[r0,#0]
000a60  e3c00406          BIC      r0,r0,#0x6000000
000a64  e3800301          ORR      r0,r0,#0x4000000
000a68  e241100c          SUB      r1,r1,#0xc
000a6c  e5810000          STR      r0,[r1,#0]
;;;514        /* setup and start DMA using dma_addr */
;;;515    
;;;516        if ( is_write ) {
000a70  e3570000          CMP      r7,#0
000a74  0a000015          BEQ      |L1.2768|
;;;517            register char *ptr= (char *)REG_NANDRA0;
000a78  e2810e16          ADD      r0,r1,#0x160
;;;518            // To mark this page as dirty.
;;;519            if ( ptr[3] == 0xFF )
000a7c  e5d01003          LDRB     r1,[r0,#3]
000a80  e35100ff          CMP      r1,#0xff
000a84  1a000001          BNE      |L1.2704|
;;;520                ptr[3] = 0;
000a88  e3a01000          MOV      r1,#0
000a8c  e5c01003          STRB     r1,[r0,#3]
                  |L1.2704|
;;;521            if ( ptr[2] == 0xFF )
000a90  e5d01002          LDRB     r1,[r0,#2]
000a94  e35100ff          CMP      r1,#0xff
000a98  1a000001          BNE      |L1.2724|
;;;522                ptr[2] = 0;
000a9c  e3a01000          MOV      r1,#0
000aa0  e5c01002          STRB     r1,[r0,#2]
                  |L1.2724|
;;;523    
;;;524            outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x4);
000aa4  e59f14e8          LDR      r1,|L1.3988|
000aa8  e5911000          LDR      r1,[r1,#0]
000aac  e3811004          ORR      r1,r1,#4
000ab0  e59f24dc          LDR      r2,|L1.3988|
000ab4  e5821000          STR      r1,[r2,#0]
;;;525            while ( !(inpw(REG_NANDINTSTS) & 0x1) );
000ab8  e1a00000          MOV      r0,r0
                  |L1.2748|
000abc  e59f14d4          LDR      r1,|L1.3992|
000ac0  e5911000          LDR      r1,[r1,#0]
000ac4  e3110001          TST      r1,#1
000ac8  0afffffb          BEQ      |L1.2748|
;;;526    
;;;527        } else {
000acc  ea000031          B        |L1.2968|
                  |L1.2768|
;;;528            // Blocking for reading
;;;529            // Enable DMA Read
;;;530    
;;;531            outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x2);
000ad0  e59f04bc          LDR      r0,|L1.3988|
000ad4  e5900000          LDR      r0,[r0,#0]
000ad8  e3800002          ORR      r0,r0,#2
000adc  e59f14b0          LDR      r1,|L1.3988|
000ae0  e5810000          STR      r0,[r1,#0]
;;;532    
;;;533            if (inpw(REG_NANDCTL) & 0x80) {
000ae4  e1a00001          MOV      r0,r1
000ae8  e5900000          LDR      r0,[r0,#0]
000aec  e3100080          TST      r0,#0x80
000af0  0a000023          BEQ      |L1.2948|
;;;534                do {
000af4  e1a00000          MOV      r0,r0
                  |L1.2808|
;;;535                    int stat=0;
000af8  e3a08000          MOV      r8,#0
;;;536                    if ( (stat=fmiSMCorrectData ( mtd,  (unsigned long)addr)) < 0 )
000afc  e1a01006          MOV      r1,r6
000b00  e1a00004          MOV      r0,r4
000b04  ebfffffe          BL       fmiSMCorrectData
000b08  e2508000          SUBS     r8,r0,#0
000b0c  aa00000e          BGE      |L1.2892|
;;;537                    {
;;;538                        mtd->ecc_stats.failed++;
000b10  e5940084          LDR      r0,[r4,#0x84]
000b14  e2800001          ADD      r0,r0,#1
000b18  e5840084          STR      r0,[r4,#0x84]
;;;539                        outpw(REG_NANDINTSTS, 0x4);
000b1c  e3a00004          MOV      r0,#4
000b20  e59f1470          LDR      r1,|L1.3992|
000b24  e5810000          STR      r0,[r1,#0]
;;;540                        outpw(REG_FMI_DMACTL, 0x3);          // reset DMAC
000b28  e3a00003          MOV      r0,#3
000b2c  e59f1488          LDR      r1,|L1.4028|
000b30  e5810000          STR      r0,[r1,#0]
;;;541                        outpw(REG_NANDCTL, inpw(REG_NANDCTL)|0x1);
000b34  e2810e4a          ADD      r0,r1,#0x4a0
000b38  e5900000          LDR      r0,[r0,#0]
000b3c  e3800001          ORR      r0,r0,#1
000b40  e2811e4a          ADD      r1,r1,#0x4a0
000b44  e5810000          STR      r0,[r1,#0]
;;;542                        break;
000b48  ea00000c          B        |L1.2944|
                  |L1.2892|
;;;543                    }
;;;544                    else if ( stat > 0 ) {
000b4c  e3580000          CMP      r8,#0
000b50  da000002          BLE      |L1.2912|
;;;545                        //mtd->ecc_stats.corrected += stat; //Occure: MLC UBIFS mount error
;;;546                        outpw(REG_NANDINTSTS, 0x4);
000b54  e3a00004          MOV      r0,#4
000b58  e59f1438          LDR      r1,|L1.3992|
000b5c  e5810000          STR      r0,[r1,#0]
                  |L1.2912|
;;;547                    }
;;;548    
;;;549                } while (!(inpw(REG_NANDINTSTS) & 0x1) || (inpw(REG_NANDINTSTS) & 0x4));
000b60  e59f0430          LDR      r0,|L1.3992|
000b64  e5900000          LDR      r0,[r0,#0]
000b68  e3100001          TST      r0,#1
000b6c  0affffe1          BEQ      |L1.2808|
000b70  e59f0420          LDR      r0,|L1.3992|
000b74  e5900000          LDR      r0,[r0,#0]
000b78  e3100004          TST      r0,#4
000b7c  1affffdd          BNE      |L1.2808|
                  |L1.2944|
000b80  ea000004          B        |L1.2968|
                  |L1.2948|
;;;550            } else
;;;551                while (!(inpw(REG_NANDINTSTS) & 0x1));
000b84  e1a00000          MOV      r0,r0
                  |L1.2952|
000b88  e59f0408          LDR      r0,|L1.3992|
000b8c  e5900000          LDR      r0,[r0,#0]
000b90  e3100001          TST      r0,#1
000b94  0afffffb          BEQ      |L1.2952|
                  |L1.2968|
;;;552        }
;;;553    
;;;554        // Clear DMA finished flag
;;;555        outpw(REG_NANDINTSTS, inpw(REG_NANDINTSTS) | 0x1);
000b98  e59f03f8          LDR      r0,|L1.3992|
000b9c  e5900000          LDR      r0,[r0,#0]
000ba0  e3800001          ORR      r0,r0,#1
000ba4  e59f13ec          LDR      r1,|L1.3992|
000ba8  e5810000          STR      r0,[r1,#0]
;;;556    
;;;557        return 0;
000bac  e3a00000          MOV      r0,#0
;;;558    }
000bb0  e8bd87f0          POP      {r4-r10,pc}
;;;559    
                          ENDP

                  nuc970_nand_write_page_hwecc PROC
;;;566     */
;;;567    static void nuc970_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
000bb4  e92d47f0          PUSH     {r4-r10,lr}
;;;568    {
000bb8  e1a05000          MOV      r5,r0
000bbc  e1a04001          MOV      r4,r1
000bc0  e1a06002          MOV      r6,r2
;;;569        uint8_t *ecc_calc = chip->buffers->ecccalc;
000bc4  e59470e8          LDR      r7,[r4,#0xe8]
;;;570        uint32_t hweccbytes=chip->ecc.layout->eccbytes;
000bc8  e59400b8          LDR      r0,[r4,#0xb8]
000bcc  e5908000          LDR      r8,[r0,#0]
;;;571        register char * ptr=(char *)REG_NANDRA0;
000bd0  e59f93d4          LDR      r9,|L1.4012|
;;;572    
;;;573        //debug("nuc970_nand_write_page_hwecc\n");
;;;574        memset ( (void*)ptr, 0xFF, mtd->oobsize );
000bd4  e3a020ff          MOV      r2,#0xff
000bd8  e1a00009          MOV      r0,r9
000bdc  e5951018          LDR      r1,[r5,#0x18]
000be0  ebfffffe          BL       __aeabi_memset
;;;575        memcpy ( (void*)ptr, (void*)chip->oob_poi,  mtd->oobsize - chip->ecc.total );
000be4  e5950018          LDR      r0,[r5,#0x18]
000be8  e59430ac          LDR      r3,[r4,#0xac]
000bec  e0402003          SUB      r2,r0,r3
000bf0  e1a00009          MOV      r0,r9
000bf4  e5941090          LDR      r1,[r4,#0x90]
000bf8  ebfffffe          BL       __aeabi_memcpy
;;;576    
;;;577        _nuc970_nand_dma_transfer( mtd, buf, mtd->writesize , 0x1);
000bfc  e3a03001          MOV      r3,#1
000c00  e1a01006          MOV      r1,r6
000c04  e5952014          LDR      r2,[r5,#0x14]
000c08  e1a00005          MOV      r0,r5
000c0c  ebfffffe          BL       _nuc970_nand_dma_transfer
;;;578    
;;;579        // Copy parity code in SMRA to calc
;;;580        memcpy ( (void*)ecc_calc,  (void*)( REG_NANDRA0 + ( mtd->oobsize - chip->ecc.total ) ), chip->ecc.total );
000c10  e5950018          LDR      r0,[r5,#0x18]
000c14  e59430ac          LDR      r3,[r4,#0xac]
000c18  e0400003          SUB      r0,r0,r3
000c1c  e1a03009          MOV      r3,r9
000c20  e0801003          ADD      r1,r0,r3
000c24  e1a00007          MOV      r0,r7
000c28  e59420ac          LDR      r2,[r4,#0xac]
000c2c  ebfffffe          BL       __aeabi_memcpy
;;;581    
;;;582        // Copy parity code in calc to oob_poi
;;;583        memcpy ( (void*)(chip->oob_poi+hweccbytes), (void*)ecc_calc, chip->ecc.total);
000c30  e5941090          LDR      r1,[r4,#0x90]
000c34  e0810008          ADD      r0,r1,r8
000c38  e1a01007          MOV      r1,r7
000c3c  e59420ac          LDR      r2,[r4,#0xac]
000c40  ebfffffe          BL       __aeabi_memcpy
;;;584    }
000c44  e8bd87f0          POP      {r4-r10,pc}
;;;585    
                          ENDP

                  nuc970_nand_read_page_hwecc_oob_first PROC
;;;592     */
;;;593    static int nuc970_nand_read_page_hwecc_oob_first(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int page)
000c48  e92d47f0          PUSH     {r4-r10,lr}
;;;594    {
000c4c  e1a05000          MOV      r5,r0
000c50  e1a04001          MOV      r4,r1
000c54  e1a06002          MOV      r6,r2
000c58  e1a08003          MOV      r8,r3
;;;595        int eccsize = chip->ecc.size;
000c5c  e59490a4          LDR      r9,[r4,#0xa4]
;;;596        uint8_t *p = buf;
000c60  e1a0a006          MOV      r10,r6
;;;597        char * ptr= (char *)REG_NANDRA0;
000c64  e59f7340          LDR      r7,|L1.4012|
;;;598        int volatile i;
;;;599    
;;;600        //debug("nuc970_nand_read_page_hwecc_oob_first\n");
;;;601        /* At first, read the OOB area  */
;;;602        nuc970_nand_command(mtd, NAND_CMD_READOOB, 0, page);
000c68  e1a03008          MOV      r3,r8
000c6c  e3a02000          MOV      r2,#0
000c70  e3a01050          MOV      r1,#0x50
000c74  e1a00005          MOV      r0,r5
000c78  ebfffffe          BL       nuc970_nand_command
;;;603        nuc970_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);
000c7c  e5952018          LDR      r2,[r5,#0x18]
000c80  e1a00005          MOV      r0,r5
000c84  e5941090          LDR      r1,[r4,#0x90]
000c88  ebfffffe          BL       nuc970_nand_read_buf
;;;604    
;;;605        // Second, copy OOB data to SMRA for page read
;;;606        memcpy ( (void*)ptr, (void*)chip->oob_poi, mtd->oobsize );
000c8c  e5952018          LDR      r2,[r5,#0x18]
000c90  e1a00007          MOV      r0,r7
000c94  e5941090          LDR      r1,[r4,#0x90]
000c98  ebfffffe          BL       __aeabi_memcpy
;;;607    
;;;608        // Third, read data from nand
;;;609        nuc970_nand_command(mtd, NAND_CMD_READ0, 0, page);
000c9c  e1a03008          MOV      r3,r8
000ca0  e3a02000          MOV      r2,#0
000ca4  e1a01002          MOV      r1,r2
000ca8  e1a00005          MOV      r0,r5
000cac  ebfffffe          BL       nuc970_nand_command
;;;610        _nuc970_nand_dma_transfer(mtd, p, eccsize, 0x0);
000cb0  e3a03000          MOV      r3,#0
000cb4  e1a02009          MOV      r2,r9
000cb8  e1a0100a          MOV      r1,r10
000cbc  e1a00005          MOV      r0,r5
000cc0  ebfffffe          BL       _nuc970_nand_dma_transfer
;;;611    
;;;612        // Fouth, restore OOB data from SMRA
;;;613        memcpy ( (void*)chip->oob_poi, (void*)ptr, mtd->oobsize );
000cc4  e5952018          LDR      r2,[r5,#0x18]
000cc8  e1a01007          MOV      r1,r7
000ccc  e5940090          LDR      r0,[r4,#0x90]
000cd0  ebfffffe          BL       __aeabi_memcpy
;;;614    
;;;615        return 0;
000cd4  e3a00000          MOV      r0,#0
;;;616    }
000cd8  e8bd87f0          POP      {r4-r10,pc}
;;;617    
                          ENDP

                  nuc970_nand_read_oob_hwecc PROC
;;;624     */
;;;625    static int nuc970_nand_read_oob_hwecc(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
000cdc  e92d41f0          PUSH     {r4-r8,lr}
;;;626    {
000ce0  e1a04000          MOV      r4,r0
000ce4  e1a05001          MOV      r5,r1
000ce8  e1a07002          MOV      r7,r2
000cec  e1a06003          MOV      r6,r3
;;;627        char * ptr=(char *)REG_NANDRA0;
000cf0  e59f82b4          LDR      r8,|L1.4012|
;;;628    
;;;629        /* At first, read the OOB area  */
;;;630        if ( sndcmd ) {
000cf4  e3560000          CMP      r6,#0
000cf8  0a000005          BEQ      |L1.3348|
;;;631            nuc970_nand_command(mtd, NAND_CMD_READOOB, 0, page);
000cfc  e1a03007          MOV      r3,r7
000d00  e3a02000          MOV      r2,#0
000d04  e3a01050          MOV      r1,#0x50
000d08  e1a00004          MOV      r0,r4
000d0c  ebfffffe          BL       nuc970_nand_command
;;;632            sndcmd = 0;
000d10  e3a06000          MOV      r6,#0
                  |L1.3348|
;;;633        }
;;;634    
;;;635        nuc970_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);
000d14  e5942018          LDR      r2,[r4,#0x18]
000d18  e1a00004          MOV      r0,r4
000d1c  e5951090          LDR      r1,[r5,#0x90]
000d20  ebfffffe          BL       nuc970_nand_read_buf
;;;636    
;;;637        // Second, copy OOB data to SMRA for page read
;;;638        memcpy ( (void*)ptr, (void*)chip->oob_poi, mtd->oobsize );
000d24  e5942018          LDR      r2,[r4,#0x18]
000d28  e1a00008          MOV      r0,r8
000d2c  e5951090          LDR      r1,[r5,#0x90]
000d30  ebfffffe          BL       __aeabi_memcpy
;;;639    
;;;640        return sndcmd;
000d34  e1a00006          MOV      r0,r6
;;;641    }
000d38  e8bd81f0          POP      {r4-r8,pc}
;;;642    
                          ENDP

                  board_nand_init PROC
;;;644    
;;;645    int board_nand_init(struct nand_chip *nand)
000d3c  e92d4070          PUSH     {r4-r6,lr}
;;;646    {
000d40  e1a04000          MOV      r4,r0
;;;647        struct mtd_info *mtd;
;;;648    
;;;649        nuc970_nand = &g_nuc970_nand;
000d44  e59f027c          LDR      r0,|L1.4040|
000d48  e59f1268          LDR      r1,|L1.4024|
000d4c  e5810000          STR      r0,[r1,#0]  ; nuc970_nand
;;;650        memset((void*)nuc970_nand,0,sizeof(struct nuc970_nand_info));
000d50  e3a01f7a          MOV      r1,#0x1e8
000d54  e59f025c          LDR      r0,|L1.4024|
000d58  e5900000          LDR      r0,[r0,#0]  ; nuc970_nand
000d5c  ebfffffe          BL       __aeabi_memclr4
;;;651    	
;;;652        if (!nuc970_nand)
000d60  e59f0250          LDR      r0,|L1.4024|
000d64  e5900000          LDR      r0,[r0,#0]  ; nuc970_nand
000d68  e3500000          CMP      r0,#0
000d6c  1a000001          BNE      |L1.3448|
;;;653            return -1;
000d70  e3e00000          MVN      r0,#0
                  |L1.3444|
;;;654    
;;;655        mtd=&nuc970_nand->mtd;
;;;656        nuc970_nand->chip.controller = &nuc970_nand->controller;
;;;657    
;;;658        /* initialize nand_chip data structure */
;;;659        nand->IO_ADDR_R = (void *)REG_NANDDATA;
;;;660        nand->IO_ADDR_W = (void *)REG_NANDDATA;
;;;661    
;;;662        /* read_buf and write_buf are default */
;;;663        /* read_byte and write_byte are default */
;;;664        /* hwcontrol always must be implemented */
;;;665        nand->cmd_ctrl = nuc970_hwcontrol;
;;;666        nand->cmdfunc = nuc970_nand_command;
;;;667        nand->dev_ready = nuc970_dev_ready;
;;;668        nand->select_chip = nuc970_nand_select_chip;
;;;669    
;;;670        nand->read_byte = nuc970_nand_read_byte;
;;;671        nand->write_buf = nuc970_nand_write_buf;
;;;672        nand->read_buf = nuc970_nand_read_buf;
;;;673        nand->chip_delay = 50;
;;;674    
;;;675        nand->controller = &nuc970_nand->controller;
;;;676    
;;;677        nand->ecc.mode      = NAND_ECC_HW_OOB_FIRST;
;;;678        nand->ecc.hwctl     = nuc970_nand_enable_hwecc;
;;;679        nand->ecc.calculate = nuc970_nand_calculate_ecc;
;;;680        nand->ecc.correct   = nuc970_nand_correct_data;
;;;681        nand->ecc.write_page= nuc970_nand_write_page_hwecc;
;;;682        nand->ecc.read_page = nuc970_nand_read_page_hwecc_oob_first;
;;;683        nand->ecc.read_oob  = nuc970_nand_read_oob_hwecc;
;;;684        nand->ecc.layout    = &nuc970_nand_oob;
;;;685    
;;;686        mtd->priv = nand;
;;;687    
;;;688        /* initial NAND controller */
;;;689        outpw(REG_CLK_HCLKEN, (inpw(REG_CLK_HCLKEN) | 0x300000));
;;;690    
;;;691        /* select NAND function pins */
;;;692        if (inpw(REG_SYS_PWRON) & 0x08000000)
;;;693        {
;;;694            /* Set GPI1~15 for NAND */
;;;695            outpw(REG_SYS_GPI_MFPL, 0x55555550);
;;;696            outpw(REG_SYS_GPI_MFPH, 0x55555555);
;;;697        }
;;;698        else
;;;699        {
;;;700            /* Set GPC0~14 for NAND */
;;;701            outpw(REG_SYS_GPC_MFPL, 0x55555555);
;;;702            outpw(REG_SYS_GPC_MFPH, 0x05555555);
;;;703        }
;;;704    
;;;705        // Enable SM_EN
;;;706        outpw(REG_FMI_CTL, NAND_EN);
;;;707        outpw(REG_NANDTMCTL, 0x20305);
;;;708    
;;;709        // Enable SM_CS0
;;;710        outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x06000000))|0x04000000);
;;;711        outpw(REG_NANDECTL, 0x1); /* un-lock write protect */
;;;712    
;;;713        // NAND Reset
;;;714        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x1);    // software reset
;;;715        while (inpw(REG_NANDCTL) & 0x1);
;;;716    
;;;717        /* Detect NAND chips */
;;;718        /* first scan to find the device and get the page size */
;;;719        if (nand_scan_ident(&(nuc970_nand->mtd), 1, NULL)) {
;;;720            sysprintf("NAND Flash not found !\n");
;;;721            return -1;
;;;722        }
;;;723    
;;;724        //Set PSize bits of SMCSR register to select NAND card page size
;;;725        switch (mtd->writesize) {
;;;726            case 2048:
;;;727                outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x10000);
;;;728                nuc970_nand->eBCHAlgo = 0; /* T4 */
;;;729                nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[1][nuc970_nand->eBCHAlgo] );
;;;730                break;
;;;731    
;;;732            case 4096:
;;;733                outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x20000);
;;;734                nuc970_nand->eBCHAlgo = 1; /* T8 */
;;;735                nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[2][nuc970_nand->eBCHAlgo] );
;;;736                break;
;;;737    
;;;738            case 8192:
;;;739                outpw(REG_NANDCTL, (inpw(REG_NANDCTL)&(~0x30000)) + 0x30000);
;;;740                nuc970_nand->eBCHAlgo = 2; /* T12 */
;;;741                nuc970_layout_oob_table ( &nuc970_nand_oob, mtd->oobsize, g_i32ParityNum[3][nuc970_nand->eBCHAlgo] );
;;;742                break;
;;;743    
;;;744            /* Not support now. */
;;;745            case 512:
;;;746    
;;;747            default:
;;;748                sysprintf("NUC970 NAND CONTROLLER IS NOT SUPPORT THE PAGE SIZE. (%d, %d)\n", mtd->writesize, mtd->oobsize );
;;;749        }
;;;750    
;;;751        nuc970_nand->m_i32SMRASize  = mtd->oobsize;
;;;752        nand->ecc.bytes = nuc970_nand_oob.eccbytes;
;;;753        nand->ecc.size  = mtd->writesize;
;;;754    
;;;755        nand->options = 0;
;;;756    
;;;757        // Redundant area size
;;;758        outpw(REG_NANDRACTL, nuc970_nand->m_i32SMRASize);
;;;759    
;;;760        // Protect redundant 3 bytes
;;;761        // because we need to implement write_oob function to partial data to oob available area.
;;;762        // Please note we skip 4 bytes
;;;763        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x100);
;;;764    
;;;765        // To read/write the ECC parity codes automatically from/to NAND Flash after data area field written.
;;;766        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x10);
;;;767        // Set BCH algorithm
;;;768        outpw(REG_NANDCTL, (inpw(REG_NANDCTL) & (~0x007C0000)) | g_i32BCHAlgoIdx[nuc970_nand->eBCHAlgo]);
;;;769        // Enable H/W ECC, ECC parity check enable bit during read page
;;;770        outpw(REG_NANDCTL, inpw(REG_NANDCTL) | 0x00800080);
;;;771    
;;;772        return 0;
;;;773    }
000d74  e8bd8070          POP      {r4-r6,pc}
                  |L1.3448|
000d78  e59f0238          LDR      r0,|L1.4024|
000d7c  e5900000          LDR      r0,[r0,#0]            ;655  ; nuc970_nand
000d80  e2805008          ADD      r5,r0,#8              ;655
000d84  e59f022c          LDR      r0,|L1.4024|
000d88  e5900000          LDR      r0,[r0,#0]            ;656  ; nuc970_nand
000d8c  e59f1224          LDR      r1,|L1.4024|
000d90  e5911000          LDR      r1,[r1,#0]            ;656  ; nuc970_nand
000d94  e581014c          STR      r0,[r1,#0x14c]        ;656
000d98  e59f01ec          LDR      r0,|L1.3980|
000d9c  e5840000          STR      r0,[r4,#0]            ;659
000da0  e5840004          STR      r0,[r4,#4]            ;660
000da4  e59f0220          LDR      r0,|L1.4044|
000da8  e5840028          STR      r0,[r4,#0x28]         ;665
000dac  e59f021c          LDR      r0,|L1.4048|
000db0  e5840034          STR      r0,[r4,#0x34]         ;666
000db4  e59f0218          LDR      r0,|L1.4052|
000db8  e5840030          STR      r0,[r4,#0x30]         ;667
000dbc  e59f0214          LDR      r0,|L1.4056|
000dc0  e584001c          STR      r0,[r4,#0x1c]         ;668
000dc4  e59f0210          LDR      r0,|L1.4060|
000dc8  e5840008          STR      r0,[r4,#8]            ;670
000dcc  e59f020c          LDR      r0,|L1.4064|
000dd0  e5840010          STR      r0,[r4,#0x10]         ;671
000dd4  e59f0208          LDR      r0,|L1.4068|
000dd8  e5840014          STR      r0,[r4,#0x14]         ;672
000ddc  e3a00032          MOV      r0,#0x32              ;673
000de0  e584004c          STR      r0,[r4,#0x4c]         ;673
000de4  e59f01cc          LDR      r0,|L1.4024|
000de8  e5900000          LDR      r0,[r0,#0]            ;675  ; nuc970_nand
000dec  e5840094          STR      r0,[r4,#0x94]         ;675
000df0  e3a00004          MOV      r0,#4                 ;677
000df4  e5c4009c          STRB     r0,[r4,#0x9c]         ;677
000df8  e59f01e8          LDR      r0,|L1.4072|
000dfc  e58400c0          STR      r0,[r4,#0xc0]         ;678
000e00  e59f01e4          LDR      r0,|L1.4076|
000e04  e58400c4          STR      r0,[r4,#0xc4]         ;679
000e08  e59f01e0          LDR      r0,|L1.4080|
000e0c  e58400c8          STR      r0,[r4,#0xc8]         ;680
000e10  e59f01dc          LDR      r0,|L1.4084|
000e14  e58400dc          STR      r0,[r4,#0xdc]         ;681
000e18  e59f01d8          LDR      r0,|L1.4088|
000e1c  e58400d4          STR      r0,[r4,#0xd4]         ;682
000e20  e59f01d4          LDR      r0,|L1.4092|
000e24  e58400e0          STR      r0,[r4,#0xe0]         ;683
000e28  e59f01d0          LDR      r0,|L1.4096|
000e2c  e58400b8          STR      r0,[r4,#0xb8]         ;684
000e30  e5854094          STR      r4,[r5,#0x94]         ;686
000e34  e3a0020b          MOV      r0,#0xb0000000        ;689
000e38  e5900210          LDR      r0,[r0,#0x210]        ;689
000e3c  e3800603          ORR      r0,r0,#0x300000       ;689
000e40  e3a0120b          MOV      r1,#0xb0000000        ;689
000e44  e5810210          STR      r0,[r1,#0x210]        ;689
000e48  e3a0020b          MOV      r0,#0xb0000000        ;692
000e4c  e5900004          LDR      r0,[r0,#4]            ;692
000e50  e3100302          TST      r0,#0x8000000         ;692
000e54  0a000004          BEQ      |L1.3692|
000e58  e59f01a4          LDR      r0,|L1.4100|
000e5c  e58100b0          STR      r0,[r1,#0xb0]         ;695
000e60  e1800240          ORR      r0,r0,r0,ASR #4       ;696
000e64  e58100b4          STR      r0,[r1,#0xb4]         ;696
000e68  ea000004          B        |L1.3712|
                  |L1.3692|
000e6c  e59f0194          LDR      r0,|L1.4104|
000e70  e3a0120b          MOV      r1,#0xb0000000        ;701
000e74  e5810080          STR      r0,[r1,#0x80]         ;701
000e78  e1a00240          ASR      r0,r0,#4              ;702
000e7c  e5810084          STR      r0,[r1,#0x84]         ;702
                  |L1.3712|
000e80  e3a00008          MOV      r0,#8                 ;706
000e84  e59f1180          LDR      r1,|L1.4108|
000e88  e5810000          STR      r0,[r1,#0]            ;706
000e8c  e59f017c          LDR      r0,|L1.4112|
000e90  e28110a4          ADD      r1,r1,#0xa4           ;707
000e94  e5810000          STR      r0,[r1,#0]            ;707
000e98  e1c10000          BIC      r0,r1,r0              ;710
000e9c  e5900000          LDR      r0,[r0,#0]            ;710
000ea0  e3c00406          BIC      r0,r0,#0x6000000      ;710
000ea4  e3800301          ORR      r0,r0,#0x4000000      ;710
000ea8  e2411004          SUB      r1,r1,#4              ;710
000eac  e5810000          STR      r0,[r1,#0]            ;710
000eb0  e3a00001          MOV      r0,#1                 ;711
000eb4  e0811280          ADD      r1,r1,r0,LSL #5       ;711
000eb8  e5810000          STR      r0,[r1,#0]            ;711
000ebc  e0410280          SUB      r0,r1,r0,LSL #5       ;714
000ec0  e5900000          LDR      r0,[r0,#0]            ;714
000ec4  e3800001          ORR      r0,r0,#1              ;714
000ec8  e2411020          SUB      r1,r1,#0x20           ;714
000ecc  e5810000          STR      r0,[r1,#0]            ;714
000ed0  e1a00000          MOV      r0,r0                 ;715
                  |L1.3796|
000ed4  e59f00b8          LDR      r0,|L1.3988|
000ed8  e5900000          LDR      r0,[r0,#0]            ;715
000edc  e3100001          TST      r0,#1                 ;715
000ee0  1afffffb          BNE      |L1.3796|
000ee4  e3a02000          MOV      r2,#0                 ;719
000ee8  e3a01001          MOV      r1,#1                 ;719
000eec  e59f00c4          LDR      r0,|L1.4024|
000ef0  e5900000          LDR      r0,[r0,#0]            ;719  ; nuc970_nand
000ef4  e2800008          ADD      r0,r0,#8              ;719
000ef8  ebfffffe          BL       nand_scan_ident
000efc  e3500000          CMP      r0,#0                 ;719
000f00  0a000003          BEQ      |L1.3860|
000f04  e28f0f42          ADR      r0,|L1.4116|
000f08  ebfffffe          BL       sysprintf
000f0c  e3e00000          MVN      r0,#0                 ;721
000f10  eaffff97          B        |L1.3444|
                  |L1.3860|
000f14  e5950014          LDR      r0,[r5,#0x14]         ;725
000f18  e3500c02          CMP      r0,#0x200             ;725
000f1c  0a00006d          BEQ      |L1.4312|
000f20  e3500b02          CMP      r0,#0x800             ;725
000f24  0a000004          BEQ      |L1.3900|
000f28  e3500a01          CMP      r0,#0x1000            ;725
000f2c  0a00003f          BEQ      |L1.4144|
000f30  e3500a02          CMP      r0,#0x2000            ;725
000f34  1a000065          BNE      |L1.4304|
000f38  ea000050          B        |L1.4224|
                  |L1.3900|
000f3c  e1a00000          MOV      r0,r0                 ;726
000f40  e59f004c          LDR      r0,|L1.3988|
000f44  e5900000          LDR      r0,[r0,#0]            ;727
000f48  e3c00803          BIC      r0,r0,#0x30000        ;727
000f4c  e2800801          ADD      r0,r0,#0x10000        ;727
000f50  e59f103c          LDR      r1,|L1.3988|
000f54  e5810000          STR      r0,[r1,#0]            ;727
000f58  e3a00000          MOV      r0,#0                 ;728
000f5c  e59f1054          LDR      r1,|L1.4024|
000f60  e5911000          LDR      r1,[r1,#0]            ;728  ; nuc970_nand
000f64  e58101e0          STR      r0,[r1,#0x1e0]        ;728
000f68  e59f0048          LDR      r0,|L1.4024|
000f6c  e5900000          LDR      r0,[r0,#0]            ;729  ; nuc970_nand
000f70  e59001e0          LDR      r0,[r0,#0x1e0]        ;729
000f74  e59f30b0          LDR      r3,|L1.4140|
000f78  e7932100          LDR      r2,[r3,r0,LSL #2]     ;729
000f7c  e59f007c          LDR      r0,|L1.4096|
000f80  e5951018          LDR      r1,[r5,#0x18]         ;729
000f84  ebfffffe          BL       nuc970_layout_oob_table
000f88  ea000057          B        |L1.4332|
                  |L1.3980|
                          DCD      0xb000d8b8
                  |L1.3984|
                          DCD      0xb000d8b4
                  |L1.3988|
                          DCD      0xb000d8a0
                  |L1.3992|
                          DCD      0xb000d8ac
                  |L1.3996|
                          DCD      0xb000d8b0
                  |L1.4000|
                          DCD      0xb000d960
                  |L1.4004|
                          DCD      0xb000d900
                  |L1.4008|
                          DCD      0x000007ff
                  |L1.4012|
                          DCD      0xb000da00
                  |L1.4016|
                          DCD      0xb000d8bc
                  |L1.4020|
                          DCD      0xb000d8d0
                  |L1.4024|
                          DCD      nuc970_nand
                  |L1.4028|
                          DCD      0xb000d400
                  |L1.4032|
                          DCD      0xb000d410
                  |L1.4036|
                          DCD      g_i32BCHAlgoIdx
                  |L1.4040|
                          DCD      g_nuc970_nand
                  |L1.4044|
                          DCD      nuc970_hwcontrol
                  |L1.4048|
                          DCD      nuc970_nand_command
                  |L1.4052|
                          DCD      nuc970_dev_ready
                  |L1.4056|
                          DCD      nuc970_nand_select_chip
                  |L1.4060|
                          DCD      nuc970_nand_read_byte
                  |L1.4064|
                          DCD      nuc970_nand_write_buf
                  |L1.4068|
                          DCD      nuc970_nand_read_buf
                  |L1.4072|
                          DCD      nuc970_nand_enable_hwecc
                  |L1.4076|
                          DCD      nuc970_nand_calculate_ecc
                  |L1.4080|
                          DCD      nuc970_nand_correct_data
                  |L1.4084|
                          DCD      nuc970_nand_write_page_hwecc
                  |L1.4088|
                          DCD      nuc970_nand_read_page_hwecc_oob_first
                  |L1.4092|
                          DCD      nuc970_nand_read_oob_hwecc
                  |L1.4096|
                          DCD      nuc970_nand_oob
                  |L1.4100|
                          DCD      0x55555550
                  |L1.4104|
                          DCD      0x55555555
                  |L1.4108|
                          DCD      0xb000d800
                  |L1.4112|
                          DCD      0x00020305
                  |L1.4116|
001014  4e414e44          DCB      "NAND Flash not found !\n",0
001018  20466c61
00101c  7368206e
001020  6f742066
001024  6f756e64
001028  20210a00
                  |L1.4140|
                          DCD      g_i32ParityNum+0x14
                  |L1.4144|
001030  e1a00000          MOV      r0,r0                 ;732
001034  e51f00a8          LDR      r0,|L1.3988|
001038  e5900000          LDR      r0,[r0,#0]            ;733
00103c  e3c00803          BIC      r0,r0,#0x30000        ;733
001040  e2800802          ADD      r0,r0,#0x20000        ;733
001044  e51f10b8          LDR      r1,|L1.3988|
001048  e5810000          STR      r0,[r1,#0]            ;733
00104c  e3a00001          MOV      r0,#1                 ;734
001050  e51f10a0          LDR      r1,|L1.4024|
001054  e5911000          LDR      r1,[r1,#0]            ;734  ; nuc970_nand
001058  e58101e0          STR      r0,[r1,#0x1e0]        ;734
00105c  e51f00ac          LDR      r0,|L1.4024|
001060  e5900000          LDR      r0,[r0,#0]            ;735  ; nuc970_nand
001064  e59001e0          LDR      r0,[r0,#0x1e0]        ;735
001068  e59f312c          LDR      r3,|L1.4508|
00106c  e7932100          LDR      r2,[r3,r0,LSL #2]     ;735
001070  e51f0078          LDR      r0,|L1.4096|
001074  e5951018          LDR      r1,[r5,#0x18]         ;735
001078  ebfffffe          BL       nuc970_layout_oob_table
00107c  ea00001a          B        |L1.4332|
                  |L1.4224|
001080  e1a00000          MOV      r0,r0                 ;738
001084  e51f00f8          LDR      r0,|L1.3988|
001088  e5900000          LDR      r0,[r0,#0]            ;739
00108c  e3c00803          BIC      r0,r0,#0x30000        ;739
001090  e2800803          ADD      r0,r0,#0x30000        ;739
001094  e51f1108          LDR      r1,|L1.3988|
001098  e5810000          STR      r0,[r1,#0]            ;739
00109c  e3a00002          MOV      r0,#2                 ;740
0010a0  e51f10f0          LDR      r1,|L1.4024|
0010a4  e5911000          LDR      r1,[r1,#0]            ;740  ; nuc970_nand
0010a8  e58101e0          STR      r0,[r1,#0x1e0]        ;740
0010ac  e51f00fc          LDR      r0,|L1.4024|
0010b0  e5900000          LDR      r0,[r0,#0]            ;741  ; nuc970_nand
0010b4  e59001e0          LDR      r0,[r0,#0x1e0]        ;741
0010b8  e59f30e0          LDR      r3,|L1.4512|
0010bc  e7932100          LDR      r2,[r3,r0,LSL #2]     ;741
0010c0  e51f00c8          LDR      r0,|L1.4096|
0010c4  e5951018          LDR      r1,[r5,#0x18]         ;741
0010c8  ebfffffe          BL       nuc970_layout_oob_table
0010cc  ea000006          B        |L1.4332|
                  |L1.4304|
0010d0  e1a00000          MOV      r0,r0                 ;745
0010d4  e1a00000          MOV      r0,r0                 ;745
                  |L1.4312|
0010d8  e28f00c4          ADR      r0,|L1.4516|
0010dc  e5951014          LDR      r1,[r5,#0x14]         ;748
0010e0  e5952018          LDR      r2,[r5,#0x18]         ;748
0010e4  ebfffffe          BL       sysprintf
0010e8  e1a00000          MOV      r0,r0                 ;725
                  |L1.4332|
0010ec  e1a00000          MOV      r0,r0                 ;730
0010f0  e51f1140          LDR      r1,|L1.4024|
0010f4  e5950018          LDR      r0,[r5,#0x18]         ;751
0010f8  e5911000          LDR      r1,[r1,#0]            ;751  ; nuc970_nand
0010fc  e58101e4          STR      r0,[r1,#0x1e4]        ;751
001100  e51f0108          LDR      r0,|L1.4096|
001104  e5900000          LDR      r0,[r0,#0]            ;752  ; nuc970_nand_oob
001108  e58400a8          STR      r0,[r4,#0xa8]         ;752
00110c  e5950014          LDR      r0,[r5,#0x14]         ;753
001110  e58400a4          STR      r0,[r4,#0xa4]         ;753
001114  e3a00000          MOV      r0,#0                 ;755
001118  e5840050          STR      r0,[r4,#0x50]         ;755
00111c  e51f016c          LDR      r0,|L1.4024|
001120  e5900000          LDR      r0,[r0,#0]            ;758  ; nuc970_nand
001124  e59001e4          LDR      r0,[r0,#0x1e4]        ;758
001128  e51f1180          LDR      r1,|L1.4016|
00112c  e5810000          STR      r0,[r1,#0]            ;758
001130  e241001c          SUB      r0,r1,#0x1c           ;763
001134  e5900000          LDR      r0,[r0,#0]            ;763
001138  e3800c01          ORR      r0,r0,#0x100          ;763
00113c  e241101c          SUB      r1,r1,#0x1c           ;763
001140  e5810000          STR      r0,[r1,#0]            ;763
001144  e1a00001          MOV      r0,r1                 ;766
001148  e5900000          LDR      r0,[r0,#0]            ;766
00114c  e3800010          ORR      r0,r0,#0x10           ;766
001150  e5810000          STR      r0,[r1,#0]            ;766
001154  e1a00001          MOV      r0,r1                 ;768
001158  e5900000          LDR      r0,[r0,#0]            ;768
00115c  e3c0071f          BIC      r0,r0,#0x7c0000       ;768
001160  e51f11b0          LDR      r1,|L1.4024|
001164  e5911000          LDR      r1,[r1,#0]            ;768  ; nuc970_nand
001168  e59111e0          LDR      r1,[r1,#0x1e0]        ;768
00116c  e51f21b0          LDR      r2,|L1.4036|
001170  e7921101          LDR      r1,[r2,r1,LSL #2]     ;768
001174  e1800001          ORR      r0,r0,r1              ;768
001178  e51f11ec          LDR      r1,|L1.3988|
00117c  e5810000          STR      r0,[r1,#0]            ;768
001180  e1a00001          MOV      r0,r1                 ;770
001184  e5900000          LDR      r0,[r0,#0]            ;770
001188  e3800502          ORR      r0,r0,#0x800000       ;770
00118c  e3800080          ORR      r0,r0,#0x80           ;770
001190  e5810000          STR      r0,[r1,#0]            ;770
001194  e3a00000          MOV      r0,#0                 ;772
001198  eafffef5          B        |L1.3444|
;;;774    
                          ENDP

                  |L1.4508|
                          DCD      g_i32ParityNum+0x28
                  |L1.4512|
                          DCD      g_i32ParityNum+0x3c
                  |L1.4516|
0011a4  4e554339          DCB      "NUC970 NAND CONTROLLER IS NOT SUPPORT THE PAGE SIZE. (%"
0011a8  3730204e
0011ac  414e4420
0011b0  434f4e54
0011b4  524f4c4c
0011b8  45522049
0011bc  53204e4f
0011c0  54205355
0011c4  50504f52
0011c8  54205448
0011cc  45205041
0011d0  47452053
0011d4  495a452e
0011d8  202825  
0011db  642c2025          DCB      "d, %d)\n",0
0011df  64290a00
0011e3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  g_nuc970_nand
                          %        488
                  nuc970_nand_oob
                          %        584

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_i32BCHAlgoIdx
                          DCD      0x00080000
                          DCD      0x00100000
                          DCD      0x00200000
                          DCD      0x00400000
                          DCD      0x00040000
                  g_i32ParityNum
                          DCD      0x00000008
                          DCD      0x0000000f
                          DCD      0x00000017
                          DCD      0x0000001d
                          DCD      0xffffffff
                          DCD      0x00000020
                          DCD      0x0000003c
                          DCD      0x0000005c
                          DCD      0x00000074
                          DCD      0x0000005a
                          DCD      0x00000040
                          DCD      0x00000078
                          DCD      0x000000b8
                          DCD      0x000000e8
                          DCD      0x000000b4
                          DCD      0x00000080
                          DCD      0x000000f0
                          DCD      0x00000170
                          DCD      0x000001d0
                          DCD      0x00000168

                          AREA ||.data||, DATA, ALIGN=2

                  nuc970_nand
                          DCD      0x00000000
