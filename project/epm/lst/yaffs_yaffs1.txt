; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\yaffs_yaffs1.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\yaffs_yaffs1.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\yaffs_yaffs1.crf ..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_yaffs1.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  yaffs1_scan PROC
;;;22     
;;;23     int yaffs1_scan(struct yaffs_dev *dev)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;24     {
000004  e24dd07c          SUB      sp,sp,#0x7c
000008  e1a05000          MOV      r5,r0
;;;25     	struct yaffs_ext_tags tags;
;;;26     	int blk;
;;;27     	int chunk;
;;;28     	int c;
;;;29     	int deleted;
;;;30     	enum yaffs_block_state state;
;;;31     // 	LIST_HEAD(hard_list);
;;;32         struct list_head hard_list;
;;;33     	struct yaffs_block_info *bi;
;;;34     	u32 seq_number;
;;;35     	struct yaffs_obj_hdr *oh;
;;;36     	struct yaffs_obj *in;
;;;37     	struct yaffs_obj *parent;
;;;38     	int alloc_failed = 0;
00000c  e3a00000          MOV      r0,#0
000010  e58d0014          STR      r0,[sp,#0x14]
;;;39     	struct yaffs_shadow_fixer *shadow_fixers = NULL;
000014  e58d0010          STR      r0,[sp,#0x10]
;;;40     	u8 *chunk_data;
;;;41     
;;;42     	yaffs_trace(YAFFS_TRACE_SCAN,
000018  e59f01fc          LDR      r0,|L1.540|
00001c  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
000020  e3100008          TST      r0,#8
000024  0a000003          BEQ      |L1.56|
000028  e28f0e1f          ADR      r0,|L1.544|
00002c  e59510d0          LDR      r1,[r5,#0xd0]
000030  e59520d4          LDR      r2,[r5,#0xd4]
000034  ebfffffe          BL       sysprintf
                  |L1.56|
;;;43     		"yaffs1_scan starts  intstartblk %d intendblk %d...",
;;;44     		dev->internal_start_block, dev->internal_end_block);
;;;45     
;;;46     	chunk_data = yaffs_get_temp_buffer(dev);
000038  e1a00005          MOV      r0,r5
00003c  ebfffffe          BL       yaffs_get_temp_buffer
000040  e58d000c          STR      r0,[sp,#0xc]
;;;47     
;;;48     	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
000044  e3a00a01          MOV      r0,#0x1000
000048  e5850df0          STR      r0,[r5,#0xdf0]
;;;49     
;;;50     	/* Scan all the blocks to determine their state */
;;;51     	bi = dev->block_info;
00004c  e5956118          LDR      r6,[r5,#0x118]
;;;52     	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
000050  e59590d0          LDR      r9,[r5,#0xd0]
000054  ea000048          B        |L1.380|
                  |L1.88|
;;;53     	     blk++) {
;;;54     		yaffs_clear_chunk_bits(dev, blk);
000058  e1a01009          MOV      r1,r9
00005c  e1a00005          MOV      r0,r5
000060  ebfffffe          BL       yaffs_clear_chunk_bits
;;;55     		bi->pages_in_use = 0;
000064  e5960000          LDR      r0,[r6,#0]
000068  e3c00703          BIC      r0,r0,#0xc0000
00006c  e3c00bff          BIC      r0,r0,#0x3fc00
000070  e5860000          STR      r0,[r6,#0]
;;;56     		bi->soft_del_pages = 0;
000074  e5960000          LDR      r0,[r6,#0]
000078  e1a00520          LSR      r0,r0,#10
00007c  e1a00500          LSL      r0,r0,#10
000080  e5860000          STR      r0,[r6,#0]
;;;57     
;;;58     		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
000084  e28d3018          ADD      r3,sp,#0x18
000088  e28d2024          ADD      r2,sp,#0x24
00008c  e1a01009          MOV      r1,r9
000090  e1a00005          MOV      r0,r5
000094  ebfffffe          BL       yaffs_query_init_block_state
;;;59     
;;;60     		bi->block_state = state;
000098  e5960000          LDR      r0,[r6,#0]
00009c  e3c0060f          BIC      r0,r0,#0xf00000
0000a0  e5dd1024          LDRB     r1,[sp,#0x24]
0000a4  e3a0260f          MOV      r2,#0xf00000
0000a8  e0021a01          AND      r1,r2,r1,LSL #20
0000ac  e1800001          ORR      r0,r0,r1
0000b0  e5860000          STR      r0,[r6,#0]
;;;61     		bi->seq_number = seq_number;
0000b4  e59d0018          LDR      r0,[sp,#0x18]
0000b8  e5860004          STR      r0,[r6,#4]
;;;62     
;;;63     		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
0000bc  e5960004          LDR      r0,[r6,#4]
0000c0  e3700801          CMN      r0,#0x10000
0000c4  1a000006          BNE      |L1.228|
;;;64     			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
0000c8  e3a01009          MOV      r1,#9
0000cc  e58d1024          STR      r1,[sp,#0x24]
0000d0  e0020a01          AND      r0,r2,r1,LSL #20
0000d4  e5961000          LDR      r1,[r6,#0]
0000d8  e3c1160f          BIC      r1,r1,#0xf00000
0000dc  e1811000          ORR      r1,r1,r0
0000e0  e5861000          STR      r1,[r6,#0]
                  |L1.228|
;;;65     
;;;66     		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
0000e4  e59f0130          LDR      r0,|L1.540|
0000e8  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
0000ec  e3100a02          TST      r0,#0x2000
0000f0  0a000004          BEQ      |L1.264|
0000f4  e59d3018          LDR      r3,[sp,#0x18]
0000f8  e5dd2024          LDRB     r2,[sp,#0x24]
0000fc  e1a01009          MOV      r1,r9
000100  e28f0f55          ADR      r0,|L1.604|
000104  ebfffffe          BL       sysprintf
                  |L1.264|
;;;67     			"Block scanning block %d state %d seq %d",
;;;68     			blk, state, seq_number);
;;;69     
;;;70     		if (state == YAFFS_BLOCK_STATE_DEAD) {
000108  e5dd0024          LDRB     r0,[sp,#0x24]
00010c  e3500009          CMP      r0,#9
000110  1a000007          BNE      |L1.308|
;;;71     			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
000114  e59f0100          LDR      r0,|L1.540|
000118  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
00011c  e3100010          TST      r0,#0x10
000120  0a000013          BEQ      |L1.372|
000124  e1a01009          MOV      r1,r9
000128  e28f0f57          ADR      r0,|L1.652|
00012c  ebfffffe          BL       sysprintf
000130  ea00000f          B        |L1.372|
                  |L1.308|
;;;72     				"block %d is bad", blk);
;;;73     		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
000134  e5dd0024          LDRB     r0,[sp,#0x24]
000138  e3500003          CMP      r0,#3
00013c  1a00000c          BNE      |L1.372|
;;;74     			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
000140  e59f00d4          LDR      r0,|L1.540|
000144  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
000148  e3100a02          TST      r0,#0x2000
00014c  0a000001          BEQ      |L1.344|
000150  e28f0f53          ADR      r0,|L1.676|
000154  ebfffffe          BL       sysprintf
                  |L1.344|
;;;75     			dev->n_erased_blocks++;
000158  e5950128          LDR      r0,[r5,#0x128]
00015c  e2800001          ADD      r0,r0,#1
000160  e5850128          STR      r0,[r5,#0x128]
;;;76     			dev->n_free_chunks += dev->param.chunks_per_block;
000164  e5950d4c          LDR      r0,[r5,#0xd4c]
000168  e595100c          LDR      r1,[r5,#0xc]
00016c  e0800001          ADD      r0,r0,r1
000170  e5850d4c          STR      r0,[r5,#0xd4c]
                  |L1.372|
;;;77     		}
;;;78     		bi++;
000174  e2866008          ADD      r6,r6,#8
000178  e2899001          ADD      r9,r9,#1              ;53
                  |L1.380|
00017c  e59500d4          LDR      r0,[r5,#0xd4]         ;52
000180  e1500009          CMP      r0,r9                 ;52
000184  aaffffb3          BGE      |L1.88|
;;;79     	}
;;;80     
;;;81     	/* For each block.... */
;;;82     	for (blk = dev->internal_start_block;
000188  e59590d0          LDR      r9,[r5,#0xd0]
00018c  ea000206          B        |L1.2476|
                  |L1.400|
;;;83     	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
;;;84     
;;;85     		cond_resched();
000190  e1a00000          MOV      r0,r0
000194  e1a00000          MOV      r0,r0
;;;86     
;;;87     		bi = yaffs_get_block_info(dev, blk);
000198  e1a0b009          MOV      r11,r9
00019c  e59500d0          LDR      r0,[r5,#0xd0]
0001a0  e150000b          CMP      r0,r11
0001a4  ca000002          BGT      |L1.436|
0001a8  e59500d4          LDR      r0,[r5,#0xd4]
0001ac  e150000b          CMP      r0,r11
0001b0  aa00000c          BGE      |L1.488|
                  |L1.436|
0001b4  e59f0060          LDR      r0,|L1.540|
0001b8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0001bc  e3100101          TST      r0,#0x40000000
0001c0  0a000002          BEQ      |L1.464|
0001c4  e1a0100b          MOV      r1,r11
0001c8  e28f00ec          ADR      r0,|L1.700|
0001cc  ebfffffe          BL       sysprintf
                  |L1.464|
0001d0  e1a00000          MOV      r0,r0
0001d4  e3a0201f          MOV      r2,#0x1f
0001d8  e28f1f46          ADR      r1,|L1.760|
0001dc  e28f0f54          ADD      r0,pc,#0x54, 30 ; #0x150
0001e0  ebfffffe          BL       sysprintf
0001e4  e1a00000          MOV      r0,r0
                  |L1.488|
0001e8  e1a00000          MOV      r0,r0
0001ec  e59510d0          LDR      r1,[r5,#0xd0]
0001f0  e04b1001          SUB      r1,r11,r1
0001f4  e5950118          LDR      r0,[r5,#0x118]
0001f8  e0806181          ADD      r6,r0,r1,LSL #3
;;;88     		state = bi->block_state;
0001fc  e5960000          LDR      r0,[r6,#0]
000200  e1a00400          LSL      r0,r0,#8
000204  e1a00e20          LSR      r0,r0,#28
000208  e58d0024          STR      r0,[sp,#0x24]
;;;89     
;;;90     		deleted = 0;
00020c  e3a00000          MOV      r0,#0
000210  e58d0028          STR      r0,[sp,#0x28]
;;;91     
;;;92     		/* For each chunk in each block that needs scanning.... */
;;;93     		for (c = 0;
000214  e3a0a000          MOV      r10,#0
000218  ea0001b8          B        |L1.2304|
                  |L1.540|
                          DCD      yaffs_trace_mask
                  |L1.544|
000220  79616666          DCB      "yaffs: yaffs1_scan starts  intstartblk %d intendblk %d."
000224  733a2079
000228  61666673
00022c  315f7363
000230  616e2073
000234  74617274
000238  73202069
00023c  6e747374
000240  61727462
000244  6c6b2025
000248  6420696e
00024c  74656e64
000250  626c6b20
000254  25642e  
000257  2e2e0a00          DCB      "..\n",0
00025b  00                DCB      0
                  |L1.604|
00025c  79616666          DCB      "yaffs: Block scanning block %d state %d seq %d\n",0
000260  733a2042
000264  6c6f636b
000268  20736361
00026c  6e6e696e
000270  6720626c
000274  6f636b20
000278  25642073
00027c  74617465
000280  20256420
000284  73657120
000288  25640a00
                  |L1.652|
00028c  79616666          DCB      "yaffs: block %d is bad\n",0
000290  733a2062
000294  6c6f636b
000298  20256420
00029c  69732062
0002a0  61640a00
                  |L1.676|
0002a4  79616666          DCB      "yaffs: Block empty \n",0
0002a8  733a2042
0002ac  6c6f636b
0002b0  20656d70
0002b4  7479200a
0002b8  00      
0002b9  00                DCB      0
0002ba  00                DCB      0
0002bb  00                DCB      0
                  |L1.700|
0002bc  79616666          DCB      "yaffs: **>> yaffs: get_block_info block %d is not valid"
0002c0  733a202a
0002c4  2a3e3e20
0002c8  79616666
0002cc  733a2067
0002d0  65745f62
0002d4  6c6f636b
0002d8  5f696e66
0002dc  6f20626c
0002e0  6f636b20
0002e4  25642069
0002e8  73206e6f
0002ec  74207661
0002f0  6c6964  
0002f3  0a00              DCB      "\n",0
0002f5  00                DCB      0
0002f6  00                DCB      0
0002f7  00                DCB      0
                  |L1.760|
0002f8  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\yaffs_get"
0002fc  2e5c636f
000300  6d6d6f6e
000304  5c737263
000308  5c425350
00030c  5c546869
000310  72645061
000314  7274795c
000318  79616666
00031c  73325c79
000320  61666673
000324  5f676574
000328  626c6f63          DCB      "blockinfo.h",0
00032c  6b696e66
000330  6f2e6800
000334  552d426f          DCB      "U-Boot BUG at %s:%d!\n",0
000338  6f742042
00033c  55472061
000340  74202573
000344  3a256421
000348  0a00    
00034a  00                DCB      0
00034b  00                DCB      0
                  |L1.844|
;;;94     			!alloc_failed && c < dev->param.chunks_per_block &&
;;;95     			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
;;;96     			/* Read the tags and decide what to do */
;;;97     			chunk = blk * dev->param.chunks_per_block + c;
00034c  e595000c          LDR      r0,[r5,#0xc]
000350  e020a099          MLA      r0,r9,r0,r10
000354  e58d002c          STR      r0,[sp,#0x2c]
;;;98     
;;;99     			yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
000358  e28d3030          ADD      r3,sp,#0x30
00035c  e3a02000          MOV      r2,#0
000360  e1a00005          MOV      r0,r5
000364  e59d102c          LDR      r1,[sp,#0x2c]
000368  ebfffffe          BL       yaffs_rd_chunk_tags_nand
;;;100    
;;;101    			/* Let's have a good look at this chunk... */
;;;102    
;;;103    			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
00036c  e5dd0040          LDRB     r0,[sp,#0x40]
000370  e3500003          CMP      r0,#3
000374  0a000002          BEQ      |L1.900|
;;;104    			    tags.is_deleted) {
000378  e59d0048          LDR      r0,[sp,#0x48]
00037c  e3500000          CMP      r0,#0
000380  0a000006          BEQ      |L1.928|
                  |L1.900|
;;;105    				/* YAFFS1 only...
;;;106    				 * A deleted chunk
;;;107    				 */
;;;108    				deleted++;
000384  e59d0028          LDR      r0,[sp,#0x28]
000388  e2800001          ADD      r0,r0,#1
00038c  e58d0028          STR      r0,[sp,#0x28]
;;;109    				dev->n_free_chunks++;
000390  e5950d4c          LDR      r0,[r5,#0xd4c]
000394  e2800001          ADD      r0,r0,#1
000398  e5850d4c          STR      r0,[r5,#0xd4c]
00039c  ea000156          B        |L1.2300|
                  |L1.928|
;;;110    			} else if (!tags.chunk_used) {
0003a0  e59d0030          LDR      r0,[sp,#0x30]
0003a4  e3500000          CMP      r0,#0
0003a8  1a00001a          BNE      |L1.1048|
;;;111    				/* An unassigned chunk in the block
;;;112    				 * This means that either the block is empty or
;;;113    				 * this is the one being allocated from
;;;114    				 */
;;;115    
;;;116    				if (c == 0) {
0003ac  e35a0000          CMP      r10,#0
0003b0  1a000005          BNE      |L1.972|
;;;117    					/* We're looking at the first chunk in
;;;118    					 *the block so the block is unused */
;;;119    					state = YAFFS_BLOCK_STATE_EMPTY;
0003b4  e3a00003          MOV      r0,#3
0003b8  e58d0024          STR      r0,[sp,#0x24]
;;;120    					dev->n_erased_blocks++;
0003bc  e5950128          LDR      r0,[r5,#0x128]
0003c0  e2800001          ADD      r0,r0,#1
0003c4  e5850128          STR      r0,[r5,#0x128]
0003c8  ea00000c          B        |L1.1024|
                  |L1.972|
;;;121    				} else {
;;;122    					/* this is the block being allocated */
;;;123    					yaffs_trace(YAFFS_TRACE_SCAN,
0003cc  e51f01b8          LDR      r0,|L1.540|
0003d0  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
0003d4  e3100008          TST      r0,#8
0003d8  0a000003          BEQ      |L1.1004|
0003dc  e1a0200a          MOV      r2,r10
0003e0  e1a01009          MOV      r1,r9
0003e4  e28f0fc3          ADR      r0,|L1.1784|
0003e8  ebfffffe          BL       sysprintf
                  |L1.1004|
;;;124    						" Allocating from %d %d",
;;;125    						blk, c);
;;;126    					state = YAFFS_BLOCK_STATE_ALLOCATING;
0003ec  e3a00004          MOV      r0,#4
0003f0  e58d0024          STR      r0,[sp,#0x24]
;;;127    					dev->alloc_block = blk;
0003f4  e585912c          STR      r9,[r5,#0x12c]
;;;128    					dev->alloc_page = c;
0003f8  e585a130          STR      r10,[r5,#0x130]
;;;129    					dev->alloc_block_finder = blk;
0003fc  e5859134          STR      r9,[r5,#0x134]
                  |L1.1024|
;;;130    
;;;131    				}
;;;132    
;;;133    				dev->n_free_chunks +=
000400  e595100c          LDR      r1,[r5,#0xc]
000404  e041100a          SUB      r1,r1,r10
000408  e5950d4c          LDR      r0,[r5,#0xd4c]
00040c  e0800001          ADD      r0,r0,r1
000410  e5850d4c          STR      r0,[r5,#0xd4c]
000414  ea000138          B        |L1.2300|
                  |L1.1048|
;;;134    				    (dev->param.chunks_per_block - c);
;;;135    			} else if (tags.chunk_id > 0) {
000418  e59d0038          LDR      r0,[sp,#0x38]
00041c  e3500000          CMP      r0,#0
000420  0a00003a          BEQ      |L1.1296|
;;;136    				/* chunk_id > 0 so it is a data chunk... */
;;;137    				unsigned int endpos;
;;;138    
;;;139    				yaffs_set_chunk_bit(dev, blk, c);
000424  e1a0200a          MOV      r2,r10
000428  e1a01009          MOV      r1,r9
00042c  e1a00005          MOV      r0,r5
000430  ebfffffe          BL       yaffs_set_chunk_bit
;;;140    				bi->pages_in_use++;
000434  e5960000          LDR      r0,[r6,#0]
000438  e3c00703          BIC      r0,r0,#0xc0000
00043c  e3c00bff          BIC      r0,r0,#0x3fc00
000440  e5961000          LDR      r1,[r6,#0]
000444  e1a01601          LSL      r1,r1,#12
000448  e3a02001          MOV      r2,#1
00044c  e0821b21          ADD      r1,r2,r1,LSR #22
000450  e59f22c0          LDR      r2,|L1.1816|
000454  e0021501          AND      r1,r2,r1,LSL #10
000458  e1800001          ORR      r0,r0,r1
00045c  e5860000          STR      r0,[r6,#0]
;;;141    
;;;142    				in = yaffs_find_or_create_by_number(dev,
000460  e3a02001          MOV      r2,#1
000464  e1a00005          MOV      r0,r5
000468  e59d1034          LDR      r1,[sp,#0x34]
00046c  ebfffffe          BL       yaffs_find_or_create_by_number
000470  e1a04000          MOV      r4,r0
;;;143    							tags.obj_id,
;;;144    							YAFFS_OBJECT_TYPE_FILE);
;;;145    				/* PutChunkIntoFile checks for a clash
;;;146    				 * (two data chunks with the same chunk_id).
;;;147    				 */
;;;148    
;;;149    				if (!in)
000474  e3540000          CMP      r4,#0
000478  1a000001          BNE      |L1.1156|
;;;150    					alloc_failed = 1;
00047c  e3a00001          MOV      r0,#1
000480  e58d0014          STR      r0,[sp,#0x14]
                  |L1.1156|
;;;151    
;;;152    				if (in) {
000484  e3540000          CMP      r4,#0
000488  0a000008          BEQ      |L1.1200|
;;;153    					if (!yaffs_put_chunk_in_file
00048c  e3a03001          MOV      r3,#1
000490  e1a00004          MOV      r0,r4
000494  e59d1038          LDR      r1,[sp,#0x38]
000498  e59d202c          LDR      r2,[sp,#0x2c]
00049c  ebfffffe          BL       yaffs_put_chunk_in_file
0004a0  e3500000          CMP      r0,#0
0004a4  1a000001          BNE      |L1.1200|
;;;154    					    (in, tags.chunk_id, chunk, 1))
;;;155    						alloc_failed = 1;
0004a8  e3a00001          MOV      r0,#1
0004ac  e58d0014          STR      r0,[sp,#0x14]
                  |L1.1200|
;;;156    				}
;;;157    
;;;158    				endpos =
0004b0  e59d1038          LDR      r1,[sp,#0x38]
0004b4  e2411001          SUB      r1,r1,#1
0004b8  e59d003c          LDR      r0,[sp,#0x3c]
0004bc  e59520a4          LDR      r2,[r5,#0xa4]
0004c0  e02b0291          MLA      r11,r1,r2,r0
;;;159    				    (tags.chunk_id - 1) *
;;;160    				    dev->data_bytes_per_chunk +
;;;161    				    tags.n_bytes;
;;;162    				if (in &&
0004c4  e3540000          CMP      r4,#0
0004c8  0a00000f          BEQ      |L1.1292|
;;;163    				    in->variant_type ==
0004cc  e5d40064          LDRB     r0,[r4,#0x64]
0004d0  e3500001          CMP      r0,#1
0004d4  1a00000c          BNE      |L1.1292|
;;;164    				     YAFFS_OBJECT_TYPE_FILE &&
;;;165    				    in->variant.file_variant.scanned_size <
0004d8  e5942070          LDR      r2,[r4,#0x70]
0004dc  e052200b          SUBS     r2,r2,r11
0004e0  e5941074          LDR      r1,[r4,#0x74]
0004e4  e2d10000          SBCS     r0,r1,#0
0004e8  aa000007          BGE      |L1.1292|
;;;166    				      endpos) {
;;;167    					in->variant.file_variant.scanned_size =
0004ec  e3a00000          MOV      r0,#0
0004f0  e5840074          STR      r0,[r4,#0x74]
0004f4  e584b070          STR      r11,[r4,#0x70]
;;;168    					    endpos;
;;;169    					if (!dev->param.use_header_file_size) {
0004f8  e5950074          LDR      r0,[r5,#0x74]
0004fc  e3500000          CMP      r0,#0
000500  1a000001          BNE      |L1.1292|
;;;170    						in->variant.
000504  e1c407d0          LDRD     r0,r1,[r4,#0x70]
000508  e1c406f8          STRD     r0,r1,[r4,#0x68]
                  |L1.1292|
;;;171    						    file_variant.file_size =
;;;172    						    in->variant.
;;;173    						    file_variant.scanned_size;
;;;174    					}
;;;175    
;;;176    				}
;;;177    			} else {
00050c  ea0000fa          B        |L1.2300|
                  |L1.1296|
;;;178    				/* chunk_id == 0, so it is an ObjectHeader.
;;;179    				 * Make the object
;;;180    				 */
;;;181    				yaffs_set_chunk_bit(dev, blk, c);
000510  e1a0200a          MOV      r2,r10
000514  e1a01009          MOV      r1,r9
000518  e1a00005          MOV      r0,r5
00051c  ebfffffe          BL       yaffs_set_chunk_bit
;;;182    				bi->pages_in_use++;
000520  e5960000          LDR      r0,[r6,#0]
000524  e3c00703          BIC      r0,r0,#0xc0000
000528  e3c00bff          BIC      r0,r0,#0x3fc00
00052c  e5961000          LDR      r1,[r6,#0]
000530  e1a01601          LSL      r1,r1,#12
000534  e3a02001          MOV      r2,#1
000538  e0821b21          ADD      r1,r2,r1,LSR #22
00053c  e59f21d4          LDR      r2,|L1.1816|
000540  e0021501          AND      r1,r2,r1,LSL #10
000544  e1800001          ORR      r0,r0,r1
000548  e5860000          STR      r0,[r6,#0]
;;;183    
;;;184    				yaffs_rd_chunk_tags_nand(dev, chunk,
00054c  e3a03000          MOV      r3,#0
000550  e1a00005          MOV      r0,r5
000554  e59d102c          LDR      r1,[sp,#0x2c]
000558  e59d200c          LDR      r2,[sp,#0xc]
00055c  ebfffffe          BL       yaffs_rd_chunk_tags_nand
;;;185    							 chunk_data, NULL);
;;;186    
;;;187    				oh = (struct yaffs_obj_hdr *)chunk_data;
000560  e59d700c          LDR      r7,[sp,#0xc]
;;;188    
;;;189    				in = yaffs_find_by_number(dev, tags.obj_id);
000564  e1a00005          MOV      r0,r5
000568  e59d1034          LDR      r1,[sp,#0x34]
00056c  ebfffffe          BL       yaffs_find_by_number
000570  e1a04000          MOV      r4,r0
;;;190    				if (in && in->variant_type != oh->type) {
000574  e3540000          CMP      r4,#0
000578  0a000006          BEQ      |L1.1432|
00057c  e5d40064          LDRB     r0,[r4,#0x64]
000580  e5d71000          LDRB     r1,[r7,#0]
000584  e1500001          CMP      r0,r1
000588  0a000002          BEQ      |L1.1432|
;;;191    					/* This should not happen, but somehow
;;;192    					 * Wev'e ended up with an obj_id that
;;;193    					 * has been reused but not yet deleted,
;;;194    					 * and worse still it has changed type.
;;;195    					 * Delete the old object.
;;;196    					 */
;;;197    
;;;198    					yaffs_del_obj(in);
00058c  e1a00004          MOV      r0,r4
000590  ebfffffe          BL       yaffs_del_obj
;;;199    					in = NULL;
000594  e3a04000          MOV      r4,#0
                  |L1.1432|
;;;200    				}
;;;201    
;;;202    				in = yaffs_find_or_create_by_number(dev,
000598  e5d72000          LDRB     r2,[r7,#0]
00059c  e1a00005          MOV      r0,r5
0005a0  e59d1034          LDR      r1,[sp,#0x34]
0005a4  ebfffffe          BL       yaffs_find_or_create_by_number
0005a8  e1a04000          MOV      r4,r0
;;;203    								tags.obj_id,
;;;204    								oh->type);
;;;205    
;;;206    				if (!in)
0005ac  e3540000          CMP      r4,#0
0005b0  1a000001          BNE      |L1.1468|
;;;207    					alloc_failed = 1;
0005b4  e3a00001          MOV      r0,#1
0005b8  e58d0014          STR      r0,[sp,#0x14]
                  |L1.1468|
;;;208    
;;;209    				if (in && oh->shadows_obj > 0) {
0005bc  e3540000          CMP      r4,#0
0005c0  0a000016          BEQ      |L1.1568|
0005c4  e59701f8          LDR      r0,[r7,#0x1f8]
0005c8  e3500000          CMP      r0,#0
0005cc  da000013          BLE      |L1.1568|
;;;210    
;;;211    					struct yaffs_shadow_fixer *fixer;
;;;212    // 					fixer = kmalloc(sizeof(struct yaffs_shadow_fixer),GFP_NOFS);
;;;213    					fixer = yaffs_malloc(sizeof(struct yaffs_shadow_fixer));
0005d0  e3a0000c          MOV      r0,#0xc
0005d4  ebfffffe          BL       yaffs_malloc
0005d8  e1a0b000          MOV      r11,r0
;;;214    					if (fixer) {
0005dc  e35b0000          CMP      r11,#0
0005e0  0a00000d          BEQ      |L1.1564|
;;;215    						fixer->next = shadow_fixers;
0005e4  e59d0010          LDR      r0,[sp,#0x10]
0005e8  e58b0008          STR      r0,[r11,#8]
;;;216    						shadow_fixers = fixer;
0005ec  e58db010          STR      r11,[sp,#0x10]
;;;217    						fixer->obj_id = tags.obj_id;
0005f0  e59d0034          LDR      r0,[sp,#0x34]
0005f4  e58b0000          STR      r0,[r11,#0]
;;;218    						fixer->shadowed_id =
0005f8  e59701f8          LDR      r0,[r7,#0x1f8]
0005fc  e58b0004          STR      r0,[r11,#4]
;;;219    						    oh->shadows_obj;
;;;220    						yaffs_trace(YAFFS_TRACE_SCAN,
000600  e51f03ec          LDR      r0,|L1.540|
000604  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
000608  e3100008          TST      r0,#8
00060c  0a000002          BEQ      |L1.1564|
000610  e28f0f41          ADR      r0,|L1.1820|
000614  e89b0006          LDM      r11,{r1,r2}
000618  ebfffffe          BL       sysprintf
                  |L1.1564|
;;;221    							" Shadow fixer: %d shadows %d",
;;;222    							fixer->obj_id,
;;;223    							fixer->shadowed_id);
;;;224    
;;;225    					}
;;;226    
;;;227    				}
00061c  e1a00000          MOV      r0,r0
                  |L1.1568|
;;;228    
;;;229    				if (in && in->valid) {
000620  e3540000          CMP      r4,#0
000624  0a000019          BEQ      |L1.1680|
000628  e5d40000          LDRB     r0,[r4,#0]
00062c  e1b003a0          LSRS     r0,r0,#7
000630  0a000016          BEQ      |L1.1680|
;;;230    					/* We have already filled this one.
;;;231    					 * We have a duplicate and need to
;;;232    					 * resolve it. */
;;;233    
;;;234    					unsigned existing_serial = in->serial;
000634  e5d4b002          LDRB     r11,[r4,#2]
;;;235    					unsigned new_serial =
000638  e59d004c          LDR      r0,[sp,#0x4c]
00063c  e58d0008          STR      r0,[sp,#8]
;;;236    					    tags.serial_number;
;;;237    
;;;238    					if (((existing_serial + 1) & 3) ==
000640  e28b0001          ADD      r0,r11,#1
000644  e2001003          AND      r1,r0,#3
000648  e59d0008          LDR      r0,[sp,#8]
00064c  e1510000          CMP      r1,r0
000650  1a000008          BNE      |L1.1656|
;;;239    					    new_serial) {
;;;240    						/* Use new one - destroy the
;;;241    						 * exisiting one */
;;;242    						yaffs_chunk_del(dev,
000654  e3a030f4          MOV      r3,#0xf4
000658  e3a02001          MOV      r2,#1
00065c  e1a00005          MOV      r0,r5
000660  e5941028          LDR      r1,[r4,#0x28]
000664  ebfffffe          BL       yaffs_chunk_del
;;;243    								in->hdr_chunk,
;;;244    								1, __LINE__);
;;;245    						in->valid = 0;
000668  e5d40000          LDRB     r0,[r4,#0]
00066c  e3c00080          BIC      r0,r0,#0x80
000670  e5c40000          STRB     r0,[r4,#0]
000674  ea000004          B        |L1.1676|
                  |L1.1656|
;;;246    					} else {
;;;247    						/* Use existing - destroy
;;;248    						 * this one. */
;;;249    						yaffs_chunk_del(dev, chunk, 1,
000678  e3a030fa          MOV      r3,#0xfa
00067c  e3a02001          MOV      r2,#1
000680  e1a00005          MOV      r0,r5
000684  e59d102c          LDR      r1,[sp,#0x2c]
000688  ebfffffe          BL       yaffs_chunk_del
                  |L1.1676|
;;;250    								__LINE__);
;;;251    					}
;;;252    				}
00068c  e1a00000          MOV      r0,r0
                  |L1.1680|
;;;253    
;;;254    				if (in && !in->valid &&
000690  e3540000          CMP      r4,#0
000694  0a00002a          BEQ      |L1.1860|
000698  e5d40000          LDRB     r0,[r4,#0]
00069c  e1b003a0          LSRS     r0,r0,#7
0006a0  1a000027          BNE      |L1.1860|
;;;255    				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
0006a4  e59d0034          LDR      r0,[sp,#0x34]
0006a8  e3500001          CMP      r0,#1
0006ac  0a000002          BEQ      |L1.1724|
;;;256    				     tags.obj_id ==
0006b0  e59d0034          LDR      r0,[sp,#0x34]
0006b4  e3500002          CMP      r0,#2
0006b8  1a000021          BNE      |L1.1860|
                  |L1.1724|
;;;257    				     YAFFS_OBJECTID_LOSTNFOUND)) {
;;;258    					/* We only load some info, don't fiddle
;;;259    					 * with directory structure */
;;;260    					in->valid = 1;
0006bc  e5d40000          LDRB     r0,[r4,#0]
0006c0  e3800080          ORR      r0,r0,#0x80
0006c4  e5c40000          STRB     r0,[r4,#0]
;;;261    					in->variant_type = oh->type;
0006c8  e5d70000          LDRB     r0,[r7,#0]
0006cc  e5c40064          STRB     r0,[r4,#0x64]
;;;262    
;;;263    					in->yst_mode = oh->yst_mode;
0006d0  e597010c          LDR      r0,[r7,#0x10c]
0006d4  e5840034          STR      r0,[r4,#0x34]
;;;264    					yaffs_load_attribs(in, oh);
0006d8  e1a01007          MOV      r1,r7
0006dc  e1a00004          MOV      r0,r4
0006e0  ebfffffe          BL       yaffs_load_attribs
;;;265    					in->hdr_chunk = chunk;
0006e4  e59d002c          LDR      r0,[sp,#0x2c]
0006e8  e5840028          STR      r0,[r4,#0x28]
;;;266    					in->serial = tags.serial_number;
0006ec  e59d004c          LDR      r0,[sp,#0x4c]
0006f0  e5c40002          STRB     r0,[r4,#2]
0006f4  ea000080          B        |L1.2300|
                  |L1.1784|
0006f8  79616666          DCB      "yaffs:  Allocating from %d %d\n",0
0006fc  733a2020
000700  416c6c6f
000704  63617469
000708  6e672066
00070c  726f6d20
000710  25642025
000714  640a00  
000717  00                DCB      0
                  |L1.1816|
                          DCD      0x000ffc00
                  |L1.1820|
00071c  79616666          DCB      "yaffs:  Shadow fixer: %d shadows %d\n",0
000720  733a2020
000724  53686164
000728  6f772066
00072c  69786572
000730  3a202564
000734  20736861
000738  646f7773
00073c  2025640a
000740  00      
000741  00                DCB      0
000742  00                DCB      0
000743  00                DCB      0
                  |L1.1860|
;;;267    
;;;268    				} else if (in && !in->valid) {
000744  e3540000          CMP      r4,#0
000748  0a00006b          BEQ      |L1.2300|
00074c  e5d40000          LDRB     r0,[r4,#0]
000750  e1b003a0          LSRS     r0,r0,#7
000754  1a000068          BNE      |L1.2300|
;;;269    					/* we need to load this info */
;;;270    
;;;271    					in->valid = 1;
000758  e5d40000          LDRB     r0,[r4,#0]
00075c  e3800080          ORR      r0,r0,#0x80
000760  e5c40000          STRB     r0,[r4,#0]
;;;272    					in->variant_type = oh->type;
000764  e5d70000          LDRB     r0,[r7,#0]
000768  e5c40064          STRB     r0,[r4,#0x64]
;;;273    
;;;274    					in->yst_mode = oh->yst_mode;
00076c  e597010c          LDR      r0,[r7,#0x10c]
000770  e5840034          STR      r0,[r4,#0x34]
;;;275    					yaffs_load_attribs(in, oh);
000774  e1a01007          MOV      r1,r7
000778  e1a00004          MOV      r0,r4
00077c  ebfffffe          BL       yaffs_load_attribs
;;;276    					in->hdr_chunk = chunk;
000780  e59d002c          LDR      r0,[sp,#0x2c]
000784  e5840028          STR      r0,[r4,#0x28]
;;;277    					in->serial = tags.serial_number;
000788  e59d004c          LDR      r0,[sp,#0x4c]
00078c  e5c40002          STRB     r0,[r4,#2]
;;;278    
;;;279    					yaffs_set_obj_name_from_oh(in, oh);
000790  e1a01007          MOV      r1,r7
000794  e1a00004          MOV      r0,r4
000798  ebfffffe          BL       yaffs_set_obj_name_from_oh
;;;280    					in->dirty = 0;
00079c  e5d40000          LDRB     r0,[r4,#0]
0007a0  e3c00040          BIC      r0,r0,#0x40
0007a4  e5c40000          STRB     r0,[r4,#0]
;;;281    
;;;282    					/* directory stuff...
;;;283    					 * hook up to parent
;;;284    					 */
;;;285    
;;;286    					parent =
0007a8  e3a02003          MOV      r2,#3
0007ac  e1a00005          MOV      r0,r5
0007b0  e5971004          LDR      r1,[r7,#4]
0007b4  ebfffffe          BL       yaffs_find_or_create_by_number
0007b8  e1a08000          MOV      r8,r0
;;;287    					    yaffs_find_or_create_by_number
;;;288    					    (dev, oh->parent_obj_id,
;;;289    					     YAFFS_OBJECT_TYPE_DIRECTORY);
;;;290    					if (!parent)
0007bc  e3580000          CMP      r8,#0
0007c0  1a000001          BNE      |L1.1996|
;;;291    						alloc_failed = 1;
0007c4  e3a00001          MOV      r0,#1
0007c8  e58d0014          STR      r0,[sp,#0x14]
                  |L1.1996|
;;;292    					if (parent && parent->variant_type ==
0007cc  e3580000          CMP      r8,#0
0007d0  0a00000a          BEQ      |L1.2048|
0007d4  e5d80064          LDRB     r0,[r8,#0x64]
0007d8  e3500000          CMP      r0,#0
0007dc  1a000007          BNE      |L1.2048|
;;;293    					    YAFFS_OBJECT_TYPE_UNKNOWN) {
;;;294    						/* Set up as a directory */
;;;295    						parent->variant_type =
0007e0  e3a00003          MOV      r0,#3
0007e4  e5c80064          STRB     r0,[r8,#0x64]
;;;296    						    YAFFS_OBJECT_TYPE_DIRECTORY;
;;;297    						INIT_LIST_HEAD(&parent->
0007e8  e1a00000          MOV      r0,r0
0007ec  e2880068          ADD      r0,r8,#0x68
0007f0  e5880068          STR      r0,[r8,#0x68]
0007f4  e2880068          ADD      r0,r8,#0x68
0007f8  e588006c          STR      r0,[r8,#0x6c]
0007fc  ea00000b          B        |L1.2096|
                  |L1.2048|
;;;298    							variant.dir_variant.
;;;299    							children);
;;;300    					} else if (!parent ||
000800  e3580000          CMP      r8,#0
000804  0a000002          BEQ      |L1.2068|
;;;301    						parent->variant_type !=
000808  e5d80064          LDRB     r0,[r8,#0x64]
00080c  e3500003          CMP      r0,#3
000810  0a000006          BEQ      |L1.2096|
                  |L1.2068|
;;;302    						YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;303    						/* Hoosterman, a problem....
;;;304    						 * We're trying to use a
;;;305    						 * non-directory as a directory
;;;306    						 */
;;;307    
;;;308    						yaffs_trace(YAFFS_TRACE_ERROR,
000814  e51f0600          LDR      r0,|L1.540|
000818  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00081c  e3100101          TST      r0,#0x40000000
000820  0a000001          BEQ      |L1.2092|
000824  e59f026c          LDR      r0,|L1.2712|
000828  ebfffffe          BL       sysprintf
                  |L1.2092|
;;;309    							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
;;;310    							);
;;;311    						parent = dev->lost_n_found;
00082c  e5958d84          LDR      r8,[r5,#0xd84]
                  |L1.2096|
;;;312    					}
;;;313    
;;;314    					yaffs_add_obj_to_dir(parent, in);
000830  e1a01004          MOV      r1,r4
000834  e1a00008          MOV      r0,r8
000838  ebfffffe          BL       yaffs_add_obj_to_dir
;;;315    
;;;316    					switch (in->variant_type) {
00083c  e5d40064          LDRB     r0,[r4,#0x64]
000840  e3500006          CMP      r0,#6
000844  308ff100          ADDCC    pc,pc,r0,LSL #2
000848  ea00002a          B        |L1.2296|
00084c  ea000004          B        |L1.2148|
000850  ea000005          B        |L1.2156|
000854  ea00001d          B        |L1.2256|
000858  ea000018          B        |L1.2240|
00085c  ea00000a          B        |L1.2188|
000860  ea000018          B        |L1.2248|
                  |L1.2148|
;;;317    					case YAFFS_OBJECT_TYPE_UNKNOWN:
000864  e1a00000          MOV      r0,r0
;;;318    						/* Todo got a problem */
;;;319    						break;
000868  ea000022          B        |L1.2296|
                  |L1.2156|
;;;320    					case YAFFS_OBJECT_TYPE_FILE:
00086c  e1a00000          MOV      r0,r0
;;;321    						if (dev->param.
000870  e5950074          LDR      r0,[r5,#0x74]
000874  e3500000          CMP      r0,#0
000878  0a000002          BEQ      |L1.2184|
;;;322    						    use_header_file_size)
;;;323    							in->variant.
00087c  e1a00007          MOV      r0,r7
000880  ebfffffe          BL       yaffs_oh_to_size
000884  e1c406f8          STRD     r0,r1,[r4,#0x68]
                  |L1.2184|
;;;324    							file_variant.file_size
;;;325    							= yaffs_oh_to_size(oh);
;;;326    						break;
000888  ea00001a          B        |L1.2296|
                  |L1.2188|
;;;327    					case YAFFS_OBJECT_TYPE_HARDLINK:
00088c  e1a00000          MOV      r0,r0
;;;328    						in->variant.
000890  e2841068          ADD      r1,r4,#0x68
000894  e5970128          LDR      r0,[r7,#0x128]
000898  e584006c          STR      r0,[r4,#0x6c]
;;;329    						    hardlink_variant.equiv_id =
;;;330    						    oh->equiv_id;
;;;331    						list_add(&in->hard_links,
00089c  e2840014          ADD      r0,r4,#0x14
0008a0  e28d101c          ADD      r1,sp,#0x1c
0008a4  e5912000          LDR      r2,[r1,#0]
0008a8  e5810000          STR      r0,[r1,#0]
0008ac  e5801004          STR      r1,[r0,#4]
0008b0  e5802000          STR      r2,[r0,#0]
0008b4  e5820004          STR      r0,[r2,#4]
0008b8  e1a00000          MOV      r0,r0
;;;332    								&hard_list);
;;;333    						break;
0008bc  ea00000d          B        |L1.2296|
                  |L1.2240|
;;;334    					case YAFFS_OBJECT_TYPE_DIRECTORY:
0008c0  e1a00000          MOV      r0,r0
;;;335    						/* Do nothing */
;;;336    						break;
0008c4  ea00000b          B        |L1.2296|
                  |L1.2248|
;;;337    					case YAFFS_OBJECT_TYPE_SPECIAL:
0008c8  e1a00000          MOV      r0,r0
;;;338    						/* Do nothing */
;;;339    						break;
0008cc  ea000009          B        |L1.2296|
                  |L1.2256|
;;;340    					case YAFFS_OBJECT_TYPE_SYMLINK:
0008d0  e1a00000          MOV      r0,r0
;;;341    						in->variant.symlink_variant.
0008d4  e2870f4b          ADD      r0,r7,#0x12c
0008d8  ebfffffe          BL       yaffs_clone_str
0008dc  e5840068          STR      r0,[r4,#0x68]
;;;342    						    alias =
;;;343    						    yaffs_clone_str(oh->alias);
;;;344    						if (!in->variant.
0008e0  e5940068          LDR      r0,[r4,#0x68]
0008e4  e3500000          CMP      r0,#0
0008e8  1a000001          BNE      |L1.2292|
;;;345    						    symlink_variant.alias)
;;;346    							alloc_failed = 1;
0008ec  e3a00001          MOV      r0,#1
0008f0  e58d0014          STR      r0,[sp,#0x14]
                  |L1.2292|
;;;347    						break;
0008f4  e1a00000          MOV      r0,r0
                  |L1.2296|
0008f8  e1a00000          MOV      r0,r0                 ;319
                  |L1.2300|
0008fc  e28aa001          ADD      r10,r10,#1            ;95
                  |L1.2304|
000900  e59d0014          LDR      r0,[sp,#0x14]         ;94
000904  e3500000          CMP      r0,#0                 ;94
000908  1a000005          BNE      |L1.2340|
00090c  e595000c          LDR      r0,[r5,#0xc]          ;94
000910  e150000a          CMP      r0,r10                ;94
000914  da000002          BLE      |L1.2340|
000918  e5dd0024          LDRB     r0,[sp,#0x24]         ;95
00091c  e3500002          CMP      r0,#2                 ;95
000920  0afffe89          BEQ      |L1.844|
                  |L1.2340|
;;;348    					}
;;;349    				}
;;;350    			}
;;;351    		}
;;;352    
;;;353    		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
000924  e5dd0024          LDRB     r0,[sp,#0x24]
000928  e3500002          CMP      r0,#2
00092c  1a000001          BNE      |L1.2360|
;;;354    			/* If we got this far while scanning,
;;;355    			 * then the block is fully allocated. */
;;;356    			state = YAFFS_BLOCK_STATE_FULL;
000930  e3a00005          MOV      r0,#5
000934  e58d0024          STR      r0,[sp,#0x24]
                  |L1.2360|
;;;357    		}
;;;358    
;;;359    		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
000938  e5dd0024          LDRB     r0,[sp,#0x24]
00093c  e3500004          CMP      r0,#4
000940  1a000003          BNE      |L1.2388|
;;;360    			/* If the block was partially allocated then
;;;361    			 * treat it as fully allocated. */
;;;362    			state = YAFFS_BLOCK_STATE_FULL;
000944  e3a00005          MOV      r0,#5
000948  e58d0024          STR      r0,[sp,#0x24]
;;;363    			dev->alloc_block = -1;
00094c  e3e00000          MVN      r0,#0
000950  e585012c          STR      r0,[r5,#0x12c]
                  |L1.2388|
;;;364    		}
;;;365    
;;;366    		bi->block_state = state;
000954  e5960000          LDR      r0,[r6,#0]
000958  e3c0060f          BIC      r0,r0,#0xf00000
00095c  e5dd1024          LDRB     r1,[sp,#0x24]
000960  e3a0260f          MOV      r2,#0xf00000
000964  e0021a01          AND      r1,r2,r1,LSL #20
000968  e1800001          ORR      r0,r0,r1
00096c  e5860000          STR      r0,[r6,#0]
;;;367    
;;;368    		/* Now let's see if it was dirty */
;;;369    		if (bi->pages_in_use == 0 &&
000970  e5960000          LDR      r0,[r6,#0]
000974  e1a00600          LSL      r0,r0,#12
000978  e1b00b20          LSRS     r0,r0,#22
00097c  1a000009          BNE      |L1.2472|
;;;370    		    !bi->has_shrink_hdr &&
000980  e5960000          LDR      r0,[r6,#0]
000984  e1b00fa0          LSRS     r0,r0,#31
000988  1a000006          BNE      |L1.2472|
;;;371    		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
00098c  e5960000          LDR      r0,[r6,#0]
000990  e200060f          AND      r0,r0,#0xf00000
000994  e3500605          CMP      r0,#0x500000
000998  1a000002          BNE      |L1.2472|
;;;372    			yaffs_block_became_dirty(dev, blk);
00099c  e1a01009          MOV      r1,r9
0009a0  e1a00005          MOV      r0,r5
0009a4  ebfffffe          BL       yaffs_block_became_dirty
                  |L1.2472|
0009a8  e2899001          ADD      r9,r9,#1              ;83
                  |L1.2476|
0009ac  e59d0014          LDR      r0,[sp,#0x14]         ;83
0009b0  e3500000          CMP      r0,#0                 ;83
0009b4  1a000002          BNE      |L1.2500|
0009b8  e59500d4          LDR      r0,[r5,#0xd4]         ;83
0009bc  e1500009          CMP      r0,r9                 ;83
0009c0  aafffdf2          BGE      |L1.400|
                  |L1.2500|
;;;373    	}
;;;374    
;;;375    	/* Ok, we've done all the scanning.
;;;376    	 * Fix up the hard link chains.
;;;377    	 * We should now have scanned all the objects, now it's time to add
;;;378    	 * these hardlinks.
;;;379    	 */
;;;380    
;;;381    	yaffs_link_fixup(dev, &hard_list);
0009c4  e28d101c          ADD      r1,sp,#0x1c
0009c8  e1a00005          MOV      r0,r5
0009cc  ebfffffe          BL       yaffs_link_fixup
;;;382    
;;;383    	/*
;;;384    	 * Fix up any shadowed objects.
;;;385    	 * There should not be more than one of these.
;;;386    	 */
;;;387    	{
;;;388    		struct yaffs_shadow_fixer *fixer;
;;;389    		struct yaffs_obj *obj;
;;;390    
;;;391    		while (shadow_fixers) {
0009d0  ea00001c          B        |L1.2632|
                  |L1.2516|
;;;392    			fixer = shadow_fixers;
0009d4  e59db010          LDR      r11,[sp,#0x10]
;;;393    			shadow_fixers = fixer->next;
0009d8  e59b0008          LDR      r0,[r11,#8]
0009dc  e58d0010          STR      r0,[sp,#0x10]
;;;394    			/* Complete the rename transaction by deleting the
;;;395    			 * shadowed object then setting the object header
;;;396    			 to unshadowed.
;;;397    			 */
;;;398    			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
0009e0  e1a00005          MOV      r0,r5
0009e4  e59b1004          LDR      r1,[r11,#4]
0009e8  ebfffffe          BL       yaffs_find_by_number
0009ec  e58d0008          STR      r0,[sp,#8]
;;;399    			if (obj)
0009f0  e59d0008          LDR      r0,[sp,#8]
0009f4  e3500000          CMP      r0,#0
0009f8  0a000001          BEQ      |L1.2564|
;;;400    				yaffs_del_obj(obj);
0009fc  e59d0008          LDR      r0,[sp,#8]
000a00  ebfffffe          BL       yaffs_del_obj
                  |L1.2564|
;;;401    
;;;402    			obj = yaffs_find_by_number(dev, fixer->obj_id);
000a04  e1a00005          MOV      r0,r5
000a08  e59b1000          LDR      r1,[r11,#0]
000a0c  ebfffffe          BL       yaffs_find_by_number
000a10  e58d0008          STR      r0,[sp,#8]
;;;403    
;;;404    			if (obj)
000a14  e59d0008          LDR      r0,[sp,#8]
000a18  e3500000          CMP      r0,#0
000a1c  0a000007          BEQ      |L1.2624|
;;;405    				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
000a20  e3a00000          MOV      r0,#0
000a24  e58d0000          STR      r0,[sp,#0]
000a28  e58d0004          STR      r0,[sp,#4]
000a2c  e1a03000          MOV      r3,r0
000a30  e3a02001          MOV      r2,#1
000a34  e1a01000          MOV      r1,r0
000a38  e59d0008          LDR      r0,[sp,#8]
000a3c  ebfffffe          BL       yaffs_update_oh
                  |L1.2624|
;;;406    
;;;407    			yaffs_free(fixer);
000a40  e1a0000b          MOV      r0,r11
000a44  ebfffffe          BL       yaffs_free
                  |L1.2632|
000a48  e59d0010          LDR      r0,[sp,#0x10]         ;391
000a4c  e3500000          CMP      r0,#0                 ;391
000a50  1affffdf          BNE      |L1.2516|
;;;408    		}
;;;409    	}
;;;410    
;;;411    	yaffs_release_temp_buffer(dev, chunk_data);
000a54  e1a00005          MOV      r0,r5
000a58  e59d100c          LDR      r1,[sp,#0xc]
000a5c  ebfffffe          BL       yaffs_release_temp_buffer
;;;412    
;;;413    	if (alloc_failed)
000a60  e59d0014          LDR      r0,[sp,#0x14]
000a64  e3500000          CMP      r0,#0
000a68  0a000002          BEQ      |L1.2680|
;;;414    		return YAFFS_FAIL;
000a6c  e3a00000          MOV      r0,#0
                  |L1.2672|
000a70  e28dd07c          ADD      sp,sp,#0x7c
;;;415    
;;;416    	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
;;;417    
;;;418    	return YAFFS_OK;
;;;419    }
000a74  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.2680|
000a78  e51f0864          LDR      r0,|L1.540|
000a7c  e5d00000          LDRB     r0,[r0,#0]            ;416  ; yaffs_trace_mask
000a80  e3100008          TST      r0,#8                 ;416
000a84  0a000001          BEQ      |L1.2704|
000a88  e28f000c          ADR      r0,|L1.2716|
000a8c  ebfffffe          BL       sysprintf
                  |L1.2704|
000a90  e3a00001          MOV      r0,#1                 ;418
000a94  eafffff5          B        |L1.2672|
                          ENDP

                  |L1.2712|
                          DCD      ||.constdata||
                  |L1.2716|
000a9c  79616666          DCB      "yaffs: yaffs1_scan ends\n",0
000aa0  733a2079
000aa4  61666673
000aa8  315f7363
000aac  616e2065
000ab0  6e64730a
000ab4  00      
000ab5  00                DCB      0
000ab6  00                DCB      0
000ab7  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  79616666          DCB      0x79,0x61,0x66,0x66
000004  733a2079          DCB      0x73,0x3a,0x20,0x79
000008  61666673          DCB      0x61,0x66,0x66,0x73
00000c  20747261          DCB      0x20,0x74,0x72,0x61
000010  67656479          DCB      0x67,0x65,0x64,0x79
000014  3a206174          DCB      0x3a,0x20,0x61,0x74
000018  74656d70          DCB      0x74,0x65,0x6d,0x70
00001c  74696e67          DCB      0x74,0x69,0x6e,0x67
000020  20746f20          DCB      0x20,0x74,0x6f,0x20
000024  75736520          DCB      0x75,0x73,0x65,0x20
000028  6e6f6e2d          DCB      0x6e,0x6f,0x6e,0x2d
00002c  64697265          DCB      0x64,0x69,0x72,0x65
000030  63746f72          DCB      0x63,0x74,0x6f,0x72
000034  79206173          DCB      0x79,0x20,0x61,0x73
000038  20612064          DCB      0x20,0x61,0x20,0x64
00003c  69726563          DCB      0x69,0x72,0x65,0x63
000040  746f7279          DCB      0x74,0x6f,0x72,0x79
000044  20696e20          DCB      0x20,0x69,0x6e,0x20
000048  7363616e          DCB      0x73,0x63,0x61,0x6e
00004c  2e205075          DCB      0x2e,0x20,0x50,0x75
000050  7420696e          DCB      0x74,0x20,0x69,0x6e
000054  206c6f73          DCB      0x20,0x6c,0x6f,0x73
000058  742b666f          DCB      0x74,0x2b,0x66,0x6f
00005c  756e642e          DCB      0x75,0x6e,0x64,0x2e
000060  0a00              DCB      0x0a,0x00
