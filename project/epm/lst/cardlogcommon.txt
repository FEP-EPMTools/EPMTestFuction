; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\cardlogcommon.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\cardlogcommon.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\cardlogcommon.crf src\syshal\cardlog\cardlogcommon.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  CardLogUint32ToHexString PROC
;;;87     
;;;88     void CardLogUint32ToHexString(char* debugStr, uint32_t value, uint8_t* str, int strSize)
000000  e92d40fe          PUSH     {r1-r7,lr}
;;;89     {    
000004  e1a07000          MOV      r7,r0
000008  e1a05001          MOV      r5,r1
00000c  e1a06002          MOV      r6,r2
000010  e1a04003          MOV      r4,r3
;;;90         //最多8個字元
;;;91         char tmp[TRANSFER_MAX_LEN+1];
;;;92         #if(ENABLE_CARDLOG_DEBUG)
;;;93         sysprintf("CardLogUint32ToHexString [%s](strSize = %d):[%d, %X]\r\n", debugStr, strSize, value, value);  
;;;94         #endif    
;;;95         sprintf(tmp, "%08X", value);  
000014  e1a02005          MOV      r2,r5
000018  e28f1f6d          ADR      r1,|L1.468|
00001c  e1a0000d          MOV      r0,sp
000020  ebfffffe          BL       __2sprintf
;;;96         //sysprintf("[%d:%c, %c(%s)]\r\n", TRANSFER_MAX_LEN-strSize, tmp[TRANSFER_MAX_LEN-strSize], tmp[TRANSFER_MAX_LEN-strSize + 1], tmp);    
;;;97         memcpy(str, &tmp[TRANSFER_MAX_LEN-strSize], strSize*sizeof(char));//只有cpy 最後的幾格字元
000024  e1a02004          MOV      r2,r4
000028  e2640008          RSB      r0,r4,#8
00002c  e1a0300d          MOV      r3,sp
000030  e0801003          ADD      r1,r0,r3
000034  e1a00006          MOV      r0,r6
000038  ebfffffe          BL       __aeabi_memcpy
;;;98     }
00003c  e8bd80fe          POP      {r1-r7,pc}
;;;99     void CardLogUint32ToDosTime(char* debugStr, uint32_t value, uint8_t* str, int strSize)
                          ENDP

                  CardLogHexBuffToUint32 PROC
;;;111    
;;;112    uint32_t CardLogHexBuffToUint32(uint8_t* buff, int buffSize)
000040  e92d4010          PUSH     {r4,lr}
;;;113    {    
000044  e1a02000          MOV      r2,r0
;;;114        uint32_t value = 0;
000048  e3a03000          MOV      r3,#0
;;;115        for(int i = 0; i<buffSize; i++)
00004c  e3a00000          MOV      r0,#0
000050  ea000005          B        |L1.108|
                  |L1.84|
;;;116        {
;;;117            value = value | (buff[(buffSize - 1)- i]<<(8*i));
000054  e241c001          SUB      r12,r1,#1
000058  e04cc000          SUB      r12,r12,r0
00005c  e7d2c00c          LDRB     r12,[r2,r12]
000060  e1a04180          LSL      r4,r0,#3
000064  e183341c          ORR      r3,r3,r12,LSL r4
000068  e2800001          ADD      r0,r0,#1              ;115
                  |L1.108|
00006c  e1500001          CMP      r0,r1                 ;115
000070  bafffff7          BLT      |L1.84|
;;;118        }
;;;119        return value;
000074  e1a00003          MOV      r0,r3
;;;120    }
000078  e8bd8010          POP      {r4,pc}
;;;121    
                          ENDP

                  CardLogCSNToHexString PROC
;;;49     /*-----------------------------------------*/
;;;50     void CardLogCSNToHexString(char* debugStr, uint8_t* value, uint8_t* str)
00007c  e92d41f0          PUSH     {r4-r8,lr}
;;;51     {    
000080  e1a08000          MOV      r8,r0
000084  e1a05001          MOV      r5,r1
000088  e1a06002          MOV      r6,r2
;;;52         //最多32個字元
;;;53         int i;
;;;54         #if(ENABLE_CARDLOG_DEBUG)
;;;55         sysprintf("CardLogUint32ToHexString [%s](strSize = %d):[%d, %X]\r\n", debugStr, strSize, value, value);  
;;;56         #endif    
;;;57         for(i = 0; i<4; i++)
00008c  e3a04000          MOV      r4,#0
000090  ea000009          B        |L1.188|
                  |L1.148|
;;;58         {
;;;59             uint32_t uint32Value = CardLogHexBuffToUint32(&value[i*4], 4);
000094  e0850104          ADD      r0,r5,r4,LSL #2
000098  e3a01004          MOV      r1,#4
00009c  ebfffffe          BL       CardLogHexBuffToUint32
0000a0  e1a07000          MOV      r7,r0
;;;60             CardLogUint32ToHexString("uint32Value", uint32Value, str + i*8, 8);
0000a4  e0862184          ADD      r2,r6,r4,LSL #3
0000a8  e3a03008          MOV      r3,#8
0000ac  e1a01007          MOV      r1,r7
0000b0  e28f0f49          ADR      r0,|L1.476|
0000b4  ebfffffe          BL       CardLogUint32ToHexString
0000b8  e2844001          ADD      r4,r4,#1              ;57
                  |L1.188|
0000bc  e3540004          CMP      r4,#4                 ;57
0000c0  bafffff3          BLT      |L1.148|
;;;61         }
;;;62     }
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP

                  CardLogBuffToUint32 PROC
;;;64     uint32_t CardLogBuffToUint32(uint8_t* buff, int buffSize)
0000c8  e92d4010          PUSH     {r4,lr}
;;;65     {    
0000cc  e1a02000          MOV      r2,r0
;;;66         uint32_t value = 0;
0000d0  e3a03000          MOV      r3,#0
;;;67         for(int i = 0; i<buffSize; i++)
0000d4  e3a00000          MOV      r0,#0
0000d8  ea000003          B        |L1.236|
                  |L1.220|
;;;68         {
;;;69             value = value + (buff[i]<<(8*i));
0000dc  e7d2c000          LDRB     r12,[r2,r0]
0000e0  e1a04180          LSL      r4,r0,#3
0000e4  e083341c          ADD      r3,r3,r12,LSL r4
0000e8  e2800001          ADD      r0,r0,#1              ;67
                  |L1.236|
0000ec  e1500001          CMP      r0,r1                 ;67
0000f0  bafffff9          BLT      |L1.220|
;;;70         }
;;;71         return value;
0000f4  e1a00003          MOV      r0,r3
;;;72     }
0000f8  e8bd8010          POP      {r4,pc}
;;;73     
                          ENDP

                  CardLogUint32ToString PROC
;;;74     #define TRANSFER_MAX_LEN  8
;;;75     void CardLogUint32ToString(char* debugStr, uint32_t value, uint8_t* str, int strSize)
0000fc  e92d40fe          PUSH     {r1-r7,lr}
;;;76     {    
000100  e1a07000          MOV      r7,r0
000104  e1a05001          MOV      r5,r1
000108  e1a06002          MOV      r6,r2
00010c  e1a04003          MOV      r4,r3
;;;77         //最多8個字元
;;;78         char tmp[TRANSFER_MAX_LEN+1];
;;;79         #if(ENABLE_CARDLOG_DEBUG)
;;;80         sysprintf("CardLogUint32ToString [%s](strSize = %d):[%d, %X]\r\n", debugStr, strSize, value, value);  
;;;81         #endif    
;;;82         sprintf(tmp, "%08d", value);   
000110  e1a02005          MOV      r2,r5
000114  e28f10cc          ADR      r1,|L1.488|
000118  e1a0000d          MOV      r0,sp
00011c  ebfffffe          BL       __2sprintf
;;;83         //sysprintf("[%d:%c, %c (%s)]\r\n", TRANSFER_MAX_LEN-strSize, tmp[TRANSFER_MAX_LEN-strSize], tmp[TRANSFER_MAX_LEN-strSize + 1], tmp); 
;;;84         memcpy(str, &tmp[TRANSFER_MAX_LEN-strSize], strSize*sizeof(char));//只有cpy 最後的幾格字元
000120  e1a02004          MOV      r2,r4
000124  e2640008          RSB      r0,r4,#8
000128  e1a0300d          MOV      r3,sp
00012c  e0801003          ADD      r1,r0,r3
000130  e1a00006          MOV      r0,r6
000134  ebfffffe          BL       __aeabi_memcpy
;;;85         
;;;86     }
000138  e8bd80fe          POP      {r1-r7,pc}
;;;87     
                          ENDP

                  CardLogUint32ToDosTime PROC
;;;98     }
;;;99     void CardLogUint32ToDosTime(char* debugStr, uint32_t value, uint8_t* str, int strSize)
00013c  e92d41ff          PUSH     {r0-r8,lr}
;;;100    {    
000140  e1a07000          MOV      r7,r0
000144  e1a04001          MOV      r4,r1
000148  e1a06002          MOV      r6,r2
00014c  e1a05003          MOV      r5,r3
;;;101        //最多8個字元
;;;102        char tmp[TRANSFER_MAX_LEN+1];
;;;103        #if(ENABLE_CARDLOG_DEBUG)
;;;104        sysprintf("CardLogUint32ToDosTime [%s](strSize = %d):[%d, %X]\r\n", debugStr, strSize, value, value);  
;;;105        #endif    
;;;106        sprintf(tmp, "%04d%02d%02d", (value>>9)&0x7f + 1980, (value>>5)&0xf, value&0x1f);  
000150  e204001f          AND      r0,r4,#0x1f
000154  e58d0000          STR      r0,[sp,#0]
000158  e3a0000f          MOV      r0,#0xf
00015c  e00032a4          AND      r3,r0,r4,LSR #5
000160  e59f0088          LDR      r0,|L1.496|
000164  e00024a4          AND      r2,r0,r4,LSR #9
000168  e28f1084          ADR      r1,|L1.500|
00016c  e28d0004          ADD      r0,sp,#4
000170  ebfffffe          BL       __2sprintf
;;;107        //sysprintf("[%d:%c, %c(%s)]\r\n", TRANSFER_MAX_LEN-strSize, tmp[TRANSFER_MAX_LEN-strSize], tmp[TRANSFER_MAX_LEN-strSize + 1], tmp);    
;;;108        memcpy(str, &tmp[TRANSFER_MAX_LEN-strSize], strSize*sizeof(char));//只有cpy 最後的幾格字元
000174  e1a02005          MOV      r2,r5
000178  e2650008          RSB      r0,r5,#8
00017c  e28d3004          ADD      r3,sp,#4
000180  e0801003          ADD      r1,r0,r3
000184  e1a00006          MOV      r0,r6
000188  ebfffffe          BL       __aeabi_memcpy
;;;109    }
00018c  e8bd81ff          POP      {r0-r8,pc}
;;;110    
                          ENDP

                  CardLogFillSeparator PROC
;;;121    
;;;122    void CardLogFillSeparator(IPassSeparator* separator)
000190  e59f106c          LDR      r1,|L1.516|
;;;123    {
;;;124        memcpy(separator, &separatorData, sizeof(IPassSeparator));
000194  e5d12000          LDRB     r2,[r1,#0]  ; separatorData
000198  e5c02000          STRB     r2,[r0,#0]
00019c  e5d11001          LDRB     r1,[r1,#1]  ; separatorData
0001a0  e5c01001          STRB     r1,[r0,#1]
;;;125    }
0001a4  e12fff1e          BX       lr
;;;126    void CardLogFillSpace(uint8_t* data, int size)
                          ENDP

                  CardLogFillSpace PROC
0001a8  e92d4070          PUSH     {r4-r6,lr}
;;;127    {
0001ac  e1a04000          MOV      r4,r0
0001b0  e1a05001          MOV      r5,r1
;;;128        sysprintf("fillSpace(%d)\r\n", size);
0001b4  e1a01005          MOV      r1,r5
0001b8  e28f0048          ADR      r0,|L1.520|
0001bc  ebfffffe          BL       sysprintf
;;;129        memset(data, ' ', size);
0001c0  e3a02020          MOV      r2,#0x20
0001c4  e1a01005          MOV      r1,r5
0001c8  e1a00004          MOV      r0,r4
0001cc  ebfffffe          BL       __aeabi_memset
;;;130    }
0001d0  e8bd8070          POP      {r4-r6,pc}
;;;131    
                          ENDP

                  |L1.468|
0001d4  25303858          DCB      "%08X",0
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L1.476|
0001dc  75696e74          DCB      "uint32Value",0
0001e0  33325661
0001e4  6c756500
                  |L1.488|
0001e8  25303864          DCB      "%08d",0
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L1.496|
                          DCD      0x0000083b
                  |L1.500|
0001f4  25303464          DCB      "%04d%02d%02d",0
0001f8  25303264
0001fc  25303264
000200  00      
000201  00                DCB      0
000202  00                DCB      0
000203  00                DCB      0
                  |L1.516|
                          DCD      separatorData
                  |L1.520|
000208  66696c6c          DCB      "fillSpace(%d)\r\n",0
00020c  53706163
000210  65282564
000214  290d0a00

                          AREA ||.data||, DATA, ALIGN=0

                  separatorData
000000  0d0a              DCB      0x0d,0x0a
