L 1 "src\user\hwtester.c"
N/**************************************************************************//**
N* @file     hwtester.c
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N#include <stdio.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 12 "src\user\hwtester.c" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 13 "src\user\hwtester.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 14 "src\user\hwtester.c" 2
N#include "nuc970.h"
L 1 "..\..\common\src\BSP\Driver\Include\nuc970.h" 1
N/**************************************************************************//**
N * @file     nuc970.h
N * @version  V1.00
N * $Revision: 30 $
N * $Date: 15/06/12 2:51p $
N * @brief    NUC970 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro NUC970 MCU.
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro NUC970 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of NUC970 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N   */
N/**
N  * \page pg1 Revision History
N  *
N  * <b>Revision 1.00.000</b>
N  * \li Added 2D, CAN, CAP, JPEG, KPI, LCD, NAND, RTC, SC, SCUART drivers and sample codes
N  * \li Added USBH UAC class support
N  * \li Fixed compilation warnings
N  *
N  * <b>Revision 0.09.000</b>
N  * \li Preliminary release.
N*/
N#ifndef __NUC970_H__
N#define __NUC970_H__
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 67 "..\..\common\src\BSP\Driver\Include\nuc970.h" 2
N
N/** @addtogroup NUC970_PERIPHERAL_MEM_MAP NUC970 Peripheral Memory Base
N  Memory Mapped Structure for NUC970 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N#define    CRPT_BA   0xB000F000  /*!< Crypto Engine Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    KPI_BA    0xB8008000  /*!< Keypad Interface Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N#define    MTP_BA    0xB800C000  /*!< MTP Control */
N
N/*@}*/ /* end of group NUC970_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup NUC970_Peripherals NUC970 Control Register
N  NUC970 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N/*---------------------- Cryptographic Accelerator -------------------------*/
N/**
N    @addtogroup CRYPTO Cryptographic Accelerator(CRYPTO)
N    Memory Mapped Structure for Cryptographic Accelerator registers
N@{ */
N
N/* Crypto Control Registers */
N#define     CRPT_INTEN          (CRPT_BA+0x000)  /*!< Crypto Interrupt Enable Control Register      */
N#define     CRPT_INTSTS         (CRPT_BA+0x004)  /*!< Crypto Interrupt Flag                         */
N
N/* PRNG Registers */
N#define     CRPT_PRNG_CTL       (CRPT_BA+0x008)  /*!< PRNG Control Register                         */
N#define     CRPT_PRNG_SEED      (CRPT_BA+0x00C)  /*!< Seed for PRNG                                 */
N#define     CRPT_PRNG_KEY0      (CRPT_BA+0x010)  /*!< PRNG Generated Key 0                          */
N#define     CRPT_PRNG_KEY1      (CRPT_BA+0x014)  /*!< PRNG Generated Key 1                          */
N#define     CRPT_PRNG_KEY2      (CRPT_BA+0x018)  /*!< PRNG Generated Key 2                          */
N#define     CRPT_PRNG_KEY3      (CRPT_BA+0x01C)  /*!< PRNG Generated Key 3                          */
N#define     CRPT_PRNG_KEY4      (CRPT_BA+0x020)  /*!< PRNG Generated Key 4                          */
N#define     CRPT_PRNG_KEY5      (CRPT_BA+0x024)  /*!< PRNG Generated Key 5                          */
N#define     CRPT_PRNG_KEY6      (CRPT_BA+0x028)  /*!< PRNG Generated Key 6                          */
N#define     CRPT_PRNG_KEY7      (CRPT_BA+0x02C)  /*!< PRNG Generated Key 7                          */
N
N/* AES/TDES feedback Registers */
N#define     CRPT_AES_FDBCK0     (CRPT_BA+0x050)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK1     (CRPT_BA+0x054)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK2     (CRPT_BA+0x058)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK3     (CRPT_BA+0x05C)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_TDES_FDBCKH    (CRPT_BA+0x060)  /*!< TDES/DES Engine Output Feedback High Word Data after Cryptographic Operation  */
N#define     CRPT_TDES_FDBCKL    (CRPT_BA+0x064)  /*!< TDES/DES Engine Output Feedback Low Word Data after Cryptographic Operation   */
N
N/* AES Control Registers */
N#define     CRPT_AES_CTL        (CRPT_BA+0x100)   /*!< AES Control Register                               */
N#define     CRPT_AES_STS        (CRPT_BA+0x104)   /*!< AES Engine Flag                                    */
N#define     CRPT_AES_DATIN      (CRPT_BA+0x108)   /*!< AES Engine Data Input Port Register                */
N#define     CRPT_AES_DATOUT     (CRPT_BA+0x10C)   /*!< AES Engine Data Output Port Register               */
N#define     CRPT_AES0_KEY0      (CRPT_BA+0x110)   /*!< AES Key Word 0 Register for Channel 0              */
N#define     CRPT_AES0_KEY1      (CRPT_BA+0x114)   /*!< AES Key Word 1 Register for Channel 0              */
N#define     CRPT_AES0_KEY2      (CRPT_BA+0x118)   /*!< AES Key Word 2 Register for Channel 0              */
N#define     CRPT_AES0_KEY3      (CRPT_BA+0x11C)   /*!< AES Key Word 3 Register for Channel 0              */
N#define     CRPT_AES0_KEY4      (CRPT_BA+0x120)   /*!< AES Key Word 4 Register for Channel 0              */
N#define     CRPT_AES0_KEY5      (CRPT_BA+0x124)   /*!< AES Key Word 5 Register for Channel 0              */
N#define     CRPT_AES0_KEY6      (CRPT_BA+0x128)   /*!< AES Key Word 6 Register for Channel 0              */
N#define     CRPT_AES0_KEY7      (CRPT_BA+0x12C)   /*!< AES Key Word 7 Register for Channel 0              */
N#define     CRPT_AES0_IV0       (CRPT_BA+0x130)   /*!< AES Initial Vector Word 0 Register for Channel 0   */
N#define     CRPT_AES0_IV1       (CRPT_BA+0x134)   /*!< AES Initial Vector Word 1 Register for Channel 0   */
N#define     CRPT_AES0_IV2       (CRPT_BA+0x138)   /*!< AES Initial Vector Word 2 Register for Channel 0   */
N#define     CRPT_AES0_IV3       (CRPT_BA+0x13C)   /*!< AES Initial Vector Word 3 Register for Channel 0   */
N#define     CRPT_AES0_SADDR     (CRPT_BA+0x140)   /*!< AES DMA Source Address Register for Channel 0      */
N#define     CRPT_AES0_DADDR     (CRPT_BA+0x144)   /*!< AES DMA Destination Address Register for Channel 0 */
N#define     CRPT_AES0_CNT       (CRPT_BA+0x148)   /*!< AES Byte Count Register for Channel 0              */
N#define     CRPT_AES1_KEY0      (CRPT_BA+0x14C)   /*!< AES Key Word 0 Register for Channel 1              */
N#define     CRPT_AES1_KEY1      (CRPT_BA+0x150)   /*!< AES Key Word 1 Register for Channel 1              */
N#define     CRPT_AES1_KEY2      (CRPT_BA+0x154)   /*!< AES Key Word 2 Register for Channel 1              */
N#define     CRPT_AES1_KEY3      (CRPT_BA+0x158)   /*!< AES Key Word 3 Register for Channel 1              */
N#define     CRPT_AES1_KEY4      (CRPT_BA+0x15C)   /*!< AES Key Word 4 Register for Channel 1              */
N#define     CRPT_AES1_KEY5      (CRPT_BA+0x160)   /*!< AES Key Word 5 Register for Channel 1              */
N#define     CRPT_AES1_KEY6      (CRPT_BA+0x164)   /*!< AES Key Word 6 Register for Channel 1              */
N#define     CRPT_AES1_KEY7      (CRPT_BA+0x168)   /*!< AES Key Word 7 Register for Channel 1              */
N#define     CRPT_AES1_IV0       (CRPT_BA+0x16C)   /*!< AES Initial Vector Word 0 Register for Channel 1   */
N#define     CRPT_AES1_IV1       (CRPT_BA+0x170)   /*!< AES Initial Vector Word 1 Register for Channel 1   */
N#define     CRPT_AES1_IV2       (CRPT_BA+0x174)   /*!< AES Initial Vector Word 2 Register for Channel 1   */
N#define     CRPT_AES1_IV3       (CRPT_BA+0x178)   /*!< AES Initial Vector Word 3 Register for Channel 1   */
N#define     CRPT_AES1_SADDR     (CRPT_BA+0x17C)   /*!< AES DMA Source Address Register for Channel 1      */
N#define     CRPT_AES1_DADDR     (CRPT_BA+0x180)   /*!< AES DMA Destination Address Register for Channel 1 */
N#define     CRPT_AES1_CNT       (CRPT_BA+0x184)   /*!< AES Byte Count Register for Channel 1              */
N#define     CRPT_AES2_KEY0      (CRPT_BA+0x188)   /*!< AES Key Word 0 Register for Channel 2              */
N#define     CRPT_AES2_KEY1      (CRPT_BA+0x18C)   /*!< AES Key Word 1 Register for Channel 2              */
N#define     CRPT_AES2_KEY2      (CRPT_BA+0x190)   /*!< AES Key Word 2 Register for Channel 2              */
N#define     CRPT_AES2_KEY3      (CRPT_BA+0x194)   /*!< AES Key Word 3 Register for Channel 2              */
N#define     CRPT_AES2_KEY4      (CRPT_BA+0x198)   /*!< AES Key Word 4 Register for Channel 2              */
N#define     CRPT_AES2_KEY5      (CRPT_BA+0x19C)   /*!< AES Key Word 5 Register for Channel 2              */
N#define     CRPT_AES2_KEY6      (CRPT_BA+0x1A0)   /*!< AES Key Word 6 Register for Channel 2              */
N#define     CRPT_AES2_KEY7      (CRPT_BA+0x1A4)   /*!< AES Key Word 7 Register for Channel 2              */
N#define     CRPT_AES2_IV0       (CRPT_BA+0x1A8)   /*!< AES Initial Vector Word 0 Register for Channel 2   */
N#define     CRPT_AES2_IV1       (CRPT_BA+0x1AC)   /*!< AES Initial Vector Word 1 Register for Channel 2   */
N#define     CRPT_AES2_IV2       (CRPT_BA+0x1B0)   /*!< AES Initial Vector Word 2 Register for Channel 2   */
N#define     CRPT_AES2_IV3       (CRPT_BA+0x1B4)   /*!< AES Initial Vector Word 3 Register for Channel 2   */
N#define     CRPT_AES2_SADDR     (CRPT_BA+0x1B8)   /*!< AES DMA Source Address Register for Channel 2      */
N#define     CRPT_AES2_DADDR     (CRPT_BA+0x1BC)   /*!< AES DMA Destination Address Register for Channel 2 */
N#define     CRPT_AES2_CNT       (CRPT_BA+0x1C0)   /*!< AES Byte Count Register for Channel 2              */
N#define     CRPT_AES3_KEY0      (CRPT_BA+0x1C4)   /*!< AES Key Word 0 Register for Channel 3              */
N#define     CRPT_AES3_KEY1      (CRPT_BA+0x1C8)   /*!< AES Key Word 1 Register for Channel 3              */
N#define     CRPT_AES3_KEY2      (CRPT_BA+0x1CC)   /*!< AES Key Word 2 Register for Channel 3              */
N#define     CRPT_AES3_KEY3      (CRPT_BA+0x1D0)   /*!< AES Key Word 3 Register for Channel 3              */
N#define     CRPT_AES3_KEY4      (CRPT_BA+0x1D4)   /*!< AES Key Word 4 Register for Channel 3              */
N#define     CRPT_AES3_KEY5      (CRPT_BA+0x1D8)   /*!< AES Key Word 5 Register for Channel 3              */
N#define     CRPT_AES3_KEY6      (CRPT_BA+0x1DC)   /*!< AES Key Word 6 Register for Channel 3              */
N#define     CRPT_AES3_KEY7      (CRPT_BA+0x1E0)   /*!< AES Key Word 7 Register for Channel 3              */
N#define     CRPT_AES3_IV0       (CRPT_BA+0x1E4)   /*!< AES Initial Vector Word 0 Register for Channel 3   */
N#define     CRPT_AES3_IV1       (CRPT_BA+0x1E8)   /*!< AES Initial Vector Word 1 Register for Channel 3   */
N#define     CRPT_AES3_IV2       (CRPT_BA+0x1EC)   /*!< AES Initial Vector Word 2 Register for Channel 3   */
N#define     CRPT_AES3_IV3       (CRPT_BA+0x1F0)   /*!< AES Initial Vector Word 3 Register for Channel 3   */
N#define     CRPT_AES3_SADDR     (CRPT_BA+0x1F4)   /*!< AES DMA Source Address Register for Channel 3      */
N#define     CRPT_AES3_DADDR     (CRPT_BA+0x1F8)   /*!< AES DMA Destination Address Register for Channel 3 */
N#define     CRPT_AES3_CNT       (CRPT_BA+0x1FC)   /*!< AES Byte Count Register for Channel 3              */
N
N/* DES/TDES Control Registers */
N#define     CRPT_TDES_CTL       (CRPT_BA+0x200)   /*!< TDES/DES Control Register                          */
N#define     CRPT_TDES_STS       (CRPT_BA+0x204)   /*!< TDES/DES Engine Flag                               */
N#define     CRPT_TDES0_KEY1H    (CRPT_BA+0x208)   /*!< TDES/DES Key 1 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY1L    (CRPT_BA+0x20C)   /*!< TDES/DES Key 1 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY2H    (CRPT_BA+0x210)   /*!< TDES/DES Key 2 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY2L    (CRPT_BA+0x214)   /*!< TDES/DES Key 2 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY3H    (CRPT_BA+0x218)   /*!< TDES/DES Key 3 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY3L    (CRPT_BA+0x21C)   /*!< TDES/DES Key 3 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_IVH      (CRPT_BA+0x220)   /*!< TDES/DES Initial Vector High Word Register for Channel 0 */
N#define     CRPT_TDES0_IVL      (CRPT_BA+0x224)   /*!< TDES/DES Initial Vector Low Word Register for Channel 0  */
N#define     CRPT_TDES0_SADDR    (CRPT_BA+0x228)   /*!< TDES/DES DMA Source Address Register for Channel 0       */
N#define     CRPT_TDES0_DADDR    (CRPT_BA+0x22C)   /*!< TDES/DES DMA Destination Address Register for Channel 0  */
N#define     CRPT_TDES0_CNT      (CRPT_BA+0x230)   /*!< TDES/DES Byte Count Register for Channel 0         */
N#define     CRPT_TDES_DATIN     (CRPT_BA+0x234)   /*!< TDES/DES Engine Input data Word Register           */
N#define     CRPT_TDES_DATOUT    (CRPT_BA+0x238)   /*!< TDES/DES Engine Output data Word Register          */
N#define     CRPT_TDES1_KEY1H    (CRPT_BA+0x248)   /*!< TDES/DES Key 1 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY1L    (CRPT_BA+0x24C)   /*!< TDES/DES Key 1 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY2H    (CRPT_BA+0x250)   /*!< TDES/DES Key 2 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY2L    (CRPT_BA+0x254)   /*!< TDES/DES Key 2 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY3H    (CRPT_BA+0x258)   /*!< TDES/DES Key 3 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY3L    (CRPT_BA+0x25C)   /*!< TDES/DES Key 3 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_IVH      (CRPT_BA+0x260)   /*!< TDES/DES Initial Vector High Word Register for Channel 1 */
N#define     CRPT_TDES1_IVL      (CRPT_BA+0x264)   /*!< TDES/DES Initial Vector Low Word Register for Channel 1  */
N#define     CRPT_TDES1_SADDR    (CRPT_BA+0x268)   /*!< TDES/DES DMA Source Address Register for Channel 1       */
N#define     CRPT_TDES1_DADDR    (CRPT_BA+0x26C)   /*!< TDES/DES DMA Destination Address Register for Channel 1  */
N#define     CRPT_TDES1_CNT      (CRPT_BA+0x270)   /*!< TDES/DES Byte Count Register for Channel 1         */
N#define     CRPT_TDES2_KEY1H    (CRPT_BA+0x288)   /*!< TDES/DES Key 1 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY1L    (CRPT_BA+0x28C)   /*!< TDES/DES Key 1 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY2H    (CRPT_BA+0x290)   /*!< TDES/DES Key 2 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY2L    (CRPT_BA+0x294)   /*!< TDES/DES Key 2 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY3H    (CRPT_BA+0x298)   /*!< TDES/DES Key 3 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY3L    (CRPT_BA+0x29C)   /*!< TDES/DES Key 3 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_IVH      (CRPT_BA+0x2A0)   /*!< TDES/DES Initial Vector High Word Register for Channel 2 */
N#define     CRPT_TDES2_IVL      (CRPT_BA+0x2A4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 2  */
N#define     CRPT_TDES2_SADDR    (CRPT_BA+0x2A8)   /*!< TDES/DES DMA Source Address Register for Channel 2       */
N#define     CRPT_TDES2_DADDR    (CRPT_BA+0x2AC)   /*!< TDES/DES DMA Destination Address Register for Channel 2  */
N#define     CRPT_TDES2_CNT      (CRPT_BA+0x2B0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N#define     CRPT_TDES3_KEY1H    (CRPT_BA+0x2C8)   /*!< TDES/DES Key 1 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY1L    (CRPT_BA+0x2CC)   /*!< TDES/DES Key 1 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY2H    (CRPT_BA+0x2D0)   /*!< TDES/DES Key 2 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY2L    (CRPT_BA+0x2D4)   /*!< TDES/DES Key 2 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY3H    (CRPT_BA+0x2D8)   /*!< TDES/DES Key 3 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY3L    (CRPT_BA+0x2DC)   /*!< TDES/DES Key 3 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_IVH      (CRPT_BA+0x2E0)   /*!< TDES/DES Initial Vector High Word Register for Channel 3 */
N#define     CRPT_TDES3_IVL      (CRPT_BA+0x2E4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 3  */
N#define     CRPT_TDES3_SADDR    (CRPT_BA+0x2E8)   /*!< TDES/DES DMA Source Address Register for Channel 3       */
N#define     CRPT_TDES3_DADDR    (CRPT_BA+0x2EC)   /*!< TDES/DES DMA Destination Address Register for Channel 3  */
N#define     CRPT_TDES3_CNT      (CRPT_BA+0x2F0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N
N/* SHA/HMAC Control Registers */
N#define     CRPT_HMAC_CTL       (CRPT_BA+0x300)   /*!< SHA/HMAC Control Register                          */
N#define     CRPT_HMAC_STS       (CRPT_BA+0x304)   /*!< SHA/HMAC Status Flag                               */
N#define     CRPT_HMAC_DGST0     (CRPT_BA+0x308)   /*!< SHA/HMAC Digest Message 0                          */
N#define     CRPT_HMAC_DGST1     (CRPT_BA+0x30C)   /*!< SHA/HMAC Digest Message 1                          */
N#define     CRPT_HMAC_DGST2     (CRPT_BA+0x310)   /*!< SHA/HMAC Digest Message 2                          */
N#define     CRPT_HMAC_DGST3     (CRPT_BA+0x314)   /*!< SHA/HMAC Digest Message 3                          */
N#define     CRPT_HMAC_DGST4     (CRPT_BA+0x318)   /*!< SHA/HMAC Digest Message 4                          */
N#define     CRPT_HMAC_DGST5     (CRPT_BA+0x31C)   /*!< SHA/HMAC Digest Message 5                          */
N#define     CRPT_HMAC_DGST6     (CRPT_BA+0x320)   /*!< SHA/HMAC Digest Message 6                          */
N#define     CRPT_HMAC_DGST7     (CRPT_BA+0x324)   /*!< SHA/HMAC Digest Message 7                          */
N#define     CRPT_HMAC_DGST8     (CRPT_BA+0x328)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST9     (CRPT_BA+0x32C)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST10    (CRPT_BA+0x330)   /*!< SHA/HMAC Digest Message 10                         */
N#define     CRPT_HMAC_DGST11    (CRPT_BA+0x334)   /*!< SHA/HMAC Digest Message 11                         */
N#define     CRPT_HMAC_DGST12    (CRPT_BA+0x338)   /*!< SHA/HMAC Digest Message 12                         */
N#define     CRPT_HMAC_DGST13    (CRPT_BA+0x33C)   /*!< SHA/HMAC Digest Message 13                         */
N#define     CRPT_HMAC_DGST14    (CRPT_BA+0x340)   /*!< SHA/HMAC Digest Message 14                         */
N#define     CRPT_HMAC_DGST15    (CRPT_BA+0x344)   /*!< SHA/HMAC Digest Message 15                         */
N#define     CRPT_HMAC_KEYCNT    (CRPT_BA+0x348)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_SADDR     (CRPT_BA+0x34C)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_DMACNT    (CRPT_BA+0x350)   /*!< SHA/HMAC Byte Count Register                       */
N#define     CRPT_HMAC_DATIN     (CRPT_BA+0x354)   /*!< SHA/HMAC Engine Non-DMA Mode Data Input Port Register  */
N
N/**@}*/ /* end of Cryptographic Accelerator register group */
N
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Keypad Interface -------------------------*/
N/**
N    @addtogroup KPI Keypad Interface(KPI)
N    Memory Mapped Structure for KPI Controller
N@{ */
N
N#define     REG_KPI_CONF    (KPI_BA+0x00)  /*!< Keypad controller configuration Register */
N#define     REG_KPI_3KCONF  (KPI_BA+0x04)  /*!< Keypad controller 3-keys configuration register */
N#define     REG_KPI_STATUS  (KPI_BA+0x08)  /*!< Keypad status register */
N#define     REG_KPI_RSTC    (KPI_BA+0x0C)  /*!< Keypad  Reset Period Controller register */
N#define     REG_KPI_KEST        (KPI_BA+0x10)  /*!< Keypad Key State Indicator */
N#define     REG_KPI_KPE         (KPI_BA+0x18)  /*!< Press Key Event Indicator */
N#define     REG_KPI_KRE         (KPI_BA+0x20)  /*!< Release Key Event Indicator */
N#define     REG_KPI_PRESCALDIV  (KPI_BA+0x28)  /*!< Pre-Scale Divider */
N
N/**@}*/ /* end of KPI register group */
N
N
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- Multi-Time Programmable Controller --------------------*/
N/**
N    @addtogroup MTP Multi-Time Programmable Controller (MTP)
N    Memory Mapped Structure for MTP Controller
N@{ */
N
N#define     MTP_KEYEN           (MTP_BA+0x000)   /*!< MTP Key Enable Register                       */
N#define     MTP_USERDATA        (MTP_BA+0x00C)   /*!< MTP User Defined Data Register                */
N#define     MTP_KEY0            (MTP_BA+0x010)   /*!< MTP KEY 0 Register                            */
N#define     MTP_KEY1            (MTP_BA+0x014)   /*!< MTP KEY 1 Register                            */
N#define     MTP_KEY2            (MTP_BA+0x018)   /*!< MTP KEY 2 Register                            */
N#define     MTP_KEY3            (MTP_BA+0x01C)   /*!< MTP KEY 3 Register                            */
N#define     MTP_KEY4            (MTP_BA+0x020)   /*!< MTP KEY 4 Register                            */
N#define     MTP_KEY5            (MTP_BA+0x024)   /*!< MTP KEY 5 Register                            */
N#define     MTP_KEY6            (MTP_BA+0x028)   /*!< MTP KEY 6 Register                            */
N#define     MTP_KEY7            (MTP_BA+0x02C)   /*!< MTP KEY 7 Register                            */
N#define     MTP_PCYCLE          (MTP_BA+0x030)   /*!< MTP Program Cycle Program Count Register      */
N#define     MTP_CTL             (MTP_BA+0x034)   /*!< MTP Control Register                          */
N#define     MTP_PSTART          (MTP_BA+0x038)   /*!< MTP Program Start Registe                     */
N#define     MTP_STATUS          (MTP_BA+0x040)   /*!< MTP Status Registe                            */
N#define     MTP_REGLCTL         (MTP_BA+0x050)   /*!< MTP Register Write-Protection Control Register*/
N
N/**@}*/ /* end of MTP register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group NUC970_Peripherals */
N
N
N/** @addtogroup NUC970_IO_ROUTINE NUC970 I/O Routines
N  The Declaration of NUC970 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group NUC970_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup NUC970_legacy_Constants NUC970 Legacy Constants
N  NUC970 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define SPECIAL        (2)
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __NUC970_H__ */
N
N/*@}*/ /* end of group NUC970_legacy_Constants */
L 15 "src\user\hwtester.c" 2
N#include "sys.h"
L 1 "..\..\common\src\BSP\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @version  V1.00
N* $Revision: 6 $
N* $Date: 15/06/12 9:25a $
N* @brief    NUC970 SYS driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  NUC970 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    CRPT_IRQn               = 35,      /*!< Cryptographic Accelerator Interrupt        */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N    KPI_IRQn                = 61,      /*!< KPI Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N/* Define constants for use external IO in service parameters.  */
N#define EXT0            0
N#define EXT1            1
N#define EXT2            2
N#define EXT3            3
N#define EXT4            4
N
N#define SIZE_256K       4
N#define SIZE_512K       5
N#define SIZE_1M         6
N#define SIZE_2M         7
N#define SIZE_4M         8
N#define SIZE_8M         9
N#define SIZE_16M        10
N#define SIZE_32M        11
N
N#define BUS_DISABLE     12
N#define BUS_BIT_8       13
N#define BUS_BIT_16      14
N#define BUS_BIT_32      15
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    setPrintfFlag(BOOL flag);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    terninalPrintf(PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
N/* Define system library External IO functions */
NINT32   sysSetExternalIO(INT extNo, UINT32 extBaseAddr, UINT32 extSize, INT extBusWidth); /*!< set External IO \hideinitializer */
NINT32   sysSetExternalIOTiming1(INT extNo, INT tACC, INT tACS); /*!< set External IO timing1 \hideinitializer */
NINT32   sysSetExternalIOTiming2(INT extNo, INT tCOH, INT tCOS); /*!< set External IO timing2 \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_SYS_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
L 16 "src\user\hwtester.c" 2
N#include "gpio.h"
L 1 "..\..\common\src\BSP\Driver\Include\gpio.h" 1
N/**************************************************************************//**
N* @file     gpio.h
N* @version  V1.00
N* $Revision: 9 $
N* $Date: 15/05/18 5:38p $
N* @brief    NUC970 GPIO driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup NUC970_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODE Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N/// @cond HIDDEN_SYMBOLS
N#ifndef GPIO_ERR_PORT_BUSY
N#define GPIO_ERR_PORT_BUSY      -1
N#define GPIO_ERR_UNSUPPORTED    -2
N#define GPIO_ERR_BIT_BUSY       -3
N#define SUCCESSFUL              0
N#endif
N/// @endcond HIDDEN_SYMBOLS
N
N#define MAX_PORT 10  /*!< GPIO Port Number */
N
N#define GPIOA_MASK  0x0000FFFF  /*!< GPIO Port A Mask */
N#define GPIOB_MASK  0x0000FFFF  /*!< GPIO Port B Mask */
N#define GPIOC_MASK  0x00007FFF  /*!< GPIO Port C Mask */
N#define GPIOD_MASK  0x0000FFFF  /*!< GPIO Port D Mask */
N#define GPIOE_MASK  0x0000FFFF  /*!< GPIO Port E Mask */
N#define GPIOF_MASK  0x0000FFFF  /*!< GPIO Port F Mask */
N#define GPIOG_MASK  0x0000FFFF  /*!< GPIO Port G Mask */
N#define GPIOH_MASK  0x0000FFFF  /*!< GPIO Port H Mask */
N#define GPIOI_MASK  0x0000FFFF  /*!< GPIO Port I Mask */
N#define GPIOJ_MASK  0x0000003F  /*!< GPIO Port J Mask */
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef INT32 (*GPIO_CALLBACK)(UINT32 status, UINT32 userData);
Ntypedef INT32 (*EINT_CALLBACK)(UINT32 status, UINT32 userData);
N/// @endcond HIDDEN_SYMBOLS
N
N/** \brief  Structure type of GPIO_PORT
N */
Ntypedef enum {
N    GPIOA=0x000,   /*!< Port A offset of GPIO base address      */
N    GPIOB=0x040,   /*!< Port B offset of GPIO base address      */
N    GPIOC=0x080,   /*!< Port C offset of GPIO base address      */
N    GPIOD=0x0C0,   /*!< Port D offset of GPIO base address      */
N    GPIOE=0x100,   /*!< Port E offset of GPIO base address      */
N    GPIOF=0x140,   /*!< Port F offset of GPIO base address      */
N    GPIOG=0x180,   /*!< Port G offset of GPIO base address      */
N    GPIOH=0x1C0,   /*!< Port H offset of GPIO base address      */
N    GPIOI=0x200,   /*!< Port I offset of GPIO base address      */
N    GPIOJ=0x240,   /*!< Port J offset of GPIO base address      */
N} GPIO_PORT;
N
N/** \brief  Structure type of GPIO_DIR
N */
Ntypedef enum {
N    DIR_INPUT,   /*!< GPIO Output mode      */
N    DIR_OUTPUT   /*!< GPIO Input mode      */
N} GPIO_DIR;
N
N/** \brief  Structure type of GPIO_PULL
N */
Ntypedef enum {
N    NO_PULL_UP, /*!< GPIO Pull-Up Disable */
N    PULL_UP     /*!< GPIO Pull-Up Enable */
N} GPIO_PULL;
N
N/** \brief  Structure type of GPIO_DRV
N */
Ntypedef enum {
N    DRV_LOW,   /*!< GPIO Set to Low */
N    DRV_HIGH   /*!< GPIO Set to High */
N} GPIO_DRV;
N
N/** \brief  Structure type of GPIO_NIRQ
N */
Ntypedef enum {
N    NIRQ0=0,   /*!< External interrupt 0 */
N    NIRQ1,     /*!< External interrupt 1 */
N    NIRQ2,     /*!< External interrupt 2 */
N    NIRQ3,     /*!< External interrupt 3 */
N    NIRQ4,     /*!< External interrupt 4 */
N    NIRQ5,     /*!< External interrupt 5 */
N    NIRQ6,     /*!< External interrupt 6 */
N    NIRQ7,     /*!< External interrupt 7 */
N} GPIO_NIRQ;
N
N/** \brief  Structure type of GPIO_TRIGGER_TYPE
N */
Ntypedef enum {
N    LOW,                   /*!< Trigger type set low */
N    HIGH,                  /*!< Trigger type set high */
N    FALLING,               /*!< Trigger type set falling edge */
N    RISING,                /*!< Trigger type set rising edge */
N    BOTH_EDGE              /*!< Trigger type set falling edge and rising edge */
N} GPIO_TRIGGER_TYPE;
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct {
N    UINT16          bitBusyFlag[MAX_PORT];
X    UINT16          bitBusyFlag[10];
N    GPIO_CALLBACK   IRQCallback[MAX_PORT];
X    GPIO_CALLBACK   IRQCallback[10];
N    UINT32          IRQUserData[MAX_PORT];
X    UINT32          IRQUserData[10];
N    EINT_CALLBACK   EINTIRQCallback[8];
N    UINT32          EINTIRQUserData[8];
N} GPIO_CFG;
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group NUC970_GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
NINT32 GPIO_Open(GPIO_PORT port, GPIO_DIR direction, GPIO_PULL pull);
NINT32 GPIO_Close(GPIO_PORT port);
NINT32 GPIO_Set(GPIO_PORT port, UINT32 bitMap);
NINT32 GPIO_Clr(GPIO_PORT port, UINT32 bitMap);
NUINT32 GPIO_ReadPort(GPIO_PORT port);
NINT32 GPIO_SetPortDir(GPIO_PORT port, GPIO_DIR direction);
N
N/* General GPIO bit function */
NINT32 GPIO_OpenBit(GPIO_PORT port, UINT32 bit, GPIO_DIR direction, GPIO_PULL pull);
NINT32 GPIO_CloseBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_SetBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ClrBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ReadBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_SetBitDir(GPIO_PORT port, UINT32 bit, GPIO_DIR direction);
NINT32 GPIO_EnableTriggerType(GPIO_PORT port, UINT32 bit, GPIO_TRIGGER_TYPE triggerType);
NINT32 GPIO_DisableTriggerType(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_EnableInt(GPIO_PORT port, GPIO_CALLBACK callback, UINT32 userData);
NINT32 GPIO_DisableInt(GPIO_PORT port);
NINT32 GPIO_ClrISR(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ClrISRBit(GPIO_PORT port, UINT32 bit);
N
N/* GPIO status function */
NBOOL GPIO_BitIsUsed(GPIO_PORT port, UINT32 bit);
N
N/* External GPIO interrupt function */
NINT32 GPIO_EnableEINT(GPIO_NIRQ nIrq, GPIO_CALLBACK callback, UINT32 userData);
NINT32 GPIO_DisableEINT(GPIO_NIRQ nIrq);
NINT32 GPIO_EnableDebounce(INT32 debounceClkSel);
NINT32 GPIO_DisableDebounce(void);
N
N/*@}*/ /* end of group NUC970_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_GPIO_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 17 "src\user\hwtester.c" 2
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
Ntypedef signed int ptrdiff_t;
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* others (e.g. <stdio.h>) also define */
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32)
X    #if 0L
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 "..\..\common\src\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\common\src\FreeRTOS\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N#define configUSE_PREEMPTION			1
N#define configUSE_IDLE_HOOK				1
N#define configUSE_TICK_HOOK				1
N#define configCPU_CLOCK_HZ				( ( unsigned long ) 300000000 )
N//#define configTICK_RATE_HZ				( ( TickType_t ) 1000 )
N#define configTICK_RATE_HZ				( ( TickType_t ) 100 )
N#define configMAX_PRIORITIES			( 16 )
N#define configMINIMAL_STACK_SIZE		( ( unsigned short ) 1024 )
N#define configTOTAL_HEAP_SIZE			( ( size_t ) 1024*1024*16 )
N#define configMAX_TASK_NAME_LEN			( 16 )
N#define configUSE_TRACE_FACILITY		1
N#define configUSE_16_BIT_TICKS			0
N#define configIDLE_SHOULD_YIELD			1
N#define configUSE_MUTEXES				1
N#define configCHECK_FOR_STACK_OVERFLOW  1
N#define configUSE_MALLOC_FAILED_HOOK    1
N
N#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#define configUSE_COUNTING_SEMAPHORES   1
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 			0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet				0//1
N#define INCLUDE_uxTaskPriorityGet				1
N#define INCLUDE_vTaskDelete						1
N#define INCLUDE_vTaskCleanUpResources			0
N#define INCLUDE_vTaskSuspend					1
N#define INCLUDE_vTaskDelayUntil					1
N#define INCLUDE_vTaskDelay						1
N#define INCLUDE_xTaskGetCurrentTaskHandle 		1
N#define INCLUDE_uxTaskGetStackHighWaterMark     1
N
N/* This demo makes use of one or more example stats formatting functions.  These
Nformat the raw data provided by the uxTaskGetSystemState() function in to human
Nreadable ASCII form.  See the notes in the implementation of vTaskList() within 
NFreeRTOS/Source/tasks.c for limitations. */
N#define configUSE_STATS_FORMATTING_FUNCTIONS	1
N
N#endif /* FREERTOS_CONFIG_H */
L 99 "..\..\common\src\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\common\src\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\common\src\FreeRTOS\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S\portmacro.h" 1
N/*
N * It turns out that portmacro.h from the officially supported
N * GCC/ARM7_LPC2000 port can be reused at ARM926EJ-S too.
N * Although the file could remain unmodified, it was slightly modified
N * so interrupt enabling macros do not enable FIQ exceptions that is
N * currently not supported.
N * Additionally all "annoying" tabs have been replaced by spaces.
N *
N * The original file is available under the following license:
N */
N
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N    /*-----------------------------------------------------------
N     * Port specific definitions.
N     *
N     * The settings in this file configure FreeRTOS correctly for the
N     * given hardware and compiler.
N     *
N     * These settings should not be altered.
N     *-----------------------------------------------------------
N     */
N#define portCHAR        char
N#define portFLOAT        float
N#define portDOUBLE        double
N#define portLONG        long
N#define portSHORT        short
N#define portSTACK_TYPE    unsigned portLONG
N#define portBASE_TYPE    portLONG
N
N//add by sam
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef unsigned long StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S    typedef unsigned portSHORT portTickType;
S#define portMAX_DELAY ( portTickType ) 0xffff
N#else
N    typedef unsigned portLONG portTickType;
X    typedef unsigned long portTickType;
N#define portMAX_DELAY ( portTickType ) 0xffffffff
N#endif
N
N//add by sam
Ntypedef portTickType TickType_t;
N
N    /*-----------------------------------------------------------*/
N
N    /* Hardware specifics. */
N//#define portSTACK_GROWTH            ( -1 )
N//#define portTICK_RATE_MS            ( ( portTickType ) 1000 / configTICK_RATE_HZ )
N//#define portBYTE_ALIGNMENT            8
N//by sam
N/* Hardware specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N    /*-----------------------------------------------------------*/
N
N
N#define portEXIT_SWITCHING_ISR(SwitchRequired)                 \
N                        {                                                             \
N                        extern void vTaskSwitchContext(void);                         \
N                                                                                     \
N                                if(SwitchRequired)                                     \
N                                {                                                     \
N                                    vTaskSwitchContext();                             \
N                                }                                                     \
N                        }                                                             \
N
X#define portEXIT_SWITCHING_ISR(SwitchRequired)                                         {                                                                                     extern void vTaskSwitchContext(void);                                                                                                                                              if(SwitchRequired)                                                                     {                                                                                         vTaskSwitchContext();                                                             }                                                                             }                                                             
Nextern void vPortYield2( void );
N#define portYIELD() vPortYield2()
N
N
N    /* Critical section management. */
N
N#define portDISABLE_INTERRUPTS()    __disable_irq()
N#define portENABLE_INTERRUPTS()        __enable_irq()
N
N    extern void vPortEnterCritical( void );
N    extern void vPortExitCritical( void );
N
N#define portENTER_CRITICAL()        vPortEnterCritical();
N#define portEXIT_CRITICAL()            vPortExitCritical();
N    /*-----------------------------------------------------------*/
N
N    /* Compiler specifics. */
N#define inline
N#define register
N#define portNOP()                   __asm{ NOP }
N//#define portYIELD()					__asm{ SWI 0 }//asm ( "SWI 0" )
N    /*-----------------------------------------------------------*/
N
N    /* Task function macros as described on the FreeRTOS.org WEB site. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters )    void vFunction( void *pvParameters )
N
N    //
N    //
N    //#define portYIELD() vPortYield() ///os taskCPU. vPortYieldportasm.s 
N    //#define portDISABLE_INTERRUPTS()    __disable_irq()                     //// __disable_irq()  __enable_irq() 
N    //#define portENABLE_INTERRUPTS()        __enable_irq()           ////
N    //#define portNOP()    __asm{ NOP }                             ////nop
N
N    //
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
L 95 "..\..\common\src\FreeRTOS\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\common\src\FreeRTOS\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\common\src\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#if configMAX_PRIORITIES < 1
X#if ( 16 ) < 1
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
S	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
S	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
N	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
N	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
N	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
N	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
S	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
N	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
S	/* Defaults to 1 for backward compatibility. */
S	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 0 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 0 == 0 )
N	/* Either variables of tick type cannot be read atomically, or
N	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
N	the tick count is returned to the standard critical section macros. */
N	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
S	/* The tick type can be read atomically, so critical sections used when the
S	tick count is returned can be defined away. */
S	#define portTICK_TYPE_ENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ ( 16 ) ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t uxDummy8;
N		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 20 "src\user\hwtester.c" 2
N#include "task.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\common\src\FreeRTOS\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
X							TaskHandle_t * const pxCreatedTask ) ;
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * vTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
Nvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
Xvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 21 "src\user\hwtester.c" 2
N#include "queue.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\queue.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
Nvoid* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0U > 0 )
S	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 22 "src\user\hwtester.c" 2
N#include "semphr.h"
L 1 "..\..\common\src\FreeRTOS\Source\include\semphr.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef SEMAPHORE_H
N#define SEMAPHORE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include semphr.h"
N#endif
N
N#include "queue.h"
N
Ntypedef QueueHandle_t SemaphoreHandle_t;
N
N#define semBINARY_SEMAPHORE_QUEUE_LENGTH	( ( uint8_t ) 1U )
N#define semSEMAPHORE_QUEUE_ITEM_LENGTH		( ( uint8_t ) 0U )
N#define semGIVE_BLOCK_TIME					( ( TickType_t ) 0U )
N
N
N/**
N * semphr. h
N * <pre>vSemaphoreCreateBinary( SemaphoreHandle_t xSemaphore )</pre>
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * This old vSemaphoreCreateBinary() macro is now deprecated in favour of the
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * <i>Macro</i> that implements a semaphore by using the existing queue mechanism.
N * The queue length is 1 as this is a binary semaphore.  The data size is 0
N * as we don't want to actually store any data - we just want to know if the
N * queue is empty or full.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param xSemaphore Handle to the created semaphore.  Should be of type SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to vSemaphoreCreateBinary ().
N    // This is a macro so pass the variable in directly.
N    vSemaphoreCreateBinary( xSemaphore );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup vSemaphoreCreateBinary vSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define vSemaphoreCreateBinary( xSemaphore )																							\
N		{																																	\
N			( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );	\
N			if( ( xSemaphore ) != NULL )																									\
N			{																																\
N				( void ) xSemaphoreGive( ( xSemaphore ) );																					\
N			}																																\
N		}
X	#define vSemaphoreCreateBinary( xSemaphore )																									{																																				( xSemaphore ) = xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE );				if( ( xSemaphore ) != NULL )																												{																																				( void ) xSemaphoreGive( ( xSemaphore ) );																								}																																		}
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinary( void )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * The old vSemaphoreCreateBinary() macro is now deprecated in favour of this
N * xSemaphoreCreateBinary() function.  Note that binary semaphores created using
N * the vSemaphoreCreateBinary() macro are created in a state such that the
N * first call to 'take' the semaphore would pass, whereas binary semaphores
N * created using xSemaphoreCreateBinary() are created in a state such that the
N * the semaphore must first be 'given' before it can be 'taken'.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @return Handle to the created semaphore, or NULL if the memory required to
N * hold the semaphore's data structures could not be allocated.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateBinary xSemaphoreCreateBinary
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new binary semaphore instance, and returns a handle by which the
N * new semaphore can be referenced.
N *
N * NOTE: In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a binary semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, binary semaphores use a block
N * of memory, in which the semaphore structure is stored.  If a binary semaphore
N * is created using xSemaphoreCreateBinary() then the required memory is
N * automatically dynamically allocated inside the xSemaphoreCreateBinary()
N * function.  (see http://www.freertos.org/a00111.html).  If a binary semaphore
N * is created using xSemaphoreCreateBinaryStatic() then the application writer
N * must provide the memory.  xSemaphoreCreateBinaryStatic() therefore allows a
N * binary semaphore to be created without using any dynamic memory allocation.
N *
N * This type of semaphore can be used for pure synchronisation between tasks or
N * between an interrupt and a task.  The semaphore need not be given back once
N * obtained, so one task/interrupt can continuously 'give' the semaphore while
N * another continuously 'takes' the semaphore.  For this reason this type of
N * semaphore does not use a priority inheritance mechanism.  For an alternative
N * that does use priority inheritance see xSemaphoreCreateMutex().
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the semaphore is created then a handle to the created semaphore is
N * returned.  If pxSemaphoreBuffer is NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateBinary().
N    // The semaphore's data structures will be placed in the xSemaphoreBuffer
N    // variable, the address of which is passed into the function.  The
N    // function's parameter is not NULL, so the function will not attempt any
N    // dynamic memory allocation, and therefore the function will not return
N    // return NULL.
N    xSemaphore = xSemaphoreCreateBinary( &xSemaphoreBuffer );
N
N    // Rest of task code goes here.
N }
N </pre>
N * \defgroup xSemaphoreCreateBinaryStatic xSemaphoreCreateBinaryStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateBinaryStatic( pxStaticSemaphore ) xQueueGenericCreateStatic( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticSemaphore, queueQUEUE_TYPE_BINARY_SEMAPHORE )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>xSemaphoreTake(
N *                   SemaphoreHandle_t xSemaphore,
N *                   TickType_t xBlockTime
N *               )</pre>
N *
N * <i>Macro</i> to obtain a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting().
N *
N * @param xSemaphore A handle to the semaphore being taken - obtained when
N * the semaphore was created.
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  A block
N * time of portMAX_DELAY can be used to block indefinitely (provided
N * INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE
N * if xBlockTime expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N // A task that creates a semaphore.
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = xSemaphoreCreateBinary();
N }
N
N // A task that uses the semaphore.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xSemaphore != NULL )
N    {
N        // See if we can obtain the semaphore.  If the semaphore is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the semaphore and can now access the
N            // shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource.  Release the
N            // semaphore.
N            xSemaphoreGive( xSemaphore );
N        }
N        else
N        {
N            // We could not obtain the semaphore and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTake xSemaphoreTake
N * \ingroup Semaphores
N */
N#define xSemaphoreTake( xSemaphore, xBlockTime )		xQueueGenericReceive( ( QueueHandle_t ) ( xSemaphore ), NULL, ( xBlockTime ), pdFALSE )
N
N/**
N * semphr. h
N * xSemaphoreTakeRecursive(
N *                          SemaphoreHandle_t xMutex,
N *                          TickType_t xBlockTime
N *                        )
N *
N * <i>Macro</i> to recursively obtain, or 'take', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being obtained.  This is the
N * handle returned by xSemaphoreCreateRecursiveMutex();
N *
N * @param xBlockTime The time in ticks to wait for the semaphore to become
N * available.  The macro portTICK_PERIOD_MS can be used to convert this to a
N * real time.  A block time of zero can be used to poll the semaphore.  If
N * the task already owns the semaphore then xSemaphoreTakeRecursive() will
N * return immediately no matter what the value of xBlockTime.
N *
N * @return pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime
N * expired without the semaphore becoming available.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xSemaphore, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, but instead buried in a more complex
N			// call structure.  This is just for illustrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreTakeRecursive xSemaphoreTakeRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreTakeRecursive( xMutex, xBlockTime )	xQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) )
N#endif
N
N/**
N * semphr. h
N * <pre>xSemaphoreGive( SemaphoreHandle_t xSemaphore )</pre>
N *
N * <i>Macro</i> to release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary(), xSemaphoreCreateMutex() or
N * xSemaphoreCreateCounting(). and obtained using sSemaphoreTake().
N *
N * This macro must not be used from an ISR.  See xSemaphoreGiveFromISR () for
N * an alternative which can be used from an ISR.
N *
N * This macro must also not be used on semaphores created using
N * xSemaphoreCreateRecursiveMutex().
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @return pdTRUE if the semaphore was released.  pdFALSE if an error occurred.
N * Semaphores are implemented using queues.  An error can occur if there is
N * no space on the queue to post a message - indicating that the
N * semaphore was not first obtained correctly.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore = NULL;
N
N void vATask( void * pvParameters )
N {
N    // Create the semaphore to guard a shared resource.
N    xSemaphore = vSemaphoreCreateBinary();
N
N    if( xSemaphore != NULL )
N    {
N        if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N        {
N            // We would expect this call to fail because we cannot give
N            // a semaphore without first "taking" it!
N        }
N
N        // Obtain the semaphore - don't block if the semaphore is not
N        // immediately available.
N        if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
N        {
N            // We now have the semaphore and can access the shared resource.
N
N            // ...
N
N            // We have finished accessing the shared resource so can free the
N            // semaphore.
N            if( xSemaphoreGive( xSemaphore ) != pdTRUE )
N            {
N                // We would not expect this call to fail because we must have
N                // obtained the semaphore to get here.
N            }
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGive xSemaphoreGive
N * \ingroup Semaphores
N */
N#define xSemaphoreGive( xSemaphore )		xQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK )
N
N/**
N * semphr. h
N * <pre>xSemaphoreGiveRecursive( SemaphoreHandle_t xMutex )</pre>
N *
N * <i>Macro</i> to recursively release, or 'give', a mutex type semaphore.
N * The mutex must have previously been created using a call to
N * xSemaphoreCreateRecursiveMutex();
N *
N * configUSE_RECURSIVE_MUTEXES must be set to 1 in FreeRTOSConfig.h for this
N * macro to be available.
N *
N * This macro must not be used on mutexes created using xSemaphoreCreateMutex().
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * @param xMutex A handle to the mutex being released, or 'given'.  This is the
N * handle returned by xSemaphoreCreateMutex();
N *
N * @return pdTRUE if the semaphore was given.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xMutex = NULL;
N
N // A task that creates a mutex.
N void vATask( void * pvParameters )
N {
N    // Create the mutex to guard a shared resource.
N    xMutex = xSemaphoreCreateRecursiveMutex();
N }
N
N // A task that uses the mutex.
N void vAnotherTask( void * pvParameters )
N {
N    // ... Do other things.
N
N    if( xMutex != NULL )
N    {
N        // See if we can obtain the mutex.  If the mutex is not available
N        // wait 10 ticks to see if it becomes free.
N        if( xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 ) == pdTRUE )
N        {
N            // We were able to obtain the mutex and can now access the
N            // shared resource.
N
N            // ...
N            // For some reason due to the nature of the code further calls to
N			// xSemaphoreTakeRecursive() are made on the same mutex.  In real
N			// code these would not be just sequential calls as this would make
N			// no sense.  Instead the calls are likely to be buried inside
N			// a more complex call structure.
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N            xSemaphoreTakeRecursive( xMutex, ( TickType_t ) 10 );
N
N            // The mutex has now been 'taken' three times, so will not be
N			// available to another task until it has also been given back
N			// three times.  Again it is unlikely that real code would have
N			// these calls sequentially, it would be more likely that the calls
N			// to xSemaphoreGiveRecursive() would be called as a call stack
N			// unwound.  This is just for demonstrative purposes.
N            xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N			xSemaphoreGiveRecursive( xMutex );
N
N			// Now the mutex can be taken by other tasks.
N        }
N        else
N        {
N            // We could not obtain the mutex and can therefore not access
N            // the shared resource safely.
N        }
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveRecursive xSemaphoreGiveRecursive
N * \ingroup Semaphores
N */
N#if( configUSE_RECURSIVE_MUTEXES == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreGiveRecursive( xMutex )	xQueueGiveMutexRecursive( ( xMutex ) )
N#endif
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreGiveFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  release a semaphore.  The semaphore must have previously been
N * created with a call to xSemaphoreCreateBinary() or xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR.
N *
N * @param xSemaphore A handle to the semaphore being released.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreGiveFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.
N *
N * Example usage:
N <pre>
N \#define LONG_TIME 0xffff
N \#define TICKS_TO_WAIT	10
N SemaphoreHandle_t xSemaphore = NULL;
N
N // Repetitive task.
N void vATask( void * pvParameters )
N {
N    for( ;; )
N    {
N        // We want this task to run every 10 ticks of a timer.  The semaphore
N        // was created before this task was started.
N
N        // Block waiting for the semaphore to become available.
N        if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
N        {
N            // It is time to execute.
N
N            // ...
N
N            // We have finished our task.  Return to the top of the loop where
N            // we will block on the semaphore until it is time to execute
N            // again.  Note when using the semaphore for synchronisation with an
N			// ISR in this manner there is no need to 'give' the semaphore back.
N        }
N    }
N }
N
N // Timer ISR
N void vTimerISR( void * pvParameters )
N {
N static uint8_t ucLocalTickCount = 0;
N static BaseType_t xHigherPriorityTaskWoken;
N
N    // A timer tick has occurred.
N
N    // ... Do other time functions.
N
N    // Is it time for vATask () to run?
N	xHigherPriorityTaskWoken = pdFALSE;
N    ucLocalTickCount++;
N    if( ucLocalTickCount >= TICKS_TO_WAIT )
N    {
N        // Unblock the task by releasing the semaphore.
N        xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken );
N
N        // Reset the count so we release the semaphore again in 10 ticks time.
N        ucLocalTickCount = 0;
N    }
N
N    if( xHigherPriorityTaskWoken != pdFALSE )
N    {
N        // We can force a context switch here.  Context switching from an
N        // ISR uses port specific syntax.  Check the demo task for your port
N        // to find the syntax required.
N    }
N }
N </pre>
N * \defgroup xSemaphoreGiveFromISR xSemaphoreGiveFromISR
N * \ingroup Semaphores
N */
N#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>
N xSemaphoreTakeFromISR(
N                          SemaphoreHandle_t xSemaphore,
N                          BaseType_t *pxHigherPriorityTaskWoken
N                      )</pre>
N *
N * <i>Macro</i> to  take a semaphore from an ISR.  The semaphore must have
N * previously been created with a call to xSemaphoreCreateBinary() or
N * xSemaphoreCreateCounting().
N *
N * Mutex type semaphores (those created using a call to xSemaphoreCreateMutex())
N * must not be used with this macro.
N *
N * This macro can be used from an ISR, however taking a semaphore from an ISR
N * is not a common operation.  It is likely to only be useful when taking a
N * counting semaphore when an interrupt is obtaining an object from a resource
N * pool (when the semaphore count indicates the number of resources available).
N *
N * @param xSemaphore A handle to the semaphore being taken.  This is the
N * handle returned when the semaphore was created.
N *
N * @param pxHigherPriorityTaskWoken xSemaphoreTakeFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the semaphore was successfully taken, otherwise
N * pdFALSE
N */
N#define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )	xQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) )
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutex( void )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return If the mutex was successfully created then a handle to the created
N * semaphore is returned.  If there was not enough heap to allocate the mutex
N * data structures then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateMutex xSemaphoreCreateMutex
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new mutex type semaphore instance, and returns a handle by which
N * the new mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, mutex semaphores use a block
N * of memory, in which the mutex structure is stored.  If a mutex is created
N * using xSemaphoreCreateMutex() then the required memory is automatically
N * dynamically allocated inside the xSemaphoreCreateMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a mutex is created using
N * xSemaphoreCreateMutexStatic() then the application writer must provided the
N * memory.  xSemaphoreCreateMutexStatic() therefore allows a mutex to be created
N * without using any dynamic memory allocation.
N *
N * Mutexes created using this function can be accessed using the xSemaphoreTake()
N * and xSemaphoreGive() macros.  The xSemaphoreTakeRecursive() and
N * xSemaphoreGiveRecursive() macros must not be used.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will be used to hold the mutex's data structure, removing the need for
N * the memory to be allocated dynamically.
N *
N * @return If the mutex was successfully created then a handle to the created
N * mutex is returned.  If pxMutexBuffer was NULL then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A mutex cannot be used before it has been created.  xMutexBuffer is
N    // into xSemaphoreCreateMutexStatic() so no dynamic memory allocation is
N    // attempted.
N    xSemaphore = xSemaphoreCreateMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateMutexStatic xSemaphoreCreateMutexStatic
N * \ingroup Semaphores
N */
N #if( configSUPPORT_STATIC_ALLOCATION == 1 )
X #if( 0 == 1 )
S	#define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @return xSemaphore Handle to the created mutex semaphore.  Should be of type
N * SemaphoreHandle_t.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N    // Semaphore cannot be used before a call to xSemaphoreCreateMutex().
N    // This is a macro so pass the variable in directly.
N    xSemaphore = xSemaphoreCreateRecursiveMutex();
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutex xSemaphoreCreateRecursiveMutex
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 1 == 1 ) && ( 0 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateRecursiveMutexStatic( StaticSemaphore_t *pxMutexBuffer )</pre>
N *
N * Creates a new recursive mutex type semaphore instance, and returns a handle
N * by which the new recursive mutex can be referenced.
N *
N * Internally, within the FreeRTOS implementation, recursive mutexs use a block
N * of memory, in which the mutex structure is stored.  If a recursive mutex is
N * created using xSemaphoreCreateRecursiveMutex() then the required memory is
N * automatically dynamically allocated inside the
N * xSemaphoreCreateRecursiveMutex() function.  (see
N * http://www.freertos.org/a00111.html).  If a recursive mutex is created using
N * xSemaphoreCreateRecursiveMutexStatic() then the application writer must
N * provide the memory that will get used by the mutex.
N * xSemaphoreCreateRecursiveMutexStatic() therefore allows a recursive mutex to
N * be created without using any dynamic memory allocation.
N *
N * Mutexes created using this macro can be accessed using the
N * xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The
N * xSemaphoreTake() and xSemaphoreGive() macros must not be used.
N *
N * A mutex used recursively can be 'taken' repeatedly by the owner. The mutex
N * doesn't become available again until the owner has called
N * xSemaphoreGiveRecursive() for each successful 'take' request.  For example,
N * if a task successfully 'takes' the same mutex 5 times then the mutex will
N * not be available to any other task until it has also  'given' the mutex back
N * exactly five times.
N *
N * This type of semaphore uses a priority inheritance mechanism so a task
N * 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the
N * semaphore it is no longer required.
N *
N * Mutex type semaphores cannot be used from within interrupt service routines.
N *
N * See xSemaphoreCreateBinary() for an alternative implementation that can be
N * used for pure synchronisation (where one task or interrupt always 'gives' the
N * semaphore and another always 'takes' the semaphore) and from within interrupt
N * service routines.
N *
N * @param pxMutexBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the recursive mutex's data structure,
N * removing the need for the memory to be allocated dynamically.
N *
N * @return If the recursive mutex was successfully created then a handle to the
N * created recursive mutex is returned.  If pxMutexBuffer was NULL then NULL is
N * returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xMutexBuffer;
N
N void vATask( void * pvParameters )
N {
N    // A recursive semaphore cannot be used before it is created.  Here a
N    // recursive mutex is created using xSemaphoreCreateRecursiveMutexStatic().
N    // The address of xMutexBuffer is passed into the function, and will hold
N    // the mutexes data structures - so no dynamic memory allocation will be
N    // attempted.
N    xSemaphore = xSemaphoreCreateRecursiveMutexStatic( &xMutexBuffer );
N
N    // As no dynamic memory allocation was performed, xSemaphore cannot be NULL,
N    // so there is no need to check it.
N }
N </pre>
N * \defgroup xSemaphoreCreateRecursiveMutexStatic xSemaphoreCreateRecursiveMutexStatic
N * \ingroup Semaphores
N */
N#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_RECURSIVE_MUTEXES == 1 ) )
X#if( ( 0 == 1 ) && ( 0 == 1 ) )
S	#define xSemaphoreCreateRecursiveMutexStatic( pxStaticSemaphore ) xQueueCreateMutexStatic( queueQUEUE_TYPE_RECURSIVE_MUTEX, pxStaticSemaphore )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer can
N * instead optionally provide the memory that will get used by the counting
N * semaphore.  xSemaphoreCreateCountingStatic() therefore allows a counting
N * semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @return Handle to the created semaphore.  Null if the semaphore could not be
N *         created.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Semaphore cannot be used before a call to xSemaphoreCreateCounting().
N    // The max value to which the semaphore can count should be 10, and the
N    // initial value assigned to the count should be 0.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0 );
N
N    if( xSemaphore != NULL )
N    {
N        // The semaphore was created successfully.
N        // The semaphore can now be used.
N    }
N }
N </pre>
N * \defgroup xSemaphoreCreateCounting xSemaphoreCreateCounting
N * \ingroup Semaphores
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) )
N#endif
N
N/**
N * semphr. h
N * <pre>SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer )</pre>
N *
N * Creates a new counting semaphore instance, and returns a handle by which the
N * new counting semaphore can be referenced.
N *
N * In many usage scenarios it is faster and more memory efficient to use a
N * direct to task notification in place of a counting semaphore!
N * http://www.freertos.org/RTOS-task-notifications.html
N *
N * Internally, within the FreeRTOS implementation, counting semaphores use a
N * block of memory, in which the counting semaphore structure is stored.  If a
N * counting semaphore is created using xSemaphoreCreateCounting() then the
N * required memory is automatically dynamically allocated inside the
N * xSemaphoreCreateCounting() function.  (see
N * http://www.freertos.org/a00111.html).  If a counting semaphore is created
N * using xSemaphoreCreateCountingStatic() then the application writer must
N * provide the memory.  xSemaphoreCreateCountingStatic() therefore allows a
N * counting semaphore to be created without using any dynamic memory allocation.
N *
N * Counting semaphores are typically used for two things:
N *
N * 1) Counting events.
N *
N *    In this usage scenario an event handler will 'give' a semaphore each time
N *    an event occurs (incrementing the semaphore count value), and a handler
N *    task will 'take' a semaphore each time it processes an event
N *    (decrementing the semaphore count value).  The count value is therefore
N *    the difference between the number of events that have occurred and the
N *    number that have been processed.  In this case it is desirable for the
N *    initial count value to be zero.
N *
N * 2) Resource management.
N *
N *    In this usage scenario the count value indicates the number of resources
N *    available.  To obtain control of a resource a task must first obtain a
N *    semaphore - decrementing the semaphore count value.  When the count value
N *    reaches zero there are no free resources.  When a task finishes with the
N *    resource it 'gives' the semaphore back - incrementing the semaphore count
N *    value.  In this case it is desirable for the initial count value to be
N *    equal to the maximum count value, indicating that all resources are free.
N *
N * @param uxMaxCount The maximum count value that can be reached.  When the
N *        semaphore reaches this value it can no longer be 'given'.
N *
N * @param uxInitialCount The count value assigned to the semaphore when it is
N *        created.
N *
N * @param pxSemaphoreBuffer Must point to a variable of type StaticSemaphore_t,
N * which will then be used to hold the semaphore's data structure, removing the
N * need for the memory to be allocated dynamically.
N *
N * @return If the counting semaphore was successfully created then a handle to
N * the created counting semaphore is returned.  If pxSemaphoreBuffer was NULL
N * then NULL is returned.
N *
N * Example usage:
N <pre>
N SemaphoreHandle_t xSemaphore;
N StaticSemaphore_t xSemaphoreBuffer;
N
N void vATask( void * pvParameters )
N {
N SemaphoreHandle_t xSemaphore = NULL;
N
N    // Counting semaphore cannot be used before they have been created.  Create
N    // a counting semaphore using xSemaphoreCreateCountingStatic().  The max
N    // value to which the semaphore can count is 10, and the initial value
N    // assigned to the count will be 0.  The address of xSemaphoreBuffer is
N    // passed in and will be used to hold the semaphore structure, so no dynamic
N    // memory allocation will be used.
N    xSemaphore = xSemaphoreCreateCounting( 10, 0, &xSemaphoreBuffer );
N
N    // No memory allocation was attempted so xSemaphore cannot be NULL, so there
N    // is no need to check its value.
N }
N </pre>
N * \defgroup xSemaphoreCreateCountingStatic xSemaphoreCreateCountingStatic
N * \ingroup Semaphores
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	#define xSemaphoreCreateCountingStatic( uxMaxCount, uxInitialCount, pxSemaphoreBuffer ) xQueueCreateCountingSemaphoreStatic( ( uxMaxCount ), ( uxInitialCount ), ( pxSemaphoreBuffer ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * semphr. h
N * <pre>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );</pre>
N *
N * Delete a semaphore.  This function must be used with care.  For example,
N * do not delete a mutex type semaphore if the mutex is held by a task.
N *
N * @param xSemaphore A handle to the semaphore to be deleted.
N *
N * \defgroup vSemaphoreDelete vSemaphoreDelete
N * \ingroup Semaphores
N */
N#define vSemaphoreDelete( xSemaphore ) vQueueDelete( ( QueueHandle_t ) ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolder( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N * Note: This is a good way of determining if the calling task is the mutex
N * holder, but not a good way of determining the identity of the mutex holder as
N * the holder may change between the function exiting and the returned value
N * being tested.
N */
N#define xSemaphoreGetMutexHolder( xSemaphore ) xQueueGetMutexHolder( ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>TaskHandle_t xSemaphoreGetMutexHolderFromISR( SemaphoreHandle_t xMutex );</pre>
N *
N * If xMutex is indeed a mutex type semaphore, return the current mutex holder.
N * If xMutex is not a mutex type semaphore, or the mutex is available (not held
N * by a task), return NULL.
N *
N */
N#define xSemaphoreGetMutexHolderFromISR( xSemaphore ) xQueueGetMutexHolderFromISR( ( xSemaphore ) )
N
N/**
N * semphr.h
N * <pre>UBaseType_t uxSemaphoreGetCount( SemaphoreHandle_t xSemaphore );</pre>
N *
N * If the semaphore is a counting semaphore then uxSemaphoreGetCount() returns
N * its current count value.  If the semaphore is a binary semaphore then
N * uxSemaphoreGetCount() returns 1 if the semaphore is available, and 0 if the
N * semaphore is not available.
N *
N */
N#define uxSemaphoreGetCount( xSemaphore ) uxQueueMessagesWaiting( ( QueueHandle_t ) ( xSemaphore ) )
N
N#endif /* SEMAPHORE_H */
N
N
L 23 "src\user\hwtester.c" 2
N
N#include "fepconfig.h"
L 1 ".\src\fepconfig.h" 1
N/**************************************************************************//**
N* @file  fepconfig.c
N* @version  V1.00
N* $Revision:
N* $Date:
N* @brief
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __FEP_CONFIG_H__
N#define __FEP_CONFIG_H__
N
N#include "nuc970.h"
N#include "VersionMacro.h"
L 1 ".\src\VersionMacro.h" 1
N/**
N
N*/ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __VERSION_MACRO_H
N#define __VERSION_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include <stdio.h>
N
N//#include "TypeDef.h"
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N#define BUILD_YEAR_CH0 ((__DATE__)[ 7])
N#define BUILD_YEAR_CH1 ((__DATE__)[ 8])
N#define BUILD_YEAR_CH2 ((__DATE__)[ 9])
N#define BUILD_YEAR_CH3 ((__DATE__)[10])
N
N
N#define BUILD_MONTH_IS_JAN ((__DATE__)[0] == 'J' && (__DATE__)[1] == 'a' && (__DATE__)[2] == 'n')
N#define BUILD_MONTH_IS_FEB ((__DATE__)[0] == 'F')
N#define BUILD_MONTH_IS_MAR ((__DATE__)[0] == 'M' && (__DATE__)[1] == 'a' && (__DATE__)[2] == 'r')
N#define BUILD_MONTH_IS_APR ((__DATE__)[0] == 'A' && (__DATE__)[1] == 'p')
N#define BUILD_MONTH_IS_MAY ((__DATE__)[0] == 'M' && (__DATE__)[1] == 'a' && (__DATE__)[2] == 'y')
N#define BUILD_MONTH_IS_JUN ((__DATE__)[0] == 'J' && (__DATE__)[1] == 'u' && (__DATE__)[2] == 'n')
N#define BUILD_MONTH_IS_JUL ((__DATE__)[0] == 'J' && (__DATE__)[1] == 'u' && (__DATE__)[2] == 'l')
N#define BUILD_MONTH_IS_AUG ((__DATE__)[0] == 'A' && (__DATE__)[1] == 'u')
N#define BUILD_MONTH_IS_SEP ((__DATE__)[0] == 'S')
N#define BUILD_MONTH_IS_OCT ((__DATE__)[0] == 'O')
N#define BUILD_MONTH_IS_NOV ((__DATE__)[0] == 'N')
N#define BUILD_MONTH_IS_DEC ((__DATE__)[0] == 'D')
N
N
N#define BUILD_MONTH_CH0 \
N    ((BUILD_MONTH_IS_OCT || BUILD_MONTH_IS_NOV || BUILD_MONTH_IS_DEC) ? '1' : '0')
X#define BUILD_MONTH_CH0     ((BUILD_MONTH_IS_OCT || BUILD_MONTH_IS_NOV || BUILD_MONTH_IS_DEC) ? '1' : '0')
N
N#define BUILD_MONTH_CH1 \
N    ( \
N        (BUILD_MONTH_IS_JAN) ? '1' : \
N        (BUILD_MONTH_IS_FEB) ? '2' : \
N        (BUILD_MONTH_IS_MAR) ? '3' : \
N        (BUILD_MONTH_IS_APR) ? '4' : \
N        (BUILD_MONTH_IS_MAY) ? '5' : \
N        (BUILD_MONTH_IS_JUN) ? '6' : \
N        (BUILD_MONTH_IS_JUL) ? '7' : \
N        (BUILD_MONTH_IS_AUG) ? '8' : \
N        (BUILD_MONTH_IS_SEP) ? '9' : \
N        (BUILD_MONTH_IS_OCT) ? '0' : \
N        (BUILD_MONTH_IS_NOV) ? '1' : \
N        (BUILD_MONTH_IS_DEC) ? '2' : \
N        /* error default */    '?' \
N    )
X#define BUILD_MONTH_CH1     (         (BUILD_MONTH_IS_JAN) ? '1' :         (BUILD_MONTH_IS_FEB) ? '2' :         (BUILD_MONTH_IS_MAR) ? '3' :         (BUILD_MONTH_IS_APR) ? '4' :         (BUILD_MONTH_IS_MAY) ? '5' :         (BUILD_MONTH_IS_JUN) ? '6' :         (BUILD_MONTH_IS_JUL) ? '7' :         (BUILD_MONTH_IS_AUG) ? '8' :         (BUILD_MONTH_IS_SEP) ? '9' :         (BUILD_MONTH_IS_OCT) ? '0' :         (BUILD_MONTH_IS_NOV) ? '1' :         (BUILD_MONTH_IS_DEC) ? '2' :              '?'     )
N
N#define BUILD_DAY_CH0 (((__DATE__)[4] >= '0') ? ((__DATE__)[4]) : '0')
N#define BUILD_DAY_CH1 ((__DATE__)[ 5])
N
N
N
N// Example of (_IME__) string: "21:06:19"
N//                              01234567
N
N#define BUILD_HOUR_CH0 ((__TIME__)[0])
N#define BUILD_HOUR_CH1 ((__TIME__)[1])
N
N#define BUILD_MIN_CH0 ((__TIME__)[3])
N#define BUILD_MIN_CH1 ((__TIME__)[4])
N
N#define BUILD_SEC_CH0 ((__TIME__)[6])
N#define BUILD_SEC_CH1 ((__TIME__)[7])
N
N/* Private macro -------------------------------------------------------------*/
N
N
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __VERSION_MACRO_H */
N
N/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
L 17 ".\src\fepconfig.h" 2
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define MAJOR_VERSION                   1
N#define MINOR_VERSION                   9
N#define REVISION_VERSION                7
N#define BUILD_VERSION                   ((/*(BUILD_YEAR_CH0-'0')*1000 + (BUILD_YEAR_CH1-'0')*100 + */(BUILD_YEAR_CH2-'0')*10 + (BUILD_YEAR_CH3-'0'))*100000000 + \
N                                                                                                    ((BUILD_MONTH_CH0-'0')*10 + (BUILD_MONTH_CH1-'0'))*1000000 + \
N                                                                                                          ((BUILD_DAY_CH0-'0')*10 + (BUILD_DAY_CH1-'0'))*10000 + \
N                                                                                                          ((BUILD_HOUR_CH0-'0')*10 + (BUILD_HOUR_CH1-'0'))*100 + \
N                                                                                                        ((BUILD_MIN_CH0-'0')*10 + (BUILD_MIN_CH1-'0'))*1) 
X#define BUILD_VERSION                   (( (BUILD_YEAR_CH2-'0')*10 + (BUILD_YEAR_CH3-'0'))*100000000 +                                                                                                     ((BUILD_MONTH_CH0-'0')*10 + (BUILD_MONTH_CH1-'0'))*1000000 +                                                                                                           ((BUILD_DAY_CH0-'0')*10 + (BUILD_DAY_CH1-'0'))*10000 +                                                                                                           ((BUILD_HOUR_CH0-'0')*10 + (BUILD_HOUR_CH1-'0'))*100 +                                                                                                         ((BUILD_MIN_CH0-'0')*10 + (BUILD_MIN_CH1-'0'))*1) 
N#define BUILD_VERSION_EX              BUILD_VERSION  
N#define FREERTOS_USE_1000MHZ            0     
N#define USER_NEW_FATFS                  0      
N#define ENABLE_MODEM_CMD_DEBUG          0
N#define ENABLE_MODEM_FLOW_CONTROL       0 
N    
N#define BUILD_RELEASE_VERSION           0  
N#define BUILD_PRE_RELEASE_VERSION       0 
N#define BUILD_DEBUG_VERSION             0
N#define BUILD_HW_TESTER_VERSION         1
N    
N#define ENABLE_LOG_FUNCTION             1 
N#define ENABLE_BURNIN_TESTER            1
N#define ENABLE_MTP_FUNCTION             1
N#define SUPPORT_HK_10_HW                1//by Jer
N//=================================================
N#if(0)
S    //UserDrv
S    #define ENABLE_LED_DRIVER               1
S    #define ENABLE_BATTERY_DRIVER           1   
S    #define ENABLE_BUZZER_DRIVER            1    
S    //SysHal
S    #define ENABLE_GUI_DRIVER               1
S    #define ENABLE_POWER_DRIVER             1  
S    #define ENABLE_YAFFS2_DRIVER            0  
S    #define ENABLE_FATFS_DRIVER             1     
S    #define ENABLE_EPD_DRIVER               1   
S    #define ENABLE_CARD_READER_DRIVER       1 
S    #define ENABLE_SPACE_DRIVER             1 
S    #define ENABLE_MODEM_AGENT_DRIVER       0 
S    #define ENABLE_DATA_AGENT_DRIVER        0     
S    #define ENABLE_TAKE_PHOTO_DRIVER        1
S    #define ENABLE_PHOTO_AGENT_DRIVER       1
S    //User 
S    #define ENABLE_USER_DRIVER              1 
S    #define ENABLE_PARA_LIB                 1  
S    #define ENABLE_GUI_MANAGER              1
S    #define ENABLE_POWER_DOWN               0
S    
N#else
N    //UserDrv
N    #define ENABLE_LED_DRIVER               1
N    #define ENABLE_BATTERY_DRIVER           1   
N    #define ENABLE_BUZZER_DRIVER            1    
N    //SysHal
N    #define ENABLE_GUI_DRIVER               1
N    #define ENABLE_POWER_DRIVER             1  
N    #define ENABLE_YAFFS2_DRIVER            0   
N    #define ENABLE_FATFS_DRIVER             1     
N    #define ENABLE_EPD_DRIVER               1   
N    #define ENABLE_CARD_READER_DRIVER       1 
N    #define ENABLE_SPACE_DRIVER             1 
N    #define ENABLE_MODEM_AGENT_DRIVER       1 
N    #define ENABLE_DATA_AGENT_DRIVER        0     
N    #define ENABLE_TAKE_PHOTO_DRIVER        1
N    #define ENABLE_PHOTO_AGENT_DRIVER       1
N    //User 
N    #define ENABLE_USER_DRIVER              1 
N    #define ENABLE_PARA_LIB                 1  
N    #define ENABLE_GUI_MANAGER              1
N    #define ENABLE_POWER_DOWN               1
N#endif
N
N//=================================================
N
N#define DEFAULT_TARIFF_FILE_FTP_PATH            "tariffdir"
N#define DEFAULT_PARA_FILE_FTP_PATH              "paradir"
N#define DEFAULT_DCF_FILE_FTP_PATH               "dcfdsfdir"
N#define DEFAULT_DSF_FILE_FTP_PATH               "dcfdsfdir"
N#define DEFAULT_JPG_FILE_FTP_PATH               "jpgdir"
N#define DEFAULT_LOG_FILE_FTP_PATH               "logdir"
N
N//#define WEB_POST_ADDRESS                "HTTP://118.163.153.124:3000/API/getInfo?"
N#define WEB_POST_ADDRESS              "http://210.17.120.42/DCU/api/"  //"HTTP://54.249.1.95:7878/?"
N#if(1)
N    #if(1)
N        //#define FTP_ADDRESS                     "118.163.153.124"
N        //#define FTP_PORT                        "4000"
N        #define FTP_ADDRESS                     "ftp.green-ideas.com.tw" //"vpn3rgitcam.asuscomm.com" //"36.230.240.241"  //"ftp.green-ideas.com.tw"
N        #define FTP_PORT                        "21"  //"9000" 
N
N    #else
S        #define FTP_ADDRESS                     "54.250.171.197"//"118.163.153.124"
S        //#define FTP_PORT                        "21"//"4000"
S        #define FTP_PORT                        "4000"
N    #endif
N    #define FTP_ID                          "parking"  //"BurnTest"             //"test"
N    #define FTP_PASSWD                      "git123456"  //"git123456789"         //"123456"
N    #define FTP_PRE_PATH                    "test/"                   //"home/test/"  
N
N#else
S    #define FTP_ADDRESS                     "54.249.1.95"
S    #define FTP_PORT                        "21"
S    #define FTP_ID                          "sam"
S    #define FTP_PASSWD                      "samsam"
S    #define FTP_PRE_PATH                    "home/test/"  //""  
N#endif
N
N
N#define BASE_DATA_DIR                   "1:"    
N
N//#define FILE_SAVE_POSITION   FILE_AGENT_STORAGE_TYPE_FATFS
N#define FILE_SAVE_POSITION   FILE_AGENT_STORAGE_TYPE_AUTO
N
N#define EPM_ID_SAVE_POSITION            FILE_AGENT_STORAGE_TYPE_FATFS
N#define EPM_ID_FILE_DIR                 "0:"
N#define EPM_ID_FILE_NAME                "epm.id"
N
N#define EPM_STORAGE_SAVE_POSITION       FILE_SAVE_POSITION
N#define EPM_STORAGE_FILE_DIR            "1:"
N#define EPM_STORAGE_FILE_NAME           "epmstorage.dat"
N    
N#define EPM_PARA_SAVE_POSITION          FILE_SAVE_POSITION
N#define EPM_PARA_FILE_DIR               "1:"
N#define EPM_PRAR_FILE_EXTENSION         "pre"
N#define EPM_PARA_FILE_NAME              "epm.pre"
N    
N#define TARIFF_FILE_SAVE_POSITION       FILE_SAVE_POSITION
N#define TARIFF_FILE_DIR                 "1:"
N#define TARIFF_FILE_EXTENSION           "tre"   
N
N#define LOG_SAVE_POSITION               FILE_SAVE_POSITION
N#define LOG_FILE_EXTENSION              "log"
N#define LOG_FILE_DIR                    "1:"
N    
N#define PHOTO_SAVE_POSITION             FILE_SAVE_POSITION
N#define PHOTO_FILE_EXTENSION            "jpg"
N#define PHOTO_FILE_DIR                  "1:"   
N
N#define DSF_FILE_SAVE_POSITION          FILE_SAVE_POSITION
N#define DSF_FILE_EXTENSION              "dsf"
N#define DSF_FILE_DIR                    "1:"  
N
N#define DCF_FILE_SAVE_POSITION          FILE_SAVE_POSITION
N#define DCF_FILE_EXTENSION              "dcf"
N#define DCF_FILE_DIR                    "1:"
N        
N#define FILE_EXTENSION_EX(e)            "*."e  
N
N
N
N   
N    
N//SysHal
N#define DRV_INIT_THREAD_PROI            (configMAX_PRIORITIES-1)
N#define POWER_THREAD_PROI               (configMAX_PRIORITIES-2)
N#define NT066E_DRV_THREAD_PROI          (configMAX_PRIORITIES-3)
N#define DIP_THREAD_PROI                 NT066E_DRV_THREAD_PROI
N#define TIMER_DRV_0_THREAD_PROI         (NT066E_DRV_THREAD_PROI - 1)
N#define TIMER_DRV_1_THREAD_PROI         (TIMER_DRV_0_THREAD_PROI - 1)
N#define TIMER_DRV_2_THREAD_PROI         (TIMER_DRV_0_THREAD_PROI - 2)
N#define BUZZER_DRV_THREAD_PROI          (TIMER_DRV_0_THREAD_PROI - 1)
N#define CARD_READER_THREAD_PROI         (TIMER_DRV_2_THREAD_PROI - 1)
N#define SPACE_DRV_THREAD_PROI           4
N#define BATTERY_THREAD_PROI             3
N#define DEBUG_THREAD_PROI               (configMAX_PRIORITIES-1)//1
N//#define DATA_AGENT_RX_THREAD_PROI               8 
N//#define DATA_AGENT_TX_THREAD_PROI               7 
N//#define DATA_AGENT_ROUTINE_THREAD_PROI          6 
N//#define MODEM_AGENT_RX_THREAD_PROI               8 
N#define MODEM_AGENT_TX_THREAD_PROI               3 
N#define MODEM_AGENT_ROUTINE_THREAD_PROI          7 
N#define METER_DATA_PROCESS_THREAD_PROI          6 
N#define METER_TAKE_PHOTO_PROCESS_THREAD_PROI    5 
N#define EPD_BACK_LIGHT_THREAD_PROI              1 
N#define LED_THREAD_PROI                         1 
N#define GUI_DRAWING_PROI                        1
N#define RADAR_THREAD_PROI                       2 
N#define FILE_AGENT_THREAD_PROI                  5//2
N
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
N#define GUI_MANAGER_THREAD_PROI                 20
N#define LED_BUZZER_TEST_THREAD_PROI             3
N#define BATTERY_TEST_THREAD_PROI                2
N#define MODEM_TEST_THREAD_PROI                  2
N#define SMART_CARD_TEST_THREAD_PROI             2
N#define NAND_FLASH_TEST_THREAD_PROI             3
N#define CARD_READER_TEST_THREAD_PROI            3
N#define SD_CARD_TEST_THREAD_PROI                4
N#define CAMERA_TEST_THREAD_PROI                 5
N#endif
N
N
N//UserDrv
N//#define PTC_CAM_THREAD_PROI             5
N//#define UART10_THREAD_PROI              5
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif//__FEP_CONFIG_H__
L 25 "src\user\hwtester.c" 2
N#include "hwtester.h"
L 1 "src\user\hwtester.h" 1
N/**************************************************************************//**
N* @file     hwtester.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __HW_TESTER_H__
N#define __HW_TESTER_H__
N
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N#include "nuc970.h"
N#include "sys.h"
N#include "keydrv.h"
L 1 ".\src\syshal\keydrv.h" 1
N/**************************************************************************//**
N* @file     keydrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __KEY_DRV_H__
N#define __KEY_DRV_H__
N
N#include "nuc970.h"
N#include "halinterface.h"
L 1 ".\src\syshal\halinterface.h" 1
N/**************************************************************************//**
N* @file     uartinterface.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __HAL_INTERFACE_H__
N#define __HAL_INTERFACE_H__
N
N#include "nuc970.h"
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N#include "rtc.h"
L 1 "..\..\common\src\BSP\Driver\Include\rtc.h" 1
N/**************************************************************************//**
N* @file     RTC.h
N* @version  V1.00
N* $Revision: 1 $
N* $Date: 15/05/29 10:48a $
N* @brief    NUC970 RTC driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __DRVRTC_H__
N#define __DRVRTC_H__
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of system headers                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "nuc970.h"
N#include "sys.h"
N
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_RTC_Driver RTC Driver
N  @{
N*/
N
N/** @addtogroup NUC970_RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Error Code                                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define E_RTC_SUCCESS                   0   /*!< success */
N#define E_RTC_ERR_CALENDAR_VALUE        1   /*!< Wrong Calendar Value */
N#define E_RTC_ERR_TIMESACLE_VALUE       2   /*!< Wrong Time Scale Value */
N#define E_RTC_ERR_TIME_VALUE            3   /*!< Wrong Time Value */
N#define E_RTC_ERR_DWR_VALUE             4   /*!< Wrong Day Value */
N#define E_RTC_ERR_FCR_VALUE             5   /*!< Wrong Compenation value */
N#define E_RTC_ERR_EIO                   6   /*!< Initial RTC Failed */
N#define E_RTC_ERR_ENOTTY                7   /*!< Command not support, or parameter incorrect */
N#define E_RTC_ERR_ENODEV                8   /*!< Interface number incorrect */
N
N#define RTC_FCR_REFERENCE       32761   /*!< RTC Reference for frequency compensation */
N
N#define RTC_INIT_KEY        0xa5eb1357   /*!< RTC Access Key   \hideinitializer */
N#define RTC_WRITE_KEY       0xa965       /*!< RTC Access Key  \hideinitializer */
N
N#define RTC_WAIT_COUNT      0xFFFFFFFF  /*!< Initial Time Out Value  \hideinitializer */
N
N#define RTC_YEAR2000            2000   /*!< RTC Reference \hideinitializer */
N
N#define RTC_LEAP_YEAR       1     /*!< RTC leap year \hideinitializer */
N
N#define RTC_CLOCK_12            0   /*!< RTC 12 Hour  */
N#define RTC_CLOCK_24            1   /*!< RTC 24 Hour  */
N
N#define RTC_AM              1    /*!< RTC AM \hideinitializer */
N#define RTC_PM              2    /*!< RTC PM \hideinitializer */
N
N
N#define RTC_INIT_ACTIVE_Pos              (0)                                               /*!< RTC INIT: ACTIVE Position              */
N#define RTC_INIT_ACTIVE_Msk              (0x1ul << RTC_INIT_ACTIVE_Pos)                    /*!< RTC INIT: ACTIVE Mask                  */
N
N#define RTC_INIT_INIT_Pos                (0)                                               /*!< RTC INIT: INIT Position                */
N#define RTC_INIT_INIT_Msk                (0xfffffffful << RTC_INIT_INIT_Pos)               /*!< RTC INIT: INIT Mask                    */
N
N#define RTC_RWEN_RWENPASSWD_Pos          (0)                                               /*!< RTC RWEN: RWEN Position                */
N#define RTC_RWEN_RWENPASSWD_Msk          (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC RWEN: RWEN Mask                    */
N
N#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC RWEN: RWENF Position               */
N#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC RWEN: RWENF Mask                   */
N
N#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC FREQADJ: FRACTION Position         */
N#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC FREQADJ: FRACTION Mask             */
N
N#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC FREQADJ: INTEGER Position          */
N#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC FREQADJ: INTEGER Mask              */
N
N#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC TIME: SEC Position                 */
N#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC TIME: SEC Mask                     */
N
N#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC TIME: TENSEC Position              */
N#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC TIME: TENSEC Mask                  */
N
N#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC TIME: MIN Position                 */
N#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC TIME: MIN Mask                     */
N
N#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC TIME: TENMIN Position              */
N#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC TIME: TENMIN Mask                  */
N
N#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC TIME: HR Position                  */
N#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC TIME: HR Mask                      */
N
N#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC TIME: TENHR Position               */
N#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC TIME: TENHR Mask                   */
N
N#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC CAL: DAY Position                  */
N#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC CAL: DAY Mask                      */
N
N#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC CAL: TENDAY Position               */
N#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC CAL: TENDAY Mask                   */
N
N#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC CAL: MON Position                  */
N#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC CAL: MON Mask                      */
N
N#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC CAL: TENMON Position               */
N#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC CAL: TENMON Mask                   */
N
N#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC CAL: YEAR Position                 */
N#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC CAL: YEAR Mask                     */
N
N#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC CAL: TENYEAR Position              */
N#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC CAL: TENYEAR Mask                  */
N
N#define RTC_TIMEFMT_24HEN_Pos             (0)                                               /*!< RTC CLKFMT: 24HEN Position             */
N#define RTC_TIMEFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC CLKFMT: 24HEN Mask                 */
N
N#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC WEEKDAY: WEEKDAY Position          */
N#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC WEEKDAY: WEEKDAY Mask              */
N
N#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC TALM: SEC Position                 */
N#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC TALM: SEC Mask                     */
N
N#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC TALM: TENSEC Position              */
N#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC TALM: TENSEC Mask                  */
N
N#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC TALM: MIN Position                 */
N#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC TALM: MIN Mask                     */
N
N#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC TALM: TENMIN Position              */
N#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC TALM: TENMIN Mask                  */
N
N#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC TALM: HR Position                  */
N#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC TALM: HR Mask                      */
N
N#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC TALM: TENHR Position               */
N#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC TALM: TENHR Mask                   */
N
N#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC CALM: DAY Position                 */
N#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC CALM: DAY Mask                     */
N
N#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC CALM: TENDAY Position              */
N#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC CALM: TENDAY Mask                  */
N
N#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC CALM: MON Position                 */
N#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC CALM: MON Mask                     */
N
N#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC CALM: TENMON Position              */
N#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC CALM: TENMON Mask                  */
N
N#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC CALM: YEAR Position                */
N#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC CALM: YEAR Mask                    */
N
N#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC CALM: TENYEAR Position             */
N#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC CALM: TENYEAR Mask                 */
N
N#define RTC_CALM_WEEKDAY_Pos             (24)                                              /*!< RTC CALM: WEEKDAY Position             */
N#define RTC_CALM_WEEKDAY_Msk             (0x7ul << RTC_CALM_WEEKDAY_Pos)                   /*!< RTC CALM: WEEKDAY Mask                 */
N
N#define RTC_CALM_DAYALM_MSK_Pos          (28)                                              /*!< RTC CALM: DAYALM_MSK Position             */
N#define RTC_CALM_DAYALM_MSK_Msk          (0x1ul << RTC_CALM_DAYALM_MSK_Pos)                /*!< RTC CALM: DAYALM_MSK Mask                 */
N
N#define RTC_CALM_MONALM_MSK_Pos          (29)                                              /*!< RTC CALM: MONALM_MSK Position             */
N#define RTC_CALM_MONALM_MSK_Msk          (0x1ul << RTC_CALM_MONALM_MSK_Pos)                /*!< RTC CALM: MONALM_MSK Mask                 */
N
N#define RTC_CALM_YRALM_MSK_Pos           (30)                                              /*!< RTC CALM: YRALM_MSK Position             */
N#define RTC_CALM_YRALM_MSK_Msk           (0x1ul << RTC_CALM_YRALM_MSK_Pos)                 /*!< RTC CALM: YRALM_MSK Mask                 */
N
N#define RTC_CALM_WKDALM_MSK_Pos          (31)                                              /*!< RTC CALM: WKDALM_MSK Position             */
N#define RTC_CALM_WKDALM_MSK_Msk          (0x1ul << RTC_CALM_WKDALM_MSK_Pos)                /*!< RTC CALM: WKDALM_MSK Mask                 */
N
N
N#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC LEAPYEAR: LEAPYEAR Position        */
N#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC LEAPYEAR: LEAPYEAR Mask            */
N
N#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC INTEN: ALMIEN Position             */
N#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC INTEN: ALMIEN Mask                 */
N
N#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC INTEN: TICKIEN Position            */
N#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC INTEN: TICKIEN Mask                */
N
N#define RTC_INTEN_WAKEUPIEN_Pos          (2)                                               /*!< RTC INTEN: WAKEUPIEN Position            */
N#define RTC_INTEN_WAKEUPIEN_Msk          (0x1ul << RTC_INTEN_WAKEUPIEN_Pos)                /*!< RTC INTEN: WAKEUPIEN Mask                */
N
N#define RTC_INTEN_PWRSWIEN_Pos           (3)                                               /*!< RTC INTEN: PWRSWIEN Position            */
N#define RTC_INTEN_PWRSWIEN_Msk           (0x1ul << RTC_INTEN_PWRSWIEN_Pos)                 /*!< RTC INTEN: PWRSWIEN Mask                */
N
N#define RTC_INTEN_RELALMIEN_Pos          (4)                                               /*!< RTC INTEN: RELALMIEN Position            */
N#define RTC_INTEN_RELALMIEN_Msk          (0x1ul << RTC_INTEN_RELALMIEN_Pos)                /*!< RTC INTEN: RELALMIEN Mask                */
N
N#define RTC_INTEN_KEYPRESIEN_Pos         (5)                                               /*!< RTC INTEN: KEYPRESIEN Position            */
N#define RTC_INTEN_KEYPRESIEN_Msk         (0x1ul << RTC_INTEN_KEYPRESIEN_Pos)               /*!< RTC INTEN: KEYPRESIEN Mask                */
N
N
N#define RTC_INTSTS_ALMINT_Pos             (0)                                              /*!< RTC INTSTS: ALMINT Position             */
N#define RTC_INTSTS_ALMINT_Msk             (0x1ul << RTC_INTSTS_ALMINT_Pos)                 /*!< RTC INTSTS: ALMINT Mask                 */
N
N#define RTC_INTSTS_TICKINT_Pos            (1)                                              /*!< RTC INTSTS: TICKINT Position            */
N#define RTC_INTSTS_TICKINT_Msk            (0x1ul << RTC_INTSTS_TICKINT_Pos)                /*!< RTC INTSTS: TICKINT Mask                */
N
N#define RTC_INTSTS_WAKEUPINT_Pos          (2)                                              /*!< RTC INTSTS: WAKEUPINT Position            */
N#define RTC_INTSTS_WAKEUPINT_Msk          (0x1ul << RTC_INTSTS_WAKEUPINT_Pos)              /*!< RTC INTSTS: WAKEUPINT Mask                */
N
N#define RTC_INTSTS_PWRSWINT_Pos           (3)                                              /*!< RTC INTSTS: PWRSWINT Position            */
N#define RTC_INTSTS_PWRSWINT_Msk           (0x1ul << RTC_INTSTS_PWRSWINT_Pos)               /*!< RTC INTSTS: PWRSWINT Mask                */
N
N#define RTC_INTSTS_RELALMINT_Pos          (4)                                              /*!< RTC INTSTS: RELALMINT Position            */
N#define RTC_INTSTS_RELALMINT_Msk          (0x1ul << RTC_INTSTS_RELALMINT_Pos)              /*!< RTC INTSTS: RELALMINT Mask                */
N
N#define RTC_INTSTS_KEYPRESINT_Pos         (5)                                              /*!< RTC INTSTS: KEYPRESINT Position            */
N#define RTC_INTSTS_KEYPRESINT_Msk         (0x1ul << RTC_INTSTS_KEYPRESINT_Pos)             /*!< RTC INTSTS: KEYPRESINT Mask                */
N
N#define RTC_INTSTS_REGWRBUSY_Pos          (31)                                             /*!< RTC INTSTS: REGWRBUSY Position            */
N#define RTC_INTSTS_REGWRBUSY_Msk          (0x1ul << RTC_INTSTS_REGWRBUSY_Pos)              /*!< RTC INTSTS: REGWRBUSY Mask                */
N
N
N#define RTC_TICK_TTR_Pos                  (0)                                              /*!< RTC TICK: TTR Position                */
N#define RTC_TICK_TTR_Msk                  (0x7ul << RTC_TICK_TTR_Pos)                      /*!< RTC TICK: TTR Mask                    */
N
N#define RTC_PWRCTL_PWR_ON_Pos             (0)                                              /*!< RTC PWRCTL: PWR_ON Position               */
N#define RTC_PWRCTL_PWR_ON_Msk             (0x1ul << RTC_PWRCTL_PWR_ON_Pos)                 /*!< RTC PWRCTL: PWR_ON Mask                   */
N
N#define RTC_PWRCTL_SW_PCLR_Pos            (1)                                              /*!< RTC PWRCTL: SW_PCLR Position               */
N#define RTC_PWRCTL_SW_PCLR_Msk            (0x1ul << RTC_PWRCTL_SW_PCLR_Pos)                /*!< RTC PWRCTL: SW_PCLR Mask                   */
N
N#define RTC_PWRCTL_HW_PCLR_EN_Pos         (2)                                              /*!< RTC PWRCTL: HW_PCLR_EN Position               */
N#define RTC_PWRCTL_HW_PCLR_EN_Msk         (0x1ul << RTC_PWRCTL_HW_PCLR_EN_Pos)             /*!< RTC PWRCTL: HW_PCLR_EN Mask                   */
N
N#define RTC_PWRCTL_ALARM_EN_Pos           (3)                                              /*!< RTC PWRCTL: ALARM_EN Position               */
N#define RTC_PWRCTL_ALARM_EN_Msk           (0x1ul << RTC_PWRCTL_ALARM_EN_Pos)               /*!< RTC PWRCTL: ALARM_EN Mask                   */
N
N#define RTC_PWRCTL_REL_ALARM_EN_Pos       (4)                                              /*!< RTC PWRCTL: REL_ALARM_EN Position               */
N#define RTC_PWRCTL_REL_ALARM_EN_Msk       (0x1ul << RTC_PWRCTL_REL_ALARM_EN_Pos)           /*!< RTC PWRCTL: REL_ALARM_EN Mask                   */
N
N#define RTC_PWRCTL_EDGE_TRIG_Pos          (5)                                              /*!< RTC PWRCTL: EDGE_TRIG Position               */
N#define RTC_PWRCTL_EDGE_TRIG_Msk          (0x1ul << RTC_PWRCTL_EDGE_TRIG_Pos)              /*!< RTC PWRCTL: EDGE_TRIG Mask                   */
N
N#define RTC_PWRCTL_TIMEUNITL_Pos          (6)                                              /*!< RTC PWRCTL: TIMEUNITL Position               */
N#define RTC_PWRCTL_TIMEUNITL_Msk          (0x1ul << RTC_PWRCTL_TIMEUNITLPos)               /*!< RTC PWRCTL: TIMEUNITL Mask                   */
N
N#define RTC_PWRCTL_PWR_KEY_Pos            (7)                                              /*!< RTC PWRCTL: PWR_KEY Position               */
N#define RTC_PWRCTL_PWR_KEY_Msk            (0x1ul << RTC_PWRCTL_PWR_KEY_Pos)                /*!< RTC PWRCTL: PWR_KEY Mask                   */
N
N#define RTC_PWRCTL_PWRON_TIME_Pos         (8)                                              /*!< RTC PWRCTL: PWRON_TIME Position               */
N#define RTC_PWRCTL_PWRON_TIME_Msk         (0xful << RTC_PWRCTL_PWRON_TIME_Pos)             /*!< RTC PWRCTL: PWRON_TIME Mask                   */
N
N#define RTC_PWRCTL_PWROFF_TIME_Pos        (12)                                             /*!< RTC PWRCTL: PWROFF_TIME Position               */
N#define RTC_PWRCTL_PWROFF_TIME_Msk        (0xful << RTC_PWRCTL_PWROFF_TIME_Pos)            /*!< RTC PWRCTL: PWROFF_TIME Mask                   */
N
N#define RTC_PWRCTL_RELALM_TIME_Pos        (16)                                             /*!< RTC PWRCTL: RELALM_TIME Position               */
N#define RTC_PWRCTL_RELALM_TIME_Msk        (0xffful << RTC_PWRCTL_RELALM_TIME_Pos)          /*!< RTC PWRCTL: RELALM_TIME Mask                   */
N
N#define RTC_PWRCTL_ALARM_MODE_Pos         (28)                                             /*!< RTC PWRCTL: ALARM_MODE Position               */
N#define RTC_PWRCTL_ALARM_MODE_Msk         (0x1ul << RTC_PWRCTL_ALARM_MODE_Pos)             /*!< RTC PWRCTL: ALARM_MODE Mask                   */
N
N
N#define RTC_SPRCTL_SNPDEN_Pos            (0)                                               /*!< RTC SPRCTL: SNPDEN Position            */
N#define RTC_SPRCTL_SNPDEN_Msk            (0x1ul << RTC_SPRCTL_SNPDEN_Pos)                  /*!< RTC SPRCTL: SNPDEN Mask                */
N
N#define RTC_SPRCTL_SNPTYPE0_Pos          (1)                                               /*!< RTC SPRCTL: SNPTYPE0 Position          */
N#define RTC_SPRCTL_SNPTYPE0_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE0_Pos)                /*!< RTC SPRCTL: SNPTYPE0 Mask              */
N
N#define RTC_SPRCTL_SPRRWEN_Pos           (2)                                               /*!< RTC SPRCTL: SPRRWEN Position           */
N#define RTC_SPRCTL_SPRRWEN_Msk           (0x1ul << RTC_SPRCTL_SPRRWEN_Pos)                 /*!< RTC SPRCTL: SPRRWEN Mask               */
N
N#define RTC_SPRCTL_SNPTYPE1_Pos          (3)                                               /*!< RTC SPRCTL: SNPTYPE1 Position          */
N#define RTC_SPRCTL_SNPTYPE1_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE1_Pos)                /*!< RTC SPRCTL: SNPTYPE1 Mask              */
N
N#define RTC_SPRCTL_SPRCSTS_Pos           (5)                                               /*!< RTC SPRCTL: SPRCSTS Position           */
N#define RTC_SPRCTL_SPRCSTS_Msk           (0x1ul << RTC_SPRCTL_SPRCSTS_Pos)                 /*!< RTC SPRCTL: SPRCSTS Mask               */
N
N#define RTC_SPRCTL_SPRRWRDY_Pos          (7)                                               /*!< RTC SPRCTL: SPRRWRDY Position          */
N#define RTC_SPRCTL_SPRRWRDY_Msk          (0x1ul << RTC_SPRCTL_SPRRWRDY_Pos)                /*!< RTC SPRCTL: SPRRWRDY Mask              */
N
N#define RTC_SPR0_SPARE_Pos               (0)                                               /*!< RTC SPR0: SPARE Position               */
N#define RTC_SPR0_SPARE_Msk               (0xfffffffful << RTC_SPR0_SPARE_Pos)              /*!< RTC SPR0: SPARE Mask                   */
N
N#define RTC_SPR1_SPARE_Pos               (0)                                               /*!< RTC SPR1: SPARE Position               */
N#define RTC_SPR1_SPARE_Msk               (0xfffffffful << RTC_SPR1_SPARE_Pos)              /*!< RTC SPR1: SPARE Mask                   */
N
N#define RTC_SPR2_SPARE_Pos               (0)                                               /*!< RTC SPR2: SPARE Position               */
N#define RTC_SPR2_SPARE_Msk               (0xfffffffful << RTC_SPR2_SPARE_Pos)              /*!< RTC SPR2: SPARE Mask                   */
N
N#define RTC_SPR3_SPARE_Pos               (0)                                               /*!< RTC SPR3: SPARE Position               */
N#define RTC_SPR3_SPARE_Msk               (0xfffffffful << RTC_SPR3_SPARE_Pos)              /*!< RTC SPR3: SPARE Mask                   */
N
N#define RTC_SPR4_SPARE_Pos               (0)                                               /*!< RTC SPR4: SPARE Position               */
N#define RTC_SPR4_SPARE_Msk               (0xfffffffful << RTC_SPR4_SPARE_Pos)              /*!< RTC SPR4: SPARE Mask                   */
N
N#define RTC_SPR5_SPARE_Pos               (0)                                               /*!< RTC SPR5: SPARE Position               */
N#define RTC_SPR5_SPARE_Msk               (0xfffffffful << RTC_SPR5_SPARE_Pos)              /*!< RTC SPR5: SPARE Mask                   */
N
N#define RTC_SPR6_SPARE_Pos               (0)                                               /*!< RTC SPR6: SPARE Position               */
N#define RTC_SPR6_SPARE_Msk               (0xfffffffful << RTC_SPR6_SPARE_Pos)              /*!< RTC SPR6: SPARE Mask                   */
N
N#define RTC_SPR7_SPARE_Pos               (0)                                               /*!< RTC SPR7: SPARE Position               */
N#define RTC_SPR7_SPARE_Msk               (0xfffffffful << RTC_SPR7_SPARE_Pos)              /*!< RTC SPR7: SPARE Mask                   */
N
N#define RTC_SPR8_SPARE_Pos               (0)                                               /*!< RTC SPR8: SPARE Position               */
N#define RTC_SPR8_SPARE_Msk               (0xfffffffful << RTC_SPR8_SPARE_Pos)              /*!< RTC SPR8: SPARE Mask                   */
N
N#define RTC_SPR9_SPARE_Pos               (0)                                               /*!< RTC SPR9: SPARE Position               */
N#define RTC_SPR9_SPARE_Msk               (0xfffffffful << RTC_SPR9_SPARE_Pos)              /*!< RTC SPR9: SPARE Mask                   */
N
N#define RTC_SPR10_SPARE_Pos              (0)                                               /*!< RTC SPR10: SPARE Position              */
N#define RTC_SPR10_SPARE_Msk              (0xfffffffful << RTC_SPR10_SPARE_Pos)             /*!< RTC SPR10: SPARE Mask                  */
N
N#define RTC_SPR11_SPARE_Pos              (0)                                               /*!< RTC SPR11: SPARE Position              */
N#define RTC_SPR11_SPARE_Msk              (0xfffffffful << RTC_SPR11_SPARE_Pos)             /*!< RTC SPR11: SPARE Mask                  */
N
N#define RTC_SPR12_SPARE_Pos              (0)                                               /*!< RTC SPR12: SPARE Position              */
N#define RTC_SPR12_SPARE_Msk              (0xfffffffful << RTC_SPR12_SPARE_Pos)             /*!< RTC SPR12: SPARE Mask                  */
N
N#define RTC_SPR13_SPARE_Pos              (0)                                               /*!< RTC SPR13: SPARE Position              */
N#define RTC_SPR13_SPARE_Msk              (0xfffffffful << RTC_SPR13_SPARE_Pos)             /*!< RTC SPR13: SPARE Mask                  */
N
N#define RTC_SPR14_SPARE_Pos              (0)                                               /*!< RTC SPR14: SPARE Position              */
N#define RTC_SPR14_SPARE_Msk              (0xfffffffful << RTC_SPR14_SPARE_Pos)             /*!< RTC SPR14: SPARE Mask                  */
N
N#define RTC_SPR15_SPARE_Pos              (0)                                               /*!< RTC SPR15: SPARE Position              */
N#define RTC_SPR15_SPARE_Msk              (0xfffffffful << RTC_SPR15_SPARE_Pos)             /*!< RTC SPR15: SPARE Mask                  */
N
N#define RTC_SPR16_SPARE_Pos              (0)                                               /*!< RTC SPR16: SPARE Position              */
N#define RTC_SPR16_SPARE_Msk              (0xfffffffful << RTC_SPR16_SPARE_Pos)             /*!< RTC SPR16: SPARE Mask                  */
N
N#define RTC_SPR17_SPARE_Pos              (0)                                               /*!< RTC SPR17: SPARE Position              */
N#define RTC_SPR17_SPARE_Msk              (0xfffffffful << RTC_SPR17_SPARE_Pos)             /*!< RTC SPR17: SPARE Mask                  */
N
N#define RTC_SPR18_SPARE_Pos              (0)                                               /*!< RTC SPR18: SPARE Position              */
N#define RTC_SPR18_SPARE_Msk              (0xfffffffful << RTC_SPR18_SPARE_Pos)             /*!< RTC SPR18: SPARE Mask                  */
N
N#define RTC_SPR19_SPARE_Pos              (0)                                               /*!< RTC SPR19: SPARE Position              */
N#define RTC_SPR19_SPARE_Msk              (0xfffffffful << RTC_SPR19_SPARE_Pos)             /*!< RTC SPR19: SPARE Mask                  */
N
N/**
N  * @brief  RTC define interrupt source
N  */
Ntypedef enum {
N    RTC_ALARM_INT           =0x01,  /*!< Alarm interrupt */
N    RTC_TICK_INT            =0x02,  /*!< Tick interrupt */
N    RTC_WAKEUP_INT          =0x04,  /*!< Wake-up interrupt */
N    RTC_PSWI_INT            =0x08,  /*!< Power switch interrupt */
N    RTC_RELATIVE_ALARM_INT  =0x10,  /*!< Releative Alarm interrupt */
N    RTC_KEY_PRESS_INT       =0x20,  /*!< Power Key press interrupt */
N    RTC_ALL_INT             =0x3F   /*!< All interrupt */
N} RTC_INT_SOURCE;
N
N/**
N  * @brief  Define Ioctl commands
N  */
Ntypedef enum {
N    RTC_IOC_IDENTIFY_LEAP_YEAR      =  0,    /*!< Identify leap year */
N    RTC_IOC_SET_TICK_MODE           =  1,    /*!< Set tick mode */
N    RTC_IOC_GET_TICK                =  2,    /*!< Get tick count */
N    RTC_IOC_RESTORE_TICK            =  3,    /*!< Reset tick count */
N    RTC_IOC_ENABLE_INT              =  4,    /*!< Enable RTC interrupt */
N    RTC_IOC_DISABLE_INT             =  5,    /*!< Disable RTC interrupt */
N    RTC_IOC_SET_CURRENT_TIME        =  6,    /*!< Set current time */
N    RTC_IOC_SET_ALAMRM_TIME         =  7,    /*!< set alarm time */
N    RTC_IOC_SET_FREQUENCY           =  8,    /*!< Set frequency compensation value */
N    RTC_IOC_SET_POWER_ON            =  9,    /*!< Set Power on */
N    RTC_IOC_SET_POWER_OFF           =  10,    /*!< Set Power off*/
N    RTC_IOC_SET_POWER_OFF_PERIOD    =  11,    /*!< Set Power off period */
N    RTC_IOC_ENABLE_HW_POWEROFF      =  12,    /*!< Enable H/W Power off */
N    RTC_IOC_DISABLE_HW_POWEROFF     =  13,    /*!< Disable H/W Power off */
N    RTC_IOC_GET_POWERKEY_STATUS     =  14,    /*!< Get Power key status */
N    RTC_IOC_SET_PSWI_CALLBACK       =  15,    /*!< Set Power switch isr call back function */
N    //RTC_IOC_GET_SW_STATUS         =  16,
N    //RTC_IOC_SET_SW_STATUS         =  17,
N    RTC_IOC_SET_RELEATIVE_ALARM     =  18,    /*!< Set releative alarm */
N    //RTC_IOC_SET_POWER_KEY_DELAY   =  19,
N    //RTC_IOC_SET_CLOCK_SOURCE      =  20,
N    //RTC_IOC_GET_CLOCK_SOURCE      =  21
N} E_RTC_CMD;
N
N/**
N  * @brief  RTC define Tick mode
N  */
Ntypedef enum {
N    RTC_TICK_1_SEC       =         0,      /*!< Time tick is 1 second     */
N    RTC_TICK_1_2_SEC     =         1,      /*!< Time tick is 1/2 second   */
N    RTC_TICK_1_4_SEC     =         2,      /*!< Time tick is 1/4 second   */
N    RTC_TICK_1_8_SEC     =         3,      /*!< Time tick is 1/8 second   */
N    RTC_TICK_1_16_SEC    =         4,      /*!< Time tick is 1/16 second  */
N    RTC_TICK_1_32_SEC    =         5,      /*!< Time tick is 1/32 second  */
N    RTC_TICK_1_64_SEC    =         6,      /*!< Time tick is 1/64 second  */
N    RTC_TICK_1_128_SEC   =         7       /*!< Time tick is 1/128 second */
N} RTC_TICK;
N
Ntypedef void (PFN_RTC_CALLBACK)(void);  /*!< Call back function \hideinitializer */
N
N/**
N  * @brief  RTC current/alarm time select
N  */
Ntypedef enum {
N    RTC_CURRENT_TIME    =    0,   /*!< Select current time */
N    RTC_ALARM_TIME      =    1    /*!< Select alarm time */
N} E_RTC_TIME_SELECT;
N
N/**
N  * @brief  RTC define Day of week parameter
N  */
Ntypedef enum {
N    RTC_SUNDAY         =   0,   /*!< Sunday    */
N    RTC_MONDAY         =   1,   /*!< Monday    */
N    RTC_TUESDAY        =   2,   /*!< Tuesday   */
N    RTC_WEDNESDAY      =   3,   /*!< Wednesday */
N    RTC_THURSDAY       =   4,   /*!< Thursday  */
N    RTC_FRIDAY         =   5,   /*!< Friday    */
N    RTC_SATURDAY       =   6    /*!< Saturday  */
N} E_RTC_DWR_PARAMETER;
N
N/**
N  * @brief  RTC define Time Data Struct
N  */
Ntypedef struct {
N    UINT8 u8cClockDisplay;            /*!<  12-Hour, 24-Hour */
N    UINT8 u8cAmPm;                    /*!<  Time Scale select 12-hr/24-hr */
N    UINT32 u32cSecond;                /*!<  Second value */
N    UINT32 u32cMinute;                /*!<  Minute value */
N    UINT32 u32cHour;                  /*!<  Hour value */
N    UINT32 u32cDayOfWeek;             /*!<  Day of week value */
N    UINT32 u32cDay;                   /*!<  Day value */
N    UINT32 u32cMonth;                 /*!<  Month value */
N    UINT32 u32Year;                   /*!<  Year value */
N    UINT32 u32AlarmMaskSecond;        /*!<  Alarm mask second */
N    UINT32 u32AlarmMaskMinute;        /*!<  Alarm mask minute */
N    UINT32 u32AlarmMaskHour;          /*!<  Alarm mask hour */
N    PFN_RTC_CALLBACK *pfnAlarmCallBack;    /*!< Alarm ISR call back funstion */
N} RTC_TIME_DATA_T;
N
N/**
N  * @brief  RTC define Tick Struct
N  */
Ntypedef struct {
N    UINT8 ucMode;                           /*!< Tick Mode  */
N    PFN_RTC_CALLBACK *pfnTickCallBack;      /*!< Tick ISR call back function  */
N} RTC_TICK_T;
N
N/*@}*/ /* end of group NUC970_RTC_EXPORTED_CONSTANTS */
N
N/** @addtogroup NUC970_RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
NUINT32 RTC_Init(void);
NUINT32 RTC_Open(RTC_TIME_DATA_T *sPt);
NUINT32 RTC_Ioctl(INT32 i32Num, E_RTC_CMD eCmd, UINT32 u32Arg0, UINT32 u32Arg1);
NUINT32 RTC_Read(E_RTC_TIME_SELECT eTime, RTC_TIME_DATA_T *sPt);
NUINT32 RTC_Write(E_RTC_TIME_SELECT eTime, RTC_TIME_DATA_T *sPt);
NUINT32 RTC_DoFrequencyCompensation(INT32 i32FrequencyX100);
NUINT32 RTC_WriteEnable (BOOL bEnable);
NUINT32 RTC_Close(void);
Nvoid RTC_EnableClock(BOOL bEnable);
N
N/*@}*/ /* end of group NUC970_RTC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_RTC_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#ifdef  __cplusplus
S}
N#endif
N
N#endif /* __DRVRTC_H__ */
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
N
N
L 23 ".\src\syshal\halinterface.h" 2
N#include "fileagent.h"
L 1 ".\src\syshal\fileagent.h" 1
N/**************************************************************************//**
N* @file     fileagent.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __FILE_AGENT_H__
N#define __FILE_AGENT_H__
N
N#include "nuc970.h"
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N
N#include "fepconfig.h"
N#include "ff.h"
L 1 "..\..\common\src\BSP\ThirdParty\FATFS\src\ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include R0.11     (C)ChaN, 2015
N/----------------------------------------------------------------------------/
N/ FatFs module is a free software that opened under license policy of
N/ following conditions.
N/
N/ Copyright (C) 2015, ChaN, all right reserved.
N/
N/ 1. Redistributions of source code must retain the above copyright notice,
N/    this condition and the following disclaimer.
N/
N/ This software is provided by the copyright holder and contributors "AS IS"
N/ and any warranties related to this software are DISCLAIMED.
N/ The copyright owner or contributors be NOT LIABLE for any damages caused
N/ by use of this software.
N/---------------------------------------------------------------------------*/
N
N
N#ifndef _FATFS
N#define _FATFS	32020	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\..\common\src\BSP\ThirdParty\FATFS\src\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
S
N#else			/* Embedded platform */
N
N/* This type MUST be 8 bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16 bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 16 bit or 32 bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* These types MUST be 32 bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N#endif
N
N#endif
L 27 "..\..\common\src\BSP\ThirdParty\FATFS\src\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\..\common\src\BSP\ThirdParty\FATFS\src\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.11 (C)ChaN, 2015
N/---------------------------------------------------------------------------*/
N
N#define _FFCONF 32020	/* Revision ID */
N
N/*---------------------------------------------------------------------------/
N/ Functions and Buffer Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY		0
N/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
N/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS
N/  bytes. Instead of private sector buffer eliminated from the file object,
N/  common sector buffer in the file system object (FATFS) is used for the file
N/  data transfer. */
N
N
N#define _FS_READONLY	0
N/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
N/  Read-only configuration removes writing API functions, f_write(), f_sync(),
N/  f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(), f_getfree()
N/  and optional writing functions as well. */
N
N
N#define _FS_MINIMIZE	0
N/* This option defines minimization level to remove some basic API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_chmod(), f_utime(),
N/      f_truncate() and f_rename() function are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	1
N/* This option switches string functions, f_gets(), f_putc(), f_puts() and
N/  f_printf().
N/
N/  0: Disable string functions.
N/  1: Enable without LF-CRLF conversion.
N/  2: Enable with LF-CRLF conversion. */
N
N
N#define _USE_FIND		1
N/* This option switches filtered directory read feature and related functions,
N/  f_findfirst() and f_findnext(). (0:Disable or 1:Enable) */
N
N
N#define	_USE_MKFS		1
N/* This option switches f_mkfs() function. (0:Disable or 1:Enable) */
N
N
N#define	_USE_FASTSEEK	0
N/* This option switches fast seek feature. (0:Disable or 1:Enable) */
N
N
N#define _USE_LABEL		0
N/* This option switches volume label functions, f_getlabel() and f_setlabel().
N/  (0:Disable or 1:Enable) */
N
N
N#define	_USE_FORWARD	0
N/* This option switches f_forward() function. (0:Disable or 1:Enable)
N/  To enable it, also _FS_TINY need to be set to 1. */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	1252//932
N/* This option specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   1    - ASCII (No extended character. Non-LFN cfg. only)
N/   437  - U.S.
N/   720  - Arabic
N/   737  - Greek
N/   775  - Baltic
N/   850  - Multilingual Latin 1
N/   852  - Latin 2
N/   855  - Cyrillic
N/   857  - Turkish
N/   858  - Multilingual Latin 1 + Euro
N/   862  - Hebrew
N/   866  - Russian
N/   874  - Thai
N/   932  - Japanese Shift_JIS (DBCS)
N/   936  - Simplified Chinese GBK (DBCS)
N/   949  - Korean (DBCS)
N/   950  - Traditional Chinese Big5 (DBCS)
N*/
N
N
N#define	_USE_LFN	2//3//0
N#define	_MAX_LFN	255
N/* The _USE_LFN option switches the LFN feature.
N/
N/   0: Disable LFN feature. _MAX_LFN has no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  When enable the LFN feature, Unicode handling functions (option/unicode.c) must
N/  be added to the project. The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes.
N/  When use stack for the working buffer, take care on stack overflow. When use heap
N/  memory for the working buffer, memory management functions, ff_memalloc() and
N/  ff_memfree(), must be added to the project. */
N
N
N#define	_LFN_UNICODE	0
N/* This option switches character encoding on the API. (0:ANSI/OEM or 1:Unicode)
N/  To use Unicode string for the path name, enable LFN feature and set _LFN_UNICODE
N/  to 1. This option also affects behavior of string I/O functions. */
N
N
N#define _STRF_ENCODE	3
N/* When _LFN_UNICODE is 1, this option selects the character encoding on the file to
N/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
N/
N/  0: ANSI/OEM
N/  1: UTF-16LE
N/  2: UTF-16BE
N/  3: UTF-8
N/
N/  When _LFN_UNICODE is 0, this option has no effect. */
N
N
N#define _FS_RPATH	1
N/* This option configures relative path feature.
N/
N/   0: Disable relative path feature and remove related functions.
N/   1: Enable relative path feature. f_chdir() and f_chdrive() are available.
N/   2: f_getcwd() function is available in addition to 1.
N/
N/  Note that directory items read via f_readdir() are affected by this option. */
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	3//9
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0
N#define _VOLUME_STRS	"SD0","SFlash0","SFlash1"//"RAM","NAND","CF","SD1","SD2","USB1","USB2","USB3"
N/* _STR_VOLUME_ID option switches string volume ID feature.
N/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
N/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
N/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
N/  the drive ID strings are: A-Z and 0-9. */
N
N
N#define	_MULTI_PARTITION	0
N/* This option switches multi-partition feature. By default (0), each logical drive
N/  number is bound to the same physical drive number and only an FAT volume found on
N/  the physical drive will be mounted. When multi-partition feature is enabled (1),
N/  each logical drive number is bound to arbitrary physical drive and partition
N/  listed in the VolToPart[]. Also f_fdisk() funciton will be available. */
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		4096
N/* These options configure the range of sector size to be supported. (512, 1024,
N/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
N/  harddisk. But a larger value may be required for on-board flash memory and some
N/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
N/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
N/  disk_ioctl() function. */
N
N
N#define	_USE_TRIM	0
N/* This option switches ATA-TRIM feature. (0:Disable or 1:Enable)
N/  To enable Trim feature, also CTRL_TRIM command should be implemented to the
N/  disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option, and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define _FS_NORTC	0
N#define _NORTC_MON	2
N#define _NORTC_MDAY	1
N#define _NORTC_YEAR	2015
N/* The _FS_NORTC option switches timestamp feature. If the system does not have
N/  an RTC function or valid timestamp is not needed, set _FS_NORTC to 1 to disable
N/  the timestamp feature. All objects modified by FatFs will have a fixed timestamp
N/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR.
N/  When timestamp feature is enabled (_FS_NORTC	== 0), get_fattime() function need
N/  to be added to the project to read current time form RTC. _NORTC_MON,
N/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
N/  These options have no effect at read-only configuration (_FS_READONLY == 1). */
N
N
N#define	_FS_LOCK	0
N/* The _FS_LOCK option switches file lock feature to control duplicated file open
N/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
N/  is 1.
N/
N/  0:  Disable file lock feature. To avoid volume corruption, application program
N/      should avoid illegal open, remove and rename to the open objects.
N/  >0: Enable file lock feature. The value defines how many files/sub-directories
N/      can be opened simultaneously under file lock control. Note that the file
N/      lock feature is independent of re-entrancy. */
N
N
N#define _FS_REENTRANT	1//0
N#define _FS_TIMEOUT		portMAX_DELAY//1000
N//#define _FS_TIMEOUT		1000
N#define	_SYNC_t			SemaphoreHandle_t//HANDLE
N/* The _FS_REENTRANT option switches the re-entrancy (thread safe) of the FatFs
N/  module itself. Note that regardless of this option, file access to different
N/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
N/  and f_fdisk() function, are always not re-entrant. Only file/directory access
N/  to the same volume is under control of this feature.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function, must be added to the project. Samples are available in
N/      option/syscall.c.
N/
N/  The _FS_TIMEOUT defines timeout period in unit of time tick.
N/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
N/  SemaphoreHandle_t and etc.. A header file for O/S definitions needs to be
N/  included somewhere in the scope of ff.c. */
N
N
N#define _WORD_ACCESS	0
N/* The _WORD_ACCESS option is an only platform dependent option. It defines
N/  which access method is used to the word data on the FAT volume.
N/
N/   0: Byte-by-byte access. Always compatible with all platforms.
N/   1: Word access. Do not choose this unless under both the following conditions.
N/
N/  * Address misaligned memory access is always allowed to ALL instructions.
N/  * Byte order on the memory is little-endian.
N/
N/  If it is the case, _WORD_ACCESS can also be set to 1 to reduce code size.
N/  Following table shows allowable settings of some processor types.
N/
N/  ARM7TDMI   0   *2          ColdFire   0    *1         V850E      0    *2
N/  Cortex-M3  0   *3          Z80        0/1             V850ES     0/1
N/  Cortex-M0  0   *2          x86        0/1             TLCS-870   0/1
N/  AVR        0/1             RX600(LE)  0/1             TLCS-900   0/1
N/  AVR32      0   *1          RL78       0    *2         R32C       0    *2
N/  PIC18      0/1             SH-2       0    *1         M16C       0/1
N/  PIC24      0   *2          H8S        0    *1         MSP430     0    *2
N/  PIC32      0   *1          H8/300H    0    *1         8051       0/1
N/
N/  *1:Big-endian.
N/  *2:Unaligned memory access is not supported.
N/  *3:Some compilers generate LDM/STM for mem_cpy function.
N*/
N
L 28 "..\..\common\src\BSP\ThirdParty\FATFS\src\ff.h" 2
N#if _FATFS != _FFCONF
X#if 32020 != 32020
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode string */
X#if 0			 
S#if !_USE_LFN
S#error _LFN_UNICODE must be 0 at non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
S
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N
N#endif
N#if _FS_REENTRANT
X#if 1
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N#endif
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
N	BYTE	n_fats;			/* Number of FAT copies (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N#if _MAX_SS != _MIN_SS
X#if 4096 != 512
N	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
N#endif
N#if _FS_REENTRANT
X#if 1
N	_SYNC_t	sobj;			/* Identifier of sync object */
X	SemaphoreHandle_t	sobj;			 
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clust;		/* Last allocated cluster */
N	DWORD	free_clust;		/* Number of free clusters */
N#endif
N#if _FS_RPATH
X#if 1
N	DWORD	cdir;			/* Current directory start cluster (0:root) */
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries, = number of clusters + 2 */
N	DWORD	fsize;			/* Sectors per FAT */
N	DWORD	volbase;		/* Volume start sector */
N	DWORD	fatbase;		/* FAT start sector */
N	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
N	DWORD	database;		/* Data start sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[4096];	 
N} FATFS;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the related file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	BYTE	flag;			/* Status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	DWORD	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	fsize;			/* File size */
N	DWORD	sclust;			/* File start cluster (0:no cluster chain, always 0 when fsize is 0) */
N	DWORD	clust;			/* Current cluster of fpter (not valid when fprt is 0) */
N	DWORD	dsect;			/* Sector number appearing in buf[] (0:invalid) */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector number containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */
N#endif
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID origin from 1 (index of file semaphore table Files[]) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File private data read/write window */
X	BYTE	buf[4096];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the owner file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	WORD	index;			/* Current read/write index number */
N	DWORD	sclust;			/* Table start cluster (0:Root dir) */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if _USE_LFN
X#if 2
N	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
N	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N#if _USE_FIND
X#if 1
N	const TCHAR*	pat;	/* Pointer to the name matching pattern */
N#endif
N} DIR;
N
N
N
N/* File information structure (FILINFO) */
N
Ntypedef struct {
N	DWORD	fsize;			/* File size */
N	WORD	fdate;			/* Last modified date */
N	WORD	ftime;			/* Last modified time */
N	BYTE	fattrib;		/* Attribute */
N	TCHAR	fname[13];		/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 2
N	TCHAR*	lfname;			/* Pointer to the LFN buffer */
N	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from a file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to a file */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_lseek (FIL* fp, DWORD ofs);								/* Move file pointer of a file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of a writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);	/* Find first file */
NFRESULT f_findnext (DIR* dp, FILINFO* fno);							/* Find next file */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);			/* Change attribute of the file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change times-tamp of the file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);				/* Create a file system on the volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
N
N#define f_eof(fp) ((int)((fp)->fptr == (fp)->fsize))
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->fsize)
N#define f_rewind(fp) f_lseek((fp), 0)
N#define f_rewinddir(dp) f_readdir((dp), 0)
N
N#ifndef EOF
S#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY && !_FS_NORTC
X#if !0 && !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN							/* Unicode - OEM code conversion */
X#if 2							 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 2 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 1
N
Nint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Xint ff_cre_syncobj (BYTE vol, SemaphoreHandle_t* sobj);	 
Nint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Xint ff_req_grant (SemaphoreHandle_t sobj);				 
Nvoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Xvoid ff_rel_grant (SemaphoreHandle_t sobj);				 
Nint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
Xint ff_del_syncobj (SemaphoreHandle_t sobj);				 
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00
N
N#if !_FS_READONLY
X#if !0
N#define	FA_WRITE			0x02
N#define	FA_CREATE_NEW		0x04
N#define	FA_CREATE_ALWAYS	0x08
N#define	FA_OPEN_ALWAYS		0x10
N#define FA__WRITTEN			0x20
N#define FA__DIRTY			0x40
N#endif
N
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N
N/* Fast seek feature */
N#define CREATE_LINKMAP	0xFFFFFFFF
N
N
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 25 ".\src\syshal\fileagent.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N 
N
Ntypedef enum{
N    FILE_AGENT_ADD_DATA_TYPE_OVERWRITE = 0x00,
N    FILE_AGENT_ADD_DATA_TYPE_APPEND    = 0x01
N}FileAgentAddType;
N
N
Ntypedef enum{
N    FILE_AGENT_STORAGE_TYPE_AUTO = 0x00,
N    FILE_AGENT_STORAGE_TYPE_YAFFS2 = 0x01,
N    FILE_AGENT_STORAGE_TYPE_FATFS = 0x02
N}StorageType;  
N
N#if(0)
Stypedef enum{
S    FILE_AGENT_RETURN_ERROR = 0x00,
S    FILE_AGENT_RETURN_OK_YAFFS2 = 0x01,
S    FILE_AGENT_RETURN_OK_FATFS_0 = 0x02,
S    FILE_AGENT_RETURN_OK_FATFS_1 = 0x04,
S    FILE_AGENT_RETURN_OK_FATFS_2 = 0x08
S}FileAgentReturn;
N#else
N#define FILE_AGENT_RETURN_ERROR         0x00
N#define FILE_AGENT_RETURN_OK_YAFFS2     0x01
N#define FILE_AGENT_RETURN_OK_FATFS_0    0x02
N#define FILE_AGENT_RETURN_OK_FATFS_1    0x04
N#define FILE_AGENT_RETURN_OK_FATFS_2    0x08
Ntypedef int FileAgentReturn;
N#endif
N
N
Ntypedef struct
N{
N    StorageType         storageType; 
N    char                dir[_MAX_LFN]; 
X    char                dir[255]; 
N    char                name[_MAX_LFN];
X    char                name[255];
N    uint8_t*            data;
N    int                 dataLen;
N    BOOL                dataNeedFreeFlag;
N    FileAgentAddType    addType;
N    BOOL                checkMode;
N}FileAgentDataItem;
N
Ntypedef struct
N{
N    char    name[_MAX_LFN];
X    char    name[255];
N    BOOL    existFlag;
N}FileAgentTargetFileName; 
N
Ntypedef BOOL(*fileAgentFatfsListCallback)(char* dir, char* extensionName, int fileLen, void* para1, void* para2, void* para3, void* para4);
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL FileAgentInit(void);
NBOOL FileAgentAddData(StorageType storageType,char* dir, char* name, uint8_t* data, int dataLen, FileAgentAddType addType, BOOL dataNeedFreeFlag, BOOL blockFlag, BOOL checkMode);
NFileAgentReturn FileAgentGetData(StorageType storageType,char* dir, char* name, uint8_t** data, size_t* buffLen, BOOL* needFree, BOOL checkMode);
NBOOL FileAgentParserAutoData(uint8_t* srcData, size_t srcDataLen, uint8_t** targetData, size_t* targetDataLen);
NFileAgentReturn FileAgentDelFile(StorageType storageType,char* dir, char* name);
NBOOL FileAgentGetFatfsList (char* dir, char* extensionName, char* excludeFileName, fileAgentFatfsListCallback callback, void* para1, void* para2, void* para3, void* para4);
NBOOL FileAgentFatfsListFile (char* dir, char* extensionName);
NBOOL FileAgentFatfsDeleteFile (char* dir, char* extensionName);
NBOOL FileAgentGetList(StorageType storageType, char* dir, char* extensionName, char* excludeFileName, fileAgentFatfsListCallback callback, void* para1, void* para2, void* para3, void* para4);
NBOOL FileAgentFatFsFormat(char* dir);
Nint FileAgentGetFatFsAutoFormatCounter(void);
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
NBOOL AppendBurninErrorLog(char *msgBuffer, uint32_t msgLength);
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__DATA_PROCESS_LIB_H__
L 24 ".\src\syshal\halinterface.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N//************************  KEY  ************************//  
Ntypedef BOOL(*keyCallbackFunc)(uint8_t keyId, uint8_t downUp);
N    
Ntypedef BOOL(*keyInitFunc)(void);
Ntypedef void(*keySetCallbackFunc)(keyCallbackFunc func);
Ntypedef void(*keySetPowerFunc)(BOOL powerFlag);
N//************************  TIMER  ************************//    
Ntypedef BOOL(*timerCallbackFunc)(uint8_t timerIndex);  
N
N
Ntypedef BOOL(*timerInitFunc)(void);
Ntypedef BOOL(*timerSetTimeoutFunc)(uint8_t timerIndex, TickType_t time);
Ntypedef BOOL(*timerRunFunc)(uint8_t timerIndex);
Ntypedef void(*timerSetCallbackFunc)(timerCallbackFunc callback);  
N    
N//************************  GUI  ************************//  
Ntypedef BOOL(*guiOnDrawFunc)(uint8_t oriGuiId, uint8_t reFreshPara, int para2, int para3);
Ntypedef BOOL(*guiUpdateDataFunc)(void);
Ntypedef BOOL(*guiKeyCallbackFunc)(uint8_t keyId, uint8_t downUp); 
Ntypedef BOOL(*guiTimerCallbackFunc)(uint8_t timerIndex); 
Ntypedef BOOL(*guiPowerCallbackFunc)(uint8_t type, int flag); 
N    
Ntypedef BOOL(*guiInitFunc)(BOOL testModeFlag);
Ntypedef void(*guiSetKeyCallbackFunc)(guiKeyCallbackFunc callback);  
Ntypedef void(*guiSetTimerCallbackFunc)(guiTimerCallbackFunc callback); 
Ntypedef void(*guiSetTimeoutFunc)(uint8_t timerIndex, TickType_t time);
Ntypedef void(*guiRunTimeoutFunc)(uint8_t timerIndex);
N
N//************************  TSReader  ************************// 
Ntypedef void(*tsreaderDepositResultCallback)(BOOL flag, uint16_t paraValue, uint16_t infoValue);
Ntypedef void(*tsreaderCNResultCallback)(BOOL flag, uint8_t* cn, int cnLen);
N
Ntypedef BOOL(*tsreaderInitFunc)(void);
Ntypedef BOOL(*tsreaderSetPowerFunc)(uint8_t id, BOOL flag);
Ntypedef uint8_t(*tsreaderCheckReaderFunc)(void);
Ntypedef BOOL(*tsreaderBreakCheckReaderFunc)(void);
Ntypedef BOOL(*tsreaderProcessFunc)(uint16_t targetDeduct, tsreaderDepositResultCallback callback);
Ntypedef BOOL(*tsreaderProcessCNFunc)(tsreaderCNResultCallback callback);
Ntypedef BOOL(*tsreaderGetBootedStatus)(void);
Ntypedef BOOL(*tsreaderSignOnProcess)(void);
Ntypedef void(*tsreaderSaveFileFunc)(RTC_TIME_DATA_T pt, uint16_t paraValue);
Ntypedef void(*tsreaderSaveFilePureFunc)(void);
N
N//************************  Camera  ************************//
Ntypedef BOOL(*cameraInitFunc)(BOOL testModeFlag);
N#if(SUPPORT_HK_10_HW)
X#if(1)
Ntypedef BOOL(*cameraTakePhoto)(int index, uint8_t** photoPr, int* photoLen, StorageType type, char* dir, char* fileName, BOOL smallSizeFlag,int photoNum, int takeInterval);
N#else
Stypedef BOOL(*cameraTakePhoto)(int index, uint8_t** photoPr, int* photoLen, StorageType type, char* dir, char* fileName, BOOL smallSizeFlag);
N#endif
Ntypedef void(*cameraSetPower)(int index,BOOL flag);
N
Ntypedef BOOL(*cameraInitBurningFunc)(BOOL testModeFlag);
N
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N//************************  KEY ************************//
Ntypedef struct
N{
N    keyInitFunc             initFunc;
N    keySetCallbackFunc      setCallbackFunc;
N    keySetPowerFunc      setPowerFunc;
N}KeyInterface;
N
NKeyInterface* KeyGetInterface(void);
N//************************  TIMER  ************************//
Ntypedef struct
N{
N    timerInitFunc               initFunc;
N    timerSetTimeoutFunc         setTimeoutFunc;
N    timerRunFunc                runFunc;
N    timerSetCallbackFunc        setCallbackFunc;
N}TimerInterface;
N
NTimerInterface* TimerGetInterface(void);
N
N//************************  GUI  ************************//
Ntypedef struct
N{
N    guiInitFunc                     initFunc;
N    guiSetKeyCallbackFunc           setKeyCallbackFunc;
N    guiSetTimerCallbackFunc         setTimerCallbackFunc;
N    guiSetTimeoutFunc               setTimeoutFunc;
N    guiRunTimeoutFunc               runTimeoutFunc;
N}GuiInterface;
N
NGuiInterface* GuiGetInterface(void);
N
N//************************  TSReader  ************************//
N#define TSREADER_HALINTERFACE_NUM          1//2
N
N#define TSREADER_CHECK_READER_INIT              1
N#define TSREADER_CHECK_READER_OK                2
N#define TSREADER_CHECK_READER_ERROR             3 
N#define TSREADER_CHECK_READER_BREAK             4
N
N
N//#define TSREADER_TS1000_INTERFACE_INDEX     0
N#define TSREADER_EPM_READER_INTERFACE_INDEX     0//1    
N
Ntypedef struct
N{
N    tsreaderInitFunc                initFunc;
N    tsreaderSetPowerFunc            setPowerFunc;
N    tsreaderBreakCheckReaderFunc    breakCheckReaderFunc;
N    tsreaderCheckReaderFunc         checkReaderFunc;
N    tsreaderProcessFunc             processFunc;
N    tsreaderProcessCNFunc           processCNFunc;
N    tsreaderGetBootedStatus         getBootedStatusFunc;
N    tsreaderSignOnProcess           signOnProcessFunc;
N    tsreaderSaveFileFunc            saveFileFunc;
N    tsreaderSaveFilePureFunc        saveFilePureFunc;
N}TSReaderInterface;
N
NTSReaderInterface* TSReaderGetInterface(uint8_t index);
N
N//************************  Camera  ************************//
N#define CAMERA_HALINTERFACE_NUM          1
N
N//#define CAMERA_PCT08_INTERFACE_INDEX     0  
N//#define CAMERA_ZM460_INTERFACE_INDEX     1  
N#define CAMERA_UVC_INTERFACE_INDEX     0//2  
Ntypedef struct
N{
N    cameraInitFunc                  initFunc;
N    cameraTakePhoto                 takePhotoFunc; 
N    cameraSetPower                  setPowerFunc;
N    cameraInitBurningFunc           initBurningFunc;
N}CameraInterface;
N
NCameraInterface* CameraGetInterface(uint8_t index);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__HAL_INTERFACE_H__
L 17 ".\src\syshal\keydrv.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N#define KEY_DRV_MODE_NORMAL_INDEX  0x01
N#define KEY_DRV_MODE_TEST_INDEX  0x02
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL KeyDrvInit(void);
Nvoid KeyDrvSetCallbackFunc(keyCallbackFunc func);
Nvoid KeyDrvSetPowerFunc(BOOL powerFlag);
Nvoid KeyDrvSetMode(uint8_t mode);
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__KEY_DRV_H__
L 21 "src\user\hwtester.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define ACTION_TESTER_ITEM_NONE     0x00
N#define ACTION_TESTER_ITEM_TRUE     0x01
N#define ACTION_TESTER_ITEM_FALSE    0x02
N	
N
N	
N#define TOUCH_UP		1
N#define TOUCH_DOWN		2
N
N	
N
N	
N/*
N#define MATRIX_NUMBER_BUZZER			0
N#define MATRIX_NUMBER_LED				1
N#define MATRIX_NUMBER_SWITCH			2
N#define MATRIX_NUMBER_BOTTON			3
N#define MATRIX_NUMBER_EPD				4
N#define MATRIX_NUMBER_TOUCH				5
N#define MATRIX_NUMBER_MODEM				6
N#define MATRIX_NUMBER_RTC				7
N#define MATRIX_NUMBER_READER			8
N#define MATRIX_NUMBER_FLASH				9
N#define MATRIX_NUMBER_SMARTCARD		    10
N#define MATRIX_NUMBER_CAMERA			11
N#define MATRIX_NUMBER_PROWAVE			12
N#define MATRIX_NUMBER_BATTERY			13
N*/
Ntypedef BOOL(*HWTesterFunc)(void* para1, void* para2);
N
Ntypedef struct
N{
N    char                        charItem;
N    char*                       itemName;
N    HWTesterFunc                testerFunc;
N}HWTesterItem;
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL HWTesterInit(void);
NBOOL MTPTesterInit(void);
N
NBOOL CallBackReturnValue(uint8_t keyId, uint8_t downUp);
Nvoid SetGuiResponseVal(char guiresponse);
NBOOL GetTesterFlag(void);
N/*
NBOOL GetTesterResult(void);
NBOOL GetEPDPrintFlag(void);
Nchar* GetEPDString(void);
Nuint32_t GetCardID(void);
NBOOL GetRefresh(void);*/
N
Nint GetDeviceIDString(void);
NBOOL SetDeviceIDString(void* para1,void* para2);
N
Nvoid hwtestEDPflashBurn(void);
N
Nvoid hwtestEDPflashBurnLite(void);
N
NBOOL readMBtestFunc(void);
NBOOL readAssemblyTestFunc(void);
N
Nvoid HwTestReceieveU32Func(UINT32 tempVal);
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
NBOOL LEDColorBuffSet(UINT16 GreenPinBite, UINT16 RedPinBite);
NBOOL LEDBoardLightSet(void);
N#endif
N
Nvoid QueryCADtimeoutFunc(BOOL timeoutFlag);
N
NBOOL QueryNTPfun(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__HW_TESTER_H__
L 26 "src\user\hwtester.c" 2
N#include "buzzerdrv.h"
L 1 ".\src\userdrv\buzzerdrv.h" 1
N/**************************************************************************//**
N* @file     buzzerdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __BUZZER_DRV_H__
N#define __BUZZER_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
L 1 ".\src\userdrv\interface.h" 1
N/**************************************************************************//**
N* @file     interface.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __INTERFACE_H__
N#define __INTERFACE_H__
N
N#include "nuc970.h"
N#include "uart.h"
L 1 "..\..\common\src\BSP\Driver\Include\uart.h" 1
N/**************************************************************************//**
N* @file     uart.h
N* @version  V1.00
N* $Revision: 5 $
N* $Date: 15/06/10 12:00p $
N* @brief    NUC970 UART driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __UART_H__
N#define __UART_H__
N
N#include "nuc970.h"
N
N/* Scheduler includes. */
N//add by sam
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_UART_Driver UART Driver
N  @{
N*/
N
N
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N/// @cond HIDDEN_SYMBOLS
N#define UART_NUM         11
N
N#define UARTOFFSET       0x100
N/// @endcond HIDDEN_SYMBOLS
N
N/** @addtogroup NUC970_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N#define UARTWRITESIZE    (1024+256)//by sam 100 /*!< UART max. write size */
N
N#define UARTINTMODE      1   /*!< UART interrupt mode */
N#define UARTPOLLMODE     0   /*!< UART polling mode */
N#define DISABLEALLIER    0   /*!< Disable all interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART channel number                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART0       0    /*!< UART0  channel */
N#define UART1       1    /*!< UART1  channel */
N#define UART2       2    /*!< UART2  channel */
N#define UART3       3    /*!< UART3  channel */
N#define UART4       4    /*!< UART4  channel */
N#define UART5       5    /*!< UART5  channel */
N#define UART6       6    /*!< UART6  channel */
N#define UART7       7    /*!< UART7  channel */
N#define UART8       8    /*!< UART8  channel */
N#define UART9       9    /*!< UART9  channel */
N#define UARTA       10   /*!< UART10  channel */
N#define ALLCHANNEL  11   /*!< UART ALL  channel */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE      (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES     (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES     (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES    (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N#define UART_FCR_RFITL_30BYTES    (0x4 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 30 bits */
N#define UART_FCR_RFITL_46BYTES    (0x5 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 46 bits */
N#define UART_FCR_RFITL_62BYTES    (0x6 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 62 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE      (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES     (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES     (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES    (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N#define UART_FCR_RTS_TRI_LEV_30BYTES    (0x4 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 30 bits */
N#define UART_FCR_RTS_TRI_LEV_46BYTES    (0x5 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 46 bits */
N#define UART_FCR_RTS_TRI_LEV_62BYTES    (0x6 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 62 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DATA_BITS_5     (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define DATA_BITS_6     (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define DATA_BITS_7     (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define DATA_BITS_8     (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define PARITY_STICK    (0x8 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as stick parity */
N
N#define STOP_BITS_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define STOP_BITS_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define STOP_BITS_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Tigger   */
N#define UART_RTS_IS_LOW_LEV_TRG  (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Tigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART CTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_CTS_IS_HIGH_LEV_TRG    (0x1 << UART_MSR_LEV_CTS_Pos) /*!< Set CTS is High Level Trigger   */
N#define UART_CTS_IS_LOW_LEV_TRG     (0x0 << UART_MSR_LEV_CTS_Pos) /*!< Set CTS is Low Level Trigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART  (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN   (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Funciton             */
N#define UART_FUNC_SEL_IrDA  (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485 (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LIN_CTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LIN_CTL_LINS_EN        (0x1UL << UART_LIN_CTL_LINS_EN_Pos)       /*!< UA_LIN_CTL setting to set LIN Slave Mode Enable */
N#define UART_LIN_CTL_LINS_HDET_EN   (0x1UL << UART_LIN_CTL_LINS_HDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Slave Header Detection Enable */
N#define UART_LIN_CTL_LINS_ARS_EN    (0x1UL << UART_LIN_CTL_LINS_ARS_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Automatic Resynchronization Mode Enable */
N#define UART_LIN_CTL_LINS_DUM_EN    (0x1UL << UART_LIN_CTL_LINS_DUM_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Divider Update Method Enable */
N#define UART_LIN_CTL_LIN_WAKE_EN    (0x1UL << UART_LIN_CTL_LIN_WAKE_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Wake-Up Mode Enable */
N#define UART_LIN_CTL_LIN_SHD        (0x1UL << UART_LIN_CTL_LIN_SHD_Pos)       /*!< UA_LIN_CTL setting to set LIN TX Send Header Enable */
N#define UART_LIN_CTL_LIN_IDPEN      (0x1UL << UART_LIN_CTL_LIN_IDPEN_Pos)     /*!< UA_LIN_CTL setting to set LIN ID Parity Enable */
N#define UART_LIN_CTL_LIN_BKDET_ENN  (0x1UL << UART_LIN_CTL_LIN_BKDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Detection Enable */
N#define UART_LIN_CTL_LIN_RX_DIS     (0x1UL << UART_LIN_CTL_LIN_RX_DIS_Pos)    /*!< UA_LIN_CTL setting to set LIN Receiver Disable */
N#define UART_LIN_CTL_BIT_ERR_EN     (0x1UL << UART_LIN_CTL_BIT_ERR_EN_Pos)    /*!< UA_LIN_CTL setting to set Bit Error Detect Enable */
N#define UART_LIN_CTL_LIN_BKFL(x)    (((x)-1) << UART_LIN_CTL_LIN_BKFL_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LIN_CTL_LIN_BS_LEN(x)  (((x)-1) << UART_LIN_CTL_LIN_BS_LEN_Pos)/*!< UA_LIN_CTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK             (0x0UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC        (0x1UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field and sync field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC_ID     (0x2UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LIN_CTL_LIN_LIN_PID(x) ((x) << UART_LIN_CTL_LIN_PID_Pos)       /*!< UA_LIN_CTL setting to set LIN PID value */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* BAUD constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0        (0)  /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2        (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk)  /*!< Set UART Baudrate Mode is Mode2 */
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
N#define UART_RBR_RBR_Msk        (0xFFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART IER: RX DMA Enable Posistion */
N#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART IER: RX DMA Enable Mask      */
N
N#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART IER: TX DMA Enable Posistion */
N#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART IER: TX DMA Enable Mask      */
N
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART IER: LIN_RX_BRK_IEN Posistion   */
N#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART IER: LIN_RX_BRK_IEN Mask        */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART ISR: LIN_RX_BREAK_INT Position       */
N#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART ISR: LIN_RX_BREAK_INT Mask           */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART ISR: LIN RX BREAK IF Position   */
N#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART ISR: LIN RX BREAK IF Mask       */
N
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)            /*!< UART TOR: TOIC Mask                  */
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
N
N/* UART LIN_CTL Bit Field Definitions */
N#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART LIN_CTL: LIN_PID Position       */
N#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART LIN_CTL: LIN_PID Mask           */
N
N#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART LIN_CTL: LIN_HEAD_SEL Position       */
N#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART LIN_CTL: LIN_HEAD_SEL Mask           */
N
N#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART LIN_CTL: LIN_BS_LEN Position       */
N#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART LIN_CTL: LIN_BS_LEN Mask           */
N
N#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART LIN_CTL: LIN_BKFL Position       */
N#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART LIN_CTL: LIN_BKFL Mask           */
N
N#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART LIN_CTL: BIT_ERR_EN Position       */
N#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART LIN_CTL: BIT_ERR_EN Mask           */
N
N#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART LIN_CTL: LIN_RX_DIS Position       */
N#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART LIN_CTL: LIN_RX_DIS Mask           */
N
N#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART LIN_CTL: LIN_BKDET_EN Position       */
N#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART LIN_CTL: LIN_BKDET_EN Mask           */
N
N#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART LIN_CTL: LIN_IDPEN Position       */
N#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART LIN_CTL: LIN_IDPEN Mask           */
N
N#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART LIN_CTL: LIN_SHD Position       */
N#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART LIN_CTL: LIN_SHD Mask           */
N
N#define UART_LIN_CTL_LIN_WAKE_EN_Pos    4                                          /*!< UART LIN_CTL: LIN_WAKE_EN Position       */
N#define UART_LIN_CTL_LIN_WAKE_EN_Msk    (1ul << UART_LIN_CTL_LIN_WAKE_EN_Pos)      /*!< UART LIN_CTL: LIN_WAKE_EN Mask           */
N
N#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART LIN_CTL: LINS_DUM_EN Position       */
N#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART LIN_CTL: LINS_DUM_EN Mask           */
N
N#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART LIN_CTL: LINS_ARS_EN Position       */
N#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART LIN_CTL: LINS_ARS_EN Mask           */
N
N#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART LIN_CTL: LINS_HDET_EN Position       */
N#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART LIN_CTL: LINS_HDET_EN Mask           */
N
N#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART LIN_CTL: LINS_EN Position       */
N#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART LIN_CTL: LINS_EN Mask           */
N
N/* UART LIN_SR Bit Field Definitions */
N#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART LIN_SR: LINS_SYNC_F Position       */
N#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART LIN_SR: LINS_SYNC_F Mask           */
N
N#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART LIN_SR: LINS_IDPERR_F Position       */
N#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART LIN_SR: LINS_IDPERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART LIN_SR: LINS_HERR_F Position       */
N#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART LIN_SR: LINS_HERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART LIN_SR: LINS_HDET_F Position       */
N#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART LIN_SR: LINS_HDET_F Mask           */
N
N/* UART DEBUG Bit Field Definitions */
N#define UART_DEBUG_ERR_DIVIA_F_Pos      0                                           /*!< UART DEBUG: ERR_DIVIA_F Position       */
N#define UART_DEBUG_ERR_DIVIA_F_Msk      (1ul << UART_DEBUG_ERR_DIVIA_F_Pos)         /*!< UART DEBUG: ERR_DIVIA_F Mask           */
N
N#define UART_DEBUG_ERR_HETIME_OUT_F_Pos 1                                           /*!< UART DEBUG: ERR_HETIME_OUT_F Position  */
N#define UART_DEBUG_ERR_HETIME_OUT_F_Msk (1ul << UART_DEBUG_ERR_HETIME_OUT_F_Pos)    /*!< UART DEBUG: ERR_HETIME_OUT_F Mask      */
N
N#define UART_DEBUG_ERR_HEFE_F_Pos       2                                           /*!< UART DEBUG: ERR_HEFE_F Position        */
N#define UART_DEBUG_ERR_HEFE_F_Msk       (1ul << UART_DEBUG_ERR_HEFE_F_Pos)          /*!< UART DEBUG: ERR_HEFE_F Mask            */
N
N#define UART_DEBUG_ERR_SYNC_F_Pos       3                                           /*!< UART DEBUG: ERR_SYNC_F Position        */
N#define UART_DEBUG_ERR_SYNC_F_Msk       (1ul << UART_DEBUG_ERR_SYNC_F_Pos)          /*!< UART DEBUG: ERR_SYNC_F Mask            */
N
N/* UART SC_CTL Bit Field Definitions */
N#define UART_SC_CTL_RX_ERETRY_Pos       0                                           /*!< UART SC_CTL: RX_ERETRY Position        */
N#define UART_SC_CTL_RX_ERETRY_Msk       (7ul << UART_SC_CTL_RX_ERETRY_Pos)          /*!< UART SC_CTL: RX_ERETRY Mask            */
N
N#define UART_SC_CTL_RX_ERETRY_EN_Pos    3                                           /*!< UART SC_CTL: RX_ERETRY_EN Position     */
N#define UART_SC_CTL_RX_ERETRY_EN_Msk    (1ul << UART_SC_CTL_RX_ERETRY_EN_Pos)       /*!< UART SC_CTL: RX_ERETRY_EN Mask         */
N
N#define UART_SC_CTL_TX_ERETRY_Pos       4                                           /*!< UART SC_CTL: TX_ERETRY Position        */
N#define UART_SC_CTL_TX_ERETRY_Msk       (7ul << UART_SC_CTL_TX_ERETRY_Pos)          /*!< UART SC_CTL: TX_ERETRY Mask            */
N
N#define UART_SC_CTL_TX_ERETRY_EN_Pos    7                                           /*!< UART SC_CTL: TX_ERETRY_EN Position     */
N#define UART_SC_CTL_TX_ERETRY_EN_Msk    (1ul << UART_SC_CTL_TX_ERETRY_EN_Pos)       /*!< UART SC_CTL: TX_ERETRY_EN Mask         */
N
N/* UART SC_FSR Bit Field Definitions */
N#define UART_SC_FSR_RX_OVER_ERETRY_Pos      0                                       /*!< UART SC_FSR: RX_OVER_ERETRY Position   */
N#define UART_SC_FSR_RX_OVER_ERETRY_Msk      (1ul << UART_SC_FSR_RX_OVER_ERETRY_Pos) /*!< UART SC_FSR: RX_OVER_ERETRY Mask       */
N
N#define UART_SC_FSR_TX_OVER_ERETRY_Pos      1                                       /*!< UART SC_FSR: TX_OVER_ERETRY Position   */
N#define UART_SC_FSR_TX_OVER_ERETRY_Msk      (1ul << UART_SC_FSR_TX_OVER_ERETRY_Pos) /*!< UART SC_FSR: TX_OVER_ERETRY Mask       */
N
N#define UART_SC_FSR_RX_ERETRY_F_Pos         8                                       /*!< UART SC_FSR: RX_ERETRY_F Position      */
N#define UART_SC_FSR_RX_ERETRY_F_Msk         (1ul << UART_SC_FSR_RX_ERETRY_F_Pos)    /*!< UART SC_FSR: RX_ERETRY_F Mask          */
N
N#define UART_SC_FSR_TX_ERETRY_F_Pos         9                                       /*!< UART SC_FSR: TX_ERETRY_F Position      */
N#define UART_SC_FSR_TX_ERETRY_F_Msk         (1ul << UART_SC_FSR_TX_ERETRY_F_Pos)    /*!< UART SC_FSR: TX_ERETRY_F Mask          */
N
N/*  Enable/Disable IrDA Mode */
N#define ENABLEIrDA            1  /*!< Enable IrDA */
N#define DISABLEIrDA           0  /*!< Disable IrDA */
N
N/*  define IrDA Direction */
N#define IrDA_TX               0   /*!< Set IrDA Tx direction*/
N#define IrDA_RX               1   /*!< Set IrDA Rx direction*/
N
N/*  define RTS signal */
N#define UART_RTS_HIGH           1  /*!< Set RTS high*/
N#define UART_RTS_LOW            0  /*!< Set RTS low*/
N
N/* define IOCTL command of UART operation mode, interrupt or pooling mode */
N#define UART_IOC_SETTXMODE               1     /*!< Set Tx Mode */
N#define UART_IOC_SETRXMODE               2     /*!< Set Tx Mode */
N#define UART_IOC_GETRECCHARINFO          3     /*!< Get receive character */
N#define UART_IOC_SETUARTPARAMETER        4     /*!< Config UART */
N//#define UART_IOC_PERFORMBLUETOOTH      5
N#define UART_IOC_PERFORMIrDA             6     /*!< Config IrDA */
N#define UART_IOC_GETUARTREGISTERVALUE    7     /*!< Get UART register value*/
N#define UART_IOC_GETERRNO                8     /*!< Get rrror code */
N//#define UART_IOC_SETMODEMLOOPBACK      9
N//#define UART_IOC_GETDSRSTATE           10
N//#define UART_IOC_SETDTRSIGNAL          11
N#define UART_IOC_SETINTERRUPT            12    /*!< Set interrupt */
N#define UART_IOC_SETBREAKCONTROL         13    /*!< Set break */
N#define UART_IOC_GETBIISTATE             14    /*!< Get break status */
N#define UART_IOC_GETCTSSTATE             15    /*!< Get CTS status */
N#define UART_IOC_SETRTSSIGNAL            16    /*!< Set RTS signal */
N#define UART_IOC_SETMODEMINTERRUPT       17    /*!< Set modem interrupt */
N#define UART_IOC_ENABLEHWFLOWCONTROL     18    /*!< Enable H/W flow control */
N#define UART_IOC_DISABLEHWFLOWCONTROL    19    /*!< Disable H/W flow control */
N//#define UART_IOC_ENABLESWFLOWCONTROL   20    /*!< Enable S/W flow control */
N//#define UART_IOC_DISABLESWFLOWCONTROL  21    /*!< Disable S/W flow control */
N//#define UART_IOC_SETUART1FULLMODEM       22
N//#define UART_IOC_SETUART1HIGHSPEED       23
N
N#define UART_IOC_FLUSH_TX_BUFFER         24    /*!< Flush Tx buffer */
N#define UART_IOC_FLUSH_RX_BUFFER         25    /*!< Flus Rx buffer */
N
N#define UART_IOC_SET_RS485_MODE          26     /*!< Select RS485 Mode */
N#define UART_IOC_SEND_RS485_ADDRESS     27     /*!< Send RS485 Address*/
N#define UART_IOC_SET_RS485_RXOFF         28     /*!< Select RS485 Mode */
N#define UART_IOC_SET_ALTCTL_REG          29     /*!< Set ALT_CTL register */
N#define UART_IOC_GET_ALTCTL_REG          30     /*!< Get ALT_CTL register */
N
N#define UART_IOC_SET_LIN_MODE            31     /*!< Select LIN Mode */
N
N
N/*  Enable/Disable Modem interrupt */
N#define UART_ENABLE_MODEM_INT   0   /*!< Enable Modem interrupt */
N#define UART_DISABLE_MODEM_INT  1   /*!< Disable Modem interrupt */
N
N/* These error code can get from UART_IOC_GETERRNO */
N#define UART_ERR_PARITY_INVALID          -1   /*!< Parity invalid */
N#define UART_ERR_DATA_BITS_INVALID       -2   /*!< Data bits invalid */
N#define UART_ERR_STOP_BITS_INVALID       -3   /*!< Stop bit invalid */
N#define UART_ERR_TRIGGERLEVEL_INVALID    -4   /*!< Trigger level invalid */
N#define UART_ERR_CHANNEL_INVALID         -5   /*!< UART channel invalid */
N#define UART_ERR_ALLOC_MEMORY_FAIL       -6   /*!< Allocate memory error */
N//#define UART_ERR_CLOCK_SOURCE_INVALID    -7   /*!< Clock Source invalid */
N//#define UART_ERR_BAUDRATE_INVALID        -8   /*!< Baudrate invalid */
N//#define UART_ERR_CONFIGURE_BT_FAIL       -9
N#define UART_ERR_IrDA_COMMAND_INVALID    -10   /*!< IrDA mode invalid */
N#define UART_ERR_TX_BUF_NOT_ENOUGH       -11   /*!< Tx buffer not enough */
N#define UART_ERR_OPERATE_MODE_INVALID    -12   /*!< Operation mode invalid */
N#define UART_ERR_SET_BAUDRATE_FAIL       -13   /*!< Set baudrate fail */
N
N/* These are the error code actually returns to user application */
N#define UART_ERR_ID     0xFFFF1700        /*!< UART library ID */
N#define UART_ENOTTY    (1 | UART_ERR_ID)  /*!< Command not support           */
N#define UART_ENODEV    (2 | UART_ERR_ID)  /*!< Interface number out of range */
N#define UART_EIO       (3 | UART_ERR_ID)  /*!< Read/Write error              */
N
N/*@}*/ /* end of group NUC970_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_UART_EXPORTED_STRUCTS UART Exported Structs
N  @{
N*/
N
N/// @cond HIDDEN_SYMBOLS
N/*----------------------------------------------------*/
N/* Define UART buffer structure                       */
N/*----------------------------------------------------*/
Ntypedef struct UART_BUFFER_STRUCT {
N    UINT32 volatile  uUartTxHead, uUartTxTail;
N    UINT32 volatile  uUartRxHead, uUartRxTail;
N
N    PUINT8    pucUartTxBuf;
N    PUINT8    pucUartRxBuf;
N    PVOID     pvUartVector;
N    BOOL      bIsUseUARTTxInt;
N    BOOL      bIsUseUARTRxInt;
N    BOOL      bIsUARTInitial;
N
N    PINT      pucUARTFlag;
N    PINT      pucLINFlag;
N    UINT32 volatile uRecCnt;
N    INT32 volatile nErrno;
N
N} UART_BUFFER_T;
N/// @endcond HIDDEN_SYMBOLS
N
N/** \brief  Structure type of UART data
N */
Ntypedef struct UART_STRUCT {
N    UINT32      uFreq;       /*!< UART clock frequency */
N    UINT32      uBaudRate;   /*!< Baudrate */
N    UINT8       ucUartNo;    /*!< UART Port */
N    UINT8       ucDataBits;  /*!< Select Data length */
N    UINT8       ucStopBits;  /*!< Select stop bit length */
N    UINT8       ucParity;    /*!< Select Parity */
N    UINT8       ucRxTriggerLevel;  /*!< Select Rx FIFO trigger level */
N} UART_T;
N
N/** \brief  Structure type of UART register
N */
Ntypedef struct UART_REGISTER_STRUCT {
N    UINT32 uUartReg[14][2]; /*!< Store UART register value */
N} UART_REGISTER_T;
N
N/*@}*/ /* end of group NUC970_UART_EXPORTED_STRUCTS */
N
N
N/** @addtogroup NUC970_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N/**
N *    @brief   Calculate UART baudrate mode0 divider
N *
N *    @param[in]   u32SrcFreq      UART clock frequency
N *    @param[in]   u32BaudRate     Baudrate of UART module
N *
N *    @return  UART baudrate mode0 divider
N *  \hideinitializer
N *
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N *    @brief   Calculate UART baudrate mode2 divider
N *
N *    @param[in]   u32SrcFreq     UART clock frequency
N *    @param[in]   u32BaudRate    Baudrate of UART module
N *
N *    @return  UART baudrate mode2 divider
N * \hideinitializer
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NINT uartOpen(PVOID param);
NINT uartInit(void);
NINT uartIoctl(INT nNum, UINT32 uCom, UINT32 uArg0, UINT32 uArg1);
NINT32 uartRelease(INT nNum);
NINT32 uartWrite(INT nNum, PUINT8 pucBuf, UINT32 uLen);
NINT32 uartRead(INT nNum, PUINT8 pucBuf, UINT32 uLen);
N//add by sam
NBaseType_t uartWaitReadEvent(INT nNum, TickType_t time);
N/*@}*/ /* end of group NUC970_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_UART_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#endif
L 17 ".\src\userdrv\interface.h" 2
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N
N#include "vl53l0xdrv.h"
L 1 ".\src\userdrv\vl53l0xdrv.h" 1
N/**************************************************************************//**
N* @file     vl53l0xdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __VL53L0X_DRV_H__
N#define __VL53L0X_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
L 1 ".\src\userdrv\interface.h" 1
N/**************************************************************************//**
N* @file     interface.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __INTERFACE_H__
S#define __INTERFACE_H__
S
S#include "nuc970.h"
S#include "uart.h"
S/* Scheduler includes. */
S#include "FreeRTOS.h"
S#include "task.h"
S#include "queue.h"
S#include "semphr.h"
S
S#include "vl53l0xdrv.h"
S
S
S#ifdef __cplusplus
Sextern "C"
S{
S#endif
S
S/*-----------------------------------------*/
S/* marco, type and constant definitions    */
S/*-----------------------------------------*/
S//************************  UART  ************************//
S#define UART_INTERFACE_NUM          8 //7
S
S#define UART_1_INTERFACE_INDEX      0
S#define UART_2_INTERFACE_INDEX      1
S#define UART_3_INTERFACE_INDEX      2    
S#define UART_4_INTERFACE_INDEX      3 
S#define UART_7_INTERFACE_INDEX      4
S#define UART_8_INTERFACE_INDEX      5    
S#define UART_10_INTERFACE_INDEX     6 
S#define UART_0_INTERFACE_INDEX      7    
S    
S#define UART_IOC_SET_OCTOPUS_MODE   40  //must exceed UART_IOC_SET_LIN_MODE        	 31     /*!< Select LIN Mode */
S
Stypedef BOOL (*uartInitFunc)(UINT32 baudRate);
Stypedef INT32(*uartWriteFunc)(PUINT8 pucBuf, UINT32 uLen);
Stypedef INT32(*uartReadFunc)(PUINT8 pucBuf, UINT32 uLen);
Stypedef BaseType_t(*uartReadWaitFunc)(TickType_t time);
Stypedef BOOL(*uartSetPowerFunc)(BOOL flag);
Stypedef INT (*uartIoctlFunc)(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1);
S
S//************************  SPI  ************************//
S#define SPI_INTERFACE_NUM           2
S
S#define SPI_0_INTERFACE_INDEX       0
S#define SPI_1_INTERFACE_INDEX       1
S
S    
Stypedef BOOL(*spiInitFunc)(void);
Stypedef void(*spiWriteFunc)(uint8_t buff_id, uint32_t data);
Stypedef uint32_t(*spiReadFunc)(uint8_t buff_id);
Stypedef void(*spiActiveCS)(BOOL active);
Stypedef void(*spiSetPin)(void);
Stypedef void(*spiResetPin)(void);
S
S//************************  I2C  ************************//
S#define I2C_INTERFACE_NUM           1
S
S#define I2C_1_INTERFACE_INDEX       0
S    
Stypedef BOOL(*i2cInitFunc)(void);
Stypedef int32_t(*i2cIoctlFunc)(uint32_t cmd, uint32_t arg0, uint32_t arg1);
Stypedef int32_t(*i2cReadFunc)(uint8_t* buf, uint32_t len);
Stypedef int32_t(*i2cWriteFunc)(uint8_t* buf, uint32_t len);
Stypedef void(*i2cenableCriticalSectionFunc)(BOOL flag);
Stypedef void(*i2cSetPin)(void);
Stypedef void(*i2cResetPin)(void);
S
S//************************  KEY  ************************//
S#define KEY_HARDWARE_INTERFACE_NUM               2
S
S#define KEY_HARDWARE_PCF8885_INTERFACE_INDEX     0
S#define KEY_HARDWARE_DIP_INTERFACE_INDEX         1
S    
S#define KEY_HARDWARE_DOWN_EVENT                  0x1
S#define KEY_HARDWARE_UP_EVENT                    0x2
S#define KEY_HARDWARE_ERROR_EVENT                 0xf
S
Stypedef BOOL(*keyHardwareCallbackFunc)(uint8_t keyId, uint8_t downUp);
S    
Stypedef BOOL(*keyHardwareInitFunc)(BOOL testModeFlag);
Stypedef void(*keyHardwareSetCallbackFunc)(keyHardwareCallbackFunc func);
Stypedef BOOL(*keyHardwareSetPowerFunc)(BOOL powerFlag);
S
S//************************  Distance  ************************//
S#define DIST_INTERFACE_NUM              1
S
S#define DIST_SR04T_INTERFACE_INDEX      0
S
S#define DIST_DEVICE_1  0
S#define DIST_DEVICE_2  1
S    
Stypedef BOOL(*distInitFunc)(void);
Stypedef BOOL(*distMeasureDist)(uint8_t id, int* detectResult);
S
S//************************  Storage  ************************//
S#define STORAGE_INTERFACE_NUM              1
S
S#define STORAGE_FLASH_INTERFACE_INDEX       0
S    
Stypedef BOOL(*storageInitFunc)(void);
Stypedef BOOL(*storageWrite)(uint8_t *u8DataBuffer, int BuffLen);
Stypedef BOOL(*storageRead)(uint8_t *u8DataBuffer, int BuffLen);
S
S//************************  Communication  ************************//
S#define COMMUNICATION_INTERFACE_NUM                 2 //1
S
S#define COMMUNICATION_RS232_INTERFACE_INDEX         0
S#define MTP_RS232_INTERFACE_INDEX                   1
S
Stypedef BOOL(*commInitFunc)(void);
Stypedef INT32(*commWrite)(PUINT8 pucBuf, UINT32 uLen);
Stypedef INT32(*commRead)(PUINT8 pucBuf, UINT32 uLen);
Stypedef BaseType_t(*commReadWaitFunc)(TickType_t time);
S
S//************************  FatFs Hardware  ************************//
S#define FATFS_HARDWARE_INTERFACE_NUM                     3
S
S#define FATFS_HARDWARE_SD_INTERFACE_INDEX                0
S#define FATFS_HARDWARE_SFLASH_0_INTERFACE_INDEX          1
S#define FATFS_HARDWARE_SFLASH_1_INTERFACE_INDEX          2
S
Stypedef BOOL(*fatfsHwInitFunc)(void);
Stypedef BOOL(*diskInitialize)(uint8_t pdrv);
Stypedef BOOL(*diskStatus)(uint8_t pdrv);
Stypedef BOOL(*diskRead)(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
Stypedef BOOL(*diskWrite)(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
Stypedef BOOL(*diskIoctl)(uint8_t pdrv, uint8_t cmd, void *buff );
S
S//************************  Radar  ************************//
S//UT(FpFO})
S//#define RADAR_INTERFACE_NUM                     2//pFq
S//#define RADAR_AV_DESIGN_INTERFACE_INDEX         0//pF(index)
S//#define LIDAR_AV_DESIGN_INTERFACE_INDEX         1//F(index)
S
S#define RADAR_INTERFACE_NUM                     3 //2
S#define RADAR_AV_DESIGN_INTERFACE_INDEX         0
S#define LIDAR_AV_DESIGN_INTERFACE_INDEX         1
S#define NEWRADAR_INTERFACE_INDEX                2
S
S#define LIDAR_FEATURE_OCCUPIED      0x01
S#define LIDAR_FEATURE_VACUUM        0x02
S#define LIDAR_FEATURE_UN_STABLED    0x03
S#define LIDAR_FEATURE_INIT          0x04
S#define LIDAR_FEATURE_IGNORE        0x05
S#define LIDAR_FEATURE_FAIL          0xFF
S
S#define RADAR_FEATURE_OCCUPIED                  0x01
S#define RADAR_FEATURE_OCCUPIED_UN_STABLED       0x02
S#define RADAR_FEATURE_VACUUM                    0x03
S#define RADAR_FEATURE_VACUUM_UN_STABLED         0x04
S#define RADAR_FEATURE_INIT                      0x05
S#define RADAR_FEATURE_IGNORE                    0x06
S
S
S#define RADAR_FEATURE_OCCUPIED_LIDAR_FAIL                  0x31
S#define RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL       0x32
S#define RADAR_FEATURE_VACUUM_LIDAR_FAIL                    0x33
S#define RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL         0x34
S#define RADAR_FEATURE_INIT_LIDAR_FAIL                      0x35
S#define RADAR_FEATURE_IGNORE_LIDAR_FAIL                    0x36
S
S#define RADAR_FEATURE_FAIL                      0xFF
S
S#define RADAR_OCCUPIED_TYPE_POWER_1             0x10
S#define RADAR_OCCUPIED_TYPE_POWER_2             0x11
S#define RADAR_OCCUPIED_TYPE_DISTANCE            0x20
S#define RADAR_VACUUM_TYPE                       0x00
S
S#define RADAR_QUERY_VERSION_OK                  0x50
S#define RADAR_CALIBRATION_OK                    0x51
S
S
S#if (ENABLE_BURNIN_TESTER)
S#define VOS_INDEX_0                           0x0
S#define VOS_INDEX_1                           0x1
S
S//spFAPIwq
S#define VOS_FEATURE_OCCUPIED                  0x01
S#define VOS_FEATURE_OCCUPIED_UN_STABLED       0x02
S#define VOS_FEATURE_VACUUM                    0x03
S#define VOS_FEATURE_VACUUM_UN_STABLED         0x04
S#define VOS_FEATURE_INIT                      0x05
S#define VOS_FEATURE_IGNORE                    0x06
S#define VOS_FEATURE_FAIL                      0xFF
S
S#define VOS_OCCUPIED_TYPE_POWER_1             0x10
S#define VOS_OCCUPIED_TYPE_POWER_2             0x11
S#define VOS_OCCUPIED_TYPE_DISTANCE            0x20
S#define VOS_VACUUM_TYPE                       0x00
S
S//0 (from 0xff):TwA  1:sb  2:sb  3:bJw  4:bXw
S#define VOS_OBJECT_MOVING_UNSTABLE            0x00
S#define VOS_OBJECT_MOVING_EXIST               0x01
S#define VOS_OBJECT_MOVING_NON_EXIST           0x02
S#define VOS_OBJECT_MOVING_ENTERING            0x03
S#define VOS_OBJECT_MOVING_LEAVING             0x04
S#define VOS_OBJECT_MOVING_ERROR               0x05
S#endif
S
S
S
S
Stypedef BOOL(*radarInitialize)(void);
S//typedef int (*radarCheckFeature)(int index, BOOL* changeFlag, void* para1, void* para2);
Stypedef int (*radarCheckFeature)(int index, BOOL* changeFlag, void* para1, void* para2, void* para3);
Stypedef void(*radarSetPowerStatusFunc)(int index, BOOL flag);
Stypedef void(*radarSetPowerFunc)(BOOL flag);
S//m
Stypedef void(*radarSetStartCalibrate)(int lidarIndex, BOOL flag);
Stypedef void(*radarSetQueryVersion)(int lidarIndex, BOOL flag);
S
S
Stypedef void(*radarReadQueryVersion)(int lidarIndex, uint8_t* code1 ,uint8_t* code2, uint8_t* code3, uint8_t* code4);
Stypedef int(*radarReadQueryVersionString)(int lidarIndex, char* VersionStr);
S
S
Stypedef int (*radarCalibrateFunc)(int index, BOOL* changeFlag,int* dist1 ,int* dist2,void* para1, void* para2, void* para3);
S
Stypedef int (*radarReadDistValueFunc)(int index,int* dist);
S
S
Stypedef int (*radarCaptureEmptyFeature)(int radarIndex);
S//typedef BOOL (*radarSetEmptyFeature)(int radarIndex, pm_feature* feature);
S//typedef BOOL (*radarGetEmptyFeature)(int radarIndex, pm_feature* feature);
Stypedef BOOL (*radarCheckEmptyFeaturnFunc)(int radarIndex);
S
Stypedef void(*radarSetPowerExFunc)(int radarIndex, BOOL flag);
S
S
Stypedef BOOL (*radarFirstOTA)(int radarIndex, int BufferLen);
Stypedef BOOL (*radarOTA)(int radarIndex, uint8_t* ReadBuffer, int BufferIndex, int ReadBufferLen);
S
Stypedef BOOL (*radarRecentDistValue)(int radarIndex, uint16_t* lidarDist,  uint16_t* radarDist);
S
Stypedef int (*radarResult)(int radarIndex, uint8_t radarCmd, uint8_t* CmdBuff, uint8_t* radarData);
S
Stypedef void(*radarCreateTask)(void);
Stypedef void(*radarDeleteTask)(void);
S
Stypedef BOOL (*radarRB60POTA)(int radarIndex);
Stypedef void (*radarFlush)(int radarIndex);
Stypedef BOOL (*radarInitBurning)(int radarIndex);
S
S
S/*-----------------------------------------*/
S/* interface function declarations         */
S/*-----------------------------------------*/
S//************************  UART  ************************//
Stypedef struct
S{
S    uartInitFunc        initFunc;
S    uartWriteFunc       writeFunc;
S    uartReadFunc        readFunc;
S    uartReadWaitFunc    readWaitFunc;
S    uartSetPowerFunc    setPowerFunc;
S    uartSetPowerFunc    setRS232PowerFunc;
S    uartIoctlFunc       ioctlFunc;
S}UartInterface;
S
SUartInterface* UartGetInterface(uint8_t index);
S
S//************************  SPI  ************************//
Stypedef struct
S{
S    spiInitFunc         initFunc;
S    spiWriteFunc        writeFunc;
S    spiReadFunc         readFunc;
S    spiActiveCS         activeCSFunc;
S    spiSetPin           setPin;
S    spiResetPin         resetPin;
S}SpiInterface;
S
SSpiInterface* SpiGetInterface(uint8_t index);
S
S//************************  I2C  ************************//
Stypedef struct
S{
S    i2cInitFunc         initFunc;
S    i2cIoctlFunc        ioctlFunc;
S    i2cWriteFunc        writeFunc;
S    i2cReadFunc         readFunc;
S    i2cenableCriticalSectionFunc enableCriticalSectionFunc;
S    i2cSetPin           setPin;
S    i2cResetPin         resetPin;    
S}I2cInterface;
S
SI2cInterface* I2cGetInterface(uint8_t index);
S
S//************************  KEY  Hardware************************//
Stypedef struct
S{
S    keyHardwareInitFunc             initFunc;
S    keyHardwareSetCallbackFunc      setCallbackFunc;
S    keyHardwareSetPowerFunc         setPowerFunc;
S}KeyHardwareInterface;
S
SKeyHardwareInterface* KeyHardwareGetInterface(uint8_t index);
S
S//************************  Distance  ************************//
Stypedef struct
S{
S    distInitFunc         initFunc;
S    distMeasureDist      measureDistFunc;
S}DistInterface;
S
SDistInterface* DistGetInterface(uint8_t index);
S
S//************************  Storage  ************************//
Stypedef struct
S{
S    storageInitFunc         initFunc;
S    storageWrite            writeFunc;
S    storageRead             readFunc;
S}StorageInterface;
S
SStorageInterface* StorageGetInterface(uint8_t index);
S
S
S//************************  Communication  ************************//
Stypedef struct
S{
S    commInitFunc            initFunc;
S    commWrite               writeFunc;
S    commRead                readFunc;
S    commReadWaitFunc        readWaitFunc;
S}CommunicationInterface;
S
SCommunicationInterface* CommunicationGetInterface(uint8_t index);
S
S//************************  FatfsDrv  ************************//
S
Stypedef struct
S{
S    fatfsHwInitFunc     initFunc;
S    diskInitialize      diskInitFunc;
S    diskStatus          diskStatusFunc;
S    diskRead            diskReadFunc;
S    diskWrite           diskWriteFunc;
S    diskIoctl           diskIoctlFunc;
S    uint16_t            diskSectorSize;
S}FatfsHardwareInterface;
S
SFatfsHardwareInterface* FatfsHardwareGetInterface(uint8_t index);
S
S//************************  Radar  ************************//
S//typedef struct
S//{
S//    radarInitialize             initFunc;
S//    radarCheckFeature           checkFeaturnFunc;
S//    radarSetPowerFunc           setPowerFunc;
S//    radarSetPowerExFunc         setPowerExFunc;
S//}RadarInterface;
S
S//RadarInterface* RadarGetInterface(uint8_t index);
Stypedef struct
S{
S    radarInitialize             initFunc;
S    radarCheckFeature           checkFeaturnFunc;
S    radarSetPowerFunc           setPowerFunc;
S    radarSetPowerStatusFunc     setPowerStatusFunc;
S    //m
S    radarSetStartCalibrate      setStartCalibrate;
S    radarCalibrateFunc          calibrateFunc; 
S    radarReadDistValueFunc      readDistValueFunc;
S    radarSetQueryVersion        setQueryVersion;
S    radarReadQueryVersion       readQueryVersion;
S    radarReadQueryVersionString readQueryVersionString;
S    radarFirstOTA               FirstOTAFunc;
S    radarOTA                    OTAFunc;
S    radarRecentDistValue        RecentDistValueFunc;
S    radarResult                 RadarResultFunc;
S    radarResult                 RadarResultElite;
S    radarCreateTask             RadarCreateTaskFunc;
S    radarDeleteTask             RadarDeleteTaskFunc;
S    radarRB60POTA               RadarRB60POTAFunc;
S    radarFlush                  RadarFlushFunc;
S    radarInitBurning            RadarinitBurningFunc;
S}RadarInterface;
S
SRadarInterface* RadarGetInterface(uint8_t index);
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif //__INTERFACE_H__
L 17 ".\src\userdrv\vl53l0xdrv.h" 2
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define VL53L0X_DEVICE_1        0x0
N#define VL53L0X_DEVICE_2        0x1
N#define VL53L0X_DEVICE_ALL      0xf
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N
N
N
NBOOL Vl53l0xDrvInit(void);
NBOOL Vl53l0xMeasureDist(uint8_t id, int* detectResult);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__VL53L0X_DRV_H__
L 24 ".\src\userdrv\interface.h" 2
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N//************************  UART  ************************//
N#define UART_INTERFACE_NUM          8 //7
N
N#define UART_1_INTERFACE_INDEX      0
N#define UART_2_INTERFACE_INDEX      1
N#define UART_3_INTERFACE_INDEX      2    
N#define UART_4_INTERFACE_INDEX      3 
N#define UART_7_INTERFACE_INDEX      4
N#define UART_8_INTERFACE_INDEX      5    
N#define UART_10_INTERFACE_INDEX     6 
N#define UART_0_INTERFACE_INDEX      7    
N    
N#define UART_IOC_SET_OCTOPUS_MODE   40  //must exceed UART_IOC_SET_LIN_MODE        	 31     /*!< Select LIN Mode */
N
Ntypedef BOOL (*uartInitFunc)(UINT32 baudRate);
Ntypedef INT32(*uartWriteFunc)(PUINT8 pucBuf, UINT32 uLen);
Ntypedef INT32(*uartReadFunc)(PUINT8 pucBuf, UINT32 uLen);
Ntypedef BaseType_t(*uartReadWaitFunc)(TickType_t time);
Ntypedef BOOL(*uartSetPowerFunc)(BOOL flag);
Ntypedef INT (*uartIoctlFunc)(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1);
N
N//************************  SPI  ************************//
N#define SPI_INTERFACE_NUM           2
N
N#define SPI_0_INTERFACE_INDEX       0
N#define SPI_1_INTERFACE_INDEX       1
N
N    
Ntypedef BOOL(*spiInitFunc)(void);
Ntypedef void(*spiWriteFunc)(uint8_t buff_id, uint32_t data);
Ntypedef uint32_t(*spiReadFunc)(uint8_t buff_id);
Ntypedef void(*spiActiveCS)(BOOL active);
Ntypedef void(*spiSetPin)(void);
Ntypedef void(*spiResetPin)(void);
N
N//************************  I2C  ************************//
N#define I2C_INTERFACE_NUM           1
N
N#define I2C_1_INTERFACE_INDEX       0
N    
Ntypedef BOOL(*i2cInitFunc)(void);
Ntypedef int32_t(*i2cIoctlFunc)(uint32_t cmd, uint32_t arg0, uint32_t arg1);
Ntypedef int32_t(*i2cReadFunc)(uint8_t* buf, uint32_t len);
Ntypedef int32_t(*i2cWriteFunc)(uint8_t* buf, uint32_t len);
Ntypedef void(*i2cenableCriticalSectionFunc)(BOOL flag);
Ntypedef void(*i2cSetPin)(void);
Ntypedef void(*i2cResetPin)(void);
N
N//************************  KEY  ************************//
N#define KEY_HARDWARE_INTERFACE_NUM               2
N
N#define KEY_HARDWARE_PCF8885_INTERFACE_INDEX     0
N#define KEY_HARDWARE_DIP_INTERFACE_INDEX         1
N    
N#define KEY_HARDWARE_DOWN_EVENT                  0x1
N#define KEY_HARDWARE_UP_EVENT                    0x2
N#define KEY_HARDWARE_ERROR_EVENT                 0xf
N
Ntypedef BOOL(*keyHardwareCallbackFunc)(uint8_t keyId, uint8_t downUp);
N    
Ntypedef BOOL(*keyHardwareInitFunc)(BOOL testModeFlag);
Ntypedef void(*keyHardwareSetCallbackFunc)(keyHardwareCallbackFunc func);
Ntypedef BOOL(*keyHardwareSetPowerFunc)(BOOL powerFlag);
N
N//************************  Distance  ************************//
N#define DIST_INTERFACE_NUM              1
N
N#define DIST_SR04T_INTERFACE_INDEX      0
N
N#define DIST_DEVICE_1  0
N#define DIST_DEVICE_2  1
N    
Ntypedef BOOL(*distInitFunc)(void);
Ntypedef BOOL(*distMeasureDist)(uint8_t id, int* detectResult);
N
N//************************  Storage  ************************//
N#define STORAGE_INTERFACE_NUM              1
N
N#define STORAGE_FLASH_INTERFACE_INDEX       0
N    
Ntypedef BOOL(*storageInitFunc)(void);
Ntypedef BOOL(*storageWrite)(uint8_t *u8DataBuffer, int BuffLen);
Ntypedef BOOL(*storageRead)(uint8_t *u8DataBuffer, int BuffLen);
N
N//************************  Communication  ************************//
N#define COMMUNICATION_INTERFACE_NUM                 2 //1
N
N#define COMMUNICATION_RS232_INTERFACE_INDEX         0
N#define MTP_RS232_INTERFACE_INDEX                   1
N
Ntypedef BOOL(*commInitFunc)(void);
Ntypedef INT32(*commWrite)(PUINT8 pucBuf, UINT32 uLen);
Ntypedef INT32(*commRead)(PUINT8 pucBuf, UINT32 uLen);
Ntypedef BaseType_t(*commReadWaitFunc)(TickType_t time);
N
N//************************  FatFs Hardware  ************************//
N#define FATFS_HARDWARE_INTERFACE_NUM                     3
N
N#define FATFS_HARDWARE_SD_INTERFACE_INDEX                0
N#define FATFS_HARDWARE_SFLASH_0_INTERFACE_INDEX          1
N#define FATFS_HARDWARE_SFLASH_1_INTERFACE_INDEX          2
N
Ntypedef BOOL(*fatfsHwInitFunc)(void);
Ntypedef BOOL(*diskInitialize)(uint8_t pdrv);
Ntypedef BOOL(*diskStatus)(uint8_t pdrv);
Ntypedef BOOL(*diskRead)(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
Ntypedef BOOL(*diskWrite)(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
Ntypedef BOOL(*diskIoctl)(uint8_t pdrv, uint8_t cmd, void *buff );
N
N//************************  Radar  ************************//
N//UT(FpFO})
N//#define RADAR_INTERFACE_NUM                     2//pFq
N//#define RADAR_AV_DESIGN_INTERFACE_INDEX         0//pF(index)
N//#define LIDAR_AV_DESIGN_INTERFACE_INDEX         1//F(index)
N
N#define RADAR_INTERFACE_NUM                     3 //2
N#define RADAR_AV_DESIGN_INTERFACE_INDEX         0
N#define LIDAR_AV_DESIGN_INTERFACE_INDEX         1
N#define NEWRADAR_INTERFACE_INDEX                2
N
N#define LIDAR_FEATURE_OCCUPIED      0x01
N#define LIDAR_FEATURE_VACUUM        0x02
N#define LIDAR_FEATURE_UN_STABLED    0x03
N#define LIDAR_FEATURE_INIT          0x04
N#define LIDAR_FEATURE_IGNORE        0x05
N#define LIDAR_FEATURE_FAIL          0xFF
N
N#define RADAR_FEATURE_OCCUPIED                  0x01
N#define RADAR_FEATURE_OCCUPIED_UN_STABLED       0x02
N#define RADAR_FEATURE_VACUUM                    0x03
N#define RADAR_FEATURE_VACUUM_UN_STABLED         0x04
N#define RADAR_FEATURE_INIT                      0x05
N#define RADAR_FEATURE_IGNORE                    0x06
N
N
N#define RADAR_FEATURE_OCCUPIED_LIDAR_FAIL                  0x31
N#define RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL       0x32
N#define RADAR_FEATURE_VACUUM_LIDAR_FAIL                    0x33
N#define RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL         0x34
N#define RADAR_FEATURE_INIT_LIDAR_FAIL                      0x35
N#define RADAR_FEATURE_IGNORE_LIDAR_FAIL                    0x36
N
N#define RADAR_FEATURE_FAIL                      0xFF
N
N#define RADAR_OCCUPIED_TYPE_POWER_1             0x10
N#define RADAR_OCCUPIED_TYPE_POWER_2             0x11
N#define RADAR_OCCUPIED_TYPE_DISTANCE            0x20
N#define RADAR_VACUUM_TYPE                       0x00
N
N#define RADAR_QUERY_VERSION_OK                  0x50
N#define RADAR_CALIBRATION_OK                    0x51
N
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
N#define VOS_INDEX_0                           0x0
N#define VOS_INDEX_1                           0x1
N
N//spFAPIwq
N#define VOS_FEATURE_OCCUPIED                  0x01
N#define VOS_FEATURE_OCCUPIED_UN_STABLED       0x02
N#define VOS_FEATURE_VACUUM                    0x03
N#define VOS_FEATURE_VACUUM_UN_STABLED         0x04
N#define VOS_FEATURE_INIT                      0x05
N#define VOS_FEATURE_IGNORE                    0x06
N#define VOS_FEATURE_FAIL                      0xFF
N
N#define VOS_OCCUPIED_TYPE_POWER_1             0x10
N#define VOS_OCCUPIED_TYPE_POWER_2             0x11
N#define VOS_OCCUPIED_TYPE_DISTANCE            0x20
N#define VOS_VACUUM_TYPE                       0x00
N
N//0 (from 0xff):TwA  1:sb  2:sb  3:bJw  4:bXw
N#define VOS_OBJECT_MOVING_UNSTABLE            0x00
N#define VOS_OBJECT_MOVING_EXIST               0x01
N#define VOS_OBJECT_MOVING_NON_EXIST           0x02
N#define VOS_OBJECT_MOVING_ENTERING            0x03
N#define VOS_OBJECT_MOVING_LEAVING             0x04
N#define VOS_OBJECT_MOVING_ERROR               0x05
N#endif
N
N
N
N
Ntypedef BOOL(*radarInitialize)(void);
N//typedef int (*radarCheckFeature)(int index, BOOL* changeFlag, void* para1, void* para2);
Ntypedef int (*radarCheckFeature)(int index, BOOL* changeFlag, void* para1, void* para2, void* para3);
Ntypedef void(*radarSetPowerStatusFunc)(int index, BOOL flag);
Ntypedef void(*radarSetPowerFunc)(BOOL flag);
N//m
Ntypedef void(*radarSetStartCalibrate)(int lidarIndex, BOOL flag);
Ntypedef void(*radarSetQueryVersion)(int lidarIndex, BOOL flag);
N
N
Ntypedef void(*radarReadQueryVersion)(int lidarIndex, uint8_t* code1 ,uint8_t* code2, uint8_t* code3, uint8_t* code4);
Ntypedef int(*radarReadQueryVersionString)(int lidarIndex, char* VersionStr);
N
N
Ntypedef int (*radarCalibrateFunc)(int index, BOOL* changeFlag,int* dist1 ,int* dist2,void* para1, void* para2, void* para3);
N
Ntypedef int (*radarReadDistValueFunc)(int index,int* dist);
N
N
Ntypedef int (*radarCaptureEmptyFeature)(int radarIndex);
N//typedef BOOL (*radarSetEmptyFeature)(int radarIndex, pm_feature* feature);
N//typedef BOOL (*radarGetEmptyFeature)(int radarIndex, pm_feature* feature);
Ntypedef BOOL (*radarCheckEmptyFeaturnFunc)(int radarIndex);
N
Ntypedef void(*radarSetPowerExFunc)(int radarIndex, BOOL flag);
N
N
Ntypedef BOOL (*radarFirstOTA)(int radarIndex, int BufferLen);
Ntypedef BOOL (*radarOTA)(int radarIndex, uint8_t* ReadBuffer, int BufferIndex, int ReadBufferLen);
N
Ntypedef BOOL (*radarRecentDistValue)(int radarIndex, uint16_t* lidarDist,  uint16_t* radarDist);
N
Ntypedef int (*radarResult)(int radarIndex, uint8_t radarCmd, uint8_t* CmdBuff, uint8_t* radarData);
N
Ntypedef void(*radarCreateTask)(void);
Ntypedef void(*radarDeleteTask)(void);
N
Ntypedef BOOL (*radarRB60POTA)(int radarIndex);
Ntypedef void (*radarFlush)(int radarIndex);
Ntypedef BOOL (*radarInitBurning)(int radarIndex);
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N//************************  UART  ************************//
Ntypedef struct
N{
N    uartInitFunc        initFunc;
N    uartWriteFunc       writeFunc;
N    uartReadFunc        readFunc;
N    uartReadWaitFunc    readWaitFunc;
N    uartSetPowerFunc    setPowerFunc;
N    uartSetPowerFunc    setRS232PowerFunc;
N    uartIoctlFunc       ioctlFunc;
N}UartInterface;
N
NUartInterface* UartGetInterface(uint8_t index);
N
N//************************  SPI  ************************//
Ntypedef struct
N{
N    spiInitFunc         initFunc;
N    spiWriteFunc        writeFunc;
N    spiReadFunc         readFunc;
N    spiActiveCS         activeCSFunc;
N    spiSetPin           setPin;
N    spiResetPin         resetPin;
N}SpiInterface;
N
NSpiInterface* SpiGetInterface(uint8_t index);
N
N//************************  I2C  ************************//
Ntypedef struct
N{
N    i2cInitFunc         initFunc;
N    i2cIoctlFunc        ioctlFunc;
N    i2cWriteFunc        writeFunc;
N    i2cReadFunc         readFunc;
N    i2cenableCriticalSectionFunc enableCriticalSectionFunc;
N    i2cSetPin           setPin;
N    i2cResetPin         resetPin;    
N}I2cInterface;
N
NI2cInterface* I2cGetInterface(uint8_t index);
N
N//************************  KEY  Hardware************************//
Ntypedef struct
N{
N    keyHardwareInitFunc             initFunc;
N    keyHardwareSetCallbackFunc      setCallbackFunc;
N    keyHardwareSetPowerFunc         setPowerFunc;
N}KeyHardwareInterface;
N
NKeyHardwareInterface* KeyHardwareGetInterface(uint8_t index);
N
N//************************  Distance  ************************//
Ntypedef struct
N{
N    distInitFunc         initFunc;
N    distMeasureDist      measureDistFunc;
N}DistInterface;
N
NDistInterface* DistGetInterface(uint8_t index);
N
N//************************  Storage  ************************//
Ntypedef struct
N{
N    storageInitFunc         initFunc;
N    storageWrite            writeFunc;
N    storageRead             readFunc;
N}StorageInterface;
N
NStorageInterface* StorageGetInterface(uint8_t index);
N
N
N//************************  Communication  ************************//
Ntypedef struct
N{
N    commInitFunc            initFunc;
N    commWrite               writeFunc;
N    commRead                readFunc;
N    commReadWaitFunc        readWaitFunc;
N}CommunicationInterface;
N
NCommunicationInterface* CommunicationGetInterface(uint8_t index);
N
N//************************  FatfsDrv  ************************//
N
Ntypedef struct
N{
N    fatfsHwInitFunc     initFunc;
N    diskInitialize      diskInitFunc;
N    diskStatus          diskStatusFunc;
N    diskRead            diskReadFunc;
N    diskWrite           diskWriteFunc;
N    diskIoctl           diskIoctlFunc;
N    uint16_t            diskSectorSize;
N}FatfsHardwareInterface;
N
NFatfsHardwareInterface* FatfsHardwareGetInterface(uint8_t index);
N
N//************************  Radar  ************************//
N//typedef struct
N//{
N//    radarInitialize             initFunc;
N//    radarCheckFeature           checkFeaturnFunc;
N//    radarSetPowerFunc           setPowerFunc;
N//    radarSetPowerExFunc         setPowerExFunc;
N//}RadarInterface;
N
N//RadarInterface* RadarGetInterface(uint8_t index);
Ntypedef struct
N{
N    radarInitialize             initFunc;
N    radarCheckFeature           checkFeaturnFunc;
N    radarSetPowerFunc           setPowerFunc;
N    radarSetPowerStatusFunc     setPowerStatusFunc;
N    //m
N    radarSetStartCalibrate      setStartCalibrate;
N    radarCalibrateFunc          calibrateFunc; 
N    radarReadDistValueFunc      readDistValueFunc;
N    radarSetQueryVersion        setQueryVersion;
N    radarReadQueryVersion       readQueryVersion;
N    radarReadQueryVersionString readQueryVersionString;
N    radarFirstOTA               FirstOTAFunc;
N    radarOTA                    OTAFunc;
N    radarRecentDistValue        RecentDistValueFunc;
N    radarResult                 RadarResultFunc;
N    radarResult                 RadarResultElite;
N    radarCreateTask             RadarCreateTaskFunc;
N    radarDeleteTask             RadarDeleteTaskFunc;
N    radarRB60POTA               RadarRB60POTAFunc;
N    radarFlush                  RadarFlushFunc;
N    radarInitBurning            RadarinitBurningFunc;
N}RadarInterface;
N
NRadarInterface* RadarGetInterface(uint8_t index);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__INTERFACE_H__
L 17 ".\src\userdrv\buzzerdrv.h" 2
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL BuzzerDrvInit(BOOL testMode);
Nvoid BuzzerPlay(uint32_t time, uint32_t delayTime, uint8_t counter, BOOL blocking);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__BUZZER_DRV_H__
L 27 "src\user\hwtester.c" 2
N#include "timelib.h"
L 1 ".\src\syshal\timelib.h" 1
N/**************************************************************************//**
N* @file     timelib.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __TIME_LIB_H__
N#define __TIME_LIB_H__
N#include <time.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\time.h" 1
N/* time.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.12 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                      */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * time.h declares two macros, four types and several functions for
N * manipulating time. Many functions deal with a calendar time that
N * represents the current date (according to the Gregorian
N * calendar) and time. Some functions deal with local time, which
N * is the calendar time expressed for some specific time zone, and
N * with Daylight Savings Time, which is a temporary change in the
N * algorithm for determining local time.
N */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __time_h
N#define __time_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N  #ifndef __TIME_DECLS
N  #define __TIME_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N    /* CLOCKS_PER_SEC: the number per second of the value returned by the
N     * clock function. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S  extern const int __aeabi_CLOCKS_PER_SEC;
S  #define CLOCKS_PER_SEC (__aeabi_CLOCKS_PER_SEC)
N#else
N  #ifdef __CLK_TCK
S    #define CLOCKS_PER_SEC  __CLK_TCK
N  #else
N    #define CLOCKS_PER_SEC  100
N  #endif
N#endif
N
N#ifndef __STRICT_ANSI__
N  #define CLK_TCK CLOCKS_PER_SEC
N#endif
N
Ntypedef unsigned int clock_t;    /* cpu time type */
Ntypedef unsigned int time_t;     /* date/time in unix secs past 1-Jan-70 */
N
N#pragma push
N#pragma anon_unions
N
Nstruct tm {
N    int tm_sec;   /* seconds after the minute, 0 to 60
N                     (0 - 60 allows for the occasional leap second) */
N    int tm_min;   /* minutes after the hour, 0 to 59 */
N    int tm_hour;  /* hours since midnight, 0 to 23 */
N    int tm_mday;  /* day of the month, 1 to 31 */
N    int tm_mon;   /* months since January, 0 to 11 */
N    int tm_year;  /* years since 1900 */
N    int tm_wday;  /* days since Sunday, 0 to 6 */
N    int tm_yday;  /* days since January 1, 0 to 365 */
N    int tm_isdst; /* Daylight Savings Time flag */
N    union {       /* ABI-required extra fields, in a variety of types */
N        struct {
N            int __extra_1, __extra_2;
N        };
N        struct {
N            long __extra_1_long, __extra_2_long;
N        };
N        struct {
N            char *__extra_1_cptr, *__extra_2_cptr;
N        };
N        struct {
N            void *__extra_1_vptr, *__extra_2_vptr;
N        };
N    };
N};
N
N#pragma pop
N
N   /* struct tm holds the components of a calendar time, called the broken-down
N    * time. The value of tm_isdst is positive if Daylight Savings Time is in
N    * effect, zero if Daylight Savings Time is not in effect, and negative if
N    * the information is not available.
N    */
N
Nextern _ARMABI clock_t clock(void);
Xextern __declspec(__nothrow) clock_t clock(void);
N   /* determines the processor time used.
N    * Returns: the implementation's best approximation to the processor time
N    *          used by the program since program invocation. The time in
N    *          seconds is the value returned divided by the value of the macro
N    *          CLK_TCK. The value (clock_t)-1 is returned if the processor time
N    *          used is not available.
N    */
Nextern _ARMABI double difftime(time_t /*time1*/, time_t /*time0*/);
Xextern __declspec(__nothrow) double difftime(time_t  , time_t  );
N   /*
N    * computes the difference between two calendar times: time1 - time0.
N    * Returns: the difference expressed in seconds as a double.
N    */
Nextern _ARMABI time_t mktime(struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) time_t mktime(struct tm *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the broken-down time, expressed as local time, in the structure
N    * pointed to by timeptr into a calendar time value with the same encoding
N    * as that of the values returned by the time function. The original values
N    * of the tm_wday and tm_yday components of the structure are ignored, and
N    * the original values of the other components are not restricted to the
N    * ranges indicated above. On successful completion, the values of the
N    * tm_wday and tm_yday structure components are set appropriately, and the
N    * other components are set to represent the specified calendar time, but
N    * with their values forced to the ranges indicated above; the final value
N    * of tm_mday is not set until tm_mon and tm_year are determined.
N    * Returns: the specified calendar time encoded as a value of type time_t.
N    *          If the calendar time cannot be represented, the function returns
N    *          the value (time_t)-1.
N    */
Nextern _ARMABI time_t time(time_t * /*timer*/);
Xextern __declspec(__nothrow) time_t time(time_t *  );
N   /*
N    * determines the current calendar time. The encoding of the value is
N    * unspecified.
N    * Returns: the implementations best approximation to the current calendar
N    *          time. The value (time_t)-1 is returned if the calendar time is
N    *          not available. If timer is not a null pointer, the return value
N    *          is also assigned to the object it points to.
N    */
N
Nextern _ARMABI char *asctime(const struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *asctime(const struct tm *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI char *_asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *_asctime_r(const struct tm *  ,
N                                char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *asctime_r(const struct tm *  ,
N                               char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the broken-down time in the structure pointed to by timeptr into
N    * a string in the form "Sun Sep 16 01:03:52 1973\n\0".
N    * Returns: a pointer to the string containing the date and time.
N    */
Nextern _ARMABI char *ctime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *ctime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer to local time in the form
N    * of a string. It is equivalent to asctime(localtime(timer));
N    * Returns: the pointer returned by the asctime function with that
N    *          broken-down time as argument.
N    */
Nextern _ARMABI struct tm *gmtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *gmtime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed as Greenwich Mean Time (GMT).
N    * Returns: a pointer to that object or a null pointer if GMT not available.
N    */
Nextern _ARMABI struct tm *localtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *localtime(const time_t *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI struct tm *_localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *_localtime_r(const time_t * __restrict  ,
N                                       struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI struct tm *localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *localtime_r(const time_t * __restrict  ,
N                                      struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed a local time.
N    * Returns: a pointer to that object.
N    */
Nextern _ARMABI size_t strftime(char * __restrict /*s*/, size_t /*maxsize*/,
Xextern __declspec(__nothrow) size_t strftime(char * __restrict  , size_t  ,
N                       const char * __restrict /*format*/,
N                       const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N   /*
N    * places characters into the array pointed to by s as controlled by the
N    * string pointed to by format. The format string consists of zero or more
N    * directives and ordinary characters. A directive consists of a % character
N    * followed by a character that determines the directive's behaviour. All
N    * ordinary characters (including the terminating null character) are copied
N    * unchanged into the array. No more than maxsize characters are placed into
N    * the array. Each directive is replaced by appropriate characters  as
N    * described in the following list. The appropriate characters are
N    * determined by the LC_TIME category of the current locale and by the
N    * values contained in the structure pointed to by timeptr.
N    * %a is replaced by the locale's abbreviated weekday name.
N    * %A is replaced by the locale's full weekday name.
N    * %b is replaced by the locale's abbreviated month name.
N    * %B is replaced by the locale's full month name.
N    * %c is replaced by the locale's appropriate date and time representation.
N    * %d is replaced by the day of the month as a decimal number (01-31).
N    * %H is replaced by the hour (24-hour clock) as a decimal number (00-23).
N    * %I is replaced by the hour (12-hour clock) as a decimal number (01-12).
N    * %j is replaced by the day of the year as a decimal number (001-366).
N    * %m is replaced by the month as a decimal number (01-12).
N    * %M is replaced by the minute as a decimal number (00-59).
N    * %p is replaced by the locale's equivalent of either AM or PM designations
N    *       associated with a 12-hour clock.
N    * %S is replaced by the second as a decimal number (00-61).
N    * %U is replaced by the week number of the year (Sunday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %w is replaced by the weekday as a decimal number (0(Sunday) - 6).
N    * %W is replaced by the week number of the year (Monday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %x is replaced by the locale's appropriate date representation.
N    * %X is replaced by the locale's appropriate time representation.
N    * %y is replaced by the year without century as a decimal number (00-99).
N    * %Y is replaced by the year with century as a decimal number.
N    * %Z is replaced by the timezone name or abbreviation, or by no characters
N    *       if no time zone is determinable.
N    * %% is replaced by %.
N    * If a directive is not one of the above, the behaviour is undefined.
N    * Returns: If the total number of resulting characters including the
N    *          terminating null character is not more than maxsize, the
N    *          strftime function returns the number of characters placed into
N    *          the array pointed to by s not including the terminating null
N    *          character. otherwise, zero is returned and the contents of the
N    *          array are indeterminate.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __TIME_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __TIME_NO_EXPORTS
S      using ::std::clock_t;
S      using ::std::time_t;
S      using ::std::tm;
S      using ::std::tm;
S      using ::std::clock;
S      using ::std::difftime;
S      using ::std::mktime;
S      using ::std::time;
S      using ::std::asctime;
S      using ::std::_asctime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::asctime_r;
S#endif
S      using ::std::ctime;
S      using ::std::gmtime;
S      using ::std::localtime;
S      using ::std::_localtime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::localtime_r;
S#endif
S      using ::std::strftime;
S      using ::std::size_t;
S    #endif /* __TIME_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of time.h */
N
L 15 ".\src\syshal\timelib.h" 2
N#include "nuc970.h"
N#include "rtc.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N//#include        "loc_time.h"
N#define YEAR0               1900  /* the first year */
N#define EPOCH_YR            1970  /* EPOCH = Jan 1 1970 00:00:00 */
N#define SECS_DAY            (24L * 60L * 60L)
N#define LEAPYEAR(year)      (!((year) % 4) && (((year) % 100) || !((year) % 400)))
N#define YEARSIZE(year)      (LEAPYEAR(year) ? 366 : 365)
N#define FIRSTSUNDAY(timp)    (((timp)->tm_yday - (timp)->tm_wday + 420) % 7)
N#define FIRSTDAYOF(timp)    (((timp)->tm_wday - (timp)->tm_yday + 420) % 7)
N#define TIME_MAX            ULONG_MAX
N#define ABB_LEN 3
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
Ntime_t RTC2Time(RTC_TIME_DATA_T* pt);
NRTC_TIME_DATA_T* Time2RTC(time_t rawtime, RTC_TIME_DATA_T* ppt);
NBOOL RTCAddTime(RTC_TIME_DATA_T* pt, time_t addTime);
Ntime_t RTCAddTimeEx(time_t addTime);
NBOOL SetOSTime(uint32_t u32Year, uint32_t u32cMonth, uint32_t u32cDay, uint32_t u32cHour, uint32_t u32cMinute, uint32_t u32cSecond, uint32_t u32cDayOfWeek);
NBOOL SetOSTimeLite(uint32_t u32Year, uint32_t u32cMonth, uint32_t u32cDay, uint32_t u32cHour, uint32_t u32cMinute, uint32_t u32cSecond);
Ntime_t GetCurrentUTCTime(void);
NBOOL UTCTimeToString(time_t time, char* str);
NBOOL UTCTimeToStringEx(time_t time, char* str);
Nvoid PrintRTC(void);
N#ifdef __cplusplus
S}
N#endif
N
N#endif//__TIME_LIB_H__
L 28 "src\user\hwtester.c" 2
N#include "leddrv.h"
L 1 ".\src\syshal\leddrv.h" 1
N/**************************************************************************//**
N* @file     leddrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __LED_DRV_H__
N#define __LED_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#include "fepconfig.h"
N#include "ledcmdlib.h"
L 1 ".\src\syshal\ledcmdlib.h" 1
N/**************************************************************************//**
N* @file     ledcmdlib.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __LED_CMD_LIB_H__
N#define __LED_CMD_LIB_H__
N
N
N
N
N#ifdef EPM_PROJECT
N    #include <stdio.h>
N    #include <stdlib.h>
N    #include <string.h>
N    #include <time.h>
N    #include "nuc970.h"
N#else
S    #include <stdio.h>
N#endif
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define TOTAL_BAY_LIGHT_NUM     8
N    
N#define NOT_FLASHING_OFF        0x00
N#define NOT_FLASHING_ON         0xff
N#define LED_ON_TIME_10MS        0x01
N#define LED_PERIOD_01MS         0x01
N    
N#define LIGHT_COLOR_OFF         0
N#define LIGHT_COLOR_GREEN       1
N#define LIGHT_COLOR_RED         2
N#define LIGHT_COLOR_YELLOW      3
N#define LIGHT_COLOR_IGNORE	    0xff
N
N#define COMMAND_ERROR            0
N#define COMMAND_LENGTH_ERROR     (-10)
N#define COMMAND_FORMAT_ERROR     (-11)
N
N#define COMMAND_SUCCESSFUL      1
N#define COMMAND_FIAL            (-1)
N
Nuint8_t Bay_light_Command(char* Out_command, uint8_t Buff_LEN,uint8_t Frequency, uint8_t Period);
Nuint8_t Alive_State_light_Command(char* Out_command, uint8_t Buff_LEN, uint8_t Frequency, uint8_t Period);
Nuint8_t State_light_Command(char* Out_command, uint8_t Buff_LEN, uint8_t Frequency, uint8_t Period);
Nuint8_t Light_Color_Command(char* Out_command, uint8_t Buff_LEN, uint8_t Bay[], uint8_t state);
Nuint8_t HeartBeatTimeSet(char* Out_command, uint8_t Buff_LEN, uint8_t DeathMin, uint8_t DeathSec);
Nuint8_t CalibrationSet(char* Out_command, uint8_t Buff_LEN);
Nuint8_t CollisionSet(char* Out_command, uint8_t Buff_LEN,uint8_t bias_degree,uint8_t strength_X,uint8_t strength_Y,uint8_t strength_Z);
Nuint8_t VersionQuery(char* Out_command, uint8_t Buff_LEN);
Nuint8_t CollisionClean(char* Out_command, uint8_t Buff_LEN);
N
Nint8_t FactoryTest(char* Results_Command , uint8_t Command_LEN);
N//int8_t RUN_Results(char* Results_Command , uint8_t Len, short* Command_ID);
Nint8_t RUN_Results(char* Results_Command , uint8_t Command_LEN, short* Command_ID, int* head);
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N//BOOL BaseDrvInit(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__LED_CMD_LIB_H__
L 19 ".\src\syshal\leddrv.h" 2
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N//#define LED_MODE_NORMAL_INDEX       0x01
N//#define LED_MODE_REPLACE_BP_INDEX   0x02
N#if(BUILD_RELEASE_VERSION)
X#if(0)
S    #define LED_HEARTBEAT_SECONDS       (60*5)
N#else    
N    #if(BUILD_PRE_RELEASE_VERSION)
X    #if(0)
S        #define LED_HEARTBEAT_SECONDS       (60*5)
N    #else
N        #define LED_HEARTBEAT_SECONDS       1677 //Max Sec
N    #endif
N    //#define LED_HEARTBEAT_SECONDS       60
N#endif
N/*
N#define LED_RING_BUFFER_SIZE       1024
N    
Ntypedef struct LEDRINGFIFO{
N    char Buff[LED_RING_BUFFER_SIZE];
N    short SaveIndex;
N    short ReadIndex;
N} LEDRingfifoStruct;    
N*/
N    
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL LedDrvInit(BOOL testMode);
NBOOL LedSetStatus(void);
NBOOL LedSetColor(uint8_t* bayColor, uint8_t statusColor, BOOL checkFlag);
N//void LedSetMode(uint8_t mode);
NBOOL LedSendHeartbeat(uint8_t* ret);
NBOOL LedSetAliveStatusLightFlush(uint8_t LED_freq,uint8_t LED_period);
NBOOL LedSetStatusLightFlush(uint8_t LED_freq,uint8_t LED_period);
NBOOL LedSetBayLightFlush(uint8_t LED_freq,uint8_t LED_period);
N
N
N//BOOL MemsCalibrationSet(void);
N
NBOOL MemsCalibrationSet(short* MEMSx,short* MEMSy,short* MEMSz);
N
NBOOL MemsCollisionSet(uint8_t bias_degree,uint8_t strength_X,uint8_t strength_Y,uint8_t strength_Z);
NBOOL MemsCollisionClean(void);
N
N//BOOL MemsGetStatus(uint8_t* status);
NBOOL QueryVersion(uint8_t* VerCode1,uint8_t* VerCode2,uint8_t* VerCode3,uint8_t* YearCode,
N									uint8_t* MonthCode,uint8_t* DayCode,uint8_t* HourCode,uint8_t* MinuteCode);
N							
NBOOL ClrLedInitFlag(void);                            
NBOOL LedSendFactoryTest(void);
Nvoid LedSetPower(BOOL flag);
N
NBOOL QueryMEMSValue(short* MEMSx,short* MEMSy,short* MEMSz);
Nvoid QueryMEMSValueEx(short* MEMSx,short* MEMSy,short* MEMSz);
N
NBOOL LedReadShake(uint8_t* ret);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__LED_DRV_H__
L 29 "src\user\hwtester.c" 2
N#include "flashdrvex.h"
L 1 ".\src\userdrv\flashdrvex.h" 1
N/**************************************************************************//**
N* @file     flashdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __FLASH_DRV_EX_H__
N#define __FLASH_DRV_EX_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N//page 256 bytes    (program/write uint)
N//sector 4K bytes = 16 pages (erase unit)
N//block 32k/64k = 8/16 sectors
N//64Mb = 8MB = 2048 sectors = 32768 pages // half: 16384 pages = 8192 record
N
N#define SPI_FLASH_EX_TOTAL_SIZE            (8*1024*1024)
N#define SPI_FLASH_EX_PAGE_SIZE             256
N#define SPI_FLASH_EX_SECTOR_SIZE           (4*1024)
N#define SPI_FLASH_EX_PAGE_NUM_PER_SECTOR   (SPI_FLASH_EX_SECTOR_SIZE / SPI_FLASH_EX_PAGE_SIZE)//16
N// |----------------------- 8MB -------------------|
N// |---  RAW:3MB  --|----------  FS:5MB   ---------|
N
N//=============
N//use it to set serial-record size.
N#define SPI_FLASH_EX_RAW_START_ADDRESS      0
N//#define SPI_FLASH_EX_RAW_START_ADDRESS      SPI_FLASH_EX_SECTOR_SIZE//0
N#define SPI_FLASH_EX_RAW_START_PAGE         (SPI_FLASH_EX_RAW_START_ADDRESS/SPI_FLASH_EX_PAGE_SIZE)  // 0
N#define SPI_FLASH_EX_RAW_START_SECTOR       (SPI_FLASH_EX_RAW_START_ADDRESS/SPI_FLASH_EX_SECTOR_SIZE)  //0
N#define SPI_FLASH_EX_RAW_END_PAGE           (SPI_FLASH_EX_FS_START_PAGE - 1)
N#define SPI_FLASH_EX_RAW_END_SECTOR         (SPI_FLASH_EX_FS_START_SECTOR - 1)
N#define SPI_FLASH_EX_RAW_PAGE_SIZE          (SPI_FLASH_EX_RAW_END_PAGE - SPI_FLASH_EX_RAW_START_PAGE + 1)
N#define SPI_FLASH_EX_RAW_SECTOR_SIZE        (SPI_FLASH_EX_RAW_END_SECTOR - SPI_FLASH_EX_RAW_START_SECTOR + 1)
N    
N//=============
N//use it to set file system size.
N//#define SPI_FLASH_EX_FS_TOTAL_SIZE         (4*1024*1024)   //4MB
N#define SPI_FLASH_EX_FS_TOTAL_SIZE         (5*1024*1024)   //5MB
N//#define SPI_FLASH_EX_FS_TOTAL_SIZE         (8*1024*1024)  //8MB
N//------------
N#define SPI_FLASH_EX_FS_START_ADDRESS       (SPI_FLASH_EX_TOTAL_SIZE - SPI_FLASH_EX_FS_TOTAL_SIZE)
N//#define SPI_FLASH_EX_FS_START_ADDRESS       0
N#define SPI_FLASH_EX_FS_START_PAGE          (SPI_FLASH_EX_FS_START_ADDRESS/SPI_FLASH_EX_PAGE_SIZE)
N#define SPI_FLASH_EX_FS_START_SECTOR        (SPI_FLASH_EX_FS_START_ADDRESS/SPI_FLASH_EX_SECTOR_SIZE)
N#define SPI_FLASH_EX_FS_END_PAGE            (SPI_FLASH_EX_FS_START_PAGE + SPI_FLASH_EX_FS_TOTAL_SIZE/SPI_FLASH_EX_PAGE_SIZE)
N#define SPI_FLASH_EX_FS_END_SECTOR          (SPI_FLASH_EX_FS_START_SECTOR + SPI_FLASH_EX_FS_TOTAL_SIZE/SPI_FLASH_EX_SECTOR_SIZE)
N
N
N    
N
N#define SPI_FLASH_EX_0_INDEX  1
N#define SPI_FLASH_EX_1_INDEX  2
N
N#define SPI_FLASH_EX_2_INDEX  3
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL FlashDrvExInit(BOOL testModeFlag);
N
NBOOL FlashDrvExInitialize(uint8_t pdrv);
NBOOL FlashDrvExStatus(uint8_t pdrv);
NBOOL FlashDrvExRead(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
NBOOL FlashDrvExWrite(uint8_t pdrv, uint8_t *buff, uint32_t sector, UINT count);
NBOOL FlashDrvExIoctl(uint8_t pdrv, uint8_t cmd, void *buff );
Nvoid FlashDrvExChipEraseFs(uint8_t flashIndex);
Nvoid FlashDrvExChipEraseFull(uint8_t flashIndex);
Nvoid FlashDrvExChipErasePure(uint8_t flashIndex, int startSector, int endSector);
Nuint16_t FlashDrvExGetChipID(uint8_t flashIndex);
N
Nvoid FlashDrvPageProgram(uint8_t flashIndex, uint32_t StartAddress, uint8_t *u8DataBuffer, int BuffLen);
Nvoid FlashDrvSectorErase(uint8_t flashIndex, uint32_t StartAddress);
Nvoid FlashDrvNormalRead(uint8_t flashIndex, uint32_t StartAddress, uint8_t *u8DataBuffer, int BuffLen);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__FLASH_DRV_EX_H__
L 30 "src\user\hwtester.c" 2
N#include "epddrv.h"
L 1 ".\src\syshal\epddrv.h" 1
N/**************************************************************************//**
N* @file     epddrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __EPD_DRV_H__
N#define __EPD_DRV_H__
N#include <time.h>
N#include "nuc970.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
Ntypedef unsigned char TByte; //1 byte
Ntypedef unsigned short TWord; //2 bytes
Ntypedef unsigned long TDWord; //4 bytes
N//structure prototype 3
N//See user defined command ?Get Device information (0x0302)
Ntypedef struct
N{
N    TWord usPanelW;
N    TWord usPanelH;
N    TWord usImgBufAddrL;
N    TWord usImgBufAddrH;
N    TWord usFWVersion[8]; //16 Bytes String
N    TWord usLUTVersion[8]; //16 Bytes String
N    
N}I80IT8951DevInfo;
Ntypedef void(*guiUpdateMsgFunc)(void);
Ntypedef struct
N{
N    char responeChar;
N    int whiteItemName;
N    int blackItemName;
N}ItemIndex;
N
Ntypedef enum{
N    EPD_PICT_ALL_WHITE_INDEX = 3,
N    EPD_PICT_ALL_BLACK_INDEX = 4,      
N    
N    EPD_PICT_PIXEL_4_INDEX = 5, 
N    
N    EPD_PICT_INDEX_INIT = 6,
N    EPD_PICT_INDEX_FILE_DOWNLOADING = 7,
N    EPD_PICT_INDEX_INIT_FAIL = 8,  
N
N    EPD_PICT_NUM_SMALL_INDEX = 9,
N    EPD_PICT_X_SMALL_INDEX = 25,
N    EPD_PICT_COLON_SMALL_INDEX = 26,
N    
N    EPD_PICT_DEPOSIT_FAILE_ERROR_CODE_INDEX = 27,
N    EPD_PICT_DEPOSIT_FAILE_ECC_INDEX = 28,
N    EPD_PICT_DEPOSIT_FAILE_FAILURE_INDEX = 29,
N    EPD_PICT_DEPOSIT_FAILE_CANT_USE_INDEX = 30,
N    EPD_PICT_DEPOSIT_FAILE_INSUFFOCOENT_MONEY_INDEX = 31,
N    EPD_PICT_PAYMENT_QRCODE_UNCHECK_INDEX = 32,
N    EPD_PICT_PAYMENT_QRCODE_CHECKED_INDEX = 33,
N    EPD_PICT_PAYMENT_CARD_UNCHECK_INDEX = 34,
N    EPD_PICT_PAYMENT_CARD_CHECKED_INDEX = 35,
N   
N    EPD_PICT_NUM_BIG_INDEX = 42,
N    EPD_PICT_COLON_BIG_INDEX = 52,
N    EPD_PICT_LINE_BIG_INDEX = 53,  
N    EPD_PICT_POINT_BIG_INDEX = 54,    
N    
N    EPD_PICT_NUM_BIG_I_INDEX = 55,
N    EPD_PICT_COLON_BIG_I_INDEX = 65,
N    EPD_PICT_LINE_BIG_I_INDEX = 66, 
N    EPD_PICT_POINT_BIG_I_INDEX = 67,  
N    EPD_PICT_POINT_TRAILVER_INDEX = 68, 
N    
N    EPD_PICT_NUM_SMALL_2_INDEX = 81,
N    EPD_PICT_COLON_SMALL_2_INDEX = 91,
N    EPD_PICT_LINE_SMALL_2_INDEX = 92, 
N    EPD_PICT_SLASH_SMALL_2_INDEX = 93,
N    EPD_PICT_POINT_SMALL_2_INDEX = 94, 
N    EPD_PICT_V_SMALL_2_INDEX = 95,
N    
N    EPD_PICT_NUM_SMALL_2_I_INDEX = 96,
N    EPD_PICT_COLON_SMALL_2_I_INDEX = 106,
N    EPD_PICT_LINE_SMALL_2_I_INDEX = 107, 
N    EPD_PICT_SLASH_SMALL_2_I_INDEX = 108,
N    EPD_PICT_POINT_SMALL_2_I_INDEX = 109, 
N    EPD_PICT_V_SMALL_2_I_INDEX = 110,
N
N    EPD_PICT_CAR1_INDEX = 120, 
N    
N    EPD_PICT_INDEX_ISSUED_W = 122,
N    EPD_PICT_INDEX_ISSUED_B = 123,
N    EPD_PICT_BIG_CAST_BG_INDEX = 124,
N    
N    EPD_PICT_CAR1_I_INDEX = 126,
N    EPD_PICT_METER_INDEX = 132,
N    EPD_PICT_UPPER_LINE_INDEX = 133,
N    EPD_PICT_SIGNAL_INDEX = 134,
N    EPD_PICT_SIGNAL_BG_INDEX = 135,
N    
N    EPD_PICT_DISABLE_PARKING_INDEX = 136,
N    EPD_PICT_DISABLE_PARKING_E_INDEX = 137,
N    
N    EPD_PICT_CONTAIN_CLEAR_INDEX = 138,    
N    EPD_PICT_CONTAIN_SELECT_TIME_INDEX = 139,    
N    EPD_PICT_SMALL_CAST_BG_INDEX = 140,
N    EPD_PICT_CONTAIN_DEPOSIT_INDEX = 141,
N    EPD_PICT_EPD_VERSION_INDEX = 142,
N    EPD_PICT_CONTAIN_LINEPAY_INDEX = 143,
N    EPD_PICT_CONTAIN_LINEPAY_IN_PROGRESS_INDEX = 144,
N    EPD_PICT_CONTAIN_SELECT_MOBILE_INDEX = 145,
N    EPD_PICT_CONTAIN_READER_INIT_INDEX = 146,    
N    EPD_PICT_CONTAIN_READER_INIT_FAIL_INDEX = 147,    
N    EPD_PICT_CONTAIN_SEL_PAYMENT_INDEX = 148,    
N    EPD_PICT_CONTAIN_DEPOSIT_OK_INDEX = 149,    
N    EPD_PICT_CONTAIN_DEPOSIT_FAIL_INDEX = 150,   
N    EPD_PICT_CONTAIN_SCAN2PAY_INDEX = 151, 
N    EPD_PICT_CONTAIN_MOBILE_PAY_OK_INDEX = 152, 
N
N    EPD_PICT_CONTAIN_INDEX_BATTERY_REPLACE = 153,  
N    EPD_PICT_INDEX_BATTERY_REPLACE_INUSE = 154,  
N    EPD_PICT_INDEX_BATTERY_REPLACE_NEED_REPLACE = 155,  
N    EPD_PICT_INDEX_BATTERY_REPLACE_IDLE = 156,  
N    EPD_PICT_INDEX_BATTERY_REPLACE_EMPTY = 157,  
N    
N    EPD_PICT_CONTAIN_INDEX_TESTER_KEYPAD = 158, 
N    EPD_PICT_CONTAIN_INDEX_TESTER = 159,  
N    
N    //EPD_PICT_CONTAIN_BG_6_5_INDEX = 160,
N    //EPD_PICT_CONTAIN_BG_4_INDEX = 161,
N    //EPD_PICT_CONTAIN_BG_4_3_INDEX = 162,
N    EPD_PICT_CONTAIN_BG_2_INDEX = 163,
N//    EPD_PICT_CONTAIN_BG_2_1_INDEX = 164,
N    //EPD_PICT_BOARD_4_L_INDEX = 165,
N    //EPD_PICT_BOARD_4_R_INDEX = 166,
N    //EPD_PICT_BOARD_4_I_L_INDEX = 167,
N    //EPD_PICT_BOARD_4_I_R_INDEX = 168,
N    EPD_PICT_BOARD_2_L_INDEX = 169,
N    EPD_PICT_BOARD_2_R_INDEX = 170,
N    EPD_PICT_BOARD_2_I_L_INDEX = 171,
N    EPD_PICT_BOARD_2_I_R_INDEX = 172,
N    
N    EPD_PICT_INDEX_EXPIRED_BG = 173,
N    EPD_PICT_INDEX_EXPIRED_W = 174,
N    EPD_PICT_INDEX_EXPIRED_B = 175,
N    EPD_PICT_INDEX_FREE     = 177,
N    EPD_PICT_INDEX_OFF_2      = 178,
N    EPD_PICT_CONTAIN_DEPOSIT_2_INDEX = 179,      
N
N    EDP_PICT_LINE_H     = 180,
N    EDP_PICT_LINE_V     = 181,
N    /////UPPER//////
N    EPD_PICT_UPPER_A        = 182,
N    
N    EPD_PICT_0X21_24        = 208,
N    EPD_PICT_0X22_24        = 209,
N    EPD_PICT_0X23_24        = 210,
N    EPD_PICT_EMPTY          = 211,
N    EPD_PICT_LOADING        = 212,
N    /////LOWER//////
N    EPD_PICT_LOWER_A        = 213,
N    /////KEY////////
N    EPD_PICT_KEY_CLEAN_BAR  = 239,
N    EPD_PICT_KEY_CONFIRM    = 240,
N    EPD_PICT_KEY_LEFT       = 241,
N    EPD_PICT_KEY_MINUS      = 242,
N    EPD_PICT_KEY_PLUS       = 243,
N    EPD_PICT_KEY_RIGHT      = 244,
N    EPD_PICT_KEY_CROSS      = 245,
N    EPD_PICT_KEY_CARD       = 246,
N    EPD_PICT_KEY_CARD2      = 247,
N    EPD_PICT_KEY_QRCODE     = 248,
N    EPD_PICT_KEY_ONE        = 249,
N    EPD_PICT_KEY_TWO        = 250,
N    EPD_PICT_KEY_THREE      = 251,
N    EPD_PICT_KEY_FOUR       = 252,
N    EPD_PICT_KEY_FIVE       = 253,
N    EPD_PICT_KEY_SIX        = 254,
N    
N    EPD_PICT_SMALL2_UPPER_A_INDEX = 255,
N    EPD_PICT_SMALL2_UPPER_0_INDEX = 281,
N    
N    EPD_PICT_INDEX_NULL      = 0xffff,
N    
N}epdPictIndex; 
N/*  Keypad Icon Char Defination */
N#define KEYPAD_ONE_CHAR '<'
N#define KEYPAD_TWO_CHAR '>'
N#define KEYPAD_THREE_CHAR '+'
N#define KEYPAD_FOUR_CHAR  '='
N#define KEYPAD_FIVE_CHAR  '{'
N#define KEYPAD_SIX_CHAR   '}'
N
N
N#define KEYPAD_REAL_PLUS_CHAR   0xD3
N
N#define EPD_FONT_TYPE_SMALL     0x01
N#define EPD_FONT_TYPE_SMALL_2   0x02
N#define EPD_FONT_TYPE_MEDIUM    0x03
N#define EPD_FONT_TYPE_BIG       0x04
N#define EPD_FONT_TYPE_DEBUG     0x05
N
N#define CAR_ITEM_MAX_NUM    6
N#define BANNER_ITEM_NUM    (CAR_ITEM_MAX_NUM + 1)
N
N#define DEPOSIT_TIME_DIGITAL_NUM          4//5
N
N#define DEVICE_ID_DIGITAL_NUM          8
N
N#define MAX_LOAD_IMG    32
N
N#define SPI_FLASH_EX_PAGE_SIZE   256
N
N#pragma pack(1)
Ntypedef struct
N{
N    unsigned int        bmpId;
N    unsigned int        xPos;
N    unsigned int        yPos;
N    
N}positionInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[DEVICE_ID_DIGITAL_NUM]; 
X    positionInfo info[8]; 
N}positionDeviceIDInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info;   
N}positionSingleInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[32];   
N}positionStringInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[MAX_LOAD_IMG];   
X    positionInfo info[32];   
N}positionMultiInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[6]; //(car board, number)*2  
N}positionItemInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[BANNER_ITEM_NUM + CAR_ITEM_MAX_NUM*2 + 1];
X    positionInfo info[(6 + 1) + 6*2 + 1];
N}positionAllItemInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[BANNER_ITEM_NUM + 1];   
X    positionInfo info[(6 + 1) + 1];   
N}bannerLinePositionInfo;
N
Ntypedef struct
N{
N    unsigned int carEnableNum;
N    positionInfo info[BANNER_ITEM_NUM];   
X    positionInfo info[(6 + 1)];   
N}bannerPositionInfo;
N
Ntypedef struct
N{
N    unsigned int boardEnableNum;
N    positionInfo info[CAR_ITEM_MAX_NUM];   
X    positionInfo info[6];   
N}containPositionInfo;
N
Ntypedef struct
N{
N    unsigned int depositTimeEnableNum;
N    positionInfo info[2*DEPOSIT_TIME_DIGITAL_NUM];   
X    positionInfo info[2*4];   
N}depositTimePositionInfo;
N
Ntypedef struct
N{
N    unsigned int depositTimeEnableNum;
N    positionInfo info[CAR_ITEM_MAX_NUM*DEPOSIT_TIME_DIGITAL_NUM];   
X    positionInfo info[6*4];   
N}depositTimeAllPositionInfo;
N
Ntypedef struct
N{
N    unsigned int itemNum;
N    positionInfo info[20];   
N}positionTmpInfo;
N
Ntypedef struct
N{
N    uint8_t id[5];   
N}timeIdInfo;
N#define MAX_COST_POSITION  4
Ntypedef struct
N{
N    uint8_t id[MAX_COST_POSITION];   //9999
X    uint8_t id[4];   
N}costIdInfo;
N
N#pragma pack()
N
Ntypedef void(*epdReinitCallbackFunc)(void);
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL EpdDrvInit(BOOL testModeFlag);
Nvoid EPDSetBacklight(BOOL flag);
NBOOL EPDGetBacklight(void);
Nvoid EPDReSetBacklightTimeout(time_t time);
Nvoid EPDSetReinitCallbackFunc(epdReinitCallbackFunc callback);
Nvoid EPDSetSleepFunction(BOOL flag);
Nvoid EPDDrawDeviceId(BOOL reFreshFlag);
Nvoid EPDShowBGScreen(int id, BOOL reFreshFlag);
Nvoid EPDShowErrorID(uint16_t id);
Nvoid ShowExpired(uint8_t id, BOOL leftShow, BOOL rightShow, BOOL reFreshFlag);
N
Nvoid EPDDrawBanner(BOOL reFreshFlag);
Nvoid EPDDrawContain(BOOL reFreshFlag);
Nvoid EPDDrawUpperLine(BOOL reFreshFlag);
Nvoid EPDDrawBannerLine(BOOL reFreshFlag);
N
Nvoid UpdateClock(BOOL reFreshFlag, BOOL checkFlag);
NBOOL calculatePreparePositionInfo(uint8_t meterPosition, uint8_t carEnableNumber);
Nvoid calculateDeviceIDPositionInfo(int32_t id);
N
NBOOL calculateAllItemInfo(void);
Nvoid EPDDrawContainBG(BOOL reFreshFlag);
Nvoid EPDDrawCar(BOOL reFreshFlag, uint8_t selectCarId, BOOL inverseFlag);
Nvoid EPDDrawBoard(BOOL reFreshFlag, uint8_t selectCarId, BOOL inverseFlag);
Nvoid EPDDrawItem(BOOL reFreshFlag, uint8_t oriSelectCarId, uint8_t selectCarId);
Nvoid EPDDrawAllItem(BOOL reFreshFlag);
Nvoid EPDDrawAllDepositTime(BOOL reFreshFlag);
Nvoid EPDDrawDepositTime(BOOL reFreshFlag, uint8_t oriSelectItemId, uint8_t selectItemId);
Nvoid EPDDrawAllScreen(BOOL reFreshFlag);
Nvoid EPDDrawPleaseWait(BOOL reFreshFlag, BOOL clearFlag);
Nvoid EPDDrawContainSelTime(BOOL reFreshFlag);
Nvoid EPDDrawContainClear(BOOL reFreshFlag);
Nvoid EPDDrawTime(BOOL reFreshFlag, time_t time);
Nvoid EPDDrawCost(BOOL reFreshFlag, uint32_t cost);
Nvoid EPDDrawContainByID(BOOL reFreshFlag, uint8_t id);
NBOOL getIDFromTime(time_t time, timeIdInfo* info);
Nvoid SetDepositTimeBmpIdInfo(uint8_t index, time_t time);
N
Nvoid ShowBatteryStatus(uint8_t leftId, BOOL leftShow, uint8_t rightId, BOOL rightShow, BOOL reFreshFlag);
Nvoid ShowVoltage(time_t leftVoltage, BOOL leftShow, time_t rightVoltage, BOOL rightShow, BOOL reFreshFlag);
N
Nvoid setTotalPower(BOOL flag);
N//////////custom function//////////
Nvoid EPDDrawContainByIDPos(BOOL reFreshFlag, uint8_t id,unsigned int x_Pos,unsigned int y_Pos);
Nint  EPDDrawString(BOOL rowrefresh,char* string,unsigned int x_init_Pos,unsigned int y_init_Pos);
Nvoid EPDDrawStringMax(BOOL refresh,char* string,unsigned int x_Pos,unsigned int y_Pos,BOOL load);
Nvoid EPDDrawMulti(BOOL reFreshFlag, uint8_t id,unsigned int x_Pos,unsigned int y_Pos);
NBOOL ReadIT8951SystemInfoLite(char* readFWVersion,char* readLUTVersion);
NBOOL ReadIT8951SystemInfo(char* readFWVersion,char* readLUTVersion);
N
NBOOL EPDIT8951Test(void);
N
Nvoid W25Q64BVquery(int temposition);
Nvoid W25Q64BVqueryEx(int temposition,uint8_t *u8DataBuffer,int size);
Nvoid W25Q64BVErase(void);
Nvoid W25Q64BVBurn(uint32_t StartAddress, uint8_t *u8DataBuffer, int BuffLen);
N
NBOOL SpiFlash_WaitEraseReady(void);
N
NBOOL readEPDswitch(void);
Nvoid toggleEPDswitch(BOOL toggleEPDflag);
N
N
N
Nvoid IT8951WriteReg(uint16_t usRegAddr,uint16_t usValue);
N
Nuint16_t IT8951GetVCOM(void);
Nvoid IT8951SetVCOM(uint16_t vcom);
N
N
Nvoid setSpecialCleanFlag(BOOL flag);
N
N
Nvoid setdataCode(uint32_t buildDataCode);
Nuint32_t getdataCode(void);
N
Nuint8_t getflashvalue(int position);
N
Nvoid W25Q64BVdeviceID(void);
N
Nvoid setW25Q64BVspecialburn(void);
N
Nvoid clrW25Q64BVspecialburn(void);
N
Nvoid EPDShowBGScreenEx(int id, BOOL reFreshFlag,TWord usW, TWord usH);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EPD_DRV_H__
L 31 "src\user\hwtester.c" 2
N#include "cardreader.h"
L 1 ".\src\syshal\cardreader.h" 1
N/**************************************************************************//**
N* @file     cardreader.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __CARD_READER_H__
N#define __CARD_READER_H__
N
N#include "nuc970.h"
N#include "rtc.h"
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N
N#include "halinterface.h"
N#include "epmreader.h"
L 1 ".\src\syshal\cardlib\epmreader.h" 1
N/**************************************************************************//**
N* @file     epmreader.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef _EPM_READER
N#define _EPM_READER
N
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N
N#ifdef _PC_ENV_
S    #include "basetype.h"
N#else
N    #include "nuc970.h"
N#endif
N
N#include "halinterface.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define CARD_TYPE_ID_NONE                           0x00
N#define CARD_TYPE_ID_IPASS                          0x01
N#define CARD_TYPE_ID_ECC                            0x02
N
N#define CARD_MESSAGE_TYPE_CN                        0x01  
N#define CARD_MESSAGE_TYPE_TIME                      0x02
N#define CARD_MESSAGE_TYPE_API_VER_NO                0x03
N#define CARD_MESSAGE_TYPE_READER_ID                 0x04
N
N//(returnCode)    
N#define CARD_MESSAGE_CODE_NO_USE                    0xff
N
N//(returnInfo) common return value 
N#define CARD_MESSAGE_RETURN_TIMEOUT                     0x01
N#define CARD_MESSAGE_RETURN_SUCCESS                     0x02
N#define CARD_MESSAGE_RETURN_PARSER_ERROR                0x03
N#define CARD_MESSAGE_RETURN_SEND_ERROR                  0x04
N#define CARD_MESSAGE_RETURN_OTHER_ERROR                 0x05
N
N
N#define CARD_MESSAGE_TYPE_CN_RETURN_LEN_1                0x11
N#define CARD_MESSAGE_TYPE_CN_RETURN_NOT_SUPPORT_CARDTYPE 0x12
N#define CARD_MESSAGE_TYPE_CN_RETURN_UNKNOWN_CARDTYPE     0x13
N
N#define CARD_MESSAGE_TYPE_IPASS_RETURN_BASE				 0x20
N#define CARD_MESSAGE_TYPE_ECC_RETURN_BASE				 0x30  
N
N
N#define EPM_READER_CTRL_ID_GUI      0 
N//#define EPM_READER_CTRL_ID_MODEM    1 
N//#define EPM_READER_CTRL_NUMBER      (EPM_READER_CTRL_ID_MODEM + 1)
N
N//typedef struct
N//{
N//   BOOL         onOffFlag;
N//}EpmReaderCtrl;
N
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL EPMReaderInit(void);
NBOOL EPMReaderSetPower(uint8_t id, BOOL flag);
Nuint8_t EPMReaderCheckReader(void);
NBOOL EPMReaderBreakCheckReader(void);
N
Nuint32_t EPMReaderSendCmd(uint8_t buff[], int len);
Nint EPMReaderReceiveCmd(uint32_t waitTime, uint8_t** receiveData, uint16_t* dataLen);
Nuint16_t EPMReaderParserMessage(uint8_t msgType, uint8_t* msgBuff, uint16_t msgLen, uint16_t* returnCode);
N
NBOOL EPMReaderProcess(uint16_t targetDeduct, tsreaderDepositResultCallback callback);
NBOOL EPMReaderProcessCN(tsreaderCNResultCallback callback);
NBOOL EPMReaderGetBootedStatus(void);
NBOOL EPMReaderGetBootedStatusEx(void);
N
NBOOL EPMReaderSignOnProcess(void);
Nvoid EPMReaderSaveFile(RTC_TIME_DATA_T pt, uint16_t paraValue);
Nvoid EPMReaderSaveFilePure(void);
Nvoid EPMReaderFlushBuffer(void);
Nchar EPMReaderLRC(uint8_t *array,int start,int len);
Nvoid EPMReaderGetVersion(char* ReaderVerBuf);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //_EPM_READER
L 25 ".\src\syshal\cardreader.h" 2
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL CardReaderInit(BOOL testModeFlag);
Nint CardReaderGetBootedStatus(void);
N//void CardReaderStartInit(void);
N//void CardReaderStopInit(void);
Nvoid CardReaderSetPower(uint8_t id, BOOL flag);
NBOOL CardReaderProcess(uint16_t targetDeduct, tsreaderDepositResultCallback callback);
NBOOL CardReaderProcessCN(tsreaderCNResultCallback callback);
NBOOL CardReaderSignOnProcess(void);
Nvoid CardReaderSaveFile(RTC_TIME_DATA_T pt, uint16_t paraValue);
Nvoid CardReaderEnterCS(void);
Nvoid CardReaderExitCS(void);
Nvoid SetReaderInterconnectFlag(BOOL Flag);
NBOOL ReaderInterconnectResult(void);
N
NBOOL CardReaderCheckHangUpEnable(void);
Nvoid InitCardReaderHangUpStatus(void);
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
Nuint32_t GetCardReaderBurninTestCounter(void);
Nuint32_t GetCardReaderBurninTestErrorCounter(void);
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CARD_READER_H__
L 32 "src\user\hwtester.c" 2
N#include "nt066edrv.h"
L 1 ".\src\userdrv\nt066edrv.h" 1
N/**************************************************************************//**
N* @file     nt066edrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __NT066E_DRV_H__
N#define __NT066E_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL NT066EDrvInit(BOOL testModeFlag);
Nvoid NT066ESetCallbackFunc(keyHardwareCallbackFunc func);
NBOOL NT066EResetChip(void);  
NBOOL NT066ESetPower(BOOL flag);   
NBOOL NT066ESetTriggerLevel(int level);    
N    
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
Nuint32_t GetNT066EBurninTestCounter(void);
Nuint32_t GetNT066EBurninTestErrorCounter(void);
N#endif    
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__NT066E_DRV_H__
L 33 "src\user\hwtester.c" 2
N#include "pct08drv.h"
L 1 ".\src\syshal\pct08drv.h" 1
N/**************************************************************************//**
N* @file     pct08drv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __PCT08_DRV_H__
N#define __PCT08_DRV_H__
N
N#include "nuc970.h"
N#include "halinterface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL PCT08DrvInit(BOOL testModeFlag);
Nvoid PCT08FlushTxRx(void);
Nvoid PCT08SetPower(BOOL flag);
NINT32 PCT08Read(PUINT8 pucBuf, UINT32 uLen);
NINT32 PCT08Write(PUINT8 pucBuf, UINT32 uLen);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PCT08_DRV_H__
L 34 "src\user\hwtester.c" 2
N#include "pct08cmdlib.h"
L 1 ".\src\syshal\pct08cmdlib.h" 1
N/*
N * To change this license header, choose License Headers in Project Properties.
N * To change this template file, choose Tools | Templates
N * and open the template in the editor.
N */
N
N/* 
N * File:   pct08cmdlib.h
N * Author: Sam Chang
N *
N * Created on 2017125,  4:55
N */
N
N#ifndef PCT08CMDLIB_H
N#define PCT08CMDLIB_H
N
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N#include "nuc970.h"
N#include "sys.h"
N
N#include "fileagent.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
NBOOL PCT08TakePhoto(uint8_t** photoPr, int* photoLen, StorageType type, char* dir, char* fileName);
NBOOL PCT08ReadVerInfo(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PCT08CMDLIB_H */
N
L 35 "src\user\hwtester.c" 2
N#include "quentelmodemlib.h"
L 1 ".\src\syshal\modemlib\quentelmodemlib.h" 1
N/**************************************************************************//**
N* @file     quentelmodemlib.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __QUENTEL_MODEM_LIB_H__
N#define __QUENTEL_MODEM_LIB_H__
N
N#include <stdio.h>
N#include <string.h>
N#include "stdlib.h"
N#include "stdint.h"   
N#include "nuc970.h"
N
N#include "atcmdparser.h"
L 1 ".\src\syshal\modemlib\atcmdparser.h" 1
N/**************************************************************************//**
N* @file     atcmdparser.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __AT_CMD_PARSER_H__
N#define __AT_CMD_PARSER_H__
N#include "stdlib.h"
N#include "stdio.h"
N#include "stdint.h"
N#include <nuc970.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define CHECK_AT_TEST_CMD          "AT\r\n"
N#define CHECK_AT_TEST_VER_CMD      "AT+GMR\r\n"
N#define SLEEP_CMD                  "AT+QSCLK=1\r\n"
N#define QURCCFG_CMD                  "AT+QURCCFG=\"urcport\",\"uart1\"\r\n" 
N#define CFUN_CMD                   "AT+CFUN?\r\n"
N    
N#define QUERY_SIM_INIT_STATUS_CMD  "AT+QINISTAT\r\n" 
N    
N#define AUTOMATIC_TIME_ZONE_UPDATE_W_CMD    "AT+CTZR=1\r\n" 
N#define AUTOMATIC_TIME_ZONE_UPDATE_R_CMD    "AT+CTZU?\r\n"  //"AT+CCLK?\r\n"
N#define QUERY_TIME_ZONE_W_CMD               "AT+CTZR=2\r\n" 
N#define QUERY_TIME_ZONE_R_CMD               "AT+CTZR?\r\n" 
N    
N#define QUERY_NETWORK_TIME_CMD              "AT+QLTS=2\r\n" 
N    
N    
N#if(ENABLE_MODEM_FLOW_CONTROL)
X#if(0)
S    #define CHECK_FLOW_CTL_ON_CMD       "AT+IFC=2,2\r\n"
N#else
N    #define CHECK_FLOW_CTL_ON_CMD       "AT+IFC=0,0\r\n"
N#endif
N#define CHECK_ECHO_OFF_CMD          "ATE0\r\n"
N    
N#define CHECK_EXIST_CMD             "AT+CPIN?\r\n"
N#define CHECK_PIN_CMD              "AT+CPIN=0000\r\n"  //"AT+CPIN=1234\r\n"
N#define CHECK_REG_CMD               "AT+CREG?\r\n"
N    
N#define CHECK_SIM_NUM_CMD               "AT+CIMI\r\n"    
N    
N//#define CHECK_OPS_CMD               "AT+COPS?\r\n"   
N#define CHECK_GATT_CMD              "AT+CGATT?\r\n"    
N#define CHECK_GREG_CMD              "AT+CGREG?\r\n" 
N#define CHECK_CONTEXT_SETTING_CMD   "AT+QICSGP=1,1,\"internet\",\"\",\"\",0\r\n"
N#define CHECK_CONNECTING_CMD        "AT+QIACT=1\r\n"
N#define CHECK_DISCONNECT_CMD        "AT+QIDEACT=1\r\n"
N#define CHECK_QUERY_CONNECTED_CMD   "AT+QIACT?\r\n"
N    
N#define FTP_SET_PDP_CMD             "AT+QFTPCFG=\"contextid\",1\r\n"
N#define FTP_SET_USER_INFO_CMD(id, passwd)       "AT+QFTPCFG=\"account\",\""id"\",\""passwd"\"\r\n"
N#define FTP_SET_FILE_TYPE_CMD       "AT+QFTPCFG=\"filetype\",0\r\n"
N#define FTP_SET_TRANSFER_MODE_CMD   "AT+QFTPCFG=\"transmode\",1\r\n"   //passive
N//#define FTP_SET_TRANSFER_MODE_CMD   "AT+QFTPCFG=\"transmode\",0\r\n"    //active
N#define FTP_SET_TIMEOUT_CMD         "AT+QFTPCFG=\"rsptimeout\",90\r\n"
N#define FTP_CONNECTING_CMD(address, port) "AT+QFTPOPEN=\""address"\","port"\r\n"
N#define FTP_DISCONNECT_CMD          "AT+QFTPCLOSE\r\n"
N#define FTP_QUERY_CSQ_CMD          "AT+CSQ\r\n"
N
N
N#define FTP_DEL_FIL_FRONT          "AT+QFTPDEL=\""
N#define FTP_DEL_FIL_END            "\"\r\n"
N
N/*
N#define str(strx,stry,strz)        #strx#stry#strz
N#define FTP_DELETE_FILE(name)      str(FTP_DEL_FIL_FRONT,name,FTP_DEL_FIL_END)   //str(FTP_DEL_FIL_FRONT)   //###name##str(FTP_DEL_FIL_END)  //"AT+QFTPDEL=\"#name\"\r\n"          
N*/
N
N#define SET_IPR_CMD              "AT+IPR=921600;&W\r\n" 
N//#define FTP_GET_DATA_CMD          "AT+QHTTPREAD=80\r\n"
N    
N//#define FTP_CONNECT_CMD             "AT+QFTPOPEN=\"54.249.1.95\",21\r\n"
N
N
Ntypedef enum{
N	CMD_REQ_NULL            = 0,
N	CMD_REQ_OK              = 100,
N	CMD_REQ_ERROR           = 200, //include timeout
N    CMD_REQ_CME_ERROR       = 300,
N	CMD_REQ_EXIST_OK        = 101,
N	CMD_REQ_REG_OK          = 102,
N    CMD_REQ_GATT_OK         = 103,
N    CMD_REQ_GREG_OK         = 104,
N    CMD_REQ_QUERY_CONNECTED_OK = 105,
N    CMD_REQ_QUERY_FTP_CONNECTED_OK = 106,
N    CMD_REQ_CONNECT_OK      = 107,
N    CMD_REQ_FTP_SEND_DATA_OK = 108,
N    CMD_REQ_FTP_SEND_DATA_TIMEOUT = 109,
N    CMD_REQ_FTP_DISCONNECT = 110,
N    CMD_REQ_WEB_POST_OK = 111,
N    CMD_REQ_WEB_POST_GET_DATA = 112,
N    CMD_REQ_FTP_CHANGE_DIR_OK = 113,
N    CMD_REQ_FTP_CHANGE_DIR_ERROR = 114,
N    CMD_REQ_FTP_GET_DATA_OK = 115,
N    CMD_REQ_FTP_MAKE_DIR_OK = 116,
N    CMD_REQ_FTP_MAKE_DIR_ERROR = 117,
N    CMD_REQ_FTP_GET_DIR_OK = 118,
N    CMD_REQ_FTP_GET_DIR_ERROR = 119,
N    CMD_REQ_QUERY_CSQ_OK = 120,
N    CMD_REQ_NEED_PIN_OK = 121,
N    CMD_REQ_FTP_GET_SIZE_OK = 122,
N    CMD_REQ_REBOOT_OK       = 1100
N}CmdReq;
N
Ntypedef enum{
N    PARSER_TYPE_NORMAL = 0x01,
N    PARSER_TYPE_WEB_POST = 0x02,
N    PARSER_TYPE_FTP = 0x03
N}ParserType;
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/    
N  
N
NCmdReq atCmdProcessReadData(uint8_t* data, int len, ParserType parserType);
NCmdReq atCmdProcessReadData2(uint8_t* data, int len, ParserType parserType, int atLeastSize);
Nvoid ATCmdSetReceiveDebugFlag(int flag);
Nuint8_t* ATCmdDataTempBuffer(uint32_t* len);
NBOOL ATCmdGetReceiveDebugFlag(void);
Nuint8_t* ATCmdDataTempBuffer2(uint32_t* len);
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __AT_CMD_PARSER_H__ */
N
L 22 ".\src\syshal\modemlib\quentelmodemlib.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N    
N    
N
N//------------
N#define MODEM_STAGE_CMD_REG_ACTION_NUM 4
Ntypedef enum{
N    DIALUP_IDLE_STAGE_INDEX            = 0x00,
N    DIALUP_FLOW_CTL_ON_STAGE_INDEX     = 0x01,
N    DIALUP_ECHO_OFF_STAGE_INDEX        = 0x02,
N    DIALUP_EXIST_STAGE_INDEX           = 0x03,
N    DIALUP_REGISTER_STAGE_INDEX        = 0x04,
N    DIALUP_GATT_STAGE_INDEX            = 0x05,
N    DIALUP_GREG_STAGE_INDEX            = 0x06,
N    DIALUP_CONTEXT_SETTING_STAGE_INDEX = 0x07,
N    DIALUP_CONNECTING_STAGE_INDEX      = 0x08,
N    DIALUP_DISCONNECT_STAGE_INDEX      = 0x09,
N    DIALUP_QUERY_CONNECTED_STAGE_INDEX = 0x0a,
N    DIALUP_PIN_STAGE_INDEX             = 0x0b,
N    DIALUP_CONNECTED_STAGE_INDEX       = 0x0f,
N    
N    FTP_IDLE_STAGE_INDEX                = 0x10,
N    FTP_SET_PDP_STAGE_INDEX             = 0x11,
N    FTP_SET_USER_INFO_STAGE_INDEX       = 0x12,
N    FTP_SET_FILE_TYPE_STAGE_INDEX       = 0x13,
N    FTP_SET_TRANSFER_MODE_STAGE_INDEX   = 0x14,
N    FTP_SET_TIMEOUT_STAGE_INDEX         = 0x15,
N    FTP_CONNECTING_STAGE_INDEX          = 0x16,
N    FTP_DISCONNECT_STAGE_INDEX          = 0x17,
N    FTP_QUERY_CONNECTED_STAGE_INDEX     = 0x18,
N    FTP_CONNECTED_STAGE_INDEX           = 0x1f,
N            
N    MODEM_NULL_STAGE_INDEX            = 0xff,
N}ModemStageIndex;
N//-------------------------
Ntypedef struct
N{
N    CmdReq      cmdReg;
N    ModemStageIndex	nextStage;    
N}ModemCmdRegAction;
N    
Ntypedef struct
N{
N    ModemStageIndex         stageIndex;
N    uint8_t*                cmd;
N    ModemCmdRegAction*      cmdRegAction;
N    uint32_t                checkIntervalTime;
N    uint32_t                waitTime;
N    uint8_t                 retryTimes;
N}ModemStageItem;
N
N
N//------------
Ntypedef struct
N{
N    CmdReq      cmdReg;
N    BOOL        returnValue;    
N}CmdRegAction;
N
Ntypedef struct
N{
N    uint8_t*                cmd;
N    CmdRegAction*           cmdRegAction;
N    uint32_t                checkIntervalTime;
N    uint32_t                waitTime;
N}ModemCmdItem;
N
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/   
NBOOL QModemLibInit(UINT32 baudRate);
NBOOL QModemDialupProcess(void);
Nvoid QModemDialupStart(void);
N
N
NBOOL QModemFtpClientProcess(void);
Nvoid QModemFtpClientStart(void);
N
Nvoid QModemTotalStop(void);
N
NBOOL FtpClientSendFile(BOOL needChdirFlag, char* preDirName, char* dirName, char* fileName, uint8_t* buff, int len);
NBOOL FtpClientSendFileEx(BOOL needChdirFlag, char* preDirName, char* dirName, char* fileName, uint8_t* buff, int len,
N                       int* err1,int* err2);
NBOOL FtpClientDeleteFile(BOOL needChdirFlag, char* preDirName, char* dirName, char* fileName);
N
NBOOL FtpClientGetFile(char* dirName, char* fileName);
NBOOL FtpClientGetFileLite(char* dirName, char* fileName);
NBOOL FtpClientGetFilePure(char* dirName, char* fileName, uint8_t** dataBuff, uint32_t* dataLen, uint32_t waitTime);
NBOOL WebPostMessage(char* url, uint8_t* buff);
NBOOL FtpClientClose(void);
N
NBOOL FtpDeleteFile(char* filename);
N
Nchar* FtpQueryCsq(void);
NBOOL QModemATCmdTest(void);
N
NModemStageIndex QModemDialupStageIndex(void);
NModemStageIndex QModemFtpStageIndex(void);
NBOOL QModemSetHighSpeed(void);
NBOOL QModemQueryIPAddress(char* ipBuffer);
NBOOL QModemGetVer(char* reStr);
NBOOL QModemGetSIMNumber(char* SIMStr);
N
NINT QModemIoctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1);
N
NBOOL QModemSetSleep(void);
Nvoid QModemSetQurccfg(void);
Nvoid QModemSetTestCmd(void);
N
NBOOL QModemQuerySIMInitStatus(int* para);
NBOOL QModemQueryNTP(UINT32* rYear,UINT32* rMonth,UINT32* rDay,UINT32* rHour,UINT32* rMinute,UINT32* rSecond);
NBOOL QModemTerminal(char* CmdString,char* FBCmdStr,int FBCmdSize,int* retlen,int waitime);
N
N
NBOOL QModemSetPower(BOOL flag);
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __QUENTEL_MODEM_LIB_H__ */
N
L 36 "src\user\hwtester.c" 2
N#include "dipdrv.h"
L 1 ".\src\userdrv\dipdrv.h" 1
N/**************************************************************************//**
N* @file     dipdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __DIP_DRV_H__
N#define __DIP_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define DIP_NORMAL_ID               0x10
N#define DIP_REPLACE_BP_ID           0x11 
N#define DIP_SETTING_SPACE_ID        0x12 
N#define DIP_TESTER_KEYPAD_ID        0x13 
N#define DIP_TESTER_ID               0x14    
N    
N    
N#define DIP_SW6_GPIO_PORT           GPIOJ
N#define DIP_SW6_GPIO_F1             BIT0
N#define DIP_SW6_GPIO_F2             BIT1
N#define DIP_SW6_GPIO_F3             BIT2
N#define DIP_SW6_GPIO_F4             BIT3
N#define DIP_SW6_GPIO_F5             BIT4    
N    
N
N//Contactless Card Reader Selector (High=TSReader, Low=OctopusReader)
N#define DIP_CARD_READER_SELECT_PORT     DIP_SW6_GPIO_PORT
N#define DIP_CARD_READER_SELECT_PIN      DIP_SW6_GPIO_F5
N//Testing Program Selector (High=Normal Tester, Low=Burn/In Tester)
N#define DIP_BURNIN_TEST_PORT            DIP_SW6_GPIO_PORT
N#define DIP_BURNIN_TEST_PIN             DIP_SW6_GPIO_F1
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL DipDrvInit(BOOL testModeFlag);
Nvoid DipSetCallbackFunc(keyHardwareCallbackFunc func);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__DIP_DRV_H__
L 37 "src\user\hwtester.c" 2
N#include "batterydrv.h"
L 1 ".\src\userdrv\batterydrv.h" 1
N/**************************************************************************//**
N* @file     batterydrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __BATTERY_DRV_H__
N#define __BATTERY_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define BATTERY_STATUS_IN_USE           0x01
N#define BATTERY_STATUS_NEED_REPLACE     0x02
N#define BATTERY_STATUS_IDLE             0x03
N#define BATTERY_STATUS_EMPTY            0x04
N	
N#define BATTERY_1_LOW_DETECT_PORT       GPIOH
N#define BATTERY_1_LOW_DETECT_PIN        BIT6
N#define BATTERY_2_LOW_DETECT_PORT       GPIOH
N#define BATTERY_2_LOW_DETECT_PIN        BIT5
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL BatteryDrvInit(BOOL testMode);
Nvoid BatteryGetValue(UINT32* solarBatVoltage, UINT32* leftVoltage, UINT32* rightVoltage);
Nvoid BatteryGetStatus(uint8_t* leftStatus, uint8_t* rightStatus);
Nvoid BatterySwitchStatusEx(BOOL leftSwitch);
NBOOL BatteryGetVoltage(void);
Nvoid BatterySetEnableTestMode(BOOL mode);
Nvoid BatterySetSwitch1(BOOL flag);
Nvoid BatterySetSwitch2(BOOL flag);
NBOOL BatteryCheckPowerDownCondition(void);
N
Nvoid setBatterySwitchStatus(BOOL battery1Switch, BOOL battery2Switch);
N
Nvoid ModifyAjustSolarBatFactor(uint32_t factorValue);
N
Nuint32_t ShowAjustSolarBatFactor(void);
N
N
Nvoid SetCADtenConnectFlagFunc(BOOL flag);
N
NBOOL ReadCADtenConnectFlagFunc(void);
N
Nvoid SetBatINTtestFlagFunc(int index,BOOL flag);
N
NBOOL ReadBatINTtestFlagFunc(int index);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__BATTERY_DRV_H__
L 38 "src\user\hwtester.c" 2
N#include "sr04tdrv.h"
L 1 ".\src\userdrv\sr04tdrv.h" 1
N/**************************************************************************//**
N* @file     sr04tdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SR04T_DRV_H__
N#define __SR04T_DRV_H__
N
N#include "nuc970.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL SR04TDrvInit(void);
NBOOL SR04TMeasureDist(uint8_t id, int* detectResult);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SR04T_DRV_H__
L 39 "src\user\hwtester.c" 2
N#include "smartcarddrv.h"
L 1 ".\src\userdrv\smartcarddrv.h" 1
N/**************************************************************************//**
N* @file     smartcarddrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SMART_CARD_DRV_H__
N#define __SMART_CARD_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N  
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL SmartCardDrvInit(BOOL testModeFlag);
N
NBOOL SmartCardTestInit(BOOL testModeFlag);
Nuint32_t GetSmartCardBurninTestCounter(void);
Nuint32_t GetSmartCardBurninTestErrorCounter(void);    
N    
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SMART_CARD_DRV_H__
L 40 "src\user\hwtester.c" 2
N#include "powerdrv.h"
L 1 ".\src\syshal\powerdrv.h" 1
N/**************************************************************************//**
N* @file     powerdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __POWER_DRV_H__
N#define __POWER_DRV_H__
N
N#include "nuc970.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define WAKEUP_SOURCE_NONE      0x00
N#define WAKEUP_SOURCE_RTC       0x01   
N#define WAKEUP_SOURCE_KEYPAD    0x02    
N#define WAKEUP_SOURCE_DIP       0x03   
N#define WAKEUP_SOURCE_USER      0x04      
N#define WAKEUP_SOURCE_OTHER     0x05     
N#define WAKEUP_SOURCE_BATTERY   0x06       
N
N#define MAX_POWER_REG_CALLBACK_NUM  10
Ntypedef BOOL(*powerCallback)(int);
N    
Ntypedef struct
N{
N    char* drvName;
N    powerCallback powerPreOffCallback;
N    powerCallback powerOffCallback;
N    powerCallback powerOnCallback;
N    powerCallback powerStatusCallback;    
N}powerCallbackFunc;
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL PowerDrvInit(BOOL testModeFlag);
NBOOL PowerSuspend(UINT32 wakeUpSource);
Nvoid PowerClearISR(void);
Nvoid PowerSetWakeupTime(UINT32 time);
N//BOOL GetPowerStableStatus(void);
Nint PowerRegCallback(powerCallbackFunc* callbackFunc);
Nvoid __wfi(void);
Nuint32_t PowerGetTotalWakeupTick(void);  
Nvoid PowerDrvSetEnable(BOOL flag);
Nvoid PowerDrvResetSystem(void);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__POWER_DRV_H__
L 41 "src\user\hwtester.c" 2
N
N#include "guimanager.h"
L 1 "src\user\guimanager.h" 1
N/**************************************************************************//**
N* @file     guimanager.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __GUI_MANAGER_H__
N#define __GUI_MANAGER_H__
N
N#include "nuc970.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/    
N#define GUI_STANDBY_ID          1
N#define GUI_SEL_SPACE_ID        2
N#define GUI_SEL_TIME_ID         3
N#define GUI_READER_INIT_ID      4
N#define GUI_DEPOSIT_ID          5
N#define GUI_DEPOSIT_OK_ID       6
N#define GUI_DEPOSIT_FAIL_ID     7
N#define GUI_REPLACE_BP_ID       8
N#define GUI_TESTER_ID           9
N#define GUI_TESTER_KEYPAD_ID    10
N#define GUI_FILE_DOWNLOAD_ID    11
N#define GUI_FREE_ID             12
N#define GUI_OFF_ID              13
N#define GUI_HW_TEST_ID          14
N#define GUI_ALL_TEST_ID         15
N#define GUI_SINGLE_TEST_ID      16
N#define GUI_TOOL_TEST_ID        17
N#define GUI_FACTORY_TEST_ID     18
N#define GUI_SETTING_ID          19
N#define GUI_SHOW_CARD_ID        20
N#define GUI_RADAR_ID            21
N#define GUI_USB_CAM_ID          22
N#define GUI_LIDAR_ID            23
N#define GUI_NULL_ID             24
N#define GUI_CALIBRATION_ID      25
N#define GUI_VERSION_ID          26
N#define GUI_BLANK_ID            27
N#define GUI_EPDFLASH_TOOL_ID    28
N#define GUI_RADAROTA_TOOL_ID    29
N#define GUI_BURNIN_TESTER_ID    30
N#define GUI_RTC_TOOL_ID         31
N#define GUI_RADAR_TOOL_ID       32
N
N
N#define GUI_SHOW_SCREEN_OK          0x01
N#define GUI_SHOW_SCREEN_ERROR       0x02
N#define GUI_SHOW_SCREEN_IGNORE      0x03
N
N#define GUI_MSG_SHOW    1
N#define GUI_MSG_REFLASH 2    
N#define GUI_MSG_CLEAN   3
N
Ntypedef struct
N{
N    char        charItem;
N    char*       itemName;
N}ListItem;
N
N/*wq GUI L^*/
Ntypedef void (*KeyinCallback)(char);
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL GuiManagerInit(void);
Nuint8_t GuiManagerShowScreen(uint8_t guiId, uint8_t para, int para2, int para3);
NBOOL GuiManagerRefreshScreen(void);
NBOOL GuiManagerUpdateScreen(void);
NBOOL GuiManagerCompareCurrentScreenId(uint8_t guiId);
N//new add 2019/01/15 by Jermey
NBOOL GuiManagerResetInstance(void);
NBOOL GuiManagerResetKeyCallbackFunc(void);
N
NBOOL GuiManagerTimerSet(uint8_t reFreshPara);
N
NBOOL GuiManagerCleanMessage(uint8_t reFreshPara);
N
NBOOL GuiManagerUpdateMessage(uint8_t reFreshPara,int UpdatePara2,int UpdatePara3);
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
Nuint32_t GetEpdBurninTestCounter(void);
Nuint32_t GetEpdBurninTestErrorCounter(void);
Nvoid SetEpdErrorFlag(BOOL flag);
N#endif
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GUI_MANAGER_H__
L 43 "src\user\hwtester.c" 2
N#include "guidrv.h"
L 1 ".\src\syshal\guidrv.h" 1
N/**************************************************************************//**
N* @file     guidrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __GUI_DRV_H__
N#define __GUI_DRV_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#include "halinterface.h"
N#include "timerdrv.h"
L 1 ".\src\syshal\timerdrv.h" 1
N/**************************************************************************//**
N* @file     timerdrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __TIMER_DRV_H__
N#define __TIMER_DRV_H__
N
N#include "nuc970.h"
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
N#include "task.h"
N#include "queue.h"
N#include "semphr.h"
N
N#include "halinterface.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define TIMER_INTERFACE_NUM          3
N
N#define TIMER_0_INTERFACE_INDEX      0
N#define TIMER_1_INTERFACE_INDEX      1    
N#define TIMER_2_INTERFACE_INDEX      2 
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL TimerDrvInit(void);
NBOOL TimerSetTimeout(uint8_t timerIndex, TickType_t time);
NBOOL TimerRun(uint8_t timerIndex);
Nvoid TimerSetCallback(timerCallbackFunc callback);
NBOOL TimerAllStop(void);    
N    
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_DRV_H__
L 19 ".\src\syshal\guidrv.h" 2
N#include "dipdrv.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define GUI_TIME_0_INDEX        TIMER_0_INTERFACE_INDEX
N#define GUI_TIME_1_INDEX        TIMER_1_INTERFACE_INDEX
N#define GUI_TIME_2_INDEX        TIMER_2_INTERFACE_INDEX    
N
N#define GUI_KEY_UP_INDEX        KEY_HARDWARE_UP_EVENT
N#define GUI_KEY_DOWN_INDEX      KEY_HARDWARE_DOWN_EVENT
N#define GUI_KEY_ERROR_INDEX     KEY_HARDWARE_ERROR_EVENT   
N    
N//#define GUI_KEYPAD_LEFT_ID      0x02
N//#define GUI_KEYPAD_RIGHT_ID     0x01
N//#define GUI_KEYPAD_ADD_ID       0x03
N//#define GUI_KEYPAD_CONFIRM_ID   0x00   
N#define GUI_KEYPAD_LEFT_ID      0x03
N#define GUI_KEYPAD_RIGHT_ID     0x02
N#define GUI_KEYPAD_ADD_ID       0x04
N#define GUI_KEYPAD_MINUS_ID     0x01
N#if(SUPPORT_HK_10_HW)
X#if(1)
N    #define GUI_KEYPAD_QRCODE_ID   0x00
N    #define GUI_KEYPAD_CARD_ID     0x05
N#else
S    #define GUI_KEYPAD_CONFIRM_ID   0x00  
N#endif
N
N#define GUI_KEYPAD_ONE      0x03
N#define GUI_KEYPAD_TWO      0x02
N#define GUI_KEYPAD_THREE    0x04
N#define GUI_KEYPAD_FOUR     0x01
N#define GUI_KEYPAD_FIVE     0x05
N#define GUI_KEYPAD_SIX      0x00
N
N#define GUI_KEYPAD_NORMAL_ID            DIP_NORMAL_ID
N#define GUI_KEYPAD_REPLACE_BP_ID        DIP_REPLACE_BP_ID
N#define GUI_KEYPAD_SETTING_SPACE_ID     DIP_SETTING_SPACE_ID
N#define GUI_KEYPAD_TESTER_KEYPAD_ID     DIP_TESTER_KEYPAD_ID
N#define GUI_KEYPAD_TESTER_ID            DIP_TESTER_ID     
N
N#define GUI_POWER_STATUS_INDEX      0x01
N#define GUI_POWER_ON_INDEX          0x02
N#define GUI_POWER_OFF_INDEX         0x03
N#define GUI_POWER_PREV_OFF_INDEX    0x04
N   
N#define GUI_REDRAW_PARA_DONT_CARE   0x00   
N#define GUI_REDRAW_PARA_NONE        0x01   
N#define GUI_REDRAW_PARA_NORMAL      0x02
N#define GUI_REDRAW_PARA_REFRESH     0x03
N#define GUI_REDRAW_PARA_CONTAIN     0x04
N    
N#define GUI_TIMER_ENABLE            0x05
N#define GUI_TIMER_DISABLE           0x06
N
N#define GUI_CLEAN_MESSAGE_ENABLE    0x07
N
N#define GUI_KEY_ENABLE              0x08
N#define GUI_KEY_DISABLE             0x09
N
N#define GUI_KEYPAD_TEST             0x0A
N#define GUI_MTP_INI                 0x0B
N#define GUI_MTP_SCREEN              0x0C
N#define GUI_MTP_START               0x0D
N
N#define GUI_CAD_TIMER_ENABLE        0x10
N#define GUI_CAD_TIMER_DISABLE       0x11
N#define GUI_CAD_TIMEROUT_FLAG       0x12
N
N#define GUI_OCTOPUS_SELECTTYPE_EN   0x15 
N#define GUI_OCTOPUS_SELECTTYPE_DE   0x16
N
N#define GUI_SETRTC_YEAR             0x20
N#define GUI_SETRTC_MONTH            0x21
N#define GUI_SETRTC_DAY              0x22
N#define GUI_SETRTC_HOUR             0x23
N#define GUI_SETRTC_MINUTE           0x24
N#define GUI_SETRTC_WEEKDAY          0x25
N#define GUI_SETRTC_MODIFY           0x26
N
N#define GUI_SET_RADARA_PARAMETER    0x30
N#define GUI_SET_RADARB_PARAMETER    0x31
N#define GUI_NEW_RADAR_TEST          0x32
N#define GUI_NEW_RADARA_OTA          0x33
N#define GUI_NEW_RADARB_OTA          0x34
N
Ntypedef struct
N{
N    guiOnDrawFunc           onDraw;
N    guiUpdateDataFunc       updateData;
N    guiKeyCallbackFunc      keyCallback;
N    guiTimerCallbackFunc    timerCallback;
N    guiPowerCallbackFunc    powerCallback;
N}GuiInstance;
N
Ntypedef struct
N{
N    uint8_t           guiId;
N    GuiInstance*      guiInstance;
N}UserGuiInstance;
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL GUIDrvInit(BOOL testModeFlag);
Nvoid GuiSetKeyCallbackFunc(guiKeyCallbackFunc callback);
Nvoid GuiSetTimerCallbackFunc(guiTimerCallbackFunc callback);
NBOOL GuiSetInstance(UserGuiInstance* instance, uint8_t oriGuiId, uint8_t para, int para2, int para3);
Nvoid GuiSetTimeout(uint8_t timerIndex, TickType_t time);
Nvoid GuiRunTimeoutFunc(uint8_t timerIndex);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GUI_DRV_H__
L 44 "src\user\hwtester.c" 2
N
N#include "sflashrecord.h"
L 1 ".\src\syshal\sflashrecord.h" 1
N/**************************************************************************//**
N* @file     sflashrecord.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SFLASH_RECORD_H__
N#define __SFLASH_RECORD_H__
N
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N#include "nuc970.h"
N#include "sys.h"
N
N#include "flashdrvex.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N   
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N//|-------------  RAW:3MB  ------------------|//
N//|-- RECORD:2MB --|-- STORAGE: 16k--|--??---|//
X
N    
N//RECORD DATA
N#define SFLASH_RECORD_PAGE_SIZE_PER_RECORD  8 //page per record
N#define SFLASH_RECORD_NUM_PER_SECTOR        (SPI_FLASH_EX_PAGE_NUM_PER_SECTOR / SFLASH_RECORD_PAGE_SIZE_PER_RECORD) //4 record per sector   
N
N#define SFLASH_RECORD_START_PAGE            SPI_FLASH_EX_RAW_START_PAGE   //_l page
N#define SFLASH_RECORD_START_ADDRESS         (SFLASH_RECORD_START_PAGE * SPI_FLASH_EX_PAGE_SIZE)   //_l} 
N#define SFLASH_RECORD_TOTAL_PAGE_SIZE       8192  //use how many page, max value: SPI_FLASH_EX_RAW_PAGE_SIZE
N#define SFLASH_RECORD_LAST_PAGE             (SFLASH_RECORD_START_PAGE + SFLASH_RECORD_TOTAL_PAGE_SIZE - 1)   // page
N
N#define SFLASH_RECORD_TOTAL_NUM             (SFLASH_RECORD_TOTAL_PAGE_SIZE / SFLASH_RECORD_PAGE_SIZE_PER_RECORD)  //iHX record: 8192/8 = 1000
N#define SFLASH_RECORD_SIZE                  (SPI_FLASH_EX_PAGE_SIZE * SFLASH_RECORD_PAGE_SIZE_PER_RECORD) //Crecordjp: 256*8 = 2048byte
N
N//storage data
N#define SFLASH_STORAGE_PAGE_SIZE_PER_RECORD (SPI_FLASH_EX_SECTOR_SIZE / SPI_FLASH_EX_PAGE_SIZE) //1 sector = 16 pages   per record (4K)
N    
N#define SFLASH_STORAGE_START_PAGE           (SFLASH_RECORD_LAST_PAGE+1)   //_l page
N#define SFLASH_STORAGE_START_ADDRESS        (SFLASH_STORAGE_START_PAGE * SPI_FLASH_EX_PAGE_SIZE)   //_l} 
N#define SFLASH_STORAGE_TOTAL_PAGE_SIZE      (16*4)  //h page, 16*4*256 = 16k
N#define SFLASH_STORAGE_LAST_PAGE            (SFLASH_STORAGE_START_PAGE + SFLASH_STORAGE_TOTAL_PAGE_SIZE)   // page
N
N#define SFLASH_STORAGE_TOTAL_NUM             (SFLASH_STORAGE_TOTAL_PAGE_SIZE / SFLASH_STORAGE_PAGE_SIZE_PER_RECORD)  //iHX record: (16*4)/16 = 4
N#define SFLASH_STORAGE_SIZE                  (SPI_FLASH_EX_PAGE_SIZE * SFLASH_STORAGE_PAGE_SIZE_PER_RECORD) //Crecordjp: 256*16 = 4096byte
N
N//---
N#if(SPI_FLASH_EX_RAW_PAGE_SIZE < (SFLASH_RECORD_TOTAL_PAGE_SIZE + SFLASH_STORAGE_TOTAL_PAGE_SIZE))
X#if((((((8*1024*1024) - (5*1024*1024))/256) - 1) - (0/256) + 1) < (8192 + (16*4)))
S    #error   (SPI_FLASH_EX_RAW_PAGE_SIZE < (SFLASH_RECORD_TOTAL_PAGE_SIZE + SFLASH_STORAGE_TOTAL_PAGE_SIZE))
N#endif    
N   
N#define SFLASH_STORAGE_EPM_SERIAL_ID_INDEX_BASE  0
N
N#define SFLASH_STORAGE_SPACE_EX_DATA_INDEX_BASE  1
N    
N
N
N//#if (ENABLE_MTP_FUNCTION)
N#define SFLASH_STORAGE_EPM_SERIAL_ID_INDEX  0
N#define SFLASH_STORAGE_EPM_GUID_INDEX  1
N//#endif    
N    
N//--record flag----    
N#define SFLASH_RECORD_STATUS_EMPTY          0xFF    // 0b 1111 1111 //no data
N#define SFLASH_RECORD_STATUS_DATA           0xFE    // 0b 1111 1110 //data, but not send yet
N#define SFLASH_RECORD_STATUS_BACKUP         0xFC    // 0b 1111 1100 //data, already send to server
N#define SFLASH_RECORD_STATUS_BAD            0x00    // 0b 0000 0000 //bad data
N    
N#define SFLASH_RECORD_NAME_LEN              64//32  
N
N#define SFLASH_RECORD_TYPE_ECC              0x01  
N#define SFLASH_RECORD_TYPE_IPASS            0x02
N#define SFLASH_RECORD_TYPE_TRANSACTION      0x03
N
N#define SFLASH_HEADER_VALUE             0xda   
N#define SFLASH_HEADER_VALUE2		    0xad  
N    
N#define SFLASH_END_VALUE                0x1f   
N#define SFLASH_END_VALUE2		        0xf1  
N
N#define SFLASH_RECORD_DATA_LEN              (SFLASH_RECORD_SIZE - SFLASH_RECORD_NAME_LEN*sizeof(uint8_t) - sizeof(uint8_t) - sizeof(uint32_t) - sizeof(uint8_t) - sizeof(SFlashRecordHeader) - sizeof(SFlashRecordEnd))
N    
N#pragma pack(1)
Ntypedef struct
N{
N    uint8_t         value[2];    //2 byte
N    size_t          Len;
N}SFlashRecordHeader; //9 bytes
N
Ntypedef struct
N{
N    uint16_t    checksum; 
N    uint8_t     value[2];     //2 byte
N}SFlashRecordEnd; //4 bytes
N
Ntypedef struct
N{
N    SFlashRecordHeader      header;
N    uint8_t                 data[SFLASH_RECORD_DATA_LEN];
X    uint8_t                 data[((256 * 8) - 64*sizeof(uint8_t) - sizeof(uint8_t) - sizeof(uint32_t) - sizeof(uint8_t) - sizeof(SFlashRecordHeader) - sizeof(SFlashRecordEnd))];
N    uint8_t                 name[SFLASH_RECORD_NAME_LEN];
X    uint8_t                 name[64];
N    uint8_t                 type;  
N    int32_t                 index;
N    uint8_t                 status;
N    SFlashRecordEnd         end;
N}SFlashRecord;  //SFLASH_RECORD_SIZE  //256*4 = 1024byte
N
N//--record flag----  
N#define SFLASH_STORAGE_HEADER_VALUE            0xdb   
N#define SFLASH_STORAGE_HEADER_VALUE2		    0xbd  
N    
N#define SFLASH_STORAGE_END_VALUE        0x2f   
N#define SFLASH_STORAGE_END_VALUE2		0xf2  
N
N#define SFLASH_STORAGE_DATA_LEN              (SFLASH_STORAGE_SIZE - sizeof(SFlashStorageHeader) - sizeof(SFlashStorageEnd))
N
Ntypedef struct
N{
N    uint8_t         value[2];    //2 byte
N    size_t          Len;
N}SFlashStorageHeader; //9 bytes
N
Ntypedef struct
N{
N    uint16_t    checksum; 
N    uint8_t     value[2];     //2 byte
N}SFlashStorageEnd; //4 bytes
N
Ntypedef struct
N{
N    SFlashStorageHeader     header;
N    uint8_t                 data[SFLASH_STORAGE_DATA_LEN];
X    uint8_t                 data[((256 * ((4*1024) / 256)) - sizeof(SFlashStorageHeader) - sizeof(SFlashStorageEnd))];
N    SFlashStorageEnd        end;
N}SFlashStorage;    //4096 byte
N
N//checksum: data[SFLASH_RECORD_DATA_LEN] ~ index
N#pragma pack()
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL SFlashRecordInit(void);
Nvoid SFlashListRecord(uint8_t flashIndex);
NBOOL SFlashAppendRecord(char* name, uint8_t type, uint8_t* dataSrc, int dataSrcLen);
Nint  SFlashGetRecord(uint8_t** targetData, size_t* targetDataLen, char* fileName, uint8_t* type);
Nvoid SFlashMarkRecordStatus(int recordIndex, uint8_t status);
N
NBOOL SFlashSaveStorage(int storageId, uint8_t* dataSrc, int dataSrcLen);
NBOOL SFlashLoadStorage(int storageId, uint8_t* dataSrc, int dataSrcLen);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SFLASH_RECORD_H__
L 46 "src\user\hwtester.c" 2
N
N#include "ff.h"
N#include "fatfslib.h"
L 1 ".\src\syshal\fatfslib.h" 1
N/**************************************************************************//**
N* @file     fatfslib.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __FATFS_LIB_H__
N#define __FATFS_LIB_H__
N
N#include "nuc970.h"
N#include "interface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
Ntypedef enum{
N    FATFS_INDEX_SD = 0,
N    FATFS_INDEX_SFLASH_0 = 1,
N    FATFS_INDEX_SFLASH_1 = 2
N}FatfsIndex;      
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL FatfsInit(BOOL testModeFlag);
NFatfsHardwareInterface* FatfsGetCallback(uint8_t index);
Nvoid FatfsListFile(char* dir);
Nvoid FatfsListFileEx (char* dir);
Nvoid FatfsGetDiskUseage(char* dir);
Nint  FatfsGetDiskUseageEx(char* dir);
NBOOL FatFsFormat(char* path);
Nint FatFsGetCounter(void);
NBOOL FatFsGetExistFlag(FatfsIndex index);
Nchar* FatFsGetRootStr(FatfsIndex index);
Nint FlashDrvExGetErrorTimes(void);
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__FATFS_LIB_H__
L 49 "src\user\hwtester.c" 2
N
N#include "epddrv.h"
N#include "creditReaderDrv.h"
L 1 ".\src\syshal\creditReaderDrv.h" 1
N/**************************************************************************//**
N* @file     creditReaderDrv.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __CREDIT_CARD_READER_DRV_H__
N#define __CREDIT_CARD_READER_DRV_H__
N
N#include "nuc970.h"
N#include "halinterface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define DECODER_S0_Start                        0
N#define DECODER_S1_SOH                          1
N#define DECODER_S2_STX                          2
N#define DECODER_S3_EOT                          3
N#define DECODER_S4_SOHsequenceNumber            4
N#define DECODER_S5_NumberOfFrames1              5
N#define DECODER_S6_STXsequenceNumber            6
N#define DECODER_S7_APDU                         7
N#define DECODER_S8_IsDLE                        8
N#define DECODER_S9_IsETX                        9
N#define DECODER_S10_AddToBuffer                 10
N#define DECODER_S11_EndOfFrame                  11
N#define DECODER_S12_CRC1                        12
N#define DECODER_S13_CRC2                        13
N#define DECODER_S14_IsCrcOK                     14
N#define DECODER_S15_NACKout                     15
N#define DECODER_S16_EOTsequenceNumber           16
N#define DECODER_S17_ACKout                      17
N#define DECODER_S18_IsComplete                  18
N#define DECODER_S19_APDUmessage                 19
N#define DECODER_S20_IsSTXorSOH                  20
N#define DECODER_S21_ACKin                       21
N#define DECODER_S22_ACKsequenceNumber           22
N#define DECODER_S23_ACKmessage                  23
N#define DECODER_S24_NACKin                      24
N#define DECODER_S25_NACKsequenceNumber          25
N#define DECODER_S26_NACKmessage                 26
N#define DECODER_S27_NumberOfFrames2             27
N#define DECODER_S28_Finished                    28
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NBOOL CreditReaderDrvInit(BOOL testModeFlag);
Nvoid CreditCardFlushTxRx(void);
Nvoid CreditCardSetPower(BOOL flag);
NINT32 CreditCardRead(PUINT8 pucBuf, UINT32 uLen);
NINT32 CreditCardWrite(PUINT8 pucBuf, UINT32 uLen);
N
N#if (ENABLE_BURNIN_TESTER)
X#if (1)
Nuint32_t GetCreditReaderBurninTestCounter(void);
Nuint32_t GetCreditReaderBurninTestErrorCounter(void);
N#endif
N
Nvoid CADReadCardinit(uint8_t* pucBuf);
NBOOL CADReadCard(uint8_t* pucBuf,uint8_t* currentSequenceNum);
NBOOL DetectCADConnect(void);
Nvoid CADReadCardpoweron(void);
Nvoid CADReadCardpoweroff(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CREDIT_CARD_READER_DRV_H__
L 52 "src\user\hwtester.c" 2
N#include "../octopus/octopusreader.h"
L 1 ".\src\syshal\json\../octopus/octopusreader.h" 1
N/**************************************************************************//**
N* @file     octopusreader.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2016 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef _OCTOPUS_READER
N#define _OCTOPUS_READER
N
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N
N#ifdef _PC_ENV_
S    #include "basetype.h"
N#else
N    #include "nuc970.h"
N#endif
N
N#include "halinterface.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define OCTOPUS_USE_TEST_KEY            0
N#define OCTOPUS_USE_PRODUCTION_KEY      1
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
NTSReaderInterface* OctopusReaderGetInterface(void);
NBOOL OctopusReaderSetAIValue(uint8_t AI1, uint8_t AI2);
NBOOL OctopusReaderInit(void);
NBOOL OctopusReaderSetPower(uint8_t id, BOOL flag);
Nuint8_t OctopusReaderCheckReader(void);
NBOOL OctopusReaderBreakCheckReader(void);
N
NBOOL OctopusReaderProcess(uint16_t targetDeduct, tsreaderDepositResultCallback callback);
NBOOL OctopusReaderGetBootedStatus(void);
NBOOL OctopusReaderSignOnProcess(void);
Nvoid OctopusReaderSaveFile(RTC_TIME_DATA_T pt, uint16_t paraValue);
Nvoid OctopusReaderSaveFilePure(void);
N    
NINT32 OctopusReaderWrite(PUINT8 pucBuf, UINT32 uLen);
NINT32 OctopusReaderRead(PUINT8 pucBuf, UINT32 uLen);
Nvoid OctopusReaderFlushBuffer(void);
N
Nvoid OctopusReaderGetVersion(char* ReaderVerBuf);
N
Nvoid OctopusReaderQueryTimeEx(UINT* tempYear,UINT* tempMonth,UINT* tempDay,UINT* tempHour,UINT* tempMinute,UINT* tempSecond);
Nvoid OctopusReaderQueryTime(void);
N
NBOOL OctopusReaderCheckHangUpEnable(void);
Nvoid InitOctopusReaderHangUpStatus(void);
Nvoid OctopusReaderCheckHangUp(BOOL HUstatus);
NBOOL OctopusReaderHangUpStatus(void);
N
Nvoid ChangeOctopusKey(BOOL OctopusKey);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //_OCTOPUS_READER
L 53 "src\user\hwtester.c" 2
N#include "MtpProcedure.h"
L 1 ".\src\syshal\MtpProcedure.h" 1
N/**************************************************************************//**
N* @file     MtpProcedure.h
N* @version  V1.00
N* $Revision: 
N* $Date: 
N* @brief    
N*
N* @note
N* Copyright (C) 2019 Far Easy Pass LTD. All rights reserved.
N*****************************************************************************/
N
N#ifndef __MTP_PROCEDURE_H__
N#define __MTP_PROCEDURE_H__
N
N#include "nuc970.h"
N#include "halinterface.h"
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N
N#define MTP_LIBRARY_VERSION         "1.00.02"
N
N/*-----------------------------------------*/
N/* interface function declarations         */
N/*-----------------------------------------*/
N
NBOOL MTP_ProcedureInit(void);
NBOOL MTP_IsExitProcedure(void);
Nvoid MTP_ProcedureDeInit(void);
Nvoid MTP_WaitingStartMessage(void);
NBOOL MTP_GetProcedureFlag(void);
NBOOL MTP_GetSwitchRTCFlag(void);
N
N//===================== for CRCTool =====================
Nvoid CRCTool_Init(int CodingType);
Nuint32_t CRCTool_TableFast(uint8_t *p, int p_len);
Nuint32_t CRCTool_Table(uint8_t *p, int p_len);
N//===================== for CRCTool =====================
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__MTP_PROCEDURE_H__
L 54 "src\user\hwtester.c" 2
N//#include "modemagent.h"
N/*-----------------------------------------*/
N/* marco, type and constant definitions    */
N/*-----------------------------------------*/
N#define TEST_FALSE						0x10
N#define TEST_TRUE                       0x11    
N#define TEST_SUCCESSFUL_LIGHT_OFF		0x12
N#define TEST_SUCCESSFUL_LIGHT_ON		0x13
N
N
N#if(SUPPORT_HK_10_HW)
X#if(1)
N    #define IOPIN_BOTH_ON		0
N    #define IOPIN_ONLY1_ON		2
N    #define IOPIN_ONLY2_ON		1
N    #define IOPIN_BOTH_OFF		3
N    #define SOLAR_ON            4
N    #define SOLAR_OFF           5
N#else
S    #define IOPIN_BOTH_ON		0
S    #define IOPIN_ONLY1_ON		1
S    #define IOPIN_ONLY2_ON		2
S    #define IOPIN_BOTH_OFF		3
S    #define SOLAR_ON            4
S    #define SOLAR_OFF           5
N#endif
N
N#define BATTERY_L_MAX_VOLTAGE 770 //1200	//7.7v
N#define BATTERY_L_MIN_VOLTAGE 730 //800	//7.3v
N#define BATTERY_R_MAX_VOLTAGE 800 //1200	//7.7v
N#define BATTERY_R_MIN_VOLTAGE 760 //800	//7.3v
N#define SOLAR_BAT_MAX_VOLTAGE 850 //860 20200706 considerd loader voltage and modify by Steven 
N#define SOLAR_BAT_MIN_VOLTAGE 770 //790 20200706 considerd loader voltage and modify by Steven
N#define MB_BAT_MAX_VOLTAGE    880 //850 
N#define MB_BAT_MIN_VOLTAGE    770 //780 
N
N#define MODEM_BAUDRATE 921600
N
N#define ALL_TEST_MODE   1
N#define GET_ID_MODE     1
N#define POWER_SET_MODE  1
N/*   ERROR CODE  */
N#define GUI_MANAGER_INIT_ERROR              0x0100
N
N#define LED_CONNECT_ERRO					0x0201
N#define LED_HARDWARE_ERRO                   0x0200//no light
N
N#define RED_SWITCH_INITIAL_ERRO             0x0300//initial error
N#define RED_SWITCH_1_ERRO                   0x0301//switch 1 no detect
N#define RED_SWITCH_2_ERRO                   0x0302//switch 2 no detect
N#define RED_SWITCH_BOTH_ERRO                0x0303//switch both no detect
N#define RED_SWITCH_BOTH_ON_ERRO				0x0310
N#define RED_SWITCH_SEQUENCE_ERRO			0x0320
N
N#define POWER_BOTTON_ON_BEFOR_START_ERRO	0x0401
N#define POWER_BOTTON_WAIT_ON_ERRO			0x0402
N#define POWER_BOTTON_WAIT_OFF_ERRO			0x0403
N
N#define EPD_INIT_ERROR                      0x0500
N#define EPD_CONNECT_ERRO					0x0501
N
N#define TOUCH_CONNECT_ERRO					0x0601
N#define TOUCH_SEQUENCE_ERRO					0x0610
N#define MODEM_CONNECT_ERRO					0x0701
N#define RTC_TIME_ERRO						0x0801
N#define READER_INIT_ERRO                    0x0900
N#define READER_CONNECT_ERRO					0x0901
N#define FLASH1_SPACE_ERRO					0x0A01
N#define FLASH2_SPACE_ERRO					0x0A02
N#define SMART_CARD_CONNECT_ERRO				0x0B01
N#define CAMERA_CONNECT_ERRO					0x0C01
N#define PROWAVE1_DISTANCE_ERRO				0x0D01
N#define PROWAVE2_DISTANCE_ERRO				0x0D02
N#define BATTERY1_VALUE_ERRO					0x0E01
N#define BATTERY2_VALUE_ERRO					0x0E02
N#define BATTERY1_TIME_OUT_ERRO				0x0E10
N#define BATTERY2_TIME_OUT_ERRO				0x0E20
N#define BATTERY_SEQUENCE_ERRO				0x0E30
N
N#define SOFTWARE_ERRO 0x0010
N
N#define MODEM_BAUDRATE          921600
N
N#define MENU_STRING_MAIN    "\r\n  ************** Main Menu *************\r\nPlease Select Test Type:\r\n"
N#define MENU_STRING_SINGLE  "\r\n  ********** Single Test Menu **********\r\nPlease Select: \r\n"
N#define MENU_STRING_TOOL    "\r\n  ************* Tools Menu *************\r\nPlease Select: \r\n"
N
Ntypedef BOOL(*initFunction)(BOOL testModeFlag);
Ntypedef struct
N{
N    char*               drvName;
N    initFunction        func;    
N    BOOL                result;    
N}initFunctionList;
N
N/*-----------------------------------------*/
N/* global file scope (static) variables    */
N/*-----------------------------------------*/
N///////////////////MENU/////////////////////
Nstatic UINT8 getTerminalChar(void);
Nstatic int actionTestItem(char targetChar, HWTesterItem* item, void* para1, void* para2, BOOL ignoreChar);
Nstatic BOOL enterMunu(char* title, HWTesterItem* item, void* para1, void* para2);
Nstatic BOOL totalTest(void* para1, void* para2);
Nstatic BOOL singleTest(void* para1, void* para2);
Nstatic BOOL singleTestB(void* para1, void* para2);
Nstatic BOOL toolsFunction(void* para1, void* para2);
Nstatic BOOL blankFunction(void* para1, void* para2);
Nstatic BOOL KeyPadTool(void* para1, void* para2);
Nstatic BOOL ModemHSpdTool(void* para1, void* para2);
Nstatic BOOL RTCTool(void* para1, void* para2);
Nstatic BOOL ModemTool(void* para1, void* para2);
Nstatic BOOL NTPTool(void* para1, void* para2);
Nstatic BOOL exitTest(void* para1, void* para2);
Nstatic BOOL testSuccessful(int i,BOOL lightOff);
Nstatic BOOL testFailure(int i);
N
N#if (!ENABLE_BURNIN_TESTER)
X#if (!1)
S////////////////////LED TOOL///////////////
Sstatic BOOL LEDColorBuffSet(UINT16 GreenPinBite, UINT16 RedPinBite);
Sstatic BOOL LEDBoardLightSet(void);
N#endif
N
N//////////////////MAIN FUNCTION///////////
Nstatic BOOL buzzerTest(void* para1, void* para2);
Nstatic BOOL LEDTest(void* para1, void* para2);
Nstatic BOOL LEDTestLite(void* para1, void* para2);
Nstatic BOOL MemsTest(void* para1, void* para2);
Nstatic BOOL redSwitchAllTest(void* para1, void* para2);
Nstatic BOOL electricitySingleTest(void* para1, void* para2);
Nstatic BOOL SW6SingleTest(void* para1, void* para2);
Nstatic BOOL EPDSingleTest(void* para1, void* para2);
Nstatic BOOL CADSingleTest(void* para1, void* para2);
Nstatic BOOL CADReaderTest(void* para1, void* para2);
Nstatic BOOL keyPadAllTest(void* para1, void* para2);
Nstatic BOOL modeminit(BOOL);
Nstatic BOOL modemTest(void* para1, void* para2);
Nstatic BOOL RTCTest(void* para1, void* para2);
Nstatic BOOL readerTest(void* para1, void* para2);;
Nstatic BOOL sFlashTest(void* para1, void* para2);
Nstatic BOOL smartCardTest(void* para1, void* para2);
Nstatic BOOL versionQuery(void* para1, void* para2);
N
Nstatic BOOL cameraTest(void* para1, void* para2);
Nstatic BOOL radarSingleTest(void* para1, void* para2);
Nstatic BOOL NewRadarSingleTest(void* para1, void* para2);
Nstatic BOOL sensorSingleTest(void* para1, void* para2);
Nstatic BOOL lidarSingleTest(void* para1, void* para2);
Nstatic BOOL batteryTest(void* para1, void* para2);
Nstatic BOOL SuperCapTest(void* para1, void* para2);
N//static BOOL epdTest(void* para1, void* para2);
N//static BOOL toolsAdjustKeypad(void* para1, void* para2);
N//static BOOL idConfig(void* para1, void* para2);
N//static BOOL enable12vPower(void* para1, void* para2);
Nstatic BOOL suspendSystem(void* para1, void* para2);
N//static BOOL batterySelect(void* para1, void* para2);
N//static BOOL buzzerLoop(void* para1, void* para2);
N//static BOOL modemSetHighSpeed(void* para1, void* para2);
Nstatic BOOL readerGetCN(void* para1, void* para2);
Nstatic BOOL radarTest(void* para1, void* para2);
Nstatic BOOL NEWradarTest(void* para1, void* para2);
Nstatic BOOL NEWradarSet(void* para1, void* para2);
Nstatic BOOL radarPowerSet(void* para1, void* para2);
Nstatic BOOL usbCamTest(void* para1, void* para2);
Nstatic BOOL usbCamPowerSet(void* para1, void* para2);
Nstatic BOOL lidarTest(void* para1, void* para2);
Nstatic BOOL lidarPowerSet(void* para1, void* para2);
Nstatic BOOL epdBurningTest(void* para1, void* para2);
Nstatic BOOL calibrationConfig(void* para1, void* para2);
Nstatic BOOL versionQueryTool(void* para1, void* para2);
Nstatic BOOL EPDflashTool(void* para1, void* para2);
Nstatic BOOL NewRadarTool(void* para1, void* para2);
Nstatic BOOL NEWradarSetDefault(void* para1, void* para2);
Nstatic BOOL RadarOTATool(void* para1, void* para2);
Nstatic BOOL CADPowerTest(void* para1, void* para2);
Nstatic BOOL ModemAndReaderTest(void* para1, void* para2);
Nstatic BOOL otherIOTest(void* para1, void* para2);
N
N
N
Nstatic BOOL setDeviceID(void* para1, void* para2);
Nstatic int getDeviceID(void* para1, void* para2);
Nstatic BOOL setDeviceIDTool(void* para1, void* para2);
Nstatic BOOL getDeviceIDTool(void* para1, void* para2);
N
Nstatic void cleanRst(void);
Nstatic void cleanMsg(void);
N
N//void setTotalPower(BOOL flag);
N//Getter Setter
Nstatic void setTesterFlag(BOOL testerflag);
Nstatic char getGuiResponse(void);
N
Nstatic void InitMTPvalue(uint8_t index,uint8_t* MTPBuf);
Nstatic void SetMTPCRC(uint8_t index,uint8_t* MTPBuf);
Nstatic void MTPCmdprint(uint8_t index,uint8_t* MTPBuf);
Nstatic void MTPCmdprintEx(uint8_t index,uint8_t* MTPBuf);
N//PRIVATE VARIABLE
Nstatic char guiResponseChar=0;
Nstatic BOOL guiResponseFlag=FALSE;
Xstatic BOOL guiResponseFlag=(0);
Nstatic BOOL TouchPadResponseFlag = FALSE;
Xstatic BOOL TouchPadResponseFlag = (0);
Nstatic BOOL testerFlag=FALSE;
Xstatic BOOL testerFlag=(0);
Nstatic BOOL testerResult=FALSE;
Xstatic BOOL testerResult=(0);
Nstatic char* epdString;
Nstatic BOOL epdPrintFlag=FALSE;
Xstatic BOOL epdPrintFlag=(0);
Nstatic BOOL refreshMsgBar=FALSE;
Xstatic BOOL refreshMsgBar=(0);
Nstatic BOOL isEPDInit=FALSE;
Xstatic BOOL isEPDInit=(0);
Nstatic int passItem=0;
Nstatic int failItem=0;
Nstatic int testedItem=0;
Nstatic int allTestItem=0;
Nstatic int MBallTestItem=0;
N//LED PATTERN
Nstatic uint8_t bayColorOff[8] =     {LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF,   LIGHT_COLOR_OFF, LIGHT_COLOR_OFF};
Xstatic uint8_t bayColorOff[8] =     {0,   0,   0,   0,   0,   0,   0, 0};
Nstatic uint8_t bayColorAllGreen[8]= {LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF};
Xstatic uint8_t bayColorAllGreen[8]= {1, 1, 1, 1, 1, 1, 0, 0};
Nstatic uint8_t bayColorAllRed[8] = {LIGHT_COLOR_RED, LIGHT_COLOR_RED, LIGHT_COLOR_RED, LIGHT_COLOR_RED, LIGHT_COLOR_RED, LIGHT_COLOR_RED, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF};
Xstatic uint8_t bayColorAllRed[8] = {2, 2, 2, 2, 2, 2, 0, 0};
N
Nstatic uint8_t modemColorAllGreen[8]= {LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_GREEN, LIGHT_COLOR_GREEN};
Xstatic uint8_t modemColorAllGreen[8]= {0, 0, 0, 0, 0, 0, 1, 1};
Nstatic uint8_t modemColorAllRed[8] = {LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_RED, LIGHT_COLOR_RED};
Xstatic uint8_t modemColorAllRed[8] = {0, 0, 0, 0, 0, 0, 2, 2};
N
Nstatic uint8_t bayColorChange[8] = {LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF, LIGHT_COLOR_OFF};
Xstatic uint8_t bayColorChange[8] = {0, 0, 0, 0, 0, 0, 0, 0};
Nstatic uint8_t callBackKeyId,callBackDownUp;
Nstatic UINT16 testErroCode = 0x0000;
N
N
N
Nstatic unsigned int *setVCOMpoint;
Nstatic unsigned int setVCOMEx;
N
Nstatic int epmIDSet=0 ;
Nstatic uint32_t cardID=0;
N
Nstatic BOOL firstInitFlag = TRUE;
Xstatic BOOL firstInitFlag = (1);
N
Nstatic BOOL ModemGPIOH4INTFlag = FALSE;
Xstatic BOOL ModemGPIOH4INTFlag = (0);
Nstatic BOOL ModemResultLEDFlag = FALSE;
Xstatic BOOL ModemResultLEDFlag = (0);
Nstatic BOOL EPDtestFlag = FALSE;
Xstatic BOOL EPDtestFlag = (0);
N
N//static int  SDbufferSize = 128 ;
NFIL filephoto;
NUINT brPHOTO;
N
N//static char * PhotoFileNameStr;
N//static char  PhotoFileNameStr[50];
N
NRTC_TIME_DATA_T* pptPHOTO;
N
N#define PHOTOBUFFERSIZE 256
Nstatic uint8_t tempPr[PHOTOBUFFERSIZE];
Xstatic uint8_t tempPr[256];
N//static uint8_t tempPr[100000];
N//static char * PhotoFileNameStr;
N//static char PhotoFileNameStr[50];
N
N
Nstatic BOOL IOtestResultFlag[20];
N
Nstatic BOOL targetkeyStage;
N
Nstatic BOOL MBtestFlag = FALSE;
Xstatic BOOL MBtestFlag = (0);
N
Nstatic BOOL AssemblyTestFlag = FALSE;
Xstatic BOOL AssemblyTestFlag = (0);
N
Nstatic BOOL SleeptestFlag = FALSE;
Xstatic BOOL SleeptestFlag = (0);
N
Nstatic BOOL gCADtimeoutFlag = FALSE;
Xstatic BOOL gCADtimeoutFlag = (0);
N
Nstatic UINT32 ReceieveTouchPadVal;
N
Nstatic uint8_t MTPString[60][18] = {{0x90,0x90,0x09,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00}, //[0]battery test
N                                    {0x90,0x91,0x00,0x00,0x00}, //[1]ask bat1 signal
N                                    {0x90,0x92,0x00,0x00,0x00}, //[2]ask bat2 signal
N                                    {0x90,0x93,0x00,0x00,0x00}, //[3]ask solar bat signal
N                                    {0x90,0x94,0x00,0x00,0x00}, //[4]switch bat1
N                                    {0x90,0x95,0x00,0x00,0x00}, //[5]switch bat2
N                                    
N                                    {0x90,0x9A,0x01,0x82,0x00,0x00}, //[6]buzzer test
N                                    {0x90,0x9B,0x00,0x00,0x00}, //[7]ask buzzer test
N                                    
N                                    {0x90,0x9C,0x04,0x82,0x82,0x82,0x82,0x00,0x00}, //[8]LED test
N                                    {0x90,0x9D,0x00,0x00,0x00}, //[9]ask LED signal
N                                    
N                                    {0x90,0x9E,0x01,0x82,0x00,0x00}, //[10]Credit Card Power
N                                    {0x90,0x9F,0x00,0x00,0x00}, //[11]ask 12V test result
N                                    
N                                    {0x90,0xA0,0x07,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00}, //[12]Keypad test
N                                    {0x90,0xA1,0x00,0x00,0x00}, //[13]press key1
N                                    {0x90,0xA2,0x00,0x00,0x00}, //[14]press key2
N                                    {0x90,0xA3,0x00,0x00,0x00}, //[15]press key3
N                                    {0x90,0xA4,0x00,0x00,0x00}, //[16]press key4
N                                    {0x90,0xA5,0x00,0x00,0x00}, //[17]press key5
N                                    {0x90,0xA6,0x00,0x00,0x00}, //[18]press key6
N                                    
N                                    {0x90,0xA7,0x07,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00}, //[19]switch test
N                                    {0x90,0xA8,0x00,0x00,0x00}, //[20]switch SW4on
N                                    {0x90,0xA9,0x00,0x00,0x00}, //[21]switch SW4off
N                                    {0x90,0xAA,0x00,0x00,0x00}, //[22]switch SW5on
N                                    {0x90,0xAB,0x00,0x00,0x00}, //[23]switch SW5off
N                                    {0x90,0xAC,0x00,0x00,0x00}, //[24]switch SW6on
N                                    {0x90,0xAD,0x00,0x00,0x00}, //[25]switch SW6off
N
N                                    {0x90,0xB0,0x06,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00}, //[26]Credit Card test
N                                    
N                                    {0x90,0xB1,0x0D,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00},
N                                     //[27]Modem & Reader test
N                                    {0x90,0xB2,0x00,0x00,0x00}, //[28]ask SysPwr D5
N                                    
N                                    {0x90,0xB3,0x09,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x00,0x00}, //[29]sensor test
N                                    {0x90,0xB4,0x00,0x00,0x00}, //[30]ask SysPwr D2
N                                    
N                                    {0x90,0xB5,0x01,0x82,0x00,0x00}, //[31]RTC test
N                                    
N                                    {0x90,0xB6,0x01,0x82,0x00,0x00}, //[32]EPD test
N                                    
N                                    {0x90,0xB7,0x01,0x82,0x00,0x00}, //[33]sleep test
N                                    {0x90,0xB8,0x00,0x00,0x00}, //[34]key any touchpad
N                                    {0x90,0xB9,0x00,0x00,0x00}, //[35]ask sleep current
N                                    
N                                    {0x90,0xBA,0x01,0x82,0x00,0x00}, //[36]SuperCap test
N                                    {0x90,0xBB,0x00,0x00,0x00}, //[37]ask test result
N                                    
N                                    {0x90,0xC0,0x00,0x00,0x00}, //[38]End condition
N                                    
N                                    {0x90,0xC1,0x00,0x00,0x00},  //[39]show"Start test battery"
N                                    {0x90,0xC2,0x00,0x00,0x00},  //[40]show"Start test buzzer"
N                                    {0x90,0xC3,0x00,0x00,0x00},  //[41]show"Start test LED"
N                                    {0x90,0xC4,0x00,0x00,0x00},  //[42]show"Start test Credit Card Power"
N                                    {0x90,0xC5,0x00,0x00,0x00},  //[43]show"Start test Keypad"
N                                    {0x90,0xC6,0x00,0x00,0x00},  //[44]show"Start test switch"
N                                    {0x90,0xC7,0x00,0x00,0x00},  //[45]show"Start test Credit Card"
N                                    {0x90,0xC8,0x00,0x00,0x00},  //[46]show"Start test Modem & Reader"
N                                    {0x90,0xC9,0x00,0x00,0x00},  //[47]show"Start test sensor"
N                                    {0x90,0xCA,0x00,0x00,0x00},  //[48]show"Start test RTC"
N                                    {0x90,0xCB,0x00,0x00,0x00},  //[49]show"Start test EPD"
N                                    {0x90,0xCC,0x00,0x00,0x00},  //[50]show"Start test sleep mode"
N                                    
N                                    //{0x90,0xCD,0x00,0x00,0x00},  //[51]show"Start test SuperCap" X
N                                    {0x90,0xC0,0x00,0x00,0x00},  //[51]End condition
N                                    
N                                    {0x90,0xD1,0x00,0x00,0x00},  //[52]show"Start test battery1 switch"
N                                    {0x90,0xD2,0x00,0x00,0x00},  //[53]show"Start test battery2 switch"
N                                    {0x90,0xD3,0x00,0x00,0x00},  //[54]show"Start test solar battery switch"
N                                    
N                                    {0x90,0xD4,0x00,0x00,0x00},  //[55]show"Start test LED reset"
N                                    {0x90,0xD5,0x00,0x00,0x00},  //[56]show"Start test LED version"
N                                    
N                                    }; 
N                                  
Nstatic uint8_t MTPReportindex[15]={0,6,8,10,12,19,26,27,29,31,32,33,36};                    
N                                    
N//static uint16_t crctemp[4];
N
N
N    
Nstatic initFunctionList mInitFunctionList[] =  {{"EpdDrv", EpdDrvInit, FALSE},
Xstatic initFunctionList mInitFunctionList[] =  {{"EpdDrv", EpdDrvInit, (0)},
N                                                {"LEDDrv", LedDrvInit, FALSE},
X                                                {"LEDDrv", LedDrvInit, (0)},
N                                                {"BuzzerDrv",BuzzerDrvInit,FALSE},
X                                                {"BuzzerDrv",BuzzerDrvInit,(0)},
N                                                {"GUIDrv", GUIDrvInit, FALSE},
X                                                {"GUIDrv", GUIDrvInit, (0)},
N                                                {"CardReader", CardReaderInit, FALSE},
X                                                {"CardReader", CardReaderInit, (0)},
N                                                {"PowerDrv", PowerDrvInit, FALSE},
X                                                {"PowerDrv", PowerDrvInit, (0)},
N                                                {"FlashDrv", FlashDrvExInit, FALSE},
X                                                {"FlashDrv", FlashDrvExInit, (0)},
N                                                {"QModem", modeminit, FALSE},
X                                                {"QModem", modeminit, (0)},
N                                                {"", NULL,FALSE}};	
X                                                {"", 0,(0)}};	
N
Nstatic HWTesterItem   mainTestItem[] = {
N{'v',   "Version Check", versionQueryTool},
N{'a',   "All Test",     totalTest},
N{'s',   "Single Test",  singleTest},
N{'t',   "Tools",        toolsFunction},
N{'b',   NULL,          blankFunction},
X{'b',   0,          blankFunction},
N//{'d',   "Auto Test",autoTest},
N//{'e',   "Exit Test",   exitTest},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
Nstatic HWTesterItem   MB_mainTestItem[] = {
N{'a',   "All Test",     totalTest},
N{'s',   "Single Test",  singleTest},
N{'t',   "Tools",        toolsFunction},
N{'b',   NULL,          blankFunction},
X{'b',   0,          blankFunction},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
N
Nstatic char ReaderitemName[20] = "Reader" ;
N//static char* ReaderitemName = "Reader" ; Octopus
N
Nstatic HWTesterItem   singleTestItem[] = { 
N{'1',   "Buzzer",          buzzerTest},
N{'2',   "Key Pad",         keyPadAllTest},
N{'3',   "LED",             LEDTestLite},
N{'4',   "Switch",      redSwitchAllTest},																					
N{'5',   "Battery",         batteryTest},
N{'6',   "Credit Card",      CADReaderTest},
N{'7',   "Mems",          MemsTest},
N{'8',   "Modem\\RTC",      modemTest},
N{'9',   "Flash",    sFlashTest},
N//{'a',   "Radar\\Lidar",      radarSingleTest},
N{'a',   "Radar",        NewRadarSingleTest},
N{'b',   "Smart Card",      smartCardTest},
N{'c',   "Camera",     cameraTest},
N{'d',   ReaderitemName,          readerTest},
N{'q',   "Quit", exitTest},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
N
Nstatic HWTesterItem   AllTestItem[] = { 
N{'1',   "Buzzer",          buzzerTest},
N{'2',   "Key Pad",         keyPadAllTest},
N{'3',   "LED",             LEDTestLite},
N{'4',   "Switch",      redSwitchAllTest},																					
N{'5',   "Battery",         batteryTest},
N{'6',   "Credit Card",      CADReaderTest},
N{'7',   "Mems",          MemsTest},
N{'8',   "Modem\\RTC",      modemTest},
N{'9',   "Flash",    sFlashTest},
N//{'a',   "Radar\\Lidar",      radarSingleTest},
N{'a',   "Radar",        NewRadarSingleTest},
N{'b',   "Smart Card",      smartCardTest},
N{'c',   "Camera",     cameraTest},
N{'q',   "Quit", exitTest},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
Nstatic HWTesterItem   MB_singleTestItem[] = { 
N{'1',   "Battery",          batteryTest},
N{'2',   "Buzzer",           buzzerTest},
N{'3',   "LED",              LEDTest},
N{'4',   "Credit Card Power",CADPowerTest},
N{'5',   "Key Pad",          keyPadAllTest},
N{'6',   "Switch",           redSwitchAllTest},
N{'7',   "Credit Card",      CADSingleTest},
N{'8',   "Reader & Modem",   otherIOTest},
N{'9',   "Sensor",           sensorSingleTest},
N{'a',   "RTC",              RTCTest},
N{'b',   "EPD",              EPDSingleTest},
N{'c',   "CPU Sleep",        suspendSystem},
N//{'d',   "SuperCap",         SuperCapTest},
N{'q',   "Quit",             exitTest},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
N//{'a',   "Reader Flash",     sFlashTest},
N//{'7',   "Credit Card",      CADSingleTest},
N//{'8',   "Modem & Reader",   ModemAndReaderTest},
N//{'9',   "sensor",           radarSingleTest},
N
N
N//{'2',   "Smart Card",      smartCardTest},
N//{'3',   "Flash",    sFlashTest},
N//{'2',   "Modem",            modemTest},
N
N
Nstatic HWTesterItem   toolsFunctionItem[] = {   
N//{'1',   "Adjust Key Pad",     toolsAdjustKeypad},  
N//{'2',   "ID Config",          idConfig}, 
N//{'3',   "12V Power",          enable12vPower}, 
N//{'4',   "Suspend System",     suspendSystem},
N//{'5',   "Battery Select",     batterySelect},
N//{'6',   "Buzzer Loop",        buzzerLoop},
N//{'7',   "Modem Set to High Speed",    modemSetHighSpeed},
N{'1',   "Set Device ID",    setDeviceIDTool},
N{'2',   "Get Device ID",    getDeviceIDTool},
N{'3',   "CardRead Show ID", readerGetCN},
N{'4',   "New Radar Tool",   NewRadarTool},
N//{'4',   "New Radar Test",   NEWradarTest},
N//{'4',   "Radar Test",       radarTest},
N{'5',   "Radar Power Set",  radarPowerSet},
N{'6',   "USB CAM Test",     usbCamTest},
N{'7',   "USB CAM Power Set", usbCamPowerSet},
N//{'8',   "Lidar Test",       lidarTest},
N//{'9',   "Lidar Power Set",  lidarPowerSet},
N//{'8',   "EPD Burning Test", epdBurningTest},
N{'8',   "Calibration",      calibrationConfig},
N//{'c',   "versionQueryTool", versionQueryTool},
N{'9',   "EPD Tool", EPDflashTool},
N{'a',   "Radar OTA", RadarOTATool},
N{'b',   "KeyPad Tool", KeyPadTool},
N{'c',   "Set Modem to High Speed", ModemHSpdTool},
N{'d',   "Set RTC", RTCTool},
N//{'e',   "New Radar Set", NEWradarSet},
N//{'e',   "Modem Tool", ModemTool},
N//{'f',   "NTP Tool", NTPTool},
N{'q',   "Quit",            exitTest },//exitTest
N//{'d',   NULL,               blankFunction},
N{0,     NULL,               NULL}};
X{0,     0,               0}};
N
Nstatic ListItem calibrationListItem[] = {
N//{'0',"Gyroscope"},
N{'0',"MEMS"},
N{'1',"Lidar1"},
N{'2',"Lidar2"},
N{'q',"Quit"},
N//{'2',"Radar"},
N{0,     NULL}
X{0,     0}
N};
N
N
Nstatic ListItem EPDflashToolListItem[] = {
N//{'0',"query"},
N{'0',"FACTORY TEST"},
N//{'1',"SD BURN"},
N{'1',"EPD VCOM"},
N{'2',"EPD BURNING TEST"},
N{'3',"EPD All BLACK"},
N{'4',"EPD All WHITE"},
N{'5',"EPD DISP"},
N{'q',"Quit"},
N{0,     NULL}
X{0,     0}
N};
N
Nstatic ListItem EPDEmergentToolListItem[] = {
N{'0',"EPD EMERGENT BURN"},
N{'q',"Quit"},
N{0,     NULL}
X{0,     0}
N};
N
Nstatic ListItem RadarOTAToolListItem[] = {
N{'0',"Radar1 OTA"},
N{'1',"Radar2 OTA"},
N{'q',"Quit"},
N{0,     NULL}
X{0,     0}
N};
N
Nstatic ListItem NewRadarToolListItem[] = {
N{'0',"Set Default RadarA"},
N{'1',"Set Default RadarB"},
N{'2',"Set RadarA Parameter"},
N{'3',"Set RadarB Parameter"},
N{'4',"New Radar Test"},
N{'5',"RadarA OTA"},
N{'6',"RadarB OTA"},
N{'q',"Quit"},
N{0,     NULL}
X{0,     0}
N};
N/*
Nstatic ListItem NewRadarToolListItem[] = {
N{'0',"Set RadarA Parameter"},
N{'1',"Set RadarB Parameter"},
N{'2',"New Radar Test"},
N{'q',"Quit"},
N{0,     NULL}
N};
N*/
N
Ntypedef struct
N{
N    char    charItem;
N    char*   itemName;
N    BOOL    result;
N}TestResult;
N
N/*-----------------------------------------*/
N/* prototypes of static functions          */
N/*-----------------------------------------*/
N/////////////////////Tool function/////////////////////////
Nstatic void SetMTPCRC(uint8_t index,uint8_t* MTPBuf)
N{
N    uint16_t crctemp;
N    CRCTool_Init(2);
N    //crctemp = CRCTool_Table(MTPBuf, MTPBuf[2]+3); 
N    crctemp = CRCTool_Table(MTPBuf+18*index, *(MTPBuf+18*index+2)+3); 
N    //MTPBuf[MTPBuf[2]+3] = crctemp >> 8;
N    //MTPBuf[MTPBuf[2]+4] = crctemp & 0x00FF;
N    *(MTPBuf + 18*index + *(MTPBuf+18*index+2)+3) = crctemp >> 8;
N    *(MTPBuf + 18*index + *(MTPBuf+18*index+2)+4) = crctemp & 0x00FF;
N}
N
Nstatic void InitMTPvalue(uint8_t index,uint8_t* MTPBuf)
N{
N    for(int k=0;k<(*(MTPBuf+18*index+2));k++)
N        *(MTPBuf + 18*index + 3 + k) = 0x82;
N}
N
Nstatic void MTPCmdprint(uint8_t index,uint8_t* MTPBuf)
N{
N    
N    vTaskDelay(300/portTICK_RATE_MS);
X    vTaskDelay(300/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    for(int k=0;k<(*(MTPBuf+18*index+2)+5);k++)
N    {
N        while ((inpw(REG_UART0_FSR) & (1<<23))); //waits for TX_FULL bit is clear
X        while (((*((volatile unsigned int *)((0xB8000000+0x18)))) & (1<<23))); 
N            outpw(REG_UART0_THR, *(MTPBuf+18*index+k));
X            *((volatile unsigned int *)((0xB8000000+0x00))) = *(MTPBuf+18*index+k);
N    }
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    /*    
N    for(int k=0;k<(*(MTPBuf+2)+5);k++)
N    {
N        while ((inpw(REG_UART0_FSR) & (1<<23))); //waits for TX_FULL bit is clear
N            outpw(REG_UART0_THR, *(MTPBuf+k));
N    }
N    */
N}
Nstatic void MTPCmdprintEx(uint8_t index,uint8_t* MTPBuf)
N{
N    
N    //vTaskDelay(300/portTICK_RATE_MS);
N    for(int k=0;k<(*(MTPBuf+18*index+2)+5);k++)
N    {
N        while ((inpw(REG_UART0_FSR) & (1<<23))); //waits for TX_FULL bit is clear
X        while (((*((volatile unsigned int *)((0xB8000000+0x18)))) & (1<<23))); 
N            outpw(REG_UART0_THR, *(MTPBuf+18*index+k));
X            *((volatile unsigned int *)((0xB8000000+0x00))) = *(MTPBuf+18*index+k);
N    }
N    //vTaskDelay(100/portTICK_RATE_MS);
N
N}
N
Nstatic UINT8 getTerminalChar(void)
N{
N    UINT8 charTmp;
N    charTmp = sysGetChar();
N//    terninalPrintf("getTerminalChar: %c ", charTmp);
N    if((charTmp >= 'A') && (charTmp <= 'Z'))
N    {
N        return charTmp + 'a' - 'A';
N    }
N    else if(((charTmp >= 'a') && (charTmp <= 'z')) || ((charTmp >= '0') && (charTmp <= '9')) ||  (charTmp == ' '))
N    {
N        return charTmp;
N    }
N    else
N    {
N        return 0;
N    }
N}
N
Nstatic char userResponseLoop(void)
N{
N    while(sysIsKbHit())
N    {//empty registor buffer
N#include <TMPA900.H>
L 1 "C:\Keil\ARM\Inc\Toshiba\TMPA900.H" 1
N/******************************************************************************/
N/*  This file is part of the uVision/ARM development tools                    */
N/*  Copyright KEIL - An ARM Company 2002-2009                                 */
N/******************************************************************************/
N/*                                                                            */
N/*  TMPA900.h:  Header file for Toshiba TMPA900 Device Series                 */
N/*                                                                            */
N/******************************************************************************/
N
N#ifndef _TMPA900CM_H_
N#define _TMPA900CM_H_
N
Ntypedef	unsigned char		UINT8_t;		  /* unsigned  8bit  */
Ntypedef unsigned short	UINT16_t;		/* unsigned 16bit	*/
Ntypedef	unsigned long		UINT32_t;		  /* unsigned 32bit	*/
N/*
N * --------------------------------------------------------------------------
N *   Macro Define
N * --------------------------------------------------------------------------
N */
N#define MADDRESS_ACCESS		1	/* use address for UDC2AB	*/
N
N
N#define	IO_0_Base				(0xF0000000)
N#define	SysCtrl_Base			(IO_0_Base+0x00000)
N#define	WDT_Base				(IO_0_Base+0x10000)
N#define	PMC_Base				(IO_0_Base+0x20000)
N#define	RTC_MLD_Base			(IO_0_Base+0x30000)
N#define	TMR16_01_Base			(IO_0_Base+0x40000)
N#define	TMR16_23_Base			(IO_0_Base+0x41000)
N#define	TMR16_45_Base			(IO_0_Base+0x42000)
N#define	PLLCG_Base				(IO_0_Base+0x50000)
N#define	TSI_Base				(IO_0_Base+0x60000)
N#define	I2C0_Base				(IO_0_Base+0x70000)
N#define	I2C1_Base				(IO_0_Base+0x71000)
N#define	ADC_Base				(IO_0_Base+0x80000)
N#define	OFD_Base				(IO_0_Base+0x90000)
N#define	EBI_Base				(IO_0_Base+0xA0000)
N#define	LCDCOP_Base				(IO_0_Base+0xB0000)
N/* ---- */
N#define	IO_1_Base				(0xF0800000)
N#define	IO_1_GPIO_Base			(IO_1_Base+0x00000)
N#define	GPIO_A_Base				(IO_1_GPIO_Base+0x0000)
N#define	GPIO_B_Base				(IO_1_GPIO_Base+0x1000)
N#define	GPIO_C_Base				(IO_1_GPIO_Base+0x2000)
N#define	GPIO_D_Base				(IO_1_GPIO_Base+0x3000)
N#define	GPIO_F_Base				(IO_1_GPIO_Base+0x5000)
N#define	GPIO_G_Base				(IO_1_GPIO_Base+0x6000)
N#define	GPIO_J_Base				(IO_1_GPIO_Base+0x8000)
N#define	GPIO_K_Base				(IO_1_GPIO_Base+0x9000)
N#define	GPIO_L_Base				(IO_1_GPIO_Base+0xA000)
N#define	GPIO_M_Base				(IO_1_GPIO_Base+0xB000)
N#define	GPIO_N_Base				(IO_1_GPIO_Base+0xC000)
N#define	GPIO_R_Base				(IO_1_GPIO_Base+0xE000)
N#define	GPIO_T_Base				(IO_1_GPIO_Base+0xF000)
N#define	GPIO_U_Base				(IO_1_GPIO_Base+0x4000)
N#define	GPIO_V_Base				(IO_1_GPIO_Base+0x7000)
N/* ---- */
N#define	IO_3_Base				(0xF2000000)
N#define	UART0_Base				(IO_3_Base+0x00000)
N#define	UART1_Base				(IO_3_Base+0x01000)
N#define	SSP0_Base				(IO_3_Base+0x02000)
N#define	SSP1_Base				(IO_3_Base+0x03000)
N#define	UART2_Base				(IO_3_Base+0x04000)
N#define	NDFC_Base				(IO_3_Base+0x10000)
N#define	CMSI_Base				(IO_3_Base+0x20000)
N#define	I2S_Base				(IO_3_Base+0x40000)
N#define	LCDDA_Base				(IO_3_Base+0x50000)
N/* ---- */
N#define	IO_4_Base				(0xF4000000)
N#define	INTC_Base				(IO_4_Base+0x000000)
N#define	DMAC_Base				(IO_4_Base+0x100000)
N#define	LCDC_Base				(IO_4_Base+0x200000)
N#define	MPMC0_DMC_Base			(IO_4_Base+0x300000)
N#define	MPMC0_SMC_Base			(IO_4_Base+0x301000)
N#define	MPMC1_DMC_Base			(IO_4_Base+0x310000)
N#define	MPMC1_SMC_Base			(IO_4_Base+0x311000)
N#define	UDC2_Base				(IO_4_Base+0x400000)
N#define	USBH_Base				(IO_4_Base+0x500000)
N
N/* ======================================================================== */
N
N/* ------------------------------------------------------------------------ */
N/* System Controller		 : 0xF0000000	*/
N#define	Remap					*((volatile UINT32_t *)(SysCtrl_Base+0x0004))	/* Reset memory map (REMAP) */
N
N/* ------------------------------------------------------------------------ */
N/* Clock Controller			 : 0xF0050000	*/
N#define	SYSCR0					*((volatile UINT32_t *)(PLLCG_Base+0x0000))	/* System Control Register 0 */
N#define	SYSCR1					*((volatile UINT32_t *)(PLLCG_Base+0x0004))	/* System Control Register 1 */
N#define	SYSCR2					*((volatile UINT32_t *)(PLLCG_Base+0x0008))	/* System Control Register 2 */
N#define	SYSCR3					*((volatile UINT32_t *)(PLLCG_Base+0x000C))	/* System Control Register 3 */
N#define	SYSCR4					*((volatile UINT32_t *)(PLLCG_Base+0x0010))	/* System Control Register 4 */
N#define	SYSCR5					*((volatile UINT32_t *)(PLLCG_Base+0x0014))	/* System Control Register 5 */
N#define	SYSCR6					*((volatile UINT32_t *)(PLLCG_Base+0x0018))	/* System Control Register 6 */
N#define	SYSCR7					*((volatile UINT32_t *)(PLLCG_Base+0x001C))	/* System Control Register 7 */
N#define	SYSCR8					*((volatile UINT32_t *)(PLLCG_Base+0x0020))	/* System Control Register 8 */
N
N#define	CLKCR5					*((volatile UINT32_t *)(PLLCG_Base+0x0054))	/* Clock Control Register 5 */
N
N/* ------------------------------------------------------------------------ */
N/* INTC						 : 0xF4000000	*/
N#define	VICIRQSTATUS			*((volatile UINT32_t *)(INTC_Base+0x0000))	/* IRQ Status Register */
N#define	VICFIQSTATUS			*((volatile UINT32_t *)(INTC_Base+0x0004))	/* FIQ Status Register */
N#define	VICRAWINTR				*((volatile UINT32_t *)(INTC_Base+0x0008))	/* Raw Interrupt Status Register */
N#define	VICINTSELECT			*((volatile UINT32_t *)(INTC_Base+0x000C))	/* Interrupt Select Register  */
N#define	VICINTENABLE			*((volatile UINT32_t *)(INTC_Base+0x0010))	/* Interrupt Enable Register */
N#define	VICINTENCLEAR			*((volatile UINT32_t *)(INTC_Base+0x0014))	/* Interrupt Enable Clear Register */
N#define	VICSOFTINT				*((volatile UINT32_t *)(INTC_Base+0x0018))	/* Software Interrupt Register */
N#define	VICSOFTINTCLEAR		*((volatile UINT32_t *)(INTC_Base+0x001C))	/* Software Interrupt Clear Register */
N#define	VICPROTECTION			*((volatile UINT32_t *)(INTC_Base+0x0020))	/* Protection Enable Register */
N#define	VICSWPRIORITYMASK	*((volatile UINT32_t *)(INTC_Base+0x0024))	/* Software Priority Mask Register */
N/* #define Reserved				*((volatile UINT32_t *)(INTC_Base+0x0028)) */
N/* ---- */
N#define	VICVECTADDR0			*((volatile UINT32_t *)(INTC_Base+0x0100))	/* Vector Address 0 Register */
N#define	VICVECTADDR1			*((volatile UINT32_t *)(INTC_Base+0x0104))	/* Vector Address 1 Register */
N#define	VICVECTADDR2			*((volatile UINT32_t *)(INTC_Base+0x0108))	/* Vector Address 2 Register */
N#define	VICVECTADDR3			*((volatile UINT32_t *)(INTC_Base+0x010C))	/* Vector Address 3 Register */
N#define	VICVECTADDR4			*((volatile UINT32_t *)(INTC_Base+0x0110))	/* Vector Address 4 Register */
N#define	VICVECTADDR5			*((volatile UINT32_t *)(INTC_Base+0x0114))	/* Vector Address 5 Register */
N#define	VICVECTADDR6			*((volatile UINT32_t *)(INTC_Base+0x0118))	/* Vector Address 6 Register */
N#define	VICVECTADDR7			*((volatile UINT32_t *)(INTC_Base+0x011C))	/* Vector Address 7 Register */
N#define	VICVECTADDR8			*((volatile UINT32_t *)(INTC_Base+0x0120))	/* Vector Address 8 Register */
N#define	VICVECTADDR9			*((volatile UINT32_t *)(INTC_Base+0x0124))	/* Vector Address 9 Register */
N#define	VICVECTADDR10			*((volatile UINT32_t *)(INTC_Base+0x0128))	/* Vector Address 10 Register */
N#define	VICVECTADDR11			*((volatile UINT32_t *)(INTC_Base+0x012C))	/* Vector Address 11 Register */
N#define	VICVECTADDR12			*((volatile UINT32_t *)(INTC_Base+0x0130))	/* Vector Address 12 Register */
N#define	VICVECTADDR13			*((volatile UINT32_t *)(INTC_Base+0x0134))	/* Vector Address 13 Register */
N#define	VICVECTADDR14			*((volatile UINT32_t *)(INTC_Base+0x0138))	/* Vector Address 14 Register */
N#define	VICVECTADDR15			*((volatile UINT32_t *)(INTC_Base+0x013C))	/* Vector Address 15 Register */
N#define	VICVECTADDR16			*((volatile UINT32_t *)(INTC_Base+0x0140))	/* Vector Address 16 Register */
N#define	VICVECTADDR17			*((volatile UINT32_t *)(INTC_Base+0x0144))	/* Vector Address 17 Register */
N#define	VICVECTADDR18			*((volatile UINT32_t *)(INTC_Base+0x0148))	/* Vector Address 18 Register */
N/* #define VICVECTADDR19			*((volatile UINT32_t *)(INTC_Base+0x014C))	Vector Address 19 Register */
N#define	VICVECTADDR20			*((volatile UINT32_t *)(INTC_Base+0x0150))	/* Vector Address 20 Register */
N#define	VICVECTADDR21			*((volatile UINT32_t *)(INTC_Base+0x0154))	/* Vector Address 21 Register */
N#define	VICVECTADDR22			*((volatile UINT32_t *)(INTC_Base+0x0158))	/* Vector Address 22 Register */
N#define	VICVECTADDR23			*((volatile UINT32_t *)(INTC_Base+0x015C))	/* Vector Address 23 Register */
N/* #define	VICVECTADDR24			*((volatile UINT32_t *)(INTC_Base+0x0160))	Vector Address 24 Register */
N/* #define	VICVECTADDR25			*((volatile UINT32_t *)(INTC_Base+0x0164))	Vector Address 25 Register */
N#define	VICVECTADDR26			*((volatile UINT32_t *)(INTC_Base+0x0168))	/* Vector Address 26 Register */
N#define	VICVECTADDR27			*((volatile UINT32_t *)(INTC_Base+0x016C))	/* Vector Address 27 Register */
N#define	VICVECTADDR28			*((volatile UINT32_t *)(INTC_Base+0x0170))	/* Vector Address 28 Register */
N#define	VICVECTADDR29			*((volatile UINT32_t *)(INTC_Base+0x0174))	/* Vector Address 29 Register */
N#define	VICVECTADDR30			*((volatile UINT32_t *)(INTC_Base+0x0178))	/* Vector Address 30 Register */
N#define	VICVECTADDR31			*((volatile UINT32_t *)(INTC_Base+0x017C))	/* Vector Address 31 Register */
N/* ---- */
N#define	VICVECTPRIORITY0		*((volatile UINT32_t *)(INTC_Base+0x0200))	/* Vector Priority 0 Register */
N#define	VICVECTPRIORITY1		*((volatile UINT32_t *)(INTC_Base+0x0204))	/* Vector Priority 1 Register */
N#define	VICVECTPRIORITY2		*((volatile UINT32_t *)(INTC_Base+0x0208))	/* Vector Priority 2 Register */
N#define	VICVECTPRIORITY3		*((volatile UINT32_t *)(INTC_Base+0x020C))	/* Vector Priority 3 Register */
N#define	VICVECTPRIORITY4		*((volatile UINT32_t *)(INTC_Base+0x0210))	/* Vector Priority 4 Register */
N#define	VICVECTPRIORITY5		*((volatile UINT32_t *)(INTC_Base+0x0214))	/* Vector Priority 5 Register */
N#define	VICVECTPRIORITY6		*((volatile UINT32_t *)(INTC_Base+0x0218))	/* Vector Priority 6 Register */
N#define	VICVECTPRIORITY7		*((volatile UINT32_t *)(INTC_Base+0x021C))	/* Vector Priority 7 Register */
N#define	VICVECTPRIORITY8		*((volatile UINT32_t *)(INTC_Base+0x0220))	/* Vector Priority 8 Register */
N#define	VICVECTPRIORITY9		*((volatile UINT32_t *)(INTC_Base+0x0224))	/* Vector Priority 9 Register */
N#define	VICVECTPRIORITY10		*((volatile UINT32_t *)(INTC_Base+0x0228))	/* Vector Priority 10 Register */
N#define	VICVECTPRIORITY11		*((volatile UINT32_t *)(INTC_Base+0x022C))	/* Vector Priority 11 Register */
N#define	VICVECTPRIORITY12		*((volatile UINT32_t *)(INTC_Base+0x0230))	/* Vector Priority 12 Register */
N#define	VICVECTPRIORITY13		*((volatile UINT32_t *)(INTC_Base+0x0234))	/* Vector Priority 13 Register */
N#define	VICVECTPRIORITY14		*((volatile UINT32_t *)(INTC_Base+0x0238))	/* Vector Priority 14 Register */
N#define	VICVECTPRIORITY15		*((volatile UINT32_t *)(INTC_Base+0x023C))	/* Vector Priority 15 Register */
N#define	VICVECTPRIORITY16		*((volatile UINT32_t *)(INTC_Base+0x0240))	/* Vector Priority 16 Register */
N#define	VICVECTPRIORITY17		*((volatile UINT32_t *)(INTC_Base+0x0244))	/* Vector Priority 17 Register */
N#define	VICVECTPRIORITY18		*((volatile UINT32_t *)(INTC_Base+0x0248))	/* Vector Priority 18 Register */
N/* #define	VICVECTPRIORITY19		*((volatile UINT32_t *)(INTC_Base+0x024C))	Vector Priority 19 Register */
N#define	VICVECTPRIORITY20		*((volatile UINT32_t *)(INTC_Base+0x0250))	/* Vector Priority 20 Register */
N#define	VICVECTPRIORITY21		*((volatile UINT32_t *)(INTC_Base+0x0254))	/* Vector Priority 21 Register */
N#define	VICVECTPRIORITY22		*((volatile UINT32_t *)(INTC_Base+0x0258))	/* Vector Priority 22 Register */
N#define	VICVECTPRIORITY23		*((volatile UINT32_t *)(INTC_Base+0x025C))	/* Vector Priority 23 Register */
N/* #define	VICVECTPRIORITY24		*((volatile UINT32_t *)(INTC_Base+0x0260))	Vector Priority 24 Register */
N/* #define	VICVECTPRIORITY25		*((volatile UINT32_t *)(INTC_Base+0x0264))	Vector Priority 25 Register */
N#define	VICVECTPRIORITY26		*((volatile UINT32_t *)(INTC_Base+0x0268))	/* Vector Priority 26 Register */
N#define	VICVECTPRIORITY27		*((volatile UINT32_t *)(INTC_Base+0x026C))	/* Vector Priority 27 Register */
N#define	VICVECTPRIORITY28		*((volatile UINT32_t *)(INTC_Base+0x0270))	/* Vector Priority 28 Register */
N#define	VICVECTPRIORITY29		*((volatile UINT32_t *)(INTC_Base+0x0274))	/* Vector Priority 29 Register */
N#define	VICVECTPRIORITY30		*((volatile UINT32_t *)(INTC_Base+0x0278))	/* Vector Priority 30 Register */
N#define	VICVECTPRIORITY31		*((volatile UINT32_t *)(INTC_Base+0x027C))	/* Vector Priority 31 Register */
N/* ---- */
N#define	VICADDRESS				*((volatile UINT32_t *)(INTC_Base+0x0F00))	/* Vector Address Register */
N
N/* ------------------------------------------------------------------------ */
N/* DMAC						 : 0xF4100000	*/
N#define	DMACIntStatus			*((volatile UINT32_t *)(DMAC_Base+0x0000))	/* DMAC Interrupt Status Register */
N#define	DMACIntTCStatus			*((volatile UINT32_t *)(DMAC_Base+0x0004))	/* DMAC Interrupt Terminal Count Status Register */
N#define	DMACIntTCClear			*((volatile UINT32_t *)(DMAC_Base+0x0008))	/* DMAC Interrupt Terminal Count Clear Register */
N#define	DMACIntErrorStatus		*((volatile UINT32_t *)(DMAC_Base+0x000C))	/* DMAC Interrupt Error Status Register */
N#define	DMACIntErrClr			*((volatile UINT32_t *)(DMAC_Base+0x0010))	/* DMAC Interrupt Error Clear Register */
N#define	DMACRawIntTCStatus		*((volatile UINT32_t *)(DMAC_Base+0x0014))	/* DMAC Raw Interrupt Terminal Count Status Register */
N#define	DMACRawIntErrorStatus	*((volatile UINT32_t *)(DMAC_Base+0x0018))	/* DMAC Raw Error Interrupt Status Register */
N#define	DMACEnbldChns			*((volatile UINT32_t *)(DMAC_Base+0x001C))	/* DMAC Enabled Channel Register */
N#define	DMACSoftBReq			*((volatile UINT32_t *)(DMAC_Base+0x0020))	/* DMAC Software Burst Request Register */
N#define	DMACSoftSReq			*((volatile UINT32_t *)(DMAC_Base+0x0024))	/* DMAC Software Single Request Register */
N/* #define Reserved				*((volatile UINT32_t *)(DMAC_Base+0x0028)) */
N/* #define Reserved				*((volatile UINT32_t *)(DMAC_Base+0x002C)) */
N#define	DMACConfiguration		*((volatile UINT32_t *)(DMAC_Base+0x0030))	/* DMAC Configuration Register */
N/* #define Reserved				*((volatile UINT32_t *)(DMAC_Base+0x0034)) */
N/* ---- */
N#define	DMACC0SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x0100))	/* DMAC Channel0 Source Address Register */
N#define	DMACC0DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x0104))	/* DMAC Channel0 Destination Address Register */
N#define	DMACC0LLI				*((volatile UINT32_t *)(DMAC_Base+0x0108))	/* DMAC Channel0 Linked List Item Register */
N#define	DMACC0Control			*((volatile UINT32_t *)(DMAC_Base+0x010C))	/* DMAC Channel0 Control Register */
N#define	DMACC0Configuration		*((volatile UINT32_t *)(DMAC_Base+0x0110))	/* DMAC Channel0 Configuration Register */
N/* ---- */
N#define	DMACC1SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x0120))	/* DMAC Channel1 Source Address Register */
N#define	DMACC1DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x0124))	/* DMAC Channel1 Destination Address Register */
N#define	DMACC1LLI				*((volatile UINT32_t *)(DMAC_Base+0x0128))	/* DMAC Channel1 Linked List Item Register */
N#define	DMACC1Control			*((volatile UINT32_t *)(DMAC_Base+0x012C))	/* DMAC Channel1 Control Register */
N#define	DMACC1Configuration		*((volatile UINT32_t *)(DMAC_Base+0x0130))	/* DMAC Channel1 Configuration Register */
N/* ---- */
N#define	DMACC2SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x0140))	/* DMAC Channel2 Source Address Register */
N#define	DMACC2DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x0144))	/* DMAC Channel2 Destination Address Register */
N#define	DMACC2LLI				*((volatile UINT32_t *)(DMAC_Base+0x0148))	/* DMAC Channel2 Linked List Item Register */
N#define	DMACC2Control			*((volatile UINT32_t *)(DMAC_Base+0x014C))	/* DMAC Channel2 Control Register */
N#define	DMACC2Configuration		*((volatile UINT32_t *)(DMAC_Base+0x0150))	/* DMAC Channel2 Configuration Register */
N/* ---- */
N#define	DMACC3SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x0160))	/* DMAC Channel3 Source Address Register */
N#define	DMACC3DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x0164))	/* DMAC Channel3 Destination Address Register */
N#define	DMACC3LLI				*((volatile UINT32_t *)(DMAC_Base+0x0168))	/* DMAC Channel3 Linked List Item Register */
N#define	DMACC3Control			*((volatile UINT32_t *)(DMAC_Base+0x016C))	/* DMAC Channel3 Control Register */
N#define	DMACC3Configuration		*((volatile UINT32_t *)(DMAC_Base+0x0170))	/* DMAC Channel3 Configuration Register */
N/* ---- */
N#define	DMACC4SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x0180))	/* DMAC Channel4 Source Address Register */
N#define	DMACC4DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x0184))	/* DMAC Channel4 Destination Address Register */
N#define	DMACC4LLI				*((volatile UINT32_t *)(DMAC_Base+0x0188))	/* DMAC Channel4 Linked List Item Register */
N#define	DMACC4Control			*((volatile UINT32_t *)(DMAC_Base+0x018C))	/* DMAC Channel4 Control Register */
N#define	DMACC4Configuration		*((volatile UINT32_t *)(DMAC_Base+0x0190))	/* DMAC Channel4 Configuration Register */
N/* ---- */
N#define	DMACC5SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x01A0))	/* DMAC Channel5 Source Address Register */
N#define	DMACC5DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x01A4))	/* DMAC Channel5 Destination Address Register */
N#define	DMACC5LLI				*((volatile UINT32_t *)(DMAC_Base+0x01A8))	/* DMAC Channel5 Linked List Item Register */
N#define	DMACC5Control			*((volatile UINT32_t *)(DMAC_Base+0x01AC))	/* DMAC Channel5 Control Register */
N#define	DMACC5Configuration		*((volatile UINT32_t *)(DMAC_Base+0x01B0))	/* DMAC Channel5 Configuration Register */
N/* ---- */
N#define	DMACC6SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x01C0))	/* DMAC Channel6 Source Address Register */
N#define	DMACC6DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x01C4))	/* DMAC Channel6 Destination Address Register */
N#define	DMACC6LLI				*((volatile UINT32_t *)(DMAC_Base+0x01C8))	/* DMAC Channel6 Linked List Item Register */
N#define	DMACC6Control			*((volatile UINT32_t *)(DMAC_Base+0x01CC))	/* DMAC Channel6 Control Register */
N#define	DMACC6Configuration		*((volatile UINT32_t *)(DMAC_Base+0x01D0))	/* DMAC Channel6 Configuration Register */
N/* ---- */
N#define	DMACC7SrcAddr			*((volatile UINT32_t *)(DMAC_Base+0x01E0))	/* DMAC Channel7 Source Address Register */
N#define	DMACC7DestAddr			*((volatile UINT32_t *)(DMAC_Base+0x01E4))	/* DMAC Channel7 Destination Address Register */
N#define	DMACC7LLI				*((volatile UINT32_t *)(DMAC_Base+0x01E8))	/* DMAC Channel7 Linked List Item Register */
N#define	DMACC7Control			*((volatile UINT32_t *)(DMAC_Base+0x01EC))	/* DMAC Channel7 Control Register */
N#define	DMACC7Configuration		*((volatile UINT32_t *)(DMAC_Base+0x01F0))	/* DMAC Channel7 Configuration Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO A		 			 : 0xF0800000	*/
N#define	GPIOADATA				*((volatile UINT32_t *)(GPIO_A_Base+0x03FC))	/* PortA Data Regsiter */
N/* #define	GPIOADIR				*((volatile UINT32_t *)(GPIO_A_Base+0x0400))	 PortA Data Direction Register */
N/* ---- */
N/* #define	GPIOAFR1				*((volatile UINT32_t *)(GPIO_A_Base+0x0424))	 PortA Function Register1 */
N/* #define	GPIOAFR2				*((volatile UINT32_t *)(GPIO_A_Base+0x0428))	 PortA Function Register2 */
N/* ---- */
N#define	GPIOAIS					*((volatile UINT32_t *)(GPIO_A_Base+0x0804))	/* PortA Interrupt Selection Register (Level and Edge) */
N#define	GPIOAIBE				*((volatile UINT32_t *)(GPIO_A_Base+0x0808))	/* PortA Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIOAIEV				*((volatile UINT32_t *)(GPIO_A_Base+0x080C))	/* PortA Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIOAIE					*((volatile UINT32_t *)(GPIO_A_Base+0x0810))	/* PortA Interrupt Enable Register */
N#define	GPIOARIS				*((volatile UINT32_t *)(GPIO_A_Base+0x0814))	/* PortA Interrupt Status Register (Raw) */
N#define	GPIOAMIS				*((volatile UINT32_t *)(GPIO_A_Base+0x0818))	/* PortA Interrupt Status Register (Masked) */
N#define	GPIOAIC					*((volatile UINT32_t *)(GPIO_A_Base+0x081C))	/* PortA Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOAODE				*((volatile UINT32_t *)(GPIO_AB_Base+0x0C00))	 PortA Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO B					 : 0xF0801000	*/
N#define	GPIOBDATA				*((volatile UINT32_t *)(GPIO_B_Base+0x03FC))	/* PortB Data Regsiter */
N/* #define	GPIOBDIR				*((volatile UINT32_t *)(GPIO_B_Base+0x0400))	 PortB Data Direction Register */
N/* ---- */
N#define	GPIOBFR1				*((volatile UINT32_t *)(GPIO_B_Base+0x0424))	/* PortB Function Register1 */
N#define	GPIOBFR2				*((volatile UINT32_t *)(GPIO_B_Base+0x0428))	/* PortB Function Register2 */
N/* ---- */
N/* #define	GPIOBIS					*((volatile UINT32_t *)(GPIO_B_Base+0x0804))	 PortB Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOBIBE				*((volatile UINT32_t *)(GPIO_B_Base+0x0808))	 PortB Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOBIEV				*((volatile UINT32_t *)(GPIO_B_Base+0x080C))	 PortB Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOBIE					*((volatile UINT32_t *)(GPIO_B_Base+0x0810))	 PortB Interrupt Enable Register */
N/* #define	GPIOBRIS				*((volatile UINT32_t *)(GPIO_B_Base+0x0814))	 PortB Interrupt Status Register (Raw) */
N/* #define	GPIOBMIS				*((volatile UINT32_t *)(GPIO_B_Base+0x0818))	 PortB Interrupt Status Register (Masked) */
N/* #define	GPIOBIC					*((volatile UINT32_t *)(GPIO_B_Base+0x081C))	 PortB Interrupt Clear Register */
N/* ---- */
N#define	GPIOBODE				*((volatile UINT32_t *)(GPIO_B_Base+0x0C00))	/* PortB Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO C					 : 0xF0802000	*/
N#define	GPIOCDATA				*((volatile UINT32_t *)(GPIO_C_Base+0x03FC))	/* PortC Data Regsiter */
N#define	GPIOCDIR				*((volatile UINT32_t *)(GPIO_C_Base+0x0400))	/* PortC Data Direction Register */
N/* ---- */
N#define	GPIOCFR1				*((volatile UINT32_t *)(GPIO_C_Base+0x0424))	/* PortC Function Register1 */
N#define	GPIOCFR2				*((volatile UINT32_t *)(GPIO_C_Base+0x0428))	/* PortC Function Register2 */
N/* ---- */
N#define	GPIOCIS					*((volatile UINT32_t *)(GPIO_C_Base+0x0804))	/* PortC Interrupt Selection Register (Level and Edge) */
N#define	GPIOCIBE				*((volatile UINT32_t *)(GPIO_C_Base+0x0808))	/* PortC Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIOCIEV				*((volatile UINT32_t *)(GPIO_C_Base+0x080C))	/* PortC Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIOCIE					*((volatile UINT32_t *)(GPIO_C_Base+0x0810))	/* PortC Interrupt Enable Register */
N#define	GPIOCRIS				*((volatile UINT32_t *)(GPIO_C_Base+0x0814))	/* PortC Interrupt Status Register (Raw) */
N#define	GPIOCMIS				*((volatile UINT32_t *)(GPIO_C_Base+0x0818))	/* PortC Interrupt Status Register (Masked) */
N#define	GPIOCIC					*((volatile UINT32_t *)(GPIO_C_Base+0x081C))	/* PortC Interrupt Clear Register */
N/* ---- */
N#define	GPIOCODE				*((volatile UINT32_t *)(GPIO_C_Base+0x0C00))	/* PortC Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO D					 : 0xF0803000	*/
N#define	GPIODDATA				*((volatile UINT32_t *)(GPIO_D_Base+0x03FC))	/* PortD Data Regsiter */
N/* #define	GPIODDIR				*((volatile UINT32_t *)(GPIO_D_Base+0x0400))	 PortD Data Direction Register */
N/* ---- */
N#define	GPIODFR1				*((volatile UINT32_t *)(GPIO_D_Base+0x0424))	/* PortD Function Register1 */
N#define	GPIODFR2				*((volatile UINT32_t *)(GPIO_D_Base+0x0428))	/* PortD Function Register2 */
N/* ---- */
N#define	GPIODIS					*((volatile UINT32_t *)(GPIO_D_Base+0x0804))	/* PortD Interrupt Selection Register (Level and Edge) */
N#define	GPIODIBE				*((volatile UINT32_t *)(GPIO_D_Base+0x0808))	/* PortD Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIODIEV				*((volatile UINT32_t *)(GPIO_D_Base+0x080C))	/* PortD Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIODIE					*((volatile UINT32_t *)(GPIO_D_Base+0x0810))	/* PortD Interrupt Enable Register */
N#define	GPIODRIS				*((volatile UINT32_t *)(GPIO_D_Base+0x0814))	/* PortD Interrupt Status Register (Raw) */
N#define	GPIODMIS				*((volatile UINT32_t *)(GPIO_D_Base+0x0818))	/* PortD Interrupt Status Register (Masked) */
N#define	GPIODIC					*((volatile UINT32_t *)(GPIO_D_Base+0x081C))	/* PortD Interrupt Clear Register */
N/* ---- */
N/* #define	GPIODODE				*((volatile UINT32_t *)(GPIO_AB_Base+0x0C00))	 PortD Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO F					 : 0xF0805000	*/
N#define	GPIOFDATA				*((volatile UINT32_t *)(GPIO_F_Base+0x03FC))	/* PortF Data Regsiter */
N#define	GPIOFDIR				*((volatile UINT32_t *)(GPIO_F_Base+0x0400))	/* PortF Data Direction Register */
N/* ---- */
N#define	GPIOFFR1				*((volatile UINT32_t *)(GPIO_F_Base+0x0424))	/* PortF Function Register1 */
N#define	GPIOFFR2				*((volatile UINT32_t *)(GPIO_F_Base+0x0428))	/* PortF Function Register2 */
N/* ---- */
N#define	GPIOFIS					*((volatile UINT32_t *)(GPIO_F_Base+0x0804))	/* PortF Interrupt Selection Register (Level and Edge) */
N#define	GPIOFIBE				*((volatile UINT32_t *)(GPIO_F_Base+0x0808))	/* PortF Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIOFIEV				*((volatile UINT32_t *)(GPIO_F_Base+0x080C))	/* PortF Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIOFIE					*((volatile UINT32_t *)(GPIO_F_Base+0x0810))	/* PortF Interrupt Enable Register */
N#define	GPIOFRIS				*((volatile UINT32_t *)(GPIO_F_Base+0x0814))	/* PortF Interrupt Status Register (Raw) */
N#define	GPIOFMIS				*((volatile UINT32_t *)(GPIO_F_Base+0x0818))	/* PortF Interrupt Status Register (Masked) */
N#define	GPIOFIC					*((volatile UINT32_t *)(GPIO_F_Base+0x081C))	/* PortF Interrupt Clear Register */
N/* ---- */
N#define	GPIOFODE				*((volatile UINT32_t *)(GPIO_F_Base+0x0C00))	/* PortF Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO G					 : 0xF0806000	*/
N#define	GPIOGDATA				*((volatile UINT32_t *)(GPIO_G_Base+0x03FC))	/* PortG Data Regsiter */
N#define	GPIOGDIR				*((volatile UINT32_t *)(GPIO_G_Base+0x0400))	/* PortG Data Direction Register */
N/* ---- */
N#define	GPIOGFR1				*((volatile UINT32_t *)(GPIO_G_Base+0x0424))	/* PortG Function Register1 */
N/* #define	GPIOGFR2				*((volatile UINT32_t *)(GPIO_G_Base+0x0428))	 PortG Function Register2 */
N/* ---- */
N/* #define	GPIOGIS					*((volatile UINT32_t *)(GPIO_G_Base+0x0804))	 PortG Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOGIBE				*((volatile UINT32_t *)(GPIO_G_Base+0x0808))	 PortG Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOGIEV				*((volatile UINT32_t *)(GPIO_G_Base+0x080C))	 PortG Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOGIE					*((volatile UINT32_t *)(GPIO_G_Base+0x0810))	 PortG Interrupt Enable Register */
N/* #define	GPIOGRIS				*((volatile UINT32_t *)(GPIO_G_Base+0x0814))	 PortG Interrupt Status Register (Raw) */
N/* #define	GPIOGMIS				*((volatile UINT32_t *)(GPIO_G_Base+0x0818))	 PortG Interrupt Status Register (Masked) */
N/* #define	GPIOGIC					*((volatile UINT32_t *)(GPIO_G_Base+0x081C))	 PortG Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOGODE				*((volatile UINT32_t *)(GPIO_G_Base+0x0C00))	 PortG Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO J					 : 0xF0808000	*/
N#define	GPIOJDATA				*((volatile UINT32_t *)(GPIO_J_Base+0x03FC))	/* PortJ Data Regsiter */
N#define	GPIOJDIR				*((volatile UINT32_t *)(GPIO_J_Base+0x0400))	/* PortJ Data Direction Register */
N/* ---- */
N#define	GPIOJFR1				*((volatile UINT32_t *)(GPIO_J_Base+0x0424))	/* PortJ Function Register1 */
N#define	GPIOJFR2				*((volatile UINT32_t *)(GPIO_J_Base+0x0428))	/* PortJ Function Register2 */
N/* ---- */
N/* #define	GPIOJIS					*((volatile UINT32_t *)(GPIO_J_Base+0x0804))	 PortJ Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOJIBE				*((volatile UINT32_t *)(GPIO_J_Base+0x0808))	 PortJ Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOJIEV				*((volatile UINT32_t *)(GPIO_J_Base+0x080C))	 PortJ Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOJIE					*((volatile UINT32_t *)(GPIO_J_Base+0x0810))	 PortJ Interrupt Enable Register */
N/* #define	GPIOJRIS				*((volatile UINT32_t *)(GPIO_J_Base+0x0814))	 PortJ Interrupt Status Register (Raw) */
N/* #define	GPIOJMIS				*((volatile UINT32_t *)(GPIO_J_Base+0x0818))	 PortJ Interrupt Status Register (Masked) */
N/* #define	GPIOJIC					*((volatile UINT32_t *)(GPIO_J_Base+0x081C))	 PortJ Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOJODE				*((volatile UINT32_t *)(GPIO_J_Base+0x0C00))	 PortJ Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO K					 : 0xF0809000	*/
N#define	GPIOKDATA				*((volatile UINT32_t *)(GPIO_K_Base+0x03FC))	/* PortK Data Regsiter */
N#define	GPIOKDIR				*((volatile UINT32_t *)(GPIO_K_Base+0x0400))	/* PortK Data Direction Register */
N/* ---- */
N#define	GPIOKFR1				*((volatile UINT32_t *)(GPIO_K_Base+0x0424))	/* PortK Function Register1 */
N#define	GPIOKFR2				*((volatile UINT32_t *)(GPIO_K_Base+0x0428))	/* PortK Function Register2 */
N/* ---- */
N/* #define	GPIOKIS					*((volatile UINT32_t *)(GPIO_K_Base+0x0804))	 PortK Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOKIBE				*((volatile UINT32_t *)(GPIO_K_Base+0x0808))	 PortK Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOKIEV				*((volatile UINT32_t *)(GPIO_K_Base+0x080C))	 PortK Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOKIE					*((volatile UINT32_t *)(GPIO_K_Base+0x0810))	 PortK Interrupt Enable Register */
N/* #define	GPIOKRIS				*((volatile UINT32_t *)(GPIO_K_Base+0x0814))	 PortK Interrupt Status Register (Raw) */
N/* #define	GPIOKMIS				*((volatile UINT32_t *)(GPIO_K_Base+0x0818))	 PortK Interrupt Status Register (Masked) */
N/* #define	GPIOKIC					*((volatile UINT32_t *)(GPIO_K_Base+0x081C))	 PortK Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOKODE				*((volatile UINT32_t *)(GPIO_K_Base+0x0C00))	 PortK Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO L					 : 0xF080A000	*/
N#define	GPIOLDATA				*((volatile UINT32_t *)(GPIO_L_Base+0x03FC))	/* PortL Data Regsiter */
N/* ---- */
N#define	GPIOLDIR				*((volatile UINT32_t *)(GPIO_L_Base+0x0400))	/* PortL Data Direction Register */
N/* ---- */
N#define	GPIOLFR1				*((volatile UINT32_t *)(GPIO_L_Base+0x0424))	/* PortL Function Register1 */
N#define	GPIOLFR2				*((volatile UINT32_t *)(GPIO_L_Base+0x0428))	/* PortL Function Register2 */
N/* ---- */
N/* #define	GPIOLIS					*((volatile UINT32_t *)(GPIO_L_Base+0x0804))	 PortL Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOLIBE				*((volatile UINT32_t *)(GPIO_L_Base+0x0808))	 PortL Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOLIEV				*((volatile UINT32_t *)(GPIO_L_Base+0x080C))	 PortL Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOLIE					*((volatile UINT32_t *)(GPIO_L_Base+0x0810))	 PortL Interrupt Enable Register */
N/* #define	GPIOLRIS				*((volatile UINT32_t *)(GPIO_L_Base+0x0814))	 PortL Interrupt Status Register (Raw) */
N/* #define	GPIOLMIS				*((volatile UINT32_t *)(GPIO_L_Base+0x0818))	 PortL Interrupt Status Register (Masked) */
N/* #define	GPIOLIC					*((volatile UINT32_t *)(GPIO_L_Base+0x081C))	 PortL Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOLODE				*((volatile UINT32_t *)(GPIO_L_Base+0x0C00))	 PortL Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO M					 : 0xF080B000	*/
N#define	GPIOMDATA				*((volatile UINT32_t *)(GPIO_M_Base+0x03FC))	/* PortM Data Regsiter */
N#define	GPIOMDIR				*((volatile UINT32_t *)(GPIO_M_Base+0x0400))	/* PortM Data Direction Register */
N/* ---- */
N#define	GPIOMFR1				*((volatile UINT32_t *)(GPIO_M_Base+0x0424))	/* PortM Function Register1 */
N#define	GPIOMFR2				*((volatile UINT32_t *)(GPIO_M_Base+0x0428))	/* PortM Function Register2 */
N/* ---- */
N/* #define	GPIOMIS					*((volatile UINT32_t *)(GPIO_M_Base+0x0804))	 PortM Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOMIBE				*((volatile UINT32_t *)(GPIO_M_Base+0x0808))	 PortM Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOMIEV				*((volatile UINT32_t *)(GPIO_M_Base+0x080C))	 PortM Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOMIE					*((volatile UINT32_t *)(GPIO_M_Base+0x0810))	 PortM Interrupt Enable Register */
N/* #define	GPIOMRIS				*((volatile UINT32_t *)(GPIO_M_Base+0x0814))	 PortM Interrupt Status Register (Raw) */
N/* #define	GPIOMMIS				*((volatile UINT32_t *)(GPIO_M_Base+0x0818))	 PortM Interrupt Status Register (Masked) */
N/* #define	GPIOMIC					*((volatile UINT32_t *)(GPIO_M_Base+0x081C))	 PortM Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOMODE				*((volatile UINT32_t *)(GPIO_M_Base+0x0C00))	 PortM Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO N					 : 0xF080C000	*/
N#define	GPIONDATA				*((volatile UINT32_t *)(GPIO_N_Base+0x03FC))	/* PortN Data Regsiter */
N#define	GPIONDIR				*((volatile UINT32_t *)(GPIO_N_Base+0x0400))	/* PortN Data Direction Register */
N/* ---- */
N#define	GPIONFR1				*((volatile UINT32_t *)(GPIO_N_Base+0x0424))	/* PortN Function Register1 */
N#define	GPIONFR2				*((volatile UINT32_t *)(GPIO_N_Base+0x0428))	/* PortN Function Register2 */
N/* ---- */
N#define	GPIONIS					*((volatile UINT32_t *)(GPIO_N_Base+0x0804))	/* PortN Interrupt Selection Register (Level and Edge) */
N#define	GPIONIBE				*((volatile UINT32_t *)(GPIO_N_Base+0x0808))	/* PortN Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIONIEV				*((volatile UINT32_t *)(GPIO_N_Base+0x080C))	/* PortN Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIONIE					*((volatile UINT32_t *)(GPIO_N_Base+0x0810))	/* PortN Interrupt Enable Register */
N#define	GPIONRIS				*((volatile UINT32_t *)(GPIO_N_Base+0x0814))	/* PortN Interrupt Status Register (Raw) */
N#define	GPIONMIS				*((volatile UINT32_t *)(GPIO_N_Base+0x0818))	/* PortN Interrupt Status Register (Masked) */
N#define	GPIONIC					*((volatile UINT32_t *)(GPIO_N_Base+0x081C))	/* PortN Interrupt Clear Register */
N/* ---- */
N/* #define	GPIONODE				*((volatile UINT32_t *)(GPIO_N_Base+0x0C00))	 PortN Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO R		 			: 0xF080E000	*/
N#define	GPIORDATA				*((volatile UINT32_t *)(GPIO_R_Base+0x03FC))	/* PortR Data Regsiter */
N#define	GPIORDIR				*((volatile UINT32_t *)(GPIO_R_Base+0x0400))	/* PortR Data Direction Register */
N/* ---- */
N#define	GPIORFR1				*((volatile UINT32_t *)(GPIO_R_Base+0x0424))	/* PortR Function Register1 */
N#define	GPIORFR2				*((volatile UINT32_t *)(GPIO_R_Base+0x0428))	/* PortR Function Register2 */
N/* ---- */
N#define	GPIORIS					*((volatile UINT32_t *)(GPIO_R_Base+0x0804))	/* PortR Interrupt Selection Register (Level and Edge) */
N#define	GPIORIBE				*((volatile UINT32_t *)(GPIO_R_Base+0x0808))	/* PortR Interrupt Selection Register (Fellow edge and Both edge) */
N#define	GPIORIEV				*((volatile UINT32_t *)(GPIO_R_Base+0x080C))	/* PortR Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N#define	GPIORIE					*((volatile UINT32_t *)(GPIO_R_Base+0x0810))	/* PortR Interrupt Enable Register */
N#define	GPIORRIS				*((volatile UINT32_t *)(GPIO_R_Base+0x0814))	/* PortR Interrupt Status Register (Raw) */
N#define	GPIORMIS				*((volatile UINT32_t *)(GPIO_R_Base+0x0818))	/* PortR Interrupt Status Register (Masked) */
N#define	GPIORIC					*((volatile UINT32_t *)(GPIO_R_Base+0x081C))	/* PortR Interrupt Clear Register */
N/* ---- */
N/* #define	GPIORODE				*((volatile UINT32_t *)(GPIO_R_Base+0x0C00))	 PortR Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO T					 : 0xF080F000	*/
N#define	GPIOTDATA				*((volatile UINT32_t *)(GPIO_T_Base+0x03FC))	/* PortT Data Regsiter */
N#define	GPIOTDIR				*((volatile UINT32_t *)(GPIO_T_Base+0x0400))	/* PortT Data Direction Register */
N/* ---- */
N#define	GPIOTFR1				*((volatile UINT32_t *)(GPIO_T_Base+0x0424))	/* PortT Function Register1 */
N#define	GPIOTFR2				*((volatile UINT32_t *)(GPIO_T_Base+0x0428))	
N/* ---- */
N/* #define	GPIOTIS					*((volatile UINT32_t *)(GPIO_T_Base+0x0804))	 PortT Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOTIBE				*((volatile UINT32_t *)(GPIO_T_Base+0x0808))	 PortT Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOTIEV				*((volatile UINT32_t *)(GPIO_T_Base+0x080C))	 PortT Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOTIE					*((volatile UINT32_t *)(GPIO_T_Base+0x0810))	 PortT Interrupt Enable Register */
N/* #define	GPIOTRIS				*((volatile UINT32_t *)(GPIO_T_Base+0x0814))	 PortT Interrupt Status Register (Raw) */
N/* #define	GPIOTMIS				*((volatile UINT32_t *)(GPIO_T_Base+0x0818))	 PortT Interrupt Status Register (Masked) */
N/* #define	GPIOTIC					*((volatile UINT32_t *)(GPIO_T_Base+0x081C))	 PortT Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOTODE				*((volatile UINT32_t *)(GPIO_T_Base+0x0C00))	 PortT Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO U					 : 0xF0804000	*/
N#define	GPIOUDATA				*((volatile UINT32_t *)(GPIO_U_Base+0x03FC))	/* PortU Data Regsiter */
N#define	GPIOUDIR				*((volatile UINT32_t *)(GPIO_U_Base+0x0400))	/* PortU Data Direction Register */
N/* ---- */
N#define	GPIOUFR1				*((volatile UINT32_t *)(GPIO_U_Base+0x0424))	/* PortU Function Register1 */
N#define	GPIOUFR2				*((volatile UINT32_t *)(GPIO_U_Base+0x0428))	/* PortU Function Register2 */
N/* ---- */
N/* #define	GPIOUIS					*((volatile UINT32_t *)(GPIO_U_Base+0x0804))	 PortU Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOUIBE				*((volatile UINT32_t *)(GPIO_U_Base+0x0808))	 PortU Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOUIEV				*((volatile UINT32_t *)(GPIO_U_Base+0x080C))	 PortU Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOUIE					*((volatile UINT32_t *)(GPIO_U_Base+0x0810))	 PortU Interrupt Enable Register */
N/* #define	GPIOURIS				*((volatile UINT32_t *)(GPIO_U_Base+0x0814))	 PortU Interrupt Status Register (Raw) */
N/* #define	GPIOUMIS				*((volatile UINT32_t *)(GPIO_U_Base+0x0818))	 PortU Interrupt Status Register (Masked) */
N/* #define	GPIOUIC					*((volatile UINT32_t *)(GPIO_U_Base+0x081C))	 PortU Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOUODE				*((volatile UINT32_t *)(GPIO_U_Base+0x0C00))	 PortU Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* GPIO V					 : 0xF0807000	*/
N#define	GPIOVDATA				*((volatile UINT32_t *)(GPIO_V_Base+0x03FC))	/* PortV Data Regsiter */
N#define	GPIOVDIR				*((volatile UINT32_t *)(GPIO_V_Base+0x0400))	/* PortV Data Direction Register */
N/* ---- */
N#define	GPIOVFR1				*((volatile UINT32_t *)(GPIO_V_Base+0x0424))	/* PortV Function Register1 */
N#define	GPIOVFR2				*((volatile UINT32_t *)(GPIO_V_Base+0x0428))	/* PortV Function Register2 */
N/* ---- */
N/* #define	GPIOVIS					*((volatile UINT32_t *)(GPIO_V_Base+0x0804))	 PortV Interrupt Selection Register (Level and Edge) */
N/* #define	GPIOVIBE				*((volatile UINT32_t *)(GPIO_V_Base+0x0808))	 PortV Interrupt Selection Register (Fellow edge and Both edge) */
N/* #define	GPIOVIEV				*((volatile UINT32_t *)(GPIO_V_Base+0x080C))	 PortV Interrupt Selection Register (Fall down edge/Low level and Rising up edge/High level) */
N/* #define	GPIOVIE					*((volatile UINT32_t *)(GPIO_V_Base+0x0810))	 PortV Interrupt Enable Register */
N/* #define	GPIOVRIS				*((volatile UINT32_t *)(GPIO_V_Base+0x0814))	 PortV Interrupt Status Register (Raw) */
N/* #define	GPIOVMIS				*((volatile UINT32_t *)(GPIO_V_Base+0x0818))	 PortV Interrupt Status Register (Masked) */
N/* #define	GPIOVIC					*((volatile UINT32_t *)(GPIO_V_Base+0x081C))	 PortV Interrupt Clear Register */
N/* ---- */
N/* #define	GPIOVODE				*((volatile UINT32_t *)(GPIO_V_Base+0x0C00))	 PortV Open-drain Output Enable Register */
N
N/* ------------------------------------------------------------------------ */
N/* EBI			 			 : 0xF00A0000	*/
N#define	smc_timeout				*((volatile UINT32_t *)(EBI_Base+0x0050))	/* SMC Time Out Register  */
N
N/* ------------------------------------------------------------------------ */
N/* MPMC0_DMC				 : 0xF4300000	*/
N#define	dmc_memc_status_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x000))	/* DMC Memory Controller Status Register */
N#define	dmc_memc_cmd_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x004))	/* DMC Memory Controller Command Register */
N#define	dmc_direct_cmd_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x008))	/* DMC Direct Command Register */
N#define	dmc_memory_cfg_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x00C))	/* DMC Memory Configuration Register */
N#define	dmc_refresh_prd_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x010))	/* DMC Refresh Period Register */
N#define	dmc_cas_latency_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x014))	/* DMC CAS Latency Register */
N#define	dmc_t_dqss_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x018))	/* DMC t_dqss Register */
N#define	dmc_t_mrd_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x01C))	/* DMC t_mrd Register */
N#define	dmc_t_ras_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x020))	/* DMC t_ras Register */
N#define	dmc_t_rc_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x024))	/* DMC t_rc Register */
N#define	dmc_t_rcd_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x028))	/* DMC t_rcd Register */
N#define	dmc_t_rfc_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x02C))	/* DMC t_rfc Register */
N#define	dmc_t_rp_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x030))	/* DMC t_rp Register */
N#define	dmc_t_rrd_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x034))	/* DMC t_rrd Register */
N#define	dmc_t_wr_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x038))	/* DMC t_wr Register */
N#define	dmc_t_wtr_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x03C))	/* DMC t_wtr Register */
N#define	dmc_t_xp_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x040))	/* DMC t_xp Register */
N#define	dmc_t_xsr_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x044))	/* DMC t_xsr Register */
N#define	dmc_t_esr_3				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x048))	/* DMC t_esr Register */
N/* ---- */
N#define	dmc_id_0_cfg_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x100))	/* DMC id_<0-3>_cfg Registers */
N#define	dmc_id_1_cfg_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x104))	/* DMC id_<0-3>_cfg Registers */
N#define	dmc_id_2_cfg_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x108))	/* DMC id_<0-3>_cfg Registers */
N#define	dmc_id_3_cfg_3			*((volatile UINT32_t *)(MPMC0_DMC_Base+0x10C))	/* DMC id_<0-3>_cfg Registers */
N/* ---- */
N#define	dmc_chip_0_cfg_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x200))	/* DMC chip_0_cfg Registers */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x204)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x208)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x20C)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0x300)) */
N#define	dmc_user_config_3		*((volatile UINT32_t *)(MPMC0_DMC_Base+0x304))	/* DMC user_config Register */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xE00)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xE04)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xE08)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xFE0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xFF0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_DMC_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* MPMC0_SMC				 : 0xF4301000	*/
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x000)) */
N#define	smc_memif_cfg_3			*((volatile UINT32_t *)(MPMC0_SMC_Base+0x004))	/* SMC Memory Interface Configuration Register */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x008)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x00C)) */
N#define	smc_direct_cmd_3		*((volatile UINT32_t *)(MPMC0_SMC_Base+0x010))	/* SMC Direct Command Register */
N#define	smc_set_cycles_3		*((volatile UINT32_t *)(MPMC0_SMC_Base+0x014))	/* SMC Set Cycles Register */
N#define	smc_set_opmode_3		*((volatile UINT32_t *)(MPMC0_SMC_Base+0x018))	/* SMC Set Opmode Register */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x020)) */
N/* ---- */
N#define	smc_sram_cycles0_0_3	*((volatile UINT32_t *)(MPMC0_SMC_Base+0x100))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_0_3			*((volatile UINT32_t *)(MPMC0_SMC_Base+0x104))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_1_3	*((volatile UINT32_t *)(MPMC0_SMC_Base+0x120))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_1_3			*((volatile UINT32_t *)(MPMC0_SMC_Base+0x124))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_2_3	*((volatile UINT32_t *)(MPMC0_SMC_Base+0x140))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_2_3			*((volatile UINT32_t *)(MPMC0_SMC_Base+0x144))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_3_3	*((volatile UINT32_t *)(MPMC0_SMC_Base+0x160))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_3_3			*((volatile UINT32_t *)(MPMC0_SMC_Base+0x164))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x200)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0x204)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xE00)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xE04)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xE08)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xFE0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xFF0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC0_SMC_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* MPMEC1_DMC				 : 0xF4310000	*/
N#define	dmc_memc_status_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x000))	/* DMC Memory Controller Status Register */
N#define	dmc_memc_cmd_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x004))	/* DMC Memory Controller Command Register */
N#define	dmc_direct_cmd_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x008))	/* DMC Direct Command Register */
N#define	dmc_memory_cfg_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x00C))	/* DMC Memory Configuration Register */
N#define	dmc_refresh_prd_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x010))	/* DMC Refresh Period Register */
N#define	dmc_cas_latency_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x014))	/* DMC CAS Latency Register */
N#define	dmc_t_dqss_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x018))	/* DMC t_dqss Register */
N#define	dmc_t_mrd_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x01C))	/* DMC t_mrd Register */
N#define	dmc_t_ras_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x020))	/* DMC t_ras Register */
N#define	dmc_t_rc_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x024))	/* DMC t_rc Register */
N#define	dmc_t_rcd_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x028))	/* DMC t_rcd Register */
N#define	dmc_t_rfc_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x02C))	/* DMC t_rfc Register */
N#define	dmc_t_rp_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x030))	/* DMC t_rp Register */
N#define	dmc_t_rrd_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x034))	/* DMC t_rrd Register */
N#define	dmc_t_wr_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x038))	/* DMC t_wr Register */
N#define	dmc_t_wtr_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x03C))	/* DMC t_wtr Register */
N#define	dmc_t_xp_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x040))	/* DMC t_xp Register */
N#define	dmc_t_xsr_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x044))	/* DMC t_xsr Register */
N#define	dmc_t_esr_5				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x048))	/* DMC t_esr Register */
N/* ---- */
N#define	dmc_id_0_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x100))	/* DMC id_<0-5>_cfg Registers */
N#define	dmc_id_1_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x104))	/* DMC id_<0-5>_cfg Registers */
N#define	dmc_id_2_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x108))	/* DMC id_<0-5>_cfg Registers */
N#define	dmc_id_3_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x10C))	/* DMC id_<0-5>_cfg Registers */
N#define	dmc_id_4_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x110))	/* DMC id_<0-5>_cfg Registers */
N#define	dmc_id_5_cfg_5			*((volatile UINT32_t *)(MPMC1_DMC_Base+0x114))	/* DMC id_<0-5>_cfg Registers */
N/* ---- */
N#define	dmc_chip_0_cfg_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x200))	/* DMC chip_0_cfg Registers */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x204)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x208)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x20C)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0x300)) */
N#define	dmc_user_config_5		*((volatile UINT32_t *)(MPMC1_DMC_Base+0x304))	/* DMC user_config Register */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xE00)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xE04)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xE08)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xFE0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xFF0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_DMC_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* MPMC1_SMC				 : 0xF4311000	*/
N#define	smc_memc_status_5		*((volatile UINT32_t *)(MPMC1_SMC_Base+0x000))	/* SMC Memory Controller Status Register */
N#define	smc_memif_cfg_5			*((volatile UINT32_t *)(MPMC1_SMC_Base+0x004))	/* SMC Memory Interface Configuration Register */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0x008)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0x00C)) */
N#define	smc_direct_cmd_5		*((volatile UINT32_t *)(MPMC1_SMC_Base+0x010))	/* SMC Direct Command Register */
N#define	smc_set_cycles_5		*((volatile UINT32_t *)(MPMC1_SMC_Base+0x014))	/* SMC Set Cycles Register */
N#define	smc_set_opmode_5		*((volatile UINT32_t *)(MPMC1_SMC_Base+0x018))	/* SMC Set Opmode Register */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0x020)) */
N/* ---- */
N#define	smc_sram_cycles0_0_5	*((volatile UINT32_t *)(MPMC1_SMC_Base+0x100))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_0_5			*((volatile UINT32_t *)(MPMC1_SMC_Base+0x104))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_1_5	*((volatile UINT32_t *)(MPMC1_SMC_Base+0x120))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_1_5			*((volatile UINT32_t *)(MPMC1_SMC_Base+0x124))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_2_5	*((volatile UINT32_t *)(MPMC1_SMC_Base+0x140))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_2_5			*((volatile UINT32_t *)(MPMC1_SMC_Base+0x144))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N#define	smc_sram_cycles0_3_5	*((volatile UINT32_t *)(MPMC1_SMC_Base+0x160))	/* SMC SRAM Cycles Registers <0-3> */
N#define	smc_opmode0_3_5			*((volatile UINT32_t *)(MPMC1_SMC_Base+0x164))	/* SMC Opmode Registers <0-3> */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0x200)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0x204)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xE00)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xE04)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xE08)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xFE0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xFF0)) */
N/* ...                                                                             */
N/* #define Reserved				*((volatile UINT32_t *)(MPMC1_SMC_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* NDFC						 : 0xF2010000	*/
N#define	NDFMCR0					*((volatile UINT32_t *)(NDFC_Base+0x0000))	/* NAND-Flash Control Register-0 */
N#define	NDFMCR1					*((volatile UINT32_t *)(NDFC_Base+0x0004))	/* NAND-Flash Control Register-1 */
N#define	NDFMCR2					*((volatile UINT32_t *)(NDFC_Base+0x0008))	/* NAND-Flash Control Register-2 */
N#define	NDFINTC					*((volatile UINT32_t *)(NDFC_Base+0x000C))	/* NAND-Flash Interrupt Control Register */
N#define	NDFDTR					*((volatile UINT32_t *)(NDFC_Base+0x0010))	/* NAND-Flash Data Register */
N#define	NDECCRD0				*((volatile UINT32_t *)(NDFC_Base+0x0020))	/* NAND-Flash ECC-code Read Register-0 */
N#define	NDECCRD1				*((volatile UINT32_t *)(NDFC_Base+0x0024))	/* NAND-Flash ECC-code Read Register-1 */
N#define	NDECCRD2				*((volatile UINT32_t *)(NDFC_Base+0x0028))	/* NAND-Flash ECC-code Read Register-2 */
N/* ---- */
N#define	NDRSCA0					*((volatile UINT32_t *)(NDFC_Base+0x0030))	/* NAND-Flash Reed-Solomon Calculation result Address Register-0 */
N#define	NDRSCD0					*((volatile UINT32_t *)(NDFC_Base+0x0034))	/* NAND-Flash Reed-Solomon Calculation result Data Register-0 */
N#define	NDRSCA1					*((volatile UINT32_t *)(NDFC_Base+0x0038))	/* NAND-Flash Reed-Solomon Calculation result Address Register-1 */
N#define	NDRSCD1					*((volatile UINT32_t *)(NDFC_Base+0x003C))	/* NAND-Flash Reed-Solomon Calculation result Data Register-1 */
N#define	NDRSCA2					*((volatile UINT32_t *)(NDFC_Base+0x0040))	/* NAND-Flash Reed-Solomon Calculation result Address Register-2 */
N#define	NDRSCD2					*((volatile UINT32_t *)(NDFC_Base+0x0044))	/* NAND-Flash Reed-Solomon Calculation result Data Register-2 */
N#define	NDRSCA3					*((volatile UINT32_t *)(NDFC_Base+0x0048))	/* NAND-Flash Reed-Solomon Calculation result Address Register-3 */
N#define	NDRSCD3					*((volatile UINT32_t *)(NDFC_Base+0x004C))	/* NAND-Flash Reed-Solomon Calculation result Data Register-3 */
N
N/* ------------------------------------------------------------------------ */
N/* TMRB_PWM					 : 0xF0040000	*/
N#define	Timer0Load				*((volatile UINT32_t *)(TMR16_01_Base+0x000))	/* Timer0 Load value */
N#define	Timer0Value				*((volatile UINT32_t *)(TMR16_01_Base+0x004))	/* The current value for Timer0 */
N#define	Timer0Control			*((volatile UINT32_t *)(TMR16_01_Base+0x008))	/* Timer0 control register */
N#define	Timer0IntClr			*((volatile UINT32_t *)(TMR16_01_Base+0x00C))	/* Timer0 interrupt clear */
N#define	Timer0RIS				*((volatile UINT32_t *)(TMR16_01_Base+0x010))	/* Timer0 raw interrupt status */
N#define	Timer0MIS				*((volatile UINT32_t *)(TMR16_01_Base+0x014))	/* Timer0 masked interrupt status */
N#define	Timer0BGLoad			*((volatile UINT32_t *)(TMR16_01_Base+0x018))	/* Background load value for Timer0 */
N#define	Timer0Mode				*((volatile UINT32_t *)(TMR16_01_Base+0x01C))	/* Timer0 mode register */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x020)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x040)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x060)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x064)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x068)) */
N/* ---- */
N#define	Timer0Compare1			*((volatile UINT32_t *)(TMR16_01_Base+0x0A0))	/* Timer0 Compare value */
N/* ---- */
N#define	Timer0CmpIntClr1		*((volatile UINT32_t *)(TMR16_01_Base+0x0C0))	/* Timer0 Compare Interrupt clear */
N/* ---- */
N#define	Timer0CmpEn				*((volatile UINT32_t *)(TMR16_01_Base+0x0E0))	/* Timer0 Compare Enable */
N#define	Timer0CmpRIS			*((volatile UINT32_t *)(TMR16_01_Base+0x0E4))	/* Timer0 Compare raw interrupt status */
N#define	Timer0CmpMIS			*((volatile UINT32_t *)(TMR16_01_Base+0x0E8))	/* Timer0 Compare masked int status */
N#define	Timer0BGCmp				*((volatile UINT32_t *)(TMR16_01_Base+0x0EC))	/* Background compare value for Timer0 */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x0F0)) */
N/* ---- */
N#define	Timer1Load				*((volatile UINT32_t *)(TMR16_01_Base+0x100))	/* Timer1 Load value */
N#define	Timer1Value				*((volatile UINT32_t *)(TMR16_01_Base+0x104))	/* The current value for Timer1 */
N#define	Timer1Control			*((volatile UINT32_t *)(TMR16_01_Base+0x108))	/* Timer1 control register */
N#define	Timer1IntClr			*((volatile UINT32_t *)(TMR16_01_Base+0x10C))	/* Timer1 interrupt clear */
N#define	Timer1RIS				*((volatile UINT32_t *)(TMR16_01_Base+0x110))	/* Timer1 raw interrupt status */
N#define	Timer1MIS				*((volatile UINT32_t *)(TMR16_01_Base+0x114))	/* Timer1 masked interrupt status */
N#define	Timer1BGLoad			*((volatile UINT32_t *)(TMR16_01_Base+0x118))	/* Background load value for Timer1 */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x120)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x140)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x160)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x164)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x168)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x1A0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x1C0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x1E0)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x1E4)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_01_Base+0x1E8)) */
N
N/* ------------------------------------------------------------------------ */
N/* TMR16_23					 : 0xF0041000	*/
N#define	Timer2Load				*((volatile UINT32_t *)(TMR16_23_Base+0x000))	/* Timer2 Load value */
N#define	Timer2Value				*((volatile UINT32_t *)(TMR16_23_Base+0x004))	/* The current value for Timer2 */
N#define	Timer2Control			*((volatile UINT32_t *)(TMR16_23_Base+0x008))	/* Timer2 control register */
N#define	Timer2IntClr			*((volatile UINT32_t *)(TMR16_23_Base+0x00C))	/* Timer2 interrupt clear */
N#define	Timer2RIS				*((volatile UINT32_t *)(TMR16_23_Base+0x010))	/* Timer2 raw interrupt status */
N#define	Timer2MIS				*((volatile UINT32_t *)(TMR16_23_Base+0x014))	/* Timer2 masked interrupt status */
N#define	Timer2BGLoad			*((volatile UINT32_t *)(TMR16_23_Base+0x018))	/* Background load value for Timer2 */
N#define	Timer2Mode				*((volatile UINT32_t *)(TMR16_23_Base+0x01C))	/* Timer2 mode register */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x020)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x040)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x060)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x064)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x068)) */
N/* ---- */
N#define	Timer2Compare1			*((volatile UINT32_t *)(TMR16_23_Base+0x0A0))	/* Timer2 mode register */
N/* ---- */
N#define	Timer2CmpIntClr1		*((volatile UINT32_t *)(TMR16_23_Base+0x0C0))	/* Timer2 Compare Interrupt clear */
N/* ---- */
N#define	Timer2CmpEn				*((volatile UINT32_t *)(TMR16_23_Base+0x0E0))	/* Timer2 Compare Enable */
N#define	Timer2CmpRIS			*((volatile UINT32_t *)(TMR16_23_Base+0x0E4))	/* Timer2 Compare raw interrupt status */
N#define	Timer2CmpMIS			*((volatile UINT32_t *)(TMR16_23_Base+0x0E8))	/* Timer2 Compare masked int status */
N#define	Timer2BGCmp				*((volatile UINT32_t *)(TMR16_23_Base+0x0EC))	/* Background compare value for Timer2 */
N/* ---- */
N#define	Timer3Load				*((volatile UINT32_t *)(TMR16_23_Base+0x100))	/* Timer3 Load value */
N#define	Timer3Value				*((volatile UINT32_t *)(TMR16_23_Base+0x104))	/* The current value for Timer3 */
N#define	Timer3Control			*((volatile UINT32_t *)(TMR16_23_Base+0x108))	/* Timer3 control register */
N#define	Timer3IntClr			*((volatile UINT32_t *)(TMR16_23_Base+0x10C))	/* Timer3 interrupt clear */
N#define	Timer3RIS				*((volatile UINT32_t *)(TMR16_23_Base+0x110))	/* Timer3 raw interrupt status */
N#define	Timer3MIS				*((volatile UINT32_t *)(TMR16_23_Base+0x114))	/* Timer3 masked interrupt status */
N#define	Timer3BGLoad			*((volatile UINT32_t *)(TMR16_23_Base+0x118))	/* Background load value for Timer3 */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x120)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x140)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x160)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x164)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x168)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x1A0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x1C0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x1E0)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x1E4)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_23_Base+0x1E8)) */
N
N/* ------------------------------------------------------------------------ */
N/* TMR16_45					 : 0xF0042000	*/
N#define	Timer4Load				*((volatile UINT32_t *)(TMR16_45_Base+0x000))	/* Timer4 Load value */
N#define	Timer4Value				*((volatile UINT32_t *)(TMR16_45_Base+0x004))	/* The current value for Timer4 */
N#define	Timer4Control			*((volatile UINT32_t *)(TMR16_45_Base+0x008))	/* Timer4 control register */
N#define	Timer4IntClr			*((volatile UINT32_t *)(TMR16_45_Base+0x00C))	/* Timer4 interrupt clear */
N#define	Timer4RIS				*((volatile UINT32_t *)(TMR16_45_Base+0x010))	/* Timer4 raw interrupt status */
N#define	Timer4MIS				*((volatile UINT32_t *)(TMR16_45_Base+0x014))	/* Timer4 masked interrupt status */
N#define	Timer4BGLoad			*((volatile UINT32_t *)(TMR16_45_Base+0x018))	/* Background load value for Timer4 */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x01C)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x020)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x040)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x060)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x064)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x068)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0A0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0C0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0E0)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0E4)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0E8)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x0EC)) */
N/* ---- */
N#define	Timer5Load				*((volatile UINT32_t *)(TMR16_45_Base+0x100))	/* Timer5 Load value */
N#define	Timer5Value				*((volatile UINT32_t *)(TMR16_45_Base+0x104))	/* The current value for Timer5 */
N#define	Timer5Control			*((volatile UINT32_t *)(TMR16_45_Base+0x108))	/* Timer5 control register */
N#define	Timer5IntClr			*((volatile UINT32_t *)(TMR16_45_Base+0x10C))	/* Timer5 interrupt clear  r */
N#define	Timer5RIS				*((volatile UINT32_t *)(TMR16_45_Base+0x110))	/* Timer5 raw interrupt status */
N#define	Timer5MIS				*((volatile UINT32_t *)(TMR16_45_Base+0x114))	/* Timer5 masked interrupt status */
N#define	Timer5BGLoad			*((volatile UINT32_t *)(TMR16_45_Base+0x118))	/* Background load value for Timer5 */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x120)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x140)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x160)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x164)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x168)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x1A0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x1C0)) */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x1E0)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x1E4)) */
N/* #define Reserved				*((volatile UINT32_t *)(TMR16_45_Base+0x1E8)) */
N
N/* ------------------------------------------------------------------------ */
N/* UART 0					 : 0xF2000000	*/
N#define	UART0DR					*((volatile UINT32_t *)(UART0_Base+0x000))	/* UART 0 Data Register */
N#define	UART0SR					*((volatile UINT32_t *)(UART0_Base+0x004))	/* UART 0 RX Status Register */
N#define	UART0ECR				UART0SR										/* UART 0 Error Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x008)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x00C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x010)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x014)) */
N#define	UART0FR					*((volatile UINT32_t *)(UART0_Base+0x018))	/* UART 0 Flag Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x01C)) */
N#define	UART0ILPR				*((volatile UINT32_t *)(UART0_Base+0x020))	/* UART 0 IrDA Low Power Counter Register */
N#define	UART0IBRD				*((volatile UINT32_t *)(UART0_Base+0x024))	/* UART 0 Integer Baud Rate Divisor Register */
N#define	UART0FBRD				*((volatile UINT32_t *)(UART0_Base+0x028))	/* UART 0 Fraction Baud Rate Divisor Register */
N#define	UART0LCR_H				*((volatile UINT32_t *)(UART0_Base+0x02C))	/* UART 0 Data Format Control Register */
N#define	UART0CR					*((volatile UINT32_t *)(UART0_Base+0x030))	/* UART 0 Control Register */
N#define	UART0IFLS				*((volatile UINT32_t *)(UART0_Base+0x034))	/* UART 0 Interrupt FIF Level Select Register */
N#define	UART0IMSC				*((volatile UINT32_t *)(UART0_Base+0x038))	/* UART 0 Interrupt Mask Set/Clear Register */
N#define	UART0RIS				*((volatile UINT32_t *)(UART0_Base+0x03C))	/* UART 0 Raw Interrupt Status Register */
N#define	UART0MIS				*((volatile UINT32_t *)(UART0_Base+0x040))	/* UART 0 Mask Interrupt Status Register */
N#define	UART0ICR				*((volatile UINT32_t *)(UART0_Base+0x044))	/* UART 0 Interrupt Clear Register */
N#define	UART0DMACR				*((volatile UINT32_t *)(UART0_Base+0x048))	/* UART 0 DMA Control Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x04C)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x07C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x080)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x08C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0x090)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFCC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFD0)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFDC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFE0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFE4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFE8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFF0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFF4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFF8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART0_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* UART 1					 : 0xF2001000	*/
N#define	UART1DR					*((volatile UINT32_t *)(UART1_Base+0x000))	/* UART 1 Data Register */
N#define	UART1SR					*((volatile UINT32_t *)(UART1_Base+0x004))	/* UART 1 RX Status Register */
N#define	UART1ECR				UART1SR										/* UART 1 Error Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x008)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x00C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x010)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x014)) */
N#define	UART1FR					*((volatile UINT32_t *)(UART1_Base+0x018))	/* UART 1 Flag Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x01C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x020)) */
N#define	UART1IBRD				*((volatile UINT32_t *)(UART1_Base+0x024))	/* UART 1 Integer Baud Rate Divisor Register */
N#define	UART1FBRD				*((volatile UINT32_t *)(UART1_Base+0x028))	/* UART 1 Fraction Baud Rate Divisor Register */
N#define	UART1LCR_H				*((volatile UINT32_t *)(UART1_Base+0x02C))	/* UART 1 Data Format Control Register */
N#define	UART1CR					*((volatile UINT32_t *)(UART1_Base+0x030))	/* UART 1 Control Register */
N#define	UART1IFLS				*((volatile UINT32_t *)(UART1_Base+0x034))	/* UART 1 Interrupt FIF Level Select Register */
N#define	UART1IMSC				*((volatile UINT32_t *)(UART1_Base+0x038))	/* UART 1 Interrupt Mask Set/Clear Register */
N#define	UART1RIS				*((volatile UINT32_t *)(UART1_Base+0x03C))	/* UART 1 Raw Interrupt Status Register */
N#define	UART1MIS				*((volatile UINT32_t *)(UART1_Base+0x040))	/* UART 1 Mask Interrupt Status Register */
N#define	UART1ICR				*((volatile UINT32_t *)(UART1_Base+0x044))	/* UART 1 Interrupt Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x048)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x04C)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x07C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x080)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x08C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0x090)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFCC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFD0)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFDC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFE0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFE4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFE8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFF0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFF4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFF8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART1_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* UART 2					 : 0xF2004000	*/
N#define	UART2DR					*((volatile UINT32_t *)(UART2_Base+0x000))	/* UART 2 Data Register */
N#define	UART2SR					*((volatile UINT32_t *)(UART2_Base+0x004))	/* UART 2 RX Status Register */
N#define	UART2ECR				UART2SR										/* UART 2 Error Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x008)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x00C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x010)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x014)) */
N#define	UART2FR					*((volatile UINT32_t *)(UART2_Base+0x018))	/* UART 2 Flag Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x01C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x020)) */
N#define	UART2IBRD				*((volatile UINT32_t *)(UART2_Base+0x024))	/* UART 2 Integer Baud Rate Divisor Register */
N#define	UART2FBRD				*((volatile UINT32_t *)(UART2_Base+0x028))	/* UART 2 Fraction Baud Rate Divisor Register */
N#define	UART2LCR_H				*((volatile UINT32_t *)(UART2_Base+0x02C))	/* UART 2 Data Format Control Register */
N#define	UART2CR					*((volatile UINT32_t *)(UART2_Base+0x030))	/* UART 2 Control Register */
N#define	UART2IFLS				*((volatile UINT32_t *)(UART2_Base+0x034))	/* UART 2 Interrupt FIF Level Select Register */
N#define	UART2IMSC				*((volatile UINT32_t *)(UART2_Base+0x038))	/* UART 2 Interrupt Mask Set/Clear Register */
N#define	UART2RIS				*((volatile UINT32_t *)(UART2_Base+0x03C))	/* UART 2 Raw Interrupt Status Register */
N#define	UART2MIS				*((volatile UINT32_t *)(UART2_Base+0x040))	/* UART 2 Mask Interrupt Status Register */
N#define	UART2ICR				*((volatile UINT32_t *)(UART2_Base+0x044))	/* UART 2 Interrupt Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x048)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x04C)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x07C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x080)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x08C)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0x090)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFCC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFD0)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFDC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFE0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFE4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFE8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFEC)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFF0)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFF4)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFF8)) */
N/* #define Reserved				*((volatile UINT32_t *)(UART2_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* I2C_0					 : 0xF0070000	*/
N#define	I2C0CR1					*((volatile UINT32_t *)(I2C0_Base+0x000))	/* I2C0 Control Register 1 */
N#define	I2C0DBR					*((volatile UINT32_t *)(I2C0_Base+0x004))	/* I2C0 Data Buffer Register  */
N#define	I2C0AR					*((volatile UINT32_t *)(I2C0_Base+0x008))	/* I2C0 (Slave) Address Register */
N#define	I2C0CR2					*((volatile UINT32_t *)(I2C0_Base+0x00C))	/* I2C0 Control Register 2 */
N#define	I2C0SR					I2C0CR2										/* I2C0 Status Register */
N#define	I2C0PRS					*((volatile UINT32_t *)(I2C0_Base+0x010))	/* I2C0 Prescaler Clock Set Register */
N#define	I2C0IE					*((volatile UINT32_t *)(I2C0_Base+0x014))	/* I2C0 Interrupt Enable Register */
N#define	I2C0IR					*((volatile UINT32_t *)(I2C0_Base+0x018))	/* I2C0 Interrupt Register */
N
N/* ------------------------------------------------------------------------ */
N/* I2C_1					 : 0xF0071000	*/
N#define	I2C1CR1					*((volatile UINT32_t *)(I2C1_Base+0x000))	/* I2C1 Control Register 1 */
N#define	I2C1DBR					*((volatile UINT32_t *)(I2C1_Base+0x004))	/* I2C1 Data Buffer Register  */
N#define	I2C1AR					*((volatile UINT32_t *)(I2C1_Base+0x008))	/* I2C1 (Slave) Address Register */
N#define	I2C1CR2					*((volatile UINT32_t *)(I2C1_Base+0x00C))	/* I2C1 Control Register 2 */
N#define	I2C1SR					I2C1CR2										/* I2C1 Status Register */
N#define	I2C1PRS					*((volatile UINT32_t *)(I2C1_Base+0x010))	/* I2C1 Prescaler Clock Set Register */
N#define	I2C1IE					*((volatile UINT32_t *)(I2C1_Base+0x014))	/* I2C1 Interrupt Enable Register */
N#define	I2C1IR					*((volatile UINT32_t *)(I2C1_Base+0x018))	/* I2C1 Interrupt Register */
N
N/* ------------------------------------------------------------------------ */
N/* SSP0						 : 0xF2002000	*/
N#define	SSP0CR0					*((volatile UINT32_t *)(SSP0_Base+0x000))	/* SSP 0 Control Register 0 */
N#define	SSP0CR1					*((volatile UINT32_t *)(SSP0_Base+0x004))	/* SSP 0 Control Register 1 */
N#define	SSP0DR					*((volatile UINT32_t *)(SSP0_Base+0x008))	/* SSP 0 Data Register */
N#define	SSP0SR					*((volatile UINT32_t *)(SSP0_Base+0x00C))	/* SSP 0 Status Register */
N#define	SSP0CPSR				*((volatile UINT32_t *)(SSP0_Base+0x010))	/* SSP 0 Clock Prescale Register */
N#define	SSP0IMSC				*((volatile UINT32_t *)(SSP0_Base+0x014))	/* SSP 0 Interrupt Mask Set/Clear Control Register */
N#define	SSP0RIS					*((volatile UINT32_t *)(SSP0_Base+0x018))	/* SSP 0 Raw Interrupt Status Register */
N#define	SSP0MIS					*((volatile UINT32_t *)(SSP0_Base+0x01C))	/* SSP 0 Mask Interrupt Status Register */
N#define	SSP0ICR					*((volatile UINT32_t *)(SSP0_Base+0x020))	/* SSP 0 Interrupt Clear Register */
N#define	SSP0DMACR				*((volatile UINT32_t *)(SSP0_Base+0x024))	/* DMAC Control Register */
N/* #define Reserved				*((volatile UINT32_t *)(SSP0_Base+0x028)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(SSP0_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* SSP1						 : 0xF2003000	*/
N#define	SSP1CR0					*((volatile UINT32_t *)(SSP1_Base+0x000))	/* SSP 1 Control Register 0 */
N#define	SSP1CR1					*((volatile UINT32_t *)(SSP1_Base+0x004))	/* SSP 1 Control Register 1 */
N#define	SSP1DR					*((volatile UINT32_t *)(SSP1_Base+0x008))	/* SSP 1 Data Register */
N#define	SSP1SR					*((volatile UINT32_t *)(SSP1_Base+0x00C))	/* SSP 1 Status Register */
N#define	SSP1CPSR				*((volatile UINT32_t *)(SSP1_Base+0x010))	/* SSP 1 Clock Prescale Register */
N#define	SSP1IMSC				*((volatile UINT32_t *)(SSP1_Base+0x014))	/* SSP 1 Interrupt Mask Set/Clear Control Register */
N#define	SSP1RIS					*((volatile UINT32_t *)(SSP1_Base+0x018))	/* SSP 1 Raw Interrupt Status Register */
N#define	SSP1MIS					*((volatile UINT32_t *)(SSP1_Base+0x01C))	/* SSP 1 Mask Interrupt Status Register */
N#define	SSP1ICR					*((volatile UINT32_t *)(SSP1_Base+0x020))	/* SSP 1 Interrupt Clear Register */
N#define	SSP1DMACR				*((volatile UINT32_t *)(SSP1_Base+0x024))	/* SSP 1 DMA Control Register */
N/* #define Reserved				*((volatile UINT32_t *)(SSP1_Base+0x028)) */
N/* ...                                                                          */
N/* #define Reserved				*((volatile UINT32_t *)(SSP1_Base+0xFFC)) */
N
N/* ------------------------------------------------------------------------ */
N/* UDC2						 : 0xF4400000	*/
N#define	UDINTSTS				*((volatile UINT32_t *)(UDC2_Base+0x0000))	/* Interrupt Status Register */
N#define	UDINTENB				*((volatile UINT32_t *)(UDC2_Base+0x0004))	/* Interrupt Enable Register */
N#define	UDMWTOUT				*((volatile UINT32_t *)(UDC2_Base+0x0008))	/* Master Write Timeout Register */
N#define	UDC2STSET				*((volatile UINT32_t *)(UDC2_Base+0x000C))	/* UDC2 Setting Register */
N#define	UDMSTSET				*((volatile UINT32_t *)(UDC2_Base+0x0010))	/* DMAC Setting Register */
N#define	DMACRDREQ				*((volatile UINT32_t *)(UDC2_Base+0x0014))	/* DMAC Read Requset Register */
N#define	DMACRDVL				*((volatile UINT32_t *)(UDC2_Base+0x0018))	/* DMAC Read Value Register */
N#define	UDC2RDREQ				*((volatile UINT32_t *)(UDC2_Base+0x001C))	/* UDC2 Read Request Register */
N#define	UDC2RDVL				*((volatile UINT32_t *)(UDC2_Base+0x0020))	/* UDC2 Read Value Register */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x0024)) */
N/* ...                                                                         */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x0038)) */
N#define	ARBTSET					*((volatile UINT32_t *)(UDC2_Base+0x003C))	/* Arbiter Setting Register  */
N#define	UDMWSADR				*((volatile UINT32_t *)(UDC2_Base+0x0040))	/* Master Write Start Address Register */
N#define	UDMWEADR				*((volatile UINT32_t *)(UDC2_Base+0x0044))	/* Master Write End Address Register */
N#define	UDMWCADR				*((volatile UINT32_t *)(UDC2_Base+0x0048))	/* Master Write Current Address Register */
N#define	UDMWAHBADR				*((volatile UINT32_t *)(UDC2_Base+0x004C))	/* Master Write AHB Address Register */
N#define	UDMRSADR				*((volatile UINT32_t *)(UDC2_Base+0x0050))	/* Master Read Start Address Register */
N#define	UDMREADR				*((volatile UINT32_t *)(UDC2_Base+0x0054))	/* Master Read End Address Register */
N#define	UDMRCADR				*((volatile UINT32_t *)(UDC2_Base+0x0058))	/* Master Read Current Address Register */
N#define	UDMRAHBADR				*((volatile UINT32_t *)(UDC2_Base+0x005C))	/* Master Read AHB Address Register */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x0060)) */
N/* ...                                                                         */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x007C)) */
N#define	UDPWCTL					*((volatile UINT32_t *)(UDC2_Base+0x0080))	/* Power Detect Control Register */
N#define	UDMSTSTS				*((volatile UINT32_t *)(UDC2_Base+0x0084))	/* Master Status Register */
N#define	UDTOUTCNT				*((volatile UINT32_t *)(UDC2_Base+0x0088))	/* Timeout Count Register */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x008C)) */
N/* ...                                                                         */
N/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x01FC)) */
N#if(MADDRESS_ACCESS == 0)
X#if(1 == 0)
S#define	UD2ADR					*((volatile UINT32_t *)(UDC2_Base+0x0200))	/* UDC2 Address-State Register */
S#define	UD2FRM					*((volatile UINT32_t *)(UDC2_Base+0x0204))	/* UDC2 Frame Register */
S#define	UD2TMD					*((volatile UINT32_t *)(UDC2_Base+0x0208))	/* UDC2 USB-Testmode Register */
S#define	UD2CMD					*((volatile UINT32_t *)(UDC2_Base+0x020C))	/* UDC2 Command Register */
S#define	UD2BRQ					*((volatile UINT32_t *)(UDC2_Base+0x0210))	/* UDC2 bRequest-bmRequestType Register */
S#define	UD2WVL					*((volatile UINT32_t *)(UDC2_Base+0x0214))	/* UDC2 wValue Register */
S#define	UD2WIDX					*((volatile UINT32_t *)(UDC2_Base+0x0218))	/* UDC2 wIndex Register */
S#define	UD2WLGTH				*((volatile UINT32_t *)(UDC2_Base+0x021C))	/* UDC2 wLength Register */
S#define	UD2INT					*((volatile UINT32_t *)(UDC2_Base+0x0220))	/* UDC2 INT Register */
S#define	UD2INTEP				*((volatile UINT32_t *)(UDC2_Base+0x0224))	/* UDC2 INT_EP Register */
S#define	UD2INTEPMASK			*((volatile UINT32_t *)(UDC2_Base+0x0228))	/* UDC2 INT_EP_MASK Register */
S#define	UD2INTRX0				*((volatile UINT32_t *)(UDC2_Base+0x022C))	/* UDC2 INT_RX_DATA0 Register */
S#define	UD2EP0MSZ				*((volatile UINT32_t *)(UDC2_Base+0x0230))	/* UDC2 EP0_MaxPacketSize Register */
S#define	UD2EP0STS				*((volatile UINT32_t *)(UDC2_Base+0x0234))	/* UDC2 EP0_Status Register */
S#define	UD2EP0DSZ				*((volatile UINT32_t *)(UDC2_Base+0x0238))	/* UDC2 EP0_Datasize Register */
S#define	UD2EP0FIFO				*((volatile UINT32_t *)(UDC2_Base+0x023C))	/* UDC2 EP0_FIFO Register */
S#define	UD2EP1MSZ				*((volatile UINT32_t *)(UDC2_Base+0x0240))	/* UDC2 EP1_MaxPacketSize Register */
S#define	UD2EP1STS				*((volatile UINT32_t *)(UDC2_Base+0x0244))	/* UDC2 EP1_Status Register */
S#define	UD2EP1DSZ				*((volatile UINT32_t *)(UDC2_Base+0x0248))	/* UDC2 EP1_Datasize Register */
S#define	UD2EP1FIFO				*((volatile UINT32_t *)(UDC2_Base+0x024C))	/* UDC2 EP1_FIFO Register */
S#define	UD2EP2MSZ				*((volatile UINT32_t *)(UDC2_Base+0x0250))	/* UDC2 EP2_MaxPacketSize Register */
S#define	UD2EP2STS				*((volatile UINT32_t *)(UDC2_Base+0x0254))	/* UDC2 EP2_Status Register */
S#define	UD2EP2DSZ				*((volatile UINT32_t *)(UDC2_Base+0x0258))	/* UDC2 EP2_Datasize Register */
S#define	UD2EP2FIFO				*((volatile UINT32_t *)(UDC2_Base+0x025C))	/* UDC2 EP2_FIFO Register */
S#define	UD2EP3MSZ				*((volatile UINT32_t *)(UDC2_Base+0x0260))	/* UDC2 EP3_MaxPacketSize Register */
S#define	UD2EP3STS				*((volatile UINT32_t *)(UDC2_Base+0x0264))	/* UDC2 EP3_Status Register */
S#define	UD2EP3DSZ				*((volatile UINT32_t *)(UDC2_Base+0x0268))	/* UDC2 EP3_Datasize Register */
S#define	UD2EP3FIFO				*((volatile UINT32_t *)(UDC2_Base+0x026C))	/* UDC2 EP3_FIFO Register */
S/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x0270) */
S/* ...                                                                         */
S/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x032C)) */
S#define	UD2INTNAK				*((volatile UINT32_t *)(UDC2_Base+0x0330))	/* UDC2 INT_NAK Register */
S#define	UD2INTNAKMSK			*((volatile UINT32_t *)(UDC2_Base+0x0334))	/* UDC2 INT_NAK_MASK Register */
S/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x0338)) */
S/* ...                                                                         */
S/* #define Reserved				*((volatile UINT32_t *)(UDC2_Base+0x03FC)) */
N#else /* #if(MADDRESS_ACCESS == 0)	*/
N#define	UD2ADR					( UINT32_t )(UDC2_Base+0x0200)	/* UDC2 Address-State Register */
N#define	UD2FRM					( UINT32_t )(UDC2_Base+0x0204)	/* UDC2 Frame Register */
N#define	UD2TMD					( UINT32_t )(UDC2_Base+0x0208)	/* UDC2 USB-Testmode Register */
N#define	UD2CMD					( UINT32_t )(UDC2_Base+0x020C)	/* UDC2 Command Register */
N#define	UD2BRQ					( UINT32_t )(UDC2_Base+0x0210)	/* UDC2 bRequest-bmRequestType Register */
N#define	UD2WVL					( UINT32_t )(UDC2_Base+0x0214)	/* UDC2 wValue Register */
N#define	UD2WIDX					( UINT32_t )(UDC2_Base+0x0218)	/* UDC2 wIndex Register */
N#define	UD2WLGTH				( UINT32_t )(UDC2_Base+0x021C)	/* UDC2 wLength Register */
N#define	UD2INT					( UINT32_t )(UDC2_Base+0x0220)	/* UDC2 INT Register */
N#define	UD2INTEP				( UINT32_t )(UDC2_Base+0x0224)	/* UDC2 INT_EP Register */
N#define	UD2INTEPMASK			( UINT32_t )(UDC2_Base+0x0228)	/* UDC2 INT_EP_MASK Register */
N#define	UD2INTRX0				( UINT32_t )(UDC2_Base+0x022C)	/* UDC2 INT_RX_DATA0 Register */
N#define	UD2EP0MSZ				( UINT32_t )(UDC2_Base+0x0230)	/* UDC2 EP0_MaxPacketSize Register */
N#define	UD2EP0STS				( UINT32_t )(UDC2_Base+0x0234)	/* UDC2 EP0_Status Register */
N#define	UD2EP0DSZ				( UINT32_t )(UDC2_Base+0x0238)	/* UDC2 EP0_Datasize Register */
N#define	UD2EP0FIFO				( UINT32_t )(UDC2_Base+0x023C)	/* UDC2 EP0_FIFO Register */
N#define	UD2EP1MSZ				( UINT32_t )(UDC2_Base+0x0240)	/* UDC2 EP1_MaxPacketSize Register */
N#define	UD2EP1STS				( UINT32_t )(UDC2_Base+0x0244)	/* UDC2 EP1_Status Register */
N#define	UD2EP1DSZ				( UINT32_t )(UDC2_Base+0x0248)	/* UDC2 EP1_Datasize Register */
N#define	UD2EP1FIFO				( UINT32_t )(UDC2_Base+0x024C)	/* UDC2 EP1_FIFO Register */
N#define	UD2EP2MSZ				( UINT32_t )(UDC2_Base+0x0250)	/* UDC2 EP2_MaxPacketSize Register */
N#define	UD2EP2STS				( UINT32_t )(UDC2_Base+0x0254)	/* UDC2 EP2_Status Register */
N#define	UD2EP2DSZ				( UINT32_t )(UDC2_Base+0x0258)	/* UDC2 EP2_Datasize Register */
N#define	UD2EP2FIFO				( UINT32_t )(UDC2_Base+0x025C)	/* UDC2 EP2_FIFO Register */
N#define	UD2EP3MSZ				( UINT32_t )(UDC2_Base+0x0260)	/* UDC2 EP3_MaxPacketSize Register */
N#define	UD2EP3STS				( UINT32_t )(UDC2_Base+0x0264)	/* UDC2 EP3_Status Register */
N#define	UD2EP3DSZ				( UINT32_t )(UDC2_Base+0x0268)	/* UDC2 EP3_Datasize Register */
N#define	UD2EP3FIFO				( UINT32_t )(UDC2_Base+0x026C)	/* UDC2 EP3_FIFO Register */
N/* #define	Reserved				( UINT32_t )(UDC2_Base+0x0270) */
N/* ...                                                                         */
N/* #define	Reserved				( UINT32_t )(UDC2_Base+0x032C) */
N#define	UD2INTNAK				( UINT32_t )(UDC2_Base+0x0330)	/* UDC2 INT_NAK Register */
N#define	UD2INTNAKMSK			( UINT32_t )(UDC2_Base+0x0334)	/* UDC2 INT_NAK_MASK Register */
N#define	UD2INTNAK				( UINT32_t )(UDC2_Base+0x0330)	/* UDC2 INT_NAK Register */
N#define	UD2INTNAKMSK			( UINT32_t )(UDC2_Base+0x0334)	/* UDC2 INT_NAK_MASK Register */
N/* #define	Reserved				( UINT32_t *)(UDC2_Base+0x0338) */
N/* ...                                                                         */
N/* #define	Reserved				( UINT32_t *)(UDC2_Base+0x03FC) */
N#endif
N
N/* ------------------------------------------------------------------------ */
N/* I2S						 : 0xF2040000	*/
N#define	I2STCON					*((volatile UINT32_t *)(I2S_Base+0x0000))	/* I2S TX Control Register */
N#define	I2STSLVON				*((volatile UINT32_t *)(I2S_Base+0x0004))	/* I2S TX Slave WS/SCK Control Register */
N#define	I2STFCLR				*((volatile UINT32_t *)(I2S_Base+0x0008))	/* I2S TX FIFO CLR ON/OFF Register */
N#define	I2STMS					*((volatile UINT32_t *)(I2S_Base+0x000C))	/* I2S TX Master/Slave Register */
N#define	I2STMCON				*((volatile UINT32_t *)(I2S_Base+0x0010))	/* I2S TX Master I2S1WS/I2S1SCLK Period Register */
N#define	I2STMSTP				*((volatile UINT32_t *)(I2S_Base+0x0014))	/* I2S TX Master Stop Register */
N#define	I2STDMA1				*((volatile UINT32_t *)(I2S_Base+0x0018))	/* I2S TX DMA Ready Register */
N/* #define Reserved				*((volatile UINT32_t *)(I2S_Base+0x001C)) */
N#define	I2SRCON					*((volatile UINT32_t *)(I2S_Base+0x0020))	/* I2S RX Control Register */
N#define	I2SRSLVON				*((volatile UINT32_t *)(I2S_Base+0x0024))	/* I2S RX Slave WS/SCK Control Register */
N#define	I2SFRFCLR				*((volatile UINT32_t *)(I2S_Base+0x0028))	/* I2S RX FIFO CLR ON/OFF Register */
N#define	I2SRMS					*((volatile UINT32_t *)(I2S_Base+0x002C))	/* I2S RX Master/Slave Register */
N#define	I2SRMCON				*((volatile UINT32_t *)(I2S_Base+0x0030))	/* I2S RX Master I2S1WS/I2S1SCLK Period Register*/
N#define	I2SRMSTP				*((volatile UINT32_t *)(I2S_Base+0x0034))	/* I2S RX Master Stop Register */
N#define	I2SRDMA1				*((volatile UINT32_t *)(I2S_Base+0x0038))	/* I2S RX DMA Ready Register */
N/* #define Reserved				*((volatile UINT32_t *)(I2S_Base+0x003C)) */
N/* ---- */
N#define	I2SCOMMON				*((volatile UINT32_t *)(I2S_Base+0x0044))	/* I2S Common Control Register */
N#define	I2STST					*((volatile UINT32_t *)(I2S_Base+0x0048))	/* I2S TX Status Register */
N#define	I2SRST					*((volatile UINT32_t *)(I2S_Base+0x004C))	/* I2S RX Status Register */
N#define	I2SINT					*((volatile UINT32_t *)(I2S_Base+0x0050))	/* I2S Interrupt Register */
N#define	I2SINTMSK				*((volatile UINT32_t *)(I2S_Base+0x0054))	/* I2S Interrupt Mask Register */
N/* ---- */
N#define	I2STDAT					*((volatile UINT32_t *)(I2S_Base+0x1000))	/* I2S TX FIFO Window DMA Target -0x1FFF */
N#define	I2SRDAT					*((volatile UINT32_t *)(I2S_Base+0x2000))	/* I2S RX FIFO Window DMA Target -0x2FFF */
N
N/* ------------------------------------------------------------------------ */
N/* LCDC						 : 0xF4200000	*/
N#define	LCDTiming0				*((volatile UINT32_t *)(LCDC_Base+0x0000))	/* LCD Horizontal Control Register */
N#define	LCDTiming1				*((volatile UINT32_t *)(LCDC_Base+0x0004))	/* LCD Vertical Control Register */
N#define	LCDTiming2				*((volatile UINT32_t *)(LCDC_Base+0x0008))	/* LCD Clock/Signal Polarity Control Register */
N#define	LCDTiming3				*((volatile UINT32_t *)(LCDC_Base+0x000C))	/* LCD Row Termination Control Register */
N#define	LCDUPBASE				*((volatile UINT32_t *)(LCDC_Base+0x0010))	/* LCD Upper Panel Frame Base Address Register */
N#define	LCDLPBASE				*((volatile UINT32_t *)(LCDC_Base+0x0014))	/* LCD Lower Panel Frame Base Address Register */
N#define	LCDIMSC					*((volatile UINT32_t *)(LCDC_Base+0x0018))	/* LCD Interrupt Mask Set/Clear Register */
N#define	LCDControl				*((volatile UINT32_t *)(LCDC_Base+0x001C))	/* LCD Control Register */
N#define	LCDRIS					*((volatile UINT32_t *)(LCDC_Base+0x0020))	/* LCD Raw Interrupt Status Register */
N#define	LCDMIS					*((volatile UINT32_t *)(LCDC_Base+0x0024))	/* LCD Mask Interrupt Status Register */
N#define	LCDICR					*((volatile UINT32_t *)(LCDC_Base+0x0028))	/* LCD Interrupt Clear Register */
N#define	LCDUPCURR				*((volatile UINT32_t *)(LCDC_Base+0x002C))	/* LCD Upper Panel Current Address Value Registers */
N#define	LCDLPCURR				*((volatile UINT32_t *)(LCDC_Base+0x0030))	/* LCD Lower Panel Current Address Value Registers */
N/* ---- */
N#define	LCDPalette				*((volatile UINT32_t *)(LCDC_Base+0x0200))	/* LCD Color Palette Register -0x3FC */
N
N/* ------------------------------------------------------------------------ */
N/* LCDCOP					 : 0xF00B0000	*/
N#define	STN64CR					*((volatile UINT32_t *)(LCDCOP_Base+0x0000))	/* STN64 Control register */
N
N/* ------------------------------------------------------------------------ */
N/* LCDDA					 : 0xF2050000	*/
N#define	LDACR0					*((volatile UINT32_t *)(LCDDA_Base+0x0000))	/* LCDDA Control Register 0 */
N#define	LDADRSRC1				*((volatile UINT32_t *)(LCDDA_Base+0x0004))	/* LCDDA Density Ratio of Source 1 Picture */
N#define	LDADRSRC0				*((volatile UINT32_t *)(LCDDA_Base+0x0008))	/* LCDDA Density Ratio of Source 0 Picture */
N#define	LDAFCPSRC1				*((volatile UINT32_t *)(LCDDA_Base+0x000C))	/* LCDDA Replaced Font Area Color pallet of Source1 */
N#define	LDAEFCPSRC1				*((volatile UINT32_t *)(LCDDA_Base+0x0010))	/* LCDDA Replaced Except Font Area Color pallet of Source1 */
N#define	LDADVSRC1				*((volatile UINT32_t *)(LCDDA_Base+0x0014))	/* LCDDA Replaced Except Font Area Color pallet of Source1 */
N#define	LDACR2					*((volatile UINT32_t *)(LCDDA_Base+0x0018))	/* LCDDA Control Register 2 */
N#define	LDADXDST				*((volatile UINT32_t *)(LCDDA_Base+0x001C))	/* LCDDA X-Delta Value (Write Step) address Register of Destination */
N#define	LDADYDST				*((volatile UINT32_t *)(LCDDA_Base+0x0020))	/* LCDDA Y-Delta Value (Write Step) address Register of Destination */
N#define	LDASSIZE				*((volatile UINT32_t *)(LCDDA_Base+0x0024))	/* LCDDA Source Picture Size */
N#define	LDADSIZE				*((volatile UINT32_t *)(LCDDA_Base+0x0028))	/* LCDDA Destination Picture Size */
N#define	LDAS0AD					*((volatile UINT32_t *)(LCDDA_Base+0x002C))	/* LCDDA Source 0 Start Address */
N#define	LDADAD					*((volatile UINT32_t *)(LCDDA_Base+0x0030))	/* LCDDA Destination Start Address */
N#define	LDACR1					*((volatile UINT32_t *)(LCDDA_Base+0x0034))	/* LCDDA Control Register1 */
N#define	LDADVSRC0				*((volatile UINT32_t *)(LCDDA_Base+0x0038))	/* LCDDA Delta Value (Read Step) address Register of Source 0 */
N
N/* ------------------------------------------------------------------------ */
N/* TSI						 : 0xF0060000	*/
N#define	TSICR0					*((volatile UINT32_t *)(TSI_Base+0x01F0))	/* TSI Control Register0 */
N#define	TSICR1					*((volatile UINT32_t *)(TSI_Base+0x01F4))	/* TSI Control Register1 */
N
N/* ------------------------------------------------------------------------ */
N/* CMSI						 : 0xF2020000	*/
N#define	CMSCR					*((volatile UINT32_t *)(CMSI_Base+0x0000))	/* CMOS Image Sensor Control Register */
N#define	CMSCV					*((volatile UINT32_t *)(CMSI_Base+0x0004))	/* CMOS Image Sensor Color Space Conversion Register */
N#define	CMSCVP0					*((volatile UINT32_t *)(CMSI_Base+0x0008))	/* CMOS Image Sensor Color Conversion Parameter Register0 */
N#define	CMSCVP1					*((volatile UINT32_t *)(CMSI_Base+0x000C))	/* CMOS Image Sensor Color Conversion Parameter Register1 */
N#define	CMSYD					*((volatile UINT32_t *)(CMSI_Base+0x0010))	/* CMOS Image Sensor Soft Conversrion Y-data Resister */
N#define	CMSUD					*((volatile UINT32_t *)(CMSI_Base+0x0014))	/* CMOS Image Sensor Soft Conversrion U-data Resister */
N#define	CMSVD					*((volatile UINT32_t *)(CMSI_Base+0x0018))	/* CMOS Image Sensor Soft Conversrion V-data Resister */
N/* ---- */
N#define	CMSFPT					*((volatile UINT32_t *)(CMSI_Base+0x0020))	/* CMOS Image Sensor FIFO Port Read Register */
N#define	CMSSCTR					*((volatile UINT32_t *)(CMSI_Base+0x0024))	/* CMOS Image Sensor Scaling & Trimming Control Register */
N/* ---- */
N#define	CMSTS					*((volatile UINT32_t *)(CMSI_Base+0x0030))	/* CMOS Image Sensor Trimming Space Start Point Setting Register */
N#define	CMSTE					*((volatile UINT32_t *)(CMSI_Base+0x0034))	/* CMOS Image Sensor Trimming Space End Point Setting Register */
N/* ---- */
N#define	CMSSCDMA				*((volatile UINT32_t *)(CMSI_Base+0x0040))	/* CMOS Image Sensor Soft Conversrion DMA YUV-Data */
N
N/* ------------------------------------------------------------------------ */
N/* RTC_MLD					 : 0xF0030000	*/
N#define	RTCDATA					*((volatile UINT32_t *)(RTC_MLD_Base+0x0000))	/* RTC Data Register */
N#define	RTCCOMP					*((volatile UINT32_t *)(RTC_MLD_Base+0x0004))	/* RTC Compare Register */
N#define	RTCPRST					*((volatile UINT32_t *)(RTC_MLD_Base+0x0008))	/* RTC Preset Register */
N/* ---- */
N#define	MLDALMINV				*((volatile UINT32_t *)(RTC_MLD_Base+0x0100))	/* Melody Alarm Invert Register */
N#define	MLDALMSEL				*((volatile UINT32_t *)(RTC_MLD_Base+0x0104))	/* Melody Alarm signal Select Register */
N#define	ALMCNTCR				*((volatile UINT32_t *)(RTC_MLD_Base+0x0108))	/* Alarm Counter Control Register */
N#define	ALMPATERN				*((volatile UINT32_t *)(RTC_MLD_Base+0x010C))	/* Alarm Pattern Register */
N#define	MLDCNTCR				*((volatile UINT32_t *)(RTC_MLD_Base+0x0110))	/* Melody Counter Control Register */
N#define	MLDFRQ					*((volatile UINT32_t *)(RTC_MLD_Base+0x0114))	/* Melody Frequency Register */
N/* ---- */
N#define	RTCALMINCTR				*((volatile UINT32_t *)(RTC_MLD_Base+0x0200))	/* RTC ALM Interrupt Control Register */
N#define	RTCALMMIS				*((volatile UINT32_t *)(RTC_MLD_Base+0x0204))	/* RTC ALM Interrupt Status Register */
N
N/* ------------------------------------------------------------------------ */
N/* ADC						 : 0xF0080000	*/
N#define	ADREG0L					*((volatile UINT32_t *)(ADC_Base+0x0000))	/* AD Conversion Result Register 0 Low */
N#define	ADREG0H					*((volatile UINT32_t *)(ADC_Base+0x0004))	/* AD Conversion Result Register 0 High */
N#define	ADREG1L					*((volatile UINT32_t *)(ADC_Base+0x0008))	/* AD Conversion Result Register 1 Low */
N#define	ADREG1H					*((volatile UINT32_t *)(ADC_Base+0x000C))	/* AD Conversion Result Register 1 High */
N#define	ADREG2L					*((volatile UINT32_t *)(ADC_Base+0x0010))	/* AD Conversion Result Register 2 Low */
N#define	ADREG2H					*((volatile UINT32_t *)(ADC_Base+0x0014))	/* AD Conversion Result Register 2 High */
N#define	ADREG3L					*((volatile UINT32_t *)(ADC_Base+0x0018))	/* AD Conversion Result Register 3 Low */
N#define	ADREG3H					*((volatile UINT32_t *)(ADC_Base+0x001C))	/* AD Conversion Result Register 3 High */
N#define	ADREG4L					*((volatile UINT32_t *)(ADC_Base+0x0020))	/* AD Conversion Result Register 4 Low */
N#define	ADREG4H					*((volatile UINT32_t *)(ADC_Base+0x0024))	/* AD Conversion Result Register 4 High */
N#define	ADREG5L					*((volatile UINT32_t *)(ADC_Base+0x0028))	/* AD Conversion Result Register 5 Low */
N#define	ADREG5H					*((volatile UINT32_t *)(ADC_Base+0x002C))	/* AD Conversion Result Register 5 High */
N#define	ADREG6L					*((volatile UINT32_t *)(ADC_Base+0x0030))	/* AD Conversion Result Register 6 Low */
N#define	ADREG6H					*((volatile UINT32_t *)(ADC_Base+0x0034))	/* AD Conversion Result Register 6 High */
N#define	ADREG7L					*((volatile UINT32_t *)(ADC_Base+0x0038))	/* AD Conversion Result Register 7 Low */
N#define	ADREG7H					*((volatile UINT32_t *)(ADC_Base+0x003C))	/* AD Conversion Result Register 7 High */
N#define	ADREGSPL				*((volatile UINT32_t *)(ADC_Base+0x0040))	/* High-priority AD Conversion Result Register SP Low */
N#define	ADREGSPH				*((volatile UINT32_t *)(ADC_Base+0x0044))	/* High-priority AD Conversion Result Register SP High */
N#define	ADCOMREGL				*((volatile UINT32_t *)(ADC_Base+0x0048))	/* AD Conversion Result Compare Criterion Register 0 Low */
N#define	ADCOMREGH				*((volatile UINT32_t *)(ADC_Base+0x004C))	/* AD Conversion Result Compare Criterion Register 0 High */
N#define	ADMOD0					*((volatile UINT32_t *)(ADC_Base+0x0050))	/* AD Mode Control Register 0 */
N#define	ADMOD1					*((volatile UINT32_t *)(ADC_Base+0x0054))	/* AD Mode Control Register 1 */
N#define	ADMOD2					*((volatile UINT32_t *)(ADC_Base+0x0058))	/* AD Mode Control Register 2 */
N#define	ADMOD3					*((volatile UINT32_t *)(ADC_Base+0x005C))	/* AD Mode Control Register 3 */
N#define	ADMOD4					*((volatile UINT32_t *)(ADC_Base+0x0060))	/* AD Mode Control Register 4 */
N/* #define Reserved				*((volatile UINT32_t *)(ADC_Base+0x0064)) */
N/* #define Reserved				*((volatile UINT32_t *)(ADC_Base+0x0068)) */
N/* #define Reserved				*((volatile UINT32_t *)(ADC_Base+0x006C)) */
N#define	ADCLK					*((volatile UINT32_t *)(ADC_Base+0x0070))	/* AD Conversion Clock Setting Register */
N#define	ADIE					*((volatile UINT32_t *)(ADC_Base+0x0074))	/* AD Interrupt Enable Register */
N#define	ADIS					*((volatile UINT32_t *)(ADC_Base+0x0078))	/* AD Interrupt Status Register */
N#define	ADIC					*((volatile UINT32_t *)(ADC_Base+0x007C))	/* AD Interrupt Clear Register */
N/* #define Reserved				*((volatile UINT32_t *)(ADC_Base+0x0080)) */
N/* ...                                                                         */
N/* #define Reserved				*((volatile UINT32_t *)(ADC_Base+0x0FFC) */
N
N/* ------------------------------------------------------------------------ */
N/* WDT						 : 0xF0010000	*/
N#define	WdogLoad				*((volatile UINT32_t *)(WDT_Base+0x0000))	/* Watchdog load register */
N#define	WdogValue				*((volatile UINT32_t *)(WDT_Base+0x0004))	/* The current value for the watchdog counter */
N#define	WdogControl				*((volatile UINT32_t *)(WDT_Base+0x0008))	/* Watchdog control register */
N#define	WdogIntClr				*((volatile UINT32_t *)(WDT_Base+0x000C))	/* Clears the watchdog interrupt */
N#define	WdogRIS					*((volatile UINT32_t *)(WDT_Base+0x0010))	/* Watchdog raw interrupt status */
N#define	WdogMIS					*((volatile UINT32_t *)(WDT_Base+0x0014))	/* Watchdog masked interrupt status */
N/* ---- */
N#define	WdogLock				*((volatile UINT32_t *)(WDT_Base+0x0C00))	/* Watchdog Lock register */
N
N/* ------------------------------------------------------------------------ */
N/* PMC						 : 0xF0020000	*/
N#define	BPADATA					*((volatile UINT32_t *)(PMC_Base+0x0900))	/* PortA Data Set Register when Power Cut Mode */
N#define	BPBDATA					*((volatile UINT32_t *)(PMC_Base+0x0904))	/* PortB Data Set Register when Power Cut Mode */
N#define	BPCDATA					*((volatile UINT32_t *)(PMC_Base+0x0908))	/* PortC Data Set Register when Power Cut Mode */
N#define	BPDDATA					*((volatile UINT32_t *)(PMC_Base+0x090C))	/* PortD Data Set Register when Power Cut Mode */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0910) */
N#define	BPFDATA					*((volatile UINT32_t *)(PMC_Base+0x0914))	/* PortF Data Set Register when Power Cut Mode */
N#define	BPGDATA					*((volatile UINT32_t *)(PMC_Base+0x0918))	/* PortG Data Set Register when Power Cut Mode */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x091C) */
N/* ---- */
N#define	BPJDATA					*((volatile UINT32_t *)(PMC_Base+0x0924))	/* PortJ Data Set Register when Power Cut Mode */
N#define	BPKDATA					*((volatile UINT32_t *)(PMC_Base+0x0928))	/* PortK Data Set Register when Power Cut Mode */
N#define	BPLDATA					*((volatile UINT32_t *)(PMC_Base+0x092C))	/* PortL Data Set Register when Power Cut Mode */
N#define	BPMDATA					*((volatile UINT32_t *)(PMC_Base+0x0930))	/* PortM Data Set Register when Power Cut Mode */
N#define	BPNDATA					*((volatile UINT32_t *)(PMC_Base+0x0934))	/* PortN Data Set Register when Power Cut Mode */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x093C) */
N/* ---- */
N#define	BPRDATA					*((volatile UINT32_t *)(PMC_Base+0x0944))	/* PortR Data Set Register when Power Cut Mode */
N/* ---- */
N#define	BPTDATA					*((volatile UINT32_t *)(PMC_Base+0x094C))	/* PortT Data Set Register when Power Cut Mode */
N#define	BPUDATA					*((volatile UINT32_t *)(PMC_Base+0x0950))	/* PortU Data Set Register when Power Cut Mode */
N#define	BPVDATA					*((volatile UINT32_t *)(PMC_Base+0x0954))	/* PortV Data Set Register when Power Cut Mode */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0B80)) */
N#define	BPBOE					*((volatile UINT32_t *)(PMC_Base+0x0B84))	/* PortB Data Out Enable Control when Power Cut Mode */
N#define	BPCOE					*((volatile UINT32_t *)(PMC_Base+0x0B88))	/* PortC Data Out Enable Control when Power Cut Mode */
N#define	BPDOE					*((volatile UINT32_t *)(PMC_Base+0x0B8C))	/* PortD Data Out Enable Control when Power Cut Mode */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0B90)) */
N#define	BPFOE					*((volatile UINT32_t *)(PMC_Base+0x0B94))	/* PortF Data Out Enable Control when Power Cut Mode */
N#define	BPGOE					*((volatile UINT32_t *)(PMC_Base+0x0B98))	/* PortG Data Out Enable Control when Power Cut Mode */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0B9C)) */
N/* ---- */
N#define	BPJOE					*((volatile UINT32_t *)(PMC_Base+0x0BA4))	/* PortJ Data Out Enable Control when Power Cut Mode */
N#define	BPKOE					*((volatile UINT32_t *)(PMC_Base+0x0BA8))	/* PortK Data Out Enable Control when Power Cut Mode */
N#define	BPLOE					*((volatile UINT32_t *)(PMC_Base+0x0BAC))	/* PortL Data Out Enable Control when Power Cut Mode */
N#define	BPMOE					*((volatile UINT32_t *)(PMC_Base+0x0BB0))	/* PortM Data Out Enable Control when Power Cut Mode */
N#define	BPNOE					*((volatile UINT32_t *)(PMC_Base+0x0BB4))	/* PortN Data Out Enable Control when Power Cut Mode */
N/* ---- */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0BBC)) */
N/* ---- */
N#define	BPROE					*((volatile UINT32_t *)(PMC_Base+0x0BC4))	/* PortR Data Out Enable Control when Power Cut Mode */
N/* ---- */
N#define	BPTOE					*((volatile UINT32_t *)(PMC_Base+0x0BCC))	/* PortT Data Out Enable Control when Power Cut Mode */
N#define	BPUOE					*((volatile UINT32_t *)(PMC_Base+0x0BD0))	/* PortU Data Out Enable Control when Power Cut Mode */
N#define	BPVOE					*((volatile UINT32_t *)(PMC_Base+0x0BD4))	/* PortV Data Out Enable Control when Power Cut Mode */
N/* ---- */
N#define	BSADATA					*((volatile UINT32_t *)(PMC_Base+0x0800))	/* SA Data Set Register when Power Cut Mode */
N#define	BSBDATA					*((volatile UINT32_t *)(PMC_Base+0x0804))	/* SB Data Set Register when Power Cut Mode */
N#define	BSCDATA					*((volatile UINT32_t *)(PMC_Base+0x0808))	/* SC Data Set Register when Power Cut Mode */
N#define	BSDDATA					*((volatile UINT32_t *)(PMC_Base+0x080C))	/* SD Data Set Register when Power Cut Mode */
N#define	BSEDATA					*((volatile UINT32_t *)(PMC_Base+0x0810))	/* SE Data Set Register when Power Cut Mode */
N#define	BSFDATA					*((volatile UINT32_t *)(PMC_Base+0x0814))	/* SF Data Set Register when Power Cut Mode */
N#define	BSGDATA					*((volatile UINT32_t *)(PMC_Base+0x0818))	/* SG Data Set Register when Power Cut Mode */
N#define	BSHDATA					*((volatile UINT32_t *)(PMC_Base+0x081C))	/* SH Data Set Register when Power Cut Mode */
N/* ---- */
N#define	BSJDATA					*((volatile UINT32_t *)(PMC_Base+0x0824))	/* SJ Data Set Register when Power Cut Mode */
N#define	BSKDATA					*((volatile UINT32_t *)(PMC_Base+0x0828))	/* SK Data Set Register when Power Cut Mode */
N#define	BSLDATA					*((volatile UINT32_t *)(PMC_Base+0x082C))	/* SL Data Set Register when Power Cut Mode */
N/* ---- */
N#define	BSTDATA					*((volatile UINT32_t *)(PMC_Base+0x084C))	/* ST Data Set Register when Power Cut Mode */
N#define	BSUDATA					*((volatile UINT32_t *)(PMC_Base+0x0850))	/* SU Data Set Register when Power Cut Mode */
N/* ---- */
N#define	BSAOE					*((volatile UINT32_t *)(PMC_Base+0x0A80))	/* SA Data Out Enable Control when Power Cut Mode */
N#define	BSBOE					*((volatile UINT32_t *)(PMC_Base+0x0A84))	/* SB Data Out Enable Control when Power Cut Mode */
N#define	BSCOE					*((volatile UINT32_t *)(PMC_Base+0x0A88))	/* SC Data Out Enable Control when Power Cut Mode */
N#define	BSDOE					*((volatile UINT32_t *)(PMC_Base+0x0A8C))	/* SD Data Out Enable Control when Power Cut Mode */
N#define	BSEOE					*((volatile UINT32_t *)(PMC_Base+0x0A90))	/* SE Data Out Enable Control when Power Cut Mode */
N#define	BSFOE					*((volatile UINT32_t *)(PMC_Base+0x0A94))	/* SF Data Out Enable Control when Power Cut Mode */
N#define	BSGOE					*((volatile UINT32_t *)(PMC_Base+0x0A98))	/* SG Data Out Enable Control when Power Cut Mode */
N#define	BSHOE					*((volatile UINT32_t *)(PMC_Base+0x0A9C))	/* SH Data Out Enable Control when Power Cut Mode */
N/* ---- */
N#define	BSJOE					*((volatile UINT32_t *)(PMC_Base+0x0AA4))	/* SJ Data Out Enable Control when Power Cut Mode */
N#define	BSKOE					*((volatile UINT32_t *)(PMC_Base+0x0AA8))	/* SK Data Out Enable Control when Power Cut Mode */
N#define	BSLOE					*((volatile UINT32_t *)(PMC_Base+0x0AAC))	/* SL Data Out Enable Control when Power Cut Mode */
N/* ---- */
N#define	BSTOE					*((volatile UINT32_t *)(PMC_Base+0x0ACC))	/* ST Data Out Enable Control when Power Cut Mode */
N#define	BSUOE					*((volatile UINT32_t *)(PMC_Base+0x0AD0))	/* SU Data Out Enable Control when Power Cut Mode */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0AD4)) */
N/* #define Reserved				*((volatile UINT32_t *)(PMC_Base+0x0AD8)) */
N/* ---- */
N#define BPAIE					*((volatile UINT32_t *)(PMC_Base+0x0D80))	/* PortA WakeUp Input Enable */
N/* ---- */
N#define BPCIE					*((volatile UINT32_t *)(PMC_Base+0x0D88))	/* PortC WakeUp Input Enable */
N#define BPDIE					*((volatile UINT32_t *)(PMC_Base+0x0D8C))	/* PortD WakeUp Input Enable */
N/* ---- */
N#define BPFIE					*((volatile UINT32_t *)(PMC_Base+0x0D94))	/* PortF WakeUp Input Enable */
N/* ---- */
N#define BPNIE					*((volatile UINT32_t *)(PMC_Base+0x0DB4))	/* PortN WakeUp Input Enable */
N/* ---- */
N#define BPRIE					*((volatile UINT32_t *)(PMC_Base+0x0DC4))	/* PortR WakeUp Input Enable */
N/* ---- */
N#define	BPARELE					*((volatile UINT32_t *)(PMC_Base+0x0200))	/* PortA Enable Write Register of Wake-up trigger from Power Cut Mode */
N#define	BPDRELE					*((volatile UINT32_t *)(PMC_Base+0x0204))	/* PortD Enable Write Register of Wake-up trigger from Power Cut Mode */
N#define	BRTRELE					*((volatile UINT32_t *)(PMC_Base+0x0208))	/* RTC Request Enable Register of Wake-up trigger from Power Cut Mode */
N#define	BRXRELE					*((volatile UINT32_t *)(PMC_Base+0x020C))	/* Other Port Enable Register of Wake-up trigger from Power Cut Mode */
N/* ---- */
N#define	BPAEDGE	 				*((volatile UINT32_t *)(PMC_Base+0x0220))	/* PortA Selection Register of Wake-up trigger Edge from Power Cut Mode */
N#define	BPDEDGE					*((volatile UINT32_t *)(PMC_Base+0x0224))	/* PortD Selection Register of Wake-up trigger Edge from Power Cut Mode */
N/* ---- */
N#define	BPXEDGE					*((volatile UINT32_t *)(PMC_Base+0x022C))	/* Other Port Selection Register of Wake-up trigger Edge from Power Cut Mode */
N/* ---- */
N#define	BADRINT					*((volatile UINT32_t *)(PMC_Base+0x0240))	/* PortA Wake-up Interrupt status Register */
N#define	BPDRINT					*((volatile UINT32_t *)(PMC_Base+0x0244))	/* PortD Wake-up Interrupt status Register */
N#define	BRTRINT					*((volatile UINT32_t *)(PMC_Base+0x0248))	/* RTC Wake-up Interrupt status Register */
N#define	BPXRINT					*((volatile UINT32_t *)(PMC_Base+0x024C))	/* Other Port Wake-up Interrupt status Register */
N/* ---- */
N#define	PMCDRV					*((volatile UINT32_t *)(PMC_Base+0x0260))	/* External Port Driverbility control Register */
N/* ---- */
N#define	DMCCKECTL				*((volatile UINT32_t *)(PMC_Base+0x0280))	/* DMCCKE pin setting Register(PCM mode) */
N/* ---- */
N#define	PMCCTL					*((volatile UINT32_t *)(PMC_Base+0x0300))	/* Power Management Circuit Control Register */
N/* ---- */
N#define	PMCWV1					*((volatile UINT32_t *)(PMC_Base+0x400))	/* Control for PMC Register */
N/* ---- */
N#define	PMCWV2					*((volatile UINT32_t *)(PMC_Base+0x408))	/* Control for XT_CTL Control Register */
N/* ---- */
N#define PMCRES					*((volatile UINT32_t *)(PMC_Base+0x41C))	/* PCM_ON Flag Clear Register for PMCCTL_R<PMC_ON> */
N
N/* ------------------------------------------------------------------------ */
N/* USBH						 : 0xF4500000	*/
N#define	HcRevision				*((volatile UINT32_t *)(USBH_Base+0x0000))	/*  */
N#define	HcControl				*((volatile UINT32_t *)(USBH_Base+0x0004))	/*  */
N#define	HcCommandStatus			*((volatile UINT32_t *)(USBH_Base+0x0008))	/*  */
N#define	HcInterruptStatus		*((volatile UINT32_t *)(USBH_Base+0x000C))	/*  */
N#define	HcInterruptEnable		*((volatile UINT32_t *)(USBH_Base+0x0010))	/*  */
N#define	HcInterruptDisable		*((volatile UINT32_t *)(USBH_Base+0x0014))	/*  */
N#define	HcHCCA					*((volatile UINT32_t *)(USBH_Base+0x0018))	/*  */
N#define	HcPeriodCurrentED		*((volatile UINT32_t *)(USBH_Base+0x001C))	/*  */
N#define	HcControlHeadED			*((volatile UINT32_t *)(USBH_Base+0x0020))	/*  */
N#define	HcControlCurrentED		*((volatile UINT32_t *)(USBH_Base+0x0024))	/*  */
N#define	HcBulkHeadED			*((volatile UINT32_t *)(USBH_Base+0x0028))	/*  */
N#define	HcBulkCurrentED			*((volatile UINT32_t *)(USBH_Base+0x002C))	/*  */
N#define	HcDoneHead				*((volatile UINT32_t *)(USBH_Base+0x0030))	/*  */
N#define	HcFmInterval			*((volatile UINT32_t *)(USBH_Base+0x0034))	/*  */
N#define	HcFmRemaining			*((volatile UINT32_t *)(USBH_Base+0x0038))	/*  */
N#define	HcFmNumber				*((volatile UINT32_t *)(USBH_Base+0x003C))	/*  */
N#define	HcPeriodStart			*((volatile UINT32_t *)(USBH_Base+0x0040))	/*  */
N#define	HcLSThreshold			*((volatile UINT32_t *)(USBH_Base+0x0044))	/*  */
N#define	HcRhDescriptorA			*((volatile UINT32_t *)(USBH_Base+0x0048))	/*  */
N#define	HcRhDescripterB			*((volatile UINT32_t *)(USBH_Base+0x004C))	/*  */
N#define	HcRhStatus				*((volatile UINT32_t *)(USBH_Base+0x0050))	/*  */
N#define	HcRhPortStatus			*((volatile UINT32_t *)(USBH_Base+0x0054))	/*  */
N/* #define Reserved				*((volatile UINT32_t *)(USBH_Base+0x0058))	  */
N/* #define Reserved				*((volatile UINT32_t *)(USBH_Base+0x005C))	  */
N/* ---- */
N#define	HCBCR0					*((volatile UINT32_t *)(USBH_Base+0x0080))	/*  */
N
N/* ------------------------------------------------------------------------ */
N/* OFD						 : 0xF0090000	*/
N#define	CLKSCR1					*((volatile UINT32_t *)(OFD_Base+0x0000))	/* Oscillation frequency detectiton control register1 */
N#define	CLKSCR2					*((volatile UINT32_t *)(OFD_Base+0x0004))	/* Oscillation frequency detectiton control register2 */
N#define	CLKSCR3					*((volatile UINT32_t *)(OFD_Base+0x0008))	/* Oscillation frequency detectiton control register3 */
N/* ---- */
N#define	CLKSMN					*((volatile UINT32_t *)(OFD_Base+0x0010))	/* Lower detection frequency setting register */
N/* ---- */
N#define	CLKSMX					*((volatile UINT32_t *)(OFD_Base+0x0020))	/* Higher detection frequency setting register */
N
N/* ************************************************************************ */
N#endif	/* _TMPA900CM_H_ */
L 676 "src\user\hwtester.c" 2
N        getTerminalChar();
N    }
N    while(guiResponseFlag)
N    {//empty registor buffer
N        getGuiResponse();
N    }
N    while(1)
N    {//wait user respone
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(sysIsKbHit())
N        {
N            return getTerminalChar();
N        }
N        if(guiResponseFlag)
N        {
N            return getGuiResponse();
N        }
N    }
N}
N
Nstatic char userResponse(void)
N{
N    char reVal = FALSE;
X    char reVal = (0);
N    if(sysIsKbHit())
N    {
N        reVal = getTerminalChar();
N    }
N    if(guiResponseFlag)
N    {
N        reVal = getGuiResponse();
N    }
N    while(sysIsKbHit())
N    {//empty registor buffer
N        getTerminalChar();
N    }
N    while(guiResponseFlag)
N    {//empty registor buffer
N        getGuiResponse();
N    }
N    return reVal;
N}
N
N
Nstatic char superResponseLoop(void)
N{
N    while(sysIsKbHit())
N    {//empty registor buffer
N        sysGetChar();
N    }
N    while(guiResponseFlag)
N    {//empty registor buffer
N        getGuiResponse();
N    }
N    while(1)
N    {//wait user respone
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(sysIsKbHit())
N        {
N            return sysGetChar();
N        }
N        if(guiResponseFlag)
N        {
N            return getGuiResponse();
N        }
N    }
N}
N
Nstatic char superResponseLoopEx(void)
N{
N    while(sysIsKbHit())
N    {//empty registor buffer
N        sysGetChar();
N    }
N    while(guiResponseFlag)
N    {//empty registor buffer
N        getGuiResponse();
N    }
N    while(1)
N    {//wait user respone
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(sysIsKbHit())
N        {
N            TouchPadResponseFlag = FALSE;
X            TouchPadResponseFlag = (0);
N            return sysGetChar();
N        }
N        if(guiResponseFlag)
N        {
N            TouchPadResponseFlag = TRUE;
X            TouchPadResponseFlag = (1);
N            return getGuiResponse();
N        }
N    }
N}
N
N#if (!ENABLE_BURNIN_TESTER)
X#if (!1)
Sstatic BOOL LEDColorBuffSet(UINT16 GreenPinBite, UINT16 RedPinBite)
N#else
NBOOL LEDColorBuffSet(UINT16 GreenPinBite, UINT16 RedPinBite)
N#endif
N{
N    UINT8 i;
N    for(i=0;i<=5;i++)
N    {
N        if(((RedPinBite >> i)& 0x1) == 1)
N        {
N            bayColorChange[i] = LIGHT_COLOR_RED;
X            bayColorChange[i] = 2;
N        }
N        else if(((GreenPinBite >> i)& 0x1) == 1)
N        {
N            bayColorChange[i] = LIGHT_COLOR_GREEN;
X            bayColorChange[i] = 1;
N        }
N        else
N        {
N            bayColorChange[i] = LIGHT_COLOR_OFF;
X            bayColorChange[i] = 0;
N        }
N    }
N    return TRUE;
X    return (1);
N}
N
N#if (!ENABLE_BURNIN_TESTER)
X#if (!1)
Sstatic BOOL LEDBoardLightSet(void)
N#else
NBOOL LEDBoardLightSet(void)
N{
N    //setPrintfFlag(FALSE);    
N    LedSetColor(bayColorChange, LIGHT_COLOR_OFF, TRUE); 
X    LedSetColor(bayColorChange, 0, (1)); 
N    //setPrintfFlag(TRUE);
N    return TRUE;
X    return (1);
N}
N#endif
Nstatic uint8_t guiManagerShowScreen(uint8_t guiId, uint8_t para, int para2, int para3)
N{
N    if(isEPDInit)
N    {
N        return GuiManagerShowScreen(guiId,para,para2,para3);
N    }
N    return 0;
N}
Nstatic BOOL guiManagerRefreshScreen(void)
N{
N    if(isEPDInit)
N    {
N        return GuiManagerRefreshScreen();
N    }
N    return FALSE;
X    return (0);
N}
Nstatic BOOL guiManagerResetKeyCallbackFunc(void)
N{
N    if(isEPDInit)
N    {
N        return GuiManagerResetKeyCallbackFunc();
N    }
N    return FALSE;
X    return (0);
N}
Nstatic BOOL guiManagerCompareCurrentScreenId(uint8_t guiId)
N{
N    if(isEPDInit)
N    {
N        return GuiManagerCompareCurrentScreenId(guiId);
N    }
N    return FALSE;
X    return (0);
N}
N//static BOOL guiManagerResetInstance(void){
N//    if(isEPDInit)
N//        return GuiManagerResetInstance();
N//    return FALSE;
N//}
N#define X_POS_RST 550
N#define Y_POS_RST 154
N#define X_POS_MSG 550
N#define Y_POS_MSG 354 //304
N
N#define X_RETRY_BAR_MSG 550
N#define Y_RETRY_BAR_MSG 556
N
Nstatic void guiPrintResult(char* str)
N{
N    if(isEPDInit)
N    {
N        //vTaskDelay(15/portTICK_RATE_MS);
N        EPDDrawString(FALSE,"                 \n                \n",X_POS_RST,Y_POS_RST);
X        EPDDrawString((0),"                 \n                \n",550,154);
N        EPDDrawString(TRUE ,str,X_POS_RST,Y_POS_RST);
X        EPDDrawString((1) ,str,550,154);
N    }
N}
N
Nstatic void guiPrintMessage(char* str)
N{
N    if(isEPDInit)
N    {
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawContainByIDPos(FALSE,EPD_PICT_KEY_CLEAN_BAR,X_POS_MSG-2,Y_POS_MSG-2);
X        EPDDrawContainByIDPos((0),EPD_PICT_KEY_CLEAN_BAR,550-2,354-2);
N        EPDDrawString(TRUE,str,X_POS_MSG,Y_POS_MSG);
X        EPDDrawString((1),str,550,354);
N    }
N}
Nstatic void guiPrintMessageNoClean(char* str)
N{
N    if(isEPDInit)
N    {
N        //EPDDrawContainByIDPos(FALSE,EPD_PICT_KEY_CLEAN_BAR,X_POS_MSG-2,Y_POS_MSG-2);
N        EPDDrawString(TRUE,str,X_POS_MSG,Y_POS_MSG);
X        EPDDrawString((1),str,550,354);
N    }
N}
Nstatic void cleanMsg(void){
N    if(isEPDInit)
N    {
N        //CLEAR MSG BAR//
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawContainByIDPos(FALSE,EPD_PICT_KEY_CLEAN_BAR,X_POS_MSG-2,Y_POS_MSG-2);
X        EPDDrawContainByIDPos((0),EPD_PICT_KEY_CLEAN_BAR,550-2,354-2);
N    }
N}
N
Nstatic void cleanRst(void){
N    if(isEPDInit)
N    {
N        //CLEAR MSG BAR//
N        EPDDrawString(FALSE,"         ",X_POS_RST+200,Y_POS_RST-50);
X        EPDDrawString((0),"         ",550+200,154-50);
N        EPDDrawString(TRUE,"                 \n                \n",X_POS_RST,Y_POS_RST);
X        EPDDrawString((1),"                 \n                \n",550,154);
N    }
N}
N
Nstatic void SolarValtageCalibration(void)
N{
N    char tempchar;
N    char* numberString = NULL;
X    char* numberString = 0;
N    UINT8 firststringflag = 1;
N    UINT8 changenumberflag = 0;
N
N    char str[20];
N   
N
N    int number = 0;
N    //terninalPrintf("\r\nLast VCOM value = %d \r\n",IT8951GetVCOM());
N    terninalPrintf("Please enter AjustSolarBatFactor Value in decimal, now value = %d\r\n",ShowAjustSolarBatFactor());
N    terninalPrintf("Enter number is ");
N    
N
N    
N    char charTmp;
N    unsigned int idTmp=0,i=0;
N
N    while(1){
N        //charTmp=userResponseLoop();
N        
N        charTmp = superResponseLoop();
N        
N        if(charTmp>='0'&&charTmp<='9')
N        {
N            idTmp=idTmp*10;
N            idTmp+=(charTmp-'0');
N            i++;
N            terninalPrintf("%c",charTmp);
N        }
N        if(charTmp == 0x0D)
N        {
N            ModifyAjustSolarBatFactor(idTmp);
N            break;
N        }
N        if((charTmp=='y') || (charTmp=='q'))
N        {
N            break;
N        }
N        if(i==5)
N        {
N            ModifyAjustSolarBatFactor(idTmp);           
N            break;
N        }
N    }
N    terninalPrintf("\r\n");
N    
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    
W "src\user\hwtester.c" 897 10 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 898 11 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 899 11 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 900 11 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 902 10 variable "str" was declared but never referenced
W "src\user\hwtester.c" 905 9 variable "number" was declared but never referenced
N}
N
Nstatic BOOL SetEPDVCOM(void)
N{
N    char tempchar;
N    char* numberString = NULL;
X    char* numberString = 0;
N    UINT8 firststringflag = 1;
N    UINT8 changenumberflag = 0;
N
N    char str[20];
N   
N
N    int number = 0;
N    //terninalPrintf("\r\nLast VCOM value = %d \r\n",IT8951GetVCOM());
N    terninalPrintf("Please enter EPD VCOM Value in decimal.\r\n");
N    terninalPrintf("Enter number is ");
N    
N    /*
N    do
N    {   
N        tempchar = superResponseLoop();  
N
N        terninalPrintf("%c",tempchar);
N        if((tempchar >= 48) && (tempchar <= 57))   
N        { 
N            changenumberflag = 1;
N            if(firststringflag == 0)
N                sprintf(numberString,"%s%c",numberString,tempchar);
N            else
N            {
N                sprintf(numberString,"%c",tempchar);
N                firststringflag = 0;
N            }
N                
N        }
N
N    }while(tempchar != 0x0D);
N
N    if (changenumberflag)
N        number = atoi(numberString);
N
N    terninalPrintf("\r\n");
N    if (changenumberflag)
N        IT8951SetVCOM(number);
N    
N    */
N    
N    //terninalPrintf("New VCOM value = %d \r\n",IT8951GetVCOM());
N    
N    char charTmp;
N    unsigned int idTmp=0,i=0;
N    //terninalPrintf("Current Device ID: %05d\nPlease Enter 5 Digit Number To Set Device ID\n",getDeviceID(0,0));
N    //terninalPrintf("Press 'q' to quit without save...\n");
N    while(1){
N        //charTmp=userResponseLoop();
N        
N        charTmp = superResponseLoop();
N        
N        if(charTmp>='0'&&charTmp<='9')
N        {
N            idTmp=idTmp*10;
N            idTmp+=(charTmp-'0');
N            i++;
N            terninalPrintf("%c",charTmp);
N        }
N        if(charTmp == 0x0D)
N        {
N            //setDeviceID(&epmIDSet,NULL);//empIDSet is set by guisettingid
N            *setVCOMpoint = idTmp;
N            IT8951SetVCOM(idTmp);
N            break;
N        }
N        if((charTmp=='y') || (charTmp=='q'))
N        {
N            break;
N        }
N        if(i==5)
N        {
N            //setDeviceID(&idTmp,NULL);
N            *setVCOMpoint = idTmp;
N            IT8951SetVCOM(idTmp);
N            break;
N        }
N    }
N    terninalPrintf("\r\n");
N    
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    return TRUE;
X    return (1);
N
N
W "src\user\hwtester.c" 951 10 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 952 11 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 953 11 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 954 11 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 956 10 variable "str" was declared but never referenced
W "src\user\hwtester.c" 959 9 variable "number" was declared but never referenced
N}
N
N
Nstatic BOOL SetEPDVCOMEx(void)
N{
N    char tempchar;
N    char* numberString = NULL;
X    char* numberString = 0;
N    UINT8 firststringflag = 1;
N    UINT8 changenumberflag = 0;
N
N    char str[20];
N   
N
N    int number = 0;
N    //terninalPrintf("\r\nLast VCOM value = %d \r\n",IT8951GetVCOM());
N    terninalPrintf("Please enter EPD VCOM Value in decimal.\r\n");
N    terninalPrintf("Enter number is ");
N    
N
N    
N    char charTmp;
N    unsigned int idTmp=0,i=0;
N
N    while(1){
N        //charTmp=userResponseLoop();
N        
N        charTmp = superResponseLoop();
N        
N        if(charTmp>='0'&&charTmp<='9')
N        {
N            idTmp=idTmp*10;
N            idTmp+=(charTmp-'0');
N            i++;
N            terninalPrintf("%c",charTmp);
N        }
N        if(charTmp == 0x0D)
N        {
N            //setDeviceID(&epmIDSet,NULL);//empIDSet is set by guisettingid
N            //*setVCOMpoint = idTmp;
N            setVCOMEx = idTmp;
N            
N            //IT8951SetVCOM(idTmp);
N            break;
N        }
N        if((charTmp=='y') || (charTmp=='q'))
N        {
N            break;
N        }
N        if(i==5)
N        {
N            //setDeviceID(&idTmp,NULL);
N            //*setVCOMpoint = idTmp;
N            setVCOMEx = idTmp;
N            //IT8951SetVCOM(idTmp);
N            break;
N        }
N    }
N    terninalPrintf("\r\n");
N    
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    return TRUE;
X    return (1);
N
N
W "src\user\hwtester.c" 1043 10 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 1044 11 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 1045 11 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 1046 11 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 1048 10 variable "str" was declared but never referenced
W "src\user\hwtester.c" 1051 9 variable "number" was declared but never referenced
N}
N
N
Nstatic BOOL W25Q64BVQuery(void)
N{
N    char tempchar;
N    char* numberString = NULL;
X    char* numberString = 0;
N    UINT8 firststringflag = 1;
N    UINT8 changenumberflag = 0;
N
N    char str[20];
N   
N
N    int number = 0;
N    
N    terninalPrintf("Please enter flash memory address in decimal.\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {   
N        tempchar = superResponseLoop();  
N
N        terninalPrintf("%c",tempchar);
N        if((tempchar >= 48) && (tempchar <= 57))   
N        { 
N            changenumberflag = 1;
N            if(firststringflag == 0)
N                sprintf(numberString,"%s%c",numberString,tempchar);
N            else
N            {
N                sprintf(numberString,"%c",tempchar);
N                firststringflag = 0;
N            }
N                
N        }
N
N    }while(tempchar != 0x0D);
N
N    if (changenumberflag)
N        number = atoi(numberString);
N
N    terninalPrintf("\r\n");
N    if (changenumberflag)
N        W25Q64BVquery(number);
N    
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    return TRUE;
X    return (1);
N
N
W "src\user\hwtester.c" 1112 10 variable "str" was declared but never referenced
N}
N
N
Nstatic BOOL W25Q64BVerase(void)
N{
N    int waitime = 20;
N    int waitCounter = 30;
N    int retryTime = 0;
N    W25Q64BVErase();
N
N    GPIO_ClrBit(GPIOI, BIT0); 
X    GPIO_ClrBit(GPIOI, (0x00000001)); 
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    do{
N        waitime = 20 - retryTime;
N        if(waitime <= 0)
N            waitime = 0;
N        terninalPrintf("W25Q64BV erasing,please wait %d second...\r",waitime);
N        if(SpiFlash_WaitEraseReady())
N            break;
N        retryTime++;
N        waitCounter--;
N    }
N    while(waitCounter > 0);
N
N    GPIO_SetBit(GPIOI, BIT0);
X    GPIO_SetBit(GPIOI, (0x00000001));
N    if(waitCounter <= 0)
N        return FALSE;
X        return (0);
N    else
N        return TRUE;
X        return (1);
N    
N    
N    
N    /*
N    int waitime = 15;
N    W25Q64BVErase();
N
N    for(int i=0;i<waitime;i++)
N    {
N        terninalPrintf("W25Q64BV erasing,please wait %d second...\r",waitime-i);
N        vTaskDelay(1000/portTICK_RATE_MS);
N    }  
N    terninalPrintf("W25Q64BV erase complete.                      \r\n");
N
N
N    return TRUE;
N
N    */
N}
N
Nstatic BOOL W25Q64BVburn(void)
N{
N
N    
N    
N        char tempchar;
N        char* numberString = NULL;
X        char* numberString = 0;
N        UINT8 firststringflag = 1;
N        UINT8 changenumberflag = 0;
N    
N        int binselect;
N        //int count = 2560;
N        //uint8_t u8DataBuffer[count];
N        int  SDbufferSize = 2560 ;
N        uint8_t SDbuffer[SDbufferSize];
N        FIL file;
N        UINT br;
N        char * binString;
N    
N        
N        terninalPrintf("Open SD card bin file DefaultTest.bin .\r\n");
N        /*
N        //terninalPrintf("Please select bin file. 0:DefaultTest_1.01.06.bin  1:DefaultTest.bin\r\n");
N        terninalPrintf("Please select bin file. 1:DefaultTest.bin\r\n");
N        terninalPrintf("Enter number is ");
N        do
N        {   
N            tempchar = superResponseLoop();  
N
N            terninalPrintf("%c",tempchar);
N            if((tempchar >= 48) && (tempchar <= 57))   
N            { 
N                changenumberflag = 1;
N                if(firststringflag == 0)
N                    sprintf(numberString,"%s%c",numberString,tempchar);
N                else
N                {
N                    sprintf(numberString,"%c",tempchar);
N                    firststringflag = 0;
N                }
N                    
N            }
N
N        }while(tempchar != 0x0D);
N        
N        terninalPrintf("\r\n");
N    
N        if (changenumberflag)
N        binselect = atoi(numberString);
N        
N    
N        if(binselect == 1)
N        {
N            binString = "0:DefaultTest.bin"; //"0:DefaultTest_1.01.06.bin" ;
N        }
N        else
N        {
N            binString = "0:DefaultTest.bin" ;
N        }
N        */
N        
N        binString = "0:DefaultTest.bin";
N        
N
N        
N        
N        
N        
W "src\user\hwtester.c" 1268 13 function "UserDrvInit" declared implicitly
N        if(!UserDrvInit(FALSE))
X        if(!UserDrvInit((0)))
N        {
N            terninalPrintf("UserDrvInit fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N        if(!FatfsInit(TRUE))
X        if(!FatfsInit((1)))
N        {
N            terninalPrintf("FatfsInit fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N        //if(f_open(&file, "0:DefaultTest_1.01.06.bin", FA_OPEN_EXISTING |FA_READ))
N        if(f_open(&file, binString, FA_OPEN_EXISTING |FA_READ))
X        if(f_open(&file, binString, 0x00 |0x01))
N        {
N            terninalPrintf("SD card file open fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N        
N        if(W25Q64BVerase() == FALSE)
X        if(W25Q64BVerase() == (0))
N        {
N            terninalPrintf("Erase fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N
N        int count = file.fsize / SDbufferSize;
N        int remain = file.fsize % SDbufferSize;
N        int progress = count / 10 ;
N        
N        //terninalPrintf("file.fsize = %d\r\n",file.fsize);
N        //terninalPrintf("count = %d\r\n",count);
N        //terninalPrintf("remain = %d\r\n",remain);
N        //terninalPrintf("progress = %d\r\n",progress);
N        terninalPrintf("W25Q64BV burning...\r\n");
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        GPIO_ClrBit(GPIOI, BIT0); 
X        GPIO_ClrBit(GPIOI, (0x00000001)); 
N        //vTaskDelay(10/portTICK_RATE_MS);
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        
N        for(int i=0;i<count;i++)
N        {
N            if(i%progress == 0)
N            {
N                terninalPrintf("%d%% complete...\r",(i/progress)*10);
N            }
N            
N            f_read(&file, SDbuffer, 2560, &br);
N            W25Q64BVBurn(i*SDbufferSize,(uint8_t *) SDbuffer,sizeof(SDbuffer) );
N        }
N        
N        if(remain != 0)
N        {
N            f_read(&file, SDbuffer, remain, &br);
N            W25Q64BVBurn(count*SDbufferSize,(uint8_t *) SDbuffer,remain );
N        }
N        
N        GPIO_SetBit(GPIOI, BIT0);
X        GPIO_SetBit(GPIOI, (0x00000001));
N        
N        
N        
N        /*
N        for(int i=0;i<count;i++)
N        {
N            SDbuffer[i] = i%256;   
N        }  */
N
N
N        /*for(int k=0;k<10;k++)
N        {
N            terninalPrintf("%d%% complete...\r",(k+1)*10);
N            for(int j=0;j<325;j++)
N                {
N                    W25Q64BVBurn(k*325*SDbufferSize+j*SDbufferSize,(uint8_t *) SDbuffer,sizeof(SDbuffer) );
N                }
N        }  */
N        terninalPrintf("\r\n");
N
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        f_close(&file);
N        
N        return TRUE;
X        return (1);
N
W "src\user\hwtester.c" 1205 14 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 1206 15 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 1207 15 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 1208 15 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 1210 13 variable "binselect" was declared but never referenced
N}
N
N
Nstatic BOOL W25Q64BVFetch(void)
N{
N
N    
N
N        char tempchar;
N        char* numberString = NULL;
X        char* numberString = 0;
N        UINT8 firststringflag = 1;
N        UINT8 changenumberflag = 0;
N    
N        int binselect;
N        //int count = 2560;
N        //uint8_t u8DataBuffer[count];
N        //int  SDbufferSize = 2560 ;
N        int totalSize;
N        int  SDbufferSize = 2000 ;
N        uint8_t SDbuffer[SDbufferSize];
N        FIL file,fileread;
N        //FIL file;
N        UINT br;
N        char * binString;
N    
N        
N        terninalPrintf("\r\n");
N        
N        binString = "0:DefaultTest.bin";
N        
N        
N        
N        
N        
W "src\user\hwtester.c" 1382 13 function "UserDrvInit" declared implicitly
N        if(!UserDrvInit(FALSE))
X        if(!UserDrvInit((0)))
N        {
N            terninalPrintf("UserDrvInit fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N        if(!FatfsInit(TRUE))
X        if(!FatfsInit((1)))
N        {
N            terninalPrintf("FatfsInit fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N        
N        //if(f_open(&file, "0:DefaultTest_1.01.06.bin", FA_OPEN_EXISTING |FA_READ))
N        if(f_open(&file, binString, FA_OPEN_EXISTING |FA_READ))
X        if(f_open(&file, binString, 0x00 |0x01))
N        {
N            terninalPrintf("SD card file open %s fail.\r\n",binString);
N            return FALSE;
X            return (0);
N        }
N        
N        
N        totalSize = file.fsize;
N        int count = file.fsize / SDbufferSize;
N        int remain = file.fsize % SDbufferSize;
N        int progress = count / 10 ;
N
N        
N        
N        
N        
N        if(f_open(&fileread,"0:EPDdebug.bin", FA_CREATE_ALWAYS | FA_WRITE))
X        if(f_open(&fileread,"0:EPDdebug.bin", 0x08 | 0x02))
N        {
N            terninalPrintf("SD card file open EPDdebug.bin fail.\r\n");
N            return FALSE;
X            return (0);
N        }
N       
N        terninalPrintf("file.fsize = %d\r\n",totalSize);
N        terninalPrintf("count = %d\r\n",count);
N        terninalPrintf("remain = %d\r\n",remain);
N        terninalPrintf("progress = %d\r\n",progress);
N        //terninalPrintf("W25Q64BV burning...\r\n");
N         
N         
N         //int count = 50;
N         //int progress = 5;
N         //int remain  = 3;
N        
N        GPIO_ClrBit(GPIOI, BIT0); 
X        GPIO_ClrBit(GPIOI, (0x00000001)); 
N        vTaskDelay(10/portTICK_RATE_MS);
X        vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N         
N        for(int i=0;i<count;i++)
N        {
N            if(i%progress == 0)
N            {
N                terninalPrintf("%d%% complete...\r",(i/progress)*10);
N            }
N            
N            //f_read(&file, SDbuffer, 2560, &br);
N            //W25Q64BVBurn(i*SDbufferSize,(uint8_t *) SDbuffer,sizeof(SDbuffer) );
N            //terninalPrintf("i = %d\r\n",i);
N            W25Q64BVqueryEx(i*SDbufferSize,SDbuffer,sizeof(SDbuffer));
N            //W25Q64BVquery(i);
N            //W25Q64BVqueryEx(i*SDbufferSize,NULL,sizeof(SDbuffer));
N            f_write(&fileread, SDbuffer, SDbufferSize, &br);
N            
N        }
N        
N        if(remain != 0)
N        {   
N            //f_read(&file, SDbuffer, remain, &br);
N            //W25Q64BVBurn(count*SDbufferSize,(uint8_t *) SDbuffer,remain );
N            
N            W25Q64BVqueryEx(count*SDbufferSize,SDbuffer,remain);
N            f_write(&fileread, SDbuffer, remain, &br);
N            
N        }
N        
N        
N        GPIO_SetBit(GPIOI, BIT0);
X        GPIO_SetBit(GPIOI, (0x00000001));
N        
N        
N
N        terninalPrintf("\r\n");
N
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        f_close(&file);
N        f_close(&fileread);
N        return TRUE;
X        return (1);
N
W "src\user\hwtester.c" 1356 14 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 1357 15 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 1358 15 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 1359 15 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 1361 13 variable "binselect" was declared but never referenced
N}
N
N
N
Nstatic BOOL RadarOTAprogramTool(int radarIndex)
N{
N    char tempchar;
N    char* numberString = NULL;
X    char* numberString = 0;
N    UINT8 firststringflag = 1;
N    UINT8 changenumberflag = 0;
N
N    int binselect;
N    int  SDbufferSize = 256 ;
N    uint8_t SDbuffer[SDbufferSize];
N    FIL file;
N    UINT br;
N    char * binString;
N    if(radarIndex)
N    {
N        EPDDrawString(FALSE,"            ",700,100+(44*(2)));
X        EPDDrawString((0),"            ",700,100+(44*(2)));
N        EPDDrawString(FALSE,"Wait.       ",700,100+(44*(3)));
X        EPDDrawString((0),"Wait.       ",700,100+(44*(3)));
N    }
N    else
N    {
N        EPDDrawString(FALSE,"Wait.       ",700,100+(44*(2)));
X        EPDDrawString((0),"Wait.       ",700,100+(44*(2)));
N        EPDDrawString(FALSE,"            ",700,100+(44*(3)));
X        EPDDrawString((0),"            ",700,100+(44*(3)));
N    }
N    EPDDrawString(FALSE,"                                 ",50,100+(44*(8)));
X    EPDDrawString((0),"                                 ",50,100+(44*(8)));
N    EPDDrawString(FALSE,"                                 ",50,100+(44*(9)));
X    EPDDrawString((0),"                                 ",50,100+(44*(9)));
N    EPDDrawString(FALSE,"                                 ",50,100+(44*(10)));
X    EPDDrawString((0),"                                 ",50,100+(44*(10)));
N    EPDDrawString(TRUE,"                                 ",50,100+(44*(11)));
X    EPDDrawString((1),"                                 ",50,100+(44*(11)));
N    
N    static RadarInterface* pRadarInterface;
N
N    pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(0);
N
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N    }
N
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N    }
N    
N    
N    
N    
N    
N    
N    /*
N    terninalPrintf("Please select bin file. 0:OTA_Test.bin  1:RadarLidar_V1.0.46.Beta.bin  2:RadarLidar_V1.0.44.Beta.bin  ");
N    terninalPrintf("3:RadarLidar_1.0.42.Beta.bin  4:RadarLidar_1.0.41.Beta.bin  5:RadarLidar_1.0.40.Beta.bin\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {   
N        tempchar = superResponseLoop();  
N
N        terninalPrintf("%c",tempchar);
N        if((tempchar >= 48) && (tempchar <= 57))   
N        { 
N            changenumberflag = 1;
N            if(firststringflag == 0)
N                sprintf(numberString,"%s%c",numberString,tempchar);
N            else
N            {
N                sprintf(numberString,"%c",tempchar);
N                firststringflag = 0;
N            }
N                
N        }
N
N    }while(tempchar != 0x0D);
N    
N    terninalPrintf("\r\n");
N
N    if (changenumberflag)
N    binselect = atoi(numberString);  */
N   /* 
N    for(int s=0;s<100;s++)
N    {
N    
N    terninalPrintf("s = %d \r\n",s);
N    binselect = (s%5) + 1 ; 
N        
N    terninalPrintf("Enter number = %d \r\n",binselect);  */
N/*
N    switch(binselect) { 
N        case 0: 
N            binString = "0:RadarLidar_V1.0.46.Beta.bin"; //"0:OTA_Test.bin";
N            break;
N        case 1: 
N            binString = "0:RadarLidar_V1.0.46.Beta.bin"; 
N            break; 
N        case 2: 
N            binString = "0:RadarLidar_V1.0.44.Beta.bin"; 
N            break; 
N        case 3: 
N            binString = "0:RadarLidar_1.0.42.Beta.bin"; 
N            break; 
N        case 4: 
N            binString = "0:RadarLidar_1.0.41.Beta.bin"; 
N            break; 
N        case 5: 
N            binString = "0:RadarLidar_1.0.40.Beta.bin"; 
N            break; 
N
N        default: 
N            binString = "0:RadarLidar_V1.0.46.Beta.bin"; 
N    } */
N    
N    //terninalPrintf("binString = %s \r\n",binString);
N    vTaskDelay(5000/portTICK_RATE_MS);
X    vTaskDelay(5000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    binString = "0:OTA.bin";
N    
N    
N    
N    pRadarInterface->setPowerStatusFunc(radarIndex,FALSE);
X    pRadarInterface->setPowerStatusFunc(radarIndex,(0));
N    vTaskDelay(500/portTICK_RATE_MS);
X    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    pRadarInterface->setPowerStatusFunc(radarIndex,TRUE);
X    pRadarInterface->setPowerStatusFunc(radarIndex,(1));
N    vTaskDelay(3000/portTICK_RATE_MS);
X    vTaskDelay(3000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    char templastString[50] ;
N    char tempRadarlastVersionString[50];
N    int lastretryCounter = 3;
N    
N    
N    while(lastretryCounter>0)
N    {
N        if(pRadarInterface -> readQueryVersionString(radarIndex, tempRadarlastVersionString))
N            break;
N        lastretryCounter--;
N    }
N
N    if(lastretryCounter>0)
N    {
N        //terninalPrintf("\r");
N        terninalPrintf("Last Radar%d Version = %s\r\n",radarIndex+1,tempRadarlastVersionString);
N        sprintf(templastString,"Radar%d last Ver.:%s",radarIndex+1,tempRadarlastVersionString);
N    }
N    else
N    {
N        terninalPrintf("Last Radar%d Version = Error\r\n",radarIndex+1);
N        sprintf(templastString,"Radar%d last Ver.:Error",radarIndex+1);
N    }
N    
N        EPDDrawString(FALSE,templastString,50,100+(44*(radarIndex*2+8)));
X        EPDDrawString((0),templastString,50,100+(44*(radarIndex*2+8)));
N        EPDDrawString(TRUE,"                                 ",50,100+(44*(radarIndex*2+9)));
X        EPDDrawString((1),"                                 ",50,100+(44*(radarIndex*2+9)));
N    
N   // vTaskDelay(3000/portTICK_RATE_MS);
N    
N    
N    
N    
N    terninalPrintf("Open file \"%s\" \r\n",binString);
N    
N    
N    
N    
N    /*if(!UserDrvInit(FALSE))
N    {
N        terninalPrintf("UserDrvInit fail.\r\n");
N        EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
N        return FALSE;
N    }*/
N    
N    //terninalPrintf("-\r\n");
N    //setPrintfFlag(FALSE);
N    /*//if(firstInitFlag)
N    //{
N    //    firstInitFlag = FALSE;
N        if(!FatfsInit(TRUE))
N        {
N            terninalPrintf("FatfsInit fail.\r\n");
N            EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
N            return FALSE;
N        }
N    //} */
N    //terninalPrintf("--\r\n");
N    //if(f_open(&file, "0:DefaultTest_1.01.06.bin", FA_OPEN_EXISTING |FA_READ))
N    if(f_open(&file, binString, FA_OPEN_EXISTING |FA_READ))
X    if(f_open(&file, binString, 0x00 |0x01))
N    {
N        terninalPrintf("SD card file open fail.\r\n");
N        f_close(&file);
N        EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
X        EPDDrawString((1),"Fail.       ",700,100+(44*(radarIndex+2)));
N        return FALSE;
X        return (0);
N    }
N    
N    //terninalPrintf("---\r\n");
N    int count = file.fsize / SDbufferSize;
N    int remain = file.fsize % SDbufferSize;
N    int progress = count / 10 ;
N    
N    terninalPrintf("file.fsize = %d\r\n",file.fsize);
N    terninalPrintf("count = %d\r\n",count);
N    terninalPrintf("remain = %d\r\n",remain);
N    terninalPrintf("progress = %d\r\n",progress);
N    
N    terninalPrintf("\r\r\r");
N
N    
N    
N
N    
N    
N    
N    
N    
N    
N    
N    
N    
N
N    //pRadarInterface->setPowerStatusFunc(radarIndex,TRUE);
N
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    //terninalPrintf("-----\r\n");
N    if(pRadarInterface->FirstOTAFunc(radarIndex,file.fsize) == FALSE)
X    if(pRadarInterface->FirstOTAFunc(radarIndex,file.fsize) == (0))
N    {
N        terninalPrintf("Radar%d first OTA fail.\r\n",radarIndex+1);
N        EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
X        EPDDrawString((1),"Fail.       ",700,100+(44*(radarIndex+2)));
N        return FALSE;
X        return (0);
N    }   
N    
N    terninalPrintf("0%% complete...\r");
N    EPDDrawString(TRUE,"0 percent   ",700,100+(44*(radarIndex+2)));
X    EPDDrawString((1),"0 percent   ",700,100+(44*(radarIndex+2)));
N    char tempProgressString[13];
N    for(int i=1;i<=count;i++)
N    {
N        //terninalPrintf("i=%d\r",i);
N        //terninalPrintf(".");
N        if(i%progress == 0)
N        {
N            terninalPrintf("%d%% complete...\r",(i/progress)*10);
N            sprintf(tempProgressString,"%d percent ",(i/progress)*10);
N            EPDDrawString(TRUE,tempProgressString,700,100+(44*(radarIndex+2)));
X            EPDDrawString((1),tempProgressString,700,100+(44*(radarIndex+2)));
N        } 
N        
N        f_read(&file, SDbuffer, SDbufferSize, &br);
N       
N        if(pRadarInterface->OTAFunc(radarIndex,SDbuffer, i, SDbufferSize) == FALSE)
X        if(pRadarInterface->OTAFunc(radarIndex,SDbuffer, i, SDbufferSize) == (0))
N        {
N            f_close(&file);
N            terninalPrintf("Radar%d OTA fail@%d.\r\n",radarIndex+1,i);
N            EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
X            EPDDrawString((1),"Fail.       ",700,100+(44*(radarIndex+2)));
N            return FALSE;
X            return (0);
N        }
N       // W25Q64BVBurn(i*SDbufferSize,(uint8_t *) SDbuffer,sizeof(SDbuffer) );
N    }
N    
N    if(remain != 0)
N    {
N        f_read(&file, SDbuffer, remain, &br);
N        if(pRadarInterface->OTAFunc(radarIndex,SDbuffer, count + 1, remain) == FALSE)
X        if(pRadarInterface->OTAFunc(radarIndex,SDbuffer, count + 1, remain) == (0))
N        {
N            f_close(&file);
N            terninalPrintf("Radar%d OTA fail@%d.\r\n",radarIndex+1,count + 1);
N            EPDDrawString(TRUE,"Fail.       ",700,100+(44*(radarIndex+2)));
X            EPDDrawString((1),"Fail.       ",700,100+(44*(radarIndex+2)));
N            return FALSE;
X            return (0);
N        }
N            
N        //W25Q64BVBurn(count*SDbufferSize,(uint8_t *) SDbuffer,remain );
N    }
N    
N    
N    
N    
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    //pRadarInterface->setPowerStatusFunc(radarIndex,FALSE);
N    
N    f_close(&file);
N    
N    
N    
N    
N    
N    //vTaskDelay(5000/portTICK_RATE_MS);
N    terninalPrintf("Radar%d OTA success.\r\n",radarIndex+1);
N    EPDDrawString(TRUE,"Success.    ",700,100+(44*(radarIndex+2)));
X    EPDDrawString((1),"Success.    ",700,100+(44*(radarIndex+2)));
N    //pRadarInterface->setPowerStatusFunc(radarIndex,FALSE);
N    
N    vTaskDelay(7000/portTICK_RATE_MS);
X    vTaskDelay(7000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    pRadarInterface->setPowerStatusFunc(radarIndex,FALSE);
X    pRadarInterface->setPowerStatusFunc(radarIndex,(0));
N    
N    
N    /*pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
N
N    if(pRadarInterface == NULL)
N    {
N        terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N    }
N
N    if(pRadarInterface->initFunc() == FALSE)
N    {
N        terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N    }
N    
N    
N    pRadarInterface->setPowerStatusFunc(radarIndex,TRUE);
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    */
N    vTaskDelay(3000/portTICK_RATE_MS);
X    vTaskDelay(3000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    pRadarInterface->setPowerStatusFunc(radarIndex,TRUE);
X    pRadarInterface->setPowerStatusFunc(radarIndex,(1));
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //vTaskDelay(4000/portTICK_RATE_MS);
N
N    char tempnewString[50] ;
N    char tempRadarnewVersionString[50];
N    int newretryCounter = 3;
N    
N    while(newretryCounter>0)
N    {
N        if(pRadarInterface -> readQueryVersionString(radarIndex, tempRadarnewVersionString))
N            break;
N        newretryCounter--;
N    }
N
N    if(newretryCounter>0)
N    {
N        //terninalPrintf("\r");
N        terninalPrintf("New Radar%d Version = %s\r\n",radarIndex+1,tempRadarnewVersionString);
N        sprintf(tempnewString,"Radar%d  new Ver.:%s",radarIndex+1,tempRadarnewVersionString);
N    }
N    else
N    {
N        terninalPrintf("New Radar%d Version = Error\r\n",radarIndex+1);
N        sprintf(tempnewString,"Radar%d  new Ver.:Error",radarIndex+1);
N    }
N    
N    pRadarInterface->setPowerStatusFunc(radarIndex,FALSE);
X    pRadarInterface->setPowerStatusFunc(radarIndex,(0));
N    EPDDrawString(TRUE,tempnewString,50,100+(44*(radarIndex*2+9)));
X    EPDDrawString((1),tempnewString,50,100+(44*(radarIndex*2+9)));
N   /* if(radarIndex)      
N        EPDDrawString(TRUE,tempString,100,100+(44*(11)));
N    else
N        EPDDrawString(TRUE,tempString,100,100+(44*(10)));
N     */   
N    
N    //setPrintfFlag(TRUE);
N    
N    
N    //terninalPrintf("New Radar%d Version = %s\r\n",radarIndex+1,tempRadarnewVersionString);
N    
N    /*
N    char SucCoutString[50] ;
N    
N    sprintf(SucCoutString,"Success Count : %d   ",s+1);
N    
N    
N    EPDDrawString(TRUE,SucCoutString,50,100+(44*(6)));
N    
N    
N    }   */
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 1475 10 variable "tempchar" was declared but never referenced
W "src\user\hwtester.c" 1476 11 variable "numberString" was declared but never referenced
W "src\user\hwtester.c" 1477 11 variable "firststringflag" was declared but never referenced
W "src\user\hwtester.c" 1478 11 variable "changenumberflag" was declared but never referenced
W "src\user\hwtester.c" 1480 9 variable "binselect" was declared but never referenced
N}
N
Nstatic BOOL OpenCamPhoto(int index)
N{
N    
N    //FIL filephoto;
N    char * PhotoFileNameStr;
W "src\user\hwtester.c" 1831 9 function "UserDrvInit" declared implicitly
N    if(!UserDrvInit(FALSE))
X    if(!UserDrvInit((0)))
N    {
N        terninalPrintf("UserDrvInit fail.\r\n");
N        return FALSE;
X        return (0);
N    }
N    if(!FatfsInit(TRUE))
X    if(!FatfsInit((1)))
N    {
N        terninalPrintf("FatfsInit fail.\r\n");
N        return FALSE;
X        return (0);
N    }
N  
N    
N    //Time2RTC(GetCurrentUTCTime(), pptPHOTO);
N    //terninalPrintf("Year/Month/Day/Hour/Minute/Second  %04d/%02d/%02d/%02d/%02d/%02d \r\n",ppt->u32Year,ppt->u32cMonth,ppt->u32cDay,ppt->u32cHour,ppt->u32cMinute,ppt->u32cSecond);
N    
N    //sprintf(PhotoFileNameStr,"0:photo%d_%s.jpg",index+1,timeStr);
N    
N    
N    //sprintf(PhotoFileNameStr,"0:photo%d_%04d%02d%02d%02d%02d%02d.jpg",index+1,pptPHOTO->u32Year ,pptPHOTO->u32cMonth,pptPHOTO->u32cDay,pptPHOTO->u32cHour,pptPHOTO->u32cMinute,pptPHOTO->u32cSecond);
N    
N    //sprintf(PhotoFileNameStr,"0:photo%d_%02d%02d%02d%02d%02d.jpg",index+1,pptPHOTO->u32cMonth,pptPHOTO->u32cDay,pptPHOTO->u32cHour,pptPHOTO->u32cMinute,pptPHOTO->u32cSecond);
N    
N    sprintf(PhotoFileNameStr,"0:photo%d_%d.jpg",index+1,GetCurrentUTCTime());
N    
N    
N    //terninalPrintf("PhotoFileNameStr = %s\r\n",PhotoFileNameStr);
N    //sprintf(PhotoFileNameStr,"0:photo%d.jpg",index+1);
N                    
N    if(f_open(&filephoto,PhotoFileNameStr, FA_CREATE_ALWAYS | FA_WRITE))
X    if(f_open(&filephoto,PhotoFileNameStr, 0x08 | 0x02))
N    //if(f_open(&filephoto, PhotoFileNameStr, FA_OPEN_EXISTING |FA_READ))
N    {
N        terninalPrintf("SD card file open %s fail.\r\n",PhotoFileNameStr);
N        return FALSE;
X        return (0);
N    }
N    
N    
W "src\user\hwtester.c" 1867 1 missing return statement at end of non-void function "OpenCamPhoto"
N}
N
Nstatic void CloseCamPhoto(void)
N{
N    f_close(&filephoto);
N
N}
N
Nstatic BOOL SaveCamPhoto(int index,uint8_t* photoPr,int photoLen)
N{
N   // int  SDbufferSize = 256 ;
N   // uint8_t SDbuffer[SDbufferSize];
N    //FIL filephoto;
N    //char * PhotoFileNameStr;
N    //char  PhotoFileNameStr[50];
N    //UINT br;
N    
N    //RTC_TIME_DATA_T* ppt;
N    
N    int count ;
N    int remain ;
N    int progress ;
N
N    char * timeStr;
N    /*
N    if(!UserDrvInit(FALSE))
N    {
N        terninalPrintf("UserDrvInit fail.\r\n");
N        return FALSE;
N    }
N    if(!FatfsInit(TRUE))
N    {
N        terninalPrintf("FatfsInit fail.\r\n");
N        return FALSE;
N    }
N    */
N    
N    
N    
N    //UTCTimeToStringEx(GetCurrentUTCTime(), timeStr);
N    //Time2RTC(GetCurrentUTCTime(), ppt);
N    //terninalPrintf("timeStr = %s\r\n",timeStr);
N    //terninalPrintf("Year/Month/Day/Hour/Minute/Second  %04d/%02d/%02d/%02d/%02d/%02d \r\n",ppt->u32Year,ppt->u32cMonth,ppt->u32cDay,ppt->u32cHour,ppt->u32cMinute,ppt->u32cSecond);
N    
N    //sprintf(PhotoFileNameStr,"0:photo%d_%s.jpg",index+1,timeStr);
N    
N    /*
N    //sprintf(PhotoFileNameStr,"0:photo%d_%02d%02d%02d%02d%02d.jpg",index+1,ppt->u32cMonth,ppt->u32cDay,ppt->u32cHour,ppt->u32cMinute,ppt->u32cSecond);
N    sprintf(PhotoFileNameStr,"0:photo%d_%d.jpg",index+1,GetCurrentUTCTime());
N    //terninalPrintf("PhotoFileNameStr = %s\r\n",PhotoFileNameStr);
N    //sprintf(PhotoFileNameStr,"0:photo%d.jpg",index+1);
N                    
N    if(f_open(&filephoto,PhotoFileNameStr, FA_CREATE_ALWAYS | FA_WRITE))
N    //if(f_open(&filephoto, PhotoFileNameStr, FA_OPEN_EXISTING |FA_READ))
N    {
N        terninalPrintf("SD card file open %s fail.\r\n",PhotoFileNameStr);
N        return FALSE;
N    }
N    */
N    
N    f_write(&filephoto, tempPr, photoLen, &brPHOTO);
N    //f_close(&filephoto);
N    
N    
N    //count = photoLen / SDbufferSize;
N    //remain = photoLen % SDbufferSize;
N    //progress = count / 10 ;
N    /*
N    terninalPrintf("count = %d\r\n",count);
N    terninalPrintf("remain = %d\r\n",remain);
N    terninalPrintf("progress = %d\r\n",progress);
N    */
N    //uint8_t tempBuffer[] = {0x7A,0xA7,index};
N    /*
N    if(index == 1)
N        tempBuffer[2] = 0x02;
N    else
N        tempBuffer[2] = 0x01;
N    */
N    //f_write(&filephoto, tempBuffer, sizeof(tempBuffer), &br);
N
N    
N    //terninalPrintf("photoPrAddr = %08x \r\n",photoPr);
N    /*
N                    terninalPrintf("nphotoPr = ");
N                for(int j=0;j<10;j++)
N                    terninalPrintf("%02x ",*(photoPr+j));
N        
N                terninalPrintf("\r\n");
N    */
N    
N    /*
N    for(int i=0;i<count;i++)
N    {
N        if(i%progress == 0)
N        {
N            terninalPrintf("%d%% complete...\r",(i/progress)*10);
N        }
N        
N        //W25Q64BVqueryEx(i*SDbufferSize,SDbuffer,sizeof(SDbuffer));
N        //memcpy(SDbuffer,*(&photoPr+i*SDbufferSize) , SDbufferSize);
N        
N        //memcpy(SDbuffer,photoPr+i*SDbufferSize , SDbufferSize);
N        for(int j=0;j<SDbufferSize;j++)
N            SDbuffer[j] = *(photoPr+i*SDbufferSize+j);
N        f_write(&filephoto, SDbuffer, SDbufferSize, &br);
N        
N    }
N    
N    if(remain != 0)
N    {   
N        
N        //W25Q64BVqueryEx(count*SDbufferSize,SDbuffer,remain);
N        //memcpy(SDbuffer,*(&photoPr+count*SDbufferSize) , remain);
N        
N        
N        //memcpy(SDbuffer,photoPr+count*SDbufferSize , remain);
N        
N        for(int k=0;k<remain;k++)
N            SDbuffer[k] = *(photoPr+count*SDbufferSize+k);
N        
N        f_write(&filephoto, SDbuffer, remain, &br);
N        
N    }
N        
N    */
N
N
N    return TRUE;
X    return (1);
N    
W "src\user\hwtester.c" 1886 9 variable "count" was declared but never referenced
W "src\user\hwtester.c" 1887 9 variable "remain" was declared but never referenced
W "src\user\hwtester.c" 1888 9 variable "progress" was declared but never referenced
W "src\user\hwtester.c" 1890 12 variable "timeStr" was declared but never referenced
N}
N
N
N//====================================================/=/=======================================================//
N
Nstatic BOOL versionQuery(void* para1, void* para2)
N{
N	  //uint8_t *VerCode1,*VerCode2,*VerCode3,*YearCode,*MonthCode,*DayCode,*HourCode,*MinuteCode;
N	
N        uint8_t VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode;
N		char* string = malloc(29);
N		//char* string2 = malloc(17);
N		//terninalPrintf("%d",string);
N		//char string[28];
N
N		QueryVersion(&VerCode1,&VerCode2,&VerCode3,&YearCode,&MonthCode,&DayCode,&HourCode,&MinuteCode);
N		/*terninalPrintf("VerCode1=%d\r\n",VerCode1);
N		terninalPrintf("VerCode2=%d\r\n",VerCode2);
N		terninalPrintf("VerCode3=%d\r\n",VerCode3);
N		terninalPrintf("YearCode=%d\r\n",YearCode);
N		terninalPrintf("MonthCode=%d\r\n",MonthCode);
N		terninalPrintf("DayCode=%d\r\n",DayCode);
N		terninalPrintf("HourCode=%d\r\n",HourCode);
N		terninalPrintf("MinuteCode=%d\r\n",MinuteCode);*/
N	
N		*string      = 'V';
N		*(string+1)  = 'e';
N	    *(string+2)  = 'r';
N	    *(string+3)  = ' ';
N	    *(string+4)  = 48+VerCode1;
N		*(string+5)  = '.';
N	    *(string+6)  = 48+(VerCode2/10);
N		*(string+7)  = 48+(VerCode2%10);
N		*(string+8)  = '.';
N	    *(string+9)  = 48+(VerCode3/10);
N	    *(string+10) = 48+(VerCode3%10);		
N		*(string+11) = '\n';
N		*(string+12) = 'b';
N		*(string+13) = 'u';
N		*(string+14) = 'i';
N		*(string+15) = 'l';
N		*(string+16) = 'd';
N		*(string+17) = ' ';
N		*(string+18) = 48+(YearCode/10);
N		*(string+19) = 48+(YearCode%10);
N		*(string+20) = 48+(MonthCode/10);
N		*(string+21) = 48+(MonthCode%10);
N		*(string+22) = 48+(DayCode/10);
N		*(string+23) = 48+(DayCode%10);
N		*(string+24) = 48+(HourCode/10);
N		*(string+25) = 48+(HourCode%10);
N		*(string+26) = 48+(MinuteCode/10);
N		*(string+27) = 48+(MinuteCode%10);
N		*(string+28) = '\0';		
N	
N		//EPDDrawString(TRUE,"Version Query",X_POS_MSG,Y_POS_MSG+50);
N		//terninalPrintf("%s\r\n",string1);
N		terninalPrintf("%s\r\n",string);
N		terninalPrintf("Is the version number correct?(y/n)\r\n");
N		guiPrintMessage(string);
N		//EPDDrawString(TRUE,string1,X_POS_MSG,Y_POS_MSG+50);
N		//EPDDrawString(TRUE,string2,X_POS_MSG,Y_POS_MSG+100);
N		
N		
N		//vTaskDelay(2000/portTICK_RATE_MS);
N		//EPDDrawContainByIDPos(TRUE,EPD_PICT_KEY_CLEAN_BAR,X_POS_MSG-2,Y_POS_MSG-2); 
N		
N		free(string);
N		//free(string2);
N		
N		if(userResponseLoop()=='n')
N          {
N			guiPrintMessage("");
N            EPDSetBacklight(FALSE);
X            EPDSetBacklight((0));
N            return TEST_FALSE;
X            return 0x10;
N          }
N		return TEST_SUCCESSFUL_LIGHT_OFF;
X		return 0x12;
N}
N
N
N
N
N
N
N//////////////////////buzzer test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL buzzerTest(void* para1, void* para2)
N{
N    char tempchar;
N    terninalPrintf("!!! buzzerTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N    {
N        guiPrintResult("Buzzer Testing");
N        guiPrintMessage("Speaker play \n2 Time");
N        //EPDDrawString(TRUE,"Buzzer Will  \nBeep 2 Time",X_POS_MSG,Y_POS_MSG);
N    }
N    terninalPrintf("Speaker play 2 Time\n");
N    //vTaskDelay(1300/portTICK_RATE_MS);
N    BuzzerPlay(400,400, 2, TRUE);
X    BuzzerPlay(400,400, 2, (1));
N    if(MBtestFlag )
N    {
N        SetMTPCRC(7,(uint8_t*)MTPString);
N        MTPCmdprint(7,(uint8_t*)MTPString); 
N    }
N    else
N    {
N        cleanMsg();
N        guiPrintMessage("\n+:Have Sound\n=:No Sound");
N    }
N    terninalPrintf("Do you Heard Buzzer playing two time?(y/n)\n");
N
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar=='y')
N        {
N            //terninalPrintf(" Buzzer Test..... [OK]\r\n");
N            MTPString[6][3] = 0x81;
N            return TEST_SUCCESSFUL_LIGHT_OFF;
X            return 0x12;
N        }
N        else if(tempchar=='n')
N        {
N            if(MBtestFlag )
N            {
N                MTPString[6][3] = 0x80;
N            }
N            else
N            {
N                //EPDDrawString(TRUE,"FAIL             ",X_POS_RST,Y_POS_RST);
N                //terninalPrintf(" Buzzer Test..... [ERROR]\r\n");
N                cleanMsg();
N            }
N            
N            if(MBtestFlag )
N                return FALSE;
X                return (0);
N            else
N                return TEST_FALSE;
X                return 0x10;
N        }
N    }
N}
N
N//////////////////////KeyPad test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
N
Nstatic BOOL keyPadAllTest(void* para1, void* para2)
N{
N    if(MBtestFlag )
N    {
N        /////guiManagerShowScreen(GUI_BLANK_ID, GUI_REDRAW_PARA_REFRESH,0, 0);
N        //guiManagerShowScreen(GUI_SINGLE_TEST_ID, GUI_REDRAW_PARA_REFRESH,(int)MB_singleTestItem, 0);
N        SetMTPCRC(18,(uint8_t*)MTPString);
N        MTPCmdprint(18,(uint8_t*)MTPString);
N        
N        NT066ESetPower(TRUE);
X        NT066ESetPower((1));
N    }
N    terninalPrintf("!!! keypadTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Keypad Testing");
N    terninalPrintf("Start Test Keypad...\r\n");
N#if(SUPPORT_HK_10_HW)
X#if(1)
N    BOOL lastKey[] = {GUI_KEYPAD_LEFT_ID,GUI_KEYPAD_RIGHT_ID,GUI_KEYPAD_ADD_ID,GUI_KEYPAD_MINUS_ID,GUI_KEYPAD_CARD_ID,GUI_KEYPAD_QRCODE_ID};
X    BOOL lastKey[] = {0x03,0x02,0x04,0x01,0x05,0x00};
N    if(MBtestFlag )
N    {
N        lastKey[0] = 0x05; //0x00;
N        lastKey[1] = 0x04; //0x01;
N        lastKey[2] = 0x03; //0x02;
N        lastKey[3] = 0x02; //0x03;
N        lastKey[4] = 0x01; //0x04;
N        lastKey[5] = 0x00; //0x05;
N    }
N#else
S    BOOL lastKey[] = {GUI_KEYPAD_LEFT_ID,GUI_KEYPAD_RIGHT_ID,GUI_KEYPAD_ADD_ID,GUI_KEYPAD_MINUS_ID,GUI_KEYPAD_CONFIRM_ID}; 
N#endif
N    BOOL lastStage[] = {TOUCH_UP, TOUCH_DOWN};
X    BOOL lastStage[] = {1, 2};
N    BOOL keyStage = 0;
N    BOOL tempkeyStage = 0;
N    BOOL statusStage = 0;
N
N    callBackKeyId = 0;
N    callBackDownUp = 0;
N    
N    int counter1s = 0;
N    int counterms = 0;
N    int MTPcounterms = 0;
N    
N    KeyDrvSetMode(KEY_DRV_MODE_NORMAL_INDEX);
X    KeyDrvSetMode(0x01);
N    KeyDrvSetCallbackFunc(CallBackReturnValue);
N
N    if(MBtestFlag )
N    {
N        targetkeyStage = lastKey[keyStage];
N        //terninalPrintf("Click Key 1\n");
N        //SetMTPCRC(18,(uint8_t*)MTPString);
N        //NT066ESetPower(FALSE);
N        //MTPCmdprintEx(18,(uint8_t*)MTPString);
N        //NT066ESetPower(TRUE);
N        terninalPrintf("Click Key 6\n");
N        while(1)
N        {
N            if(callBackDownUp != 0)
N            {
N                sysprintf("keyId = 0x%x,downUp = 0x%x\r\n ", callBackKeyId, callBackDownUp);
N                if((callBackDownUp == lastStage[statusStage]) && (callBackKeyId == lastKey[keyStage]))
N                {
N                    if(statusStage == 1)
N                    {	
N                        keyStage++;
N                        
N                        statusStage = 0;
N                        switch(keyStage){
N                        case 1:
N                            //terninalPrintf("Click Key 2\n");
N                            MTPString[12][8] = 0x81;
N                            //SetMTPCRC(17,(uint8_t*)MTPString);
N                            //NT066ESetPower(FALSE);
N                            //MTPCmdprint(17,(uint8_t*)MTPString);
N                            //NT066ESetPower(TRUE);
N                            terninalPrintf("Click Key 5\n");
N                            counter1s = 0;
N                            counterms = 0;
N                            break;
N                        case 2:
N                            MTPString[12][7] = 0x81;
N                            //terninalPrintf("Click Key 3\n");
N                            //SetMTPCRC(16,(uint8_t*)MTPString);
N                            //NT066ESetPower(FALSE);
N                            //MTPCmdprint(16,(uint8_t*)MTPString);
N                            //NT066ESetPower(TRUE);
N                            terninalPrintf("Click Key 4\n");
N                            counter1s = 0;
N                            counterms = 0;
N                            break;
N                        case 3:
N                            MTPString[12][6] = 0x81;
N                            //terninalPrintf("Click Key 4\n");
N                            //SetMTPCRC(15,(uint8_t*)MTPString);
N                            //NT066ESetPower(FALSE);
N                            //MTPCmdprint(15,(uint8_t*)MTPString);
N                            //NT066ESetPower(TRUE);
N                            terninalPrintf("Click Key 3\n");
N                            counter1s = 0;
N                            counterms = 0;
N                            break;
N                    #if(SUPPORT_HK_10_HW)
X                    #if(1)
N                        case 4:
N                            MTPString[12][5] = 0x81;
N                            //terninalPrintf("Click Key 5\n");
N                            //SetMTPCRC(14,(uint8_t*)MTPString);
N                            //NT066ESetPower(FALSE);
N                            //MTPCmdprint(14,(uint8_t*)MTPString);
N                            //NT066ESetPower(TRUE);
N                            terninalPrintf("Click Key 2\n");
N                            counter1s = 0;
N                            counterms = 0;
N                            break;
N                        case 5:
N                            MTPString[12][4] = 0x81;
N                            //terninalPrintf("Click Key 6\n");
N                            //SetMTPCRC(13,(uint8_t*)MTPString);
N                            //NT066ESetPower(FALSE);
N                            //MTPCmdprint(13,(uint8_t*)MTPString);
N                            //NT066ESetPower(TRUE);
N                            terninalPrintf("Click Key 1\n");
N                            counter1s = 0;
N                            counterms = 0;
N                            break;
N                    #else
S                        case 4:
S                            guiPrintMessage("Click { Key");
S                            terninalPrintf("Click Key 5\n");
S                            break;
N                    #endif
N                        }
N                    }
N                    else
N                    {	
N                        //BuzzerPlay(200, 0, 1, FALSE);
N                        statusStage++;
N                    }
N                    
N                }
N                else
N                {
N                    testErroCode = TOUCH_SEQUENCE_ERRO;
X                    testErroCode = 0x0610;
N    //                NT066ESetPower(FALSE);
N                    setPrintfFlag(TRUE);
X                    setPrintfFlag((1));
N                    //terninalPrintf("KeyPad Test [ERROR]\n");
N                    //guiManagerResetKeyCallbackFunc();
N
N                    if(MBtestFlag )
N                         KeyDrvSetCallbackFunc(NULL);
X                         KeyDrvSetCallbackFunc(0);
N                     //   NT066ESetPower(FALSE);
N                    if(MBtestFlag )
N                        return FALSE;
X                        return (0);
N                    //return TEST_FALSE;
N                }
N                
N            #if(SUPPORT_HK_10_HW)
X            #if(1)
N                if(keyStage == 6)
N            #else
S                if(keyStage == 5)
N            #endif
N                {
N                    break;
N                }
N                callBackDownUp = 0;
N            }
N            targetkeyStage = lastKey[keyStage];
N            vTaskDelay(10/portTICK_RATE_MS);
X            vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            
N            counterms++;
N            MTPcounterms++;
N            
N            if(MTPcounterms >= 40)
N            {
N                MTPcounterms = 0;
N                if(tempkeyStage < keyStage)
N                {
N                    tempkeyStage++;
N                    switch(keyStage)
N                        {
N                            case 1:
N                                SetMTPCRC(17,(uint8_t*)MTPString);
N                                MTPCmdprintEx(17,(uint8_t*)MTPString);
N                                break;
N                            case 2:
N                                SetMTPCRC(16,(uint8_t*)MTPString);
N                                MTPCmdprintEx(16,(uint8_t*)MTPString);
N                                break;
N                            case 3:
N                                SetMTPCRC(15,(uint8_t*)MTPString);
N                                MTPCmdprintEx(15,(uint8_t*)MTPString);
N                                break;
N                            case 4:
N                                SetMTPCRC(14,(uint8_t*)MTPString);
N                                MTPCmdprintEx(14,(uint8_t*)MTPString);
N                                break;
N                            case 5:
N                                SetMTPCRC(13,(uint8_t*)MTPString);
N                                MTPCmdprintEx(13,(uint8_t*)MTPString);
N                                break;    
N                        }
N                }
N
N            }
N            
N            if(counterms >= 100)
N            {
N                counterms = 0;
N                terninalPrintf("%d \r",15-counter1s);
N                counter1s++;
N                if(counter1s >= 15)
N                {
N                    testErroCode = TOUCH_SEQUENCE_ERRO;
X                    testErroCode = 0x0610;
N                    setPrintfFlag(TRUE);
X                    setPrintfFlag((1));
N                    MTPString[12][8 - keyStage] = 0x80;
N                    MTPString[12][9] = 0x80;
N                    if(MBtestFlag )
N                         KeyDrvSetCallbackFunc(NULL);
X                         KeyDrvSetCallbackFunc(0);
N                    if(MBtestFlag )
N                        return FALSE;
X                        return (0);
N                }
N            }
N            
N            
N        }
N        //terninalPrintf("KeyPad Test..... [OK]\n");
N        //guiManagerResetKeyCallbackFunc();
N        
N        
N        if(MBtestFlag )
N        {
N             KeyDrvSetCallbackFunc(NULL);
X             KeyDrvSetCallbackFunc(0);
N            //NT066ESetPower(FALSE);
N        }
N        MTPString[12][3] = 0x81;
N        MTPString[12][9] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N 
N    }
N    else
N    {
N        targetkeyStage = lastKey[keyStage];
N        // KeyDrvInit();
N        //TODO FIND BUG cannot run 2nd time
N        guiPrintMessage("Click < Key");
N        terninalPrintf("Click Key 1\n");
N        while(1)
N        {
N            if(callBackDownUp != 0)
N            {
N                sysprintf("keyId = 0x%x,downUp = 0x%x\r\n ", callBackKeyId, callBackDownUp);
N                if((callBackDownUp == lastStage[statusStage]) && (callBackKeyId == lastKey[keyStage]))
N                {
N                    if(statusStage == 1)
N                    {	
N                        keyStage++;
N                        statusStage = 0;
N                        
N                        counter1s = 0;
N                        counterms = 0;
N                        switch(keyStage){
N                        case 1:
N                            guiPrintMessage("Click > Key");
N                            terninalPrintf("Click Key 2\n");
N                            break;
N                        case 2:
N                            guiPrintMessage("Click + Key");
N                            terninalPrintf("Click Key 3\n");
N                            break;
N                        case 3:
N                            guiPrintMessage("Click = Key");
N                            terninalPrintf("Click Key 4\n");
N                            break;
N                    #if(SUPPORT_HK_10_HW)
X                    #if(1)
N                        case 4:
N                            guiPrintMessage("Click { Key");
N                            terninalPrintf("Click Key 5\n");
N                            break;
N                        case 5:
N                            guiPrintMessage("Click } Key");
N                            terninalPrintf("Click Key 6\n");
N                            break;
N                    #else
S                        case 4:
S                            guiPrintMessage("Click { Key");
S                            terninalPrintf("Click Key 5\n");
S                            break;
N                    #endif
N                        }
N                    }
N                    else
N                    {	
N                        //BuzzerPlay(200, 0, 1, FALSE);
N                        statusStage++;
N                    }
N                    
N                }
N                else
N                {
N                    testErroCode = TOUCH_SEQUENCE_ERRO;
X                    testErroCode = 0x0610;
N    //                NT066ESetPower(FALSE);
N                    setPrintfFlag(TRUE);
X                    setPrintfFlag((1));
N                    //terninalPrintf("KeyPad Test [ERROR]\n");
N                    guiManagerResetKeyCallbackFunc();
N
N                    if(MBtestFlag )
N                        NT066ESetPower(FALSE);
X                        NT066ESetPower((0));
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N                
N            #if(SUPPORT_HK_10_HW)
X            #if(1)
N                if(keyStage == 6)
N            #else
S                if(keyStage == 5)
N            #endif
N                {
N                    break;
N                }
N                callBackDownUp = 0;
N            }
N            targetkeyStage = lastKey[keyStage];
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            
N            counterms++;
N            
N            if(counterms >= 10)
N            {
N                counterms = 0;
N                terninalPrintf("%d \r",15-counter1s);
N                counter1s++;
N                if(counter1s >= 15)
N                {
N                    testErroCode = TOUCH_SEQUENCE_ERRO;
X                    testErroCode = 0x0610;
N                    setPrintfFlag(TRUE);
X                    setPrintfFlag((1));
N                    guiManagerResetKeyCallbackFunc();
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N            }
N            
N            
N        }
N        //terninalPrintf("KeyPad Test..... [OK]\n");
N        guiManagerResetKeyCallbackFunc();
N        
N        
N        if(MBtestFlag )
N        {
N            NT066ESetPower(FALSE);
X            NT066ESetPower((0));
N        }
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N}
N
N//////////////////////LED    test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL LEDTest(void* para1, void* para2)
N{
N    char tempchar;
N    BOOL LEDresultFlag1 = FALSE;        //  LED flash result
X    BOOL LEDresultFlag1 = (0);        
N    BOOL LEDresultFlag2 = FALSE;        //  LED reset result
X    BOOL LEDresultFlag2 = (0);        
N    BOOL LEDresultFlag3 = FALSE;        //  LED version result
X    BOOL LEDresultFlag3 = (0);        
N    terninalPrintf("!!! ledTest !!!\r\n");
N    if(MBtestFlag )
N    {
N        //SetMTPCRC(40,(uint8_t*)MTPString);
N        //MTPCmdprint(40,(uint8_t*)MTPString);
N    }
N    else
N        guiPrintResult("LED Testing");
N    EPDSetBacklight(FALSE);
X    EPDSetBacklight((0));
N    vTaskDelay(1500/portTICK_RATE_MS);
X    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(LedDrvInit(TRUE) == TRUE)
X    if(LedDrvInit((1)) == (1))
N    {
N        //MemsCalibrationSet();
N        //1.White LED Test
N        //terninalPrintf("5 White LED will lightup\n");
N        //guiPrintMessage("Background Light\nwill ON");
N        //vTaskDelay(2000/portTICK_RATE_MS);
N        //EPDSetBacklight(TRUE);
N        
N        //guiPrintMessage("Background Light\nwill ON\n\n+:Yes =:No");
N        //terninalPrintf("Does 5 Background White LED lightup?(y/n)\n");
N       /* if(userResponseLoop()=='n')
N        {
N            EPDSetBacklight(FALSE);
N            //terninalPrintf(" LED Test [ERROR]\r\n");
N            return TEST_FALSE;
N        }
N        EPDSetBacklight(FALSE); */
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintResult("LED Testing");
N        //2.Red Green LED test
N        //terninalPrintf("Front 7 LED and Back 3 LED will lightup one by one.\r\n");
N        //guiPrintMessage("Front 7 LED\nBack  3 LED\nTurn ON\nOne By One");
N        terninalPrintf("Front 8 LED and Back 3 LED will lightup one by one.\r\n");
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("Front 8 LED\nBack  3 LED\nTurn ON\nOne By One");
N        vTaskDelay(1500/portTICK_RATE_MS);
X        vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDSetBacklight(TRUE);
X        EPDSetBacklight((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        GPIO_SetBit(GPIOG, BIT7);
X        GPIO_SetBit(GPIOG, (0x00000080));
N        EPDSetBacklight(FALSE);
X        EPDSetBacklight((0));
N        LedSendFactoryTest();
N        //vTaskDelay(1500/portTICK_RATE_MS);
N
N        vTaskDelay(5000/portTICK_RATE_MS);
X        vTaskDelay(5000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //guiPrintMessage("Front 7 LED\nBack  3 LED\nTurn ON\nOne By One\n\n+:Yes =:No");
N        if(MBtestFlag )
N        {
N            SetMTPCRC(9,(uint8_t*)MTPString);
N            MTPCmdprint(9,(uint8_t*)MTPString);
N        }
N        else
N            guiPrintMessage("Front 8 LED\nBack  3 LED\nTurn ON\nOne By One\n\n+:Yes =:No");
N        terninalPrintf("Does all LED lightup?(y/n)\n");
N        GPIO_ClrBit(GPIOG, BIT7);
X        GPIO_ClrBit(GPIOG, (0x00000080));
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                //cleanMsg();
N                //EPDDrawString(TRUE,"PASS              ",X_POS_RST,Y_POS_RST);
N                //terninalPrintf(" LED Test [OK]\r\n");
N                //////////////////////MEMS   test/////////////////////////
N                //return MemsTest(para1,para2);
N                EPDSetBacklight(FALSE);
X                EPDSetBacklight((0));
N                LEDresultFlag1 = TRUE;
X                LEDresultFlag1 = (1);
N                MTPString[8][3] = 0x81;
N                break;
N                //return TEST_SUCCESSFUL_LIGHT_OFF;
N            }
N            else if(tempchar =='n')
N            {
N                EPDSetBacklight(FALSE);
X                EPDSetBacklight((0));
N                LEDresultFlag1 = FALSE;
X                LEDresultFlag1 = (0);
N                MTPString[8][3] = 0x80;
N                if(MBtestFlag )
N                    return FALSE;
X                    return (0);
N                break;
N                //return TEST_FALSE;
N            }
N        }
N         
N    }
N    else
N    {    //LED hardware initial fail
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("INIT ERROR");
N        terninalPrintf("LED Initial [ERROR]\r\n");
N        testErroCode = LED_CONNECT_ERRO;
X        testErroCode = 0x0201;
N        LEDresultFlag1 = FALSE;
X        LEDresultFlag1 = (0);
N        EPDSetBacklight(FALSE);
X        EPDSetBacklight((0));
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N    }
N    
N    
N    //terninalPrintf(" LED Test [ERROR]\r\n");  
N    //EPDSetBacklight(FALSE);
N    //return TEST_FALSE;
N    
N    //--------------LED reset----------------------------------
N    uint8_t VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode;
N    char LEDVerStr[50];
N    //char* string = malloc(29);
N    GPIO_ClrBit(GPIOF, BIT9);
X    GPIO_ClrBit(GPIOF, (0x00000200));
N    terninalPrintf("Test LED reset pin.\r\n");
N    if(MBtestFlag )
N    {
N        SetMTPCRC(55,(uint8_t*)MTPString);
N        MTPCmdprint(55,(uint8_t*)MTPString);
N    }
N    else
N    {
N        guiPrintResult("Test LED reset");
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        guiPrintMessage("");
N    }
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(QueryVersion(&VerCode1,&VerCode2,&VerCode3,&YearCode,&MonthCode,&DayCode,&HourCode,&MinuteCode))
N    {
N 
N        // sprintf(LEDVerStr,"Ver %d.%d.%d Build %02d%02d%02d%02d%02d",VerCode1,VerCode2,VerCode3,
N         //        YearCode,MonthCode,DayCode,HourCode,MinuteCode);
N        //terninalPrintf("LED Ver: %s\r\n",LEDVerStr); 
N        terninalPrintf("LED reset error.\r\n");
N        LEDresultFlag2 = FALSE;
X        LEDresultFlag2 = (0);
N        MTPString[8][4] = 0x80;
N        GPIO_SetBit(GPIOF, BIT9);
X        GPIO_SetBit(GPIOF, (0x00000200));
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            guiPrintMessage("reset error.");
N    }
N    else
N    {
N        //terninalPrintf("LED Ver: Error\r\n");
N        terninalPrintf("LED reset success.\r\n");
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("reset success.");
N        LEDresultFlag2 = TRUE;
X        LEDresultFlag2 = (1);
N        MTPString[8][4] = 0x81;
N        GPIO_SetBit(GPIOF, BIT9);
X        GPIO_SetBit(GPIOF, (0x00000200));
N        
N
N    }
N    
N    //--------------LED reset----------------------------------
N    
N    
N    
N    //--------------LED version----------------------------------
N    
N    
N    terninalPrintf("Test LED version.\r\n");
N    if(MBtestFlag )
N    {
N        SetMTPCRC(56,(uint8_t*)MTPString);
N        MTPCmdprint(56,(uint8_t*)MTPString);
N    }
N    else
N    {
N        guiPrintResult("Test LED version.");
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        guiPrintMessage("");
N    }
N    vTaskDelay(1000/portTICK_RATE_MS);
X    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    LedDrvInit(SPECIAL);
X    LedDrvInit((2));
N    vTaskDelay(3000/portTICK_RATE_MS);
X    vTaskDelay(3000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(QueryVersion(&VerCode1,&VerCode2,&VerCode3,&YearCode,&MonthCode,&DayCode,&HourCode,&MinuteCode))
N    {
N 
N        sprintf(LEDVerStr,"Ver %d.%d.%d Build %02d%02d%02d%02d%02d",VerCode1,VerCode2,VerCode3,
N                 YearCode,MonthCode,DayCode,HourCode,MinuteCode);
N        terninalPrintf("LED Ver: %s\r\n",LEDVerStr); 
N        if(MBtestFlag )
N        {}
N        else
N        {
N            char ShowLEDVerStr[50];
N            sprintf(ShowLEDVerStr,"LED Ver: \nVer %d.%d.%d\nBuild %02d%02d%02d%02d%02d",
N                    VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode);
N            guiPrintMessage(ShowLEDVerStr);
N        }
N
N        LEDresultFlag3 = TRUE;
X        LEDresultFlag3 = (1);
N        MTPString[8][5] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("LED Ver: Error\r\n");
N        //terninalPrintf("LED version success.\r\n");
N        MTPString[8][5] = 0x80;        
N        LEDresultFlag3 = FALSE;
X        LEDresultFlag3 = (0);
N        
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            guiPrintMessage("LED Ver: Error");
N
N    }
N    
N    //--------------LED version----------------------------------
N    
N    
N    if(LEDresultFlag1 && LEDresultFlag2 && LEDresultFlag3)
N    {
N        MTPString[8][6] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N    else
N    {
N        MTPString[8][6] = 0x80;
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N}
N
Nstatic BOOL LEDTestLite(void* para1, void* para2)
N{
N    char tempchar;
N    BOOL LEDresultFlag1 = FALSE;        //  LED flash result
X    BOOL LEDresultFlag1 = (0);        
N    BOOL LEDresultFlag2 = FALSE;        //  LED reset result
X    BOOL LEDresultFlag2 = (0);        
N    BOOL LEDresultFlag3 = FALSE;        //  LED version result
X    BOOL LEDresultFlag3 = (0);        
N    terninalPrintf("!!! ledTest !!!\r\n");
N
N    guiPrintResult("LED Testing");
N    
N    
N    //--------------LED reset----------------------------------
N    uint8_t VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode;
N    char LEDVerStr[50];
N    //char* string = malloc(29);
N    GPIO_ClrBit(GPIOF, BIT9);
X    GPIO_ClrBit(GPIOF, (0x00000200));
N    terninalPrintf("Test LED reset pin.\r\n");
N    if(MBtestFlag )
N    {
N        SetMTPCRC(55,(uint8_t*)MTPString);
N        MTPCmdprint(55,(uint8_t*)MTPString);
N    }
N    else
N    {
N        guiPrintResult("Test LED reset");
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        guiPrintMessage("");
N    }
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(QueryVersion(&VerCode1,&VerCode2,&VerCode3,&YearCode,&MonthCode,&DayCode,&HourCode,&MinuteCode))
N    {
N 
N
N        terninalPrintf("LED reset error.\r\n");
N        LEDresultFlag2 = FALSE;
X        LEDresultFlag2 = (0);
N        MTPString[8][4] = 0x80;
N        GPIO_SetBit(GPIOF, BIT9);
X        GPIO_SetBit(GPIOF, (0x00000200));
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            guiPrintMessage("reset error.");
N    }
N    else
N    {
N        //terninalPrintf("LED Ver: Error\r\n");
N        terninalPrintf("LED reset success.\r\n");
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("reset success.");
N        LEDresultFlag2 = TRUE;
X        LEDresultFlag2 = (1);
N        MTPString[8][4] = 0x81;
N        GPIO_SetBit(GPIOF, BIT9);
X        GPIO_SetBit(GPIOF, (0x00000200));
N        
N
N    }
N    
N    //--------------LED reset----------------------------------
N    
N    
N    
N    
N    EPDSetBacklight(FALSE);
X    EPDSetBacklight((0));
N    //vTaskDelay(1500/portTICK_RATE_MS);
N    vTaskDelay(1000/portTICK_RATE_MS);
X    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    LedDrvInit(SPECIAL);
X    LedDrvInit((2));
N    vTaskDelay(500/portTICK_RATE_MS);
X    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    if(LedDrvInit(TRUE) == TRUE)
X    if(LedDrvInit((1)) == (1))
N    {
N
N
N        guiPrintResult("LED Testing");
N        terninalPrintf("Front 8 LED and Back 3 LED will lightup one by one.\r\n");
N        guiPrintMessage("Front 8 LED\nBack  3 LED\nTurn ON\nOne By One");
N        vTaskDelay(1500/portTICK_RATE_MS);
X        vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDSetBacklight(TRUE);
X        EPDSetBacklight((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        GPIO_SetBit(GPIOG, BIT7);
X        GPIO_SetBit(GPIOG, (0x00000080));
N        EPDSetBacklight(FALSE);
X        EPDSetBacklight((0));
N        LedSendFactoryTest();
N
N        vTaskDelay(5000/portTICK_RATE_MS);
X        vTaskDelay(5000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        guiPrintMessage("Front 8 LED\nBack  3 LED\nTurn ON\nOne By One\n\n+:Yes =:No");
N        terninalPrintf("Does all LED lightup?(y/n)\n");
N        GPIO_ClrBit(GPIOG, BIT7);
X        GPIO_ClrBit(GPIOG, (0x00000080));
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                EPDSetBacklight(FALSE);
X                EPDSetBacklight((0));
N                LEDresultFlag1 = TRUE;
X                LEDresultFlag1 = (1);
N                MTPString[8][3] = 0x81;
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                EPDSetBacklight(FALSE);
X                EPDSetBacklight((0));
N                LEDresultFlag1 = FALSE;
X                LEDresultFlag1 = (0);
N                MTPString[8][3] = 0x80;
N                if(MBtestFlag )
N                    return FALSE;
X                    return (0);
N                break;
N            }
N        }
N         
N    }
N    else
N    {   
N        guiPrintMessage("INIT ERROR");
N        terninalPrintf("LED Initial [ERROR]\r\n");
N        testErroCode = LED_CONNECT_ERRO;
X        testErroCode = 0x0201;
N        LEDresultFlag1 = FALSE;
X        LEDresultFlag1 = (0);
N        EPDSetBacklight(FALSE);
X        EPDSetBacklight((0));
N
N    }
N    
N    
N    
N    if(LEDresultFlag1 && LEDresultFlag2)
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    else
N        return TEST_FALSE;
X        return 0x10;
N    
W "src\user\hwtester.c" 2733 10 variable "LEDresultFlag3" was declared but never referenced
W "src\user\hwtester.c" 2741 10 variable "LEDVerStr" was declared but never referenced
N}
N
N//////////////////////MEMS   test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL MemsTest(void* para1, void* para2)
N{
N    //guiPrintMessage("Upright EPM");
N    //terninalPrintf("\n1.stand upright EPM\n");
N    uint8_t ret;
N    int timeout = 10;
N    //x y z axis test
N    
N
N
N  
N
N    /*
N    for(int i=0;i<timeout;i++)
N    {
N        if(i == (timeout-1))
N        {
N            return TEST_FALSE;
N        }
N        if(LedSendHeartbeat(&ret) == TRUE)
N        {
N            char str[40];
N            terninalPrintf("result [%08b (%d)] collision(%b) x(%b) y(%b) z(%b)  %d  \r\n",ret,ret,ret&0x1,(ret>>3)&0x1,(ret>>2)&0x1,(ret>>1)&0x1,timeout - i);
N            sprintf(str,"\nx %d y %d z %d",(ret>>3)&0x1,(ret>>2)&0x1,(ret>>1)&0x1);
N            guiPrintMessageNoClean(str);
N            if(((ret>>1)&0x3)==0)
N                break;
N            else
N                vTaskDelay(3000/portTICK_RATE_MS);
N        }
N    }
N    guiPrintMessage("LayDown EPM");
N    terninalPrintf("\n2.lay down EPM\n");
N    timeout = 10;
N    //x y z axis test
N    for(int i=0;i<timeout;i++)
N    {
N        if(i == (timeout-1))
N        {
N            return TEST_FALSE;
N        }
N        if(LedSendHeartbeat(&ret) == TRUE)
N        {
N            char str[40];
N            terninalPrintf("result [%08b (%d)] collision(%b) x(%b) y(%b) z(%b)  %d  \r\n",ret,ret,ret&0x1,(ret>>3)&0x1,(ret>>2)&0x1,(ret>>1)&0x1,timeout - i);
N            sprintf(str,"\nx %d y %d z %d",(ret>>3)&0x1,(ret>>2)&0x1,(ret>>1)&0x1);
N            guiPrintMessageNoClean(str);
N            if(!((ret>>3)&0x1)&&((ret>>2)&0x1)&&((ret>>1)&0x1))
N                break;
N            else
N                vTaskDelay(3000/portTICK_RATE_MS);
N        }
N    }
N    timeout = 10;
N    */
N    //collision test
N
N    int count=0;
N    /*
N    do{
N        MemsCollisionClean();
N        //vTaskDelay(500/portTICK_RATE_MS);
N        //LedSendHeartbeat(&ret);
N        //vTaskDelay(1500/portTICK_RATE_MS);
N        //LedSendHeartbeat(&ret);
N        count++;
N        terninalPrintf("MemsCollisionClean count=%d ret=%08b\r\n",count,ret);
N        //vTaskDelay(3000/portTICK_RATE_MS);
N        //vTaskDelay(500/portTICK_RATE_MS);
N    }while(ret&0x1);    
N    */
N    
N    
N    MemsCollisionClean();
N    vTaskDelay(1500/portTICK_RATE_MS);
X    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    /*
N    GPIO_ClrBit(GPIOF, BIT9);
N    vTaskDelay(100/portTICK_RATE_MS);
N    GPIO_SetBit(GPIOF, BIT9);
N    vTaskDelay(1000/portTICK_RATE_MS);
N    LedDrvInit(SPECIAL);
N    vTaskDelay(500/portTICK_RATE_MS);
N    */
N    
N    
N    guiPrintMessage("Collision EPM");
N    terninalPrintf("\nCollision EPM\n");
N    //terninalPrintf("\n3.Collision EPM\n");
N 
N
N    /*
N    //LedSetPower(0);
N    //GPIO_SetBit(GPIOF, BIT8);
N    GPIO_ClrBit(GPIOF, BIT9);
N    vTaskDelay(500/portTICK_RATE_MS);
N    //GPIO_ClrBit(GPIOF, BIT8);
N    GPIO_SetBit(GPIOF, BIT9);
N    //LedSetPower(1);  */
N    for(int i=0;i<timeout;i++)
N    {
N        if(i == (timeout-1))
N        {
N            return TEST_FALSE;
X            return 0x10;
N        }
N        //if(LedSendHeartbeat(&ret) == TRUE)
N        if(LedReadShake(&ret) == TRUE)
X        if(LedReadShake(&ret) == (1))
N        {
N            char str[40];
N            //terninalPrintf("ret = %02x\r\n",ret);
N            terninalPrintf("result [%08b (%d)] collision(%b) x(%b) y(%b) z(%b)  %d  \r\n",ret,ret,ret&0x1,(ret>>3)&0x1,(ret>>2)&0x1,(ret>>1)&0x1,timeout - i);
N            sprintf(str,"\nCollision %d",ret&0x1);
N            guiPrintMessageNoClean(str);
N            if((ret&0x1)>0)
N                return TEST_SUCCESSFUL_LIGHT_OFF;
X                return 0x12;
N            else
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        }
N    }
N    return TEST_FALSE;
X    return 0x10;
W "src\user\hwtester.c" 2913 9 variable "count" was declared but never referenced
N}
N
N/////////////////////Red Switch test//////////////////////////////TEST_SUCCESSFUL_LIGHT_ON;
Nstatic BOOL redSwitchAllTest(void* para1, void* para2)
N{
N    terninalPrintf("!!! switch Test !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        //guiPrintResult("Blue Switch \nTesting");
N        guiPrintResult("SW4 Switch \nTesting");
N        //guiPrintResult("Red Switch \nTesting");
N    UINT8 lastStatus[] = {IOPIN_BOTH_OFF, IOPIN_ONLY1_ON, IOPIN_BOTH_OFF, IOPIN_ONLY2_ON, IOPIN_BOTH_OFF}; 
X    UINT8 lastStatus[] = {3, 2, 3, 1, 3}; 
N    UINT8 statusStage = 0;
N    UINT32 portValue = GPIO_ReadPort(GPIOH);
N    UINT8 pinStage = (portValue>>2)&0x3;
N    if(!DipDrvInit(TRUE))
X    if(!DipDrvInit((1)))
N    {
N        terninalPrintf(" DIP Driver Init [ERROR]\r\n");
N        setPrintfFlag(TRUE);
X        setPrintfFlag((1));
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    //terninalPrintf("Please Switch SW1 and SW2  to off position\r\n");
N    terninalPrintf("ok\nPlease Switch SW1 and SW2  to on position\r\n");
N    if(MBtestFlag )
N    {        
N        SetMTPCRC(20,(uint8_t*)MTPString);
N        MTPCmdprint(20,(uint8_t*)MTPString);
N    }
N    else
N        guiPrintMessage("Switch 1\\2\nON");
N    int timeOut = 15; //10;
N    //int mscounter = 0;
N    while((timeOut--)>0)
N    {
N        terninalPrintf("\r%d ",timeOut);
N        /*
N        vTaskDelay(1000/portTICK_RATE_MS);
N        portValue = GPIO_ReadPort(GPIOH);
N        pinStage = (portValue>>2)&0x3;
N        */
N        portValue = GPIO_ReadPort(GPIOH);
N        pinStage = (portValue>>2)&0x3;
N        for(int i=0;i<10;i++)
N        {
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N            if(pinStage != ((GPIO_ReadPort(GPIOH)>>2)&0x3))                            
N                BuzzerPlay(200, 500, 1, TRUE);
X                BuzzerPlay(200, 500, 1, (1));
N            portValue = GPIO_ReadPort(GPIOH);
N            pinStage = (portValue>>2)&0x3;
N        }
N        //if(pinStage == IOPIN_BOTH_OFF)
N        if(pinStage == IOPIN_BOTH_ON)
X        if(pinStage == 0)
N        {
N            MTPString[19][3] = 0x81;
N            //terninalPrintf("ok\nPlease Switch SW1 and SW2  to on position\r\n");
N            terninalPrintf("Please Switch SW1 and SW2  to off position\r\n");
N            if(MBtestFlag )
N            {
N                SetMTPCRC(21,(uint8_t*)MTPString);
N                MTPCmdprint(21,(uint8_t*)MTPString);
N            }
N            else
N                guiPrintMessage("Switch 1\\2\nOFF");
N            timeOut = 15; //10;
N            while((timeOut)-->0)
N            {
N                terninalPrintf("\r%d",timeOut);
N                /*
N                vTaskDelay(1000/portTICK_RATE_MS);
N                portValue = GPIO_ReadPort(GPIOH);
N                pinStage = (portValue>>2)&0x3;
N                */
N                portValue = GPIO_ReadPort(GPIOH);
N                pinStage = (portValue>>2)&0x3;
N                for(int i=0;i<10;i++)
N                {
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N                    if(pinStage != ((GPIO_ReadPort(GPIOH)>>2)&0x3))                            
N                        BuzzerPlay(200, 500, 1, TRUE);
X                        BuzzerPlay(200, 500, 1, (1));
N                    portValue = GPIO_ReadPort(GPIOH);
N                    pinStage = (portValue>>2)&0x3;
N                }
N                
N                //if(pinStage == IOPIN_BOTH_ON)
N                if(pinStage == IOPIN_BOTH_OFF)
X                if(pinStage == 3)
N                {
N                    //terninalPrintf("\nRedSwitch Test [OK]\r\n");
N                    MTPString[19][4] = 0x81;
N                    return electricitySingleTest(para1,para2);
N                }
N            }
N            
N            if(MBtestFlag )
N            {
N                MTPString[19][4] = 0x80;
N            }
N            else
N                //guiPrintMessage("BlueSwitch FAIL");
N            guiPrintMessage("SW4 test FAIL");
N                //guiPrintMessage("RedSwitch FAIL");
N            
N            if(MBtestFlag )
N                return FALSE;
X                return (0);
N            else
N                return TEST_FALSE;
X                return 0x10;
N            
N            
N        }
N    }
N    //terninalPrintf("RedSwitch Test [ERROR]\r\n");
N    if(MBtestFlag )
N    {
N        MTPString[19][3] = 0x80;
N    }
N    else
N        //guiPrintMessage("BlueSwitch FAIL");
N        guiPrintMessage("SW4 test FAIL");
N        //guiPrintMessage("RedSwitch FAIL");
N    
N    if(MBtestFlag )
N        return FALSE;
X        return (0);
N    else
N        return TEST_FALSE;
X        return 0x10;
N    
W "src\user\hwtester.c" 2987 11 variable "lastStatus" was declared but never referenced
W "src\user\hwtester.c" 2988 11 variable "statusStage" was declared but never referenced
N}
Nstatic BOOL redSwitchAllTest_old(void* para1, void* para2)
N{
N    terninalPrintf("!!! switch Test !!!\r\n");
N    guiPrintResult("Red Switch \nTesting");
N    UINT8 lastStatus[] = {IOPIN_BOTH_OFF, IOPIN_ONLY1_ON, IOPIN_BOTH_OFF, IOPIN_ONLY2_ON, IOPIN_BOTH_OFF}; 
X    UINT8 lastStatus[] = {3, 2, 3, 1, 3}; 
N    UINT8 statusStage = 0;
N    UINT32 portValue = GPIO_ReadPort(GPIOH);
N    UINT8 pinStage = (portValue>>2)&0x3;
N    if(!DipDrvInit(TRUE))
X    if(!DipDrvInit((1)))
N    {
N        terninalPrintf(" DIP Driver Init [ERROR]\r\n");
N        setPrintfFlag(TRUE);
X        setPrintfFlag((1));
N        return TEST_FALSE;
X        return 0x10;
N    }
N    terninalPrintf("Please Switch SW1 and SW2  to off position\r\n");
N    guiPrintMessage("Switch SW1\\SW2\nOff");
N    while(1)
N    {
N        portValue = GPIO_ReadPort(GPIOH);
N        pinStage = (portValue>>2)&0x3;
N        if(pinStage == IOPIN_BOTH_OFF)
X        if(pinStage == 3)
N        {
N            break;
N        }
N    }
N    portValue = GPIO_ReadPort(GPIOH);
N    pinStage = (portValue>>2)&0x3;
N    //step1 both off
N    if((pinStage) != lastStatus[statusStage])
N    {
N        return TEST_FALSE;
X        return 0x10;
N    }
N    else
N    {
N        statusStage++;
N        guiPrintMessage("Switch SW1 ON");
N        terninalPrintf("Switch 1 on\r\n");
N        while(1)
N        {
N            portValue = GPIO_ReadPort(GPIOH);
N            pinStage = (portValue>>2)&0x3;
N            if((pinStage != lastStatus[statusStage-1]) && (pinStage != lastStatus[statusStage]))
N            {
N                if(pinStage == IOPIN_BOTH_ON)
X                if(pinStage == 0)
N                {
N                    testErroCode = RED_SWITCH_BOTH_ON_ERRO;
X                    testErroCode = 0x0310;
N                }
N                else
N                {
N                    testErroCode = RED_SWITCH_SEQUENCE_ERRO;
X                    testErroCode = 0x0320;
N                }
N                guiPrintResult("Operating ERRO");
N                //terninalPrintf("RedSwitch Test [ERROR]\r\n");
N                return TEST_FALSE;
X                return 0x10;
N            }
N            else
N            {
N                if(pinStage == lastStatus[statusStage])
N                {
N                    switch(pinStage)
N                    {
N                    case IOPIN_BOTH_ON:
X                    case 0:
N                        break;
N                    case IOPIN_ONLY1_ON:
X                    case 2:
N                        guiPrintMessage("Switch SW1 OFF");
N                        terninalPrintf("Switch 1 off\r\n");
N                        break;
N                    case IOPIN_ONLY2_ON:
X                    case 1:
N                        guiPrintMessage("Switch SW2 OFF");
N                        terninalPrintf("Switch 2 off !!!\r\n");
N                        break;
N                    case IOPIN_BOTH_OFF:
X                    case 3:
N                        if(statusStage==2)
N                        {
N                            guiPrintMessage("Switch SW2 ON");
N                            terninalPrintf("Switch 2 on \r\n");
N                        }
N                        break;
N                    default:
N                        terninalPrintf("Switch = 0x%02x !!!\r\n", (portValue>>2)&0x3);
N                        break;
N                    }
N                    statusStage++;
N                }
N            }
N            if(statusStage == 5)
N            {
N                //terninalPrintf("RedSwitch Test [OK]\r\n");
N                return electricitySingleTest(para1,para2);
N            }
N        }
N    }
N    //terninalPrintf("RedSwitch Test [ERROR]\r\n");
W "src\user\hwtester.c" 3199 5 statement is unreachable
N    return FALSE;
X    return (0);
N}
N
N//////////////////////Power Button Test///////////////////TEST_SUCCESSFUL_LIGHT_ON
Nstatic BOOL electricitySingleTest(void* para1, void* para2)
N{
N    //terninalPrintf("!!! Button Switch Test !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Button Switch");
N    if(DipDrvInit(TRUE))
X    if(DipDrvInit((1)))
N    {
N        terninalPrintf("Press Power Button\r\n");
N        if(MBtestFlag )
N        {
N            SetMTPCRC(22,(uint8_t*)MTPString);
N            MTPCmdprint(22,(uint8_t*)MTPString);
N        }
N        else
N        {
N            cleanMsg();
N            guiPrintMessage("Press Button");
N        }
N        int timeOut = 15; //10;
N        while((timeOut--)>0)
N        {
N            //vTaskDelay(1000/portTICK_RATE_MS);
N            terninalPrintf("\r%d",timeOut);
N        #if(SUPPORT_HK_10_HW)
X        #if(1)
N            UINT32 powerBitValue = GPIO_ReadBit(GPIOI, 0x08);
N        #else
S            UINT32 powerBitValue = GPIO_ReadBit(GPIOH, 0x10);
N        #endif
N            
N            for(int i=0;i<10;i++)
N            {
N                vTaskDelay(100/portTICK_RATE_MS);
X                vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N                if(powerBitValue != GPIO_ReadBit(GPIOI, 0x08) )                            
N                    BuzzerPlay(200, 500, 1, TRUE);
X                    BuzzerPlay(200, 500, 1, (1));
N                powerBitValue = GPIO_ReadBit(GPIOI, 0x08);
N            }
N            
N            if(!powerBitValue)
N            {
N                MTPString[19][5] = 0x81;
N                terninalPrintf("\nPower on !!!\r\n");
N                if(MBtestFlag )
N                {}
N                else
N                {
N                    LEDColorBuffSet(0x3F, 0x00);
N                    LEDBoardLightSet();
N                }
N                terninalPrintf("Release Power Button\r\n");
N                if(MBtestFlag )
N                {
N                    SetMTPCRC(23,(uint8_t*)MTPString);
N                    MTPCmdprint(23,(uint8_t*)MTPString);
N                }
N                else
N                    guiPrintMessage("Release Button");
N                timeOut = 15; //10;
N                while((timeOut--)>0)
N                {
N                    terninalPrintf("\r%d",timeOut);
N                    //vTaskDelay(1000/portTICK_RATE_MS);
N                #if(SUPPORT_HK_10_HW)
X                #if(1)
N                    powerBitValue = GPIO_ReadBit(GPIOI, 0x08);
N                #else
S                    powerBitValue = GPIO_ReadBit(GPIOH, 0x10);
N                #endif
N                    
N                for(int i=0;i<10;i++)
N                {
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N                    if(powerBitValue != GPIO_ReadBit(GPIOI, 0x08) )                            
N                        BuzzerPlay(200, 500, 1, TRUE);
X                        BuzzerPlay(200, 500, 1, (1));
N                    powerBitValue = GPIO_ReadBit(GPIOI, 0x08);
N                }
N                    
N                    
N                    if(powerBitValue)
N                    {
N                        MTPString[19][6] = 0x81;
N                        terninalPrintf("\nPower off !!!\r\n");
N                        if(MBtestFlag )
N                        {}
N                        else
N                        {
N                            LEDColorBuffSet(0x00, 0x00);
N                            LEDBoardLightSet();
N                        }
N                        //terninalPrintf("Power Button Test [OK]\r\n");
N                        if(MBtestFlag )
N                        {
N                            return SW6SingleTest(para1, para2);
N                        }
N                        else
N                        {
N                            return TEST_SUCCESSFUL_LIGHT_ON;
X                            return 0x13;
N                        }
N                    }                   
N                }
N                if(MBtestFlag )
N                {
N                    MTPString[19][6] = 0x80;
N                }
N                else
N                    guiPrintMessage("Power Button\nFAIL");
N                if(MBtestFlag )
N                    return FALSE;
X                    return (0);
N                else
N                    return TEST_FALSE;
X                    return 0x10;
N                
W "src\user\hwtester.c" 3316 17 statement is unreachable
N                break;
N            }
N        }
N        vTaskDelay(300/portTICK_RATE_MS);
X        vTaskDelay(300/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    }
N    else
N    {
N        //terninalPrintf(" DIP Driver Init [ERROR]\r\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    //terninalPrintf("Power Button Test [ERROR]\r\n");
N    if(MBtestFlag )
N    {
N        MTPString[19][5] = 0x80;
N    }
N    else
N        guiPrintMessage("Power Button\nFAIL");
N    if(MBtestFlag )
N        return FALSE;
X        return (0);
N    else
N        return TEST_FALSE;
X        return 0x10;
N}
N
Nstatic BOOL SW6SingleTest(void* para1, void* para2)
N{
N    uint8_t timeOut1 = 0;
N    uint8_t timeOut2 = 0;
N    uint8_t maxtime = 15;
N    uint32_t tempPort;
N    //UINT32 portValue = (GPIO_ReadPort(GPIOJ) & 0x1F);
N    SetMTPCRC(24,(uint8_t*)MTPString);
N    MTPCmdprint(24,(uint8_t*)MTPString);
N    terninalPrintf("Please Switch SW6 No.1~5 to on position\r\n");
N    while(1)
N    {
N        if((GPIO_ReadPort(GPIOJ) & 0x1F) == 0)
N            break;
N        terninalPrintf("\r%d ",maxtime-timeOut1);
N        timeOut1++;
N        if(timeOut1 >= maxtime)
N        {
N            if(MBtestFlag )
N            {            
N                MTPString[19][7] = 0x80;
N                return FALSE;
X                return (0);
N            }
N            else
N                return TEST_FALSE;
X                return 0x10;
N        }
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        tempPort = GPIO_ReadPort(GPIOJ) & 0x1F ;
N        for(int i=0;i<10;i++)
N        {
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N            if(tempPort != (GPIO_ReadPort(GPIOJ) & 0x1F) )                            
N                BuzzerPlay(200, 500, 1, TRUE);
X                BuzzerPlay(200, 500, 1, (1));
N            tempPort = GPIO_ReadPort(GPIOJ) & 0x1F ;
N        }
N        
N    }
N    MTPString[19][7] = 0x81;
N    SetMTPCRC(25,(uint8_t*)MTPString);
N    MTPCmdprint(25,(uint8_t*)MTPString);
N    terninalPrintf("Please Switch SW6 No.1~5 to off position\r\n");
N    while(1)
N    {
N        if((GPIO_ReadPort(GPIOJ) & 0x1F) == 0x1F)
N            break;
N        terninalPrintf("\r%d ",maxtime-timeOut2);
N        timeOut2++;
N        if(timeOut2 >= maxtime)
N        {
N            if(MBtestFlag )
N            {
N                MTPString[19][8] = 0x80;
N                return FALSE;
X                return (0);
N            }
N            else
N                return TEST_FALSE;
X                return 0x10;
N        }
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        
N        tempPort = GPIO_ReadPort(GPIOJ) & 0x1F ;
N        for(int i=0;i<10;i++)
N        {
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N            if(tempPort != (GPIO_ReadPort(GPIOJ) & 0x1F) )                            
N                BuzzerPlay(200, 500, 1, TRUE);
X                BuzzerPlay(200, 500, 1, (1));
N            tempPort = GPIO_ReadPort(GPIOJ) & 0x1F ;
N        }
N        
N    }
N    MTPString[19][8] = 0x81;
N    MTPString[19][9] = 0x81;
N    return TEST_SUCCESSFUL_LIGHT_ON;
X    return 0x13;
N}
N
N
Nstatic BOOL EPDSingleTest(void* para1, void* para2)
N{    
N    char  preadFWVersion[16];
N    char  CmpStr[16];
N    BOOL EPDtestFlag = TRUE;
X    BOOL EPDtestFlag = (1);
N    memset(preadFWVersion,0x00,sizeof(preadFWVersion));
N    memset(CmpStr,0x00,sizeof(CmpStr));
N    
N    terninalPrintf("Please wait about 10 seconds.\r\n");
N
N    ReadIT8951SystemInfo( preadFWVersion, NULL);
X    ReadIT8951SystemInfo( preadFWVersion, 0);
N    
N    //EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE); 
N    //EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);
N    /*
N    EPDtestFlag = TRUE;
N    
N    terninalPrintf("Please wait about 10 seconds.\r\n");
N    if(readEPDswitch() == FALSE)
N    {
N        vTaskDelay(500/portTICK_RATE_MS);
N        toggleEPDswitch(TRUE);
N        //if(!ReadIT8951SystemInfo( preadFWVersion, NULL))
N        //    EPDtestFlag = FALSE;
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        //EPDDrawString(TRUE,"ENABLE  ",90+325,100+(44*(8)));
N        //terninalPrintf("ENABLE EPD.\r\n");
N
N        vTaskDelay(1000/portTICK_RATE_MS);
N    }
N    GPIO_ClrBit(GPIOI, BIT0); 
N    vTaskDelay(100/portTICK_RATE_MS);
N    GPIO_SetBit(GPIOI, BIT0);
N    //vTaskDelay(5000/portTICK_RATE_MS);
N    if(!ReadIT8951SystemInfo( preadFWVersion, NULL))
N        EPDtestFlag = FALSE;
N    
N    //GPIO_ClrBit(GPIOI, BIT0);
N    if(EPDtestFlag)
N    {
N        //EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE); 
N        //EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);
N    }
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    if(readEPDswitch() == TRUE)
N    {
N        //if(EPDtestFlag)
N        //    EPDDrawString(TRUE,"DISABLE",90+325,100+(44*(8)));
N
N        toggleEPDswitch(FALSE);
N    }
N    if(EPDtestFlag)
N    {
N        //EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE); 
N        //EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);
N    }
N    vTaskDelay(500/portTICK_RATE_MS);
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    
N    */
N
N    
N    if(memcmp(preadFWVersion,CmpStr,sizeof(CmpStr)) == 0)
N    {
N        MTPString[32][3] = 0x80;
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    else
N    {
N        terninalPrintf("readFWVersion=%s\r\n",preadFWVersion);
N        MTPString[32][3] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N
N    
N/*
N    if(EPDIT8951Test())
N        return TEST_SUCCESSFUL_LIGHT_OFF;
N    else
N        return TEST_FALSE;
N    */
W "src\user\hwtester.c" 3423 10 variable "EPDtestFlag" was declared but never referenced
N}
N
Nstatic BOOL CADPowerTest(void* para1, void* para2)
N{
N    
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<16)) | (0x0<<16);
N    GPIO_OpenBit(GPIOB, BIT4, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000010), DIR_OUTPUT, NO_PULL_UP);
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<12)) | (0x0<<12));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<12)) | (0x0<<12);
N    GPIO_OpenBit(GPIOB, BIT3, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000008), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOA, BIT14, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOA, (0x00004000), DIR_OUTPUT, PULL_UP);
N
N    //GPIO_SetBit(GPIOG, BIT6);
N    //GPIO_SetBit(GPIOB, BIT3);
N    GPIO_ClrBit(GPIOB, BIT3);
X    GPIO_ClrBit(GPIOB, (0x00000008));
N    GPIO_SetBit(GPIOB, BIT4);
X    GPIO_SetBit(GPIOB, (0x00000010));
N    GPIO_SetBit(GPIOA, BIT14);
X    GPIO_SetBit(GPIOA, (0x00004000));
N    
N    char tempchar;
N    SetMTPCRC(11,(uint8_t*)MTPString);
N    MTPCmdprint(11,(uint8_t*)MTPString);
N    terninalPrintf("IS CAD power 12V?(y/n)\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            terninalPrintf("CAD power OK.\r\n");
N            
N            //close CAD power
N            GPIO_SetBit(GPIOB, BIT3);
X            GPIO_SetBit(GPIOB, (0x00000008));
N            GPIO_ClrBit(GPIOB, BIT4);
X            GPIO_ClrBit(GPIOB, (0x00000010));
N            GPIO_ClrBit(GPIOA, BIT14);
X            GPIO_ClrBit(GPIOA, (0x00004000));
N            MTPString[10][3] = 0x81;
N            return TEST_SUCCESSFUL_LIGHT_ON;
X            return 0x13;
N        }                
N        else if(tempchar =='n')
N        {
N            terninalPrintf("CAD power ERROR.\r\n");
N            
N            //close CAD power
N            GPIO_SetBit(GPIOB, BIT3);
X            GPIO_SetBit(GPIOB, (0x00000008));
N            GPIO_ClrBit(GPIOB, BIT4);
X            GPIO_ClrBit(GPIOB, (0x00000010));
N            GPIO_ClrBit(GPIOA, BIT14);
X            GPIO_ClrBit(GPIOA, (0x00004000));
N            MTPString[10][3] = 0x80;
N            if(MBtestFlag )
N                return FALSE;
X                return (0);
N            else
N                return TEST_FALSE;
X                return 0x10;
N        }                
N    }
N    
N    
N    
N}
N
Nstatic BOOL CADSingleTest(void* para1, void* para2)
N{
N    BOOL resultFlag1 = FALSE;   //test CAD 12v power flag
X    BOOL resultFlag1 = (0);   
N    BOOL resultFlag2 = FALSE;   //test CAD Rx & Tx interconnect flag
X    BOOL resultFlag2 = (0);   
N    BOOL resultFlag3 = FALSE;   //test RTS & CTS interconnect flag
X    BOOL resultFlag3 = (0);   
N    BOOL resultFlag4 = FALSE;   //test CAD TEN & Solar I/O connect flag
X    BOOL resultFlag4 = (0);   
N    char SendCADStr[] = "Hello CAD";
N    char SendDebugStr[] = "Cmd OK";
N    char CADReadBuf[15];
N    char DebugReadBuf[10];
N    int ReadBufLen;
N    // open CAD power
N    UartInterface* CADUartInterface;
N    CADUartInterface = UartGetInterface(UART_10_INTERFACE_INDEX);
X    CADUartInterface = UartGetInterface(6);
N    
N    CommunicationInterface* CreditCardInterface;
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<16)) | (0x0<<16);
N    GPIO_OpenBit(GPIOB, BIT4, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000010), DIR_OUTPUT, NO_PULL_UP);
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<12)) | (0x0<<12));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<12)) | (0x0<<12);
N    GPIO_OpenBit(GPIOB, BIT3, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000008), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOA, BIT14, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOA, (0x00004000), DIR_OUTPUT, PULL_UP);
N
N    //GPIO_SetBit(GPIOG, BIT6);
N    GPIO_SetBit(GPIOB, BIT3);
X    GPIO_SetBit(GPIOB, (0x00000008));
N    GPIO_SetBit(GPIOB, BIT4);
X    GPIO_SetBit(GPIOB, (0x00000010));
N    GPIO_SetBit(GPIOA, BIT14);
X    GPIO_SetBit(GPIOA, (0x00004000));
N    
N    // Initial debug UART and flush buffer      
N    UartInterface* pUartInterface;
N    pUartInterface = UartGetInterface(UART_1_INTERFACE_INDEX);
X    pUartInterface = UartGetInterface(0);
N    if(pUartInterface == NULL)
X    if(pUartInterface == 0)
N    {   
N        terninalPrintf("Debug UART GetInterface ERROR.\r\n");
N    }        
N    
N    if(pUartInterface->initFunc(115200) == FALSE)
X    if(pUartInterface->initFunc(115200) == (0))
N    {
N        terninalPrintf("Debug UART GetInterface ERROR.\r\n");
N    }
N    uartIoctl(1, 25, 0, 0);  //UART1FlushBuffer , UARTA=1 , UART_IOC_FLUSH_RX_BUFFER=25 
N    //pUartInterface->setPowerFunc(FALSE);
N    //pUartInterface->setRS232PowerFunc(FALSE); 
N    
N    
N    //vTaskDelay(3000/portTICK_RATE_MS);
N    
N    
N    // Initial CAD and flush buffer
N    CreditCardInterface = CommunicationGetInterface(0);
N    CreditCardInterface->initFunc();
N    
N    CADUartInterface->setPowerFunc(TRUE);
X    CADUartInterface->setPowerFunc((1));
N    uartIoctl(10, 25, 0, 0);  //UART10FlushBuffer , UARTA=10 , UART_IOC_FLUSH_RX_BUFFER=25 
N    //CreditCardInterface->readFunc((PUINT8)CADReadBuf, sizeof(CADReadBuf));
N    //while(1);
N    /*
N    char tempchar;
N    
N    terninalPrintf("IS CAD power 12V?(y/n)\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            terninalPrintf("CAD power OK.\r\n");
N            resultFlag1 = TRUE;
N            break;
N        }                
N        else if(tempchar =='n')
N        {
N            terninalPrintf("CAD power ERROR.\r\n");
N            resultFlag1 = FALSE;
N            break;
N        }                
N    }
N    */
N    
N    
N    
N    
N    
N    int index = 0;
N    int counter = 0;
N    INT32 reVal;
N    int offsetindex = 0;
N
N    // Debug send message to CAD
N    pUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
X    pUartInterface->ioctlFunc(16, 0, 0);
N    pUartInterface->writeFunc((PUINT8)SendCADStr,sizeof(SendCADStr));
N    //vTaskDelay(10/portTICK_RATE_MS);
N    memset(CADReadBuf, 0x0, sizeof(CADReadBuf));
N    while(counter < 30)
N    {
N
N        reVal = CreditCardInterface->readFunc((PUINT8)CADReadBuf + index, sizeof(CADReadBuf)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
X        vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            
N            
N            /*
N            terninalPrintf("CADReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",CADReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((CADReadBuf[k] >= 0x20) && (CADReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",CADReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            */
N            
N            while((CADReadBuf[offsetindex] != SendCADStr[0] ) && (offsetindex < (sizeof(CADReadBuf)-sizeof(SendCADStr))))
N            {
N                offsetindex++;
N            }
N            
N            if(offsetindex>0)
N            {
N                memcpy(CADReadBuf,(char*)CADReadBuf+offsetindex,sizeof(SendCADStr));
N                offsetindex = 0;
N            }
N            
N            
N            /*
N            terninalPrintf("offsetindex = %d",offsetindex);
N            terninalPrintf("CADReceive(mod)<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",CADReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((CADReadBuf[k] >= 0x20) && (CADReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",CADReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            */
N        }
N   
N        counter++;
N    }
N    
N    if( memcmp(CADReadBuf,SendCADStr,sizeof(SendCADStr)) == 0 )
N    {
N        terninalPrintf("U14 Rx & U15 Tx connect success.\r\n");
N        MTPString[26][3] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("U14 Rx & U15 Tx connect error.\r\n");
N        MTPString[26][3] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N
N    //vTaskDelay(1000/portTICK_RATE_MS);
N        
N            // CAD send message to Debug
N    CADUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);    
X    CADUartInterface->ioctlFunc(16, 0, 0);    
N    //terninalPrintf("1. DebudCTSValue=%32b\n",inpw(REG_UART0_MSR+UART1*UARTOFFSET));
N    CreditCardInterface->writeFunc((PUINT8)SendDebugStr,sizeof(SendDebugStr));
N    //terninalPrintf("2. DebudCTSValue=%32b\n",inpw(REG_UART0_MSR+UART1*UARTOFFSET));
N    index = 0;
N    counter = 0;
N
N    memset(DebugReadBuf, 0x0, sizeof(DebugReadBuf));
N    while(counter < 30)
N    {
N
N        reVal = pUartInterface->readFunc((PUINT8)DebugReadBuf + index, sizeof(DebugReadBuf)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
X        vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            /*
N            terninalPrintf("DebugReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",DebugReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((DebugReadBuf[k] >= 0x20) && (DebugReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",DebugReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            */
N        }
N   
N        counter++;
N    }
N    
N       // terninalPrintf("3. DebudCTSValue=%32b\n",inpw(REG_UART0_MSR+UART1*UARTOFFSET));
N    
N    
N    if( memcmp(DebugReadBuf,SendDebugStr,sizeof(SendDebugStr)) == 0 )
N    {
N        terninalPrintf("U14 Tx & U15 Rx connect success.\r\n");
N        MTPString[26][4] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("U14 Tx & U15 Rx connect error.\r\n");
N        MTPString[26][4] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    /*
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    vTaskDelay(100/portTICK_RATE_MS);
N    uint32_t CADCTSValue,DebudCTSValue;
N
N    
N    // Debug send RTS signal to CAD
N    //pUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
N    pUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
N    vTaskDelay(100/portTICK_RATE_MS);
N    CADCTSValue =  inpw(REG_UART0_MSR+UARTA*UARTOFFSET) ;
N    //terninalPrintf("CADCTSValue=%32b\n",CADCTSValue);
N    */
N    
N    
N    BOOL DebugUR1RTSLowCADUR10CTSInFlag  = FALSE;
X    BOOL DebugUR1RTSLowCADUR10CTSInFlag  = (0);
N    BOOL DebugUR1RTSHighCADUR10CTSInFlag = FALSE;
X    BOOL DebugUR1RTSHighCADUR10CTSInFlag = (0);
N
N    
N    //Set DebugUR1RTS(PE4) and CADUR10CTS(PB15) GPIO
N
N    GPIO_CloseBit(GPIOB, BIT15);
X    GPIO_CloseBit(GPIOB, (0x00008000));
N    GPIO_CloseBit(GPIOE, BIT4);
X    GPIO_CloseBit(GPIOE, (0x00000010));
N    
N    //Set CADUR10CTS(PB15) input
W "src\user\hwtester.c" 3794 5 integer operation result is out of range
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 28)) | (0<< 28));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<< 28)) | (0<< 28);
N    GPIO_OpenBit(GPIOB, BIT15, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00008000), DIR_INPUT, PULL_UP);
N
N    //Set DebugUR1RTS(PE4) output
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<< 16)) | (0<< 16));
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<< 16)) | (0<< 16);
N    GPIO_OpenBit(GPIOE, BIT4, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000010), DIR_OUTPUT, PULL_UP);
N
N    
N    //Set DebugUR1RTS(PE4) LOW
N    GPIO_ClrBit(GPIOE, BIT4);
X    GPIO_ClrBit(GPIOE, (0x00000010));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT15))
X    if(!GPIO_ReadBit(GPIOB, (0x00008000)))
N        DebugUR1RTSLowCADUR10CTSInFlag  = TRUE;
X        DebugUR1RTSLowCADUR10CTSInFlag  = (1);
N        //terninalPrintf("CADUR10CTS receieve DebugUR1RTSLow success\r\n");
N    else
N        DebugUR1RTSLowCADUR10CTSInFlag  = FALSE;
X        DebugUR1RTSLowCADUR10CTSInFlag  = (0);
N        //terninalPrintf("CADUR10CTS receieve DebugUR1RTSLow error.\r\n");
N    
N    //Set DebugUR1RTS(PE4) HIGH
N    GPIO_SetBit(GPIOE, BIT4);
X    GPIO_SetBit(GPIOE, (0x00000010));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT15))
X    if(GPIO_ReadBit(GPIOB, (0x00008000)))
N        DebugUR1RTSHighCADUR10CTSInFlag = TRUE;
X        DebugUR1RTSHighCADUR10CTSInFlag = (1);
N        //terninalPrintf("CADUR10CTS receieve DebugUR1RTSHigh success\r\n");
N    else
N        DebugUR1RTSHighCADUR10CTSInFlag = FALSE;
X        DebugUR1RTSHighCADUR10CTSInFlag = (0);
N        //terninalPrintf("CADUR10CTS receieve DebugUR1RTSHigh error.\r\n");
N    GPIO_CloseBit(GPIOB, BIT15);
X    GPIO_CloseBit(GPIOB, (0x00008000));
N    GPIO_CloseBit(GPIOE, BIT4);
X    GPIO_CloseBit(GPIOE, (0x00000010));
N    
N    
N   // if(CADCTSValue & 0x01 )
N    if(DebugUR1RTSLowCADUR10CTSInFlag & DebugUR1RTSHighCADUR10CTSInFlag )
N    {
N        terninalPrintf("U14 CTS & U15 RTS connect success.\r\n");
N        MTPString[26][5] = 0x81;
N    }
N    else
N    {        
N        terninalPrintf("U14 CTS & U15 RTS connect error.\r\n");
N        MTPString[26][5] = 0x80;
N        return FALSE;
X        return (0);
N     
N    }
N    
N    /*
N    // CAD send RTS signal to Debug   
N    //CADUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
N    CADUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
N    vTaskDelay(100/portTICK_RATE_MS);
N    DebudCTSValue =  inpw(REG_UART0_MSR+UART1*UARTOFFSET) ;
N    //terninalPrintf("DebudCTSValue=%32b\n",DebudCTSValue);
N    */
N    
N    
N    BOOL CADUR10RTSLowDebugUR1CTSInFlag  = FALSE;
X    BOOL CADUR10RTSLowDebugUR1CTSInFlag  = (0);
N    BOOL CADUR10RTSHighDebugUR1CTSInFlag = FALSE;
X    BOOL CADUR10RTSHighDebugUR1CTSInFlag = (0);
N
N    
N    //Set CADUR10RTS(PB14) and DebugUR1CTS(PE5) GPIO
N
N    GPIO_CloseBit(GPIOE, BIT5);
X    GPIO_CloseBit(GPIOE, (0x00000020));
N    GPIO_CloseBit(GPIOB, BIT14);
X    GPIO_CloseBit(GPIOB, (0x00004000));
N    
N    //Set DebugUR1CTS(PE5) input
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<< 20)) | (0<< 20));
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<< 20)) | (0<< 20);
N    GPIO_OpenBit(GPIOE, BIT5, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000020), DIR_INPUT, PULL_UP);
N
N    //Set CADUR10RTS(PB14) output
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 24)) | (0<< 24));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<< 24)) | (0<< 24);
N    GPIO_OpenBit(GPIOB, BIT14, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00004000), DIR_OUTPUT, PULL_UP);
N
N    
N    //Set CADUR10RTS(PB14) LOW
N    GPIO_ClrBit(GPIOB, BIT14);
X    GPIO_ClrBit(GPIOB, (0x00004000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOE, BIT5))
X    if(!GPIO_ReadBit(GPIOE, (0x00000020)))
N        CADUR10RTSLowDebugUR1CTSInFlag  = TRUE;
X        CADUR10RTSLowDebugUR1CTSInFlag  = (1);
N        //terninalPrintf("DebugUR1CTS receieve CADUR10RTSLow success\r\n");
N    else
N        CADUR10RTSLowDebugUR1CTSInFlag  = FALSE;
X        CADUR10RTSLowDebugUR1CTSInFlag  = (0);
N        //terninalPrintf("DebugUR1CTS receieve CADUR10RTSLow error.\r\n");
N    
N    //Set CADUR10RTS(PB14) HIGH
N    GPIO_SetBit(GPIOB, BIT14);
X    GPIO_SetBit(GPIOB, (0x00004000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOE, BIT5))
X    if(GPIO_ReadBit(GPIOE, (0x00000020)))
N        CADUR10RTSHighDebugUR1CTSInFlag = TRUE;
X        CADUR10RTSHighDebugUR1CTSInFlag = (1);
N        //terninalPrintf("DebugUR1CTS receieve CADUR10RTSHigh success\r\n");
N    else
N        CADUR10RTSHighDebugUR1CTSInFlag = FALSE;
X        CADUR10RTSHighDebugUR1CTSInFlag = (0);
N        //terninalPrintf("DebugUR1CTS receieve CADUR10RTSHigh error.\r\n");
N    GPIO_CloseBit(GPIOE, BIT5);
X    GPIO_CloseBit(GPIOE, (0x00000020));
N    GPIO_CloseBit(GPIOB, BIT14);
X    GPIO_CloseBit(GPIOB, (0x00004000));
N    
N    
N    
N    //if(DebudCTSValue & 0x01 )
N    if(CADUR10RTSLowDebugUR1CTSInFlag & CADUR10RTSHighDebugUR1CTSInFlag )
N    {
N        terninalPrintf("U14 RTS & U15 CTS connect success.\r\n");
N        MTPString[26][6] = 0x81;
N    }
N    else
N    {        
N        terninalPrintf("U14 RTS & U15 CTS connect error.\r\n");
N        MTPString[26][6] = 0x80;  
N        return FALSE;
X        return (0);
N    }
N    /*
N    if(resultFlag2 && resultFlag3)
N    {
N        terninalPrintf("U14 & U15 RX,TX,CTS,RTS connect success.\r\n");
N        IOtestResultFlag[0] = TRUE;
N        MTPString[26][3] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("U14 & U15 RX,TX,CTS,RTS connect error.\r\n");
N        IOtestResultFlag[0] = FALSE;
N        return FALSE;
N    }
N    */
N    SetCADtenConnectFlagFunc(FALSE);
X    SetCADtenConnectFlagFunc((0));
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    GPIO_ClrBit(GPIOA, BIT14); // TEN I/O clear LOW
X    GPIO_ClrBit(GPIOA, (0x00004000)); 
N    
N    if(ReadCADtenConnectFlagFunc())
N    {
N        terninalPrintf("CAD TEN & Solar I/O connect success.\r\n");
N        resultFlag4 = TRUE;
X        resultFlag4 = (1);
N        IOtestResultFlag[1] = TRUE;
X        IOtestResultFlag[1] = (1);
N        MTPString[26][7] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("CAD TEN & Solar I/O connect error.\r\n");
N        resultFlag4 = FALSE;
X        resultFlag4 = (0);
N        IOtestResultFlag[1] = FALSE;
X        IOtestResultFlag[1] = (0);
N        MTPString[26][7] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    
N    //vTaskDelay(3000/portTICK_RATE_MS);
N    
N    //close debug UART RS232 power
N    pUartInterface->setRS232PowerFunc(TRUE);
X    pUartInterface->setRS232PowerFunc((1));
N    
N    //close CAD RS232 power
N    CADUartInterface->setPowerFunc(FALSE);
X    CADUartInterface->setPowerFunc((0));
N    
N    //close CAD UART IO
N    
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<<16)) | (0x0<<16);
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<<20)) | (0x0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<<20)) | (0x0<<20);
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<<24)) | (0x0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<<24)) | (0x0<<24);
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xFu<<28))| (0x0<<28)); 
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xFu<<28))| (0x0<<28); 
N    
N    GPIO_OpenBit(GPIOB, BIT12, DIR_OUTPUT, NO_PULL_UP); 
X    GPIO_OpenBit(GPIOB, (0x00001000), DIR_OUTPUT, NO_PULL_UP); 
N    GPIO_OpenBit(GPIOB, BIT13, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00002000), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOB, BIT14, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00004000), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOB, BIT15, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00008000), DIR_OUTPUT, NO_PULL_UP);
N    
N    GPIO_ClrBit(GPIOB, BIT12);
X    GPIO_ClrBit(GPIOB, (0x00001000));
N    GPIO_ClrBit(GPIOB, BIT13);
X    GPIO_ClrBit(GPIOB, (0x00002000));
N    GPIO_ClrBit(GPIOB, BIT14);
X    GPIO_ClrBit(GPIOB, (0x00004000));
N    GPIO_ClrBit(GPIOB, BIT15);
X    GPIO_ClrBit(GPIOB, (0x00008000));
N    
N    //close debug UART IO
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<8))  | (0x0<<8));
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<<8)) | (0x0<<8);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<12)) | (0x0<<12));
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<<12)) | (0x0<<12);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<<16)) | (0x0<<16);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<20)) | (0x0<<20));   
X    *((volatile unsigned int *)((0xB0000000+0x090))) = ((*((volatile unsigned int *)((0xB0000000+0x090)))) & ~(0xF<<20)) | (0x0<<20);   
N    
N    GPIO_OpenBit(GPIOE, BIT2, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000004), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOE, BIT3, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000008), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOE, BIT4, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000010), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_OpenBit(GPIOE, BIT5, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000020), DIR_OUTPUT, NO_PULL_UP);
N    
N    GPIO_ClrBit(GPIOE, BIT2);
X    GPIO_ClrBit(GPIOE, (0x00000004));
N    GPIO_ClrBit(GPIOE, BIT3);
X    GPIO_ClrBit(GPIOE, (0x00000008));
N    GPIO_ClrBit(GPIOE, BIT4);
X    GPIO_ClrBit(GPIOE, (0x00000010));
N    GPIO_ClrBit(GPIOE, BIT5);
X    GPIO_ClrBit(GPIOE, (0x00000020));
N    
N    //close CAD power
N
N    GPIO_SetBit(GPIOB, BIT3);
X    GPIO_SetBit(GPIOB, (0x00000008));
N    GPIO_ClrBit(GPIOB, BIT4);
X    GPIO_ClrBit(GPIOB, (0x00000010));
N    GPIO_ClrBit(GPIOA, BIT14);
X    GPIO_ClrBit(GPIOA, (0x00004000));
N    
N
N    if( (MTPString[26][3] == 0x81)  &&  
N        (MTPString[26][4] == 0x81)  &&
N        (MTPString[26][5] == 0x81)  &&
N        (MTPString[26][6] == 0x81)  &&
N        (MTPString[26][7] == 0x81)  
N      )
N    {
N        MTPString[26][8] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N    else
N    {
N        MTPString[26][8] = 0x80;
N        if(MBtestFlag)
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE; 
X            return 0x10; 
N    }
N    
N   /* 
N    if( IOtestResultFlag[0]  &&  
N        IOtestResultFlag[1]
N      )
N    {
N        MTPString[26][5] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
N    }
N    else
N    {
N        if(MBtestFlag)
N            return FALSE;
N        else
N            return TEST_FALSE; 
N    }
N    */
N    /*
N    //if( (resultFlag1 == TRUE) && (resultFlag2 == TRUE) && (resultFlag3 == TRUE) && (resultFlag4 == TRUE) )
N    if( (resultFlag2 == TRUE) && (resultFlag3 == TRUE) && (resultFlag4 == TRUE) )
N        return TEST_SUCCESSFUL_LIGHT_ON;
N    else
N        return TEST_FALSE;
N    
N    */
W "src\user\hwtester.c" 3560 10 variable "resultFlag1" was declared but never referenced
W "src\user\hwtester.c" 3561 10 variable "resultFlag2" was declared but never referenced
W "src\user\hwtester.c" 3562 10 variable "resultFlag3" was declared but never referenced
W "src\user\hwtester.c" 3563 10 variable "resultFlag4" was set but never used
W "src\user\hwtester.c" 3568 9 variable "ReadBufLen" was declared but never referenced
N}
N
Nvoid QueryCADtimeoutFunc(BOOL timeoutFlag)
N{
N    gCADtimeoutFlag = timeoutFlag;
N}
N
Nstatic BOOL CADReaderTest(void* para1, void* para2)
N{
N    uint8_t pucBuf[300];
N    int waitcounter = 0;
N    int mwaitcounter = 0;
N    uint8_t currentSequenceNum = 0;
N    gCADtimeoutFlag = FALSE;
X    gCADtimeoutFlag = (0);
N    
N    guiPrintResult("credit card\nTesting");
N    //guiPrintResult("credit card Init");
N    
N    CADReadCardinit((uint8_t*)pucBuf);
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    terninalPrintf("Please insert credit card in 10 seconds.\r\n");
N    guiPrintMessage("Please Tag\nor key = skip");
N    GuiManagerCleanMessage(GUI_CAD_TIMER_ENABLE);
X    GuiManagerCleanMessage(0x10);
N    
N    char tempchar;
N    
N    CADReadCard((uint8_t*)pucBuf ,&currentSequenceNum);
N    
N    while(1)
N    {
N        //terninalPrintf("%d \r",10-waitcounter);
N        if(CADReadCard((uint8_t*)pucBuf ,&currentSequenceNum))
N        {
N            //BuzzerPlay(200, 500, 1, TRUE);
N            GuiManagerCleanMessage(GUI_CAD_TIMER_DISABLE);
X            GuiManagerCleanMessage(0x11);
N            break;
N        }
N        
N        
N        GuiManagerCleanMessage(GUI_CAD_TIMEROUT_FLAG);
X        GuiManagerCleanMessage(0x12);
N        if(gCADtimeoutFlag)
N            break;
N        
N        tempchar = userResponse();
N        if( (tempchar =='n') || !DetectCADConnect())
N        {
N            GuiManagerCleanMessage(GUI_CAD_TIMER_DISABLE);
X            GuiManagerCleanMessage(0x11);
N            CADReadCardpoweroff();
N            return TEST_FALSE;
X            return 0x10;
N        }
N
N        /*
N        else
N            mwaitcounter++;
N        if(mwaitcounter >= 2)
N        {
N            mwaitcounter = 0;
N            waitcounter++; 
N        }
N        if(waitcounter >= 10)
N            break;
N        vTaskDelay(500/portTICK_RATE_MS);
N        */
N    }
N    
N    
N    CADReadCardpoweroff();
N    //if(waitcounter >= 10)
N    if(gCADtimeoutFlag)
N        return TEST_FALSE;
X        return 0x10;
N    else
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N
N    
N    
N    
W "src\user\hwtester.c" 4044 9 variable "waitcounter" was declared but never referenced
W "src\user\hwtester.c" 4045 9 variable "mwaitcounter" was declared but never referenced
N}
N
N//////////////////////Battery test////////////////////////TEST_SUCCESSFUL_LIGHT_ON
Nstatic BOOL batteryTest(void* para1, void* para2)
N{    
N    char string1[50];
N    terninalPrintf("!!! batteryTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Battery Testing");
N//    uint16_t ledData = 0x00;
N    //BOOL lastStatus[] = {IOPIN_BOTH_OFF, IOPIN_ONLY1_ON, IOPIN_BOTH_OFF, IOPIN_ONLY2_ON, IOPIN_BOTH_OFF, SOLAR_OFF, SOLAR_ON}; 
N    BOOL lastStatus[] = {IOPIN_BOTH_OFF, IOPIN_ONLY1_ON, IOPIN_BOTH_OFF, IOPIN_ONLY2_ON, IOPIN_BOTH_OFF};
X    BOOL lastStatus[] = {3, 2, 3, 1, 3};
N    BOOL statusStage = 0;
N    //BOOL pinStage = 0;
N    UINT32 solarVoltage ,leftVoltage,  rightVoltage;
N
N    if(MBtestFlag )
N    {
N        char tempchar;
N        BOOL batResultFlag1 = FALSE;   // Test battery1 
X        BOOL batResultFlag1 = (0);   
N        BOOL batResultFlag2 = FALSE;   // Test battery2
X        BOOL batResultFlag2 = (0);   
N        BOOL batResultFlag3 = FALSE;   // Test solar battery
X        BOOL batResultFlag3 = (0);   
N        BOOL batResultFlag4 = FALSE;   // ADC0
X        BOOL batResultFlag4 = (0);   
N        BOOL batResultFlag5 = FALSE;   // ADC1
X        BOOL batResultFlag5 = (0);   
N        BOOL batResultFlag6 = FALSE;   // ADC2
X        BOOL batResultFlag6 = (0);   
N        BOOL batResultFlag7 = FALSE;   //Test SW1
X        BOOL batResultFlag7 = (0);   
N        BOOL batResultFlag8 = FALSE;   //Test SW2
X        BOOL batResultFlag8 = (0);   
N        
N        int waitCount; 
N        
N        BatteryDrvInit(FALSE);
X        BatteryDrvInit((0));
N/*
N        terninalPrintf("Test solar battery.\r\n");
N        BatterySetSwitch1(FALSE);
N        BatterySetSwitch2(FALSE);
N        
N        outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<<24)));
N        GPIO_OpenBit(GPIOE,BIT14, DIR_OUTPUT, NO_PULL_UP); 
N        
N        GPIO_ClrBit(GPIOE,BIT14);
N        vTaskDelay(1000/portTICK_RATE_MS);
N        GPIO_SetBit(GPIOE,BIT14);
N        vTaskDelay(1000/portTICK_RATE_MS);
N        GPIO_ClrBit(GPIOE,BIT14);
N        vTaskDelay(1000/portTICK_RATE_MS);
N        GPIO_SetBit(GPIOE,BIT14);
N        vTaskDelay(1000/portTICK_RATE_MS);
N        GPIO_ClrBit(GPIOE,BIT14);
N        
N        terninalPrintf("Is the D7 light signal correct?(y/n)\r\n");
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                terninalPrintf("solar battery control success.\r\n");
N                batResultFlag1 =TRUE;
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                terninalPrintf("solar battery control error.\r\n");
N                batResultFlag1 = FALSE;
N                return TEST_FALSE;
N            }
N        }
N        */
N        
N        terninalPrintf("Test battery voltage.\r\n");
N        //GPIO_ClrBit(GPIOE,BIT14);
N        //BatterySetSwitch2(FALSE);
N        
N        BatteryGetVoltage();				
N        vTaskDelay(500/portTICK_RATE_MS);
X        vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        BatteryGetValue(&solarVoltage, &leftVoltage, &rightVoltage);
N        terninalPrintf(" Voltage: [%d], [%d] , SolarVol: [%d]\r\n", leftVoltage, rightVoltage, solarVoltage);
N        
N        if((leftVoltage < MB_BAT_MIN_VOLTAGE) || (leftVoltage > MB_BAT_MAX_VOLTAGE))
X        if((leftVoltage < 770) || (leftVoltage > 880))
N        {
N            terninalPrintf("Battery 1 Voltage: [%d][ERROR]\r\n", leftVoltage);
N            batResultFlag5= FALSE;
X            batResultFlag5= (0);
N            MTPString[0][3] = 0x80;
N        }
N        else
N        {
N            batResultFlag5= TRUE;
X            batResultFlag5= (1);
N            MTPString[0][3] = 0x81;
N        }
N        if((rightVoltage < MB_BAT_MIN_VOLTAGE) || (rightVoltage > MB_BAT_MAX_VOLTAGE))
X        if((rightVoltage < 770) || (rightVoltage > 880))
N        {   
N            terninalPrintf("Battery 2 Voltage: [%d][ERROR]\r\n", rightVoltage);
N            batResultFlag6= FALSE;
X            batResultFlag6= (0);
N            MTPString[0][4] = 0x80;
N        }
N        else
N        {
N            batResultFlag6= TRUE;
X            batResultFlag6= (1);
N            MTPString[0][4] = 0x81;
N        }
N        if((solarVoltage < MB_BAT_MIN_VOLTAGE) || (solarVoltage > MB_BAT_MAX_VOLTAGE))
X        if((solarVoltage < 770) || (solarVoltage > 880))
N        {   
N            terninalPrintf("Solar Bat Voltage: [%d][ERROR]\r\n", solarVoltage);
N            batResultFlag4= FALSE;
X            batResultFlag4= (0);
N            MTPString[0][5] = 0x80;
N        }
N        else
N        {
N            batResultFlag4= TRUE;
X            batResultFlag4= (1);
N            MTPString[0][5] = 0x81;
N        }
N        if(!(batResultFlag4 && batResultFlag5 && batResultFlag6))  
N        {    
N            //SetMTPCRC(0,(uint8_t*)MTPString);
N            //MTPCmdprint(0,(uint8_t*)MTPString);            
N            return FALSE;
X            return (0);
N        }
N        
N        SetMTPCRC(52,(uint8_t*)MTPString);
N        MTPCmdprint(52,(uint8_t*)MTPString); 
N        terninalPrintf("Test battery1.\r\n");
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        BatterySetSwitch1(TRUE);
X        BatterySetSwitch1((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        BatterySetSwitch1(FALSE);
X        BatterySetSwitch1((0));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        BatterySetSwitch1(TRUE);
X        BatterySetSwitch1((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        //BatterySetSwitch1(FALSE);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        //BatterySetSwitch1(TRUE);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        GPIO_SetBit(GPIOE,BIT14);
X        GPIO_SetBit(GPIOE,(0x00004000));
N        
N        SetMTPCRC(1,(uint8_t*)MTPString);
N        MTPCmdprint(1,(uint8_t*)MTPString); 
N        terninalPrintf("Is the D7 & D8 light signal correct?(y/n)\r\n");
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                terninalPrintf("battery1 control success.\r\n");
N                batResultFlag1 =TRUE;
X                batResultFlag1 =(1);
N                MTPString[0][6] = 0x81;
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                terninalPrintf("battery1 control error.\r\n");
N                batResultFlag1 = FALSE;
X                batResultFlag1 = (0);
N                
N                GPIO_ClrBit(GPIOE,BIT14);
X                GPIO_ClrBit(GPIOE,(0x00004000));
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                BatterySetSwitch1(FALSE);
X                BatterySetSwitch1((0));
N                BatterySetSwitch2(FALSE);
X                BatterySetSwitch2((0));
N                MTPString[0][6] = 0x80;                           
N                return FALSE;
X                return (0);
W "src\user\hwtester.c" 4272 17 statement is unreachable
N                break;
N            }
N        }
N        
N        SetMTPCRC(53,(uint8_t*)MTPString);
N        MTPCmdprint(53,(uint8_t*)MTPString); 
N        terninalPrintf("Test battery2.\r\n");
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //GPIO_SetBit(GPIOE,BIT14);
N        BatterySetSwitch2(TRUE);
X        BatterySetSwitch2((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        BatterySetSwitch2(FALSE);
X        BatterySetSwitch2((0));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        BatterySetSwitch2(TRUE);
X        BatterySetSwitch2((1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        //BatterySetSwitch2(FALSE);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        //BatterySetSwitch2(TRUE);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        BatterySetSwitch1(FALSE);
X        BatterySetSwitch1((0));
N        
N        SetMTPCRC(2,(uint8_t*)MTPString);
N        MTPCmdprint(2,(uint8_t*)MTPString);
N        terninalPrintf("Is the D8 & D9 light signal correct?(y/n)\r\n");
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                terninalPrintf("battery2 control success.\r\n");
N                batResultFlag2 =TRUE;
X                batResultFlag2 =(1);
N                MTPString[0][7] = 0x81;
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                terninalPrintf("battery2 control error.\r\n");
N                batResultFlag2= FALSE;
X                batResultFlag2= (0);
N                
N                
N                GPIO_ClrBit(GPIOE,BIT14); 
X                GPIO_ClrBit(GPIOE,(0x00004000)); 
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                BatterySetSwitch1(FALSE);
X                BatterySetSwitch1((0));
N                BatterySetSwitch2(FALSE);
X                BatterySetSwitch2((0));
N                MTPString[0][7] = 0x80;
N                return FALSE;
X                return (0);
W "src\user\hwtester.c" 4321 17 statement is unreachable
N                break;
N            }
N        }
N        
N        SetMTPCRC(54,(uint8_t*)MTPString);
N        MTPCmdprint(54,(uint8_t*)MTPString);
N        terninalPrintf("Test solar battery.\r\n");
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //BatterySetSwitch1(FALSE);
N        //BatterySetSwitch2(FALSE); 
N        
N        GPIO_ClrBit(GPIOE,BIT14);
X        GPIO_ClrBit(GPIOE,(0x00004000));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        GPIO_SetBit(GPIOE,BIT14);
X        GPIO_SetBit(GPIOE,(0x00004000));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        GPIO_ClrBit(GPIOE,BIT14);
X        GPIO_ClrBit(GPIOE,(0x00004000));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //vTaskDelay(500/portTICK_RATE_MS);
N        //GPIO_SetBit(GPIOE,BIT14);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        //GPIO_ClrBit(GPIOE,BIT14);
N        //vTaskDelay(1000/portTICK_RATE_MS);
N        BatterySetSwitch2(FALSE); 
X        BatterySetSwitch2((0)); 
N        
N        SetMTPCRC(3,(uint8_t*)MTPString);
N        MTPCmdprint(3,(uint8_t*)MTPString);
N        terninalPrintf("Is the D7 & D9 light signal correct?(y/n)\r\n");
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                terninalPrintf("solar battery control success.\r\n");
N                batResultFlag3 =TRUE;
X                batResultFlag3 =(1);
N                MTPString[0][8] = 0x81;
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                terninalPrintf("solar battery control error.\r\n");
N                batResultFlag3 = FALSE;
X                batResultFlag3 = (0);
N                
N                GPIO_ClrBit(GPIOE,BIT14); 
X                GPIO_ClrBit(GPIOE,(0x00004000)); 
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                BatterySetSwitch1(FALSE);
X                BatterySetSwitch1((0));
N                BatterySetSwitch2(FALSE);
X                BatterySetSwitch2((0));
N                MTPString[0][8] = 0x80;
N                return FALSE;
X                return (0);
N                //return TEST_FALSE;
W "src\user\hwtester.c" 4372 17 statement is unreachable
N                break;
N            }
N        }
N        
N        
N        
N        
N        SetMTPCRC(4,(uint8_t*)MTPString);
N        MTPCmdprint(4,(uint8_t*)MTPString);
N        terninalPrintf("Test SW1.\r\n");
N        SetBatINTtestFlagFunc(1,FALSE);
X        SetBatINTtestFlagFunc(1,(0));
N        waitCount = 10;
N        
N        while(1)
N        {
N            if(ReadBatINTtestFlagFunc(1))
N            {
N                terninalPrintf("SW1 test success.\r\n");
N                batResultFlag7= TRUE;
X                batResultFlag7= (1);
N                BuzzerPlay(200, 500, 1, TRUE);
X                BuzzerPlay(200, 500, 1, (1));
N                LEDColorBuffSet(0x00,0x04 );
N                LEDBoardLightSet();
N                MTPString[0][9] = 0x81;
N                break;
N            }
N            
N            if(waitCount <= 0)
N            {
N                terninalPrintf("SW1 test error.\r\n");
N                batResultFlag7= FALSE;
X                batResultFlag7= (0);
N                MTPString[0][9] = 0x80;
N                return FALSE;
X                return (0);
W "src\user\hwtester.c" 4404 17 statement is unreachable
N                break;
N            }
N            waitCount--;
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        }
N        
N        SetMTPCRC(5,(uint8_t*)MTPString);
N        MTPCmdprint(5,(uint8_t*)MTPString);
N        terninalPrintf("Test SW2.\r\n");
N        SetBatINTtestFlagFunc(2,FALSE);
X        SetBatINTtestFlagFunc(2,(0));
N        waitCount = 10;
N        
N        while(1)
N        {
N            if(ReadBatINTtestFlagFunc(2))
N            {
N                terninalPrintf("SW2 test success.\r\n");
N                //LEDColorBuffSet(0x00,0x20
N                BuzzerPlay(200, 500, 1, TRUE);
X                BuzzerPlay(200, 500, 1, (1));
N                LEDColorBuffSet(0x00,0x08);
N                LEDBoardLightSet();
N                batResultFlag8= TRUE;
X                batResultFlag8= (1);
N                MTPString[0][10] = 0x81;
N                break;
N            }
N            
N            if(waitCount <= 0)
N            {
N                terninalPrintf("SW2 test error.\r\n");
N                batResultFlag8= FALSE;
X                batResultFlag8= (0);
N                //SetMTPCRC(0,(uint8_t*)MTPString);
N                //MTPCmdprint(0,(uint8_t*)MTPString);
N                MTPString[0][10] = 0x80;
N                return FALSE;
X                return (0);
W "src\user\hwtester.c" 4438 17 statement is unreachable
N                break;
N            }
N            waitCount--;
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        }
N        vTaskDelay(3000/portTICK_RATE_MS);
X        vTaskDelay(3000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        LEDColorBuffSet(0x00, 0x00);
N        LEDBoardLightSet();
N        
N        if( batResultFlag1  &&
N            batResultFlag2  &&
N            batResultFlag3  &&
N            batResultFlag4  &&
N            batResultFlag5  &&
N            batResultFlag6  &&
N            batResultFlag7  && 
N            batResultFlag8 )
N        {
N            MTPString[0][11] = 0x81;
N            //SetMTPCRC(0,(uint8_t*)MTPString);
N            //MTPCmdprint(0,(uint8_t*)MTPString);
N            return TEST_SUCCESSFUL_LIGHT_ON;
X            return 0x13;
N        }
N        else
N        {
N            //SetMTPCRC(0,(uint8_t*)MTPString);
N            //MTPCmdprint(0,(uint8_t*)MTPString);
N            MTPString[0][11] = 0x80;
N            return FALSE;
X            return (0);
N        }
N            //return TEST_FALSE;
N        
N    }
N    else
N    {
N        int mtimeoutCounter1 = 0;  // Bat1 & Bat2 mtimeoutCounter
N        int timeoutCounter1 = 0;  // Bat1 & Bat2 timeoutCounter
N        int mtimeoutCounter2 = 0;  // SolarBat mtimeoutCounter
N        int timeoutCounter2 = 0;  // SolarBat timeoutCounter
N        if(BatteryDrvInit(FALSE))
X        if(BatteryDrvInit((0)))
N        {
N            //terninalPrintf(" Battery Driver Init [OK]...(press 'n' to exit!!!) \r\n");
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage("Battery Testing");
N            //UINT32 solarVoltage ,leftVoltage,  rightVoltage;
N            //BatterySetEnableTestMode(TRUE);
N            BatteryGetVoltage();				
N            vTaskDelay(500/portTICK_RATE_MS);
X            vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            BatteryGetValue(&solarVoltage, &leftVoltage, &rightVoltage);
N            terninalPrintf(" Voltage: [%d], [%d] , SolarVol: [%d]\r\n", leftVoltage, rightVoltage, solarVoltage);
N            sprintf(string1,"Battery\nLeft :%d.%dV\nRight:%d.%dV\nSolar:%d.%dV",
N                    leftVoltage/100,(leftVoltage/10)%10,
N                    rightVoltage/100,(rightVoltage/10)%10,
N                    solarVoltage/100,(solarVoltage/10)%10);
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage(string1);
N            
N
N            if(MBtestFlag )
N            {  
N                if((leftVoltage < MB_BAT_MIN_VOLTAGE) || (leftVoltage > MB_BAT_MAX_VOLTAGE))
X                if((leftVoltage < 770) || (leftVoltage > 880))
N                {
N                    terninalPrintf("Battery 1 Voltage: [%d][ERROR]\r\n", leftVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N                if((rightVoltage < MB_BAT_MIN_VOLTAGE) || (rightVoltage > MB_BAT_MAX_VOLTAGE))
X                if((rightVoltage < 770) || (rightVoltage > 880))
N                {   
N                    terninalPrintf("Battery 2 Voltage: [%d][ERROR]\r\n", rightVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N                if((solarVoltage < MB_BAT_MIN_VOLTAGE) || (solarVoltage > MB_BAT_MAX_VOLTAGE))
X                if((solarVoltage < 770) || (solarVoltage > 880))
N                {   
N                    terninalPrintf("Solar Bat Voltage: [%d][ERROR]\r\n", solarVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N            }
N            else
N            {
N                if((leftVoltage < BATTERY_L_MIN_VOLTAGE) || (leftVoltage > BATTERY_L_MAX_VOLTAGE))
X                if((leftVoltage < 730) || (leftVoltage > 770))
N                {
N                    terninalPrintf("Battery 1 Voltage: [%d][ERROR]\r\n", leftVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N                if((rightVoltage < BATTERY_R_MIN_VOLTAGE) || (rightVoltage > BATTERY_R_MAX_VOLTAGE))
X                if((rightVoltage < 760) || (rightVoltage > 800))
N                {   
N                    terninalPrintf("Battery 2 Voltage: [%d][ERROR]\r\n", rightVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N                if((solarVoltage < SOLAR_BAT_MIN_VOLTAGE) || (solarVoltage > SOLAR_BAT_MAX_VOLTAGE))
X                if((solarVoltage < 770) || (solarVoltage > 850))
N                {   
N                    terninalPrintf("Solar Bat Voltage: [%d][ERROR]\r\n", solarVoltage);
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N            }
N            terninalPrintf("  Start check battery \r\n");
N            terninalPrintf("Please Remove Battery 1\r\n");
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage("Remove Bat 1");
N            //LEDColorBuffSet(0x38, 0x00);
N            LEDColorBuffSet(0x01, 0x00);
N            LEDBoardLightSet();
N            //BOOL portValue = (GPIO_ReadBit(BATTERY_1_LOW_DETECT_PORT, BATTERY_1_LOW_DETECT_PIN) << 0) 
N            //    | (GPIO_ReadBit(BATTERY_2_LOW_DETECT_PORT, BATTERY_2_LOW_DETECT_PIN) << 1) ;
N            BOOL portValue = (GPIO_ReadBit(BATTERY_1_LOW_DETECT_PORT, BATTERY_1_LOW_DETECT_PIN) << 1)
X            BOOL portValue = (GPIO_ReadBit(GPIOH, (0x00000040)) << 1)
N                        | (GPIO_ReadBit(BATTERY_2_LOW_DETECT_PORT, BATTERY_2_LOW_DETECT_PIN) << 0);
X                        | (GPIO_ReadBit(GPIOH, (0x00000020)) << 0);
N
N            if((portValue) != lastStatus[statusStage])
N            {
N                terninalPrintf("Battery test operation[ERROR]\r\n");
N                return TEST_FALSE;
X                return 0x10;
N            }
N            else
N            {
N                //terninalPrintf("Please Remove Battery 1\r\n");
N                statusStage++;
N                while(1)
N                {
N                    //portValue = (GPIO_ReadBit(BATTERY_1_LOW_DETECT_PORT, BATTERY_1_LOW_DETECT_PIN) << 1)
N                    //    | (GPIO_ReadBit(BATTERY_2_LOW_DETECT_PORT, BATTERY_2_LOW_DETECT_PIN) << 0);
N                    portValue = (GPIO_ReadBit(BATTERY_1_LOW_DETECT_PORT, BATTERY_1_LOW_DETECT_PIN) << 0) 
X                    portValue = (GPIO_ReadBit(GPIOH, (0x00000040)) << 0) 
N                                | (GPIO_ReadBit(BATTERY_2_LOW_DETECT_PORT, BATTERY_2_LOW_DETECT_PIN) << 1) ;
X                                | (GPIO_ReadBit(GPIOH, (0x00000020)) << 1) ;
N                    if((portValue != lastStatus[statusStage-1]) && (portValue != lastStatus[statusStage]))
N                    {
N                        testErroCode = BATTERY_SEQUENCE_ERRO;
X                        testErroCode = 0x0E30;
N                        //terninalPrintf("Battery Test [ERROR]");
N                        return TEST_FALSE;
X                        return 0x10;
N                    }
N                    else if(portValue == lastStatus[statusStage])
N                        {
N                        switch(portValue)
N                        {
N                        case IOPIN_BOTH_ON:
X                        case 0:
N                            terninalPrintf("IOPIN_BOTH_ON");
N                            break;
N                        case IOPIN_ONLY1_ON:
X                        case 2:
N                            cleanMsg();
N                            //vTaskDelay(15/portTICK_RATE_MS);
N                            guiPrintMessage("Connect Bat 1");
N                            terninalPrintf("Connect Battery 1\n");
N                        
N                            //LEDColorBuffSet(0x00,0x04 );
N                            //LEDBoardLightSet();
N                            /*
N                            LEDColorBuffSet(0x38, 0x00);
N                            LEDBoardLightSet();
N                            */
N                            break;
N                        case IOPIN_ONLY2_ON:
X                        case 1:
N                            terninalPrintf("Please connect Battery 2\r\n");
N                            vTaskDelay(15/portTICK_RATE_MS);
X                            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                            guiPrintMessage("Connect Bat 2");
N                            /*
N                            LEDColorBuffSet(0x03, 0x00);
N                            LEDBoardLightSet();
N                            */
N                            break;
N                        case IOPIN_BOTH_OFF:
X                        case 3:
N                            if(statusStage==4) break;
N                            terninalPrintf("Power both neither connect !!!\r\n");
N                            //vTaskDelay(15/portTICK_RATE_MS);
N                            guiPrintMessage("Remove Bat 2");
N                            terninalPrintf("Please Remove Battery 2\r\n");
N                            //LEDColorBuffSet(0x03, 0x00);
N                            LEDColorBuffSet(0x20, 0x00);
N                            LEDBoardLightSet();
N                            break;
N                        /*
N                        case SOLAR_OFF:
N
N                            guiPrintMessage("Remove Solar Bat ");
N                            terninalPrintf("Please Remove Solar Bat\r\n");
N                            LEDColorBuffSet(0x20, 0x00);
N                            LEDBoardLightSet();
N                            break;
N                        case SOLAR_ON:
N                            terninalPrintf("Please connect Solar Bat\r\n");
N                            guiPrintMessage("Connect Solar Bat");
N
N                            break;
N                        */
N                        default:
N                            terninalPrintf("Power = 0x%02x !!!\r\n", portValue);
N                            break;
N                        }
N                        statusStage++;
N                        timeoutCounter1 = 0;
N                    }
N
N                    if(statusStage == 5)
N                    {
N                        statusStage = 0;
N                        break;
N                    }      
N                    //vTaskDelay(300/portTICK_RATE_MS);
N                    vTaskDelay(200/portTICK_RATE_MS);
X                    vTaskDelay(200/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    mtimeoutCounter1++;
N                    if(mtimeoutCounter1 >= 5)
N                    {
N                        mtimeoutCounter1 = 0 ;
N                        terninalPrintf(" %d \r", 15 - timeoutCounter1);
N                        timeoutCounter1++ ;
N                        if(timeoutCounter1 >= 15)
N                        {
N                            return TEST_FALSE;
X                            return 0x10;
N                        }
N                    }
N                    
N                    
N                }
N            }
N            /*
N            guiPrintMessage("Remove Solar Bat ");
N            terninalPrintf("Please Remove Solar Bat\r\n");
N
N            
N                LedSetStatusLightFlush(50,10);  // solve LED board bug
N            LedSetColor(bayColorOff, 0x08, TRUE);
N            LedSetBayLightFlush(0xff,8);
N            vTaskDelay(100/portTICK_RATE_MS);
N            //LedSetColor(modemColorAllGreen, 0x04, TRUE);    
N            LedSetAliveStatusLightFlush(0xff,8);
N 
N            while(!GPIO_ReadBit(GPIOH,BIT7))
N            {
N                mtimeoutCounter2++;
N                if(mtimeoutCounter2 >= 5)
N                {
N                    mtimeoutCounter2 = 0 ;
N                    terninalPrintf(" %d \r", 15 - timeoutCounter2);
N                    timeoutCounter2++ ;
N                    if(timeoutCounter2 >= 15)
N                    {
N                        LedSetStatusLightFlush(0,10);  // solve LED board bug
N                        return TEST_FALSE;
N                    }
N                }
N                vTaskDelay(200/portTICK_RATE_MS);
N            }
N
N            terninalPrintf("Please connect Solar Bat\r\n");
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage("Connect Solar Bat");
N            //while(GPIO_ReadBit(GPIOH,BIT7));
N            mtimeoutCounter2 = 0;
N            timeoutCounter2 = 0;
N            while(GPIO_ReadBit(GPIOH,BIT7))
N            {
N                mtimeoutCounter2++;
N                if(mtimeoutCounter2 >= 5)
N                {
N                    mtimeoutCounter2 = 0 ;
N                    terninalPrintf(" %d \r", 15 - timeoutCounter2);
N                    timeoutCounter2++ ;
N                    if(timeoutCounter2 >= 15)
N                    {
N                        LedSetStatusLightFlush(0,10);  // solve LED board bug
N                        return TEST_FALSE;
N                    }
N                }
N                vTaskDelay(200/portTICK_RATE_MS);
N            }
N            
N            setBatterySwitchStatus(TRUE, FALSE);
N            LedSetStatusLightFlush(0,10);  // solve LED board bug
N            //LEDColorBuffSet(0x1F, 0x00);		
N            LEDColorBuffSet(0x00, 0x00);	        
N            LEDBoardLightSet();
N            vTaskDelay(2000/portTICK_RATE_MS);
N            setBatterySwitchStatus(FALSE, TRUE);
N            LEDColorBuffSet(0x00, 0x00);							
N            LEDBoardLightSet();
N            vTaskDelay(2000/portTICK_RATE_MS);
N            setBatterySwitchStatus(TRUE, TRUE);
N            //terninalPrintf("Battery Test [OK]");
N            
N            */
N            return TEST_SUCCESSFUL_LIGHT_ON;
X            return 0x13;
N        }
N        
N        setPrintfFlag(TRUE);
X        setPrintfFlag((1));
N        //return TRUE;
N        terninalPrintf(" Battery Driver Init [ERROR]\r\n");
N        return TEST_FALSE;
X        return 0x10;
W "src\user\hwtester.c" 4475 13 variable "mtimeoutCounter2" was declared but never referenced
W "src\user\hwtester.c" 4476 13 variable "timeoutCounter2" was declared but never referenced
N    }
N}
N
Nstatic BOOL SuperCapTest(void* para1, void* para2)
N{
N    char tempchar;
N    BOOL SuperCapResultFlag = FALSE;
X    BOOL SuperCapResultFlag = (0);
N    
N    SetMTPCRC(39,(uint8_t*)MTPString);
N    MTPCmdprint(39,(uint8_t*)MTPString);
N    
N    BatterySetSwitch1(FALSE);
X    BatterySetSwitch1((0));
N    BatterySetSwitch2(FALSE); 
X    BatterySetSwitch2((0)); 
N    GPIO_SetBit(GPIOE,BIT14);
X    GPIO_SetBit(GPIOE,(0x00004000));
N    
N    vTaskDelay(500/portTICK_RATE_MS);
X    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    LEDColorBuffSet(0x0C, 0x00);
N    LEDBoardLightSet();
N
N    SetMTPCRC(37,(uint8_t*)MTPString);
N    MTPCmdprint(37,(uint8_t*)MTPString);
N    terninalPrintf("Is the D3 & D4 light signal correct?(y/n)\r\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            terninalPrintf("SuperCap test success.\r\n");
N            SuperCapResultFlag = TRUE;
X            SuperCapResultFlag = (1);
N             MTPString[36][3] = 0x81;
N            break;
N        }
N        else if(tempchar =='n')
N        {
N            terninalPrintf("SuperCap test error.\r\n");
N            SuperCapResultFlag = FALSE;
X            SuperCapResultFlag = (0);
N            break;
N        }
N    }
N    
N    BatterySetSwitch1(FALSE);
X    BatterySetSwitch1((0));
N    BatterySetSwitch2(FALSE); 
X    BatterySetSwitch2((0)); 
N    GPIO_ClrBit(GPIOE,BIT14);
X    GPIO_ClrBit(GPIOE,(0x00004000));
N    
N    LEDColorBuffSet(0x00, 0x00);
N    LEDBoardLightSet();
N    
N    if(SuperCapResultFlag)
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    else
N    {
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    
N}
N
N//////////////////////Reader   test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL fReaderCn=FALSE;
Xstatic BOOL fReaderCn=(0);
Nstatic void readerCNCallback(BOOL flag, uint8_t* cn, int cnLen)/* CALLBACK FUNCTION */
N{
N    static BOOL prevFlag = FALSE;
X    static BOOL prevFlag = (0);
N    char stringID[80];
N    if(prevFlag != flag)
N    {
N        if(flag)
N        {
N            BuzzerPlay(200, 2, 1, FALSE);
X            BuzzerPlay(200, 2, 1, (0));
N            uint32_t tmpCardID=0;
N            cleanMsg();
N            terninalPrintf("Detect Card!\nCard ID:%02X%02X%02X%02X\n\n",cn[0],cn[1],cn[2],cn[3]);
N            sprintf(stringID,"Detect Card!\nCard ID:\n%02X%02X%02X%02X\n\n",cn[0],cn[1],cn[2],cn[3]);
N            for(int i = 0; i<cnLen; i++)
N            {
N                uint32_t tmpByte = cn[i];
N                tmpCardID = tmpCardID | tmpByte << 8*(cnLen-i-1);
N            }
N            cardID=tmpCardID;
N            //terninalPrintf("\r\n");
N            //show id at epd
N            EPDDrawString(TRUE,stringID,X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((1),stringID,550,354);
N            fReaderCn=TRUE;
X            fReaderCn=(1);
N        }
N    }
N//    terninalPrintf(".");
N    prevFlag = flag;
N}
N
N
Nvoid octopusDepositResultCallback(BOOL flag, uint16_t paraValue, uint16_t infoValue)
N{    
N    char stringID[80];
N    if(flag)
N    {
N        BuzzerPlay(200, 2, 1, FALSE);
X        BuzzerPlay(200, 2, 1, (0));
N        cleanMsg();
N        terninalPrintf("Deduct Success\n\n Balance: %d\r\n\r\n", infoValue);
N        sprintf(stringID,"Deduct Success\n\n Balance: %d\r\n\r\n", infoValue);
N
N        EPDDrawString(TRUE,stringID,X_POS_MSG,Y_POS_MSG);
X        EPDDrawString((1),stringID,550,354);
N        
N    }
N    else
N    {
N        BuzzerPlay(200, 2, 1, FALSE);
X        BuzzerPlay(200, 2, 1, (0));
N        cleanMsg();
N        //terninalPrintf("Deduct Fail\n\n");
N        sprintf(stringID,"Deduct Fail\n\n");
N
N        EPDDrawString(TRUE,stringID,X_POS_MSG,Y_POS_MSG);
X        EPDDrawString((1),stringID,550,354);
N    }
N    fReaderCn=TRUE;
X    fReaderCn=(1);
N}
N
N
Nstatic UINT32 SetValue(uint8_t DecimalNumber)
N{
N    
N    char charTmp;
N    UINT32 idTmp=0,i=0;
N    
N    while(1){
N
N    charTmp = superResponseLoopEx();
N
N    if(charTmp>='0'&&charTmp<='9')
N    {
N        idTmp=idTmp*10;
N        idTmp+=(charTmp-'0');
N        i++;
N        terninalPrintf("%c",charTmp);
N    }
N    if(charTmp == 0x0D)
N    {
N        if(TouchPadResponseFlag)
N        {
N            TouchPadResponseFlag = FALSE;
X            TouchPadResponseFlag = (0);
N            terninalPrintf("%d",ReceieveTouchPadVal);
N            return ReceieveTouchPadVal;
N        }
N        else
N            return idTmp;
W "src\user\hwtester.c" 4866 9 statement is unreachable
N        break;
N    }
N    //if((charTmp=='y') || (charTmp=='q'))
N    if(charTmp=='q')
N    {
N        TouchPadResponseFlag = FALSE;
X        TouchPadResponseFlag = (0);
N        return 0xffff;
W "src\user\hwtester.c" 4873 9 statement is unreachable
N        break;
N    }
N    if(i==DecimalNumber)
N    {
N        return idTmp;
W "src\user\hwtester.c" 4878 9 statement is unreachable
N        break;
N    }
N    }
N    terninalPrintf("\r\n");
N    
N    
W "src\user\hwtester.c" 4884 1 missing return statement at end of non-void function "SetValue"
N}
N
N//static void SetOctopusTime(void)
Nstatic BOOL SetOctopusTime(void)
N{
N    uint16_t idTmpYear,idTmpMonth,idTmpDay,idTmpHour,idTmpMinute,idTmpSecond,idTmpWeekday;
N    RTC_TIME_DATA_T id;
N    GuiManagerCleanMessage(GUI_SETRTC_YEAR);
X    GuiManagerCleanMessage(0x20);
N    terninalPrintf("Please enter year value in decimal.(ex:2020)\r\n");
N    terninalPrintf("Enter number is ");
N    //idTmpYear = SetValue(4);
N    id.u32Year = SetValue(4);
N    if(id.u32Year == 0xFFFF)
N        return FALSE;
X        return (0);
N    GuiManagerCleanMessage(GUI_SETRTC_MONTH);
X    GuiManagerCleanMessage(0x21);
N    terninalPrintf("\r\nPlease enter Month value in decimal.(01~12)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpMonth = SetValue(2);
N        id.u32cMonth = SetValue(2);
N        if(id.u32cMonth == 0xFFFF)
N            return FALSE;
X            return (0);
N        //if ((idTmpMonth == 0) || (idTmpMonth > 12))
N        if ((id.u32cMonth == 0) || (id.u32cMonth > 12))
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    GuiManagerCleanMessage(GUI_SETRTC_DAY);
X    GuiManagerCleanMessage(0x22);
N    terninalPrintf("\r\nPlease enter Day value in decimal.(01~31)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpDay = SetValue(2);
N        id.u32cDay = SetValue(2);
N        if(id.u32cDay == 0xFFFF)
N            return FALSE;
X            return (0);
N        //if ((idTmpDay == 0) || (idTmpDay > 31))
N        if ((id.u32cDay == 0) || (id.u32cDay > 31))
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    GuiManagerCleanMessage(GUI_SETRTC_HOUR);
X    GuiManagerCleanMessage(0x23);
N    terninalPrintf("\r\nPlease enter Hour value in decimal.(0~23)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpHour = SetValue(2);
N        id.u32cHour = SetValue(2);
N        if(id.u32cHour == 0xFFFF)
N            return FALSE;
X            return (0);
N        //if (idTmpHour > 23)
N        if (id.u32cHour > 23)
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    GuiManagerCleanMessage(GUI_SETRTC_MINUTE);
X    GuiManagerCleanMessage(0x24);
N    terninalPrintf("\r\nPlease enter Minute value in decimal.(0~59)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpMinute = SetValue(2);
N        id.u32cMinute = SetValue(2);
N       if(id.u32cMinute == 0xFFFF)
N            return FALSE;
X            return (0);
N        //if (idTmpMinute > 59)
N        if (id.u32cMinute > 59)
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    /*
N    terninalPrintf("\r\nPlease enter Second value in decimal.(0~59)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpSecond = SetValue(2);
N        id.u32cSecond = SetValue(2);
N        
N        
N        //if (idTmpSecond > 59)
N        if (id.u32cSecond > 59)
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    */
N    GuiManagerCleanMessage(GUI_SETRTC_WEEKDAY);
X    GuiManagerCleanMessage(0x25);
N    terninalPrintf("\r\nPlease enter Weekday value in decimal.(0:Sunday,1:Monday,...,6:Saturday)\r\n");
N    terninalPrintf("Enter number is ");
N    do
N    {
N        //idTmpWeekday = SetValue(1);
N        id.u32cDayOfWeek = SetValue(1);
N        if(id.u32cDayOfWeek == 0xFFFF)
N            return FALSE;
X            return (0);
N        //if (idTmpWeekday > 6)
N        if (id.u32cDayOfWeek > 6)
N            terninalPrintf("Input error \r\nRe-enter number is ");
N        else
N            break;
N        
N    }while(1);
N    
N    //terninalPrintf("Year/Month/Day  Hour:Minute:Second = %d/%d/%d  %d:%d:%d\r\n",pt.u32Year,pt.u32cMonth,pt.u32cDay,pt.u32cHour,pt.u32cMinute,pt.u32cSecond);
N    
N
N    
N    //SetOSTime(idTmpYear,idTmpMonth,idTmpDay,idTmpHour,idTmpMinute,idTmpSecond,idTmpWeekday);
N    //SetOSTime(id.u32Year,id.u32cMonth,id.u32cDay,id.u32cHour,id.u32cMinute,id.u32cSecond,id.u32cDayOfWeek);
N    SetOSTime(id.u32Year,id.u32cMonth,id.u32cDay,id.u32cHour,id.u32cMinute,0,id.u32cDayOfWeek);
N    //vTaskDelay(100/portTICK_RATE_MS);
N    
N    //terninalPrintf("\r\nModify time: ");
N    //QueryOStime(id);
N    
N    GuiManagerCleanMessage(GUI_SETRTC_MODIFY);
X    GuiManagerCleanMessage(0x26);
N    
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 4889 14 variable "idTmpYear" was declared but never referenced
W "src\user\hwtester.c" 4889 24 variable "idTmpMonth" was declared but never referenced
W "src\user\hwtester.c" 4889 35 variable "idTmpDay" was declared but never referenced
W "src\user\hwtester.c" 4889 44 variable "idTmpHour" was declared but never referenced
W "src\user\hwtester.c" 4889 54 variable "idTmpMinute" was declared but never referenced
W "src\user\hwtester.c" 4889 66 variable "idTmpSecond" was declared but never referenced
W "src\user\hwtester.c" 4889 78 variable "idTmpWeekday" was declared but never referenced
N}
N
Nstatic BOOL readerTest(void* para1, void* para2)
N{
N    int waitCounter = 10;
N    int i=0;
N    char tempchar;
N    RTC_TIME_DATA_T ot,pt;
N    time_t time, time2, time3;
N    if(MBtestFlag )
N    {
N        
N        BOOL resultFlag1 = FALSE;       //Reader Interconnect Result Flag
X        BOOL resultFlag1 = (0);       
N        BOOL resultFlag2 = FALSE;       //SAM test Result Flag
X        BOOL resultFlag2 = (0);       
N        BOOL resultFlag3 = FALSE;       //Flash test Result Flag
X        BOOL resultFlag3 = (0);       
N        BOOL resultFlag4 = FALSE;       //Reader power control test Result Flag
X        BOOL resultFlag4 = (0);       
N        char tempchar;
N        
N        terninalPrintf("!!! readerTest !!!\r\n");
N        guiPrintResult("Reader Testing");
N        guiPrintResult("Reader Init");
N        SetReaderInterconnectFlag(TRUE);
X        SetReaderInterconnectFlag((1));
N        if(CardReaderInit(TRUE) == FALSE)
X        if(CardReaderInit((1)) == (0))
N        //if(CardReaderInit(FALSE) == FALSE)
N        {
N            terninalPrintf("CardReaderInit FAIL\r\n");
N            return TEST_FALSE;
X            return 0x10;
N        }
N
N       // CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
N        
N        if(ReaderInterconnectResult())            
N            resultFlag1 = TRUE;
X            resultFlag1 = (1);
N        else
N            resultFlag1 = FALSE;
X            resultFlag1 = (0);
N        
N        
N        if(smartCardTest(para1,para2) == TEST_SUCCESSFUL_LIGHT_OFF)
X        if(smartCardTest(para1,para2) == 0x12)
N        {
N            terninalPrintf("smartCardTest success.\r\n");
N            resultFlag2 = TRUE;
X            resultFlag2 = (1);
N        }
N        else
N        {
N            terninalPrintf("smartCardTest error.\r\n");
N            resultFlag2 = FALSE;
X            resultFlag2 = (0);
N        }
N        
N        
N        if(sFlashTest(para1,para2) == TEST_SUCCESSFUL_LIGHT_OFF)
X        if(sFlashTest(para1,para2) == 0x12)
N        {
N            terninalPrintf("FlashTest success.\r\n");
N            resultFlag3 = TRUE;
X            resultFlag3 = (1);
N        }
N        else
N        {
N            terninalPrintf("FlashTest error.\r\n");
N            resultFlag3 = FALSE;
X            resultFlag3 = (0);
N        }
N        
N               
N        outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0x0<<16));
X        *((volatile unsigned int *)((0xB0000000+0x0B0))) = ((*((volatile unsigned int *)((0xB0000000+0x0B0)))) & ~(0xF<<16)) | (0x0<<16);
N        GPIO_OpenBit(GPIOI, BIT4, DIR_OUTPUT, NO_PULL_UP);
X        GPIO_OpenBit(GPIOI, (0x00000010), DIR_OUTPUT, NO_PULL_UP);
N        GPIO_ClrBit(GPIOI, BIT4);
X        GPIO_ClrBit(GPIOI, (0x00000010));
N        
W "src\user\hwtester.c" 5076 9 integer operation result is out of range
N        outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0x0<<28));
X        *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<28)) | (0x0<<28);
N        GPIO_OpenBit(GPIOI, BIT15, DIR_OUTPUT, NO_PULL_UP);
X        GPIO_OpenBit(GPIOI, (0x00008000), DIR_OUTPUT, NO_PULL_UP);
N        GPIO_ClrBit(GPIOI, BIT15);
X        GPIO_ClrBit(GPIOI, (0x00008000));
N        
N        outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<4)) | (0x0<<4));
X        *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xF<<4)) | (0x0<<4);
N        GPIO_OpenBit(GPIOG, BIT9, DIR_OUTPUT, NO_PULL_UP);
X        GPIO_OpenBit(GPIOG, (0x00000200), DIR_OUTPUT, NO_PULL_UP);
N        GPIO_ClrBit(GPIOG, BIT9);
X        GPIO_ClrBit(GPIOG, (0x00000200));
N        
N        terninalPrintf("Close Reader power.\r\n");
N        vTaskDelay(2000/portTICK_RATE_MS);
X        vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        terninalPrintf("Open ReaderBoardSpareIO1\r\n");
N        GPIO_SetBit(GPIOI, BIT4);
X        GPIO_SetBit(GPIOI, (0x00000010));
N        vTaskDelay(2000/portTICK_RATE_MS);
X        vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        
N        terninalPrintf("Open ReaderBoardSpareIO1\r\n");        
N        GPIO_SetBit(GPIOI, BIT15);
X        GPIO_SetBit(GPIOI, (0x00008000));
N        vTaskDelay(2000/portTICK_RATE_MS);
X        vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        
N        terninalPrintf("Open VD33Ctr\r\n");        
N        GPIO_SetBit(GPIOG, BIT9);
X        GPIO_SetBit(GPIOG, (0x00000200));
N
N
N        terninalPrintf("Does all LED lightup?(y/n)\n");
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            if(tempchar =='y')
N            {
N                resultFlag4 = TRUE;
X                resultFlag4 = (1);
N                break;
N            }                
N            else if(tempchar =='n')
N            {
N                resultFlag4 = FALSE;
X                resultFlag4 = (0);
N                break;
N            }                
N        }
N        
N        
N        if( resultFlag1 & resultFlag2 & resultFlag3 & resultFlag4 )
N            return TEST_SUCCESSFUL_LIGHT_OFF;
X            return 0x12;
N        else
N            return TEST_FALSE;
X            return 0x10;
N        
N        
N        
N        /*
N        if(ReaderInterconnectResult())            
N            return TEST_SUCCESSFUL_LIGHT_OFF;
N        else
N            return TEST_FALSE;
N        */
N    }
N    else
N    {
N        
N    
N        if(!GPIO_ReadBit(GPIOJ, BIT4))
X        if(!GPIO_ReadBit(GPIOJ, (0x00000010)))
N        {
N            
N            terninalPrintf("!!! readerTest !!!\r\n");
N            guiPrintResult("Reader Testing");
N            GuiManagerCleanMessage(GUI_OCTOPUS_SELECTTYPE_EN);
X            GuiManagerCleanMessage(0x15);
N            terninalPrintf("Please Select card type 3:test card  4:formal card\r\n");
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            guiPrintMessage("Please Select\ncard type\n+:test   card\n=:formal card");
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            while(1)
N            {
N                tempchar = userResponseLoop();
N                //if(tempchar =='1')
N                if(tempchar =='3')
N                {
N                    terninalPrintf("3\r\n");
N                    GuiManagerCleanMessage(GUI_OCTOPUS_SELECTTYPE_DE);
X                    GuiManagerCleanMessage(0x16);
N                    ChangeOctopusKey(OCTOPUS_USE_TEST_KEY);
X                    ChangeOctopusKey(0);
N                    break;
N                }
N                //else if(tempchar =='2')
N                else if(tempchar =='4')
N                {
N                    terninalPrintf("4\r\n");
N                    GuiManagerCleanMessage(GUI_OCTOPUS_SELECTTYPE_DE);
X                    GuiManagerCleanMessage(0x16);
N                    ChangeOctopusKey(OCTOPUS_USE_PRODUCTION_KEY);
X                    ChangeOctopusKey(1);
N                    break;
N                    //return TEST_FALSE;
N                }
N            }
N            
N            
N
N            if(CardReaderInit(FALSE) == FALSE)
X            if(CardReaderInit((0)) == (0))
N            {
N                terninalPrintf("CardReaderInit FAIL\r\n");
N            }
N            else
N            {
N                terninalPrintf("CardReaderInit success\r\n");
N            }
N            CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
X            CardReaderSetPower(0, (1));
N            
N            RTC_Read(RTC_CURRENT_TIME, &ot);
N            //time = GetCurrentUTCTime();
N            time = RTC2Time(&ot);
N            SetOSTime(2021,1,13,15,0,0,3);
N            time2 = GetCurrentUTCTime();
N            guiPrintResult("Reader Init");
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            while(CardReaderGetBootedStatus() != TSREADER_CHECK_READER_OK)
X            while(CardReaderGetBootedStatus() != 2)
N            {
N                terninalPrintf(".");
N                switch(i)
N                {
N                case 3:
N                    i=0;
N                    guiPrintMessage(" ");
N                    break;
N                case 0:
N                    guiPrintMessage(".");
N                    break;
N                case 1:
N                    guiPrintMessage("..");
N                    break;
N                case 2:
N                    guiPrintMessage("...");
N                    break;
N                }
N                i++;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                waitCounter--;
N                if(waitCounter == 0)
N                    break;
N            }
N            if(waitCounter == 0)
N            {
N                testErroCode = READER_CONNECT_ERRO;
X                testErroCode = 0x0901;
N                //terninalPrintf("\r\n  readerTest [ERROR]\r\n");
N                //EPDDrawString(TRUE,"FAIL                ",X_POS_RST,Y_POS_RST);
N                
N                time3 = GetCurrentUTCTime();
N                time += time3 - time2;
N                Time2RTC(time, &ot);
N                SetOSTime(ot.u32Year,ot.u32cMonth,ot.u32cDay,ot.u32cHour,ot.u32cMinute,0,ot.u32cDayOfWeek);
N                
N                return TEST_FALSE;
X                return 0x10;
N            }
N            cleanMsg();
N            
N
N            
N            
N            //guiPrintMessage("Please Tag Octopus Card\n");
N            guiPrintMessage("Please Tag\nor key = skip");
N            terninalPrintf("\nPlease tag Octopus Card\n");
N            
N            InitCardReaderHangUpStatus();
N            
N            fReaderCn = FALSE;
X            fReaderCn = (0);
N            int tempstatus;
N            tempstatus = CardReaderGetBootedStatus();
N            //while(CardReaderGetBootedStatus() == TSREADER_CHECK_READER_OK)
N            while(tempstatus == TSREADER_CHECK_READER_OK)
X            while(tempstatus == 2)
N            {
N                tempstatus = CardReaderGetBootedStatus();
N                CardReaderProcess(1, octopusDepositResultCallback);
N                if(fReaderCn)
N                    break;
N                tempchar = userResponse();
N                if(tempchar =='n')
N                {
N                    CardReaderSetPower(EPM_READER_CTRL_ID_GUI,FALSE);
X                    CardReaderSetPower(0,(0));
N                    
N                    time3 = GetCurrentUTCTime();
N                    time += time3 - time2;
N                    Time2RTC(time, &ot);
N                    SetOSTime(ot.u32Year,ot.u32cMonth,ot.u32cDay,ot.u32cHour,ot.u32cMinute,0,ot.u32cDayOfWeek);
N                    
N                    return TEST_FALSE;
X                    return 0x10;
N                }
N            }
N
N            //terninalPrintf("CardReaderGetBootedStatus() = %d \n",tempstatus);
N            CardReaderSetPower(EPM_READER_CTRL_ID_GUI,FALSE);
X            CardReaderSetPower(0,(0));
N            
N            time3 = GetCurrentUTCTime();
N            time += time3 - time2;
N            Time2RTC(time, &ot);
N            SetOSTime(ot.u32Year,ot.u32cMonth,ot.u32cDay,ot.u32cHour,ot.u32cMinute,0,ot.u32cDayOfWeek);
N            
N            if(tempstatus == TSREADER_CHECK_READER_ERROR)
X            if(tempstatus == 3)
N                return TEST_FALSE;
X                return 0x10;
N            else
N                return TEST_SUCCESSFUL_LIGHT_OFF;
X                return 0x12;
N            
N            
N        }
N        else
N        {
N        
N       
N            if(CardReaderInit(TRUE) == FALSE)
X            if(CardReaderInit((1)) == (0))
N            //if(CardReaderInit(FALSE) == FALSE)
N            {
N                terninalPrintf("CardReaderInit FAIL\r\n");
N            }
N            else
N            {
N                terninalPrintf("CardReaderInit success\r\n");
N            }
N            CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
X            CardReaderSetPower(0, (1));
N            terninalPrintf("!!! readerTest !!!\r\n");
N            guiPrintResult("Reader Testing");
N            guiPrintResult("Reader Init");
N            while(CardReaderGetBootedStatus() != TSREADER_CHECK_READER_OK)
X            while(CardReaderGetBootedStatus() != 2)
N            {
N                terninalPrintf(".");
N                switch(i)
N                {
N                case 3:
N                    i=0;
N                    guiPrintMessage(" ");
N                    break;
N                case 0:
N                    guiPrintMessage(".");
N                    break;
N                case 1:
N                    guiPrintMessage("..");
N                    break;
N                case 2:
N                    guiPrintMessage("...");
N                    break;
N                }
N                i++;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                waitCounter--;
N                if(waitCounter == 0)
N                    break;
N            }
N            if(waitCounter == 0)
N            {
N                testErroCode = READER_CONNECT_ERRO;
X                testErroCode = 0x0901;
N                //terninalPrintf("\r\n  readerTest [ERROR]\r\n");
N                //EPDDrawString(TRUE,"FAIL                ",X_POS_RST,Y_POS_RST);
N                return TEST_FALSE;
X                return 0x10;
N            }
N            cleanMsg();
N    #if(SUPPORT_HK_10_HW)
X    #if(1)
N    #else
S            guiPrintMessage("Please Tag Card\nor key = skip");
S            terninalPrintf("\nPlease tag card\n");
S            while(CardReaderGetBootedStatus() == TSREADER_CHECK_READER_OK)
S            {
S                CardReaderProcessCN(readerCNCallback);
S                if(fReaderCn)
S                    break;
S                tempchar = userResponseLoop();
S                if(tempchar =='n')
S                {
S                    return TEST_FALSE;
S                }
S            }
N    #endif
N            //CardReaderSetPower(EPM_READER_CTRL_ID_GUI,FALSE);
N            
N
N            return TEST_SUCCESSFUL_LIGHT_OFF;
X            return 0x12;
N        }
N    }
N        
W "src\user\hwtester.c" 5018 24 variable "pt" was declared but never referenced
N}
N
Nstatic BOOL ModemAndReaderTest(void* para1, void* para2)
N{
N    char SendModemStr[] = "Hello Modem";
N    char SendReaderStr[] = "Hi Reader";
N    char ModemReadBuf[20];
N    char ReaderReadBuf[20];
N    UartInterface* ModemUartInterface;
N    UartInterface* ReaderUartInterface;
N    ModemUartInterface  = UartGetInterface(UART_4_INTERFACE_INDEX);
X    ModemUartInterface  = UartGetInterface(3);
N    ReaderUartInterface = UartGetInterface(UART_2_INTERFACE_INDEX);
X    ReaderUartInterface = UartGetInterface(1);
N    ModemUartInterface->initFunc(115200);
N    ReaderUartInterface->initFunc(115200);
N    //ModemUartInterface->setPowerFunc(TRUE);
N    
N    uartIoctl(4, 25, 0, 0);  //UART1FlushBuffer , UARTA=4 , UART_IOC_FLUSH_RX_BUFFER=25 
N    uartIoctl(2, 25, 0, 0);  //UART1FlushBuffer , UARTA=2 , UART_IOC_FLUSH_RX_BUFFER=25 
N    
N    int index = 0;
N    int counter = 0;
N    INT32 reVal;
N
N    // Debug send message to CAD
N    //pUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
N    ReaderUartInterface->writeFunc((PUINT8)SendModemStr,sizeof(SendModemStr));
N    memset(ModemReadBuf, 0x0, sizeof(ModemReadBuf));
N    while(counter < 30)
N    {
N        /*
N        reVal = ReaderUartInterface->readFunc((PUINT8)ReaderReadBuf + index, sizeof(SendModemStr)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            
N            terninalPrintf("ReaderReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",ReaderReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((ReaderReadBuf[k] >= 0x20) && (ReaderReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",ReaderReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            
N        }
N        */
N
N        reVal = ModemUartInterface->readFunc((PUINT8)ModemReadBuf + index, sizeof(SendModemStr)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
X        vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            /*
N            terninalPrintf("ModemReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",ModemReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((ModemReadBuf[k] >= 0x20) && (ModemReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",ModemReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            */
N        }
N   
N        counter++;
N    }
N    
N    
N    index = 0;
N    counter = 0;
N
N    //ModemUartInterface->ioctlFunc(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
N    ModemUartInterface->writeFunc((PUINT8)SendReaderStr,sizeof(SendReaderStr));
N    memset(ReaderReadBuf, 0x0, sizeof(ReaderReadBuf));
N    while(counter < 30)
N    {
N        /*
N        reVal = ModemUartInterface->readFunc((PUINT8)ModemReadBuf + index, sizeof(SendReaderStr)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            
N            terninalPrintf("ModemReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",ModemReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((ModemReadBuf[k] >= 0x20) && (ModemReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",ModemReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            
N        }
N        */
N        
N        reVal = ReaderUartInterface->readFunc((PUINT8)ReaderReadBuf + index, sizeof(SendReaderStr)-index);
N        vTaskDelay(10/portTICK_RATE_MS);
X        vTaskDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(reVal > 0)
N        {
N            index = index + reVal;
N            /*
N            terninalPrintf("ReaderReceive<=");
N            for(int i=0;i<index;i++)
N                terninalPrintf("%02x ",ReaderReadBuf[i]);
N            terninalPrintf("\r\n");
N            
N            for(int k=0;k<index;k++)
N            {
N                if((ReaderReadBuf[k] >= 0x20) && (ReaderReadBuf[k] <= 0x7E))
N                    terninalPrintf("%c",ReaderReadBuf[k]);
N            } 
N            terninalPrintf("\r\n"); 
N            */
N        }
N        
N        counter++;
N    }
N    
N    
N    if( memcmp(ReaderReadBuf,SendReaderStr,sizeof(SendReaderStr)) == 0 )
N    {
N        terninalPrintf("Modem Tx & Reader Rx connect success.\r\n");
N        IOtestResultFlag[2] = TRUE;
X        IOtestResultFlag[2] = (1);
N        MTPString[27][7] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Modem Tx & Reader Rx connect error.\r\n");
N        IOtestResultFlag[2] = FALSE;
X        IOtestResultFlag[2] = (0);
N        MTPString[27][7] = 0x80;
N    }
N    
N    if( memcmp(ModemReadBuf,SendModemStr,sizeof(SendModemStr)) == 0 )
N    {
N        terninalPrintf("Modem Rx & Reader Tx connect success.\r\n");
N        IOtestResultFlag[3] = TRUE;
X        IOtestResultFlag[3] = (1);
N        MTPString[27][8] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Modem Rx & Reader Tx connect error.\r\n");
N        IOtestResultFlag[3] = FALSE;
X        IOtestResultFlag[3] = (0);
N        MTPString[27][8] = 0x80;
N    }
N    
N
N    
N    
N    
N    BOOL ReaderUR2VDPwCTLowModemRTSInFlag  = FALSE;
X    BOOL ReaderUR2VDPwCTLowModemRTSInFlag  = (0);
N    BOOL ReaderUR2VDPwCTHighModemRTSInFlag = FALSE;
X    BOOL ReaderUR2VDPwCTHighModemRTSInFlag = (0);
N    BOOL ReaderUR2VDPwCTInModemRTSLowFlag  = FALSE;
X    BOOL ReaderUR2VDPwCTInModemRTSLowFlag  = (0);
N    BOOL ReaderUR2VDPwCTInModemRTSHighFlag = FALSE;
X    BOOL ReaderUR2VDPwCTInModemRTSHighFlag = (0);
N
N    GPIO_CloseBit(GPIOF, BIT10);
X    GPIO_CloseBit(GPIOF, (0x00000400));
N    GPIO_CloseBit(GPIOH, BIT10);
X    GPIO_CloseBit(GPIOH, (0x00000400));
N   //Set ReaderUR2VDPwCT(PF10) and ModemRTS(PH10) GPIO
N    //Set ReaderUR2VDPwCT(PF10) output
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOF, BIT10, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOF, (0x00000400), DIR_OUTPUT, PULL_UP);
N    //Set ModemRTS(PH10) input
N    outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x0AC))) = ((*((volatile unsigned int *)((0xB0000000+0x0AC)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOH, BIT10, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOH, (0x00000400), DIR_INPUT, PULL_UP);
N    
N    //Set ReaderUR2VDPwCT(PF10) LOW
N    GPIO_ClrBit(GPIOF, BIT10);
X    GPIO_ClrBit(GPIOF, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOH, BIT10))
X    if(!GPIO_ReadBit(GPIOH, (0x00000400)))
N        ReaderUR2VDPwCTLowModemRTSInFlag  = TRUE;
X        ReaderUR2VDPwCTLowModemRTSInFlag  = (1);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTLowModemRTSInFlag success\r\n");
N    else
N        ReaderUR2VDPwCTLowModemRTSInFlag  = FALSE;
X        ReaderUR2VDPwCTLowModemRTSInFlag  = (0);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTLowModemRTSInFlag error.\r\n");
N    
N    //Set ReaderUR2VDPwCT(PF10) HIGH
N    GPIO_SetBit(GPIOF, BIT10);
X    GPIO_SetBit(GPIOF, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOH, BIT10))
X    if(GPIO_ReadBit(GPIOH, (0x00000400)))
N        ReaderUR2VDPwCTHighModemRTSInFlag = TRUE;
X        ReaderUR2VDPwCTHighModemRTSInFlag = (1);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTHighModemRTSInFlag success\r\n");
N    else
N        ReaderUR2VDPwCTHighModemRTSInFlag = FALSE;
X        ReaderUR2VDPwCTHighModemRTSInFlag = (0);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTHighModemRTSInFlag error.\r\n");
N    //GPIO_ClrBit(GPIOF, BIT14);
N    GPIO_CloseBit(GPIOF, BIT10);
X    GPIO_CloseBit(GPIOF, (0x00000400));
N    GPIO_CloseBit(GPIOH, BIT10);
X    GPIO_CloseBit(GPIOH, (0x00000400));
N    
N    
N    
N    //Set ReaderUR2VDPwCT(PF10) input
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOF, BIT10, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOF, (0x00000400), DIR_INPUT, PULL_UP);
N    //Set ModemRTS(PH10) output
N    outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x0AC))) = ((*((volatile unsigned int *)((0xB0000000+0x0AC)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOH, BIT10, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOH, (0x00000400), DIR_OUTPUT, PULL_UP);
N        
N    //Set ModemRTS(PH10) LOW
N    GPIO_ClrBit(GPIOH, BIT10);
X    GPIO_ClrBit(GPIOH, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOF, BIT10))
X    if(!GPIO_ReadBit(GPIOF, (0x00000400)))
N        ReaderUR2VDPwCTInModemRTSLowFlag  = TRUE;
X        ReaderUR2VDPwCTInModemRTSLowFlag  = (1);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTInModemRTSLowFlag success\r\n");
N    else
N        ReaderUR2VDPwCTInModemRTSLowFlag  = FALSE;
X        ReaderUR2VDPwCTInModemRTSLowFlag  = (0);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTInModemRTSLowFlag error.\r\n");
N    
N    
N    //Set ModemRTS(PH10) HIGH
N    GPIO_SetBit(GPIOH, BIT10);
X    GPIO_SetBit(GPIOH, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOF, BIT10))
X    if(GPIO_ReadBit(GPIOF, (0x00000400)))
N        ReaderUR2VDPwCTInModemRTSHighFlag = TRUE;
X        ReaderUR2VDPwCTInModemRTSHighFlag = (1);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTInModemRTSHighFlag success\r\n");
N    else
N        ReaderUR2VDPwCTInModemRTSHighFlag = FALSE;
X        ReaderUR2VDPwCTInModemRTSHighFlag = (0);
N        //terninalPrintf("Modem RTS & Reader UR2VDPwCT connect ReaderUR2VDPwCTInModemRTSHighFlag error.\r\n");
N    //GPIO_ClrBit(GPIOH, BIT10);
N    GPIO_CloseBit(GPIOF, BIT10);
X    GPIO_CloseBit(GPIOF, (0x00000400));
N    GPIO_CloseBit(GPIOH, BIT10);
X    GPIO_CloseBit(GPIOH, (0x00000400));
N
N    
N    if(ReaderUR2VDPwCTLowModemRTSInFlag && ReaderUR2VDPwCTHighModemRTSInFlag &&
N       ReaderUR2VDPwCTInModemRTSLowFlag && ReaderUR2VDPwCTInModemRTSHighFlag)
N    {
N        terninalPrintf("Modem RTS & Reader UR2VDPwCT connect success\r\n");
N        IOtestResultFlag[4] = TRUE;
X        IOtestResultFlag[4] = (1);
N        MTPString[27][9] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Modem RTS & Reader UR2VDPwCT connect error.\r\n");
N        IOtestResultFlag[4] = FALSE;
X        IOtestResultFlag[4] = (0);
N        MTPString[27][9] = 0x80;
N    }
N    
N    
N    return TEST_SUCCESSFUL_LIGHT_OFF;
X    return 0x12;
N}
N
NINT32 EINT4Callback(UINT32 status, UINT32 userData)
N{
N    
N    //terninalPrintf("\r\nMODEM GPIOH4 interrupt.\r\n"); 
N    ModemGPIOH4INTFlag = TRUE;
X    ModemGPIOH4INTFlag = (1);
N    GPIO_ClrISRBit(GPIOH, BIT4);
X    GPIO_ClrISRBit(GPIOH, (0x00000010));
N    return 0;
N}
N
Nstatic BOOL otherIOTest(void* para1, void* para2)
N{
N    BOOL rightResultFlag[sizeof(IOtestResultFlag)];
N    
N    
N    memset(rightResultFlag,TRUE,sizeof(rightResultFlag));
X    memset(rightResultFlag,(1),sizeof(rightResultFlag));
N    
N    memset(IOtestResultFlag,FALSE,sizeof(IOtestResultFlag));
X    memset(IOtestResultFlag,(0),sizeof(IOtestResultFlag));
N    
N    sFlashTest(para1, para2);
N    
N    smartCardTest(para1, para2);
N    
N    //CADSingleTest(para1, para2);
N    
N    ModemAndReaderTest(para1, para2);
N    
N    //radarSingleTest(para1, para2);
N    
N    //-------------Modem INT & RST connect----------------------------
N    //Set ReaderIO1(PG8) output
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<0)) | (0x0<<0));
X    *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xF<<0)) | (0x0<<0);
N    GPIO_OpenBit(GPIOG, BIT8, DIR_OUTPUT, PULL_UP); 
X    GPIO_OpenBit(GPIOG, (0x00000100), DIR_OUTPUT, PULL_UP); 
N    GPIO_ClrBit(GPIOG, BIT8);
X    GPIO_ClrBit(GPIOG, (0x00000100));
N    //userResponseLoop();
N    
N    ModemGPIOH4INTFlag = FALSE;
X    ModemGPIOH4INTFlag = (0);
N    // Set PH4 to EINT4 
N    outpw(REG_SYS_GPH_MFPL,(inpw(REG_SYS_GPH_MFPL) & ~(0xF<<16)) | (0xF<<16));    
X    *((volatile unsigned int *)((0xB0000000+0x0A8))) = ((*((volatile unsigned int *)((0xB0000000+0x0A8)))) & ~(0xF<<16)) | (0xF<<16);    
N    // Configure PH4 to input mode 
N    GPIO_OpenBit(GPIOH, BIT4, DIR_INPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOH, (0x00000010), DIR_INPUT, NO_PULL_UP);
N    // Confingure PH4 to both-edge trigger 
N    GPIO_ClrISRBit(GPIOH, BIT4);
X    GPIO_ClrISRBit(GPIOH, (0x00000010));
N    GPIO_EnableTriggerType(GPIOH, BIT4, RISING);
X    GPIO_EnableTriggerType(GPIOH, (0x00000010), RISING);
N    //EINT5
N    GPIO_EnableEINT(NIRQ4, (GPIO_CALLBACK)EINT4Callback, 0); 
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    GPIO_SetBit(GPIOG, BIT8);
X    GPIO_SetBit(GPIOG, (0x00000100));
N    //userResponseLoop();
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    GPIO_DisableEINT(NIRQ4);
N    
N    if(ModemGPIOH4INTFlag)
N    {
N        terninalPrintf("Modem INT & RST connect success\r\n");
N        IOtestResultFlag[9] = TRUE;
X        IOtestResultFlag[9] = (1);
N        MTPString[27][10] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Modem INT & RST connect error.\r\n");
N        IOtestResultFlag[9] = FALSE;
X        IOtestResultFlag[9] = (0);
N        MTPString[27][10] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    //---------------------------end------------------------------
N    
N    
N    //-------------Reader IO1 & Reader RTS connect----------------------------
N    
N    
N    BOOL ReaderRTSLowReaderIO1InFlag  = FALSE;
X    BOOL ReaderRTSLowReaderIO1InFlag  = (0);
N    BOOL ReaderRTSHighReaderIO1InFlag = FALSE;
X    BOOL ReaderRTSHighReaderIO1InFlag = (0);
N    BOOL ReaderRTSInReaderIO1LowFlag  = FALSE;
X    BOOL ReaderRTSInReaderIO1LowFlag  = (0);
N    BOOL ReaderRTSInReaderIO1HighFlag = FALSE;
X    BOOL ReaderRTSInReaderIO1HighFlag = (0);
N
N    
N    //Set ReaderRTS(PF13) and ReaderIO1(PI4) GPIO
N    //Set ReaderRTS(PF13) output
N    GPIO_CloseBit(GPIOF, BIT13);
X    GPIO_CloseBit(GPIOF, (0x00002000));
N    GPIO_CloseBit(GPIOI, BIT4);
X    GPIO_CloseBit(GPIOI, (0x00000010));
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<<20)) | (0<<20);
N    GPIO_OpenBit(GPIOF, BIT13, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOF, (0x00002000), DIR_OUTPUT, PULL_UP);
N    //Set ReaderIO1(PI4) input
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x0B0))) = ((*((volatile unsigned int *)((0xB0000000+0x0B0)))) & ~(0xF<<16)) | (0<<16);
N    GPIO_OpenBit(GPIOI, BIT4, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00000010), DIR_INPUT, PULL_UP);
N    
N    //Set ReaderRTS(PF13) LOW
N    GPIO_ClrBit(GPIOF, BIT13);
X    GPIO_ClrBit(GPIOF, (0x00002000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOI, BIT4))
X    if(!GPIO_ReadBit(GPIOI, (0x00000010)))
N        ReaderRTSLowReaderIO1InFlag  = TRUE;
X        ReaderRTSLowReaderIO1InFlag  = (1);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSLowReaderIO1InFlag success\r\n");
N    else
N        ReaderRTSLowReaderIO1InFlag  = FALSE;
X        ReaderRTSLowReaderIO1InFlag  = (0);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSLowReaderIO1InFlag error.\r\n");
N    
N    //Set ReaderRTS(PF13) HIGH
N    GPIO_SetBit(GPIOF, BIT13);
X    GPIO_SetBit(GPIOF, (0x00002000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOI, BIT4))
X    if(GPIO_ReadBit(GPIOI, (0x00000010)))
N        ReaderRTSHighReaderIO1InFlag = TRUE;
X        ReaderRTSHighReaderIO1InFlag = (1);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSHighReaderIO1InFlag success\r\n");
N    else
N        ReaderRTSHighReaderIO1InFlag = FALSE;
X        ReaderRTSHighReaderIO1InFlag = (0);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSHighReaderIO1InFlag error.\r\n");
N    GPIO_CloseBit(GPIOF, BIT13);
X    GPIO_CloseBit(GPIOF, (0x00002000));
N    GPIO_CloseBit(GPIOI, BIT4);
X    GPIO_CloseBit(GPIOI, (0x00000010));
N    
N    
N    
N    //Set ReaderRTS(PF13) input
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<<20)) | (0<<20);
N    GPIO_OpenBit(GPIOF, BIT13, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOF, (0x00002000), DIR_INPUT, PULL_UP);
N    //Set ReaderIO1(PI4) output
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x0B0))) = ((*((volatile unsigned int *)((0xB0000000+0x0B0)))) & ~(0xF<<16)) | (0<<16);
N    GPIO_OpenBit(GPIOI, BIT4, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00000010), DIR_OUTPUT, PULL_UP);
N        
N    //Set ReaderIO1(PI4) LOW
N    GPIO_ClrBit(GPIOI, BIT4);
X    GPIO_ClrBit(GPIOI, (0x00000010));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOF, BIT13))
X    if(!GPIO_ReadBit(GPIOF, (0x00002000)))
N        ReaderRTSInReaderIO1LowFlag  = TRUE;
X        ReaderRTSInReaderIO1LowFlag  = (1);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSInReaderIO1LowFlag success\r\n");
N    else
N        ReaderRTSInReaderIO1LowFlag  = FALSE;
X        ReaderRTSInReaderIO1LowFlag  = (0);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSInReaderIO1LowFlag error.\r\n");
N    
N    
N    //Set ReaderIO1(PI4) HIGH
N    GPIO_SetBit(GPIOI, BIT4);
X    GPIO_SetBit(GPIOI, (0x00000010));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOF, BIT13))
X    if(GPIO_ReadBit(GPIOF, (0x00002000)))
N        ReaderRTSInReaderIO1HighFlag = TRUE;
X        ReaderRTSInReaderIO1HighFlag = (1);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSInReaderIO1HighFlag success\r\n");
N    else
N        ReaderRTSInReaderIO1HighFlag = FALSE;
X        ReaderRTSInReaderIO1HighFlag = (0);
N        //terninalPrintf("Reader IO1 & Reader RTS connect ReaderRTSInReaderIO1HighFlag error.\r\n");
N    GPIO_CloseBit(GPIOF, BIT13);
X    GPIO_CloseBit(GPIOF, (0x00002000));
N    GPIO_CloseBit(GPIOI, BIT4);
X    GPIO_CloseBit(GPIOI, (0x00000010));
N
N    
N    if(ReaderRTSLowReaderIO1InFlag && ReaderRTSHighReaderIO1InFlag &&
N       ReaderRTSInReaderIO1LowFlag && ReaderRTSInReaderIO1HighFlag)
N    {
N        terninalPrintf("Reader IO1 & Reader RTS connect success\r\n");
N        IOtestResultFlag[10] = TRUE;
X        IOtestResultFlag[10] = (1);
N        MTPString[27][11] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Reader IO1 & Reader RTS connect error.\r\n");
N        IOtestResultFlag[10] = FALSE;
X        IOtestResultFlag[10] = (0);
N        MTPString[27][11] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    
N    
N    //---------------------------end------------------------------
N    
N    
N    
N    //-------------Reader VD33PwCT & Reader IO2 connect----------------------------
N    
N    
N    BOOL ReaderIO2LowReaderVD33PwCTInFlag  = FALSE;
X    BOOL ReaderIO2LowReaderVD33PwCTInFlag  = (0);
N    BOOL ReaderIO2HighReaderVD33PwCTInFlag = FALSE;
X    BOOL ReaderIO2HighReaderVD33PwCTInFlag = (0);
N    BOOL ReaderIO2InReaderVD33PwCTLowFlag  = FALSE;
X    BOOL ReaderIO2InReaderVD33PwCTLowFlag  = (0);
N    BOOL ReaderIO2InReaderVD33PwCTHighFlag = FALSE;
X    BOOL ReaderIO2InReaderVD33PwCTHighFlag = (0);
N
N    
N    GPIO_CloseBit(GPIOI, BIT15);
X    GPIO_CloseBit(GPIOI, (0x00008000));
N    GPIO_CloseBit(GPIOG, BIT9);
X    GPIO_CloseBit(GPIOG, (0x00000200));
N    //Set ReaderIO2(PI15) and ReaderVD33PwCT(PG9) GPIO
N    //Set ReaderIO2(PI15) output
W "src\user\hwtester.c" 5777 5 integer operation result is out of range
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0<<28));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<28)) | (0<<28);
N    GPIO_OpenBit(GPIOI, BIT15, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00008000), DIR_OUTPUT, PULL_UP);
N    //Set ReaderVD33PwCT(PG9) input
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<< 4)) | (0<< 4));
X    *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xF<< 4)) | (0<< 4);
N    GPIO_OpenBit(GPIOG, BIT9, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOG, (0x00000200), DIR_INPUT, PULL_UP);
N    
N    //Set ReaderIO2(PI15) LOW
N    GPIO_ClrBit(GPIOI, BIT15);
X    GPIO_ClrBit(GPIOI, (0x00008000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOG, BIT9))
X    if(!GPIO_ReadBit(GPIOG, (0x00000200)))
N        ReaderIO2LowReaderVD33PwCTInFlag  = TRUE;
X        ReaderIO2LowReaderVD33PwCTInFlag  = (1);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2LowReaderVD33PwCTInFlag success\r\n");
N    else
N        ReaderIO2LowReaderVD33PwCTInFlag  = FALSE;
X        ReaderIO2LowReaderVD33PwCTInFlag  = (0);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2LowReaderVD33PwCTInFlag error.\r\n");
N    
N    //Set ReaderIO2(PI15) HIGH
N    GPIO_SetBit(GPIOI, BIT15);
X    GPIO_SetBit(GPIOI, (0x00008000));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOG, BIT9))
X    if(GPIO_ReadBit(GPIOG, (0x00000200)))
N        ReaderIO2HighReaderVD33PwCTInFlag = TRUE;
X        ReaderIO2HighReaderVD33PwCTInFlag = (1);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2HighReaderVD33PwCTInFlag success\r\n");
N    else
N        ReaderIO2HighReaderVD33PwCTInFlag = FALSE;
X        ReaderIO2HighReaderVD33PwCTInFlag = (0);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2HighReaderVD33PwCTInFlag error.\r\n");
N    GPIO_CloseBit(GPIOI, BIT15);
X    GPIO_CloseBit(GPIOI, (0x00008000));
N    GPIO_CloseBit(GPIOG, BIT9);
X    GPIO_CloseBit(GPIOG, (0x00000200));
N    
N    
N    
N    //Set ReaderIO2(PI15) input
W "src\user\hwtester.c" 5810 5 integer operation result is out of range
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0<<28));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<28)) | (0<<28);
N    GPIO_OpenBit(GPIOI, BIT15, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00008000), DIR_INPUT, PULL_UP);
N    //Set ReaderVD33PwCT(PG9) output
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<< 4)) | (0<< 4));
X    *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xF<< 4)) | (0<< 4);
N    GPIO_OpenBit(GPIOG, BIT9, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOG, (0x00000200), DIR_OUTPUT, PULL_UP);
N        
N    //Set ReaderVD33PwCT(PG9) LOW
N    GPIO_ClrBit(GPIOG, BIT9);
X    GPIO_ClrBit(GPIOG, (0x00000200));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOI, BIT15))
X    if(!GPIO_ReadBit(GPIOI, (0x00008000)))
N        ReaderIO2InReaderVD33PwCTLowFlag  = TRUE;
X        ReaderIO2InReaderVD33PwCTLowFlag  = (1);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2InReaderVD33PwCTLowFlag success\r\n");
N    else
N        ReaderIO2InReaderVD33PwCTLowFlag  = FALSE;
X        ReaderIO2InReaderVD33PwCTLowFlag  = (0);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2InReaderVD33PwCTLowFlag error.\r\n");
N    
N    
N    //Set ReaderVD33PwCT(PG9) HIGH
N    GPIO_SetBit(GPIOG, BIT9);
X    GPIO_SetBit(GPIOG, (0x00000200));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOI, BIT15))
X    if(GPIO_ReadBit(GPIOI, (0x00008000)))
N        ReaderIO2InReaderVD33PwCTHighFlag = TRUE;
X        ReaderIO2InReaderVD33PwCTHighFlag = (1);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2InReaderVD33PwCTHighFlag success\r\n");
N    else
N        ReaderIO2InReaderVD33PwCTHighFlag = FALSE;
X        ReaderIO2InReaderVD33PwCTHighFlag = (0);
N        //terninalPrintf("Reader VD33PwCT & Reader IO2 connect ReaderIO2InReaderVD33PwCTHighFlag error.\r\n");
N    GPIO_CloseBit(GPIOI, BIT15);
X    GPIO_CloseBit(GPIOI, (0x00008000));
N    GPIO_CloseBit(GPIOG, BIT9);
X    GPIO_CloseBit(GPIOG, (0x00000200));
N
N    
N    if(ReaderIO2LowReaderVD33PwCTInFlag && ReaderIO2HighReaderVD33PwCTInFlag &&
N       ReaderIO2InReaderVD33PwCTLowFlag && ReaderIO2InReaderVD33PwCTHighFlag)
N    {
N        terninalPrintf("Reader VD33PwCT & Reader IO2 connect success\r\n");
N        IOtestResultFlag[11] = TRUE;
X        IOtestResultFlag[11] = (1);
N        MTPString[27][12] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Reader VD33PwCT & Reader IO2 connect error.\r\n");
N        IOtestResultFlag[11] = FALSE;
X        IOtestResultFlag[11] = (0);
N        MTPString[27][12] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    
N    
N    //---------------------------end------------------------------
N    
N    
N    //-------------Sensor SnrSwVD33 & Reader CTS connect----------------------------
N    
N    BOOL ReaderCTSLowSensorSnrSwVD33InFlag  = FALSE;
X    BOOL ReaderCTSLowSensorSnrSwVD33InFlag  = (0);
N    BOOL ReaderCTSHighSensorSnrSwVD33InFlag = FALSE;
X    BOOL ReaderCTSHighSensorSnrSwVD33InFlag = (0);
N    BOOL ReaderCTSInSensorSnrSwVD33LowFlag  = FALSE;
X    BOOL ReaderCTSInSensorSnrSwVD33LowFlag  = (0);
N    BOOL ReaderCTSInSensorSnrSwVD33HighFlag = FALSE;
X    BOOL ReaderCTSInSensorSnrSwVD33HighFlag = (0);
N
N    /*
N    GPIO_CloseBit(GPIOF, BIT14);
N    GPIO_CloseBit(GPIOB, BIT6);
N   //Set ReaderCTS(PF14) and SensorSnrSwVD33(PB6) GPIO
N    //Set ReaderCTS(PF14) output
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0<<24));
N    GPIO_OpenBit(GPIOF, BIT14, DIR_OUTPUT, PULL_UP);
N    //Set SensorSnrSwVD33(PB6) input
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<24)) | (0<<24));
N    GPIO_OpenBit(GPIOB, BIT6, DIR_INPUT, PULL_UP);
N    
N    //Set ReaderCTS(PF14) LOW
N    GPIO_ClrBit(GPIOF, BIT14);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT6))
N        ReaderCTSLowSensorSnrSwVD33InFlag  = TRUE;
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSLowSensorSnrSwVD33InFlag success\r\n");
N    else
N        ReaderCTSLowSensorSnrSwVD33InFlag  = FALSE;
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSLowSensorSnrSwVD33InFlag error.\r\n");
N    
N    //Set ReaderCTS(PF14) HIGH
N    GPIO_SetBit(GPIOF, BIT14);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT6))
N        ReaderCTSHighSensorSnrSwVD33InFlag = TRUE;
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSHighSensorSnrSwVD33InFlag success\r\n");
N    else
N        ReaderCTSHighSensorSnrSwVD33InFlag = FALSE;
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSHighSensorSnrSwVD33InFlag error.\r\n");
N    //GPIO_ClrBit(GPIOF, BIT14);
N    */
N    
N    GPIO_CloseBit(GPIOF, BIT14);
X    GPIO_CloseBit(GPIOF, (0x00004000));
N    GPIO_CloseBit(GPIOB, BIT6);
X    GPIO_CloseBit(GPIOB, (0x00000040));
N    
N    
N    
N    //Set ReaderCTS(PF14) input
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<<24)) | (0<<24);
N    GPIO_OpenBit(GPIOF, BIT14, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOF, (0x00004000), DIR_INPUT, PULL_UP);
N    //Set SensorSnrSwVD33(PB6) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<24)) | (0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<24)) | (0<<24);
N    GPIO_OpenBit(GPIOB, BIT6, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000040), DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorSnrSwVD33(PB6) LOW
N    GPIO_ClrBit(GPIOB, BIT6);
X    GPIO_ClrBit(GPIOB, (0x00000040));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    //if(!GPIO_ReadBit(GPIOF, BIT14))
N    if(GPIO_ReadBit(GPIOF, BIT14))
X    if(GPIO_ReadBit(GPIOF, (0x00004000)))
N    {
N        ReaderCTSInSensorSnrSwVD33LowFlag  = TRUE;
X        ReaderCTSInSensorSnrSwVD33LowFlag  = (1);
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSInSensorSnrSwVD33LowFlag success\r\n");
N    }
N    else
N    {
N        ReaderCTSInSensorSnrSwVD33LowFlag  = FALSE;
X        ReaderCTSInSensorSnrSwVD33LowFlag  = (0);
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSInSensorSnrSwVD33LowFlag error.\r\n");
N    }
N    
N    
N    //Set SensorSnrSwVD33(PB6) HIGH
N    GPIO_SetBit(GPIOB, BIT6);
X    GPIO_SetBit(GPIOB, (0x00000040));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    //if(GPIO_ReadBit(GPIOF, BIT14))
N    if(!GPIO_ReadBit(GPIOF, BIT14))
X    if(!GPIO_ReadBit(GPIOF, (0x00004000)))
N    {
N        ReaderCTSInSensorSnrSwVD33HighFlag = TRUE;
X        ReaderCTSInSensorSnrSwVD33HighFlag = (1);
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSInSensorSnrSwVD33HighFlag success\r\n");
N    }
N    else
N    {
N        ReaderCTSInSensorSnrSwVD33HighFlag = FALSE;
X        ReaderCTSInSensorSnrSwVD33HighFlag = (0);
N        //terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect ReaderCTSInSensorSnrSwVD33HighFlag error.\r\n");
N    }
N    //GPIO_ClrBit(GPIOH, BIT10);
N    GPIO_CloseBit(GPIOF, BIT14);
X    GPIO_CloseBit(GPIOF, (0x00004000));
N    GPIO_CloseBit(GPIOB, BIT6);
X    GPIO_CloseBit(GPIOB, (0x00000040));
N
N    //Sensor board DC5V GPB6
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<24)) | (0x0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<24)) | (0x0<<24);
N    GPIO_OpenBit(GPIOB, BIT6, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000040), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOB, BIT6);  
X    GPIO_SetBit(GPIOB, (0x00000040));  
N    
N    vTaskDelay(500/portTICK_RATE_MS);
X    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(//ReaderCTSLowSensorSnrSwVD33InFlag && ReaderCTSHighSensorSnrSwVD33InFlag &&
N       ReaderCTSInSensorSnrSwVD33LowFlag && ReaderCTSInSensorSnrSwVD33HighFlag)
N    {
N        terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect success\r\n");
N        IOtestResultFlag[12] = TRUE;
X        IOtestResultFlag[12] = (1);
N        MTPString[27][13] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Sensor SnrSwVD33 & Reader CTS connect error.\r\n");
N        IOtestResultFlag[12] = FALSE;
X        IOtestResultFlag[12] = (0);
N        MTPString[27][13] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    //---------------------------end------------------------------
N
N    
N    //-----------------------LED D5 test--------------------------
N    
N    BOOL LEDtestFlag = FALSE;
X    BOOL LEDtestFlag = (0);
N    char tempchar;
N    LEDColorBuffSet(0x10, 0x00);
N    LEDBoardLightSet();
N    SetMTPCRC(28,(uint8_t*)MTPString);
N    MTPCmdprint(28,(uint8_t*)MTPString);
N    terninalPrintf("Is the D5 light signal correct?(y/n)\r\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            terninalPrintf("Reader SysPwr test success.\r\n");
N            LEDtestFlag = TRUE;
X            LEDtestFlag = (1);
N            MTPString[27][14] = 0x81;
N            break;
N        }
N        else if(tempchar =='n')
N        {
N            terninalPrintf("Reader SysPwr test error.\r\n");
N            LEDtestFlag = FALSE;
X            LEDtestFlag = (0);
N            MTPString[27][14] = 0x80;
N            return FALSE;
X            return (0);
W "src\user\hwtester.c" 6001 13 statement is unreachable
N            break;
N        }
N    }
N    LEDColorBuffSet(0x00, 0x00);
N    LEDBoardLightSet();
N
N    //---------------------------end------------------------------
N    
N    
N    
N    if( IOtestResultFlag[2]  &&     //  Modem Tx & Reader Rx connect test result
N        IOtestResultFlag[3]  &&     //  Modem Rx & Reader Tx connect test result
N        IOtestResultFlag[4]  &&     //  Modem RTS & Reader UR2VDPwCT connect test result
N        IOtestResultFlag[9]  &&     //  Modem INT & RST connect test result
N        IOtestResultFlag[10] &&     //  Reader IO1 & Reader RTS connect test result
N        IOtestResultFlag[11] &&     //  Reader VD33PwCT & Reader IO2 connect test result
N        IOtestResultFlag[12] &&     //  Sensor SnrSwVD33 & Reader CTS connect test result
N        IOtestResultFlag[13] &&     //  Flash1 test result
N        IOtestResultFlag[14] &&     //  Flash2 test result
N        IOtestResultFlag[15] &&     //  Flash3 test result
N        IOtestResultFlag[16] &&     //  smartCard test result 
N        LEDtestFlag             )   //  SysPwr test result
N    {
N        MTPString[27][15] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N    else
N    {
N        MTPString[27][15] = 0x80;
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE; 
X            return 0x10; 
N    }
N    
N    
N    //-------------Sensor UR3PwrCT & Reader UR33PwrCT connect----------------------------
N    /*
N    
N    BOOL ReaderUR33PwrCTLowSensorUR3PwrCTInFlag  = FALSE;
N    BOOL ReaderUR33PwrCTHighSensorUR3PwrCTInFlag = FALSE;
N    BOOL ReaderUR33PwrCTInSensorUR3PwrCTLowFlag  = FALSE;
N    BOOL ReaderUR33PwrCTInSensorUR3PwrCTHighFlag = FALSE;
N
N    
N    //Set ReaderUR33PwrCT(PG9) and SensorUR3PwrCT(PE11) GPIO
N    //Set ReaderUR33PwrCT(PG9) output
N    GPIO_CloseBit(GPIOG, BIT9);
N    GPIO_CloseBit(GPIOE, BIT11);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<4)) | (0<<4));
N    GPIO_OpenBit(GPIOG, BIT9, DIR_OUTPUT, PULL_UP);
N    //Set SensorUR3PwrCT(PE11) input
N    outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<< 12)) | (0<< 12));
N    GPIO_OpenBit(GPIOE, BIT11, DIR_INPUT, PULL_UP);
N    
N    //Set ReaderUR33PwrCT(PG9) LOW
N    GPIO_ClrBit(GPIOG, BIT9);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOE, BIT11))
N        ReaderUR33PwrCTLowSensorUR3PwrCTInFlag  = TRUE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTLowSensorUR3PwrCTInFlag success\r\n");
N    else
N        ReaderUR33PwrCTLowSensorUR3PwrCTInFlag  = FALSE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTLowSensorUR3PwrCTInFlag error.\r\n");
N    
N    //Set ReaderUR33PwrCT(PG9) HIGH
N    GPIO_SetBit(GPIOG, BIT9);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOE, BIT11))
N        ReaderUR33PwrCTHighSensorUR3PwrCTInFlag = TRUE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTHighSensorUR3PwrCTInFlag success\r\n");
N    else
N        ReaderUR33PwrCTHighSensorUR3PwrCTInFlag = FALSE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTHighSensorUR3PwrCTInFlag error.\r\n");
N    GPIO_CloseBit(GPIOE, BIT11);
N    GPIO_CloseBit(GPIOG, BIT9);
N    
N    
N    
N    //Set ReaderUR33PwrCT(PG9) input
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<4)) | (0<<4));
N    GPIO_OpenBit(GPIOG, BIT9, DIR_INPUT, PULL_UP);
N    //Set SensorUR3PwrCT(PE11) output
N    outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<< 12)) | (0<< 12));
N    GPIO_OpenBit(GPIOE, BIT11, DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorUR3PwrCT(PE11) LOW
N    GPIO_ClrBit(GPIOE, BIT11);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOG, BIT9))
N        ReaderUR33PwrCTInSensorUR3PwrCTLowFlag  = TRUE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTInSensorUR3PwrCTLowFlag success\r\n");
N    else
N        ReaderUR33PwrCTInSensorUR3PwrCTLowFlag  = FALSE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTInSensorUR3PwrCTLowFlag error.\r\n");
N    
N    
N    //Set SensorUR3PwrCT(PE11) HIGH
N    GPIO_SetBit(GPIOE, BIT11);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOG, BIT9))
N        ReaderUR33PwrCTInSensorUR3PwrCTHighFlag = TRUE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTInSensorUR3PwrCTHighFlag success\r\n");
N    else
N        ReaderUR33PwrCTInSensorUR3PwrCTHighFlag = FALSE;
N        //terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect ReaderUR33PwrCTInSensorUR3PwrCTHighFlag error.\r\n");
N    GPIO_CloseBit(GPIOE, BIT11);
N    GPIO_CloseBit(GPIOG, BIT9);
N
N    
N    if(ReaderUR33PwrCTLowSensorUR3PwrCTInFlag && ReaderUR33PwrCTHighSensorUR3PwrCTInFlag &&
N       ReaderUR33PwrCTInSensorUR3PwrCTLowFlag && ReaderUR33PwrCTInSensorUR3PwrCTHighFlag)
N    {
N        terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect success\r\n");
N        IOtestResultFlag[11] = TRUE;
N    }
N    else
N    {
N        terninalPrintf("Sensor UR3PwrCT & Reader UR33PwrCT connect error.\r\n");
N        IOtestResultFlag[11] = FALSE;
N    }
N    
N    
N    */
N    //---------------------------end------------------------------
N    
N    
N    //-------------Sensor UR7PwrCT & Reader RTS connect----------------------------
N    /*
N    
N    BOOL ReaderRTSLowSensorUR7PwrCTInFlag  = FALSE;
N    BOOL ReaderRTSHighSensorUR7PwrCTInFlag = FALSE;
N    BOOL ReaderRTSInSensorUR7PwrCTLowFlag  = FALSE;
N    BOOL ReaderRTSInSensorUR7PwrCTHighFlag = FALSE;
N
N    
N    //Set ReaderRTS(PF13) and SensorUR7PwrCT(PB10) GPIO
N    //Set ReaderRTS(PF13) output
N    GPIO_CloseBit(GPIOF, BIT13);
N    GPIO_CloseBit(GPIOB, BIT10);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20));
N    GPIO_OpenBit(GPIOF, BIT13, DIR_OUTPUT, PULL_UP);
N    //Set SensorUR7PwrCT(PB10) input
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 8)) | (0<< 8));
N    GPIO_OpenBit(GPIOB, BIT10, DIR_INPUT, PULL_UP);
N    
N    //Set ReaderRTS(PF13) LOW
N    GPIO_ClrBit(GPIOF, BIT13);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT10))
N        ReaderRTSLowSensorUR7PwrCTInFlag  = TRUE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSLowSensorUR7PwrCTInFlag success\r\n");
N    else
N        ReaderRTSLowSensorUR7PwrCTInFlag  = FALSE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSLowSensorUR7PwrCTInFlag error.\r\n");
N    
N    //Set ReaderRTS(PF13) HIGH
N    GPIO_SetBit(GPIOF, BIT13);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT10))
N        ReaderRTSHighSensorUR7PwrCTInFlag = TRUE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSHighSensorUR7PwrCTInFlag success\r\n");
N    else
N        ReaderRTSHighSensorUR7PwrCTInFlag = FALSE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSHighSensorUR7PwrCTInFlag error.\r\n");
N    GPIO_CloseBit(GPIOF, BIT13);
N    GPIO_CloseBit(GPIOB, BIT10);
N    
N    
N    
N    //Set ReaderRTS(PF13) input
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20));
N    GPIO_OpenBit(GPIOF, BIT13, DIR_INPUT, PULL_UP);
N    //Set SensorUR7PwrCT(PB10) output
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 8)) | (0<< 8));
N    GPIO_OpenBit(GPIOB, BIT10, DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorUR7PwrCT(PB10) LOW
N    GPIO_ClrBit(GPIOB, BIT10);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOF, BIT13))
N        ReaderRTSInSensorUR7PwrCTLowFlag  = TRUE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSInSensorUR7PwrCTLowFlag success\r\n");
N    else
N        ReaderRTSInSensorUR7PwrCTLowFlag  = FALSE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSInSensorUR7PwrCTLowFlag error.\r\n");
N    
N    
N    //Set SensorUR7PwrCT(PB10) HIGH
N    GPIO_SetBit(GPIOB, BIT10);
N    vTaskDelay(100/portTICK_RATE_MS);
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOF, BIT13))
N        ReaderRTSInSensorUR7PwrCTHighFlag = TRUE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSInSensorUR7PwrCTHighFlag success\r\n");
N    else
N        ReaderRTSInSensorUR7PwrCTHighFlag = FALSE;
N        //terninalPrintf("Sensor UR7PwrCT & Reader RTS connect ReaderRTSInSensorUR7PwrCTHighFlag error.\r\n");
N    GPIO_CloseBit(GPIOF, BIT13);
N    GPIO_CloseBit(GPIOB, BIT10);
N
N    
N    if(ReaderRTSLowSensorUR7PwrCTInFlag && ReaderRTSHighSensorUR7PwrCTInFlag &&
N       ReaderRTSInSensorUR7PwrCTLowFlag && ReaderRTSInSensorUR7PwrCTHighFlag)
N    {
N        terninalPrintf("Sensor UR7PwrCT & Reader RTS connect success\r\n");
N        IOtestResultFlag[12] = TRUE;
N    }
N    else
N    {
N        terninalPrintf("Sensor UR7PwrCT & Reader RTS connect error.\r\n");
N        IOtestResultFlag[12] = FALSE;
N    }
N    
N    
N    */
N    //---------------------------end------------------------------
N    /*
N    if(memcmp(IOtestResultFlag,rightResultFlag,sizeof(IOtestResultFlag)) == 0 )    
N        return TEST_SUCCESSFUL_LIGHT_OFF;
N    else
N        return TEST_FALSE;
N    */
W "src\user\hwtester.c" 5864 10 variable "ReaderCTSLowSensorSnrSwVD33InFlag" was declared but never referenced
W "src\user\hwtester.c" 5865 10 variable "ReaderCTSHighSensorSnrSwVD33InFlag" was declared but never referenced
N}
N//////////////////////EPD    test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
N/*
Nstatic BOOL epdTest(void* para1, void* para2)
N{
N    if(!isEPDInit){
N        terninalPrintf("EPD No Connection [ERROR]\n");
N        return TEST_FALSE;
N    }
N    EPDDrawString(TRUE,"EPD Testing   ",X_POS_RST,Y_POS_RST);
N    EPDSetBacklight(FALSE);
N    vTaskDelay(500/portTICK_RATE_MS);
N    EPDSetBacklight(TRUE);
N
N    EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_BLACK_INDEX,0,0);
N    vTaskDelay(1500/portTICK_RATE_MS);
N    EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N    vTaskDelay(1500/portTICK_RATE_MS);
N    guiManagerRefreshScreen();
N    vTaskDelay(7000/portTICK_RATE_MS);
N    EPDDrawString(TRUE,"EPD Testing   ",X_POS_RST,Y_POS_RST);
N    EPDDrawString(TRUE,"Is Screen\nAll Black Then\nAll White\n\n+:Yes  =:No",X_POS_MSG,Y_POS_MSG);
N    terninalPrintf("Does EPD Screen turn to all black then turn to all white?(y/n)\n");
N    if(userResponseLoop()=='y'){
N        EPDDrawString(TRUE,"PASS            ",X_POS_RST,Y_POS_RST);
N        cleanMsg();
N        //terninalPrintf("EPD Test [OK]\r\n");
N        return TEST_SUCCESSFUL_LIGHT_OFF;
N    }
N    EPDDrawString(TRUE,"ERROR              ",X_POS_RST,Y_POS_RST);
N    cleanMsg();
N    //terninalPrintf("EPD Test [ERROR]\r\n");
N    return TEST_FALSE;
N}
N*/
N
N//////////////////////Modem  test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL modeminit(BOOL testflag)
N{
N    return QModemLibInit(MODEM_BAUDRATE);
X    return QModemLibInit(921600);
N}
N
N
N
N
Nstatic BOOL modemTest(void* para1, void* para2)
N{
N 
N    QModemLibInit(MODEM_BAUDRATE);
X    QModemLibInit(921600);
N    if(MBtestFlag )
N    {     
N        BOOL resultFlag1 = FALSE;      // MODEM Dialup test resultFlag
X        BOOL resultFlag1 = (0);      
N        BOOL resultFlag2 = FALSE;      // MODEM interrupt test resultFlag
X        BOOL resultFlag2 = (0);      
N        BOOL resultFlag3 = FALSE;      // MODEM RTS test resultFlag
X        BOOL resultFlag3 = (0);      
N        char tempchar;
N        
N        terninalPrintf("MODEM Dialup test,please wait about 1 minute.\r\n");
N        //GPIO_SetBit(GPIOG, BIT7);
N        //LedSetColor(modemColorAllRed, 0x04, TRUE);
N        
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //Reset pin GPG8
N        outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xFu<<0)) | (0x0u<<0));
X        *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xFu<<0)) | (0x0u<<0);
N        GPIO_OpenBit(GPIOG, BIT8, DIR_OUTPUT, NO_PULL_UP);
X        GPIO_OpenBit(GPIOG, (0x00000100), DIR_OUTPUT, NO_PULL_UP);
N        GPIO_ClrBit(GPIOG, BIT8);
X        GPIO_ClrBit(GPIOG, (0x00000100));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        GPIO_SetBit(GPIOG, BIT8);
X        GPIO_SetBit(GPIOG, (0x00000100));
N        
N        QModemDialupStart();
N        if(QModemDialupProcess() == TRUE)
X        if(QModemDialupProcess() == (1))
N        {
N            terninalPrintf("\r\nMODEM Dialup SUCCESS\r\n");
N            LedSetBayLightFlush(0,8);
N            LedSetAliveStatusLightFlush(0,8);
N            
N            
N            resultFlag1 = TRUE;
X            resultFlag1 = (1);
N            //return RTCTest(para1,para2);
N        }
N        else
N        {
N            //terninalPrintf("\r\n");
N            terninalPrintf("\r\nMODEM Dialup ERROR\r\n");
N            LedSetAliveStatusLightFlush(0,8);
N            resultFlag1 = FALSE;
X            resultFlag1 = (0);
N            //RTCTest(para1,para2);
N            //return TEST_FALSE;
N        } 
N        
N        
N            QModemTotalStop();
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N            QModemLibInit(921600);
N            
N        ModemGPIOH4INTFlag = FALSE;
X        ModemGPIOH4INTFlag = (0);
N        // Set PH4 to EINT4 
N        outpw(REG_SYS_GPH_MFPL,(inpw(REG_SYS_GPH_MFPL) & ~(0xF<<16)) | (0xF<<16));    
X        *((volatile unsigned int *)((0xB0000000+0x0A8))) = ((*((volatile unsigned int *)((0xB0000000+0x0A8)))) & ~(0xF<<16)) | (0xF<<16);    
N        // Configure PH4 to input mode 
N        GPIO_OpenBit(GPIOH, BIT4, DIR_INPUT, NO_PULL_UP);
X        GPIO_OpenBit(GPIOH, (0x00000010), DIR_INPUT, NO_PULL_UP);
N        // Confingure PH4 to both-edge trigger 
N        GPIO_ClrISRBit(GPIOH, BIT4);
X        GPIO_ClrISRBit(GPIOH, (0x00000010));
N        GPIO_EnableTriggerType(GPIOH, BIT4, FALLING);
X        GPIO_EnableTriggerType(GPIOH, (0x00000010), FALLING);
N        //EINT5
N        GPIO_EnableEINT(NIRQ4, (GPIO_CALLBACK)EINT4Callback, 0); 
N        
N        
N            //terninalPrintf("Check MODEM AT Cmd again,please wait about 5 seconds.\n");
N            terninalPrintf("Check MODEM AT Cmd,please wait about 10 seconds.\n");
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            if(!QModemATCmdTest())
N            {   
N                terninalPrintf("MODEM send ATCmd [ERROR]\r\n");
N                return TEST_FALSE;
X                return 0x10;
N            }
N            terninalPrintf("MODEM send sleep Cmd,please wait 10 seconds.\n");
N            //QModemIoctl(UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
N
N            //vTaskDelay(30000/portTICK_RATE_MS);
N            vTaskDelay(10000/portTICK_RATE_MS);
X            vTaskDelay(10000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    
N        
N        int sentSleepCmdTimes = 3;
N        while(sentSleepCmdTimes > 0)
N        {
N            if(QModemSetSleep())
N                break;
N            sentSleepCmdTimes--;
N
N        }
N        if(sentSleepCmdTimes <= 0)
N        {
N            terninalPrintf("MODEM send SleepCmd [ERROR]\r\n");
N            resultFlag2 = FALSE;
X            resultFlag2 = (0);
N            //return TEST_FALSE;
N        }
N
N        //ModemGPIOH4INTFlag = FALSE;
N        QModemSetQurccfg();
N        /*
N        // Set PH4 to EINT4 
N        outpw(REG_SYS_GPH_MFPL,(inpw(REG_SYS_GPH_MFPL) & ~(0xF<<16)) | (0xF<<16));    
N        // Configure PH4 to input mode 
N        GPIO_OpenBit(GPIOH, BIT4, DIR_INPUT, NO_PULL_UP);
N        // Confingure PH4 to both-edge trigger 
N        GPIO_ClrISRBit(GPIOH, BIT4);
N        GPIO_EnableTriggerType(GPIOH, BIT4, FALLING);
N        //EINT5
N        GPIO_EnableEINT(NIRQ4, (GPIO_CALLBACK)EINT4Callback, 0);    
N        */
N        
N        //ModemGPIOH4INTFlag = FALSE;
N        //vTaskDelay(100/portTICK_RATE_MS);
N        //QModemSetTestCmd();
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if(!ModemGPIOH4INTFlag)
N        {
N            terninalPrintf("MODEM interrupt test error.\n");
N            GPIO_DisableEINT(NIRQ4);
N            QModemTotalStop();
N            resultFlag2 = FALSE;
X            resultFlag2 = (0);
N            //return TEST_FALSE;
N        }
N        else
N        {
N            terninalPrintf("MODEM interrupt test success.\n");
N
N            resultFlag2 = TRUE;
X            resultFlag2 = (1);
N        }
N        terninalPrintf("Please check RTS signal.\n");
N        QModemIoctl(UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
X        QModemIoctl(16, 0, 0);
N        
N        
N        terninalPrintf("MODEM RTS signal OK?(y/n)\n");
N
N        while(1)
N        {
N            tempchar = userResponseLoop();
N            QModemIoctl(UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
X            QModemIoctl(16, 1, 0);
N            GPIO_DisableEINT(NIRQ4);
N            QModemTotalStop();
N            if(tempchar =='y')
N            {
N                resultFlag3 = TRUE;
X                resultFlag3 = (1);
N                break;
N            }
N            else if(tempchar =='n')
N            {
N                resultFlag3 = FALSE;
X                resultFlag3 = (0);
N                break;
N            }
N        }
N        ModemResultLEDFlag = TRUE;
X        ModemResultLEDFlag = (1);
N
N        if(resultFlag1 & resultFlag2 & resultFlag3)
N        {
N            return TEST_SUCCESSFUL_LIGHT_OFF;
X            return 0x12;
N        }
N        else
N        {
N            return TEST_FALSE;
X            return 0x10;
N        }
N        /*
N        terninalPrintf("MODEM Dialup test,please wait about 1 minute.\r\n");
N        QModemDialupStart();
N        if(QModemDialupProcess() == TRUE)
N        {
N            terninalPrintf("\r\nMODEM Dialup SUCCESS\r\n");
N            return RTCTest(para1,para2);
N        }
N        else
N        {
N            terninalPrintf("\r\n");
N            RTCTest(para1,para2);
N            return TEST_FALSE;
N        } 
N
N        */
N    }
N    else
N    {    
N        terninalPrintf("!!! modemTest !!!\r\n");
N        guiPrintResult("Modem Testing");
N        //guiPrintMessage("Start...");
N        guiPrintMessage("Start");
N        //QModemLibInit(MODEM_BAUDRATE);
N        if(QModemATCmdTest())
N        {
N            //guiPrintMessage((char*)retVer);
N            guiPrintMessage("Modem OK");
N            terninalPrintf("  modemTest [OK]\r\n");
N            return RTCTest(para1,para2);
N        }
N        testErroCode = MODEM_CONNECT_ERRO;
X        testErroCode = 0x0701;
N        //terninalPrintf("  modemTest [ERROR]\r\n");
N        guiPrintMessage("Modem Fail");
N        terninalPrintf("  modemTest [Error]\r\n");
N        RTCTest(para1,para2);
N        return TEST_FALSE; 
X        return 0x10; 
N    }
N
N    
N    /*guiPrintMessage("Get Version");
N    char retVer[100];
N    if(QModemGetVer(retVer))
N    {   
N        //sprintf(retVer,"%s\n%s","Version",retVer);
N        terninalPrintf("=>%s  %p",retVer,retVer);
N        guiPrintMessage(retVer);
N    }
N    else
N    {
N        guiPrintMessage("Modem Fail\nATCmd Error");
N        return TEST_FALSE;
N    }
N    return TEST_SUCCESSFUL_LIGHT_OFF; */
N    
N}
N
N//////////////////////RTC   test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL RTCTest(void* para1, void* para2)
N{
N    terninalPrintf("!!! rtcTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N    {
N        guiPrintResult("RTC Testing");
N        //guiPrintMessage("Wait 2s");
N        //EPDDrawString(TRUE,"Wait 2s",X_POS_RST,Y_POS_RST+200);
N        EPDDrawString(TRUE,"Wait 2s",X_POS_RST,Y_POS_RST+250);
X        EPDDrawString((1),"Wait 2s",550,154+250);
N    }
N    RTC_TIME_DATA_T pt;
N    time_t time, time2;
N    //terninalPrintf("!!! RTCTest !!!\r\n");
N
N    if(E_RTC_SUCCESS == RTC_Read(RTC_CURRENT_TIME, &pt))
X    if(0 == RTC_Read(RTC_CURRENT_TIME, &pt))
N    {
N        char* tString;
N        //sprintf(tString,"CURRENT TIME:\n%04d-%02d-%02d\n%02d %02d %02d",
N        //    pt.u32Year, pt.u32cMonth, pt.u32cDay, 
N         //   pt.u32cHour, pt.u32cMinute, pt.u32cSecond);  
N        terninalPrintf("RTC_CURRENT_TIME: [%04d/%02d/%02d %02d:%02d:%02d (%d)  u8cClockDisplay = %d, u8cAmPm =%d]\r\n",
N            pt.u32Year, pt.u32cMonth, pt.u32cDay, 
N            pt.u32cHour, pt.u32cMinute, pt.u32cSecond, pt.u32cDayOfWeek, pt.u8cClockDisplay, pt.u8cAmPm); 
N        //guiPrintMessage(tString);
W "src\user\hwtester.c" 6510 15 variable "tString" was declared but never referenced
N    }
N    vTaskDelay(2000/portTICK_RATE_MS);//wait other task finsh
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    time = GetCurrentUTCTime();
N    terninalPrintf(" RTCTest Get time: %d, Please Wait...\r\n", time);
N    vTaskDelay(2000/portTICK_RATE_MS );
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ) );
N    time2 = GetCurrentUTCTime();
N    terninalPrintf(" RTCTest Get time again: %d\r\n", time2);
N
N    if((time2 - time) != 2)
N    {
N        testErroCode = RTC_TIME_ERRO;
X        testErroCode = 0x0801;
N        //terninalPrintf(" RTCTest [ERROR]\r\n");
N        //EPDDrawString(TRUE,"FAIL                ",X_POS_RST,Y_POS_RST);
N        //guiPrintMessage("RTC Fail");
N        //EPDDrawString(TRUE,"RTC   Fail   ",X_POS_RST,Y_POS_RST+200);
N        if(MBtestFlag )
N        {
N            MTPString[31][3] = 0x80;
N        }
N        else
N            EPDDrawString(TRUE,"RTC   Fail   ",X_POS_RST,Y_POS_RST+250);
X            EPDDrawString((1),"RTC   Fail   ",550,154+250);
N        terninalPrintf("  RTCTest [ERROR]\r\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    //terninalPrintf(" RTCTest [PASS]\r\n");
N    //EPDDrawString(TRUE,"RTC   OK     ",X_POS_RST,Y_POS_RST+200);
N    if(MBtestFlag )
N    {
N        MTPString[31][3] = 0x81;
N    }
N    else
N        EPDDrawString(TRUE,"RTC   OK     ",X_POS_RST,Y_POS_RST+250);
X        EPDDrawString((1),"RTC   OK     ",550,154+250);
N    terninalPrintf("  RTCTest [OK]\r\n");
N    return TEST_SUCCESSFUL_LIGHT_OFF;
X    return 0x12;
N}
N
N//////////////////////sFlash test/////////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL sFlashTest(void* para1, void* para2)
N{    
N    uint16_t uID;
N    terninalPrintf("!!! flashTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Flash Testing");
N    FlashDrvExInit(FALSE);
X    FlashDrvExInit((0));
N    FlashDrvExInitialize(SPI_FLASH_EX_0_INDEX);
X    FlashDrvExInitialize(1);
N    FlashDrvExInitialize(SPI_FLASH_EX_1_INDEX);
X    FlashDrvExInitialize(2);
N    FlashDrvExInitialize(SPI_FLASH_EX_2_INDEX);
X    FlashDrvExInitialize(3);
N
N    
N    terninalPrintf("Query Chip 1\r\n");
N    uID = FlashDrvExGetChipID(SPI_FLASH_EX_0_INDEX);
X    uID = FlashDrvExGetChipID(1);
N    if(uID == 0xEF16){
N        terninalPrintf(" Chip 1: 0x%04x [OK] \r\n", uID);
N        
N        if(MBtestFlag )
N        {}
N        else
N        {
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage("Chip 1 OK");
N        }
N        
N        IOtestResultFlag[13] = TRUE;
X        IOtestResultFlag[13] = (1);
N        MTPString[27][3] = 0x81;
N    }
N    else
N    {
N        testErroCode = FLASH1_SPACE_ERRO;
X        testErroCode = 0x0A01;
N        terninalPrintf(" Chip 1: 0x%04x [ERROR] \r\n", uID);
N        if(MBtestFlag )
N        {}
N        else
N        {
N            //vTaskDelay(15/portTICK_RATE_MS);
N            guiPrintMessage("Chip 1 FAIL ");
N        }
N        IOtestResultFlag[13] = FALSE;
X        IOtestResultFlag[13] = (0);
N        MTPString[27][3] = 0x80;
N        //return TEST_FALSE;
N    }
N    terninalPrintf("Query Chip 2\r\n");
N    uID = FlashDrvExGetChipID(SPI_FLASH_EX_1_INDEX);
X    uID = FlashDrvExGetChipID(2);
N    if(uID == 0xEF16){
N        terninalPrintf(" Chip 2: 0x%04x [OK] \r\n", uID);
N        //guiPrintMessage("Chip 2 OK");
N        
N        if(MBtestFlag )
N        {}
N        else
N        {
N            vTaskDelay(15/portTICK_RATE_MS);
X            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(TRUE,"Chip 2 OK    ",X_POS_RST,Y_POS_RST+250);
X            EPDDrawString((1),"Chip 2 OK    ",550,154+250);
N        }
N        IOtestResultFlag[14] = TRUE;
X        IOtestResultFlag[14] = (1);
N        MTPString[27][4] = 0x81;
N    }
N    else
N    {
N        testErroCode = FLASH2_SPACE_ERRO;
X        testErroCode = 0x0A02;
N        terninalPrintf(" Chip 2: 0x%04x [ERROR] \r\n", uID);
N        //guiPrintMessage("\nChip 2 FAIL ");
N        if(MBtestFlag )
N        {}
N        else
N        {
N            vTaskDelay(15/portTICK_RATE_MS);
X            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(TRUE,"Chip 2 FAIL  ",X_POS_RST,Y_POS_RST+250);
X            EPDDrawString((1),"Chip 2 FAIL  ",550,154+250);
N        }
N        IOtestResultFlag[14] = FALSE;
X        IOtestResultFlag[14] = (0);
N        MTPString[27][4] = 0x80;
N        //return TEST_FALSE;
N    }
N    
N    
N    
N    
N    terninalPrintf("Query Chip 3\r\n");
N    uID = FlashDrvExGetChipID(SPI_FLASH_EX_2_INDEX);
X    uID = FlashDrvExGetChipID(3);
N    if(uID == 0xEF16){
N        terninalPrintf(" Chip 3: 0x%04x [OK] \r\n", uID);
N        //guiPrintMessage("Chip 2 OK");
N        
N        if(MBtestFlag )
N        {}
N        else
N        {
N            vTaskDelay(15/portTICK_RATE_MS);
X            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(TRUE,"Chip 3 OK    ",X_POS_RST,Y_POS_RST+300);
X            EPDDrawString((1),"Chip 3 OK    ",550,154+300);
N        }
N        IOtestResultFlag[15] = TRUE;
X        IOtestResultFlag[15] = (1);
N        MTPString[27][5] = 0x81;
N    }
N    else
N    {
N        testErroCode = FLASH2_SPACE_ERRO;
X        testErroCode = 0x0A02;
N        terninalPrintf(" Chip 3: 0x%04x [ERROR] \r\n", uID);
N        //guiPrintMessage("\nChip 2 FAIL ");
N        if(MBtestFlag )
N        {}
N        else
N        {
N            vTaskDelay(15/portTICK_RATE_MS);
X            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(TRUE,"Chip 3 FAIL  ",X_POS_RST,Y_POS_RST+300);
X            EPDDrawString((1),"Chip 3 FAIL  ",550,154+300);
N        }
N        IOtestResultFlag[15] = FALSE;
X        IOtestResultFlag[15] = (0);
N        MTPString[27][5] = 0x80;
N        return TEST_FALSE;
X        return 0x10;
N    }
N    
N    
N    return TEST_SUCCESSFUL_LIGHT_OFF;
X    return 0x12;
N}
N
N//////////////////////SmartCard test//////////////////////TEST_SUCCESSFUL_LIGHT_OFF
Nstatic BOOL smartCardTest(void* para1, void* para2)
N{
N    terninalPrintf("!!! smartCardTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Smart Card\nTesting");
N    if(SmartCardDrvInit(TRUE))
X    if(SmartCardDrvInit((1)))
N    {				
N        //terninalPrintf("  smartCardTest [OK]\r\n");
N        terninalPrintf("smartCardTest success.\r\n");
N    }
N    else
N    {
N        testErroCode = SMART_CARD_CONNECT_ERRO;
X        testErroCode = 0x0B01;
N        //terninalPrintf("  smartCardTest [ERROR]\r\n");
N        terninalPrintf("smartCardTest error.\r\n");
N        IOtestResultFlag[16] = FALSE;
X        IOtestResultFlag[16] = (0);
N        MTPString[27][6] = 0x80;
N        return TEST_FALSE;
X        return 0x10;
N    }
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintMessage("OK");
N    IOtestResultFlag[16] = TRUE;
X    IOtestResultFlag[16] = (1);
N    MTPString[27][6] = 0x81;
N    return TEST_SUCCESSFUL_LIGHT_OFF;
X    return 0x12;
N}
N
N//////////////////////Camera test/////////////////////////
N
Nstatic BOOL cameraTest(void* para1, void* para2)
N{    
N    static CameraInterface*     pCameraInterface = NULL;
X    static CameraInterface*     pCameraInterface = 0;
N    uint8_t reValueFailFlag = FALSE;
X    uint8_t reValueFailFlag = (0);
N    terninalPrintf("!!! usbCamTest !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N    {
N        GPIO_ClrBit(GPIOB, BIT6);
X        GPIO_ClrBit(GPIOB, (0x00000040));
N        guiPrintResult("Camera");
N    }
N    setPrintfFlag(TRUE);    
X    setPrintfFlag((1));    
N    pCameraInterface = CameraGetInterface(CAMERA_UVC_INTERFACE_INDEX);
X    pCameraInterface = CameraGetInterface(0);
N    if(pCameraInterface == NULL)
X    if(pCameraInterface == 0)
N    {
N        sysprintf("usbCamTest ERROR (pCameraInterface == NULL)!!\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    if(pCameraInterface->initFunc(FALSE) == FALSE)
X    if(pCameraInterface->initFunc((0)) == (0))
N    {
N        sysprintf("usbCamTest ERROR (pCameraInterface->initFunc(FALSE) == FALSE)!!\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    
N    //userResponseLoop();
N    uint8_t* photoPr;
N    int photoLen = 0;
N    char targetFileNameTmp[_MAX_LFN];
X    char targetFileNameTmp[255];
N    memset(targetFileNameTmp, 0x0, sizeof(targetFileNameTmp));
N    sprintf(targetFileNameTmp,"uvcphoto.%s", PHOTO_FILE_EXTENSION);    
X    sprintf(targetFileNameTmp,"uvcphoto.%s", "jpg");    
N    //Cam0
N    //guiPrintMessage("Cam0 Testing..");
N    //terninalPrintf("  camera[0] -- Taking Photo\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintMessage("Cam1 Testing..");
N    terninalPrintf("  camera[1] -- Taking Photo\r\n");
N    //if(pCameraInterface->takePhotoFunc(0, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, FALSE))
N    //if(pCameraInterface->takePhotoFunc(0, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, FALSE, 1, 0))
N    if(pCameraInterface->takePhotoFunc(1, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, FALSE, 1, 0))
X    if(pCameraInterface->takePhotoFunc(1, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, (0), 1, 0))
N    {
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("Cam1 OK");
N        terninalPrintf("  camera[1] (%s) [OK]\r\n",targetFileNameTmp);
N        
N        IOtestResultFlag[7] = TRUE;
X        IOtestResultFlag[7] = (1);
N    }
N    else
N    {
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintMessage("Cam1 ERROR");
N        //terninalPrintf("  cameraTest[1] [ERROR]\r\n");
N        terninalPrintf("  camera[1] [ERROR]\r\n");
N        reValueFailFlag = TRUE;
X        reValueFailFlag = (1);
N        
N        IOtestResultFlag[7] = FALSE;
X        IOtestResultFlag[7] = (0);
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        //return TEST_FALSE;
N    }
N    //Cam1
N    //guiPrintMessage("Cam1 Testing..");
N    //EPDDrawString(TRUE,"Cam1 Testing..",X_POS_RST,Y_POS_RST+200);
N    
N    if(MBtestFlag )
N    {
N    }
N    else
N    {
N        EPDDrawString(TRUE,"Cam2 Testing..",X_POS_RST,Y_POS_RST+250);
X        EPDDrawString((1),"Cam2 Testing..",550,154+250);
N        terninalPrintf("  camera[2] -- Taking Photo\r\n");
N        //if(pCameraInterface->takePhotoFunc(1, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "1:", targetFileNameTmp, FALSE, 1, 0))
N        if(pCameraInterface->takePhotoFunc(0, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "1:", targetFileNameTmp, FALSE, 1, 0))
X        if(pCameraInterface->takePhotoFunc(0, &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "1:", targetFileNameTmp, (0), 1, 0))
N        {
N            //guiPrintMessage("Cam1 OK");
N            //EPDDrawString(TRUE,"Cam1 OK       ",X_POS_RST,Y_POS_RST+200);
N            EPDDrawString(TRUE,"Cam2 OK       ",X_POS_RST,Y_POS_RST+250);
X            EPDDrawString((1),"Cam2 OK       ",550,154+250);
N            //terninalPrintf("  cameraTest[2] (%s) [OK]\r\n",targetFileNameTmp);
N            terninalPrintf("  camera[2] (%s) [OK]\r\n",targetFileNameTmp);
N            
N            IOtestResultFlag[8] = TRUE;
X            IOtestResultFlag[8] = (1);
N        }
N        else
N        {
N            //guiPrintMessage("Cam1 ERROR");
N            //EPDDrawString(TRUE,"Cam1 ERROR    ",X_POS_RST,Y_POS_RST+200);
N            EPDDrawString(TRUE,"Cam2 ERROR    ",X_POS_RST,Y_POS_RST+250);
X            EPDDrawString((1),"Cam2 ERROR    ",550,154+250);
N            //terninalPrintf("  cameraTest[2] [ERROR]\r\n");
N            terninalPrintf("  camera[2] [ERROR]\r\n");
N            
N            IOtestResultFlag[8] = FALSE;
X            IOtestResultFlag[8] = (0);
N            
N            return TEST_FALSE;
X            return 0x10;
N        }
N    }
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if(MBtestFlag )
N    {}
N    else                
N        GPIO_SetBit(GPIOB, BIT6);
X        GPIO_SetBit(GPIOB, (0x00000040));
N    if(reValueFailFlag == FALSE)    
X    if(reValueFailFlag == (0))    
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    else
N    {
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N}
N
N//////////////////////Radar test//////////////////////// single
Nstatic BOOL NewRadarSingleTest(void* para1, void* para2)
N{
N    static RadarInterface* pRadarInterface;
N    
N    int featureValue[2];
N    uint8_t RadarData[22];
N    
N    //uint8_t VersionCmd[9] = {0x7A, 0xA7, 0x00, 0x09, 0x00, 0x00, 0x09, 0xD3, 0x3D};
N    uint8_t ResultCmd[24] = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
N                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
N                             0x00, 0x1A, 0xD3, 0x3D};
N    char NumStr[11][10];
N    
N    terninalPrintf("!!! New Radar Test !!!\r\n");
N    guiPrintResult("Radar");
N    pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(2);
N    terninalPrintf("Radar Initial...");
N    
N    
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    
N    //pRadarInterface->setPowerStatusFunc(0,TRUE);
N    //pRadarInterface->setPowerStatusFunc(1,TRUE);
N
N    
N    for(int i = 0; i<2; i++)
N    {
N        if(i == 0)
N            guiPrintMessage("Radar1 Test...");
N        else if(i == 1)
N            EPDDrawString(TRUE,"Radar2 Test... ",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((1),"Radar2 Test... ",550,354);
N        pRadarInterface->setPowerStatusFunc(i,TRUE);
X        pRadarInterface->setPowerStatusFunc(i,(1));
N        vTaskDelay(500/portTICK_RATE_MS);
X        vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        featureValue[i] = pRadarInterface->RadarResultFunc(i, 0x02,ResultCmd,RadarData);
N        pRadarInterface->setPowerStatusFunc(i,FALSE);
X        pRadarInterface->setPowerStatusFunc(i,(0));
N        /*
N        terninalPrintf("featureValue = %08x \r\n",featureValue);
N        terninalPrintf("RadarData =              ");
N        for(int j = 0; j<sizeof(RadarData); j++)
N            terninalPrintf("%02x ",RadarData[j]);
N        terninalPrintf("\r\n");
N        */
N        if(featureValue[i] == TRUE)
X        if(featureValue[i] == (1))
N        {
N            
N            terninalPrintf("Radar%d OK\r\n",i+1);
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(FALSE,"                ",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((0),"                ",550,354);
N            if(i == 0)
N                EPDDrawString(TRUE,"Radar1 OK",X_POS_MSG,Y_POS_MSG+50);
X                EPDDrawString((1),"Radar1 OK",550,354+50);
N            else if(i == 1)
N                EPDDrawString(TRUE,"Radar2 OK",X_POS_MSG,Y_POS_MSG+200);
X                EPDDrawString((1),"Radar2 OK",550,354+200);
N
N            /*
N            terninalPrintf("Radar%d Object Distance (R): %d\r\n",i+1,RadarData[7]*10);           
N            
N            memset(NumStr,0x00,sizeof(NumStr));
N            
N            sprintf(NumStr[3],"%d",RadarData[7]*10);
N            
N 
N            EPDDrawString(FALSE,"    ",15+7*25+515*i,100+(44*5));
N            EPDDrawString(FALSE,"    ",15+15*25+515*i,100+(44*5));
N            EPDDrawString(FALSE,"    ",15+7*25+515*i,100+(44*6));
N            EPDDrawString(FALSE,"    ",15+15*25+515*i,100+(44*6));
N            EPDDrawString(FALSE,"     ",15+8*25+515*i,100+(44*7));
N            EPDDrawString(FALSE,"     ",15+8*25+515*i,100+(44*8));
N            EPDDrawString(FALSE,"     ",15+8*25+515*i,100+(44*9));
N            EPDDrawString(FALSE,"     ",15+8*25+515*i,100+(44*10));
N            EPDDrawString(FALSE,"     ",15+8*25+515*i,100+(44*11));
N            EPDDrawString(FALSE,"     ",25+12*25+515*i,100+(44*12));
N            EPDDrawString(FALSE,"     ",25+10*25+515*i,100+(44*13));
N                      
N            
N            EPDDrawString(FALSE,NumStr[0],15+7*25+515*i,100+(44*5));
N            EPDDrawString(FALSE,NumStr[1],15+15*25+515*i,100+(44*5));
N            EPDDrawString(FALSE,NumStr[2],15+7*25+515*i,100+(44*6));
N            EPDDrawString(FALSE,NumStr[3],15+15*25+515*i,100+(44*6));
N            EPDDrawString(FALSE,NumStr[4],15+8*25+515*i,100+(44*7));
N            EPDDrawString(FALSE,NumStr[5],15+8*25+515*i,100+(44*8));
N            EPDDrawString(FALSE,NumStr[6],15+8*25+515*i,100+(44*9));
N            EPDDrawString(FALSE,NumStr[7],15+8*25+515*i,100+(44*10));
N            EPDDrawString(FALSE,NumStr[8],15+8*25+515*i,100+(44*11));
N            EPDDrawString(FALSE,NumStr[9],25+12*25+515*i,100+(44*12));
N            EPDDrawString(TRUE,NumStr[10],25+10*25+515*i,100+(44*13));
N            */
N        }
N        else
N        {
N            /*
N            if(i == 0)
N                guiPrintMessage("Radar1 FAIL");
N            else if(i == 1)
N                EPDDrawString(FALSE,"Radar2 FAIL",X_POS_MSG,Y_POS_MSG);
N            */
N            terninalPrintf("Radar%d FAIL\r\n",i+1);
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(FALSE,"                ",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((0),"                ",550,354);
N            if(i == 0)
N                EPDDrawString(TRUE,"Radar1 FAIL",X_POS_MSG,Y_POS_MSG+50);
X                EPDDrawString((1),"Radar1 FAIL",550,354+50);
N            else if(i == 1)
N                EPDDrawString(TRUE,"Radar2 FAIL",X_POS_MSG,Y_POS_MSG+200);                
X                EPDDrawString((1),"Radar2 FAIL",550,354+200);                
N            
N
N        }
N    }
N
N    //pRadarInterface->setPowerStatusFunc(0,FALSE);
N    //pRadarInterface->setPowerStatusFunc(1,FALSE);
N    if((featureValue[0] == TRUE) && (featureValue[1] == TRUE) )
X    if((featureValue[0] == (1)) && (featureValue[1] == (1)) )
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    else
N        return TEST_FALSE;
X        return 0x10;
W "src\user\hwtester.c" 6844 10 variable "NumStr" was declared but never referenced
N}
N
N
Nstatic BOOL radarSingleTest(void* para1, void* para2)
N{
N    static RadarInterface* pRadarInterface;
N    int dist0;
N    int dist1;
N    char distStringBuff0[20];
N    char distStringBuff1[20];
N    uint8_t reValueFailFlag = FALSE;
X    uint8_t reValueFailFlag = (0);
N    BOOL changeFlag;
N    BOOL LidarfailFlag = 0;
N    terninalPrintf("!!! radar\\lidar Test !!!\r\n");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintResult("Radar");
N    pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(0);
N    terninalPrintf("Radar Initial...");
N    if(MBtestFlag )
N    {}
N    else
N        guiPrintMessage("Radar Initial...");
N    
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N        return TEST_FALSE;
X        return 0x10;
N    }
N    
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        //EPDDrawString(TRUE,"FAIL            \n                  ",X_POS_RST,Y_POS_RST);
N        terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    
N    if(MBtestFlag )
N    { 
N        pRadarInterface->setPowerStatusFunc(0,TRUE);
X        pRadarInterface->setPowerStatusFunc(0,(1));
N        pRadarInterface->setPowerStatusFunc(1,TRUE);
X        pRadarInterface->setPowerStatusFunc(1,(1));
N        //guiPrintMessage("Radar1 Test...");
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if( pRadarInterface->checkFeaturnFunc(0, &changeFlag, NULL, NULL, NULL) != RADAR_FEATURE_IGNORE)
X        if( pRadarInterface->checkFeaturnFunc(0, &changeFlag, 0, 0, 0) != 0x06)
N        {
N            reValueFailFlag = TRUE;
X            reValueFailFlag = (1);
N            terninalPrintf("radar UR3TX & radar UR7RX connect error.\r\n");
N            IOtestResultFlag[5] = FALSE;
X            IOtestResultFlag[5] = (0);
N            MTPString[29][4] = 0x80;
N            return FALSE;
X            return (0);
N        }
N        else
N        {
N            terninalPrintf("radar UR3TX & radar UR7RX connect success.\r\n");
N            IOtestResultFlag[5] = TRUE;
X            IOtestResultFlag[5] = (1);
N            MTPString[29][4] = 0x81;
N        //guiPrintMessage("Radar2 Test...");
N        }
N        if( pRadarInterface->checkFeaturnFunc(1, &changeFlag, NULL, NULL, NULL) != RADAR_FEATURE_IGNORE )
X        if( pRadarInterface->checkFeaturnFunc(1, &changeFlag, 0, 0, 0) != 0x06 )
N        {
N            reValueFailFlag = TRUE;
X            reValueFailFlag = (1);
N            terninalPrintf("radar UR7TX & radar UR3RX connect error.\r\n");
N            IOtestResultFlag[6] = FALSE;
X            IOtestResultFlag[6] = (0);
N            MTPString[29][5] = 0x80;
N            return FALSE;
X            return (0);
N        }
N        else
N        {
N            terninalPrintf("radar UR7TX & radar UR3RX connect success.\r\n");
N            IOtestResultFlag[6] = TRUE;
X            IOtestResultFlag[6] = (1);
N            MTPString[29][5] = 0x81;
N        }
N        
N        pRadarInterface->setPowerStatusFunc(0,FALSE);
X        pRadarInterface->setPowerStatusFunc(0,(0));
N        pRadarInterface->setPowerStatusFunc(1,FALSE);
X        pRadarInterface->setPowerStatusFunc(1,(0));
N        
N        if(reValueFailFlag)
N        {
N            if(MBtestFlag )
N                return FALSE;
X                return (0);
N            else
N                return TEST_FALSE;
X                return 0x10;
N        }
N        else
N            return TEST_SUCCESSFUL_LIGHT_OFF;
X            return 0x12;
N        /*
N        if(reValueFailFlag)
N        {
N            cameraTest(para1, para2);
N            return TEST_FALSE;
N        }
N        else
N            return cameraTest(para1, para2);
N        */
N        
N        /*
N        if(GPIO_ReadBit(GPIOJ, BIT4))
N        {
N        
N            if(reValueFailFlag)
N            {
N                cameraTest(para1, para2);
N                return TEST_FALSE;
N            }
N            else
N                return cameraTest(para1, para2);
N                //return TEST_SUCCESSFUL_LIGHT_OFF;
N        }
N        else
N        {
N            if(reValueFailFlag)
N                return TEST_FALSE;
N            else
N                return TEST_SUCCESSFUL_LIGHT_OFF;
N        }
N        */
N    }
N    else
N    {
N        pRadarInterface->setPowerStatusFunc(0,TRUE);
X        pRadarInterface->setPowerStatusFunc(0,(1));
N        pRadarInterface->setPowerStatusFunc(1,TRUE);
X        pRadarInterface->setPowerStatusFunc(1,(1));
N        guiPrintMessage("Radar1 Test...");
N        vTaskDelay(4000/portTICK_RATE_MS);
X        vTaskDelay(4000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        int featureValue = pRadarInterface->checkFeaturnFunc(0, &changeFlag, NULL, NULL, NULL);
X        int featureValue = pRadarInterface->checkFeaturnFunc(0, &changeFlag, 0, 0, 0);
N        if(featureValue==RADAR_FEATURE_OCCUPIED
X        if(featureValue==0x01
N            || featureValue==RADAR_FEATURE_VACUUM 
X            || featureValue==0x03 
N            || featureValue==RADAR_FEATURE_OCCUPIED_UN_STABLED
X            || featureValue==0x02
N            || featureValue==RADAR_FEATURE_VACUUM_UN_STABLED
X            || featureValue==0x04
N            || featureValue==RADAR_FEATURE_IGNORE
X            || featureValue==0x06
N            || featureValue==RADAR_FEATURE_OCCUPIED_LIDAR_FAIL
X            || featureValue==0x31
N            || featureValue==RADAR_FEATURE_VACUUM_LIDAR_FAIL
X            || featureValue==0x33
N            || featureValue==RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL
X            || featureValue==0x32
N            || featureValue==RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL
X            || featureValue==0x34
N            || featureValue==RADAR_FEATURE_IGNORE_LIDAR_FAIL)
X            || featureValue==0x36)
N        {
N            terninalPrintf("Radar1 OK\n");
N            //guiPrintMessage("Radar0 OK");
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(FALSE,"                ",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((0),"                ",550,354);
N            EPDDrawString(FALSE,"Radar1 OK",X_POS_MSG,Y_POS_MSG+50);
X            EPDDrawString((0),"Radar1 OK",550,354+50);
N            if((featureValue & 0xf0) == 0x30)
N            {
N                EPDDrawString(TRUE," Lidar1 FAIL",X_POS_MSG,Y_POS_MSG+100);
X                EPDDrawString((1)," Lidar1 FAIL",550,354+100);
N                LidarfailFlag = 1;
N            }
N            else
N            {
N                EPDDrawString(TRUE," Lidar1 OK",X_POS_MSG,Y_POS_MSG+100);
X                EPDDrawString((1)," Lidar1 OK",550,354+100);
N            }
N            switch(featureValue)
N            {
N            case RADAR_FEATURE_OCCUPIED:
X            case 0x01:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_OCCUPIED!!\n" );
N                break;
N            case RADAR_FEATURE_VACUUM:
X            case 0x03:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_VACUUM!!\n" );
N                break;
N            case RADAR_FEATURE_OCCUPIED_UN_STABLED:
X            case 0x02:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_UN_STABLED!!\n" );
N                break; 
N            case RADAR_FEATURE_VACUUM_UN_STABLED:
X            case 0x04:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_UN_STABLED!!\n" );
N                break; 
N            case RADAR_FEATURE_IGNORE:
X            case 0x06:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_IGNORE!!\n" );
N                break; 
N            
N            
N            case RADAR_FEATURE_OCCUPIED_LIDAR_FAIL:
X            case 0x31:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_OCCUPIED_LIDAR_FAIL!!\n" );
N                break;
N            case RADAR_FEATURE_VACUUM_LIDAR_FAIL:
X            case 0x33:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_VACUUM_LIDAR_FAIL!!\n" );
N                break;
N            case RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL:
X            case 0x32:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL!!\n" );
N                break; 
N            case RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL:
X            case 0x34:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL!!\n" );
N                break; 
N            case RADAR_FEATURE_IGNORE_LIDAR_FAIL:
X            case 0x36:
N                terninalPrintf("[RADAR]1 ->  RADAR_FEATURE_IGNORE_LIDAR_FAIL!!\n" );
N                break; 
N            }
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            if(pRadarInterface->readDistValueFunc(0,&dist0) == TRUE)
X            if(pRadarInterface->readDistValueFunc(0,&dist0) == (1))
N            {
N                sprintf(distStringBuff0," Dist:%d",dist0);
N                EPDDrawString(TRUE,distStringBuff0,X_POS_MSG,Y_POS_MSG+150);
X                EPDDrawString((1),distStringBuff0,550,354+150);
N            }
N            else
N            {
N                EPDDrawString(TRUE," L1 not calib.",X_POS_MSG,Y_POS_MSG+150);  //"L1 not calibrated"
X                EPDDrawString((1)," L1 not calib.",550,354+150);  
N            }
N        }
N        else
N        {
N            guiPrintMessage("Radar1 TIMEOUT");
N            terninalPrintf("[RADAR]1 ->  TIMEOUT!!\n"); 
N            //terninalPrintf("RadarTest [ERROR]\n");
N            EPDDrawString(FALSE,"Radar1 FAIL",X_POS_MSG,Y_POS_MSG+50);
X            EPDDrawString((0),"Radar1 FAIL",550,354+50);
N            EPDDrawString(TRUE," Lidar1 FAIL",X_POS_MSG,Y_POS_MSG+100);
X            EPDDrawString((1)," Lidar1 FAIL",550,354+100);
N            reValueFailFlag = TRUE;
X            reValueFailFlag = (1);
N            //return TEST_FALSE;
N        }
N        //guiPrintMessage("Radar1 Test...");
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,"Radar2 Test... ",X_POS_MSG,Y_POS_MSG);
X        EPDDrawString((1),"Radar2 Test... ",550,354);
N        featureValue = pRadarInterface->checkFeaturnFunc(1, &changeFlag, NULL, NULL, NULL);
X        featureValue = pRadarInterface->checkFeaturnFunc(1, &changeFlag, 0, 0, 0);
N        if(featureValue==RADAR_FEATURE_OCCUPIED 
X        if(featureValue==0x01 
N            || featureValue==RADAR_FEATURE_VACUUM
X            || featureValue==0x03
N            || featureValue==RADAR_FEATURE_OCCUPIED_UN_STABLED
X            || featureValue==0x02
N            || featureValue==RADAR_FEATURE_VACUUM_UN_STABLED
X            || featureValue==0x04
N            || featureValue==RADAR_FEATURE_IGNORE
X            || featureValue==0x06
N            || featureValue==RADAR_FEATURE_OCCUPIED_LIDAR_FAIL
X            || featureValue==0x31
N            || featureValue==RADAR_FEATURE_VACUUM_LIDAR_FAIL
X            || featureValue==0x33
N            || featureValue==RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL
X            || featureValue==0x32
N            || featureValue==RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL
X            || featureValue==0x34
N            || featureValue==RADAR_FEATURE_IGNORE_LIDAR_FAIL)
X            || featureValue==0x36)
N        {
N            terninalPrintf("Radar2 OK\n");
N            //guiPrintMessage("Radar1 OK");
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            EPDDrawString(FALSE,"                ",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((0),"                ",550,354);
N            EPDDrawString(FALSE,"Radar2 OK",X_POS_MSG,Y_POS_MSG+200);
X            EPDDrawString((0),"Radar2 OK",550,354+200);
N            if((featureValue & 0xf0) == 0x30)
N            {
N                EPDDrawString(TRUE," Lidar2 FAIL",X_POS_MSG,Y_POS_MSG+250);
X                EPDDrawString((1)," Lidar2 FAIL",550,354+250);
N                LidarfailFlag = 1;
N            }
N            else
N            {
N                EPDDrawString(TRUE," Lidar2 OK",X_POS_MSG,Y_POS_MSG+250);
X                EPDDrawString((1)," Lidar2 OK",550,354+250);
N            }
N            switch(featureValue)
N            {
N            case RADAR_FEATURE_OCCUPIED:
X            case 0x01:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_OCCUPIED!!\n" );
N                break;
N            case RADAR_FEATURE_VACUUM:
X            case 0x03:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_VACUUM!!\n" );
N                break;
N            case RADAR_FEATURE_OCCUPIED_UN_STABLED:
X            case 0x02:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_UN_STABLED!!\n" );
N                break; 
N            case RADAR_FEATURE_VACUUM_UN_STABLED:
X            case 0x04:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_UN_STABLED!!\n" );
N                break; 
N            case RADAR_FEATURE_IGNORE:
X            case 0x06:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_IGNORE!!\n" );
N                break; 
N            
N            case RADAR_FEATURE_OCCUPIED_LIDAR_FAIL:
X            case 0x31:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_OCCUPIED_LIDAR_FAIL!!\n" );
N                break;
N            case RADAR_FEATURE_VACUUM_LIDAR_FAIL:
X            case 0x33:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_VACUUM_LIDAR_FAIL!!\n" );
N                break;
N            case RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL:
X            case 0x32:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL!!\n" );
N                break; 
N            case RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL:
X            case 0x34:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL!!\n" );
N                break; 
N            case RADAR_FEATURE_IGNORE_LIDAR_FAIL:
X            case 0x36:
N                terninalPrintf("[RADAR]2 ->  RADAR_FEATURE_IGNORE_LIDAR_FAIL!!\n" );
N                break; 
N            }
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            if(pRadarInterface->readDistValueFunc(1,&dist1) == TRUE)
X            if(pRadarInterface->readDistValueFunc(1,&dist1) == (1))
N            {
N                sprintf(distStringBuff1," Dist:%d",dist1);
N                EPDDrawString(TRUE,distStringBuff1,X_POS_MSG,Y_POS_MSG+300);
X                EPDDrawString((1),distStringBuff1,550,354+300);
N            }
N            else
N            {
N                EPDDrawString(TRUE," L2 not calib.",X_POS_MSG,Y_POS_MSG+300);  //"L2 not calibrated"
X                EPDDrawString((1)," L2 not calib.",550,354+300);  
N            }
N        }
N        else
N        {
N            //guiPrintMessage("Radar1 TIMEOUT");
N            EPDDrawString(FALSE,"Radar2 TIMEOUT",X_POS_MSG,Y_POS_MSG);
X            EPDDrawString((0),"Radar2 TIMEOUT",550,354);
N            terninalPrintf("[RADAR]2 ->  TIMEOUT!!\n"); 
N            //terninalPrintf("RadarTest [ERROR]\n");
N            EPDDrawString(FALSE,"Radar2 FAIL",X_POS_MSG,Y_POS_MSG+200);
X            EPDDrawString((0),"Radar2 FAIL",550,354+200);
N            EPDDrawString(TRUE," Lidar2 FAIL",X_POS_MSG,Y_POS_MSG+250);
X            EPDDrawString((1)," Lidar2 FAIL",550,354+250);
N            
N            pRadarInterface->setPowerStatusFunc(0,FALSE);
X            pRadarInterface->setPowerStatusFunc(0,(0));
N            pRadarInterface->setPowerStatusFunc(1,FALSE);
X            pRadarInterface->setPowerStatusFunc(1,(0));
N            
N            return TEST_FALSE;
X            return 0x10;
N        }
N        
N        if(LidarfailFlag || reValueFailFlag)
N        {
N            pRadarInterface->setPowerStatusFunc(0,FALSE);
X            pRadarInterface->setPowerStatusFunc(0,(0));
N            pRadarInterface->setPowerStatusFunc(1,FALSE);
X            pRadarInterface->setPowerStatusFunc(1,(0));
N            
N            return TEST_FALSE;
X            return 0x10;
N        }
N        
N        pRadarInterface->setPowerStatusFunc(0,FALSE);
X        pRadarInterface->setPowerStatusFunc(0,(0));
N        pRadarInterface->setPowerStatusFunc(1,FALSE);
X        pRadarInterface->setPowerStatusFunc(1,(0));
N        
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N}
N
N
Nstatic BOOL sensorSingleTest(void* para1, void* para2)
N{
N    GPIO_SetBit(GPIOG, BIT7);
X    GPIO_SetBit(GPIOG, (0x00000080));
N    if(cameraTest(para1, para2) == FALSE)
X    if(cameraTest(para1, para2) == (0))
N    {
N        GPIO_ClrBit(GPIOG, BIT7);
X        GPIO_ClrBit(GPIOG, (0x00000080));
N        MTPString[29][3] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    GPIO_ClrBit(GPIOG, BIT7);
X    GPIO_ClrBit(GPIOG, (0x00000080));
N    MTPString[29][3] = 0x81;
N    
N    if(radarSingleTest(para1, para2) == FALSE)
X    if(radarSingleTest(para1, para2) == (0))
N        return FALSE;
X        return (0);
N    
N    //-------------Sensor UR3PwrCT & Sensor UR7PwrCT connect----------------------------
N    
N    
N    BOOL SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = FALSE;
X    BOOL SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = (0);
N    BOOL SensorUR7PwrCTHighSensorUR3PwrCTInFlag = FALSE;
X    BOOL SensorUR7PwrCTHighSensorUR3PwrCTInFlag = (0);
N    BOOL SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = FALSE;
X    BOOL SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = (0);
N    BOOL SensorUR7PwrCTInSensorUR3PwrCTHighFlag = FALSE;
X    BOOL SensorUR7PwrCTInSensorUR3PwrCTHighFlag = (0);
N
N    
N    //Set SensorUR7PwrCT(PB10) and SensorUR3PwrCT(PE11) GPIO
N    //Set SensorUR7PwrCT(PB10) output
N    GPIO_CloseBit(GPIOB, BIT10);
X    GPIO_CloseBit(GPIOB, (0x00000400));
N    GPIO_CloseBit(GPIOE, BIT11);
X    GPIO_CloseBit(GPIOE, (0x00000800));
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOB, BIT10, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000400), DIR_OUTPUT, PULL_UP);
N    //Set SensorUR3PwrCT(PE11) input
N    outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<< 12)) | (0<< 12));
X    *((volatile unsigned int *)((0xB0000000+0x094))) = ((*((volatile unsigned int *)((0xB0000000+0x094)))) & ~(0xF<< 12)) | (0<< 12);
N    GPIO_OpenBit(GPIOE, BIT11, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000800), DIR_INPUT, PULL_UP);
N    
N    //Set SensorUR7PwrCT(PB10) LOW
N    GPIO_ClrBit(GPIOB, BIT10);
X    GPIO_ClrBit(GPIOB, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOE, BIT11))
X    if(!GPIO_ReadBit(GPIOE, (0x00000800)))
N        SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = TRUE;
X        SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = (1);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTLowSensorUR3PwrCTInFlag success\r\n");
N    else
N        SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = FALSE;
X        SensorUR7PwrCTLowSensorUR3PwrCTInFlag  = (0);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTLowSensorUR3PwrCTInFlag error.\r\n");
N    
N    //Set SensorUR7PwrCT(PB10) HIGH
N    GPIO_SetBit(GPIOB, BIT10);
X    GPIO_SetBit(GPIOB, (0x00000400));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOE, BIT11))
X    if(GPIO_ReadBit(GPIOE, (0x00000800)))
N        SensorUR7PwrCTHighSensorUR3PwrCTInFlag = TRUE;
X        SensorUR7PwrCTHighSensorUR3PwrCTInFlag = (1);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTHighSensorUR3PwrCTInFlag success\r\n");
N    else
N        SensorUR7PwrCTHighSensorUR3PwrCTInFlag = FALSE;
X        SensorUR7PwrCTHighSensorUR3PwrCTInFlag = (0);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTHighSensorUR3PwrCTInFlag error.\r\n");
N    GPIO_CloseBit(GPIOE, BIT11);
X    GPIO_CloseBit(GPIOE, (0x00000800));
N    GPIO_CloseBit(GPIOB, BIT10);
X    GPIO_CloseBit(GPIOB, (0x00000400));
N    
N    
N    
N    //Set SensorUR7PwrCT(PB10) input
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x07C))) = ((*((volatile unsigned int *)((0xB0000000+0x07C)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOB, BIT10, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000400), DIR_INPUT, PULL_UP);
N    //Set SensorUR3PwrCT(PE11) output
N    outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<< 12)) | (0<< 12));
X    *((volatile unsigned int *)((0xB0000000+0x094))) = ((*((volatile unsigned int *)((0xB0000000+0x094)))) & ~(0xF<< 12)) | (0<< 12);
N    GPIO_OpenBit(GPIOE, BIT11, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOE, (0x00000800), DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorUR3PwrCT(PE11) LOW
N    GPIO_ClrBit(GPIOE, BIT11);
X    GPIO_ClrBit(GPIOE, (0x00000800));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT10))
X    if(!GPIO_ReadBit(GPIOB, (0x00000400)))
N        SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = TRUE;
X        SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = (1);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTInSensorUR3PwrCTLowFlag success\r\n");
N    else
N        SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = FALSE;
X        SensorUR7PwrCTInSensorUR3PwrCTLowFlag  = (0);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTInSensorUR3PwrCTLowFlag error.\r\n");
N    
N    
N    //Set SensorUR3PwrCT(PE11) HIGH
N    GPIO_SetBit(GPIOE, BIT11);
X    GPIO_SetBit(GPIOE, (0x00000800));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT10))
X    if(GPIO_ReadBit(GPIOB, (0x00000400)))
N        SensorUR7PwrCTInSensorUR3PwrCTHighFlag = TRUE;
X        SensorUR7PwrCTInSensorUR3PwrCTHighFlag = (1);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTInSensorUR3PwrCTHighFlag success\r\n");
N    else
N        SensorUR7PwrCTInSensorUR3PwrCTHighFlag = FALSE;
X        SensorUR7PwrCTInSensorUR3PwrCTHighFlag = (0);
N        //terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect SensorUR7PwrCTInSensorUR3PwrCTHighFlag error.\r\n");
N    GPIO_CloseBit(GPIOE, BIT11);
X    GPIO_CloseBit(GPIOE, (0x00000800));
N    GPIO_CloseBit(GPIOB, BIT10);
X    GPIO_CloseBit(GPIOB, (0x00000400));
N
N    
N    if(SensorUR7PwrCTLowSensorUR3PwrCTInFlag && SensorUR7PwrCTHighSensorUR3PwrCTInFlag &&
N       SensorUR7PwrCTInSensorUR3PwrCTLowFlag && SensorUR7PwrCTInSensorUR3PwrCTHighFlag)
N    {
N        terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect success\r\n");
N        IOtestResultFlag[17] = TRUE;
X        IOtestResultFlag[17] = (1);
N        MTPString[29][6] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Sensor UR3PwrCT & Sensor UR7PwrCT connect error.\r\n");
N        IOtestResultFlag[17] = FALSE;
X        IOtestResultFlag[17] = (0);
N        MTPString[29][6] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    
N    
N    //---------------------------end------------------------------
N    
N    
N    //-------------Sensor USB1ExSel & Sensor UR7ExSel connect----------------------------
N    
N    BOOL SensorUR7ExSelLowSensorUSB1ExSelInFlag  = FALSE;
X    BOOL SensorUR7ExSelLowSensorUSB1ExSelInFlag  = (0);
N    BOOL SensorUR7ExSelHighSensorUSB1ExSelInFlag = FALSE;
X    BOOL SensorUR7ExSelHighSensorUSB1ExSelInFlag = (0);
N    BOOL SensorUR7ExSelInSensorUSB1ExSelLowFlag  = FALSE;
X    BOOL SensorUR7ExSelInSensorUSB1ExSelLowFlag  = (0);
N    BOOL SensorUR7ExSelInSensorUSB1ExSelHighFlag = FALSE;
X    BOOL SensorUR7ExSelInSensorUSB1ExSelHighFlag = (0);
N
N    
N    GPIO_CloseBit(GPIOB, BIT1);
X    GPIO_CloseBit(GPIOB, (0x00000002));
N    GPIO_CloseBit(GPIOB, BIT2);
X    GPIO_CloseBit(GPIOB, (0x00000004));
N   //Set SensorUR7ExSel(PB1) and SensorUSB1ExSel(PB2) GPIO
N    //Set SensorUR7ExSel(PB1) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 4)) | (0<< 4));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 4)) | (0<< 4);
N    GPIO_OpenBit(GPIOB, BIT1, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000002), DIR_OUTPUT, PULL_UP);
N    //Set SensorUSB1ExSel(PB2) input
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOB, BIT2, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000004), DIR_INPUT, PULL_UP);
N    
N    //Set SensorUR7ExSel(PB1) LOW
N    GPIO_ClrBit(GPIOB, BIT1);
X    GPIO_ClrBit(GPIOB, (0x00000002));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT2))
X    if(!GPIO_ReadBit(GPIOB, (0x00000004)))
N    {
N        SensorUR7ExSelLowSensorUSB1ExSelInFlag  = TRUE;
X        SensorUR7ExSelLowSensorUSB1ExSelInFlag  = (1);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelLowSensorUSB1ExSelInFlag success\r\n");
N    }
N    else
N    {
N        SensorUR7ExSelLowSensorUSB1ExSelInFlag  = FALSE;
X        SensorUR7ExSelLowSensorUSB1ExSelInFlag  = (0);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelLowSensorUSB1ExSelInFlag error.\r\n");
N    }
N    //Set SensorUR7ExSel(PB1) HIGH
N    GPIO_SetBit(GPIOB, BIT1);
X    GPIO_SetBit(GPIOB, (0x00000002));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT2))
X    if(GPIO_ReadBit(GPIOB, (0x00000004)))
N    {
N        SensorUR7ExSelHighSensorUSB1ExSelInFlag = TRUE;
X        SensorUR7ExSelHighSensorUSB1ExSelInFlag = (1);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelHighSensorUSB1ExSelInFlag success\r\n");
N    }
N    else
N    {
N        SensorUR7ExSelHighSensorUSB1ExSelInFlag = FALSE;
X        SensorUR7ExSelHighSensorUSB1ExSelInFlag = (0);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelHighSensorUSB1ExSelInFlag error.\r\n");
N    }
N    GPIO_CloseBit(GPIOB, BIT1);
X    GPIO_CloseBit(GPIOB, (0x00000002));
N    GPIO_CloseBit(GPIOB, BIT2);
X    GPIO_CloseBit(GPIOB, (0x00000004));
N    
N    
N    
N    //Set SensorUR7ExSel(PB1) input
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 4)) | (0<< 4));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 4)) | (0<< 4);
N    GPIO_OpenBit(GPIOB, BIT1, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000002), DIR_INPUT, PULL_UP);
N    //Set SensorUSB1ExSel(PB2) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 8)) | (0<< 8));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 8)) | (0<< 8);
N    GPIO_OpenBit(GPIOB, BIT2, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000004), DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorUSB1ExSel(PB2) LOW
N    GPIO_ClrBit(GPIOB, BIT2);
X    GPIO_ClrBit(GPIOB, (0x00000004));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT1))
X    if(!GPIO_ReadBit(GPIOB, (0x00000002)))
N    {
N        SensorUR7ExSelInSensorUSB1ExSelLowFlag  = TRUE;
X        SensorUR7ExSelInSensorUSB1ExSelLowFlag  = (1);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelInSensorUSB1ExSelLowFlag success\r\n");
N    }
N    else
N    {
N        SensorUR7ExSelInSensorUSB1ExSelLowFlag  = FALSE;
X        SensorUR7ExSelInSensorUSB1ExSelLowFlag  = (0);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelInSensorUSB1ExSelLowFlag error.\r\n");
N    }
N    
N    //Set SensorUSB1ExSel(PB2) HIGH
N    GPIO_SetBit(GPIOB, BIT2);
X    GPIO_SetBit(GPIOB, (0x00000004));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT1))
X    if(GPIO_ReadBit(GPIOB, (0x00000002)))
N    {
N        SensorUR7ExSelInSensorUSB1ExSelHighFlag = TRUE;
X        SensorUR7ExSelInSensorUSB1ExSelHighFlag = (1);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelInSensorUSB1ExSelHighFlag success\r\n");
N    }
N    else
N    {
N        SensorUR7ExSelInSensorUSB1ExSelHighFlag = FALSE;
X        SensorUR7ExSelInSensorUSB1ExSelHighFlag = (0);
N        //terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect SensorUR7ExSelInSensorUSB1ExSelHighFlag error.\r\n");
N    }
N    GPIO_CloseBit(GPIOB, BIT1);
X    GPIO_CloseBit(GPIOB, (0x00000002));
N    GPIO_CloseBit(GPIOB, BIT2);
X    GPIO_CloseBit(GPIOB, (0x00000004));
N
N    
N    if(SensorUR7ExSelLowSensorUSB1ExSelInFlag && SensorUR7ExSelHighSensorUSB1ExSelInFlag &&
N       SensorUR7ExSelInSensorUSB1ExSelLowFlag && SensorUR7ExSelInSensorUSB1ExSelHighFlag)
N    {
N        terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect success\r\n");
N        IOtestResultFlag[18] = TRUE;
X        IOtestResultFlag[18] = (1);
N        MTPString[29][7] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Sensor USB1ExSel & Sensor UR7ExSel connect error.\r\n");
N        IOtestResultFlag[18] = FALSE;
X        IOtestResultFlag[18] = (0);
N        MTPString[29][7] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    //---------------------------end------------------------------
N    
N    
N    
N    //-------------Sensor USB1PwCT & Sensor UR3ExSel connect----------------------------
N    
N    BOOL SensorUR3ExSelLowSensorUSB1PwCTInFlag  = FALSE;
X    BOOL SensorUR3ExSelLowSensorUSB1PwCTInFlag  = (0);
N    BOOL SensorUR3ExSelHighSensorUSB1PwCTInFlag = FALSE;
X    BOOL SensorUR3ExSelHighSensorUSB1PwCTInFlag = (0);
N    BOOL SensorUR3ExSelInSensorUSB1PwCTLowFlag  = FALSE;
X    BOOL SensorUR3ExSelInSensorUSB1PwCTLowFlag  = (0);
N    BOOL SensorUR3ExSelInSensorUSB1PwCTHighFlag = FALSE;
X    BOOL SensorUR3ExSelInSensorUSB1PwCTHighFlag = (0);
N
N    
N    GPIO_CloseBit(GPIOB, BIT5);
X    GPIO_CloseBit(GPIOB, (0x00000020));
N    GPIO_CloseBit(GPIOB, BIT0);
X    GPIO_CloseBit(GPIOB, (0x00000001));
N   //Set SensorUR3ExSel(PB0) and SensorUSB1PwCT(PB5) GPIO
N    //Set SensorUR3ExSel(PB0) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 0)) | (0<< 0));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 0)) | (0<< 0);
N    GPIO_OpenBit(GPIOB, BIT0, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000001), DIR_OUTPUT, PULL_UP);
N    //Set SensorUSB1PwCT(PB5) input
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<20)) | (0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<20)) | (0<<20);
N    GPIO_OpenBit(GPIOB, BIT5, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000020), DIR_INPUT, PULL_UP);
N    
N    //Set SensorUR3ExSel(PB0) LOW
N    GPIO_ClrBit(GPIOB, BIT0);
X    GPIO_ClrBit(GPIOB, (0x00000001));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT5))
X    if(!GPIO_ReadBit(GPIOB, (0x00000020)))
N    {
N        SensorUR3ExSelLowSensorUSB1PwCTInFlag  = TRUE;
X        SensorUR3ExSelLowSensorUSB1PwCTInFlag  = (1);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelLowSensorUSB1PwCTInFlag success\r\n");
N    }
N    else
N    {
N        SensorUR3ExSelLowSensorUSB1PwCTInFlag  = FALSE;
X        SensorUR3ExSelLowSensorUSB1PwCTInFlag  = (0);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelLowSensorUSB1PwCTInFlag error.\r\n");
N    }
N    //Set SensorUR3ExSel(PB0) HIGH
N    GPIO_SetBit(GPIOB, BIT0);
X    GPIO_SetBit(GPIOB, (0x00000001));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT5))
X    if(GPIO_ReadBit(GPIOB, (0x00000020)))
N    {
N        SensorUR3ExSelHighSensorUSB1PwCTInFlag = TRUE;
X        SensorUR3ExSelHighSensorUSB1PwCTInFlag = (1);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelHighSensorUSB1PwCTInFlag success\r\n");
N    }
N    else
N    {
N        SensorUR3ExSelHighSensorUSB1PwCTInFlag = FALSE;
X        SensorUR3ExSelHighSensorUSB1PwCTInFlag = (0);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelHighSensorUSB1PwCTInFlag error.\r\n");
N    }
N    GPIO_CloseBit(GPIOB, BIT5);
X    GPIO_CloseBit(GPIOB, (0x00000020));
N    GPIO_CloseBit(GPIOB, BIT0);
X    GPIO_CloseBit(GPIOB, (0x00000001));
N    
N    
N    
N    //Set SensorUR3ExSel(PB0) input
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 0)) | (0<< 0));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 0)) | (0<< 0);
N    GPIO_OpenBit(GPIOB, BIT0, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000001), DIR_INPUT, PULL_UP);
N    //Set SensorUSB1PwCT(PB5) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<20)) | (0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<20)) | (0<<20);
N    GPIO_OpenBit(GPIOB, BIT5, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000020), DIR_OUTPUT, PULL_UP);
N        
N    //Set SensorUSB1PwCT(PB5) LOW
N    GPIO_ClrBit(GPIOB, BIT5);
X    GPIO_ClrBit(GPIOB, (0x00000020));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(!GPIO_ReadBit(GPIOB, BIT0))
X    if(!GPIO_ReadBit(GPIOB, (0x00000001)))
N    {
N        SensorUR3ExSelInSensorUSB1PwCTLowFlag  = TRUE;
X        SensorUR3ExSelInSensorUSB1PwCTLowFlag  = (1);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelInSensorUSB1PwCTLowFlag success\r\n");
N    }
N    else
N    {
N        SensorUR3ExSelInSensorUSB1PwCTLowFlag  = FALSE;
X        SensorUR3ExSelInSensorUSB1PwCTLowFlag  = (0);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelInSensorUSB1PwCTLowFlag error.\r\n");
N    }
N    
N    //Set SensorUSB1PwCT(PB5) HIGH
N    GPIO_SetBit(GPIOB, BIT5);
X    GPIO_SetBit(GPIOB, (0x00000020));
N    vTaskDelay(100/portTICK_RATE_MS);
X    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //userResponseLoop();
N    if(GPIO_ReadBit(GPIOB, BIT0))
X    if(GPIO_ReadBit(GPIOB, (0x00000001)))
N    {
N        SensorUR3ExSelInSensorUSB1PwCTHighFlag = TRUE;
X        SensorUR3ExSelInSensorUSB1PwCTHighFlag = (1);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelInSensorUSB1PwCTHighFlag success\r\n");
N    }
N    else
N    {
N        SensorUR3ExSelInSensorUSB1PwCTHighFlag = FALSE;
X        SensorUR3ExSelInSensorUSB1PwCTHighFlag = (0);
N        //terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect SensorUR3ExSelInSensorUSB1PwCTHighFlag error.\r\n");
N    }
N    GPIO_CloseBit(GPIOB, BIT5);
X    GPIO_CloseBit(GPIOB, (0x00000020));
N    GPIO_CloseBit(GPIOB, BIT0);
X    GPIO_CloseBit(GPIOB, (0x00000001));
N    //Set SensorUR3ExSel(PB0) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<< 0)) | (0<< 0));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<< 0)) | (0<< 0);
N    GPIO_OpenBit(GPIOB, BIT0, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000001), DIR_OUTPUT, PULL_UP);
N    //Set SensorUSB1PwCT(PB5) output
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<20)) | (0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<20)) | (0<<20);
N    GPIO_OpenBit(GPIOB, BIT5, DIR_OUTPUT, PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000020), DIR_OUTPUT, PULL_UP);
N
N    
N    if(SensorUR3ExSelLowSensorUSB1PwCTInFlag && SensorUR3ExSelHighSensorUSB1PwCTInFlag &&
N       SensorUR3ExSelInSensorUSB1PwCTLowFlag && SensorUR3ExSelInSensorUSB1PwCTHighFlag)
N    {
N        terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect success\r\n");
N        IOtestResultFlag[19] = TRUE;
X        IOtestResultFlag[19] = (1);
N        MTPString[29][8] = 0x81;
N    }
N    else
N    {
N        terninalPrintf("Sensor USB1PwCT & Sensor UR3ExSel connect error.\r\n");
N        IOtestResultFlag[19] = FALSE;
X        IOtestResultFlag[19] = (0);
N        MTPString[29][8] = 0x80;
N        return FALSE;
X        return (0);
N    }
N    
N    //---------------------------end------------------------------
N    
N    //-----------------------LED D2 test--------------------------
N    
N    BOOL LEDtestFlag = FALSE;
X    BOOL LEDtestFlag = (0);
N    char tempchar;
N    LEDColorBuffSet(0x02, 0x00);
N    LEDBoardLightSet();
N    SetMTPCRC(30,(uint8_t*)MTPString);
N    MTPCmdprint(30,(uint8_t*)MTPString);
N    terninalPrintf("Is the D2 light signal correct?(y/n)\r\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            terninalPrintf("Sensor SysPwr test success.\r\n");
N            LEDtestFlag = TRUE;
X            LEDtestFlag = (1);
N            MTPString[29][9] = 0x81;
N            break;
N        }
N        else if(tempchar =='n')
N        {
N            terninalPrintf("Sensor SysPwr test error.\r\n");
N            LEDtestFlag = FALSE;
X            LEDtestFlag = (0);
N            
N            LEDColorBuffSet(0x00, 0x00);
N            LEDBoardLightSet();
N            MTPString[29][9] = 0x80;
N            return FALSE;
X            return (0);
W "src\user\hwtester.c" 7637 13 statement is unreachable
N            break;
N        }
N    }
N    LEDColorBuffSet(0x00, 0x00);
N    LEDBoardLightSet();
N
N    
N
N    //---------------------------end------------------------------
N    
N
N    
N    if( IOtestResultFlag[5]  &&     //  radar UR3TX & radar UR7RX connect test result
N        IOtestResultFlag[6]  &&     //  radar UR7TX & radar UR3RX connect test result
N        IOtestResultFlag[7]  &&     //  camera1 test result
N        //IOtestResultFlag[8]  &&   //  camera2 test result
N        IOtestResultFlag[17] &&     //  Sensor UR3PwrCT & Sensor UR7PwrCT connect test result
N        IOtestResultFlag[18] &&     //  Sensor USB1ExSel & Sensor UR7ExSel connect test result
N        IOtestResultFlag[19] &&     //  Sensor USB1PwCT & Sensor UR3ExSel connect test result
N        LEDtestFlag             )   //  SysPwr test result
N    {
N        MTPString[29][10] = 0x81;
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    }
N    else
N    {
N        MTPString[29][10] = 0x80;
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;    
X            return 0x10;    
N    }
N}
N//////////////////////  Lidar test//////////////////////// single
Nstatic BOOL lidarSingleTest(void* para1, void* para2)
N{    
N    static RadarInterface* pRadarInterface;
N    BOOL changeFlag;
N    terninalPrintf("!!! lidarTest !!!\r\n");
N    guiPrintResult("Lidar");
N    pRadarInterface = RadarGetInterface(LIDAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(1);
N    terninalPrintf("Lidar Initial...");
N    guiPrintMessage("Lidar Initial...");
N    
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        //EPDDrawString(TRUE,"FAIL            \n                  ",X_POS_RST,Y_POS_RST);
N        terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    pRadarInterface->setPowerStatusFunc(0,TRUE);
X    pRadarInterface->setPowerStatusFunc(0,(1));
N    pRadarInterface->setPowerStatusFunc(1,TRUE);
X    pRadarInterface->setPowerStatusFunc(1,(1));
N    guiPrintMessage("Lidar0 Test...");
N    int featureValue = pRadarInterface->checkFeaturnFunc(0, &changeFlag, NULL, NULL, NULL);
X    int featureValue = pRadarInterface->checkFeaturnFunc(0, &changeFlag, 0, 0, 0);
N    if(featureValue==LIDAR_FEATURE_OCCUPIED || featureValue==LIDAR_FEATURE_VACUUM || featureValue==LIDAR_FEATURE_UN_STABLED)
X    if(featureValue==0x01 || featureValue==0x02 || featureValue==0x03)
N    {
N        guiPrintMessage("Lidar0 OK");
N        switch(featureValue)
N        {
N        case LIDAR_FEATURE_OCCUPIED:
X        case 0x01:
N            terninalPrintf("[LIDAR]0 ->  LIDAR_FEATURE_OCCUPIED!!\n" );
N            break;
N        case LIDAR_FEATURE_VACUUM:
X        case 0x02:
N            terninalPrintf("[LIDAR]0 ->  LIDAR_FEATURE_VACUUM!!\n" );
N            break;
N        case LIDAR_FEATURE_UN_STABLED:
X        case 0x03:
N            terninalPrintf("[LIDAR]0 ->  LIDAR_FEATURE_UN_STABLED!!\n" );
N            break; 
N        }
N    }
N    else
N    {
N        guiPrintMessage("Lidar0 TIMEOUT");
N        terninalPrintf("[LIDAR]0 ->  TIMEOUT!!\n" ); 
N        terninalPrintf("LidarTest [ERROR]\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    featureValue = pRadarInterface->checkFeaturnFunc(1, &changeFlag, NULL, NULL, NULL);
X    featureValue = pRadarInterface->checkFeaturnFunc(1, &changeFlag, 0, 0, 0);
N    if(featureValue==LIDAR_FEATURE_OCCUPIED || featureValue==LIDAR_FEATURE_VACUUM || featureValue==LIDAR_FEATURE_UN_STABLED)
X    if(featureValue==0x01 || featureValue==0x02 || featureValue==0x03)
N    {
N        guiPrintMessage("Lidar1 OK");
N        switch(featureValue)
N        {
N        case LIDAR_FEATURE_OCCUPIED:
X        case 0x01:
N            terninalPrintf("[LIDAR]1 ->  LIDAR_FEATURE_OCCUPIED!!\n" );
N            break;
N        case LIDAR_FEATURE_VACUUM:
X        case 0x02:
N            terninalPrintf("[LIDAR]1 ->  LIDAR_FEATURE_VACUUM!!\n" );
N            break;
N        case LIDAR_FEATURE_UN_STABLED:
X        case 0x03:
N            terninalPrintf("[LIDAR]1 ->  LIDAR_FEATURE_UN_STABLED!!\n" );
N            break; 
N        }
N    }
N    else
N    {
N        guiPrintMessage("Lidar1 TIMEOUT");
N        terninalPrintf("[LIDAR]1 ->  TIMEOUT!!\n" ); 
N        terninalPrintf("LidarTest [ERROR]\n");
N        return TEST_FALSE;
X        return 0x10;
N    }
N    return TEST_SUCCESSFUL_LIGHT_OFF;
X    return 0x12;
N}
N
N
N//////////////////toolsAdjustKeypad///////////////////////
N/*
Nstatic BOOL toolsAdjustKeypad(void* para1, void* para2)
N{    
N    setPrintfFlag(FALSE);
N    if(NT066EDrvInit(TRUE) == FALSE)
N    {
N        terninalPrintf("  AdjustKeypad [ERROR]\r\n");
N    }
N    else
N    {
N
N        //if(NT066EResetChip())
N        {
N            terninalPrintf("  AdjustKeypad [OK](set I2C1 to input)...(press 'q' to exit!!!)\r\n");
N            outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<8)) | (0x0<<8));//GPG2 input
N            outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<12)) | (0x0<<12));//GPG3 input
N            GPIO_OpenBit(GPIOG, BIT2, DIR_INPUT, NO_PULL_UP);
N            GPIO_OpenBit(GPIOG, BIT3, DIR_INPUT, NO_PULL_UP);
N            while(1)
N            {
N                if(sysIsKbHit())
N                {
N                    if(getTerminalChar() == 'q')
N                        break;
N                }
N                vTaskDelay(100/portTICK_RATE_MS);
N            }
N            terninalPrintf("  AdjustKeypad Exit(set I2C1 to function)\r\n");
N            outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<8)) | (0x8<<8));//GPG2 I2C1_SCL
N            outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<12)) | (0x8<<12));//GPG3 I2C1_SDA
N        }
N        //else
N        //{
N        //    terninalPrintf("  AdjustKeypad [ERROR]\r\n");
N        //}
N    }
N
N
N    setPrintfFlag(TRUE);
N    return TRUE;
N}
N//////////////////idConfig//////////////////////////////////////
Nstatic BOOL idConfig(void* para1, void* para2)
N{        
N    terninalPrintf("  idConfig...(press 'q' to exit!!!)\r\n");
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xFFFFF<<0)) | (0x00000u<<0));    
N    while(1)
N    {
N        UINT32 portValue = GPIO_ReadPort(GPIOJ);
N        terninalPrintf(" >> epmid:%d (0x%02x) (portValue = 0x%08x)\n",portValue&0x1F, portValue&0x1F, portValue);
N        if(userResponse()=='q'){
N            break;
N        }
N        vTaskDelay(100/portTICK_RATE_MS);
N    }
N    return TRUE;
N}
N//////////////////enable12vPower///////////////////////////////
Nstatic BOOL enable12vPower(void* para1, void* para2)
N{        
N    terninalPrintf("  12V power...(press 'q' to exit!!!)\r\n");
N    terninalPrintf("    1) turn ON\r\n");
N    terninalPrintf("    2) turn OFF\r\n");
N    outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<24)) | (0x0u<<24));  
N    GPIO_OpenBit(GPIOG, BIT6, DIR_OUTPUT, NO_PULL_UP); 
N    GPIO_ClrBit(GPIOG, BIT6);    
N
N    while(1)
N    {
N        if(sysIsKbHit())
N        {
N            char cmd = getTerminalChar();
N            switch(cmd)
N            {
N            case 'q':
N                return TRUE;
N            case '1':
N                terninalPrintf("--> turn ON (GPG6 high)\r\n");
N                GPIO_SetBit(GPIOG, BIT6); 
N                break;
N            case '2':
N                terninalPrintf("--> turn OFF (GPG6 low)\r\n");
N                GPIO_ClrBit(GPIOG, BIT6);    
N                break;
N            }
N        }
N        vTaskDelay(100/portTICK_RATE_MS);
N    }
N    return TRUE;
N}
N*/
Nstatic BOOL suspendSystem(void* para1, void* para2)
N{ 
N    
N    UINT32 reg;
N    char tempchar;
N    BOOL testFlag = FALSE;
X    BOOL testFlag = (0);
N    
N    //LEDColorBuffSet(0x00,0x01 );
N    //LEDBoardLightSet();
N    //vTaskDelay(100/portTICK_RATE_MS);
N    terninalPrintf("CPU enter sleep... \r\n");
N    //terninalPrintf("Please touch keypad to continue. \r\n");
N    terninalPrintf("Please wait 5 seconds to continue. \r\n");
N    SetMTPCRC(34,(uint8_t*)MTPString);
N    MTPCmdprint(34,(uint8_t*)MTPString);
N    vTaskDelay(500/portTICK_RATE_MS);
X    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //EPDSetBacklight(TRUE);
N
N    //userResponseLoop();
N    /*
N    GPIO_CloseBit(GPIOF, BIT14);
N    GPIO_CloseBit(GPIOI, BIT15);
N    GPIO_CloseBit(GPIOG, BIT9);
N    GPIO_CloseBit(GPIOF, BIT13);
N    GPIO_CloseBit(GPIOI, BIT4);
N    */
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0x9<<24));
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<<24)) | (0x9<<24);
W "src\user\hwtester.c" 7867 5 integer operation result is out of range
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0x0<<28));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<28)) | (0x0<<28);
N    GPIO_OpenBit(GPIOI, BIT15, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00008000), DIR_OUTPUT, NO_PULL_UP);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<4)) | (0x0<<4));
X    *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4)))) & ~(0xF<<4)) | (0x0<<4);
N    GPIO_OpenBit(GPIOG, BIT9, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOG, (0x00000200), DIR_OUTPUT, NO_PULL_UP);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0x9<<20)); 
X    *((volatile unsigned int *)((0xB0000000+0x09C))) = ((*((volatile unsigned int *)((0xB0000000+0x09C)))) & ~(0xF<<20)) | (0x9<<20); 
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x0B0))) = ((*((volatile unsigned int *)((0xB0000000+0x0B0)))) & ~(0xF<<16)) | (0x0<<16);
N    GPIO_OpenBit(GPIOI, BIT4, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00000010), DIR_OUTPUT, NO_PULL_UP);
N    
N    
N    //GPIO_SetBit(GPIOE, BIT7);   // close UART1 RS232 (debug) power
N    //GPIO_ClrBit(GPIOI, BIT15);  // close ReaderBoardSpareIO2
N    //GPIO_SetBit(GPIOG, BIT9);     // close UART2 RS232 & RS485 (Reader)power
N    //GPIO_ClrBit(GPIOF, BIT8);   // close LED power
N    GPIO_ClrBit(GPIOI, BIT1);   // close EPD power
X    GPIO_ClrBit(GPIOI, (0x00000002));   
N    GPIO_ClrBit(GPIOG, BIT7);
X    GPIO_ClrBit(GPIOG, (0x00000080));
N    //GPIO_SetBit(GPIOB, BIT6);   // sensor board power enable
N    //GPIO_SetBit(GPIOB, BIT3);  // close UART10 RS232 (CAD) power
N
N    //GPIO_SetBit(GPIOE, BIT8);   // close TouchKeyPwrCT
N    GPIO_ClrBit(GPIOF, BIT10);
X    GPIO_ClrBit(GPIOF, (0x00000400));
N    
N    //GPIO_SetBit(GPIOE,BIT14);
N    //vTaskDelay(100/portTICK_RATE_MS);
N    /*
N    GPIO_CloseBit(GPIOI, BIT0);
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<0)) | (0x0<<0));
N    GPIO_OpenBit(GPIOI, BIT0, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT5);
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<20)) | (0x0<<20));
N    GPIO_OpenBit(GPIOI, BIT5, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT6);
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOI, BIT6, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT7);
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<28)) | (0x0<<28));
N    GPIO_OpenBit(GPIOI, BIT7, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT8);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<0)) | (0x0<<0));
N    GPIO_OpenBit(GPIOI, BIT8, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT9);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<4)) | (0x0<<4));
N    GPIO_OpenBit(GPIOI, BIT9, DIR_INPUT, NO_PULL_UP);
N    */
N     /*   
N    GPIO_CloseBit(GPIOE, BIT0);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<0)) | (0x0<<0));
N    GPIO_OpenBit(GPIOE, BIT0, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOE, BIT1);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<4)) | (0x0<<4));
N    GPIO_OpenBit(GPIOE, BIT1, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOE, BIT2);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<8)) | (0x0<<8));
N    GPIO_OpenBit(GPIOE, BIT2, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOE, BIT3);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<12)) | (0x0<<12));
N    GPIO_OpenBit(GPIOE, BIT3, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOE, BIT4);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<16)) | (0x0<<16));
N    GPIO_OpenBit(GPIOE, BIT4, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOE, BIT5);
N    outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<20)) | (0x0<<20));
N    GPIO_OpenBit(GPIOE, BIT5, DIR_INPUT, NO_PULL_UP);
N    */
N    /*
N    GPIO_CloseBit(GPIOF, BIT11);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0x0<<12));
N    GPIO_OpenBit(GPIOF, BIT11, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOF, BIT12);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0x0<<16));
N    GPIO_OpenBit(GPIOF, BIT12, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOF, BIT13);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0x0<<20));
N    GPIO_OpenBit(GPIOF, BIT13, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOF, BIT14);
N    outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOF, BIT14, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOB, BIT7);
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<28)) | (0x0<<28));
N    GPIO_OpenBit(GPIOB, BIT7, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOB, BIT8);
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<<0)) | (0x0<<0));
N    GPIO_OpenBit(GPIOB, BIT8, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOB, BIT9);
N    outpw(REG_SYS_GPB_MFPH,(inpw(REG_SYS_GPB_MFPH) & ~(0xF<<4)) | (0x0<<4));
N    GPIO_OpenBit(GPIOB, BIT9, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOG, BIT10);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<8)) | (0x0<<8));
N    GPIO_OpenBit(GPIOG, BIT10, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOG, BIT11);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<12)) | (0x0<<12));
N    GPIO_OpenBit(GPIOG, BIT11, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOG, BIT12);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<16)) | (0x0<<16));
N    GPIO_OpenBit(GPIOG, BIT12, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOG, BIT13);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<20)) | (0x0<<20));
N    GPIO_OpenBit(GPIOG, BIT13, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOG, BIT14);
N    outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOG, BIT14, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT10);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<8)) | (0x0<<8));
N    GPIO_OpenBit(GPIOI, BIT10, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT11);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<12)) | (0x0<<12));
N    GPIO_OpenBit(GPIOI, BIT11, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT12);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<16)) | (0x0<<16));
N    GPIO_OpenBit(GPIOI, BIT12, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT13);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<20)) | (0x0<<20));
N    GPIO_OpenBit(GPIOI, BIT13, DIR_INPUT, NO_PULL_UP);
N    GPIO_CloseBit(GPIOI, BIT14);
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOI, BIT14, DIR_INPUT, NO_PULL_UP);
N    */
N    
N    
N    
N    GPIO_ClrBit(GPIOG, BIT6);
X    GPIO_ClrBit(GPIOG, (0x00000040));
N   // SleeptestFlag = TRUE;
N    //NT066ESetPower(TRUE);
N    
N    
N    RTC_Ioctl(0, RTC_IOC_SET_RELEATIVE_ALARM, 5, NULL);
X    RTC_Ioctl(0, RTC_IOC_SET_RELEATIVE_ALARM, 5, 0);
N    
N    
N    //RTC_Ioctl(0, RTC_IOC_SET_RELEATIVE_ALARM, 0xFFFFFFFF, NULL);
N    sysDelay(10/portTICK_RATE_MS);
X    sysDelay(10/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    outpw(REG_SYS_WKUPSSR , inpw(REG_SYS_WKUPSSR)); // clean wakeup status
X    *((volatile unsigned int *)((0xB0000000+0x05C))) = (*((volatile unsigned int *)((0xB0000000+0x05C)))); 
N
N    outpw(0xB00001FC, 0x59);
X    *((volatile unsigned int *)(0xB00001FC)) = 0x59;
N    outpw(0xB00001FC, 0x16);
X    *((volatile unsigned int *)(0xB00001FC)) = 0x16;
N    outpw(0xB00001FC, 0x88);
X    *((volatile unsigned int *)(0xB00001FC)) = 0x88;
N    while(!(inpw(0xB00001FC) & 0x1));
X    while(!((*((volatile unsigned int *)(0xB00001FC))) & 0x1));
N    
N    
N    //outpw(REG_SYS_WKUPSER , (1 << 2)| (1 << 3)| (1 << 4)| (1 << 1)|(1 << 24)); // wakeup source select DIP(EINT2, EINT3, EINT4) Keypad(EINT1) RTC
N    // outpw(REG_SYS_WKUPSER ,  (1 << 1)); // wakeup source select DIP(EINT2, EINT3, EINT4) Keypad(EINT1) RTC
N     outpw(REG_SYS_WKUPSER ,  (1 << 24)); // wakeup source select RTC
X     *((volatile unsigned int *)((0xB0000000+0x058))) = (1 << 24); 
N    
N    reg=inpw(REG_CLK_PMCON);   //Enable NUC970 to enter power down mode
X    reg=(*((volatile unsigned int *)((0xB0000200+0x00))));   
N    reg = reg & (0xFF00FFFE);
N    outpw(REG_CLK_PMCON,reg);
X    *((volatile unsigned int *)((0xB0000200+0x00))) = reg;
N    
N    
N    /*
N    terninalPrintf("Is CPU sleep?(y/n)\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            RTC_Ioctl(0, RTC_IOC_SET_RELEATIVE_ALARM, 1, NULL);
N            break;
N        }
N        else if(tempchar =='n')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            RTC_Ioctl(0, RTC_IOC_SET_RELEATIVE_ALARM, 1, NULL);
N            break;
N        }
N    }
N    */
N    
N      
N    __wfi();    
N
N    
N    outpw(REG_SYS_WKUPSER , 0); // wakeup source select NONE  
X    *((volatile unsigned int *)((0xB0000000+0x058))) = 0; 
N
N    PowerClearISR();
N    
N    //NT066ESetPower(FALSE);
N    
N    //GPIO_SetBit(GPIOF, BIT8);   // open LED power
N    //GPIO_ClrBit(GPIOE,BIT14);
N    GPIO_SetBit(GPIOG, BIT6);
X    GPIO_SetBit(GPIOG, (0x00000040));
N    //EPDSetBacklight(FALSE);
N    //LEDColorBuffSet(0x00,0x00 );
N    //LEDBoardLightSet();
N    //----recovery reader flash setting-----------
N    
N    GPIO_CloseBit(GPIOB, BIT7);
X    GPIO_CloseBit(GPIOB, (0x00000080));
N    GPIO_CloseBit(GPIOB, BIT8);
X    GPIO_CloseBit(GPIOB, (0x00000100));
N    GPIO_CloseBit(GPIOB, BIT9);
X    GPIO_CloseBit(GPIOB, (0x00000200));
N    
N    GPIO_CloseBit(GPIOI, BIT10);
X    GPIO_CloseBit(GPIOI, (0x00000400));
N    GPIO_CloseBit(GPIOI, BIT11);
X    GPIO_CloseBit(GPIOI, (0x00000800));
N    GPIO_CloseBit(GPIOI, BIT12);
X    GPIO_CloseBit(GPIOI, (0x00001000));
N    GPIO_CloseBit(GPIOI, BIT13);
X    GPIO_CloseBit(GPIOI, (0x00002000));
N    GPIO_CloseBit(GPIOI, BIT14);
X    GPIO_CloseBit(GPIOI, (0x00004000));
N
N    
N    SpiInterface* pSpiInterface;
N    pSpiInterface = SpiGetInterface(0);
N    pSpiInterface->initFunc();
N    
N    //GPI14 FLASH1 CS pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<24)) | (0x0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<24)) | (0x0<<24);
N    GPIO_OpenBit(GPIOI, BIT14, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00004000), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT14);
X    GPIO_SetBit(GPIOI, (0x00004000));
N    
N    //GPI13 FLASH1 CS pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<20)) | (0x0<<20));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<20)) | (0x0<<20);
N    GPIO_OpenBit(GPIOI, BIT13, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00002000), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT13);
X    GPIO_SetBit(GPIOI, (0x00002000));
N    
N    //GPI11 FLASH0 WP pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<12)) | (0x0<<12));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<12)) | (0x0<<12);
N    GPIO_OpenBit(GPIOI, BIT11, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00000800), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT11);
X    GPIO_SetBit(GPIOI, (0x00000800));
N    //GPI12 FLASH0 HD pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<16)) | (0x0<<16);
N    GPIO_OpenBit(GPIOI, BIT12, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00001000), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT12);
X    GPIO_SetBit(GPIOI, (0x00001000));
N    
N    /*
N    //GPI4 FLASH1 WP pin
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0x0<<16));
N    GPIO_OpenBit(GPIOI, BIT4, DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT4);
N
N
N    
N    //GPI15 FLASH1 HD pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xFu<<28)) | (0x0u<<28));
N    GPIO_OpenBit(GPIOI, BIT15, DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT15);
N    */
N    //---------------------------------------------------------------
N    
N    
N    
N
N    //BuzzerPlay(200, 500, 1, TRUE);
N    
N    //----recovery EPD setting-----------
N    
N    GPIO_CloseBit(GPIOI, BIT0);
X    GPIO_CloseBit(GPIOI, (0x00000001));
N    GPIO_CloseBit(GPIOI, BIT5);
X    GPIO_CloseBit(GPIOI, (0x00000020));
N    GPIO_CloseBit(GPIOI, BIT6);
X    GPIO_CloseBit(GPIOI, (0x00000040));
N    GPIO_CloseBit(GPIOI, BIT7);
X    GPIO_CloseBit(GPIOI, (0x00000080));
N    GPIO_CloseBit(GPIOI, BIT8);
X    GPIO_CloseBit(GPIOI, (0x00000100));
N    GPIO_CloseBit(GPIOI, BIT9);
X    GPIO_CloseBit(GPIOI, (0x00000200));
N
N    SpiInterface* EPDpSpiInterface;
N    EPDpSpiInterface = SpiGetInterface(1);
N    EPDpSpiInterface->initFunc();
N    
N
N    
N    //RDY Pin
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<4)) | (0x0<<4));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<4)) | (0x0<<4);
N    GPIO_OpenBit(GPIOI, BIT9, DIR_INPUT, PULL_UP);  
X    GPIO_OpenBit(GPIOI, (0x00000200), DIR_INPUT, PULL_UP);  
N    
N    //GPI0 reset pin
N    outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<0)) | (0x0<<0));
X    *((volatile unsigned int *)((0xB0000000+0x0B0))) = ((*((volatile unsigned int *)((0xB0000000+0x0B0)))) & ~(0xF<<0)) | (0x0<<0);
N    GPIO_OpenBit(GPIOI, BIT0, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00000001), DIR_OUTPUT, NO_PULL_UP);
N    GPIO_SetBit(GPIOI, BIT0); 
X    GPIO_SetBit(GPIOI, (0x00000001)); 
N    
N    EPDpSpiInterface->setPin();
N
N
N    GPIO_SetBit(GPIOI, BIT1);   // open EPD power
X    GPIO_SetBit(GPIOI, (0x00000002));   
N    //ReadIT8951SystemInfo( NULL, NULL);
N    
N    GPIO_ClrBit(GPIOI, BIT0); 
X    GPIO_ClrBit(GPIOI, (0x00000001)); 
N   
N    sysDelay(1000/portTICK_RATE_MS);
X    sysDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //ReloadWWDT();
N    sysDelay(1000/portTICK_RATE_MS);
X    sysDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //ReloadWWDT();
N    sysDelay(1000/portTICK_RATE_MS);
X    sysDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N    GPIO_SetBit(GPIOI, BIT0); 
X    GPIO_SetBit(GPIOI, (0x00000001)); 
N    
N    
N    
N    //----------------------------------
N
N    //SleeptestFlag = FALSE;
N    /*
N    if(tempchar =='y')
N    {
N        //outpw(REG_CLK_PMCON,reg | 0x01);
N        return TEST_SUCCESSFUL_LIGHT_OFF;
N    }
N    else if(tempchar =='n')
N    {
N        //outpw(REG_CLK_PMCON,reg | 0x01);
N        return TEST_FALSE;
N    }
N    */
N    SetMTPCRC(35,(uint8_t*)MTPString);
N    MTPCmdprint(35,(uint8_t*)MTPString);
N    terninalPrintf("Is CPU sleep?(y/n)\r\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            MTPString[33][3] = 0x81;
N            testFlag = TRUE;
X            testFlag = (1);
N            break;
N            //return TEST_SUCCESSFUL_LIGHT_OFF;
N        }
N        else if(tempchar =='n')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            MTPString[33][3] = 0x80;
N            testFlag = FALSE;
X            testFlag = (0);
N            break;
N            //if(MBtestFlag )
N            //    return FALSE;
N            //else
N            //    return TEST_FALSE;
N            
N        }
N    }
N    
N
N    
N    
N    if(testFlag)
N        return TEST_SUCCESSFUL_LIGHT_OFF;
X        return 0x12;
N    else
N    {
N        if(MBtestFlag )
N            return FALSE;
X            return (0);
N        else
N            return TEST_FALSE;
X            return 0x10;
N    }
N    
N    /*
N    UINT32 reg;
N    char tempchar;
N    
N    terninalPrintf("  suspendSystem\r\n");
N    setPrintfFlag(FALSE);
N    PowerSuspend(0xffffffff); 
N    //PowerClearISR(); 
N    setPrintfFlag(TRUE);
N    terninalPrintf("Is CPU sleep?(y/n)\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='y')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            return TEST_SUCCESSFUL_LIGHT_OFF;
N        }
N        else if(tempchar =='n')
N        {
N            //outpw(REG_CLK_PMCON,reg | 0x01);
N            return TEST_FALSE;
N        }
N    }
N    */
N    
N    /*
N    terninalPrintf("  suspendSystem\r\n");
N    //setPrintfFlag(FALSE);
N    PowerSuspend(0xffffffff); 
N    PowerClearISR(); 
N    //setPrintfFlag(TRUE);
N    return TRUE;
N    */
N    
N}
N
N/*
Nstatic BOOL batterySelect(void* para1, void* para2)
N{        
N    terninalPrintf("  batterySelect...(press 'q' to exit!!!)\r\n");
N    terninalPrintf("    1) Battery 1 ON\r\n");
N    terninalPrintf("    2) Battery 1 OFF\r\n");
N    terninalPrintf("    3) Battery 2 ON\r\n");
N    terninalPrintf("    4) Battery 2 OFF\r\n");
N    setPrintfFlag(FALSE);  
N    if(BatteryDrvInit(TRUE))
N    {    
N        while(1)
N        {
N            if(sysIsKbHit())
N            {
N                char cmd = getTerminalChar();
N                switch(cmd)
N                {
N                case 'q':
N                    return TRUE;
N                case '1':
N                    terninalPrintf("--> Battery 1 ON\r\n");
N                    BatterySetSwitch1(TRUE); 
N                    break;
N                case '2':
N                    terninalPrintf("--> Battery 1 OFF\r\n");
N                    BatterySetSwitch1(FALSE);     
N                    break;
N                case '3':
N                    terninalPrintf("--> Battery 2 ON\r\n");
N                    BatterySetSwitch2(TRUE); 
N                    break;
N                case '4':
N                    terninalPrintf("--> Battery 2 OFF\r\n");
N                    BatterySetSwitch2(FALSE);     
N                    break;
N                }
N            }
N            vTaskDelay(100/portTICK_RATE_MS);
N        }
N    }
N    setPrintfFlag(TRUE);
N    return TRUE;
N}
N
Nstatic BOOL buzzerLoop(void* para1, void* para2)
N{        
N    terninalPrintf("  buzzerLoop...(press 'q' to exit!!!)\r\n");
N    if(BuzzerDrvInit(TRUE))
N    {    
N        while(1)
N        {
N            if(sysIsKbHit())
N            {
N                char cmd = getTerminalChar();
N                switch(cmd)
N                {
N                case 'q':
N                    return TRUE;                    
N                }
N            }
N            BuzzerPlay(500, 0, 1, TRUE);
N            vTaskDelay(1000/portTICK_RATE_MS);
N        }
N    }
N    return TRUE;
N}
N*/
N/********************************************************************************
N *                                    TOOL                                      *
N ********************************************************************************/
N/*  1   */
N/////////////////////////////////DEVICE ID////////////////////////////////
Nstatic BOOL setDeviceIDTool(void* para1, void* para2){
N
N    guiManagerShowScreen(GUI_SETTING_ID, GUI_REDRAW_PARA_REFRESH, 0, 0);
X    guiManagerShowScreen(19, 0x03, 0, 0);
N    if(!FlashDrvExInit(FALSE)){
X    if(!FlashDrvExInit((0))){
N        terninalPrintf("No Flash [Error]!!!\r\n");
N        BuzzerPlay(200,50,4,FALSE);
X        BuzzerPlay(200,50,4,(0));
N        LEDColorBuffSet(0x00,0xff);
N        LEDBoardLightSet();
N        vTaskDelay(700/portTICK_RATE_MS);
X        vTaskDelay(700/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        return FALSE;
X        return (0);
N    }
N    char charTmp;
N    unsigned int idTmp=0,i=0;
N    terninalPrintf("Current Device ID: %05d\nPlease Enter 5 Digit Number To Set Device ID\n",getDeviceID(0,0));
N    terninalPrintf("Press 'q' to quit without save...\n");
N    while(1){
N        charTmp=userResponseLoop();
N        if(charTmp>='0'&&charTmp<='9')
N        {
N            idTmp=idTmp*10;
N            idTmp+=(charTmp-'0');
N            i++;
N            terninalPrintf("%c",charTmp);
N        }
N        if(charTmp=='y')
N        {
N            setDeviceID(&epmIDSet,NULL);//empIDSet is set by guisettingid
X            setDeviceID(&epmIDSet,0);
N            break;
N        }
N        if(charTmp=='q')
N        {
N            break;
N        }
N        if(i==5)
N        {
N            setDeviceID(&idTmp,NULL);
X            setDeviceID(&idTmp,0);
N            break;
N        }
N    }
N    return TRUE;
X    return (1);
N}
N
Nstatic BOOL setDeviceID(void* para1, void* para2)
N{    
N    FlashDrvExInit(FALSE);
X    FlashDrvExInit((0));
N    
N    int epmID = *(int*)para1 ;
N
N    if(SFlashSaveStorage(SFLASH_STORAGE_EPM_SERIAL_ID_INDEX_BASE, (uint8_t*)&epmID, sizeof(epmID)))
X    if(SFlashSaveStorage(0, (uint8_t*)&epmID, sizeof(epmID)))
N    {
N        terninalPrintf(" >> setDeviceID:%05d (to SFlash Record) write OK\n", epmID);
N    }
N    return TRUE;
X    return (1);
N}
N/*  2   */
Nstatic BOOL getDeviceIDTool(void* para1, void* para2)
N{
N    guiManagerShowScreen(GUI_SETTING_ID, GUI_REDRAW_PARA_REFRESH, 0,GET_ID_MODE);
X    guiManagerShowScreen(19, 0x03, 0,1);
N    terninalPrintf(" >> Getting DeviceID...\n");
N    int epmid=getDeviceID(0,0);
N    terninalPrintf(" >> getDeviceIDTool:%d (from SFlash Record)\n", epmid);
N    terninalPrintf("Press 'q' to exit\r\n");
N    while(1)
N    {
N        if(userResponse()=='q')
N            break;
N        vTaskDelay(300/portTICK_RATE_MS);
X        vTaskDelay(300/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    }
N    return TRUE;
X    return (1);
N}
Nstatic int getDeviceID(void* para1, void* para2)
N{
N    int epmid;
N    FlashDrvExInit(FALSE);
X    FlashDrvExInit((0));
N    if(SFlashLoadStorage(SFLASH_STORAGE_EPM_SERIAL_ID_INDEX_BASE, (uint8_t*)&epmid, sizeof(epmid)))
X    if(SFlashLoadStorage(0, (uint8_t*)&epmid, sizeof(epmid)))
N    {  
N        terninalPrintf(" >> getDeviceID:%05d (from SFlash Record) read OK\n", epmid);
N    }
N    return epmid;
N}
N/*  3   */
N///////////////////////////CARD READER////////////////////////////////
N#define X_MARGIN_LODING 312
N#define Y_MARGIN_LODING 298
N
Nstatic void setCNResultCallback(BOOL flag, uint8_t* cn, int cnLen)
N{
N    static BOOL prevFlag = FALSE; 
X    static BOOL prevFlag = (0); 
N    if(prevFlag != flag)
N    {
N        if(flag)
N        {
N            BuzzerPlay(200, 2, 1, FALSE);
X            BuzzerPlay(200, 2, 1, (0));
N            uint32_t tmpCardID=0;
N            terninalPrintf("Detect Card!\nCard ID:%02X%02X%02X%02X\n\n",cn[0],cn[1],cn[2],cn[3]);
N            for(int i = 0; i<cnLen; i++)
N            {
N                uint32_t tmpByte = cn[i];
N                tmpCardID = tmpCardID | tmpByte << 8*(cnLen-i-1);
N            }
N            cardID=tmpCardID;
N            //terninalPrintf("\r\n");
N            //show id at epd
N            for(int i=0;i<8;i++)
N            {
N                if(i<7)
N                    EPDDrawMulti(FALSE,((cardID>>(28-(i*4)))&0xf) + EPD_PICT_NUM_SMALL_INDEX,500+(i*50),454);
X                    EPDDrawMulti((0),((cardID>>(28-(i*4)))&0xf) + EPD_PICT_NUM_SMALL_INDEX,500+(i*50),454);
N                else if(i==7)
N                    EPDDrawMulti(TRUE,((cardID>>(28-(i*4)))&0xf) + EPD_PICT_NUM_SMALL_INDEX,500+(i*50),454);
X                    EPDDrawMulti((1),((cardID>>(28-(i*4)))&0xf) + EPD_PICT_NUM_SMALL_INDEX,500+(i*50),454);
N            }
N        }
N        else
N        {//clean screen
N            terninalPrintf("Please tag your card again\n");
N            cardID=0; 
N            for(int i=0;i<8;i++)
N            {
N                EPDDrawString(FALSE,"  ",500+(i*50),454);
X                EPDDrawString((0),"  ",500+(i*50),454);
N                EPDDrawString(FALSE,"  ",500+(i*50),498);
X                EPDDrawString((0),"  ",500+(i*50),498);
N            }
N            EPDDrawString(TRUE,"  ",500,454);
X            EPDDrawString((1),"  ",500,454);
N        }
N    }
N//    terninalPrintf(".");
N    prevFlag = flag;
N}
N
Nstatic BOOL readerGetCN(void* para1, void* para2)
N{    
N    guiManagerShowScreen(GUI_SHOW_CARD_ID, GUI_REDRAW_PARA_REFRESH, 0, 0);
X    guiManagerShowScreen(20, 0x03, 0, 0);
N    int waitCounter = 30;
N    int iCount=0;
N//    uint16_t uID;
N    terninalPrintf("!!! readerGetCN !!!\r\n");
N    CardReaderInit(TRUE);
X    CardReaderInit((1));
N    CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
X    CardReaderSetPower(0, (1));
N    terninalPrintf("READER CHECK ");
N    while(CardReaderGetBootedStatus() != TSREADER_CHECK_READER_OK)
X    while(CardReaderGetBootedStatus() != 2)
N    {
N        terninalPrintf(".");
N        if(iCount==4)
N        {
N            iCount=0;
N            EPDDrawString(TRUE,"          ",X_MARGIN_LODING,Y_MARGIN_LODING);
X            EPDDrawString((1),"          ",312,298);
N        }
N        EPDDrawString(TRUE,".",X_MARGIN_LODING+(iCount*28),Y_MARGIN_LODING);
X        EPDDrawString((1),".",312+(iCount*28),298);
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        waitCounter--;
N        iCount++;
N        if(waitCounter == 0)
N        {
N            terninalPrintf("\nCHECK READER [Time Out]\n");
N            break;
N        }
N    }
N    EPDDrawString(TRUE,"          ",X_MARGIN_LODING,Y_MARGIN_LODING);
X    EPDDrawString((1),"          ",312,298);
N    vTaskDelay(1000/portTICK_RATE_MS);
X    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    BuzzerPlay(500, 2, 2, TRUE);
X    BuzzerPlay(500, 2, 2, (1));
N    EPDDrawString(TRUE,"Please tag your card        ",240,254);
X    EPDDrawString((1),"Please tag your card        ",240,254);
N    terninalPrintf("\nPlease tag your card\nPress 'q' To Quit...\n");
N    while(CardReaderGetBootedStatus() == TSREADER_CHECK_READER_OK)
X    while(CardReaderGetBootedStatus() == 2)
N    {
N        CardReaderProcessCN(setCNResultCallback);
N        if(userResponse()=='q')
N        {
N            break;
N        }
N    }
N    return TRUE;
X    return (1);
N}
N
N///////////////////////////CAM   Test/////////////////////////////////
N/*Globa Val*/
N#define CAM_MSG_X 180
N#define CAM_MSG_Y 250
N
Nstatic BOOL usbCamTest(void* para1, void* para2)
N{
N/*
N    int  SDbufferSize = 128 ;
N    uint8_t SDbuffer[SDbufferSize];
N    FIL filephoto;
N    char * PhotoFileNameStr;
N    UINT br;
N    
N    int count ;
N    int remain ;
N    int progress ;
N
N    
N    if(!UserDrvInit(FALSE))
N    {
N        terninalPrintf("UserDrvInit fail.\r\n");
N        return FALSE;
N    }
N    if(!FatfsInit(TRUE))
N    {
N        terninalPrintf("FatfsInit fail.\r\n");
N        return FALSE;
N    }
N    */
N    int count ;
N    int remain ;
N    int progress ;
N    
N    guiManagerShowScreen(GUI_USB_CAM_ID, GUI_REDRAW_PARA_REFRESH, 0, 0);
X    guiManagerShowScreen(22, 0x03, 0, 0);
N    static CameraInterface*     pCameraInterface = NULL;
X    static CameraInterface*     pCameraInterface = 0;
N    terninalPrintf("!!! usbCamTest !!!\r\n");
N//    setPrintfFlag(FALSE)
N    pCameraInterface = CameraGetInterface(CAMERA_UVC_INTERFACE_INDEX);
X    pCameraInterface = CameraGetInterface(0);
N    if(pCameraInterface == NULL)
X    if(pCameraInterface == 0)
N    {
N        sysprintf("usbCamTest ERROR (pCameraInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pCameraInterface->initFunc(FALSE) == FALSE)
X    if(pCameraInterface->initFunc((0)) == (0))
N    {
N        sysprintf("usbCamTest ERROR (pCameraInterface->initFunc(FALSE) == FALSE)!!\n");
N        return FALSE;
X        return (0);
N    }
N    int okCounter[2] = {0};
N    int errorCounter[2] = {0};
N    uint8_t* photoPr ;
N    //uint8_t tempPr[3];
N    //uint8_t photoPr[100000];
N    int photoLen = 0;
N    char targetFileNameTmp[_MAX_LFN];
X    char targetFileNameTmp[255];
N    memset(targetFileNameTmp, 0x0, sizeof(targetFileNameTmp));
N    
N    sprintf(targetFileNameTmp,"uvcphoto.%s", PHOTO_FILE_EXTENSION); 
X    sprintf(targetFileNameTmp,"uvcphoto.%s", "jpg"); 
N    vTaskDelay(3000/portTICK_RATE_MS);
X    vTaskDelay(3000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    terninalPrintf("Press 'q' to Exit\r\n");
N    EPDDrawString(TRUE,"Testing   ",CAM_MSG_X,CAM_MSG_Y);
X    EPDDrawString((1),"Testing   ",180,250);
N    while(1)
N    {   
N        for(int i = 0; i<2; i++)
N        {
N//            setPrintfFlag(FALSE); 
N            EPDDrawString(TRUE,"Testing   ",CAM_MSG_X+(i*400),CAM_MSG_Y);
X            EPDDrawString((1),"Testing   ",180+(i*400),250);
N            if(pCameraInterface->takePhotoFunc((1-i), &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, FALSE,1,0))
X            if(pCameraInterface->takePhotoFunc((1-i), &photoPr, &photoLen, FILE_AGENT_STORAGE_TYPE_FATFS, "0:", targetFileNameTmp, (0),1,0))
N            {
N                EPDDrawString(TRUE,"OK          ",CAM_MSG_X+(i*400),CAM_MSG_Y);
X                EPDDrawString((1),"OK          ",180+(i*400),250);
N                terninalPrintf("  cameraTest _%d (%s) [OK] photoLen = %d\r\n", i+1, targetFileNameTmp,photoLen);
N                
N                if(!GPIO_ReadBit(GPIOJ, BIT3))
X                if(!GPIO_ReadBit(GPIOJ, (0x00000008)))
N                {
N                    count = photoLen / PHOTOBUFFERSIZE;
X                    count = photoLen / 256;
N                    remain = photoLen % PHOTOBUFFERSIZE;
X                    remain = photoLen % 256;
N                    progress = count / 10 ;
N                    terninalPrintf("count = %d\r\n",count);
N                    terninalPrintf("remain = %d\r\n",remain);
N                    terninalPrintf("progress = %d\r\n",progress);
N                    
N                    OpenCamPhoto(i);
N                    
N                    for(int m=0;m<count;m++)
N                    {
N                        if(m%progress == 0)
N                        {
N                            terninalPrintf("%d%% complete...\r",(m/progress)*10);
N                        }
N                        
N                        for(int j=0;j<PHOTOBUFFERSIZE;j++)
X                        for(int j=0;j<256;j++)
N                        //for(int j=0;j<256;j++)
N                        {
N                            //terninalPrintf("%02x ",*(photoPr+j));
N                            tempPr[j] = *(photoPr+m*PHOTOBUFFERSIZE+j);
X                            tempPr[j] = *(photoPr+m*256+j);
N                        }
N                        
N                        SaveCamPhoto(i,NULL,PHOTOBUFFERSIZE);
X                        SaveCamPhoto(i,0,256);
N
N                        
N                    }
N                    
N                    if(remain != 0)
N                    {   
N                        
N                        for(int j=0;j<remain;j++)
N                        //for(int j=0;j<256;j++)
N                        {
N                            //terninalPrintf("%02x ",*(photoPr+j));
N                            tempPr[j] = *(photoPr+count*PHOTOBUFFERSIZE+j);
X                            tempPr[j] = *(photoPr+count*256+j);
N                        }
N                        
N                        SaveCamPhoto(i,NULL,remain);
X                        SaveCamPhoto(i,0,remain);
N     
N                    }
N                    
N                    CloseCamPhoto();
N                    
N                    /*
N                    //terninalPrintf("photoPr = ");
N                    for(int j=0;j<photoLen;j++)
N                    //for(int j=0;j<256;j++)
N                    {
N                        //terninalPrintf("%02x ",*(photoPr+j));
N                        tempPr[j] = *(photoPr+j);
N                    }
N                    
N                    */
N                    //terninalPrintf("\r\n");
N                    
N                    //terninalPrintf("photoPrAdd = %08x\r\n",photoPr);
N                    
N                    //SaveCamPhoto(i,photoPr,photoLen);
N
N                        //tempPr[0] = i+1;
N                        //tempPr[1] = i+1;
N                        //tempPr[2] = i+1;
N                    //PhotoBuffFunc(tempPr,3);
N                    
N                    
N                    
N                    
N                    //SaveCamPhoto(i,NULL,photoLen);
N                    //SaveCamPhoto(i,NULL,256);
N                }
N
N                
N                
N                
N                
N                
N                
N                okCounter[i]++;
N            }
N            else
N            {
N                EPDDrawString(TRUE,"FAIL       ",CAM_MSG_X+(i*400),CAM_MSG_Y);
X                EPDDrawString((1),"FAIL       ",180+(i*400),250);
N                terninalPrintf("  cameraTest _%d [ERROR]\r\n", i+1);
N                errorCounter[i]++;
N            }
N            terninalPrintf("**************************************************\r\n\r\n", i);
N            if(userResponse()=='q')
N            {
N                return TRUE;
X                return (1);
N            }
N        }
N        terninalPrintf("==== Cam_1-> OK:%d, ERROR:%d ====\r\n", okCounter[0], errorCounter[0]);  
N        terninalPrintf("==== Cam_2-> OK:%d, ERROR:%d ====\r\n", okCounter[1], errorCounter[1]);  
N        //vTaskDelay(20000/portTICK_RATE_MS);
N        vTaskDelay(2000/portTICK_RATE_MS);
X        vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    }
N}
N#define CAM_0_ON_OFF_X 480
N#define CAM_0_ON_OFF_Y 250
N#define CAM_1_ON_OFF_X 480
N#define CAM_1_ON_OFF_Y 300
Nstatic BOOL usbCamPowerSet(void* para1, void* para2)
N{   //init//
N    BOOL camStatus[2]={TRUE,FALSE};
X    BOOL camStatus[2]={(1),(0)};
N    BOOL changeFlag;
N    char* boolConvString[2]={" OFF "," ON  "};
N    guiManagerShowScreen(GUI_USB_CAM_ID, GUI_REDRAW_PARA_REFRESH, 0, POWER_SET_MODE);
X    guiManagerShowScreen(22, 0x03, 0, 1);
N    static CameraInterface* pCameraInterface;
N    char tmp;
N    terninalPrintf("!!! usbCamPowerSet !!!\r\n");
N    pCameraInterface = CameraGetInterface(CAMERA_UVC_INTERFACE_INDEX);
X    pCameraInterface = CameraGetInterface(0);
N    if(pCameraInterface == NULL)
X    if(pCameraInterface == 0)
N    {
N        terninalPrintf("CamTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pCameraInterface->initFunc(FALSE) == FALSE)
X    if(pCameraInterface->initFunc((0)) == (0))
N    {
N        terninalPrintf("CamTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    //pCameraInterface->setPowerFunc(0,camStatus[0]);
N    pCameraInterface->setPowerFunc(1,camStatus[0]);
N    //end init//
N    EPDDrawStringMax(FALSE,boolConvString[camStatus[0]],CAM_0_ON_OFF_X,CAM_0_ON_OFF_Y,FALSE);
X    EPDDrawStringMax((0),boolConvString[camStatus[0]],480,250,(0));
N    EPDDrawStringMax(TRUE ,boolConvString[camStatus[1]],CAM_1_ON_OFF_X,CAM_1_ON_OFF_Y,TRUE);
X    EPDDrawStringMax((1) ,boolConvString[camStatus[1]],480,300,(1));
N    //terninalPrintf("Now Power Status:('q' to exit)\n0->set Cam0\n1->set Cam1\n");
N    terninalPrintf("Now Power Status:('q' to exit)\n1->set Cam1\n2->set Cam2\n");
N    //terninalPrintf("Cam0[%s]  Cam1[%s]",boolConvString[camStatus[0]],boolConvString[camStatus[1]]);
N    terninalPrintf("Cam1[%s]  Cam2[%s]",boolConvString[camStatus[0]],boolConvString[camStatus[1]]);
N    while(1)
N    {
N        tmp=userResponseLoop();
N        //setPrintfFlag(FALSE);
N        if(tmp=='q')
N        {
N            break;
N        }
N        //else if(tmp=='0')
N        else if(tmp=='1')
N        {
N            camStatus[0] =!camStatus[0];
N            camStatus[1] = FALSE;
X            camStatus[1] = (0);
N            //pCameraInterface->setPowerFunc(0,camStatus[0]);
N            pCameraInterface->setPowerFunc(1,camStatus[0]);
N        }
N        else if(tmp=='2')
N        //else if(tmp=='2')
N        {
N            camStatus[1] =!camStatus[1];
N            camStatus[0] = FALSE;
X            camStatus[0] = (0);
N            //pCameraInterface->setPowerFunc(1,camStatus[1]);
N            pCameraInterface->setPowerFunc(0,camStatus[1]);
N        }
N        //terninalPrintf("\rCam0[%s]  Cam1[%s]",boolConvString[camStatus[0]],boolConvString[camStatus[1]]);
N        terninalPrintf("\rCam1[%s]  Cam2[%s]",boolConvString[camStatus[0]],boolConvString[camStatus[1]]);
N        EPDDrawString(FALSE,boolConvString[camStatus[0]],CAM_0_ON_OFF_X,CAM_0_ON_OFF_Y);
X        EPDDrawString((0),boolConvString[camStatus[0]],480,250);
N        EPDDrawString(TRUE ,boolConvString[camStatus[1]],CAM_1_ON_OFF_X,CAM_1_ON_OFF_Y);
X        EPDDrawString((1) ,boolConvString[camStatus[1]],480,300);
N        //setPrintfFlag(TRUE); 
N    }
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 8664 10 variable "changeFlag" was declared but never referenced
N}
N
N///////////////////////////RADAR Test/////////////////////////////////
N/*Globa Val*/
N#define RADAR_MSG_X 50  //80 //180
N#define RADAR_MSG_Y 250
N#define RADAR_INTERVAL 500  //400
Nstatic BOOL NEWradarSet(void* para1, void* para2)
N{
N    int featureValue;
N    uint8_t RadarData[22];
N    uint8_t ReadCmd[24]   = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
N                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
N                             0x00, 0x1A, 0xD3, 0x3D};
N                             
N    uint8_t ResultCmd[24] = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 
N                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
N                             0x00, 0x1B, 0xD3, 0x3D};
N                             
N    uint16_t   setIndex,setXval,setYval,setLval,setWval,setHval,setThetaval,setPhival,setLR,setFR;                              
N    uint16_t   *setIndexPtr = para1;          
N    //uint16_t   *setFRtypePtr = para2;                             
N    static RadarInterface* pRadarInterface;
N    pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(2);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("NEWradarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("NEWradarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    
N    setIndex = *setIndexPtr;
N    
N    /*
N    terninalPrintf("Please enter radar index in decimal.(1~2)\r\n");
N    terninalPrintf("Enter number is ");
N    setIndex = SetValue(1);
N    setIndex--;
N    if((setIndex == 0xffff) || ((setIndex != 0)&&(setIndex != 1)))
N        return TEST_FALSE;
N    */
N    terninalPrintf("\r\nPlease enter X parameters in decimal.(unit:cm)\r\n");
N    terninalPrintf("Enter number is ");
N    setXval = SetValue(5);
N    if(setXval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[6] = setXval >> 8;
N    ResultCmd[7] = setXval & 0x00FF;
N    
N    terninalPrintf("\r\nPlease enter Y parameters in decimal.(unit:cm)\r\n");
N    terninalPrintf("Enter number is ");
N    setYval = SetValue(5);
N    if(setYval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[8] = setYval >> 8;
N    ResultCmd[9] = setYval & 0x00FF;   
N    
N    
N    terninalPrintf("\r\nPlease enter L parameters in decimal.(unit:cm)\r\n");
N    terninalPrintf("Enter number is ");
N    setLval = SetValue(5);
N    if(setLval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[10] = setLval >> 8;
N    ResultCmd[11] = setLval & 0x00FF;  
N    
N    terninalPrintf("\r\nPlease enter W parameters in decimal.(unit:cm)\r\n");
N    terninalPrintf("Enter number is ");
N    setWval = SetValue(5);
N    if(setWval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[12] = setWval >> 8;
N    ResultCmd[13] = setWval & 0x00FF;  
N    
N    terninalPrintf("\r\nPlease enter H parameters in decimal.(unit:cm)\r\n");
N    terninalPrintf("Enter number is ");
N    setHval = SetValue(5);
N    if(setHval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[14] = setHval >> 8;
N    ResultCmd[15] = setHval & 0x00FF;  
N    
N    terninalPrintf("\r\nPlease enter Theta parameters in decimal.(unit:degree)\r\n");
N    terninalPrintf("Enter number is ");
N    setThetaval = SetValue(2);
N    if(setThetaval == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[16] = setThetaval;
N    //ResultCmd[16] = setThetaval >> 8;
N    //ResultCmd[17] = setThetaval & 0x00FF;  
N    
N    terninalPrintf("\r\nPlease enter Phi parameters in decimal.(unit:degree)\r\n");
N    terninalPrintf("Enter number is ");
N    setPhival = SetValue(2);
N    //terninalPrintf("\r\n");
N    if(setPhival == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[17] = setPhival;
N    //ResultCmd[18] = setPhival >> 8;
N    //ResultCmd[19] = setPhival & 0x00FF;
N    
N    terninalPrintf("\r\nPlease enter L/R parameters in decimal.(0:right  1:left)\r\n");
N    terninalPrintf("Enter number is ");
N    setLR = SetValue(1);
N    terninalPrintf("\r\n");
N    if( (setLR == 0xffff) || (setLR > 1) )
N        return TEST_FALSE;
X        return 0x10;
N    ResultCmd[18] = setLR;
N    /*
N    terninalPrintf("\r\nPlease enter F/R parameters in decimal.(0:F type  1:R type)\r\n");
N    terninalPrintf("Enter number is ");
N    setFR = SetValue(1);
N    terninalPrintf("\r\n");
N    if( (setFR == 0xffff) || (setFR > 1))
N        return TEST_FALSE;
N    //ResultCmd[18] = setFR;
N    */
N    //*setFRtypePtr = setFR;
N    
N    
N    pRadarInterface->setPowerStatusFunc(setIndex,TRUE);
X    pRadarInterface->setPowerStatusFunc(setIndex,(1));
N    
N    featureValue = pRadarInterface->RadarResultFunc(setIndex, 0x02,ResultCmd,RadarData);
N    
N    pRadarInterface->setPowerStatusFunc(setIndex,FALSE);
X    pRadarInterface->setPowerStatusFunc(setIndex,(0));
N    
N    if((featureValue == TRUE) && (memcmp(RadarData + 8,ResultCmd + 6,13) == 0) )
X    if((featureValue == (1)) && (memcmp(RadarData + 8,ResultCmd + 6,13) == 0) )
N    {
N        terninalPrintf("Set radar%d success.\r\n",setIndex + 1);
N        return TRUE;
X        return (1);
N    }
N    else
N    {
N        return TEST_FALSE; 
X        return 0x10; 
N    }
W "src\user\hwtester.c" 8733 13 variable "ReadCmd" was declared but never referenced
W "src\user\hwtester.c" 8741 93 variable "setFR" was declared but never referenced
N}
N
Nstatic BOOL NEWradarSetDefault(void* para1, void* para2)
N{
N    int featureValue;
N    uint8_t RadarData[22];
N    uint8_t ReadCmd[24]   = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
N                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
N                             0x00, 0x1A, 0xD3, 0x3D};
N                             
N    uint8_t ResultCmd[24] = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x01, 0x00, 0x1E, 0x00, 0x1E, 
N                             0x00, 0xC8, 0x00, 0xC8, 0x00, 0x73, 0x00, 0x2D, 0x00, 0x05,
N                             0x02, 0x8C, 0xD3, 0x3D};
N                             
N    uint16_t   setIndex,setXval,setYval,setLval,setWval,setHval,setFR,rdIndex;    
N    uint8_t    setThetaval,setPhival; //,setLR;
N    uint16_t   *setIndexPtr = para1;         
N    //uint16_t   *setFRtypePtr = para2;                     
N    static RadarInterface* pRadarInterface;
N    pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(2);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("NEWradarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("NEWradarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    
N    setIndex = *setIndexPtr;
N    
N    /*
N    terninalPrintf("Please enter radar index in decimal.(1~2)\r\n");
N    terninalPrintf("Enter number is ");
N    setIndex = SetValue(1);
N    setIndex--;
N    if((setIndex == 0xffff) || ((setIndex != 0)&&(setIndex != 1)))
N        return TEST_FALSE;
N    */
N
N    setXval = 30;
N    ResultCmd[6] = setXval >> 8;
N    ResultCmd[7] = setXval & 0x00FF;
N    
N    setYval = 30;
N    ResultCmd[8] = setYval >> 8;
N    ResultCmd[9] = setYval & 0x00FF;   
N    
N    setLval = 200;
N    ResultCmd[10] = setLval >> 8;
N    ResultCmd[11] = setLval & 0x00FF;  
N    
N    setWval = 200;
N    ResultCmd[12] = setWval >> 8;
N    ResultCmd[13] = setWval & 0x00FF;  
N    
N    setHval = 115;
N    ResultCmd[14] = setHval >> 8;
N    ResultCmd[15] = setHval & 0x00FF;  
N    
N    setThetaval = 45;
N    ResultCmd[16] = setThetaval;
N    //ResultCmd[16] = setThetaval >> 8;
N    //ResultCmd[17] = setThetaval & 0x00FF;  
N    
N    setPhival = 5;
N    ResultCmd[17] = setPhival;
N    //ResultCmd[18] = setPhival >> 8;
N    //ResultCmd[19] = setPhival & 0x00FF;
N    
N    
N    terninalPrintf("\r\nPlease enter F/R parameters in decimal.(0:F type  1:R type)\r\n");
N    terninalPrintf("Enter number is ");
N    setFR = SetValue(1);
N    terninalPrintf("\r\n");
N    if(setFR == 0xffff)
N        return TEST_FALSE;
X        return 0x10;
N    //ResultCmd[18] = setFR;
N    
N    if(setFR > 1)
N    {
N        terninalPrintf("input error.\r\n");
N        return TEST_FALSE; 
X        return 0x10; 
N    }
N    
N    //*setFRtypePtr = setFR;
N    
N    
N    if(setIndex == 0) // EPM right(A) side radar
N    {
N        if(setFR == 0)  // F type
N            ResultCmd[18] = 1;  // left radar
N        else if(setFR == 1)  // R type
N            ResultCmd[18] = 0;  // right radar
N    }
N    else if(setIndex == 1) // EPM left(B) side radar
N    {
N        if(setFR == 0)  // F type
N            ResultCmd[18] = 0;  // right radar
N        else if(setFR == 1)  // R type
N            ResultCmd[18] = 1;  // left radar
N    }
N    /*
N    if(ResultCmd[18] == 1)   // left radar
N        rdIndex = 0;
N    else if(ResultCmd[18] == 0) // right radar
N        rdIndex = 1;
N    */
N    pRadarInterface->setPowerStatusFunc(setIndex,TRUE);
X    pRadarInterface->setPowerStatusFunc(setIndex,(1));
N    
N    featureValue = pRadarInterface->RadarResultFunc(setIndex, 0x02,ResultCmd,RadarData);
N    
N    pRadarInterface->setPowerStatusFunc(setIndex,FALSE);
X    pRadarInterface->setPowerStatusFunc(setIndex,(0));
N    
N    if((featureValue == TRUE) && (memcmp(RadarData + 8,ResultCmd + 6,13) == 0) )
X    if((featureValue == (1)) && (memcmp(RadarData + 8,ResultCmd + 6,13) == 0) )
N    {
N        terninalPrintf("Set radar%d success.\r\n",setIndex + 1);
N        return TRUE;
X        return (1);
N    }
N    else
N    {
N        return TEST_FALSE; 
X        return 0x10; 
N    }
W "src\user\hwtester.c" 8867 13 variable "ReadCmd" was declared but never referenced
W "src\user\hwtester.c" 8875 71 variable "rdIndex" was declared but never referenced
N}
N/*
Nvoid UART3Callback(void)
N{
N    terninalPrintf("radar33 <= ");
N    while(!(inpw(REG_UART3_FSR) & (1 << 14)))
N        terninalPrintf("%02x ",inpw(REG_UART3_RBR));    
N    terninalPrintf("\r\n");
N}
N
Nvoid UART7Callback(void)
N{
N    terninalPrintf("radar77 <= ");
N    while(!(inpw(REG_UART7_FSR) & (1 << 14)))
N        terninalPrintf("%02x ",inpw(REG_UART7_RBR));    
N    terninalPrintf("\r\n");
N}
N*/
Nstatic BOOL NEWradarTest(void* para1, void* para2)
N{
N    int featureValue;
N    uint8_t RadarData[22];
N    
N    uint8_t VersionCmd[9] = {0x7A, 0xA7, 0x00, 0x09, 0x00, 0x00, 0x09, 0xD3, 0x3D};
N    uint8_t ResultCmd[24] = {0x7A, 0xA7, 0x00, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
N                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
N                             0x00, 0x1A, 0xD3, 0x3D};
N    
N    
N    char VerStr[2][20];
N    char NumStr[15][10]; //NumStr[11][10];
N    //uint16_t *FRtypePtr = para2;              
N    int k;
N    //uint8_t FRtype = 0;  // default F type     
N    //uint8_t tempLRvalue[2];                   
N    static RadarInterface* pRadarInterface;
N    pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(2);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("NEWradarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("NEWradarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    pRadarInterface->setPowerStatusFunc(0,TRUE);
X    pRadarInterface->setPowerStatusFunc(0,(1));
N    pRadarInterface->setPowerStatusFunc(1,TRUE);
X    pRadarInterface->setPowerStatusFunc(1,(1));
N    
N    //UART3_EnableINT(UART3Callback);
N    //UART7_EnableINT(UART7Callback);
N    
N    //vTaskDelay(10000/portTICK_RATE_MS);
N    /*
N    EPDDrawString(FALSE,"Empty",15+10*25,100+(44*1));
N    EPDDrawString(FALSE,"Empty",15+6*25,100+(44*2));
N    EPDDrawString(FALSE,"Active",15+8*25,100+(44*3));
N    EPDDrawString(FALSE,"Empty",15+8*25,100+(44*4));
N    EPDDrawString(FALSE,"1000",15+7*25,100+(44*5));
N    EPDDrawString(FALSE,"1000",15+15*25,100+(44*5));
N    EPDDrawString(FALSE,"1000",15+7*25,100+(44*6));
N    EPDDrawString(FALSE,"1000",15+15*25,100+(44*6));
N    EPDDrawString(FALSE,"1000",15+8*25,100+(44*7));
N    EPDDrawString(FALSE,"10000",15+8*25,100+(44*8));
N    EPDDrawString(FALSE,"10000",15+8*25,100+(44*9));
N    EPDDrawString(FALSE,"10000",15+8*25,100+(44*10));
N    EPDDrawString(FALSE,"10000",15+8*25,100+(44*11));
N    EPDDrawString(FALSE,"10000",25+12*25,100+(44*12));
N    EPDDrawString(TRUE,"10000",25+10*25,100+(44*13));
N    */
N    /*
N    //terninalPrintf("*FRtypePtr = %d\r\n",*FRtypePtr);
N    if(*FRtypePtr == 0) // F type
N        EPDDrawString(FALSE,"F-type",90+25*20,28);
N    else if(*FRtypePtr == 1) // R type
N        EPDDrawString(FALSE,"R-type",90+25*20,28);
N    */
N    for(int j = 0; j<2; j++)
N    {
N        if(pRadarInterface->RadarResultFunc(j, 0x00,VersionCmd,RadarData) == TRUE)
X        if(pRadarInterface->RadarResultFunc(j, 0x00,VersionCmd,RadarData) == (1))
N        {
N            terninalPrintf("Radar%d Version : Ver.%d.%d.%d.%d\r\n",j+1,RadarData[0],RadarData[1],RadarData[2],RadarData[3]);
N            sprintf(VerStr[j],"%d.%d.%d.%d",RadarData[0],RadarData[1],RadarData[2],RadarData[3]);
N            EPDDrawString(FALSE,VerStr[j],15+8*25+515*j,100+(44*0));
X            EPDDrawString((0),VerStr[j],15+8*25+515*j,100+(44*0));
N        }
N    }
N    pRadarInterface->RadarCreateTaskFunc(); 
N    //vTaskDelay(5000/portTICK_RATE_MS);
N    pRadarInterface->RadarResultFunc(0, 0x02,ResultCmd,RadarData);
N    pRadarInterface->RadarResultFunc(1, 0x02,ResultCmd,RadarData);
N    //pRadarInterface->RadarResultFunc(0, 0x02,ResultCmd,RadarData);
N    //pRadarInterface->RadarResultFunc(1, 0x02,ResultCmd,RadarData);
N    //vTaskDelay(1000/portTICK_RATE_MS);
N    while(1)
N    {
N        
N        for(int i = 0; i<2; i++)
N        {
N            //featureValue = pRadarInterface->checkFeaturnFunc(i, NULL, NULL, NULL, NULL);
N            //featureValue = pRadarInterface->RadarResultFunc(i, 0x02,ResultCmd,RadarData);
N            featureValue = pRadarInterface->RadarResultElite(i, 0x02,ResultCmd,RadarData);
N            /*
N            terninalPrintf("featureValue = %08x \r\n",featureValue);
N            terninalPrintf("RadarData =              ");
N            for(int j = 0; j<sizeof(RadarData); j++)
N                terninalPrintf("%02x ",RadarData[j]);
N            terninalPrintf("\r\n");
N            */
N            if(featureValue == TRUE)
X            if(featureValue == (1))
N            {
N                terninalPrintf("----------Radar%dResult----------\r\n",i+1);
N                
N                //k = (i + *FRtypePtr)%2;
N                k = i;
N                //terninalPrintf("Object Material: ");
N                terninalPrintf("Object Material: %d\r\n",RadarData[0]);
N                EPDDrawString(FALSE,"        ",15+10*25+515*k,100+(44*1));
X                EPDDrawString((0),"        ",15+10*25+515*k,100+(44*1));
N                sprintf(NumStr[11],"%d",RadarData[0]);
N                EPDDrawString(FALSE,NumStr[11],15+10*25+515*k,100+(44*1));
X                EPDDrawString((0),NumStr[11],15+10*25+515*k,100+(44*1));
N                /*
N                switch(RadarData[0]) 
N                {
N                    case 0x00:
N                        terninalPrintf("Empty\r\n");
N                        EPDDrawString(FALSE,"Empty",15+10*25+515*i,100+(44*1));
N                        break;
N                    case 0x01:
N                        terninalPrintf("Metal\r\n");
N                        EPDDrawString(FALSE,"Metal",15+10*25+515*i,100+(44*1));
N                        break;
N                    case 0x02:
N                        terninalPrintf("Wood\r\n");
N                        EPDDrawString(FALSE,"Wood",15+10*25+515*i,100+(44*1));
N                        break;
N                    case 0x03:
N                        terninalPrintf("Water\r\n");
N                        EPDDrawString(FALSE,"Water",15+10*25+515*i,100+(44*1));
N                        break;
N                    case 0x04:
N                        terninalPrintf("Carton\r\n");
N                        EPDDrawString(FALSE,"Carton",15+10*25+515*i,100+(44*1));
N                        break;
N                    case 0x05:
N                        terninalPrintf("Others\r\n");
N                        EPDDrawString(FALSE,"Others",15+10*25+515*i,100+(44*1));
N                        break;
N                    default:
N                        terninalPrintf("Unknown\r\n");
N                        EPDDrawString(FALSE,"Unknown",15+10*25+515*i,100+(44*1));
N                        break;
N                }
N                */
N                //terninalPrintf("Object type: ");
N                terninalPrintf("Object type: %d\r\n",RadarData[1]);
N                EPDDrawString(FALSE,"            ",15+6*25+515*k,100+(44*2));
X                EPDDrawString((0),"            ",15+6*25+515*k,100+(44*2));
N                sprintf(NumStr[12],"%d",RadarData[1]);
N                EPDDrawString(FALSE,NumStr[12],15+6*25+515*k,100+(44*2));
X                EPDDrawString((0),NumStr[12],15+6*25+515*k,100+(44*2));
N                
N                /*
N                switch(RadarData[1]) 
N                {
N                    case 0x00:
N                        terninalPrintf("Empty\r\n");
N                        EPDDrawString(FALSE,"Empty",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x01:
N                        terninalPrintf("Car\r\n");
N                        EPDDrawString(FALSE,"Car",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x02:
N                        terninalPrintf("Motocycle\r\n");
N                        EPDDrawString(FALSE,"Motocycle",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x03:
N                        terninalPrintf("Scooter\r\n");
N                        EPDDrawString(FALSE,"Scooter",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x04:
N                        terninalPrintf("Bike\r\n");
N                        EPDDrawString(FALSE,"Bike",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x05:
N                        terninalPrintf("Human\r\n");
N                        EPDDrawString(FALSE,"Human",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x06:
N                        terninalPrintf("Obstacle\r\n");
N                        EPDDrawString(FALSE,"Obstacle",15+6*25+515*i,100+(44*2));
N                        break;
N                    case 0x0F:
N                        terninalPrintf("Radar obscured\r\n");
N                        EPDDrawString(FALSE,"Radar obscured",15+6*25+515*i,100+(44*2));
N                        break;
N                    default:
N                        terninalPrintf("Unknown\r\n");
N                        EPDDrawString(FALSE,"Unknown",15+6*25+515*i,100+(44*2));
N                        break;
N                }
N                */
N                //terninalPrintf("Radar Status: ");
N                terninalPrintf("Radar Status: %d\r\n",RadarData[2]);
N                EPDDrawString(FALSE,"         ",15+8*25+515*k,100+(44*3));
X                EPDDrawString((0),"         ",15+8*25+515*k,100+(44*3));
N                sprintf(NumStr[13],"%d",RadarData[2]);
N                EPDDrawString(FALSE,NumStr[13],15+8*25+515*k,100+(44*3));
X                EPDDrawString((0),NumStr[13],15+8*25+515*k,100+(44*3));
N                /*
N                switch(RadarData[2]) 
N                {
N                    case 0x00:
N                        terninalPrintf("Active\r\n");
N                        EPDDrawString(FALSE,"Active",15+8*25+515*i,100+(44*3));
N                        break;
N                    case 0xFF:
N                        terninalPrintf("Fail\r\n");
N                        EPDDrawString(FALSE,"Fail",15+8*25+515*i,100+(44*3));
N                        break;
N                    default:
N                        terninalPrintf("Unknown\r\n");
N                        EPDDrawString(FALSE,"Unknown",15+8*25+515*i,100+(44*3));
N                        break;
N                }
N                */
N                
N                //terninalPrintf("Identification result: ");
N                terninalPrintf("Identification result: %d\r\n",RadarData[3]);
N                EPDDrawString(FALSE,"          ",15+8*25+515*k,100+(44*4));
X                EPDDrawString((0),"          ",15+8*25+515*k,100+(44*4));
N                sprintf(NumStr[14],"%d",RadarData[3]);
N                EPDDrawString(FALSE,NumStr[14],15+8*25+515*k,100+(44*4));
X                EPDDrawString((0),NumStr[14],15+8*25+515*k,100+(44*4));
N                /*
N                switch(RadarData[3]) 
N                {
N                    case 0x00:
N                        terninalPrintf("Empty\r\n");
N                        EPDDrawString(FALSE,"Empty",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x01:
N                        terninalPrintf("Parking (near)\r\n");
N                        EPDDrawString(FALSE,"Parking (near)",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x02:
N                        terninalPrintf("Parking (away)\r\n");
N                        EPDDrawString(FALSE,"Parking (away)",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x03:
N                        terninalPrintf("Parking (idling)\r\n");
N                        EPDDrawString(FALSE,"Parking (idling)",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x04:
N                        terninalPrintf("Parking (static)\r\n");
N                        EPDDrawString(FALSE,"Parking (static)",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x05:
N                        terninalPrintf("Occupying parking lot\r\n");
N                        EPDDrawString(FALSE,"Occupying parking lot",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x06:
N                        terninalPrintf("Reserved\r\n");
N                        EPDDrawString(FALSE,"Reserved",15+8*25+515*i,100+(44*4));
N                        break;
N                    case 0x0F:
N                        terninalPrintf("Radar obscured\r\n");
N                        EPDDrawString(FALSE,"Radar obscured",15+8*25+515*i,100+(44*4));
N                        break;
N                    default:
N                        terninalPrintf("Unknown\r\n");
N                        EPDDrawString(FALSE,"Unknown",15+8*25+515*i,100+(44*4));
N                        break;
N                }
N                */
N
N                terninalPrintf("Object Position (x): %d\r\n",RadarData[4]*10);
N                terninalPrintf("Object Position (y): %d\r\n",RadarData[5]*10);
N                terninalPrintf("Object Position (z): %d\r\n",RadarData[6]*10);
N                terninalPrintf("Object Distance (R): %d\r\n",RadarData[7]*10);
N                
N                terninalPrintf("X: %d\r\n",     RadarData[8]<<8 | RadarData[9]);
N                terninalPrintf("Y: %d\r\n",     RadarData[10]<<8 | RadarData[11]);
N                terninalPrintf("L: %d\r\n",     RadarData[12]<<8 | RadarData[13]);
N                terninalPrintf("W: %d\r\n",     RadarData[14]<<8 | RadarData[15]);
N                terninalPrintf("H: %d\r\n",     RadarData[16]<<8 | RadarData[17]);
N                terninalPrintf("theta: %d\r\n", RadarData[18]);
N                terninalPrintf("phi: %d\r\n",   RadarData[19]);
N                terninalPrintf("L/R: %d\r\n",   RadarData[20]);
N                //terninalPrintf("theta: %d\r\n", RadarData[18]<<8 | RadarData[19]);
N                //terninalPrintf("phi: %d\r\n",   RadarData[20]<<8 | RadarData[21]);
N                terninalPrintf("--------------------------------\r\n");
N                
N                
N                
N                
N                memset(NumStr,0x00,sizeof(NumStr));
N                
N                sprintf(NumStr[0],"%d",RadarData[4]*10);
N                sprintf(NumStr[1],"%d",RadarData[5]*10);
N                sprintf(NumStr[2],"%d",RadarData[6]*10);
N                sprintf(NumStr[3],"%d",RadarData[7]*10);
N                
N                sprintf(NumStr[4], "%d",RadarData[8]<<8  | RadarData[9]);
N                sprintf(NumStr[5], "%d",RadarData[10]<<8 | RadarData[11]);
N                sprintf(NumStr[6], "%d",RadarData[12]<<8 | RadarData[13]);
N                sprintf(NumStr[7], "%d",RadarData[14]<<8 | RadarData[15]);
N                sprintf(NumStr[8], "%d",RadarData[16]<<8 | RadarData[17]);
N                sprintf(NumStr[9], "%d",RadarData[18]);
N                sprintf(NumStr[10],"%d",RadarData[19]);
N                sprintf(NumStr[11],"%d",RadarData[20]);
N                //sprintf(NumStr[9], "%d",RadarData[18]<<8 | RadarData[19]);
N                //sprintf(NumStr[10],"%d",RadarData[20]<<8 | RadarData[21]);
N                
N                
N                EPDDrawString(FALSE,"    ",15+7*25+515*k,100+(44*5));
X                EPDDrawString((0),"    ",15+7*25+515*k,100+(44*5));
N                EPDDrawString(FALSE,"    ",15+15*25+515*k,100+(44*5));
X                EPDDrawString((0),"    ",15+15*25+515*k,100+(44*5));
N                EPDDrawString(FALSE,"    ",15+7*25+515*k,100+(44*6));
X                EPDDrawString((0),"    ",15+7*25+515*k,100+(44*6));
N                EPDDrawString(FALSE,"    ",15+15*25+515*k,100+(44*6));
X                EPDDrawString((0),"    ",15+15*25+515*k,100+(44*6));
N                EPDDrawString(FALSE,"     ",15+8*25+515*k,100+(44*7));
X                EPDDrawString((0),"     ",15+8*25+515*k,100+(44*7));
N                EPDDrawString(FALSE,"     ",15+8*25+515*k,100+(44*8));
X                EPDDrawString((0),"     ",15+8*25+515*k,100+(44*8));
N                EPDDrawString(FALSE,"     ",15+8*25+515*k,100+(44*9));
X                EPDDrawString((0),"     ",15+8*25+515*k,100+(44*9));
N                EPDDrawString(FALSE,"     ",15+8*25+515*k,100+(44*10));
X                EPDDrawString((0),"     ",15+8*25+515*k,100+(44*10));
N                EPDDrawString(FALSE,"     ",15+8*25+515*k,100+(44*11));
X                EPDDrawString((0),"     ",15+8*25+515*k,100+(44*11));
N                EPDDrawString(FALSE,"     ",25+12*25+515*k,100+(44*12));
X                EPDDrawString((0),"     ",25+12*25+515*k,100+(44*12));
N                EPDDrawString(FALSE,"     ",25+10*25+515*k,100+(44*13));
X                EPDDrawString((0),"     ",25+10*25+515*k,100+(44*13));
N                EPDDrawString(FALSE," ",10*25+515*k,100+(44*14));
X                EPDDrawString((0)," ",10*25+515*k,100+(44*14));
N                          
N                
N                EPDDrawString(FALSE,NumStr[0],15+7*25+515*k,100+(44*5));
X                EPDDrawString((0),NumStr[0],15+7*25+515*k,100+(44*5));
N                EPDDrawString(FALSE,NumStr[1],15+15*25+515*k,100+(44*5));
X                EPDDrawString((0),NumStr[1],15+15*25+515*k,100+(44*5));
N                EPDDrawString(FALSE,NumStr[2],15+7*25+515*k,100+(44*6));
X                EPDDrawString((0),NumStr[2],15+7*25+515*k,100+(44*6));
N                EPDDrawString(FALSE,NumStr[3],15+15*25+515*k,100+(44*6));
X                EPDDrawString((0),NumStr[3],15+15*25+515*k,100+(44*6));
N                EPDDrawString(FALSE,NumStr[4],15+8*25+515*k,100+(44*7));
X                EPDDrawString((0),NumStr[4],15+8*25+515*k,100+(44*7));
N                EPDDrawString(FALSE,NumStr[5],15+8*25+515*k,100+(44*8));
X                EPDDrawString((0),NumStr[5],15+8*25+515*k,100+(44*8));
N                EPDDrawString(FALSE,NumStr[6],15+8*25+515*k,100+(44*9));
X                EPDDrawString((0),NumStr[6],15+8*25+515*k,100+(44*9));
N                EPDDrawString(FALSE,NumStr[7],15+8*25+515*k,100+(44*10));
X                EPDDrawString((0),NumStr[7],15+8*25+515*k,100+(44*10));
N                EPDDrawString(FALSE,NumStr[8],15+8*25+515*k,100+(44*11));
X                EPDDrawString((0),NumStr[8],15+8*25+515*k,100+(44*11));
N                EPDDrawString(FALSE,NumStr[9],25+12*25+515*k,100+(44*12));
X                EPDDrawString((0),NumStr[9],25+12*25+515*k,100+(44*12));
N                EPDDrawString(FALSE,NumStr[10],25+10*25+515*k,100+(44*13));
X                EPDDrawString((0),NumStr[10],25+10*25+515*k,100+(44*13));
N                EPDDrawString(TRUE,NumStr[11],10*25+515*k,100+(44*14));
X                EPDDrawString((1),NumStr[11],10*25+515*k,100+(44*14));
N                
N            }
N            else if(featureValue == FALSE)
X            else if(featureValue == (0))
N                vTaskDelay(2000/portTICK_RATE_MS);
X                vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            else if( featureValue == 0x10)  // UART_FORMAT_ERR
N            {
N                if(pRadarInterface->setPowerStatusFunc != NULL) {
X                if(pRadarInterface->setPowerStatusFunc != 0) {
N                    pRadarInterface->RadarinitBurningFunc(i);
N                    pRadarInterface->setPowerStatusFunc(i, FALSE);
X                    pRadarInterface->setPowerStatusFunc(i, (0));
N                    vTaskDelay(500 / portTICK_RATE_MS);
X                    vTaskDelay(500 / ( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    pRadarInterface->setPowerStatusFunc(i, TRUE);
X                    pRadarInterface->setPowerStatusFunc(i, (1));
N                    vTaskDelay(500 / portTICK_RATE_MS);
X                    vTaskDelay(500 / ( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N            }
N            
N            
N            if(userResponse()=='q')
N            {
N                //UART3_DisableINT();
N                //UART7_DisableINT();
N                
N                pRadarInterface->RadarDeleteTaskFunc();
N                pRadarInterface->setPowerStatusFunc(0,FALSE);
X                pRadarInterface->setPowerStatusFunc(0,(0));
N                pRadarInterface->setPowerStatusFunc(1,FALSE);
X                pRadarInterface->setPowerStatusFunc(1,(0));
N                return TRUE;
X                return (1);
N            }
N        }
N    }
N    
N}
N
Nstatic BOOL radarTest(void* para1, void* para2)
N{
N    guiManagerShowScreen(GUI_RADAR_ID,GUI_REDRAW_PARA_REFRESH,0,0);
X    guiManagerShowScreen(21,0x03,0,0);
N    char epdMessage[64];
N    static RadarInterface* pRadarInterface;
N    BOOL changeFlag;
N    int dist;
N    int power;
N    int occupiedType;
N    int distValue[2];
N    
N    uint16_t lidarDistValue[2];
N    uint16_t radarDistValue[2];
N    
N    char lidarDistString[2][20];
N    char radarDistString[2][20];
N    
N    char distStringBuff[2][20];
N    terninalPrintf("!!! lidarTest !!!\r\n");
N    //setPrintfFlag(FALSE);
N    pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(0);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    terninalPrintf("Press 'q' to Exit\r\n");
N    EPDDrawString(TRUE,"Testing   ",RADAR_MSG_X,RADAR_MSG_Y);
X    EPDDrawString((1),"Testing   ",50,250);
N    pRadarInterface->setPowerStatusFunc(0,TRUE);
X    pRadarInterface->setPowerStatusFunc(0,(1));
N    pRadarInterface->setPowerStatusFunc(1,TRUE);
X    pRadarInterface->setPowerStatusFunc(1,(1));
N    vTaskDelay(4000/portTICK_RATE_MS);
X    vTaskDelay(4000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    
N    /*
N    char temp1String[50] ;
N    char tempRadarVersionString[50];
N    
N    for(int i = 0; i<2; i++)
N    {
N        pRadarInterface -> readQueryVersionString(i, tempRadarVersionString);
N        terninalPrintf("\r");
N        terninalPrintf("Radar%d Version = %s\r\n",i+1,tempRadarVersionString);
N        sprintf(templastString,"Radar%d Version:%s",i+1,tempRadarVersionString);       
N        EPDDrawString(TRUE,templastString,50,100+(44*(i+10)));        
N        vTaskDelay(1000/portTICK_RATE_MS);
N    }  */
N    
N    char temp1String[50] ;
N    char temp2String[50] ;
N    char tempRadar1VersionString[50] ;
N    char tempRadar2VersionString[50] ;
N    int retry1 = 2; 
N    int retry2 = 2;
N    
N    
N    while(retry1 > 0)
N    {
N        if(pRadarInterface -> readQueryVersionString(0, tempRadar1VersionString))
N            break;
N        retry1--;
N    }
N    
N    if(retry1 > 0)
N    {
N        
N        terninalPrintf("Radar1 Version = %s\r\n",tempRadar1VersionString);
N        sprintf(temp1String,"Radar1 Version:%s",tempRadar1VersionString);       
N        EPDDrawString(TRUE,temp1String,50,100+(44*(10)));        
X        EPDDrawString((1),temp1String,50,100+(44*(10)));        
N        
N    }
N    else
N    {
N        sprintf(temp1String,"Radar1 Version:Error");       
N        EPDDrawString(TRUE,temp1String,50,100+(44*(10)));   
X        EPDDrawString((1),temp1String,50,100+(44*(10)));   
N    }
N    
N    
N    
N    
N    while(retry2 > 0)
N    {
N        if(pRadarInterface -> readQueryVersionString(1, tempRadar2VersionString))
N            break;
N        retry2--;
N    }
N    
N    if(retry2 > 0)
N    {
N        terninalPrintf("Radar2 Version = %s\r\n",tempRadar2VersionString);
N        sprintf(temp2String,"Radar2 Version:%s",tempRadar2VersionString);       
N        EPDDrawString(TRUE,temp2String,50,100+(44*(11))); 
X        EPDDrawString((1),temp2String,50,100+(44*(11))); 
N    }
N    else
N    {
N        sprintf(temp2String,"Radar2 Version:Error");       
N        EPDDrawString(TRUE,temp2String,50,100+(44*(11)));   
X        EPDDrawString((1),temp2String,50,100+(44*(11)));   
N    }
N    
N    
N    
N    while(1)
N    {
N        for(int i = 0; i<2; i++)
N        {
N            EPDDrawString(TRUE,"Testing   ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X            EPDDrawString((1),"Testing   ",50+(i*500),250);
N            int featureValue = pRadarInterface->checkFeaturnFunc(i, &changeFlag, &dist, &power, &occupiedType);
N            switch(featureValue)
N            {
N                case RADAR_FEATURE_OCCUPIED:
X                case 0x01:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_OCCUPIED (%d)!!\n", i+1, dist);
N                    break;
N                case RADAR_FEATURE_VACUUM:
X                case 0x03:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_VACUUM (%d)!!\n", i+1, dist);
N                    break;
N                case RADAR_FEATURE_OCCUPIED_UN_STABLED:
X                case 0x02:
N                    sprintf(epdMessage, "%d %d        "        , dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_UN_STABLED (%d )!!\n", i+1, dist);
N                    break; 
N                case RADAR_FEATURE_VACUUM_UN_STABLED:
X                case 0x04:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_UN_STABLED (%d )!!\n", i+1, dist);
N                    break; 
N                case RADAR_FEATURE_IGNORE:
X                case 0x06:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_IGNORE (%d )!!\n", i+1, dist);
N                    break; 
N                
N                case RADAR_FEATURE_OCCUPIED_LIDAR_FAIL:
X                case 0x31:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_OCCUPIED_LIDAR_FAIL (%d)!!\n", i+1, dist);
N                    break;
N                case RADAR_FEATURE_VACUUM_LIDAR_FAIL:
X                case 0x33:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_VACUUM_LIDAR_FAIL (%d)!!\n", i+1, dist);
N                    break;
N                case RADAR_FEATURE_OCCUPIED_UN_STABLED_LIDAR_FAIL:
X                case 0x32:
N                    sprintf(epdMessage, "%d %d        "        , dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL (%d )!!\n", i+1, dist);
N                    break; 
N                case RADAR_FEATURE_VACUUM_UN_STABLED_LIDAR_FAIL:
X                case 0x34:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_UN_STABLED_LIDAR_FAIL (%d )!!\n", i+1, dist);
N                    break; 
N                case RADAR_FEATURE_IGNORE_LIDAR_FAIL:
X                case 0x36:
N                    sprintf(epdMessage, "%d %d        ", dist, power);
N                    EPDDrawString(TRUE,epdMessage,RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  RADAR_FEATURE_IGNORE_LIDAR_FAIL (%d )!!\n", i+1, dist);
N                    break; 
N                
N                default:
N                    EPDDrawString(TRUE,"FAIL        ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y);
X                    EPDDrawString((1),"FAIL        ",50+(i*500),250);
N                    terninalPrintf("[RADAR]%d ->  TIMEOUT!! featureValue=%d\n", i+1,featureValue);
N                    break;
N            }
N            
N            EPDDrawString(FALSE,"                  ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+50);
X            EPDDrawString((0),"                  ",50+(i*500),250+50);
N            EPDDrawString(FALSE,"                  ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+100);
X            EPDDrawString((0),"                  ",50+(i*500),250+100);
N            if(pRadarInterface->RecentDistValueFunc(i,&lidarDistValue[i],&radarDistValue[i]) == TRUE)
X            if(pRadarInterface->RecentDistValueFunc(i,&lidarDistValue[i],&radarDistValue[i]) == (1))
N            {
N
N                sprintf(lidarDistString[i],"lidarDist:%d",lidarDistValue[i]);
N                EPDDrawString(FALSE,lidarDistString[i],RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+50);
X                EPDDrawString((0),lidarDistString[i],50+(i*500),250+50);
N                sprintf(radarDistString[i],"radarDist:%d",radarDistValue[i]);
N                EPDDrawString(TRUE,radarDistString[i],RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+100);
X                EPDDrawString((1),radarDistString[i],50+(i*500),250+100);
N                
N            }
N            else
N            {
N                sprintf(lidarDistString[i],"lidarDist:error");
N                EPDDrawString(FALSE,lidarDistString[i],RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+50);
X                EPDDrawString((0),lidarDistString[i],50+(i*500),250+50);
N                sprintf(radarDistString[i],"radarDist:error");
N                EPDDrawString(TRUE,radarDistString[i],RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+100);
X                EPDDrawString((1),radarDistString[i],50+(i*500),250+100);
N            }
N            
N            EPDDrawString(FALSE,"                  ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+150);
X            EPDDrawString((0),"                  ",50+(i*500),250+150);
N            EPDDrawString(FALSE,"                  ",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+200); 
X            EPDDrawString((0),"                  ",50+(i*500),250+200); 
N            
N            if(pRadarInterface->readDistValueFunc(i,&distValue[i]) == TRUE)
X            if(pRadarInterface->readDistValueFunc(i,&distValue[i]) == (1))
N            {
N                sprintf(distStringBuff[i],"CaliDist:%d",distValue[i]);
N                //EPDDrawString(TRUE,distStringBuff[i],RADAR_MSG_X+(i*400),RADAR_MSG_Y+50);
N                EPDDrawString(TRUE,distStringBuff[i],RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+150);
X                EPDDrawString((1),distStringBuff[i],50+(i*500),250+150);
N            }
N            else
N            {
N                if(i == 0)
N                    //EPDDrawString(FALSE,"Lidar1 not",RADAR_MSG_X+(i*400),RADAR_MSG_Y+50);
N                    EPDDrawString(FALSE,"Lidar1 not",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+150);
X                    EPDDrawString((0),"Lidar1 not",50+(i*500),250+150);
N                else if(i == 1)
N                    //EPDDrawString(FALSE,"Lidar2 not",RADAR_MSG_X+(i*400),RADAR_MSG_Y+50);
N                    EPDDrawString(FALSE,"Lidar2 not",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+150);
X                    EPDDrawString((0),"Lidar2 not",50+(i*500),250+150);
N                //EPDDrawString(TRUE,"calibrated",RADAR_MSG_X+(i*400),RADAR_MSG_Y+100);
N                EPDDrawString(TRUE,"calibrated",RADAR_MSG_X+(i*RADAR_INTERVAL),RADAR_MSG_Y+200);
X                EPDDrawString((1),"calibrated",50+(i*500),250+200);
N            }
N        
N            
N            
N            if(userResponse()=='q')
N            {
N                pRadarInterface->setPowerStatusFunc(0,FALSE);
X                pRadarInterface->setPowerStatusFunc(0,(0));
N                pRadarInterface->setPowerStatusFunc(1,FALSE);
X                pRadarInterface->setPowerStatusFunc(1,(0));
N                return TRUE;
X                return (1);
N            }
N        }
N    }
N}
N#define RADAR_0_ON_OFF_X 480
N#define RADAR_0_ON_OFF_Y 250
N#define RADAR_1_ON_OFF_X 480
N#define RADAR_1_ON_OFF_Y 300
Nstatic BOOL radarPowerSet(void* para1, void* para2)
N{
Nstatic BOOL radarStatus[2]={TRUE,TRUE};
Xstatic BOOL radarStatus[2]={(1),(1)};
N    BOOL changeFlag;
N    char* boolConvString[2] = {" OFF "," ON  "};
N    guiManagerShowScreen(GUI_RADAR_ID, GUI_REDRAW_PARA_REFRESH, 0, POWER_SET_MODE);
X    guiManagerShowScreen(21, 0x03, 0, 1);
N    static RadarInterface* pRadarInterface;
N    char tmp;
N    terninalPrintf("!!! radarPowerSet !!!\r\n");
N    pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(0);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        //terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        //terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    pRadarInterface->setPowerStatusFunc(0,radarStatus[0]);
N    pRadarInterface->setPowerStatusFunc(1,radarStatus[1]);
N    
N    //terninalPrintf("Press...\r\n'0' set Radar0 to [%s]\r\n'1' set Radar1 to [%s]\r\n",boolConvString[!radarStatus[0]],boolConvString[!radarStatus[1]]);
N
N//    while(1)
N    {
N        EPDDrawString(TRUE,"Checking",RADAR_0_ON_OFF_X,RADAR_0_ON_OFF_Y);
X        EPDDrawString((1),"Checking",480,250);
N        if(pRadarInterface->checkFeaturnFunc(0, &changeFlag, NULL, NULL, NULL)==RADAR_FEATURE_FAIL)
X        if(pRadarInterface->checkFeaturnFunc(0, &changeFlag, 0, 0, 0)==0xFF)
N        {
N            EPDDrawString(TRUE,"      Error",RADAR_0_ON_OFF_X,RADAR_0_ON_OFF_Y);
X            EPDDrawString((1),"      Error",480,250);
N            radarStatus[0] = FALSE;
X            radarStatus[0] = (0);
N        }
N        else
N        {
N            EPDDrawString(TRUE,"           ",RADAR_0_ON_OFF_X,RADAR_0_ON_OFF_Y);
X            EPDDrawString((1),"           ",480,250);
N        }
N        EPDDrawString(TRUE,"Checking",RADAR_1_ON_OFF_X,RADAR_1_ON_OFF_Y);
X        EPDDrawString((1),"Checking",480,300);
N        if(pRadarInterface->checkFeaturnFunc(1, &changeFlag, NULL, NULL, NULL)==RADAR_FEATURE_FAIL)
X        if(pRadarInterface->checkFeaturnFunc(1, &changeFlag, 0, 0, 0)==0xFF)
N        {
N            EPDDrawString(TRUE,"      Error",RADAR_1_ON_OFF_X,RADAR_1_ON_OFF_Y);
X            EPDDrawString((1),"      Error",480,300);
N            radarStatus[1] = FALSE;
X            radarStatus[1] = (0);
N        }
N        else 
N        {
N            EPDDrawString(TRUE,"           ",RADAR_1_ON_OFF_X,RADAR_1_ON_OFF_Y);
X            EPDDrawString((1),"           ",480,300);
N        }
N        //break;
N        if(userResponse()=='q')
N            return TRUE;
X            return (1);
N    }
N    //terninalPrintf("Check:\r\nRadar0 [%s]\r\nRadar1 [%s]\r\n",radarStatus[0]?"OK":"ERROR",radarStatus[1]?"OK":"ERROR");
N    terninalPrintf("Check:\r\nRadar1 [%s]\r\nRadar2 [%s]\r\n",radarStatus[0]?"OK":"ERROR",radarStatus[1]?"OK":"ERROR");
N    EPDDrawString(FALSE,boolConvString[radarStatus[0]],RADAR_0_ON_OFF_X,RADAR_0_ON_OFF_Y);
X    EPDDrawString((0),boolConvString[radarStatus[0]],480,250);
N    EPDDrawString(TRUE ,boolConvString[radarStatus[1]],RADAR_1_ON_OFF_X,RADAR_1_ON_OFF_Y);
X    EPDDrawString((1) ,boolConvString[radarStatus[1]],480,300);
N    terninalPrintf("Now Power Status:('q' to exit)\r\n");
N    //terninalPrintf("Radar0[%s]  Radar1[%s] ('0' set Radar0)('1' set Radar1)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N    terninalPrintf("Radar1[%s]  Radar2[%s] ('1' set Radar1)('2' set Radar2)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N    while(1)
N    {
N        tmp=userResponseLoop();
N        //setPrintfFlag(FALSE);
N        if(tmp=='q')
N        {
N            break;
N        }
N        //else if(tmp=='0')
N        else if(tmp=='1')
N        {
N            radarStatus[0]=!(radarStatus[0]);
N            //terninalPrintf("\rRadar0[%s]  Radar1[%s] ('0' set Radar0)('1' set Radar1)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N            terninalPrintf("\rRadar1[%s]  Radar2[%s] ('1' set Radar1)('2' set Radar2)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N            pRadarInterface->setPowerStatusFunc(0,radarStatus[0]);
N        }
N        //else if(tmp=='1')
N        else if(tmp=='2')
N        {
N            radarStatus[1]=!(radarStatus[1]);
N            //terninalPrintf("\rRadar0[%s]  Radar1[%s] ('0' set Radar0)('1' set Radar1)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N            terninalPrintf("\rRadar1[%s]  Radar2[%s] ('1' set Radar1)('2' set Radar2)",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N            pRadarInterface->setPowerStatusFunc(1,radarStatus[1]);
N        }
N        EPDDrawString(FALSE,boolConvString[radarStatus[0]],RADAR_0_ON_OFF_X,RADAR_0_ON_OFF_Y);
X        EPDDrawString((0),boolConvString[radarStatus[0]],480,250);
N        EPDDrawString(TRUE ,boolConvString[radarStatus[1]],RADAR_1_ON_OFF_X,RADAR_1_ON_OFF_Y);
X        EPDDrawString((1) ,boolConvString[radarStatus[1]],480,300);
N        //setPrintfFlag(TRUE); 
N    }
N    return TRUE;
X    return (1);
N}
N
N///////////////////////////LIDAR Test/////////////////////////////////
N#define LIDAR_MSG_X 180
N#define LIDAR_MSG_Y 250
Nstatic BOOL lidarTest(void* para1, void* para2)
N{
N    guiManagerShowScreen(GUI_LIDAR_ID,GUI_REDRAW_PARA_REFRESH,0,0);
X    guiManagerShowScreen(23,0x03,0,0);
N    char epdMessage[64];
N    static RadarInterface* pRadarInterface;
N    BOOL changeFlag;
N    int dist;
N    int power;
N    int occupiedType;
N    terninalPrintf("!!! lidarTest !!!\r\n");
N    //setPrintfFlag(FALSE);
N    pRadarInterface = RadarGetInterface(LIDAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(1);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    terninalPrintf("Press 'q' to Exit\r\n");
N    EPDDrawString(TRUE,"Testing   ",LIDAR_MSG_X,LIDAR_MSG_Y);
X    EPDDrawString((1),"Testing   ",180,250);
N    pRadarInterface->setPowerStatusFunc(0,TRUE);
X    pRadarInterface->setPowerStatusFunc(0,(1));
N    pRadarInterface->setPowerStatusFunc(1,TRUE);
X    pRadarInterface->setPowerStatusFunc(1,(1));
N    while(1)
N    {
N        for(int i = 0; i<2; i++)
N        {
N            EPDDrawString(TRUE,"Testing   ",LIDAR_MSG_X+(i*400),LIDAR_MSG_Y);
X            EPDDrawString((1),"Testing   ",180+(i*400),250);
N            int featureValue = pRadarInterface->checkFeaturnFunc(i, &changeFlag, &dist, &power, &occupiedType);
N            switch(featureValue)
N            {
N                 case LIDAR_FEATURE_OCCUPIED:
X                 case 0x01:
N                    sprintf(epdMessage, "%dcm, %d", dist, power);
N                    EPDDrawString(TRUE,epdMessage,LIDAR_MSG_X+(i*400),LIDAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,180+(i*400),250);
N                    terninalPrintf("[LIDAR]%d ->  RADAR_FEATURE_OCCUPIED (%d cm)!!\n", i, dist);
N                    break;
N                 
N                case LIDAR_FEATURE_VACUUM:
X                case 0x02:
N                    sprintf(epdMessage, "%dcm, %d", dist, power);
N                    EPDDrawString(TRUE,epdMessage,LIDAR_MSG_X+(i*400),LIDAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,180+(i*400),250);
N                    terninalPrintf("[LIDAR]%d ->  RADAR_FEATURE_VACUUM (%d cm)!!\n", i, dist);
N                    break;
N                
N                case LIDAR_FEATURE_UN_STABLED:
X                case 0x03:
N                    sprintf(epdMessage, "%dcm, %d", dist, power);
N                    EPDDrawString(TRUE,epdMessage,LIDAR_MSG_X+(i*400),LIDAR_MSG_Y);
X                    EPDDrawString((1),epdMessage,180+(i*400),250);
N                    terninalPrintf("[LIDAR]%d ->  RADAR_FEATURE_UN_STABLED (%d cm)!!\n", i, dist);
N                    break;
N                
N                default:
N                    //EPDDrawString(TRUE,"FAIL        ",LIDAR_MSG_X+(i*400),LIDAR_MSG_Y);
N                    terninalPrintf("[LIDAR]%d ->  TIMEOUT!!\n", i);
N                    break;
N            }
N            if(userResponse()=='q'){
N                pRadarInterface->setPowerStatusFunc(0,FALSE);
X                pRadarInterface->setPowerStatusFunc(0,(0));
N                pRadarInterface->setPowerStatusFunc(1,FALSE);
X                pRadarInterface->setPowerStatusFunc(1,(0));
N                return TRUE;
X                return (1);
N            }
N        }
N    }
N}
N#define LIDAR_0_ON_OFF_X 480
N#define LIDAR_0_ON_OFF_Y 250
N#define LIDAR_1_ON_OFF_X 480
N#define LIDAR_1_ON_OFF_Y 300
Nstatic BOOL lidarPowerSet(void* para1, void* para2)
N{
N    static BOOL radarStatus[2]={FALSE,FALSE};
X    static BOOL radarStatus[2]={(0),(0)};
N    BOOL changeFlag;
N    char* boolConvString[2]={"OFF   ","ON    "};
N    guiManagerShowScreen(GUI_LIDAR_ID, GUI_REDRAW_PARA_REFRESH, 0, POWER_SET_MODE);
X    guiManagerShowScreen(23, 0x03, 0, 1);
N    static RadarInterface* pRadarInterface;
N    char tmp;
N    terninalPrintf("!!! lidarPowerSet !!!\r\n");
N    pRadarInterface = RadarGetInterface(LIDAR_AV_DESIGN_INTERFACE_INDEX);
X    pRadarInterface = RadarGetInterface(1);
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N        return FALSE;
X        return (0);
N    }
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N        return FALSE;
X        return (0);
N    }
N    vTaskDelay(2000/portTICK_RATE_MS);
X    vTaskDelay(2000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    pRadarInterface->setPowerStatusFunc(0,radarStatus[0]);
N    pRadarInterface->setPowerStatusFunc(1,radarStatus[1]);
N    terninalPrintf("Now Status:\r\nLidar0 [%s]\r\nLidar1 [%s]\r\n",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N    terninalPrintf("Press...\r\n'0' set Lidar0 to [%s]\r\n'1' set Lidar1 to [%s]\r\n",boolConvString[!radarStatus[0]],boolConvString[!radarStatus[1]]);
N    #if(SUPPORT_HK_10_HW)
X    #if(1)
N    #else
S    while(1)
S    {
S        EPDDrawString(TRUE,"Wait    ",LIDAR_0_ON_OFF_X,LIDAR_0_ON_OFF_Y);
S        if(pRadarInterface->checkFeaturnFunc(0, &changeFlag, NULL, NULL)==LIDAR_FEATURE_FAIL)
S        {
S            EPDDrawString(TRUE,"FAIL    ",LIDAR_0_ON_OFF_X,LIDAR_0_ON_OFF_Y);
S        }
S        else
S        {
S            EPDDrawString(TRUE,"        ",LIDAR_0_ON_OFF_X,LIDAR_0_ON_OFF_Y);
S        }
S        EPDDrawString(TRUE,"Wait    ",LIDAR_1_ON_OFF_X,LIDAR_1_ON_OFF_Y);
S        if(pRadarInterface->checkFeaturnFunc(1, &changeFlag, NULL, NULL)==LIDAR_FEATURE_FAIL)
S        {
S            EPDDrawString(TRUE,"FAIL    ",LIDAR_1_ON_OFF_X,LIDAR_1_ON_OFF_Y);
S        }
S        else
S        {
S            EPDDrawString(TRUE,"        ",LIDAR_1_ON_OFF_X,LIDAR_1_ON_OFF_Y);
S            break;
S        }
S        if(userResponse()=='q')
S        {
S            return TRUE;
S        }
S    }
N    #endif
N    EPDDrawString(FALSE,boolConvString[radarStatus[0]],LIDAR_0_ON_OFF_X,LIDAR_0_ON_OFF_Y);
X    EPDDrawString((0),boolConvString[radarStatus[0]],480,250);
N    EPDDrawString(TRUE ,boolConvString[radarStatus[1]],LIDAR_1_ON_OFF_X,LIDAR_1_ON_OFF_Y);
X    EPDDrawString((1) ,boolConvString[radarStatus[1]],480,300);
N    while(1)
N    {
N        tmp=userResponseLoop();
N        setPrintfFlag(FALSE);
X        setPrintfFlag((0));
N        if(tmp=='q')
N        {
N            break;
N        }
N        else if(tmp=='0')
N        {
N            radarStatus[0]=!(radarStatus[0]);
N            pRadarInterface->setPowerStatusFunc(0,radarStatus[0]);
N        }
N        else if(tmp=='1')
N        {
N            radarStatus[1]=!(radarStatus[1]);
N            pRadarInterface->setPowerStatusFunc(1,radarStatus[1]);
N        }
N        terninalPrintf("Now Status:\r\nLidar0 [%s]\r\nLidar1 [%s]\r\n",boolConvString[radarStatus[0]],boolConvString[radarStatus[1]]);
N        EPDDrawString(FALSE,boolConvString[radarStatus[0]],LIDAR_0_ON_OFF_X,LIDAR_0_ON_OFF_Y);
X        EPDDrawString((0),boolConvString[radarStatus[0]],480,250);
N        EPDDrawString(TRUE ,boolConvString[radarStatus[1]],LIDAR_1_ON_OFF_X,LIDAR_1_ON_OFF_Y);
X        EPDDrawString((1) ,boolConvString[radarStatus[1]],480,300);
N        terninalPrintf("Press...\r\n'0' set Lidar0 to [%s]\r\n'1' set Lidar1 to [%s]\r\n",boolConvString[!radarStatus[0]],boolConvString[!radarStatus[1]]);
N        setPrintfFlag(TRUE); 
X        setPrintfFlag((1)); 
N    }
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 9742 10 variable "changeFlag" was declared but never referenced
N}
N
N///////////////////////////Burn  Test/////////////////////////////////
N
N//static int epdImageLoopId[5]={EPD_PICT_ALL_WHITE_INDEX, EPD_PICT_ALL_BLACK_INDEX, EPD_PICT_INDEX_INIT, EPD_PICT_INDEX_INIT_FAIL, EPD_PICT_INDEX_FILE_DOWNLOADING};
N
Nstatic int epdImageLoopId[5]={EPD_PICT_ALL_BLACK_INDEX, EPD_PICT_ALL_WHITE_INDEX, EPD_PICT_INDEX_INIT, EPD_PICT_INDEX_INIT_FAIL, EPD_PICT_INDEX_FILE_DOWNLOADING};
Nstatic BOOL epdBurningTest(void* para1, void* para2)
N{    
N    //setPrintfFlag(FALSE);
N    //terninalPrintf("!!! epdImageLoopId !!!\r\n");
N    //terninalPrintf("Press 'q' to exit\r\n");
N    terninalPrintf("Press 'q' to exit\r\n");
N    //guiManagerShowScreen(GUI_NULL_ID, GUI_REDRAW_PARA_REFRESH, 0, 0);
N    //setPrintfFlag(FALSE);
N    //EpdDrvInit(TRUE);
N    //EPDSetBacklight(TRUE);
N    //EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_BLACK_INDEX,0,0);
N    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE);
X    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, (1));
N    for(int i = 0; i<3;)
N    {    
N        //EPDShowBGScreen(epdImageLoopId[i], TRUE); 
N        EPDShowBGScreenEx(epdImageLoopId[i],TRUE,500,500);
X        EPDShowBGScreenEx(epdImageLoopId[i],(1),500,500);
N        //vTaskDelay(2000/portTICK_RATE_MS);
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //if(i == 2)
N        if(i == 1)
N        {
N            i = 0;
N        }
N        else
N        {
N            i++;
N        }
N        if(userResponse()=='q'){
N            break;
N        }
N    }
N    //guiManagerRefreshScreen();
N    
N    GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X    GuiManagerCleanMessage(0x04);
N    
N    //EPDSetBacklight(FALSE);
N    //setPrintfFlag(TRUE);
N    return TRUE;
X    return (1);
N}
Nstatic BOOL calibrationConfig(void* para1, void* para2)
N{
N    
N    char tempchar;
N    static RadarInterface* pRadarInterface;
N    BOOL changeFlag;
N    int distValue[2];
N    char distStringBuff[2][20];
N    
N    short m_MEMSx,m_MEMSy,m_MEMSz;
N    char responsechar;
N    
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(calibrationListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", calibrationListItem[i].charItem, calibrationListItem[i].itemName);
N        
N    }
N    guiManagerShowScreen(GUI_CALIBRATION_ID, GUI_REDRAW_PARA_REFRESH, (int)calibrationListItem ,(int)SetGuiResponseVal);
X    guiManagerShowScreen(25, 0x03, (int)calibrationListItem ,(int)SetGuiResponseVal);
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");
N        setTesterFlag(FALSE);
X        setTesterFlag((0));
N        tempchar = userResponseLoop();
N        setTesterFlag(TRUE);
X        setTesterFlag((1));
N        terninalPrintf("%c",tempchar);
N        GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
X        GuiManagerCleanMessage(0x07);
N        switch(tempchar)
N        {
N            case 'a':
N                terninalPrintf("\r\n");
N                while(1)
N                {   
N                    responsechar = userResponse();
N                    if(responsechar == 'q')
N                        break;
N                    else if(responsechar == 'c')
N                    {   
N                        if(MemsCalibrationSet(&m_MEMSx,&m_MEMSy,&m_MEMSz))
N                        {
N                            terninalPrintf("After MEMS calibration X=%d Y=%d Z=%d\r\n",m_MEMSx,m_MEMSy,m_MEMSz);
N                        }
N                    }
N                        
N                    if(QueryMEMSValue(&m_MEMSx,&m_MEMSy,&m_MEMSz))                       
N                        terninalPrintf("MEMS measurement: X=%d Y=%d Z=%d\r\n",m_MEMSx,m_MEMSy,m_MEMSz);
N                    else
N                        terninalPrintf("MEMS measurement: No data.\r\n");
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N                break;
N            case 'b':    
N                SolarValtageCalibration();
N                break;
N            case 'm':
N                //short m_MEMSx,m_MEMSy,m_MEMSz;
N                QueryMEMSValue(&m_MEMSx,&m_MEMSy,&m_MEMSz);
N                terninalPrintf("MEMS measurement: X=%d Y=%d Z=%d\r\n",m_MEMSx,m_MEMSy,m_MEMSz);
N                break;
N            case '0':
N                terninalPrintf("\r\n =====  [0)MEMSCalibration Start] =====\r\n");
N                EPDDrawString(FALSE,"                              ",100,100+(44*(10)));
X                EPDDrawString((0),"                              ",100,100+(44*(10)));
N                EPDDrawString(FALSE,"                              ",100,100+(44*(11)));
X                EPDDrawString((0),"                              ",100,100+(44*(11)));
N                //EPDDrawString(FALSE,"           ",300+400,100+(44*(2)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(3)));
X                EPDDrawString((0),"           ",300+400,100+(44*(3)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(4)));
X                EPDDrawString((0),"           ",300+400,100+(44*(4)));
N                EPDDrawString(TRUE,"Wait",300+400,100+(44*(2)));
X                EPDDrawString((1),"Wait",300+400,100+(44*(2)));
N                short MEMSx,MEMSy,MEMSz;
N                QueryMEMSValue(&MEMSx,&MEMSy,&MEMSz);
N                terninalPrintf("Before MEMS calibration X=%d Y=%d Z=%d\r\n",MEMSx,MEMSy,MEMSz);
N                if(MemsCalibrationSet(&MEMSx,&MEMSy,&MEMSz))
N                {
N                    terninalPrintf("After MEMS calibration X=%d Y=%d Z=%d\r\n",MEMSx,MEMSy,MEMSz);
N                    QueryMEMSValueEx(&MEMSx,&MEMSy,&MEMSz);
N                    terninalPrintf("After MEMS calibration X=%d Y=%d Z=%d\r\n",MEMSx,MEMSy,MEMSz);
N                    EPDDrawString(TRUE,"OK   ",300+400,100+(44*(2)));
X                    EPDDrawString((1),"OK   ",300+400,100+(44*(2)));
N                }
N                else
N                {
N                    EPDDrawString(TRUE,"FAIL ",300+400,100+(44*(2)));
X                    EPDDrawString((1),"FAIL ",300+400,100+(44*(2)));
N                }
N                break;
N            case '1':
N                //EPDDrawString(TRUE,"no Function",300+400,100+(44*(3)));
N                EPDDrawString(FALSE,"                              ",100,100+(44*(10)));
X                EPDDrawString((0),"                              ",100,100+(44*(10)));
N                EPDDrawString(FALSE,"                              ",100,100+(44*(11)));
X                EPDDrawString((0),"                              ",100,100+(44*(11)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(2)));
X                EPDDrawString((0),"           ",300+400,100+(44*(2)));
N                //EPDDrawString(FALSE,"           ",300+400,100+(44*(3)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(4)));
X                EPDDrawString((0),"           ",300+400,100+(44*(4)));
N                EPDDrawString(TRUE,"Wait       ",300+400,100+(44*(3)));
X                EPDDrawString((1),"Wait       ",300+400,100+(44*(3)));
N
N                //terninalPrintf("\r\n!!! lidar1Test !!!\r\n");
N                terninalPrintf("\r\n =====  [1)lidar1Calibration Start] =====\r\n");
N            
N                //setPrintfFlag(FALSE);
N                //pRadarInterface = RadarGetInterface(LIDAR_AV_DESIGN_INTERFACE_INDEX);
N                pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X                pRadarInterface = RadarGetInterface(0);
N                if(pRadarInterface == NULL)
X                if(pRadarInterface == 0)
N                {
N                    terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N                    return FALSE;
X                    return (0);
N                }
N                if(pRadarInterface->initFunc() == FALSE)
X                if(pRadarInterface->initFunc() == (0))
N                {
N                    terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N                    return FALSE;
X                    return (0);
N                }
N                terninalPrintf("Press 'q' to Exit\r\n");
N                EPDDrawString(TRUE,"Start Li1  ",300+400,100+(44*(3)));
X                EPDDrawString((1),"Start Li1  ",300+400,100+(44*(3)));
N                
N                int retry1 = 3;
N                //int tempvalue;
N                while(retry1 >0)
N                {
N                    pRadarInterface->setStartCalibrate(0, TRUE);
X                    pRadarInterface->setStartCalibrate(0, (1));
N                    //tempvalue = pRadarInterface->checkFeaturnFunc( 0, &changeFlag, NULL, NULL, NULL);
N                    //terninalPrintf("tempvalue = %d \r\n",tempvalue);
N                    if(pRadarInterface->checkFeaturnFunc( 0, &changeFlag, NULL, NULL, NULL) == RADAR_CALIBRATION_OK)  
X                    if(pRadarInterface->checkFeaturnFunc( 0, &changeFlag, 0, 0, 0) == 0x51)  
N                        break;
N                    retry1--;
N                }
N                
N                if(retry1 >0)
N                {
N
N                    pRadarInterface->setPowerStatusFunc(0,FALSE);
X                    pRadarInterface->setPowerStatusFunc(0,(0));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    pRadarInterface->setPowerStatusFunc(0,TRUE);
X                    pRadarInterface->setPowerStatusFunc(0,(1));
N                    vTaskDelay(4000/portTICK_RATE_MS);
X                    vTaskDelay(4000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N
N                    
N                    
N                    pRadarInterface->checkFeaturnFunc( 0, &changeFlag, NULL, NULL, NULL);
X                    pRadarInterface->checkFeaturnFunc( 0, &changeFlag, 0, 0, 0);
N
N                    EPDDrawString(TRUE,"           ",300+400,100+(44*(3)));
X                    EPDDrawString((1),"           ",300+400,100+(44*(3)));
N                    
N                    if(pRadarInterface->readDistValueFunc(0,&distValue[0]) == TRUE)
X                    if(pRadarInterface->readDistValueFunc(0,&distValue[0]) == (1))
N                    {
N                        terninalPrintf("\r\nLidar1 Distance:%d  \r\n",distValue[0]);
N                        sprintf(distStringBuff[0],"Lidar1 Dist:%d        ",distValue[0]);
N                        EPDDrawString(TRUE,distStringBuff[0],100,100+(44*(10)));
X                        EPDDrawString((1),distStringBuff[0],100,100+(44*(10)));
N                    }
N                    else
N                    {
N                        terninalPrintf("\r\nLidar1 calibration fail.\r\n");
N                        EPDDrawString(TRUE,"Lidar1 not calibrated",100,100+(44*(10)));
X                        EPDDrawString((1),"Lidar1 not calibrated",100,100+(44*(10)));
N                    }
N                }
N                else
N                {
N                    terninalPrintf("\r\nLidar1 calibration fail.\r\n");
N                    EPDDrawString(FALSE,"           ",300+400,100+(44*(3)));
X                    EPDDrawString((0),"           ",300+400,100+(44*(3)));
N                    EPDDrawString(TRUE,"Lidar1 not calibrated",100,100+(44*(10)));
X                    EPDDrawString((1),"Lidar1 not calibrated",100,100+(44*(10)));
N                }
N                pRadarInterface->setPowerStatusFunc(0,FALSE);
X                pRadarInterface->setPowerStatusFunc(0,(0));
N                
N                break;
N            case '2':
N                EPDDrawString(FALSE,"                              ",100,100+(44*(10)));
X                EPDDrawString((0),"                              ",100,100+(44*(10)));
N                EPDDrawString(FALSE,"                              ",100,100+(44*(11)));
X                EPDDrawString((0),"                              ",100,100+(44*(11)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(2)));
X                EPDDrawString((0),"           ",300+400,100+(44*(2)));
N                EPDDrawString(FALSE,"           ",300+400,100+(44*(3)));
X                EPDDrawString((0),"           ",300+400,100+(44*(3)));
N                //EPDDrawString(TRUE,"           ",300+400,100+(44*(4)));
N                EPDDrawString(TRUE,"Wait       ",300+400,100+(44*(4)));
X                EPDDrawString((1),"Wait       ",300+400,100+(44*(4)));
N                //static RadarInterface* pRadarInterface;
N                //BOOL changeFlag;
N                //terninalPrintf("\r\n!!! lidar2Test !!!\r\n");
N                terninalPrintf("\r\n =====  [2)lidar2Calibration Start] =====\r\n");
N                //setPrintfFlag(FALSE);
N                //pRadarInterface = RadarGetInterface(LIDAR_AV_DESIGN_INTERFACE_INDEX);
N                pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
X                pRadarInterface = RadarGetInterface(0);
N                if(pRadarInterface == NULL)
X                if(pRadarInterface == 0)
N                {
N                    terninalPrintf("lidarTest ERROR (pRadarInterface == NULL)!!\n");
N                    return FALSE;
X                    return (0);
N                }
N                if(pRadarInterface->initFunc() == FALSE)
X                if(pRadarInterface->initFunc() == (0))
N                {
N                    terninalPrintf("lidarTest ERROR (initFunc false)!!\n");
N                    return FALSE;
X                    return (0);
N                }
N                terninalPrintf("Press 'q' to Exit\r\n");
N                EPDDrawString(TRUE,"Start Li2  ",300+400,100+(44*(4)));
X                EPDDrawString((1),"Start Li2  ",300+400,100+(44*(4)));
N
N                int retry2 = 3;
N                while(retry2 >0)
N                {
N                    pRadarInterface->setStartCalibrate(1, TRUE);
X                    pRadarInterface->setStartCalibrate(1, (1));
N                    if(pRadarInterface->checkFeaturnFunc( 1, &changeFlag, NULL, NULL, NULL) == RADAR_CALIBRATION_OK)  
X                    if(pRadarInterface->checkFeaturnFunc( 1, &changeFlag, 0, 0, 0) == 0x51)  
N                        break;
N                    retry2--;
N                }
N                
N                if(retry2 >0)
N                {
N
N                    pRadarInterface->setPowerStatusFunc(1,FALSE);
X                    pRadarInterface->setPowerStatusFunc(1,(0));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    pRadarInterface->setPowerStatusFunc(1,TRUE);
X                    pRadarInterface->setPowerStatusFunc(1,(1));
N                    vTaskDelay(4000/portTICK_RATE_MS);
X                    vTaskDelay(4000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    
N                    
N                    pRadarInterface->checkFeaturnFunc( 1, &changeFlag, NULL, NULL, NULL);              
X                    pRadarInterface->checkFeaturnFunc( 1, &changeFlag, 0, 0, 0);              
N
N                    EPDDrawString(TRUE,"           ",300+400,100+(44*(4)));
X                    EPDDrawString((1),"           ",300+400,100+(44*(4)));
N                    
N                    if(pRadarInterface->readDistValueFunc(1,&distValue[1]) == TRUE)
X                    if(pRadarInterface->readDistValueFunc(1,&distValue[1]) == (1))
N                    {
N                        terninalPrintf("\r\nLidar2 Distance:%d  \r\n",distValue[1]);
N                        sprintf(distStringBuff[1],"Lidar2 Dist:%d        ",distValue[1]);
N                        EPDDrawString(TRUE,distStringBuff[1],100,100+(44*(11)));
X                        EPDDrawString((1),distStringBuff[1],100,100+(44*(11)));
N                    }
N                    else
N                    {
N                        terninalPrintf("\r\nLidar2 calibration fail.\r\n");
N                        EPDDrawString(TRUE,"Lidar2 not calibrated",100,100+(44*(11)));
X                        EPDDrawString((1),"Lidar2 not calibrated",100,100+(44*(11)));
N                    }
N                }
N                else
N                {
N                    terninalPrintf("\r\nLidar2 calibration fail.\r\n");
N                    EPDDrawString(FALSE,"           ",300+400,100+(44*(4)));
X                    EPDDrawString((0),"           ",300+400,100+(44*(4)));
N                    EPDDrawString(TRUE,"Lidar2 not calibrated",100,100+(44*(11)));
X                    EPDDrawString((1),"Lidar2 not calibrated",100,100+(44*(11)));
N                }
N                pRadarInterface->setPowerStatusFunc(1,FALSE);
X                pRadarInterface->setPowerStatusFunc(1,(0));
N                
N                
N                break;
N            case '3':
N                EPDDrawString(TRUE,"no Function",300+400,100+(44*(4)));
X                EPDDrawString((1),"no Function",300+400,100+(44*(4)));
N                break;
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("error input");
N                break;
N        }
N
W "src\user\hwtester.c" 9899 9 transfer of control bypasses initialization of:
w "src\user\hwtester.c" 9899 9 variable "retry1" (declared at line 9982)
w "src\user\hwtester.c" 9899 9 variable "retry2" (declared at line 10056)
N        if(fExit)
N            break;
N       terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        
N        terninalPrintf("\r\n =====  [9)Calibration Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(calibrationListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", calibrationListItem[i].charItem, calibrationListItem[i].itemName);       
N        }
N    }
N    return TRUE;
X    return (1);
N}
N
N
N
Nstatic BOOL EPDflashTool(void* para1, void* para2)
N{
N    
N    char tempchar;
N    
N    int lastvcomValue;
N    int modifyvcomValue;
N    int newvcomValue; 
N    int recoveryvcomValue;
N    char lastVCOMString[9];
N    char modifyVCOMString[10];
N    char recoveryVCOMString[12];
N    
N    
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(EPDflashToolListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", EPDflashToolListItem[i].charItem, EPDflashToolListItem[i].itemName);
N        
N    }
N    guiManagerShowScreen(GUI_EPDFLASH_TOOL_ID, GUI_REDRAW_PARA_REFRESH, (int)EPDflashToolListItem ,(int)SetGuiResponseVal);
X    guiManagerShowScreen(28, 0x03, (int)EPDflashToolListItem ,(int)SetGuiResponseVal);
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");
N        //setTesterFlag(FALSE);
N        tempchar = userResponseLoop();
N        //setTesterFlag(TRUE);
N        terninalPrintf("%c",tempchar);
N        GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
X        GuiManagerCleanMessage(0x07);
N        switch(tempchar)
N        {
N            case 's':
N                setW25Q64BVspecialburn();
N                W25Q64BVburn();
N                clrW25Q64BVspecialburn();
N                break;
N            case 'd':
N                W25Q64BVdeviceID();
N                break;
N            case 'p':
N                W25Q64BVFetch();
N                break;
N            
N            case 'v':
N                terninalPrintf("\r\nVCOM value = %d \r\n",IT8951GetVCOM());
N                break;
N
N            case 'u':
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(4)));
N                //EPDDrawString(TRUE,"Wait",300+400,100+(44*(2)));
N                if(W25Q64BVQuery())
N                {
N                    //EPDDrawString(TRUE,"OK   ",300+400,100+(44*(2)));
N                }
N                else
N                {
N                    //EPDDrawString(TRUE,"FAIL ",300+400,100+(44*(2)));
N                }
N                break;
N            case 'e':
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(2)));
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(4)));
N                //EPDDrawString(TRUE,"Wait       ",300+400,100+(44*(3)));
N                W25Q64BVerase();
N                
N                break;
N            case '0':
N
N                //EPDDrawString(TRUE,"               ",575,100+(44*(2)));
N                terninalPrintf("\r\n =====  [0)FACTORY TEST Start] =====\r\n");
N                vTaskDelay(500/portTICK_RATE_MS);
X                vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                lastvcomValue = IT8951GetVCOM();
N
N                terninalPrintf("VCOM value before burn = %d \r\n",lastvcomValue);
N                //sprintf(lastVCOMString,"VCOM:%d   ",lastvcomValue );
N                //EPDDrawString(TRUE,lastVCOMString,575,100+(44*(2)));
N                if(lastvcomValue == 0)
N                {
N                    //if(SetEPDVCOM())
N                    if(SetEPDVCOMEx())           
N                    {
N                        //modifyvcomValue = IT8951GetVCOM();
N                        //terninalPrintf("New VCOM value = %d \r\n",modifyvcomValue);
N                        //sprintf(modifyVCOMString,":%d",modifyvcomValue );
N                        //EPDDrawString(TRUE,modifyVCOMString,550+150+8,100+(44*(2)));
N                        //vTaskDelay(1500/portTICK_RATE_MS);
N                        
N                        //terninalPrintf("New VCOM value = %d \r\n",*setVCOMpoint);
N                        terninalPrintf("New VCOM value = %d \r\n",setVCOMEx);
N                        vTaskDelay(1500/portTICK_RATE_MS);
X                        vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                        
N                    }
N                    else
N                    {
N                       // EPDDrawString(TRUE,"FAIL   ",90+575,100+(44*(2)));
N                        break;
N                    }
N                }
N                
N                GuiManagerCleanMessage(GUI_KEY_DISABLE);
X                GuiManagerCleanMessage(0x09);
N                if(W25Q64BVburn())
N                {
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    newvcomValue = IT8951GetVCOM();
N                    terninalPrintf("VCOM value after burn = %d \r\n",newvcomValue);
N                    //IT8951SetVCOM(modifyvcomValue);
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    if(lastvcomValue == 0)
N                    {
N                        //IT8951SetVCOM(*setVCOMpoint);
N                        IT8951SetVCOM(setVCOMEx);
N                    }
N                    else
N                        IT8951SetVCOM(lastvcomValue);
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    recoveryvcomValue = IT8951GetVCOM();
N                    terninalPrintf("Recovery VCOM value = %d \r\n",recoveryvcomValue);
N
N                    toggleEPDswitch(TRUE);
X                    toggleEPDswitch((1));
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE);
X                    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, (1));
N                    terninalPrintf("Enter EPD all black,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);
X                    EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, (1));
N                    terninalPrintf("Enter EPD all white,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDSetSleepFunction(TRUE);
X                    EPDSetSleepFunction((1));
N                    terninalPrintf("Enter EPD sleep mode,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDSetSleepFunction(FALSE);
X                    EPDSetSleepFunction((0));
N                    
N                    GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X                    GuiManagerCleanMessage(0x04);
N                    
N
N                    sprintf(recoveryVCOMString,"OK VCOM:%d   ",recoveryvcomValue );
N                    EPDDrawString(TRUE,recoveryVCOMString,575,100+(44*(2)));
X                    EPDDrawString((1),recoveryVCOMString,575,100+(44*(2)));
N
N     
N                    
N                }
N                else
N                {
N                    terninalPrintf("BURN FAIL\r\n");
N                    EPDDrawString(TRUE,"FAIL        ",90+575,100+(44*(2)));
X                    EPDDrawString((1),"FAIL        ",90+575,100+(44*(2)));
N                }
N                GuiManagerCleanMessage(GUI_KEY_ENABLE);
X                GuiManagerCleanMessage(0x08);
N
N                break;
N            /*
N            case '1':
N
N                EPDDrawString(TRUE,"         ",90+400,100+(44*(3)));
N                terninalPrintf("\r\n =====  [1)SD Burn Start] =====\r\n");
N                lastvcomValue = IT8951GetVCOM();
N
N                terninalPrintf("VCOM value before burn = %d \r\n",lastvcomValue);
N                sprintf(lastVCOMString,"VCOM:%d   ",lastvcomValue );
N                EPDDrawString(TRUE,lastVCOMString,400,100+(44*(3)));
N
N            
N                if(W25Q64BVburn())
N                {
N                    newvcomValue = IT8951GetVCOM();
N                    terninalPrintf("VCOM value after burn = %d \r\n",newvcomValue);
N                    IT8951SetVCOM(modifyvcomValue);
N                    recoveryvcomValue = IT8951GetVCOM();
N                    terninalPrintf("Recovery VCOM value = %d \r\n",recoveryvcomValue);
N                 
N                    EPDDrawString(TRUE,"$$$$$$$$$$$$    ",400,100+(44*(3)));
N                    EPDDrawString(TRUE,"------------    ",400,100+(44*(3)));
N                    sprintf(recoveryVCOMString,"OK VCOM:%d   ",recoveryvcomValue );
N                    EPDDrawString(TRUE,recoveryVCOMString,400,100+(44*(3)));
N     
N                    
N                }
N                else
N                {
N                    terninalPrintf("BURN FAIL\r\n");
N                    EPDDrawString(TRUE,"FAIL        ",90+400,100+(44*(3)));
N                }
N                
N
N                break;
N            */
N            case '1':
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(4)));
N                //EPDDrawString(TRUE,"Wait",300+400,100+(44*(2)));
N                terninalPrintf("\r\n =====  [1)EPD VCOM Start] =====\r\n");
N                int tempVCOM;
N                char VCOMString[5];
N                tempVCOM = IT8951GetVCOM();
N                terninalPrintf("\r\nLast VCOM value = %d \r\n",tempVCOM );
N                sprintf(VCOMString,":%d   ",tempVCOM );
N                //EPDDrawString(TRUE,VCOMString,300+400,100+(44*(3)));
N                EPDDrawString(TRUE,VCOMString,90+300,100+(44*(4)));
X                EPDDrawString((1),VCOMString,90+300,100+(44*(4)));
N                if(SetEPDVCOM())
N                {
N                    vTaskDelay(500/portTICK_RATE_MS);
X                    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    tempVCOM = IT8951GetVCOM();
N                    vTaskDelay(100/portTICK_RATE_MS);
X                    vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    terninalPrintf("New VCOM value = %d \r\n",tempVCOM);
N                    sprintf(VCOMString,":%d",tempVCOM );
N                    //EPDDrawString(TRUE,VCOMString,300+400,100+(44*(3)));
N                    EPDDrawString(TRUE,VCOMString,90+300,100+(44*(4)));
X                    EPDDrawString((1),VCOMString,90+300,100+(44*(4)));
N                    //EPDDrawString(TRUE,"OK   ",300+400,100+(44*(2)));
N                }
N                else
N                {
N                    EPDDrawString(TRUE,"FAIL   ",90+400,100+(44*(4)));
X                    EPDDrawString((1),"FAIL   ",90+400,100+(44*(4)));
N                }
N                
N                
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_BLACK_INDEX,80,600-44);
X                EPDDrawContainByIDPos((1),EPD_PICT_ALL_BLACK_INDEX,80,600-44);
N                vTaskDelay(100/portTICK_RATE_MS);
X                vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,80,600-44);
X                EPDDrawContainByIDPos((1),EPD_PICT_ALL_WHITE_INDEX,80,600-44);
N                vTaskDelay(100/portTICK_RATE_MS);
X                vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                EPDDrawStringMax(TRUE," <>:Move   {:Select    }:Exit ",90,700-44,TRUE);
X                EPDDrawStringMax((1)," <>:Move   {:Select    }:Exit ",90,700-44,(1));
N                
N                break;
N            
N            case '2':
N                terninalPrintf("\r\n =====  [2)EPD Burning Test Start] =====\r\n");
N                epdBurningTest(NULL,NULL);
X                epdBurningTest(0,0);
N                break;
N            case '3':  
N                terninalPrintf("\r\n =====  [3)EPD All Black Start] =====\r\n");
N                //EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_BLACK_INDEX,0,0);
N                EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE);            
X                EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, (1));            
N                terninalPrintf("\r\nPress 'q' to Exit Test\n");
N                while(userResponseLoop()!='q');            
N                GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X                GuiManagerCleanMessage(0x04);
N                
N                /*
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N                EPDDrawStringMax(FALSE,"EPDflashTool",90,28,FALSE);
N                EPDDrawStringMax(FALSE," <>:Move   {:Select    }:Exit ",180,700-44,TRUE);
N    
N                for(int i=0;i<6;i++)
N                {
N                    EPDDrawStringMax(FALSE,EPDflashToolListItem[i].itemName,300+50,100+(44*(2+i)),FALSE);
N                    EPDDrawStringMax(FALSE,"-",300,100+(44*(2+i)),TRUE);
N                }
N                EPDDrawString(FALSE,"ENABLE  ",300+450,100+(44*(7)));
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_LINE_SMALL_2_I_INDEX,300,100+(44*(5)));
N                */
N
N                break;    
N            case '4':
N                terninalPrintf("\r\n =====  [4)EPD All White Start] =====\r\n");
N                //EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N                EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);              
X                EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, (1));              
N                terninalPrintf("\r\nPress 'q' to Exit Test\n");
N                while(userResponseLoop()!='q');            
N                GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X                GuiManagerCleanMessage(0x04);
N                /*
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N                EPDDrawStringMax(FALSE,"EPDflashTool",90,28,FALSE);
N                EPDDrawStringMax(FALSE," <>:Move   {:Select    }:Exit ",180,700-44,TRUE);
N    
N                for(int i=0;i<6;i++)
N                {
N                    EPDDrawStringMax(FALSE,EPDflashToolListItem[i].itemName,300+50,100+(44*(2+i)),FALSE);
N                    EPDDrawStringMax(FALSE,"-",300,100+(44*(2+i)),TRUE);
N                }
N                EPDDrawString(FALSE,"ENABLE  ",300+450,100+(44*(7)));
N                EPDDrawContainByIDPos(TRUE,EPD_PICT_LINE_SMALL_2_I_INDEX,300,100+(44*(6)));
N                */
N                
N                break;              
N            case '5':
N                //setPrintfFlag(FALSE);
N                if(readEPDswitch() == TRUE)
X                if(readEPDswitch() == (1))
N                {
N                    //EPDDrawString(TRUE,"DISABLE",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"DISABLE",90+325,100+(44*(7)));
X                    EPDDrawString((1),"DISABLE",90+325,100+(44*(7)));
N                    //terninalPrintf("\r\nEPD display disable.\r\n");
N                    //terninalPrintf("\r\n =====  [1)EPD display disable] =====\r\n");
N                    terninalPrintf("\r\n =====  [5)EPD DISP Start] =====\r\n");
N                    terninalPrintf("EPD display disable.\r\n");
N                    toggleEPDswitch(FALSE);
X                    toggleEPDswitch((0));
N
N                }
N                else
N                {
N                    terninalPrintf("\r\n =====  [5)EPD DISP Start] =====\r\n");
N                    vTaskDelay(500/portTICK_RATE_MS);
X                    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    toggleEPDswitch(TRUE);
X                    toggleEPDswitch((1));
N                    //GuiManagerInit();
N                    EPDSetBacklight(FALSE);
X                    EPDSetBacklight((0));
N                    //terninalPrintf("\r\nEPD display enable.\r\n");
N                    //terninalPrintf("\r\n =====  [1)EPD display enable] =====\r\n");
N                    terninalPrintf("EPD display enable.\r\n");
N                    //setSpecialCleanFlag(TRUE);
N                    //EPDDrawString(TRUE,"$$$$$$$",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"$$$$$$$",90+325,100+(44*(7)));
X                    EPDDrawString((1),"$$$$$$$",90+325,100+(44*(7)));
N                    //EPDDrawString(TRUE,"------  ",300+450,100+(44*(3)));
N                   // EPDDrawContainByIDPos(FALSE,EPD_PICT_LINE_SMALL_2_INDEX ,300,100+(44*(oldIndex+2)));
N                    //EPDDrawString(TRUE,"ENABLE  ",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"ENABLE  ",90+325,100+(44*(7)));
X                    EPDDrawString((1),"ENABLE  ",90+325,100+(44*(7)));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N            
N            
N                //EPDDrawString(TRUE,"no Function",300+400,100+(44*(4)));
N                break;
N
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("\r\nerror input");
N                break;
N        }
N
N        if(fExit)
N            break;
N        terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        
N        terninalPrintf("\r\n =====  [a)EPD Tool Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(EPDflashToolListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", EPDflashToolListItem[i].charItem, EPDflashToolListItem[i].itemName);
N        
N        }
N    }
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 10138 9 variable "modifyvcomValue" was declared but never referenced
W "src\user\hwtester.c" 10141 10 variable "lastVCOMString" was declared but never referenced
W "src\user\hwtester.c" 10142 10 variable "modifyVCOMString" was declared but never referenced
N}
N
Nstatic BOOL NewRadarTool(void* para1, void* para2)
N{
N
N    char tempchar;
N    uint16_t mindex,rindex;
N    uint16_t FRtype = 0;  // 0:F type  1:R type
N    BOOL TempResult;
N    RadarInterface* pRadarInterface;
N    
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(NewRadarToolListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", NewRadarToolListItem[i].charItem, NewRadarToolListItem[i].itemName);
N        
N    }
N         
N    guiManagerShowScreen(GUI_RADAR_TOOL_ID, GUI_REDRAW_PARA_REFRESH, (int)NewRadarToolListItem ,(int)SetGuiResponseVal);
X    guiManagerShowScreen(32, 0x03, (int)NewRadarToolListItem ,(int)SetGuiResponseVal);
N    //setPrintfFlag(TRUE);
N    
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    
N
N    
N    
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");        
N        setTesterFlag(FALSE);
X        setTesterFlag((0));
N        tempchar = userResponseLoop();
N        setTesterFlag(TRUE);
X        setTesterFlag((1));
N        terninalPrintf("%c",tempchar);
N        //GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
N        //setPrintfFlag(TRUE);
N        switch(tempchar)
N        {
N            case '0':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [0)Set RadarA Parameter Start] =====\r\n");
N                //GuiManagerCleanMessage(GUI_SET_RADARA_PARAMETER);
N                mindex = 0;   // EPM right side               
N                TempResult = NEWradarSetDefault(&mindex,NULL);
X                TempResult = NEWradarSetDefault(&mindex,0);
N                if( (TempResult == FALSE) || (TempResult == TEST_FALSE) )
X                if( (TempResult == (0)) || (TempResult == 0x10) )
N                    break;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                GuiManagerCleanMessage(GUI_NEW_RADAR_TEST);
X                GuiManagerCleanMessage(0x32);
N                NEWradarTest(NULL,NULL);
X                NEWradarTest(0,0);
N                break;
N                
N            case '1':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [1)Set RadarB Parameter Start] =====\r\n");
N                //GuiManagerCleanMessage(GUI_SET_RADARB_PARAMETER);
N                mindex = 1;   // EPM left side 
N                TempResult = NEWradarSetDefault(&mindex,NULL);
X                TempResult = NEWradarSetDefault(&mindex,0);
N                if( (TempResult == FALSE) || (TempResult == TEST_FALSE) )
X                if( (TempResult == (0)) || (TempResult == 0x10) )
N                    break;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                GuiManagerCleanMessage(GUI_NEW_RADAR_TEST);
X                GuiManagerCleanMessage(0x32);
N                NEWradarTest(NULL,NULL);
X                NEWradarTest(0,0);
N                break;
N            case '2':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [2)Set RadarA Parameter Start] =====\r\n");
N                //GuiManagerCleanMessage(GUI_SET_RADARA_PARAMETER);
N                rindex = 0;                
N                TempResult = NEWradarSet(&rindex,NULL);
X                TempResult = NEWradarSet(&rindex,0);
N                if( (TempResult == FALSE) || (TempResult == TEST_FALSE) )
X                if( (TempResult == (0)) || (TempResult == 0x10) )
N                    break;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                GuiManagerCleanMessage(GUI_NEW_RADAR_TEST);
X                GuiManagerCleanMessage(0x32);
N                NEWradarTest(NULL,NULL);
X                NEWradarTest(0,0);
N                break;
N            case '3':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [3)Set RadarB Parameter Start] =====\r\n");
N                //GuiManagerCleanMessage(GUI_SET_RADARB_PARAMETER);
N                rindex = 1;
N                TempResult = NEWradarSet(&rindex,NULL);
X                TempResult = NEWradarSet(&rindex,0);
N                if( (TempResult == FALSE) || (TempResult == TEST_FALSE) )
X                if( (TempResult == (0)) || (TempResult == 0x10) )
N                    break;
N                vTaskDelay(1000/portTICK_RATE_MS);
X                vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                GuiManagerCleanMessage(GUI_NEW_RADAR_TEST);
X                GuiManagerCleanMessage(0x32);
N                NEWradarTest(NULL,NULL);
X                NEWradarTest(0,0);
N                break;
N            case '4':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [4)New Radar Test Start] =====\r\n");
N                /*
N                terninalPrintf("\r\nPlease enter F/R parameters in decimal.(0:F type  1:R type)\r\n");
N                terninalPrintf("Enter number is ");
N                FRtype = SetValue(1);
N                terninalPrintf("\r\n");
N                if(FRtype == 0xffff)
N                {
N                    FRtype = 0;
N                    break;
N                }
N
N                if(FRtype > 1)
N                {
N                    terninalPrintf("input error.\r\n");
N                    FRtype = 0;
N                    break;
N                }
N                */
N                GuiManagerCleanMessage(GUI_NEW_RADAR_TEST);
X                GuiManagerCleanMessage(0x32);
N                NEWradarTest(NULL,NULL);
X                NEWradarTest(0,0);
N                break;     
N            case '5':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [5)RadarA OTA] =====\r\n");
N            
N                pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X                pRadarInterface = RadarGetInterface(2);
N                if(pRadarInterface == NULL)
X                if(pRadarInterface == 0)
N                {
N                    terninalPrintf("NEWradarTest ERROR (pRadarInterface == NULL)!!\n");
N                    break;
N                }
N                if(pRadarInterface->RadarRB60POTAFunc(0) == FALSE)
X                if(pRadarInterface->RadarRB60POTAFunc(0) == (0))
N                {
N                    terninalPrintf("RB60POTAFunc ERROR!!\n");
N                    EPDDrawString(TRUE,"ERROR            ",580,100+(44*(2+5)));  
X                    EPDDrawString((1),"ERROR            ",580,100+(44*(2+5)));  
N                }
N                pRadarInterface->initFunc();                    
N                break;  
N            case '6':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [6)RadarB OTA] =====\r\n");
N            
N                pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);
X                pRadarInterface = RadarGetInterface(2);
N                if(pRadarInterface == NULL)
X                if(pRadarInterface == 0)
N                {
N                    terninalPrintf("NEWradarTest ERROR (pRadarInterface == NULL)!!\n");
N                    break;
N                }
N                if(pRadarInterface->RadarRB60POTAFunc(1) == FALSE)
X                if(pRadarInterface->RadarRB60POTAFunc(1) == (0))
N                {
N                    terninalPrintf("RB60POTAFunc ERROR!!\n");
N                    EPDDrawString(TRUE,"ERROR            ",580,100+(44*(2+6)));  
X                    EPDDrawString((1),"ERROR            ",580,100+(44*(2+6)));  
N                }
N                pRadarInterface->initFunc(); 
N                break;                  
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                //terninalPrintf("\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("\r\n");
N                terninalPrintf("error input");
N                break;
N        }
N
N        if(fExit)
N            break;
N        terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        
N        terninalPrintf("\r\n =====  [4)New Radar Tool Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(NewRadarToolListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", NewRadarToolListItem[i].charItem, NewRadarToolListItem[i].itemName);
N        
N        }
N        if( (tempchar != '5') && (tempchar != '6') )
N            GuiManagerCleanMessage(GUI_REDRAW_PARA_REFRESH);
X            GuiManagerCleanMessage(0x03);
N    }
N    
N    
N        return TRUE;
X        return (1);
W "src\user\hwtester.c" 10479 14 variable "FRtype" was declared but never referenced
N}
N
N
Nstatic BOOL RadarOTATool(void* para1, void* para2)
N{
N    
N    char tempchar;
N    
N    
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(RadarOTAToolListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", RadarOTAToolListItem[i].charItem, RadarOTAToolListItem[i].itemName);
N        
N    }
N         
N    guiManagerShowScreen(GUI_RADAR_TOOL_ID, GUI_REDRAW_PARA_REFRESH, (int)RadarOTAToolListItem ,(int)SetGuiResponseVal);
X    guiManagerShowScreen(32, 0x03, (int)RadarOTAToolListItem ,(int)SetGuiResponseVal);
N    //setPrintfFlag(TRUE);
N    
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    
N      
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");        
N        setTesterFlag(FALSE);
X        setTesterFlag((0));
N        tempchar = userResponseLoop();
N        setTesterFlag(TRUE);
X        setTesterFlag((1));
N        terninalPrintf("%c",tempchar);
N        GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
X        GuiManagerCleanMessage(0x07);
N        //setPrintfFlag(TRUE);
N        switch(tempchar)
N        {
N
N            case '0':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [0)Radar1 OTA Start] =====\r\n");
N            
N                //pRadarInterface->setPowerStatusFunc(0,TRUE);
N            
N                //pRadarInterface->FirstOTAFunc(0,0);
N            
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(2)));
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                //EPDDrawString(TRUE,"Wait     ",300+400,100+(44*(2)));
N
N                RadarOTAprogramTool(0);
N                
N
N                    
N
N                
N                /*if(W25Q64BVburn())
N                {
N                    //EPDDrawString(FALSE,"        ",300+400,100+(44*(2)));
N                    //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                    EPDDrawString(TRUE,"OK          ",300+400,100+(44*(2)));
N                }
N                else
N                {
N                    terninalPrintf("BURN FAIL\r\n");
N                    //EPDDrawString(FALSE,"        ",300+400,100+(44*(2)));
N                    //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                    EPDDrawString(TRUE,"FAIL        ",300+400,100+(44*(2)));
N                }  */
N                
N                //pRadarInterface->setPowerStatusFunc(0,FALSE);
N
N                break;
N            case '1':
N                terninalPrintf("\r\n");
N                terninalPrintf("\r\n =====  [1)Radar2 OTA Start] =====\r\n");
N                //EPDDrawString(TRUE,"Wait     ",300+400,100+(44*(3)));
N
N                RadarOTAprogramTool(1);
N                
N            
N            
N            
N
N                //setPrintfFlag(FALSE);
N                /*if(readEPDswitch() == TRUE)
N                {
N                    EPDDrawString(TRUE,"DISABLE",300+450,100+(44*(3)));
N                    toggleEPDswitch(FALSE);
N                    terninalPrintf("EPD display disable.\r\n");
N                }
N                else
N                {
N                    toggleEPDswitch(TRUE);
N                    terninalPrintf("EPD display enable.\r\n");
N                    EPDDrawString(TRUE,"ENABLE  ",300+450,100+(44*(3)));
N                    vTaskDelay(1000/portTICK_RATE_MS);
N                }  */
N                //vTaskDelay(1000/portTICK_RATE_MS);
N                
N            
N                break;
N     
N
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                //terninalPrintf("\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("\r\n");
N                terninalPrintf("error input");
N                break;
N        }
N
N        if(fExit)
N            break;
N        terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        
N        terninalPrintf("\r\n =====  [b)Radar OTA Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(RadarOTAToolListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", RadarOTAToolListItem[i].charItem, RadarOTAToolListItem[i].itemName);
N        
N        }
N    }
N    
N    
N        return TRUE;
X        return (1);
N}
N
N
N
Nstatic BOOL versionQueryTool(void* para1, void* para2)
N{
N	  //uint8_t *VerCode1,*VerCode2,*VerCode3,*YearCode,*MonthCode,*DayCode,*HourCode,*MinuteCode;
N    uint8_t *code11,*code12,*code13,*code14,*code21,*code22,*code23,*code24;
N    int pageCounter = 0;
N    int pagechangeFlag = TRUE;
X    int pagechangeFlag = (1);
N    char tempchar;
N    char  preadFWVersion[16] , preadLUTVersion[16] , tempreadLUTVersion[17];
N    static char retVer[100],SIMStr[100];
N    
N    char* pch1= malloc(100);
N    char* SIMpch1= malloc(100);
N    char* pch2;
N    char* SIMpch2;
N    static char tempchr[100],SIMtempchr[100] ;  //= malloc(100);
N    char tempRadar1VersionString[50];
N    char tempRadar2VersionString[50];
N    static RadarInterface* pRadarInterface;
N    //RadarInterface* pRadarInterface;
N    
N    
N    int waitCounter = 15;//30;
N    //int iCount=0;
N    int ReaderStatus;
N    char ReaderVerBuf[64];
N    
N    EPDDrawContainByIDPos(TRUE,EPD_PICT_LOADING,500,250);
X    EPDDrawContainByIDPos((1),EPD_PICT_LOADING,500,250);
N   
N    //EPDDrawMulti(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);   
N    guiManagerShowScreen(GUI_VERSION_ID, GUI_REDRAW_PARA_REFRESH, 0 ,0);
X    guiManagerShowScreen(26, 0x03, 0 ,0);
N    
N    
N    EPDDrawString(FALSE,"------- Version  ------",180,0);
X    EPDDrawString((0),"------- Version  ------",180,0);
N    //EPDDrawContainByIDPos(TRUE,EPD_PICT_LOADING,500,50);
N    EPDDrawString(FALSE,"Checking",275,50);
X    EPDDrawString((0),"Checking",275,50);
N    //EPDDrawString(TRUE,"LED:\nAP:\nReader:\nEPD:\nSIM:\nMODEM:\nRADAR1:\nRADAR2:\n\n\nPress \'q\' to continue...",100,150);
N    EPDDrawString(TRUE,"LED:\nAP:\nReader:\nEPD:\nSIM:\nMODEM:\nRADAR1:\nRADAR2:",100,150);   
X    EPDDrawString((1),"LED:\nAP:\nReader:\nEPD:\nSIM:\nMODEM:\nRADAR1:\nRADAR2:",100,150);   
N       
N    //---LED---
N    uint8_t VerCode1,VerCode2,VerCode3,YearCode,MonthCode,DayCode,HourCode,MinuteCode;
N    char* string = malloc(29);
N                        //char* string2 = malloc(17);
N                        //terninalPrintf("%d",string);
N                        //char string[28];
N
N    if(QueryVersion(&VerCode1,&VerCode2,&VerCode3,&YearCode,&MonthCode,&DayCode,&HourCode,&MinuteCode))
N    {
N        /*terninalPrintf("VerCode1=%d\r\n",VerCode1);
N        terninalPrintf("VerCode2=%d\r\n",VerCode2);
N        terninalPrintf("VerCode3=%d\r\n",VerCode3);
N        terninalPrintf("YearCode=%d\r\n",YearCode);
N        terninalPrintf("MonthCode=%d\r\n",MonthCode);
N        terninalPrintf("DayCode=%d\r\n",DayCode);
N        terninalPrintf("HourCode=%d\r\n",HourCode);
N        terninalPrintf("MinuteCode=%d\r\n",MinuteCode);*/
N
N        *string      = 'V';
N        *(string+1)  = 'e';
N        *(string+2)  = 'r';
N        *(string+3)  = ' ';
N        *(string+4)  = 48+VerCode1;
N        *(string+5)  = '.';
N        *(string+6)  = 48+(VerCode2/10);
N        *(string+7)  = 48+(VerCode2%10);
N        *(string+8)  = '.';
N        *(string+9)  = 48+(VerCode3/10);
N        *(string+10) = 48+(VerCode3%10);		
N        *(string+11) = '\0';
N        *(string+12)  = 'b';
N        *(string+13)  = 'u';
N        *(string+14)  = 'i';
N        *(string+15)  = 'l';
N        *(string+16)  = 'd';
N        *(string+17)  = ' ';
N        *(string+18)  = 48+(YearCode/10);
N        *(string+19)  = 48+(YearCode%10);
N        *(string+20)  = 48+(MonthCode/10);
N        *(string+21)  = 48+(MonthCode%10);
N        *(string+22) = 48+(DayCode/10);
N        *(string+23) = 48+(DayCode%10);
N        *(string+24) = 48+(HourCode/10);
N        *(string+25) = 48+(HourCode%10);
N        *(string+26) = 48+(MinuteCode/10);
N        *(string+27) = 48+(MinuteCode%10);
N        *(string+28) = '\0';		
N         
N        terninalPrintf("LED : %s\r\n",string); 
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,string,350,150);
X        EPDDrawString((1),string,350,150);
N    }
N    else
N    {
N        terninalPrintf("LED : Error\r\n"); 
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,"Error",350,150);
X        EPDDrawString((1),"Error",350,150);
N    }
N
N    //---AP---
N    vTaskDelay(15/portTICK_RATE_MS);
X    vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    EPDDrawString(TRUE,"Error",350,200);
X    EPDDrawString((1),"Error",350,200);
N    
N    //---Reader---
N    
N    
N    if(!GPIO_ReadBit(GPIOJ, BIT4))
X    if(!GPIO_ReadBit(GPIOJ, (0x00000010)))
N    {
N    
N        CardReaderInit(FALSE);
X        CardReaderInit((0));
N        CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
X        CardReaderSetPower(0, (1));
N        terninalPrintf("READER CHECK ");
N
N        do{
N            ReaderStatus = CardReaderGetBootedStatus();
N
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            waitCounter--;
N            if(ReaderStatus == TSREADER_CHECK_READER_OK)
X            if(ReaderStatus == 2)
N            {   
N                OctopusReaderGetVersion(ReaderVerBuf);
N                break;
N            }
N            if(waitCounter == 0)
N            {
N                terninalPrintf("\nCHECK READER [Time Out]\n");
N                break;
N            }
N        }while(ReaderStatus != TSREADER_CHECK_READER_OK);
X        }while(ReaderStatus != 2);
N
N        terninalPrintf("ReaderVerBuf = %s\r\n",ReaderVerBuf);
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if (waitCounter <= 0)
N        {
N            EPDDrawString(TRUE,"Error",350,250);
X            EPDDrawString((1),"Error",350,250);
N        }
N        else
N        {
N            EPDDrawString(TRUE,ReaderVerBuf,350,250);
X            EPDDrawString((1),ReaderVerBuf,350,250);
N        }
N        
N        CardReaderSetPower(EPM_READER_CTRL_ID_GUI,FALSE);
X        CardReaderSetPower(0,(0));
N    }
N    else
N    {
N       
N        CardReaderInit(TRUE);
X        CardReaderInit((1));
N        CardReaderSetPower(EPM_READER_CTRL_ID_GUI, TRUE);
X        CardReaderSetPower(0, (1));
N        terninalPrintf("READER CHECK ");
N
N        do{
N            ReaderStatus = CardReaderGetBootedStatus();
N
N            vTaskDelay(1000/portTICK_RATE_MS);
X            vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            waitCounter--;
N            if(ReaderStatus == TSREADER_CHECK_READER_OK)
X            if(ReaderStatus == 2)
N            {   
N                EPMReaderGetVersion(ReaderVerBuf);
N                break;
N            }
N            if(waitCounter == 0)
N            {
N                terninalPrintf("\nCHECK READER [Time Out]\n");
N                break;
N            }
N        }while(ReaderStatus != TSREADER_CHECK_READER_OK);
X        }while(ReaderStatus != 2);
N
N        terninalPrintf("ReaderVerBuf = %s\r\n",ReaderVerBuf);
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        if (waitCounter <= 0)
N        {
N            EPDDrawString(TRUE,"Error",350,250);
X            EPDDrawString((1),"Error",350,250);
N        }
N        else
N        {
N            EPDDrawString(TRUE,ReaderVerBuf,350,250);
X            EPDDrawString((1),ReaderVerBuf,350,250);
N        }
N    
N    }  
N    
N    //---EPD---
N    
N    GuiManagerTimerSet(GUI_TIMER_DISABLE);
X    GuiManagerTimerSet(0x06);
N    vTaskDelay(1000/portTICK_RATE_MS);
X    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    vTaskDelay(1000/portTICK_RATE_MS);
X    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    ReadIT8951SystemInfo( preadFWVersion, preadLUTVersion);
N    //memcpy(tempreadLUTVersion,preadLUTVersion,16);
N    //tempreadLUTVersion[16] = '\0';//0x00;
N    /*
N    terninalPrintf("readFWVersion=");
N    
N    for (int p=0;p<16;p++)
N    {
N        terninalPrintf(" %02x",preadFWVersion[p]);
N    }
N    
N    terninalPrintf("\r\n");
N    
N    
N    terninalPrintf("readLUTVersion=");
N    
N    for (int p=0;p<16;p++)
N    {
N        terninalPrintf(" %02x",preadLUTVersion[p]);
N    }
N    
N    terninalPrintf("\r\n");
N    */
N    terninalPrintf("readFWVersion=%s\r\n",preadFWVersion);
N    terninalPrintf("readLUTVersion=%s\r\n",preadLUTVersion);
N    //terninalPrintf("IT8951GetVCOM = %d \r\n",IT8951GetVCOM());
N    vTaskDelay(15/portTICK_RATE_MS);
X    vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    if (preadFWVersion == NULL)
X    if (preadFWVersion == 0)
N    {
N        EPDDrawString(TRUE,"Error",350,300); 
X        EPDDrawString((1),"Error",350,300); 
N    }
N    else
N    {
N        EPDDrawString(TRUE,preadFWVersion,350,300); 
X        EPDDrawString((1),preadFWVersion,350,300); 
N    }
N    
N    
N    GuiManagerTimerSet(GUI_TIMER_ENABLE);
X    GuiManagerTimerSet(0x05);
N    
N    //---SIM---
N    BOOL QModemGetSIMNumberFlag ;
N    QModemGetSIMNumberFlag = QModemGetSIMNumber(SIMStr);
N
N    if(QModemGetSIMNumberFlag)
N    {           
N        memcpy(SIMtempchr,SIMStr,100);
N        SIMpch1 = (char*) memchr(SIMtempchr,'\n',100); 
N        memcpy(SIMtempchr,SIMpch1+1,99);    
N        SIMpch2 = (char*) memchr(SIMtempchr,'\n',100);
N        memset (SIMpch2,'\0',1);
N        //terninalPrintf("tempchr=%s\r\ntempchrAD=%d\r\n",SIMtempchr,SIMtempchr); 
N        terninalPrintf("SIM : %s\r\n",SIMtempchr);
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,SIMtempchr,350,350);        
X        EPDDrawString((1),SIMtempchr,350,350);        
N    }
N    else
N    {
N        terninalPrintf("SIM : Error\r\n"); 
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,"Error",350,350);
X        EPDDrawString((1),"Error",350,350);
N    }
N    
N    
N
N    
N    //---MODEM---
N    BOOL QModemGetVerFlag;
N    QModemGetVerFlag = QModemGetVer(retVer);
N    
N    if(QModemGetVerFlag)
N    {            
N        memcpy(tempchr,retVer,100);
N        pch1 = (char*) memchr(tempchr,'\n',100);
N        memcpy(tempchr,pch1+1,99);
N        pch2 = (char*) memchr(tempchr,'\n',100);
N        memset (pch2,'\0',1);
N        //terninalPrintf("tempchr=%s\r\ntempchrAD=%d\r\n",tempchr,tempchr);
N        terninalPrintf("MODEM : %s\r\n",tempchr);
N        vTaskDelay(15/portTICK_RATE_MS);
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        EPDDrawString(TRUE,tempchr,350,400); 
X        EPDDrawString((1),tempchr,350,400); 
N    }
N    else
N    {
N        terninalPrintf("MODEM : Error\r\n");
N        vTaskDelay(15/portTICK_RATE_MS);        
X        vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));        
N        EPDDrawString(TRUE,"Error",350,400); 
X        EPDDrawString((1),"Error",350,400); 
N    }
N
N    
N    
N    
N    //---RADAR---
N    
N    
N    BOOL changeFlag;
N    
N    uint8_t RadarData[22];
N    
N    uint8_t VersionCmd[9] = {0x7A, 0xA7, 0x00, 0x09, 0x00, 0x00, 0x09, 0xD3, 0x3D};
N    //pRadarInterface = RadarGetInterface(RADAR_AV_DESIGN_INTERFACE_INDEX);
N    pRadarInterface = RadarGetInterface(NEWRADAR_INTERFACE_INDEX);  
X    pRadarInterface = RadarGetInterface(2);  
N
N    if(pRadarInterface == NULL)
X    if(pRadarInterface == 0)
N    {
N        terninalPrintf("radarTest ERROR (pRadarInterface == NULL)!!\n");
N    }
N
N    if(pRadarInterface->initFunc() == FALSE)
X    if(pRadarInterface->initFunc() == (0))
N    {
N        terninalPrintf("radarTest ERROR (initFunc false)!!\n");
N    }
N    pRadarInterface->setPowerStatusFunc(0,TRUE);
X    pRadarInterface->setPowerStatusFunc(0,(1));
N    pRadarInterface->setPowerStatusFunc(1,TRUE);
X    pRadarInterface->setPowerStatusFunc(1,(1));
N
N    for(int j = 0; j<2; j++)
N    {
N        if(pRadarInterface->RadarResultFunc(j, 0x00,VersionCmd,RadarData) == TRUE)
X        if(pRadarInterface->RadarResultFunc(j, 0x00,VersionCmd,RadarData) == (1))
N        {   
N
N            terninalPrintf("Radar%d Version : Ver.%d.%d.%d.%d\r\n",j+1,RadarData[0],RadarData[1],RadarData[2],RadarData[3]);
N            
N            if(j == 0)
N            {
N                sprintf(tempRadar1VersionString,"VER %d.%d.%d.%d",RadarData[0],RadarData[1],RadarData[2],RadarData[3]);
N                vTaskDelay(15/portTICK_RATE_MS);
X                vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                EPDDrawString(TRUE,tempRadar1VersionString,350,450);
X                EPDDrawString((1),tempRadar1VersionString,350,450);
N            }
N            else if(j == 1)
N            {
N                sprintf(tempRadar2VersionString,"VER %d.%d.%d.%d",RadarData[0],RadarData[1],RadarData[2],RadarData[3]);
N                vTaskDelay(15/portTICK_RATE_MS);
X                vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                EPDDrawString(FALSE,tempRadar2VersionString,350,500);
X                EPDDrawString((0),tempRadar2VersionString,350,500);
N            }
N        }
N        else
N        {
N            terninalPrintf("Radar%d Version : Error\r\n",j+1);
N            vTaskDelay(15/portTICK_RATE_MS);
X            vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            if(j == 0)
N                EPDDrawString(TRUE,"Error",350,450);
X                EPDDrawString((1),"Error",350,450);
N            else if(j == 1)
N                EPDDrawString(TRUE,"Error",350,500);                
X                EPDDrawString((1),"Error",350,500);                
N        } 
N    }
N    /*
N    if(pRadarInterface -> readQueryVersionString(0, tempRadar1VersionString))
N    {
N        terninalPrintf("%s\r\n",tempRadar1VersionString);
N        vTaskDelay(15/portTICK_RATE_MS);
N        EPDDrawString(TRUE,tempRadar1VersionString,350,450);
N    }
N    else
N    {
N        vTaskDelay(15/portTICK_RATE_MS);
N        EPDDrawString(TRUE,"Error",350,450);
N    }
N    if(pRadarInterface -> readQueryVersionString(1, tempRadar2VersionString))
N    {
N        terninalPrintf("%s\r\n",tempRadar2VersionString);
N        vTaskDelay(15/portTICK_RATE_MS);
N        EPDDrawString(FALSE,tempRadar2VersionString,350,500);
N    }
N    else
N    {
N        vTaskDelay(15/portTICK_RATE_MS);
N        EPDDrawString(TRUE,"Error",350,500);
N    }
N    */
N    pRadarInterface->setPowerStatusFunc(0,FALSE);
X    pRadarInterface->setPowerStatusFunc(0,(0));
N    pRadarInterface->setPowerStatusFunc(1,FALSE);
X    pRadarInterface->setPowerStatusFunc(1,(0));
N
N    
N    GuiManagerTimerSet(GUI_TIMER_DISABLE);
X    GuiManagerTimerSet(0x06);
N    //EPDDrawString(TRUE,"Press \'q\' to continue...",100,650);
N    vTaskDelay(15/portTICK_RATE_MS);
X    vTaskDelay(15/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    EPDDrawString(TRUE,"Press } to quit...",100,650);
X    EPDDrawString((1),"Press } to quit...",100,650);
N    terninalPrintf("\r\n\r\nPress 'q' to quit... \r\n");
N    
N    vTaskDelay(1500/portTICK_RATE_MS);
X    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    EPDDrawString(FALSE,"              ",275,50);
X    EPDDrawString((0),"              ",275,50);
N    EPDDrawString(FALSE,"              ",275,56);
X    EPDDrawString((0),"              ",275,56);
N    EPDDrawString(FALSE,"              ",275,100);
X    EPDDrawString((0),"              ",275,100);
N    EPDDrawString(TRUE,"              ",275,106);
X    EPDDrawString((1),"              ",275,106);
N      /*  while(1)
N        {
N
N            if(sysIsKbHit())
N            {
N
N                tempchar = getTerminalChar();
N                if(tempchar=='q')
N                    break;
N                if((tempchar=='n')&&(pageCounter == 0))
N                {
N                    pageCounter = 1;
N                    pagechangeFlag = TRUE;
N                }
N                if((tempchar=='p')&&(pageCounter == 1))
N                {
N                    pageCounter = 0;
N                    pagechangeFlag = TRUE; 
N                }
N            } 
N            if(guiResponseFlag)
N            {
N                tempchar = getGuiResponse();
N                if(tempchar=='q')
N                    break;
N                if((tempchar=='n')&&(pageCounter == 0))
N                {
N                    pageCounter = 1;
N                    pagechangeFlag = TRUE;
N                }
N                if((tempchar=='p')&&(pageCounter == 1))
N                {
N                    pageCounter = 0;
N                    pagechangeFlag = TRUE;
N                }
N            }
N            if(pagechangeFlag)
N            {
N                pagechangeFlag = FALSE;
N                if(pageCounter == 0)
N                {  
N                    EPDDrawMulti(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,50);
N                    EPDDrawString(FALSE,"LED:\n\n\nAP:\n\n\nReader:\n\n\nEPD:\n\n\n            Page1      >Next",100,50);
N                    EPDDrawString(FALSE,string,350,50);
N                    EPDDrawString(FALSE,preadFWVersion,350,500); 
N                    EPDDrawString(TRUE,preadLUTVersion,350,550);
N                }
N                else if(pageCounter == 1)
N                {
N                    EPDDrawMulti(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,50);
N                    EPDDrawString(FALSE,"SIM:\n\n\nMODEM:\n\n\nRADAR:\n\n\n\n\n\n<Previous   Page2      ",100,50);
N                    EPDDrawString(TRUE,tempchr,350,200);
N                    terninalPrintf("tempchrPrintAgain=%s\r\n",tempchr);
N                    
N                }
N            }
N            vTaskDelay(100/portTICK_RATE_MS);
N        } */
N        
N		//terninalPrintf("Is the version number correct?(y/n)\r\n");
N		//guiPrintMessage(string);
N                            //EPDDrawString(TRUE,string1,X_POS_MSG,Y_POS_MSG+50);
N                            //EPDDrawString(TRUE,string2,X_POS_MSG,Y_POS_MSG+100);
N		
N		
N                            //vTaskDelay(2000/portTICK_RATE_MS);
N                            //EPDDrawContainByIDPos(TRUE,EPD_PICT_KEY_CLEAN_BAR,X_POS_MSG-2,Y_POS_MSG-2); 
N		
N       while(1)
N       {
N            if(sysIsKbHit())
N            {
N
N                tempchar = getTerminalChar();
N                if(tempchar=='q')
N                    break;
N             } 
N            if(guiResponseFlag)
N            {
N                tempchar = getGuiResponse();
N                if(tempchar=='q')
N                    break;
N            }
N            vTaskDelay(100/portTICK_RATE_MS);
X            vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N       }
N        
N		//free(string);
N        //free(pch1);
N                            //free(string2);
N		
N
N                  
N          
N	/* if(userResponseLoop()=='n')
N      {
N				guiPrintMessage("");
N        EPDSetBacklight(FALSE);
N        return TRUE;
N      }
N      */
N		return TRUE;
X		return (1);
W "src\user\hwtester.c" 10795 14 variable "code11" was declared but never referenced
W "src\user\hwtester.c" 10795 22 variable "code12" was declared but never referenced
W "src\user\hwtester.c" 10795 30 variable "code13" was declared but never referenced
W "src\user\hwtester.c" 10795 38 variable "code14" was declared but never referenced
W "src\user\hwtester.c" 10795 46 variable "code21" was declared but never referenced
W "src\user\hwtester.c" 10795 54 variable "code22" was declared but never referenced
W "src\user\hwtester.c" 10795 62 variable "code23" was declared but never referenced
W "src\user\hwtester.c" 10795 70 variable "code24" was declared but never referenced
W "src\user\hwtester.c" 10796 9 variable "pageCounter" was declared but never referenced
W "src\user\hwtester.c" 10797 9 variable "pagechangeFlag" was declared but never referenced
W "src\user\hwtester.c" 10799 54 variable "tempreadLUTVersion" was declared but never referenced
W "src\user\hwtester.c" 11069 10 variable "changeFlag" was declared but never referenced
N}
N
N//====================================================/=/=======================================================//
N
N//////////////////////////////////////////User Interface-Cmd///////////////////////////////////////////
Nstatic BOOL exitTest(void* para1, void* para2)
N{   
N    return FALSE;
X    return (0);
N}
Nstatic BOOL totalTest(void* para1, void* para2)
N{
N    LEDColorBuffSet(0x00, 0x00);
N    LEDBoardLightSet();
N    char string1[80];
N    testedItem=0;
N    passItem=0;
N    failItem=0;
N    terninalPrintf("!!! Total Test Item !!!\r\n");
N    int result;
N    int tempItem;
N    time_t  testBegintime;
N    time_t  testEndtime;
N    
N    if(MBtestFlag )
N    {
N        //guiManagerShowScreen(GUI_SINGLE_TEST_ID, GUI_REDRAW_PARA_REFRESH,(int)MB_singleTestItem, ALL_TEST_MODE);
N        //vTaskDelay(300/portTICK_RATE_MS);
N        testBegintime = GetCurrentUTCTime();
N        result=actionTestItem(0, MB_singleTestItem, para1, para2, TRUE);
X        result=actionTestItem(0, MB_singleTestItem, para1, para2, (1));
N    }
N    else
N    {
N        //guiManagerShowScreen(GUI_SINGLE_TEST_ID, GUI_REDRAW_PARA_REFRESH,(int)singleTestItem, ALL_TEST_MODE);
N        guiManagerShowScreen(GUI_SINGLE_TEST_ID, GUI_REDRAW_PARA_REFRESH,(int)AllTestItem, ALL_TEST_MODE);       
X        guiManagerShowScreen(16, 0x03,(int)AllTestItem, 1);       
N        vTaskDelay(300/portTICK_RATE_MS);
X        vTaskDelay(300/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        //result=actionTestItem(0, singleTestItem, para1, para2, TRUE);
N        result=actionTestItem(0, AllTestItem, para1, para2, TRUE);
X        result=actionTestItem(0, AllTestItem, para1, para2, (1));
N    }
N    if(MBtestFlag )
N    {}
N    else
N    {
N        cleanRst();
N        cleanMsg();
N    }
N    if(MBtestFlag )                       
N        tempItem = MBallTestItem;//allTestItem;
N    else
N        tempItem = allTestItem - 1;
N    //if(passItem == allTestItem)
N    if(passItem == tempItem)
N    {
N        terninalPrintf("<ALL TEST>Result:[PASS]\r\n");
N        if(MBtestFlag )
N        {}
N        else
N            EPDDrawString(TRUE,"PASS            ",X_POS_RST,Y_POS_RST);
X            EPDDrawString((1),"PASS            ",550,154);
N        
N    }
N    else
N    {
N        terninalPrintf("<ALL TEST>Result:[FAIL]\r\n");
N        if(MBtestFlag )
N        {}
N        else
N        {
N            EPDDrawString(TRUE,"FAIL            ",X_POS_RST,Y_POS_RST);
X            EPDDrawString((1),"FAIL            ",550,154);
N            LEDColorBuffSet(0x00, 0xff);
N            LEDBoardLightSet();
N        }
N    }
N    
N    if(MBtestFlag )
N    {
N        sprintf(string1,"Total:%02d\\%02d\nPass :%02d\\%02d\nFail :%02d\\%02d\n\nPress } to Exit",testedItem,MBallTestItem,passItem,testedItem,failItem,testedItem);
N        terninalPrintf("Total Test Item:%d/%d\r\nPass Item:%d/%d\r\nFail Item:%d/%d\r\n",testedItem,MBallTestItem,passItem,testedItem,failItem,testedItem);
N    }
N    else
N    {
N        sprintf(string1,"Total:%02d\\%02d\nPass :%02d\\%02d\nFail :%02d\\%02d\n\nPress } to Exit",testedItem,allTestItem-1,passItem,testedItem,failItem,testedItem);
N        terninalPrintf("Total Test Item:%d/%d\r\nPass Item:%d/%d\r\nFail Item:%d/%d\r\n",testedItem,allTestItem-1,passItem,testedItem,failItem,testedItem);
N    }
N    if(MBtestFlag )
N    {
N        testEndtime = GetCurrentUTCTime();
N        terninalPrintf("Test takes time : %d seconds\r\n",testEndtime - testBegintime);
N        return TRUE;
X        return (1);
N    }
N    else
N    {
N        terninalPrintf("Press 'q' to Exit Test\n");
N        /* Show Result */
N        guiPrintMessage(string1);
N        while(userResponseLoop()!='q');
N        if(result!=ACTION_TESTER_ITEM_FALSE)
X        if(result!=0x02)
N        {
N            return TRUE;
X            return (1);
N        }
N        return FALSE;
X        return (0);
N    }
N}
N
Nstatic BOOL singleTest(void* para1, void* para2)
N{
N    int guiID = GUI_SINGLE_TEST_ID;
X    int guiID = 16;
N    if(MBtestFlag )
N        enterMunu(MENU_STRING_SINGLE, MB_singleTestItem, (void*)&guiID, NULL);
X        enterMunu("\r\n  ********** Single Test Menu **********\r\nPlease Select: \r\n", MB_singleTestItem, (void*)&guiID, 0);
N    else
N        enterMunu(MENU_STRING_SINGLE, singleTestItem, (void*)&guiID, NULL);
X        enterMunu("\r\n  ********** Single Test Menu **********\r\nPlease Select: \r\n", singleTestItem, (void*)&guiID, 0);
N    LEDColorBuffSet(0x00, 0x00);
N    LEDBoardLightSet();
N    setTesterFlag(FALSE);
X    setTesterFlag((0));
N    return TRUE;
X    return (1);
N}
N
Nstatic BOOL blankFunction(void* para1, void* para2)
N{
N    //int guiID=GUI_TOOL_TEST_ID;
N    //enterMunu(MENU_STRING_TOOL, toolsFunctionItem, (void*)&guiID, NULL);
N    
N    char chrtemp;
N    //guiManagerShowScreen(GUI_BLANK_ID, GUI_REDRAW_PARA_REFRESH,(int)singleTestItem, ALL_TEST_MODE);
N    guiManagerShowScreen(GUI_BLANK_ID, GUI_REDRAW_PARA_REFRESH,0, 0);
X    guiManagerShowScreen(27, 0x03,0, 0);
N    
N   //EPDDrawMulti(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N    
N    
N   //EPDDrawString(TRUE,"Hello World",100,100);
N    
N   /* while(1)
N    {
N        //sysInitializeUART();
N        //terninalPrintf("--> ");
N        chrtemp=userResponseLoop();
N        
N        char* stringtmp = malloc(2);
N        *stringtmp = chrtemp;
N        *(stringtmp+1) = '\0';
N        terninalPrintf("ishit=%s \n",stringtmp);
N        EPDDrawString(TRUE,stringtmp,100,150);
N        free(stringtmp); 
N        if(chrtemp=='q')
N        {
N          break;
N        }
N        vTaskDelay(1000/portTICK_RATE_MS);
N    }*/
N    terninalPrintf("confirm to quit?\n");
N    while(1)
N    {
N        if(userResponseLoop()=='q')
N        {
N            
N           return TRUE; 
X           return (1); 
N        }
N        else
N        {
N            terninalPrintf("try again!\n");
N        }
N    } 
W "src\user\hwtester.c" 11419 5 statement is unreachable
N    return TRUE;
X    return (1);
W "src\user\hwtester.c" 11379 10 variable "chrtemp" was declared but never referenced
N}
N
Nstatic BOOL KeyPadTool(void* para1, void* para2)
N{
N    //GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
N    terninalPrintf("Press SW4 to quit.\n");
N    guiManagerShowScreen(GUI_BLANK_ID, GUI_KEYPAD_TEST,0, 0);
X    guiManagerShowScreen(27, 0x0A,0, 0);
N    return TRUE;
X    return (1);
N}
Nstatic BOOL ModemHSpdTool(void* para1, void* para2)
N{
N    QModemLibInit(921600);
N    if(!QModemATCmdTest())
N    {
N        QModemLibInit(115200);
N        if(QModemSetHighSpeed())
N            terninalPrintf("QModemSetHighSpeed successful\r\n");
N        else
N            terninalPrintf("QModemSetHighSpeed ERROR\r\n");   
N        //QModemLibInit(921600);
N    }
N    else
N    {
N        terninalPrintf("QModem already HighSpeed. \r\n");
N    }
N
N    
N    /*
N    if(QModemSetHighSpeed())
N        terninalPrintf("QModemSetHighSpeed successful\r\n");
N    else
N    {
N        QModemLibInit(115200);
N        if(QModemSetHighSpeed())
N            terninalPrintf("QModemSetHighSpeed successful\r\n");
N        else
N            terninalPrintf("QModemSetHighSpeed ERROR\r\n");
N    }
N    */
N    return TRUE;
X    return (1);
N}
N
Nstatic BOOL RTCTool(void* para1, void* para2)
N{
N    char tempchar;
N    //guiManagerShowScreen(GUI_RTC_TOOL_ID, GUI_REDRAW_PARA_REFRESH, 0, 0);  
N    guiManagerShowScreen(GUI_RTC_TOOL_ID, GUI_REDRAW_PARA_REFRESH, 0 ,(int)SetGuiResponseVal); 
X    guiManagerShowScreen(31, 0x03, 0 ,(int)SetGuiResponseVal); 
N    //terninalPrintf("Recent time: ");
N    //OctopusReaderQueryTime();
N    
N    
N    //SetOctopusTime();
N    //terninalPrintf("\r\nModify time: ");
N    //OctopusReaderQueryTime();
N
N    terninalPrintf("Is RTC time correct?(y/n)\r\n");
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar == 'n')
N        {
N            if(!SetOctopusTime())
N                return TRUE;
X                return (1);
N            //terninalPrintf("\r\nModify time: ");
N            //OctopusReaderQueryTime();
N
N            terninalPrintf("Is reader time correct?(y/n)\r\n");
N        }
N        else if((tempchar == 'y') || (tempchar == 'q'))
N            break;
N        else
N            terninalPrintf("Error input\r\n");
N    }
N    
N    return TRUE;
X    return (1);
N
N}
N
Nstatic BOOL ModemTool(void* para1, void* para2)
N{
N    char tempChr;
N    char CmdString[50];
N    char FBCmdStr[100];
N    int retlen;
N    memset(CmdString,0x00,sizeof(CmdString));
N    /*
N    QModemLibInit(MODEM_BAUDRATE);
N    
N    int SIMStatus;
N    if(QModemATCmdTest())
N    {
N        QModemQuerySIMInitStatus(&SIMStatus);
N        terninalPrintf("SIMStatus = %d\r\n",SIMStatus);
N        if((SIMStatus & 0x01) || (SIMStatus & 0x02) || (SIMStatus & 0x04))
N        {
N            QModemDialupStart();
N            if(QModemDialupProcess() == TRUE)
N            {
N                terninalPrintf("\r\nMODEM Dialup SUCCESS\r\n");
N                //vTaskDelay(5000/portTICK_RATE_MS);
N                //if(QModemQueryNTP())
N                //    terninalPrintf("\r\nQuery NTP SUCCESS\r\n");
N                //else
N                //    terninalPrintf("\r\nQuery NTP ERROR\r\n");
N            }
N            else
N            {
N                terninalPrintf("\r\nMODEM Dialup ERROR\r\n");
N                
N            }
N            
N        }
N        
N    }
N    */
N    
N    //terninalPrintf("WEEKDAY = %d",inp32(REG_RTC_WEEKDAY));
N    terninalPrintf("send >> ");
N    while(1)
N    {
N        tempChr = superResponseLoop();
N        if(tempChr == 0x1B)
N            break;
N        if((tempChr >= 0x20) &&(tempChr <= 0x7E))
N            sprintf(CmdString,"%s%c",CmdString,tempChr);
N            terninalPrintf("%c",tempChr);
N        if(tempChr == 0x0D)
N        {
N            terninalPrintf("\r\n",CmdString);
N            sprintf(CmdString,"%s\r\n",CmdString);
N            QModemTerminal(CmdString,FBCmdStr,sizeof(FBCmdStr),&retlen,20);
N            terninalPrintf("retn >> %s",FBCmdStr);
N            //for(int i=0;i<retlen;i++)
N            //    FBCmdStr
N            
N            
N            memset(CmdString,0x00,sizeof(CmdString));
N            terninalPrintf("send >> ");
N        }
N    }
N    return TRUE;
X    return (1);
N}
N
Nstatic BOOL NTPTool(void* para1, void* para2)
N{
N    return QueryNTPfun();
N}
N
NBOOL QueryNTPfun(void)
N{
N    int SIMStatus;
N    int QueryNTPRtyTimes = 0;
N    int QuerySIMRtyTimes = 0;
N    int QueryMODEMRtyTimes = 0;
N    char waitStr[100]="Query NTP,please wait";
N    RTC_TIME_DATA_T id;
N    //QModemLibInit(MODEM_BAUDRATE);
N    //if(QModemATCmdTest())
N    //{
N        //QModemATCmdTest();
N        //QModemQuerySIMInitStatus(&SIMStatus);
N        //vTaskDelay(5000/portTICK_RATE_MS);
N    //terninalPrintf("Query NTP,please wait");
N    while(QuerySIMRtyTimes < 20)
N    {
N        if(QModemQuerySIMInitStatus(&SIMStatus))
N        {}
N        else
N            QueryMODEMRtyTimes++;
N        
N        if(QueryMODEMRtyTimes >= 8)
N        {
N            terninalPrintf("\r\nMODEM SETUP ERROR\r\n");
N            return FALSE;
X            return (0);
N        }
N        
N        if(SIMStatus == 7)
N            break;
N        QuerySIMRtyTimes++;
N        vTaskDelay(500/portTICK_RATE_MS);
X        vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        sprintf(waitStr,"%s.",waitStr);
N        terninalPrintf("%s\r",waitStr);
N        //terninalPrintf(".");
N        //terninalPrintf("SIMStatus = %d\r\n",SIMStatus);
N    }
N    if(QuerySIMRtyTimes >= 20)
N    {
N        terninalPrintf("\r\nSIM SETUP ERROR\r\n");
N        return FALSE;
X        return (0);
N    }
N    terninalPrintf("\r\n");
N        //if((SIMStatus & 0x01) || (SIMStatus & 0x02) || (SIMStatus & 0x04))
N        //{
N    while(QueryNTPRtyTimes < 3)
N    {
N        if(QModemQueryNTP(&id.u32Year,&id.u32cMonth,&id.u32cDay,&id.u32cHour,&id.u32cMinute,&id.u32cSecond))
N        {
N            terninalPrintf("Query NTP SUCCESS\r\n");
N            id.u32Year += 2000;
N            terninalPrintf("NTP:%d/%d/%d/ %d:%d:%d\r\n",id.u32Year, id.u32cMonth,id.u32cDay,id.u32cHour,id.u32cMinute,id.u32cSecond);
N            
N            if(SetOSTimeLite(id.u32Year, id.u32cMonth,id.u32cDay,id.u32cHour,id.u32cMinute,id.u32cSecond))
N            {
N                terninalPrintf("SET RTC SUCCESS\r\n");
N                return TRUE;
X                return (1);
N            }
N            else
N            {
N                terninalPrintf("SET RTC ERROR\r\n");
N                return FALSE;
X                return (0);
N            }
N        }
N        else
N        {
N            QueryNTPRtyTimes++;
N            //terninalPrintf("Query NTP ERROR\r\n");
N        }
N    }
N    if(QueryNTPRtyTimes >= 3)
N    {
N        terninalPrintf("Query NTP ERROR\r\n");
N        return FALSE;
X        return (0);
N    }
N
N        //}
N        //else
N        //{
N            //terninalPrintf("SIM SETUP ERROR\r\n");
N        //}
N    //}
N    
N
W "src\user\hwtester.c" 11652 1 missing return statement at end of non-void function "QueryNTPfun"
N}
N
Nstatic BOOL toolsFunction(void* para1, void* para2)
N{
N    int guiID=GUI_TOOL_TEST_ID;
X    int guiID=17;
N    enterMunu(MENU_STRING_TOOL, toolsFunctionItem, (void*)&guiID, NULL);
X    enterMunu("\r\n  ************* Tools Menu *************\r\nPlease Select: \r\n", toolsFunctionItem, (void*)&guiID, 0);
N    return TRUE;
X    return (1);
N}
N 
Nstatic BOOL enterMunu(char* title, HWTesterItem* item, void* para1, void* para2)
N{
N    UINT8 charTmp;
N    int reVal;
N    while(1)
N    {
N        LEDColorBuffSet(0x00, 0x00);
N        LEDBoardLightSet();
N        EPDSetBacklight(FALSE);
X        EPDSetBacklight((0));
N        //Print Menu
N        terninalPrintf("%s",title);
N        for(int i = 0; ; i++)
N        {
N            if(item[i].itemName == NULL)
X            if(item[i].itemName == 0)
N                break;
N            terninalPrintf("    %c) [%s]\r\n", item[i].charItem, item[i].itemName);
N        }
N        if(para1!=NULL)
X        if(para1!=0)
N        {
N            if(MBtestFlag )
N            {
N                //guiManagerShowScreen(*(int*)para1, GUI_REDRAW_PARA_REFRESH ,(int)item , 0 );
N            }
N            else
N                guiManagerShowScreen(*(int*)para1, GUI_REDRAW_PARA_REFRESH ,(int)item , 0 );
X                guiManagerShowScreen(*(int*)para1, 0x03 ,(int)item , 0 );
N            
N        }
N        terninalPrintf("--> ");
N        setTesterFlag(FALSE);
X        setTesterFlag((0));
N        //Wait user Key-in
N        charTmp = userResponseLoop();
N        terninalPrintf("%c\r\n", charTmp);
N        reVal = actionTestItem(charTmp, item, para1, para2, FALSE);
X        reVal = actionTestItem(charTmp, item, para1, para2, (0));
N        //terninalPrintf("reVal = 0x%02x\r\n", reVal);
N        if(reVal == ACTION_TESTER_ITEM_FALSE||reVal == TEST_FALSE)
X        if(reVal == 0x02||reVal == 0x10)
N        {
N            return FALSE;
X            return (0);
N        }
N        if((*(int*)para1 == GUI_SINGLE_TEST_ID) && (para2 == NULL))
X        if((*(int*)para1 == 16) && (para2 == 0))
N            GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
X            GuiManagerCleanMessage(0x07);
N        
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    }
N}
N
Nstatic int actionTestItem(char targetChar, HWTesterItem* item, void* para1, void* para2, BOOL ignoreChar)//ignoreChar TRUE->AllTest FALSE->Menu/Single/Tool
N{
N    int reVal = ACTION_TESTER_ITEM_NONE;
X    int reVal = 0x00;
N    uint16_t testResult;
N    for(int i=0;i<allTestItem+(!ignoreChar);i++)// quit();
N    {
N        //terninalPrintf("i = %d\r\n",i);
N        //terninalPrintf("allTestItem = %d\r\n",allTestItem);
N       // terninalPrintf("allTestItem+(!ignoreChar) = %d\r\n",allTestItem+(!ignoreChar));
N       // terninalPrintf("allTestItem = %d\r\n",allTestItem);
N       // terninalPrintf("(!ignoreChar) = %d\r\n",(!ignoreChar));
N       // terninalPrintf("targetChar = %c\r\n",targetChar);
N        if(((item[i].charItem == 'q') && ignoreChar) || (item[i].charItem == 0))
N            break;
N        if(((item[i].charItem == targetChar)||ignoreChar)&&(item[i].testerFunc != NULL))
X        if(((item[i].charItem == targetChar)||ignoreChar)&&(item[i].testerFunc != 0))
N        {
N            int y_offset=0;
N            if(item[i].charItem != 'q')
N                testedItem++;
N            //Errow point to now test item
N            //if((ignoreChar) && (i <allTestItem+(!ignoreChar)-1 ))
N            if((ignoreChar) && (i <allTestItem+(!ignoreChar) ))
N            {
N                if(i<5)
N                {
N                    y_offset = 110+(i*44);
N                }
N                else
N                {
N                    y_offset = 110+(i*44);//+ 28;
N                }
N                if(MBtestFlag )
N                {}
N                else
N                    EPDDrawContainByIDPos(TRUE,EPD_PICT_KEY_RIGHT,90,y_offset);
X                    EPDDrawContainByIDPos((1),EPD_PICT_KEY_RIGHT,90,y_offset);
N            }
N            LEDColorBuffSet(0x00, 0x00);
N            LEDBoardLightSet();
N            if(item[i].itemName != NULL)
X            if(item[i].itemName != 0)
N            {
N            terninalPrintf("\r\n =====  [%c)%s Start] =====\r\n", item[i].charItem, item[i].itemName);
N            }
N            else
N            {
N                terninalPrintf("\r\n =====  [%c) BLANK Start] =====\r\n", item[i].charItem);
N            }
N            if(!ignoreChar)
N            {
N                setTesterFlag(TRUE);
X                setTesterFlag((1));
N            }
N            // entry tester function point //
N            if(guiManagerCompareCurrentScreenId(GUI_SINGLE_TEST_ID))//oOnC@MlT
X            if(guiManagerCompareCurrentScreenId(16))
N            {
N                if(MBtestFlag )
N                {}
N                else
N                {
N                    cleanMsg();
N                    cleanRst();
N                }
N            }
N            if((MBtestFlag) && (item == MB_singleTestItem))
N            {
N                //terninalPrintf("i = %d \r\n", i);
N                InitMTPvalue(MTPReportindex[i],(uint8_t*)MTPString);
N                SetMTPCRC(39+i,(uint8_t*)MTPString);
N                MTPCmdprint(39+i,(uint8_t*)MTPString);
N            }
N            testResult = item[i].testerFunc(para1, (void*)&ignoreChar);
N            if(!ignoreChar)
N            {
N                setTesterFlag(FALSE);
X                setTesterFlag((0));
N            }
N            //terninalPrintf("testResult = 0x%02x\r\n", testResult);
N            switch(testResult)
N            {
N            case TRUE:
X            case (1):
N                reVal = ACTION_TESTER_ITEM_TRUE;
X                reVal = 0x01;
N                break;
N            case FALSE://exit
X            case (0):
N                if(MBtestFlag)
N                {
N                    if(item[i].charItem != 'q')
N                    {
N                        MTPString[MTPReportindex[i]][MTPString[MTPReportindex[i]][2]+2] = 0x80;
N                        SetMTPCRC(MTPReportindex[i],(uint8_t*)MTPString);
N                        MTPCmdprint(MTPReportindex[i],(uint8_t*)MTPString);
N                    }
N                    SetMTPCRC(38,(uint8_t*)MTPString);
N                    MTPCmdprint(38,(uint8_t*)MTPString);
N                }                    
N                reVal = ACTION_TESTER_ITEM_FALSE;
X                reVal = 0x02;
N                return reVal;
N            case TEST_SUCCESSFUL_LIGHT_OFF:
X            case 0x12:
N                if(ignoreChar)
N                {
N                    if(MBtestFlag )
N                    {}
N                    else
N                        EPDDrawContainByIDPos(FALSE,EPD_PICT_KEY_CONFIRM,90,y_offset);
X                        EPDDrawContainByIDPos((0),EPD_PICT_KEY_CONFIRM,90,y_offset);
N                        //EPDDrawContainByIDPos(TRUE,EPD_PICT_KEY_CONFIRM,90,y_offset);
N                    passItem++;
N                }
N                reVal = ACTION_TESTER_ITEM_TRUE;
X                reVal = 0x01;
N                if(MBtestFlag )
N                {
N                    terninalPrintf("Test [successful] !!\r\n");
N                    MTPString[MTPReportindex[i]][MTPString[MTPReportindex[i]][2]+2] = 0x81;
N                    SetMTPCRC(MTPReportindex[i],(uint8_t*)MTPString);
N                    MTPCmdprint(MTPReportindex[i],(uint8_t*)MTPString);    
N                    //if(i == (allTestItem-1))
N                    if(i == (MBallTestItem-1))
N                    {
N                        SetMTPCRC(38,(uint8_t*)MTPString);
N                        MTPCmdprint(38,(uint8_t*)MTPString);
N                    }
N                    BuzzerPlay(300, 0, 1, TRUE);
X                    BuzzerPlay(300, 0, 1, (1));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N                else
N                    testSuccessful(i,FALSE);
X                    testSuccessful(i,(0));
N                break;
N            case TEST_SUCCESSFUL_LIGHT_ON:
X            case 0x13:
N                if(ignoreChar)
N                {
N                    if(MBtestFlag )
N                    {}
N                    else
N                        EPDDrawContainByIDPos(FALSE,EPD_PICT_KEY_CONFIRM,90,y_offset);
X                        EPDDrawContainByIDPos((0),EPD_PICT_KEY_CONFIRM,90,y_offset);
N                        //EPDDrawContainByIDPos(TRUE,EPD_PICT_KEY_CONFIRM,90,y_offset);
N                    passItem++;
N                }
N                reVal = ACTION_TESTER_ITEM_TRUE;
X                reVal = 0x01;
N                if(MBtestFlag )
N                {
N                    terninalPrintf("Test [successful] !!\r\n");
N                    MTPString[MTPReportindex[i]][MTPString[MTPReportindex[i]][2]+2] = 0x81;
N                    SetMTPCRC(MTPReportindex[i],(uint8_t*)MTPString);
N                    MTPCmdprint(MTPReportindex[i],(uint8_t*)MTPString);  
N                    //if(i == (allTestItem-1))
N                    if(i == (MBallTestItem-1)) 
N                    {
N                        SetMTPCRC(38,(uint8_t*)MTPString);
N                        MTPCmdprint(38,(uint8_t*)MTPString);
N                    }
N                    BuzzerPlay(300, 0, 1, TRUE);
X                    BuzzerPlay(300, 0, 1, (1));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N                else
N                    testSuccessful(i,TRUE);
X                    testSuccessful(i,(1));
N                break;
N            case TEST_FALSE:	
X            case 0x10:	
N                if(MBtestFlag )
N                {
N                    terninalPrintf("Test [Error] !!\r\n");
N                    BuzzerPlay(80, 80, 3, TRUE);
X                    BuzzerPlay(80, 80, 3, (1));
N                    testErroCode = 0x0000;          //cleaning
N                }
N                else                
N                    testFailure(i);
N                if(ignoreChar)
N                {
N                    setTesterFlag(FALSE);
X                    setTesterFlag((0));
N                    if(MBtestFlag )
N                    {}
N                    else
N                        EPDDrawContainByIDPos(FALSE,EPD_PICT_LOWER_A+23,90,y_offset-9);
X                        EPDDrawContainByIDPos((0),EPD_PICT_LOWER_A+23,90,y_offset-9);
N                        //EPDDrawContainByIDPos(TRUE,EPD_PICT_LOWER_A+23,90,y_offset-9);
N                    failItem++;
N                    
N                    if(MBtestFlag )
N                    {
N                    }
N                    else
N                    {
N                        setTesterFlag(TRUE);
X                        setTesterFlag((1));
N                        /*
N                        //guiPrintMessageNoClean("\n\n\n\n\n+:Retry \n=:Next\n}:Exit\n");
N                        EPDDrawString(TRUE,"+:Retry \n=:Next\n}:Exit\n",X_POS_MSG+250,Y_POS_MSG-250);
N                        terninalPrintf("\r\n'y' to retry,\r\n'n' to continue,\r\n'q' to Exit\n");
N                        while(1)
N                        {
N                            char tmp=userResponseLoop();
N                            if(tmp=='y')
N                            {
N                                i--;
N                                failItem--;
N                                testedItem--;
N                                setTesterFlag(TRUE);
N                                break;
N                            }
N                            else if(tmp=='n')
N                            {
N                                setTesterFlag(TRUE);
N                                break;
N                            }
N                            else if(tmp=='q')
N                            {
N                                cleanRst();
N                                return reVal;
N                            }
N                            else
N                            {
N                                terninalPrintf("Wrong input!Please enter again!\r\n");
N                            }
N                        }
N                        */
N                    }
N                }
N                else
N                {
N                    reVal = ACTION_TESTER_ITEM_TRUE;
X                    reVal = 0x01;
N                }
N                break;
N            case TEST_TRUE:
X            case 0x11:
N                break;
N            }
N            terninalPrintf(" =====  [ End  ] =====\r\n\r\n");
N            if(ignoreChar==FALSE)
X            if(ignoreChar==(0))
N            {
N                break;
N            }
N            else
N            {
N                vTaskDelay(500/portTICK_RATE_MS);
X                vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N            }
N            //select item change to white
N            //cleanMsg();
N        }
N    }
N    return reVal;
N}
N 
Nstatic BOOL testSuccessful(int i,BOOL lightOff)
N{
N    if(EPDtestFlag)
N        EPDtestFlag = FALSE;
X        EPDtestFlag = (0);
N    else
N    {
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintResult("PASS");
N    }
N    //guiPrintMessage(" ");
N    terninalPrintf("Test [successful] !!\r\n");
N    /*
N    if(lightOff == TRUE)
N    {
N        LedSetColor(bayColorOff, LIGHT_COLOR_OFF, TRUE);	
N        vTaskDelay(500/portTICK_RATE_MS);
N    }
N    */
N    if(ModemResultLEDFlag)
N    {
N        ModemResultLEDFlag = FALSE;
X        ModemResultLEDFlag = (0);
N        GPIO_SetBit(GPIOG, BIT7);
X        GPIO_SetBit(GPIOG, (0x00000080));
N        
N            //LedSetStatusLightFlush(50,10);  // solve LED board bug
N        //LedSetColor(bayColorOff, 0x04, TRUE);
N        LedSetBayLightFlush(0xff,8);
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        LedSetColor(modemColorAllRed, 0x00, TRUE);
X        LedSetColor(modemColorAllRed, 0x00, (1));
N        
N        BuzzerPlay(300, 0, 1, TRUE);
X        BuzzerPlay(300, 0, 1, (1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        LEDColorBuffSet(0x00, 0x00);
N        LEDBoardLightSet();
N        GPIO_ClrBit(GPIOG, BIT7);
X        GPIO_ClrBit(GPIOG, (0x00000080));
N
N    }
N    else
N    {
N        LEDColorBuffSet(0xff, 0x00);
N        LEDBoardLightSet();
N        BuzzerPlay(300, 0, 1, TRUE);
X        BuzzerPlay(300, 0, 1, (1));
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        LEDColorBuffSet(0x00, 0x00);
N        LEDBoardLightSet();
N    }
N    return TRUE;
X    return (1);
N}
N
Nstatic BOOL testFailure(int i)
N{	
N    if(EPDtestFlag)
N        EPDtestFlag = FALSE;
X        EPDtestFlag = (0);
N    else
N    {
N        if(MBtestFlag )
N        {}
N        else
N            guiPrintResult("FAIL");
N    }
N    terninalPrintf("Test [Error] !!\r\n");
N    //guiPrintMessageNoClean("");
N    sysprintf("\r\n/*********  Erro Code : 0x%04x   *********/\r\n", testErroCode);
N    
N    if(ModemResultLEDFlag)
N    {
N        ModemResultLEDFlag = FALSE;  
X        ModemResultLEDFlag = (0);  
N        GPIO_SetBit(GPIOG, BIT7);        
X        GPIO_SetBit(GPIOG, (0x00000080));        
N           // LedSetStatusLightFlush(50,10);  // solve LED board bug   
N        //LedSetColor(bayColorOff, 0x04, TRUE);        
N        LedSetBayLightFlush(0xff,8);
N        vTaskDelay(100/portTICK_RATE_MS);
X        vTaskDelay(100/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N        LedSetColor(modemColorAllGreen, 0x00, TRUE);
X        LedSetColor(modemColorAllGreen, 0x00, (1));
N        
N        BuzzerPlay(80, 80, 3, TRUE);
X        BuzzerPlay(80, 80, 3, (1));
N        testErroCode = 0x0000;          //cleaning
N        
N        GPIO_ClrBit(GPIOG, BIT7);
X        GPIO_ClrBit(GPIOG, (0x00000080));
N    }
N    else
N    {
N        LEDColorBuffSet(0x00,0xff );
N        LEDBoardLightSet();
N
N        BuzzerPlay(80, 80, 3, TRUE);
X        BuzzerPlay(80, 80, 3, (1));
N
N        testErroCode = 0x0000;          //cleaning
N    }
N    return FALSE;
X    return (0);
N}
N
N//static BOOL primaryTest()
N//{
N//    BuzzerPlay(100, 800, 5, TRUE);
N//    vTaskDelay(4500/portTICK_RATE_MS);
N//    while(1);
N//}
Nstatic void hwInit(void){
N    setPrintfFlag(TRUE);
X    setPrintfFlag((1));
N    
N    
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<16)) | (0x0<<16));
X    *((volatile unsigned int *)((0xB0000000+0x0B8))) = ((*((volatile unsigned int *)((0xB0000000+0x0B8)))) & ~(0xF<<16)) | (0x0<<16);
N    GPIO_OpenBit(GPIOJ, BIT4, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOJ, (0x00000010), DIR_INPUT, PULL_UP);
N      
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<12)) | (0x0<<12));
X    *((volatile unsigned int *)((0xB0000000+0x0B8))) = ((*((volatile unsigned int *)((0xB0000000+0x0B8)))) & ~(0xF<<12)) | (0x0<<12);
N    GPIO_OpenBit(GPIOJ, BIT3, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOJ, (0x00000008), DIR_INPUT, PULL_UP);
N    
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<8)) | (0x0<<8));
X    *((volatile unsigned int *)((0xB0000000+0x0B8))) = ((*((volatile unsigned int *)((0xB0000000+0x0B8)))) & ~(0xF<<8)) | (0x0<<8);
N    GPIO_OpenBit(GPIOJ, BIT2, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOJ, (0x00000004), DIR_INPUT, PULL_UP);
N    
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<4)) | (0x0<<4));
X    *((volatile unsigned int *)((0xB0000000+0x0B8))) = ((*((volatile unsigned int *)((0xB0000000+0x0B8)))) & ~(0xF<<4)) | (0x0<<4);
N    GPIO_OpenBit(GPIOJ, BIT1, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOJ, (0x00000002), DIR_INPUT, PULL_UP);
N    
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<0)) | (0x0<<0));
X    *((volatile unsigned int *)((0xB0000000+0x0B8))) = ((*((volatile unsigned int *)((0xB0000000+0x0B8)))) & ~(0xF<<0)) | (0x0<<0);
N    GPIO_OpenBit(GPIOJ, BIT0, DIR_INPUT, PULL_UP);
X    GPIO_OpenBit(GPIOJ, (0x00000001), DIR_INPUT, PULL_UP);
N    
N    
N    if((GPIO_ReadBit(GPIOJ, BIT0)) && (!GPIO_ReadBit(GPIOJ, BIT1)) )
X    if((GPIO_ReadBit(GPIOJ, (0x00000001))) && (!GPIO_ReadBit(GPIOJ, (0x00000002))) )
N        MBtestFlag = TRUE;
X        MBtestFlag = (1);
N    else if((GPIO_ReadBit(GPIOJ, BIT0)) && (GPIO_ReadBit(GPIOJ, BIT1)) )
X    else if((GPIO_ReadBit(GPIOJ, (0x00000001))) && (GPIO_ReadBit(GPIOJ, (0x00000002))) )
N        AssemblyTestFlag = TRUE;
X        AssemblyTestFlag = (1);
N    
N    if(!GPIO_ReadBit(GPIOJ, BIT4))
X    if(!GPIO_ReadBit(GPIOJ, (0x00000010)))
N        memcpy(ReaderitemName,"Octopus Reader",sizeof("Octopus Reader"));
N
N    
N    
N    for(int i = 0; ; i++)
N    {
N        if(mInitFunctionList[i].func == NULL)
X        if(mInitFunctionList[i].func == 0)
N        {
N            break;
N        }
N        if(mInitFunctionList[i].func(TRUE))
X        if(mInitFunctionList[i].func((1)))
N        {
N            mInitFunctionList[i].result =TRUE;
X            mInitFunctionList[i].result =(1);
N            terninalPrintf(" * [%02d]: Initial %s OK...    *\r\n", i, mInitFunctionList[i].drvName);
N        }
N        else
N        {
N            terninalPrintf(" * [%02d]: Initial %s ERROR... *\r\n", i, mInitFunctionList[i].drvName);
N        }
N    }
N    //if(mInitFunctionList[0].result==TRUE)
N    //{
N        if(GuiManagerInit()){
N            isEPDInit = TRUE;
X            isEPDInit = (1);
N            terninalPrintf(" * Initial GuiManager  OK...    *\r\n");
N        }
N        else
N        {
N            terninalPrintf(" * Initial GuiManager  ERROR... *\r\n");
N        }
N    //}
N        
N    if(MBtestFlag)
N    {
N        //MBtestFlag = TRUE;
N        for(int i=0;;i++)
N        {
N            if(MB_singleTestItem[i].itemName == NULL)
X            if(MB_singleTestItem[i].itemName == 0)
N            {
N                break;
N            }
N            allTestItem++;
N            MBallTestItem++;
N        }
N        allTestItem-=1;
N        MBallTestItem-=1;
N    }
N    else
N    {
N        for(int i=0;;i++)
N        {
N            if(singleTestItem[i].itemName == NULL)
X            if(singleTestItem[i].itemName == 0)
N            {
N                break;
N            }
N            allTestItem++;
N        }
N        allTestItem-=1;
N    }
N    
N    int toolsallTestItem = 0;
N    for(int j=0;;j++)
N    {
N        if(toolsFunctionItem[j].itemName == NULL)
X        if(toolsFunctionItem[j].itemName == 0)
N        {
N            break;
N        }
N        toolsallTestItem++;
N    }
N    toolsallTestItem-=1;
N    
N    if(toolsallTestItem > allTestItem)  
N        allTestItem = toolsallTestItem;
N    
N    KeyDrvInit();
N    BatteryDrvInit(FALSE);
X    BatteryDrvInit((0));
N    
N    
N
N    
N    /*
N    // open 12V power
N    
N    outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOG, BIT6, DIR_OUTPUT, PULL_UP);
N    GPIO_SetBit(GPIOG, BIT6);
N    */
N    
N    /*
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<24)) | (0x0<<24));
N    GPIO_OpenBit(GPIOJ, BIT4, DIR_INPUT, PULL_UP);
N    
N    
N    outpw(REG_SYS_GPJ_MFPL,(inpw(REG_SYS_GPJ_MFPL) & ~(0xF<<12)) | (0x0<<12));
N    GPIO_OpenBit(GPIOJ, BIT3, DIR_INPUT, PULL_UP);
N    */
N    /*
N    //Set ModemRTS(PH10) output
N    outpw(REG_SYS_GPH_MFPH,(inpw(REG_SYS_GPH_MFPH) & ~(0xF<< 8)) | (0<< 8));
N    GPIO_OpenBit(GPIOH, BIT10, DIR_OUTPUT, PULL_UP);
N    GPIO_SetBit(GPIOH, BIT10);
N    */
N    
N    // battery control
N    if(MBtestFlag)
N    {
N        BatterySetSwitch1(FALSE);
X        BatterySetSwitch1((0));
N        BatterySetSwitch2(FALSE);
X        BatterySetSwitch2((0));
N        
N        //BatterySetSwitch1(TRUE);
N        //BatterySetSwitch2(TRUE);
N        
N        outpw(REG_SYS_GPE_MFPH,(inpw(REG_SYS_GPE_MFPH) & ~(0xF<<24)));
X        *((volatile unsigned int *)((0xB0000000+0x094))) = ((*((volatile unsigned int *)((0xB0000000+0x094)))) & ~(0xF<<24));
N        GPIO_OpenBit(GPIOE,BIT14, DIR_OUTPUT, NO_PULL_UP); 
X        GPIO_OpenBit(GPIOE,(0x00004000), DIR_OUTPUT, NO_PULL_UP); 
N        
N        GPIO_ClrBit(GPIOE,BIT14);
X        GPIO_ClrBit(GPIOE,(0x00004000));
N    }
N 
N    
N    #if(SUPPORT_HK_10_HW)
X    #if(1)
N    //Sensor board DC5V GPB6
N    outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<24)) | (0x0<<24));
X    *((volatile unsigned int *)((0xB0000000+0x078))) = ((*((volatile unsigned int *)((0xB0000000+0x078)))) & ~(0xF<<24)) | (0x0<<24);
N    GPIO_OpenBit(GPIOB, BIT6, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOB, (0x00000040), DIR_OUTPUT, NO_PULL_UP);
N    //GPIO_ClrBit(GPIOB, BIT6);
N    GPIO_SetBit(GPIOB, BIT6);   
X    GPIO_SetBit(GPIOB, (0x00000040));   
N    
W "src\user\hwtester.c" 12189 5 integer operation result is out of range
N    outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0x0<<28));
X    *((volatile unsigned int *)((0xB0000000+0x0B4))) = ((*((volatile unsigned int *)((0xB0000000+0x0B4)))) & ~(0xF<<28)) | (0x0<<28);
N    GPIO_OpenBit(GPIOI, BIT15, DIR_OUTPUT, NO_PULL_UP);
X    GPIO_OpenBit(GPIOI, (0x00008000), DIR_OUTPUT, NO_PULL_UP);
N    //GPIO_ClrBit(GPIOI, BIT15);
N    
N    
N    #endif
N}
N/*-----------------------------------------*/
N/* Exported Functions                      */
N/*-----------------------------------------*/
NBOOL HWTesterInit(void)
N{   
N    hwInit();
N    setPrintfFlag(TRUE);
X    setPrintfFlag((1));
N    vTaskDelay(1500/portTICK_RATE_MS);
X    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    BuzzerPlay(100, 800, 1, TRUE);
X    BuzzerPlay(100, 800, 1, (1));
N    //LedSendHeartbeat();
N    //LedSetColor(bayColorAllGreen, LIGHT_COLOR_OFF, TRUE);
N    NT066EResetChip();
N    
N   //BuzzerPlay(500, 500, 1, TRUE);
N   //BuzzerPlay(100, 100, 1, TRUE);
N    //BuzzerPlay(100, 500, 5, TRUE);
N   // BuzzerPlay(500, 200, 1, TRUE);
N   // vTaskDelay(10000/portTICK_RATE_MS);
N    
N    //IT8951SetVCOM(100);
N    
N    
N    //IT8951WriteReg(0x0004, 0x0001);
N    
N    //terninalPrintf("IT8951GetVCOM = %d \r\n",IT8951GetVCOM());
N    
N
N    //QModemSetPower(TRUE);
N    //QueryNTPfun();
N
N    
N    int timeOut = 0;
N    while(1)
N    {
N        int guiID = GUI_HW_TEST_ID;
X        int guiID = 14;
N        
N        if(MBtestFlag )
N            enterMunu(MENU_STRING_MAIN, MB_mainTestItem, (void*)&guiID, NULL);
X            enterMunu("\r\n  ************** Main Menu *************\r\nPlease Select Test Type:\r\n", MB_mainTestItem, (void*)&guiID, 0);
N        else
N            enterMunu(MENU_STRING_MAIN, mainTestItem, (void*)&guiID, NULL);
X            enterMunu("\r\n  ************** Main Menu *************\r\nPlease Select Test Type:\r\n", mainTestItem, (void*)&guiID, 0);
N        vTaskDelay(1000/portTICK_RATE_MS);
X        vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    }
W "src\user\hwtester.c" 12227 9 variable "timeOut" was declared but never referenced
N}
N
NBOOL MTPTesterInit(void)
N{   
N    hwInit();
N    setPrintfFlag(TRUE);
X    setPrintfFlag((1));
N    vTaskDelay(1500/portTICK_RATE_MS);
X    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N    BuzzerPlay(100, 800, 1, TRUE);
X    BuzzerPlay(100, 800, 1, (1));
N    char tempchar;
N    guiManagerShowScreen(GUI_BLANK_ID, GUI_MTP_INI,0, 0);
X    guiManagerShowScreen(27, 0x0B,0, 0);
N    //vTaskDelay(5000/portTICK_RATE_MS);
N    //GuiManagerCleanMessage(GUI_MTP_START);
N    while(1)
N    {
N        tempchar = userResponseLoop();
N        if(tempchar =='b')
N        {
N            GuiManagerCleanMessage(GUI_MTP_START);
X            GuiManagerCleanMessage(0x0D);
N            
N            if (MTP_ProcedureInit() == FALSE)
X            if (MTP_ProcedureInit() == (0))
N            {
N                terninalPrintf("blankFunction ==> MTP_ProcedureInit Failed !\r\n");
N                continue;
N            }
N            
N            //while(userResponseLoop() != 'b');
N            
N            while (1)
N            {
N                
N                if (MTP_IsExitProcedure() == TRUE) {
X                if (MTP_IsExitProcedure() == (1)) {
N                    break;
N                }
N                
N            }
N            
N            MTP_ProcedureDeInit();
N            terninalPrintf("Exit MTP Procedure!\r\n");
N            GuiManagerCleanMessage(GUI_MTP_SCREEN);
X            GuiManagerCleanMessage(0x0C);
N            continue;
N
N        }                          
N    }
N    
N    
N}
N
N/*-----------------------------------------*/
N/* KeyPad Listener                        */
N/*-----------------------------------------*/
NBOOL CallBackReturnValue(uint8_t keyId, uint8_t downUp)
N{
N    //terninalPrintf("targetkeyStage = %d\n",targetkeyStage);
N    //terninalPrintf("keyId = %d\n",keyId);
N    if(targetkeyStage == keyId)
N    {
N        callBackKeyId = keyId;
N        callBackDownUp = downUp;
N        if(GUI_KEY_DOWN_INDEX == downUp)
X        if(0x1 == downUp)
N        {
N            BuzzerPlay(200, 500, 1, TRUE);
X            BuzzerPlay(200, 500, 1, (1));
N        }
N    }
N    return 0;
N}
N/*-----------------------------------------*/
N/* getter and setter                       */
N/*-----------------------------------------*/
Nstatic char getGuiResponse(void){
N    guiResponseFlag=FALSE;
X    guiResponseFlag=(0);
N    return guiResponseChar;
N}
N
Nstatic void setTesterFlag(BOOL testerflag){
N    testerFlag=testerflag;
N}
N
Nvoid SetGuiResponseVal(char guiresponsechar){
N    guiResponseFlag = TRUE;
X    guiResponseFlag = (1);
N    guiResponseChar = guiresponsechar;
N}
N
NBOOL GetTesterFlag(void){
N    return testerFlag;
N}
N
Nint GetDeviceIDString(void){
N    return getDeviceID(0, 0);
N}
N
NBOOL SetDeviceIDString(void* para1,void* para2){
N    int deviceID=0;
N    char* deviceIDString=(char*)para1;
N    for(int i=0;i<4;i++)
N    {
N        deviceID += (deviceIDString[i]-'0');
N        deviceID *= 10;
N    }
N    deviceID += deviceIDString[4]-'0';
N    epmIDSet = deviceID;
N    return TRUE;
X    return (1);
N}
N
N
Nvoid hwtestEDPflashBurn(void)
N{
N    char tempchar;    
N    int lastvcomValue;
N    int modifyvcomValue;
N    int newvcomValue; 
N    int recoveryvcomValue;
N    char lastVCOMString[9];
N    char modifyVCOMString[10];
N    char recoveryVCOMString[12];
N    
N    
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(EPDflashToolListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", EPDflashToolListItem[i].charItem, EPDflashToolListItem[i].itemName);
N        
N    }   
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");
N        tempchar = userResponseLoop();
N        terninalPrintf("%c",tempchar);
N        switch(tempchar)
N        {
N            case 's':
N                setW25Q64BVspecialburn();
N                W25Q64BVburn();
N                clrW25Q64BVspecialburn();
N                break;
N            case 'd':
N                W25Q64BVdeviceID();
N                break;
N            case 'p':
N                W25Q64BVFetch();
N                break;
N            
N            case 'v':
N                terninalPrintf("\r\nVCOM value = %d \r\n",IT8951GetVCOM());
N                break;
N
N            case 'u':
N
N                if(W25Q64BVQuery())
N                {
N                    //EPDDrawString(TRUE,"OK   ",300+400,100+(44*(2)));
N                }
N                else
N                {
N                    //EPDDrawString(TRUE,"FAIL ",300+400,100+(44*(2)));
N                }
N                break;
N            case 'e':
N                W25Q64BVerase();
N                
N                break;
N            case '0':
N
N                terninalPrintf("\r\n =====  [0)FACTORY TEST Start] =====\r\n");
N                vTaskDelay(500/portTICK_RATE_MS);
X                vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                //lastvcomValue = IT8951GetVCOM();
N
N                //terninalPrintf("VCOM value before burn = %d \r\n",lastvcomValue);
N                //sprintf(lastVCOMString,"VCOM:%d   ",lastvcomValue );
N            
N                if(SetEPDVCOMEx())
N                {
N                    //modifyvcomValue = IT8951GetVCOM();
N                    //terninalPrintf("New VCOM value = %d \r\n",*setVCOMpoint);
N                    terninalPrintf("New VCOM value = %d \r\n",setVCOMEx);
N                    vTaskDelay(1500/portTICK_RATE_MS);
X                    vTaskDelay(1500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N
N                if(W25Q64BVburn())
N                {
N                    newvcomValue = IT8951GetVCOM();
N                    terninalPrintf("VCOM value after burn = %d \r\n",newvcomValue);
N                    IT8951SetVCOM(*setVCOMpoint);
N                    recoveryvcomValue = IT8951GetVCOM();
N                    terninalPrintf("Recovery VCOM value = %d \r\n",recoveryvcomValue);
N
N                    toggleEPDswitch(TRUE);
X                    toggleEPDswitch((1));
N                    //vTaskDelay(5000/portTICK_RATE_MS);
N                    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE);
X                    EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, (1));
N                    terninalPrintf("Enter EPD all black,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);
X                    EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, (1));
N                    terninalPrintf("Enter EPD all white,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDSetSleepFunction(TRUE);
X                    EPDSetSleepFunction((1));
N                    terninalPrintf("Enter EPD sleep mode,press \"space\" to continue.\r\n");
N                    while(userResponseLoop() != 0x20);
N                    EPDSetSleepFunction(FALSE);
X                    EPDSetSleepFunction((0));
N                    
N                    //fExit = TRUE;
N     
N                    
N                }
N                else
N                {
N                    terninalPrintf("BURN FAIL\r\n");
N                }
N
N                break;
N                /*
N            case '1':
N
N
N                terninalPrintf("\r\n =====  [1)SD Burn Start] =====\r\n");
N                lastvcomValue = IT8951GetVCOM();
N
N                terninalPrintf("VCOM value before burn = %d \r\n",lastvcomValue);
N
N            
N                if(W25Q64BVburn())
N                {
N                    newvcomValue = IT8951GetVCOM();
N                    terninalPrintf("VCOM value after burn = %d \r\n",newvcomValue);
N                    IT8951SetVCOM(modifyvcomValue);
N                    recoveryvcomValue = IT8951GetVCOM();
N                    terninalPrintf("Recovery VCOM value = %d \r\n",recoveryvcomValue);
N                 
N     
N                    
N                }
N                else
N                {
N                    terninalPrintf("BURN FAIL\r\n");
N                }
N                
N
N                break;
N                */
N            case '1':
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(3)));
N                //EPDDrawString(FALSE,"        ",300+400,100+(44*(4)));
N                //EPDDrawString(TRUE,"Wait",300+400,100+(44*(2)));
N                terninalPrintf("\r\n =====  [2)EPD VCOM Start] =====\r\n");
N                int tempVCOM;
N                char VCOMString[5];
N                tempVCOM = IT8951GetVCOM();
N                terninalPrintf("\r\nLast VCOM value = %d \r\n",tempVCOM );
N
N                if(SetEPDVCOM())
N                {
N                    vTaskDelay(500/portTICK_RATE_MS);
X                    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    tempVCOM = IT8951GetVCOM();
N                    terninalPrintf("New VCOM value = %d \r\n",tempVCOM);
N
N                }
N                else
N                {
N                    //EPDDrawString(TRUE,"FAIL   ",90+400,100+(44*(4)));
N                }
N                
N                             
N                break;
N            
N            case '2':
N                terninalPrintf("\r\n =====  [3)EPD Burning Test Start] =====\r\n");
N                epdBurningTest(NULL,NULL);
X                epdBurningTest(0,0);
N                break;
N            case '3':  
N                terninalPrintf("\r\n =====  [4)EPD All Black Start] =====\r\n");
N                //EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_BLACK_INDEX,0,0);
N                EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, TRUE);            
X                EPDShowBGScreen(EPD_PICT_ALL_BLACK_INDEX, (1));            
N                terninalPrintf("\r\nPress 'q' to Exit Test\n");
N                while(userResponseLoop()!='q');            
N                GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X                GuiManagerCleanMessage(0x04);
N                
N
N                break;    
N            case '4':
N                terninalPrintf("\r\n =====  [5)EPD All White Start] =====\r\n");
N                //EPDDrawContainByIDPos(TRUE,EPD_PICT_ALL_WHITE_INDEX,0,0);
N                EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, TRUE);              
X                EPDShowBGScreen(EPD_PICT_ALL_WHITE_INDEX, (1));              
N                terninalPrintf("\r\nPress 'q' to Exit Test\n");
N                while(userResponseLoop()!='q');            
N                GuiManagerCleanMessage(GUI_REDRAW_PARA_CONTAIN);
X                GuiManagerCleanMessage(0x04);
N                
N                break;              
N            case '5':
N                //setPrintfFlag(FALSE);
N                if(readEPDswitch() == TRUE)
X                if(readEPDswitch() == (1))
N                {
N                    //EPDDrawString(TRUE,"DISABLE",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"DISABLE",90+325,100+(44*(8)));
X                    EPDDrawString((1),"DISABLE",90+325,100+(44*(8)));
N                    //terninalPrintf("\r\nEPD display disable.\r\n");
N                    //terninalPrintf("\r\n =====  [1)EPD display disable] =====\r\n");
N                    terninalPrintf("\r\n =====  [6)EPD DISP Start] =====\r\n");
N                    terninalPrintf("EPD display disable.\r\n");
N                    toggleEPDswitch(FALSE);
X                    toggleEPDswitch((0));
N
N                }
N                else
N                {
N                    terninalPrintf("\r\n =====  [6)EPD DISP Start] =====\r\n");
N                    vTaskDelay(500/portTICK_RATE_MS);
X                    vTaskDelay(500/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                    toggleEPDswitch(TRUE);
X                    toggleEPDswitch((1));
N                    //GuiManagerInit();
N                    EPDSetBacklight(FALSE);
X                    EPDSetBacklight((0));
N                    //terninalPrintf("\r\nEPD display enable.\r\n");
N                    //terninalPrintf("\r\n =====  [1)EPD display enable] =====\r\n");
N                    terninalPrintf("EPD display enable.\r\n");
N                    //setSpecialCleanFlag(TRUE);
N                    //EPDDrawString(TRUE,"$$$$$$$",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"$$$$$$$",90+325,100+(44*(8)));
X                    EPDDrawString((1),"$$$$$$$",90+325,100+(44*(8)));
N                    //EPDDrawString(TRUE,"------  ",300+450,100+(44*(3)));
N                   // EPDDrawContainByIDPos(FALSE,EPD_PICT_LINE_SMALL_2_INDEX ,300,100+(44*(oldIndex+2)));
N                    //EPDDrawString(TRUE,"ENABLE  ",300+450,100+(44*(7)));
N                    EPDDrawString(TRUE,"ENABLE  ",90+325,100+(44*(8)));
X                    EPDDrawString((1),"ENABLE  ",90+325,100+(44*(8)));
N                    vTaskDelay(1000/portTICK_RATE_MS);
X                    vTaskDelay(1000/( ( TickType_t ) 1000 / ( ( TickType_t ) 100 ) ));
N                }
N            
N            
N                //EPDDrawString(TRUE,"no Function",300+400,100+(44*(4)));
N                break;
N
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("\r\nerror input");
N                break;
W "src\user\hwtester.c" 12487 22 variable "VCOMString" was declared but never referenced
N        }
N
N        if(fExit)
N            break;
N        terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        
N        terninalPrintf("\r\n =====  [a)EPD Tool Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(EPDflashToolListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", EPDflashToolListItem[i].charItem, EPDflashToolListItem[i].itemName);
N        
N        }
N    }
N    //return TRUE;
N    
N    
N    
N    
N    
N    /*
N    char tempchar;
N    terninalPrintf("Press \"Enter\" to Burn EPD or \'s\' to special burning or \'q\' to quit.\r\n");
N    tempchar = userResponseLoop();
N    //setTesterFlag(TRUE);
N    //terninalPrintf("%c   %02x \r\n",tempchar ,tempchar );
N    terninalPrintf("%c\r\n",tempchar);
N    //GuiManagerCleanMessage(GUI_CLEAN_MESSAGE_ENABLE);
N    switch(tempchar)
N    {
N        case 0x0:
N            W25Q64BVburn();
N            break;
N        case 'u':
N            W25Q64BVQuery();
N            break;
N        case 'e':
N            W25Q64BVerase();
N            break;
N        case 's':
N            setW25Q64BVspecialburn();
N            W25Q64BVburn();
N            clrW25Q64BVspecialburn();
N            break;
N        case 'd':
N            W25Q64BVdeviceID();
N            break;
N        case 'q':
N            //terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N            //fExit = TRUE;
N            break;
N        
N        default:
N            terninalPrintf("\r\nerror input\r\n");
N            break;
N    }
N            
N            */
N            
N    
N    
N    
W "src\user\hwtester.c" 12345 9 variable "lastvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12346 9 variable "modifyvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12349 10 variable "lastVCOMString" was declared but never referenced
W "src\user\hwtester.c" 12350 10 variable "modifyVCOMString" was declared but never referenced
W "src\user\hwtester.c" 12351 10 variable "recoveryVCOMString" was declared but never referenced
N}
N
N
Nvoid hwtestEDPflashBurnLite(void)
N{
N    char tempchar;    
N    int lastvcomValue;
N    int modifyvcomValue;
N    int newvcomValue; 
N    int recoveryvcomValue;
N    char lastVCOMString[9];
N    char modifyVCOMString[10];
N    char recoveryVCOMString[12];
N    
N    terninalPrintf("\r\n =====  [EPD Emergent Tool Start] =====\r\n");
N    for(int i = 0; ; i++)
N    {//Dont Show Quit
N        if(EPDEmergentToolListItem[i].charItem == 0)
N        {
N            break;
N        }
N        terninalPrintf("    %c) [%s]\r\n", EPDEmergentToolListItem[i].charItem, EPDEmergentToolListItem[i].itemName);
N        
N    }   
N    BOOL fExit = FALSE;
X    BOOL fExit = (0);
N    while(1)
N    {
N        if(fExit)
N            break;
N        terninalPrintf("--> ");
N        tempchar = userResponseLoop();
N        terninalPrintf("%c",tempchar);
N        switch(tempchar)
N        {
N            case '0':
N                setW25Q64BVspecialburn();
N                W25Q64BVburn();
N                clrW25Q64BVspecialburn();
N                break;
N            case 'q':
N                terninalPrintf("\r\n =====  [q)Quit Start] =====\r\n");
N                fExit = TRUE;
X                fExit = (1);
N                break;
N            default:
N                terninalPrintf("\r\nerror input");
N                break;
N        }
N
N        if(fExit)
N            break;
N        terninalPrintf(" =====  [ End  ] =====\r\n");
N        
N        terninalPrintf("\r\n =====  [EPD Emergent Tool Start] =====\r\n");
N        for(int i = 0; ; i++)
N        {//Dont Show Quit
N            if(EPDEmergentToolListItem[i].charItem == 0)
N            {
N                break;
N            }
N            terninalPrintf("    %c) [%s]\r\n", EPDEmergentToolListItem[i].charItem, EPDEmergentToolListItem[i].itemName);
N        
N        }
N    }
N    
W "src\user\hwtester.c" 12645 9 variable "lastvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12646 9 variable "modifyvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12647 9 variable "newvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12648 9 variable "recoveryvcomValue" was declared but never referenced
W "src\user\hwtester.c" 12649 10 variable "lastVCOMString" was declared but never referenced
W "src\user\hwtester.c" 12650 10 variable "modifyVCOMString" was declared but never referenced
W "src\user\hwtester.c" 12651 10 variable "recoveryVCOMString" was declared but never referenced
N}
N/*
Nuint32_t GetCardID(void){
N    return cardID;
N}*/
N
NBOOL readMBtestFunc(void)
N{
N    return MBtestFlag;
N}
N
NBOOL readAssemblyTestFunc(void)
N{
N    return AssemblyTestFlag;
N}
N
Nvoid HwTestReceieveU32Func(UINT32 tempVal)
N{
N    ReceieveTouchPadVal = tempVal;
N}
N/*** * Copyright (C) 2016 Far Easy Pass LTD. All rights reserved. ***/
N
W "src\user\hwtester.c" 157 13 function "singleTestB" was declared but never referenced
W "src\user\hwtester.c" 11498 13 function "ModemTool" was declared but never referenced
W "src\user\hwtester.c" 11563 13 function "NTPTool" was declared but never referenced
W "src\user\hwtester.c" 2002 13 function "versionQuery" was declared but never referenced
W "src\user\hwtester.c" 7671 13 function "lidarSingleTest" was declared but never referenced
W "src\user\hwtester.c" 4724 13 function "SuperCapTest" was declared but never referenced
W "src\user\hwtester.c" 9352 13 function "radarTest" was declared but never referenced
W "src\user\hwtester.c" 9670 13 function "lidarTest" was declared but never referenced
W "src\user\hwtester.c" 9739 13 function "lidarPowerSet" was declared but never referenced
W "src\user\hwtester.c" 254 13 variable "testerResult" was declared but never referenced
W "src\user\hwtester.c" 255 14 variable "epdString" was declared but never referenced
W "src\user\hwtester.c" 256 13 variable "epdPrintFlag" was declared but never referenced
W "src\user\hwtester.c" 257 13 variable "refreshMsgBar" was declared but never referenced
W "src\user\hwtester.c" 265 16 variable "bayColorOff" was declared but never referenced
W "src\user\hwtester.c" 266 16 variable "bayColorAllGreen" was declared but never referenced
W "src\user\hwtester.c" 267 16 variable "bayColorAllRed" was declared but never referenced
W "src\user\hwtester.c" 284 13 variable "firstInitFlag" was declared but never referenced
W "src\user\hwtester.c" 314 13 variable "SleeptestFlag" was declared but never referenced
W "src\user\hwtester.c" 813 13 function "guiManagerRefreshScreen" was declared but never referenced
W "src\user\hwtester.c" 3106 13 function "redSwitchAllTest_old" was declared but never referenced
W "src\user\hwtester.c" 4783 13 function "readerCNCallback" was declared but never referenced
