; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\ohci.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ohci.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\ohci.crf ..\..\common\src\BSP\Library\USB_HOST\src_core\ohci.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  add_to_ED_remove_list PROC
;;;38     
;;;39     static void add_to_ED_remove_list(ED_T *ed)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;40     {
000004  e1a04000          MOV      r4,r0
;;;41         ED_T  *p;
;;;42     
;;;43         ED_debug("add_to_ED_remove_list - 0x%x (0x%x)\n", (int)ed, ed->Info);
;;;44         DISABLE_OHCI_IRQ();
000008  e3a00018          MOV      r0,#0x18
00000c  ebfffffe          BL       sysDisableInterrupt
;;;45     
;;;46         /* check if this ED found in ed_remove_list */
;;;47         p = ed_remove_list;
000010  e59f038c          LDR      r0,|L1.932|
000014  e5905000          LDR      r5,[r0,#0]  ; ed_remove_list
;;;48         while (p)
000018  ea000005          B        |L1.52|
                  |L1.28|
;;;49         {
;;;50             if (p == ed)
00001c  e1550004          CMP      r5,r4
000020  1a000002          BNE      |L1.48|
;;;51             {
;;;52                 ENABLE_OHCI_IRQ();              /* This ED found in ed_remove_list            */
000024  e3a00018          MOV      r0,#0x18
000028  ebfffffe          BL       sysEnableInterrupt
                  |L1.44|
;;;53                 return;                         /* do nothing                                 */
;;;54             }
;;;55             p = p->next;
;;;56         }
;;;57     
;;;58         ed->Info |= ED_SKIP;                    /* ask OHCI controller skip this ED           */
;;;59         ed->next = ed_remove_list;
;;;60         ed_remove_list = ed;                    /* insert to the head of ed_remove_list       */
;;;61         ENABLE_OHCI_IRQ();
;;;62         _ohci->HcInterruptStatus = USBH_HcInterruptStatus_SF_Msk;
;;;63         _ohci->HcInterruptEnable |= USBH_HcInterruptEnable_SF_Msk;
;;;64         delay_us(2000);                         /* Full speed wait 2 ms is enough             */
;;;65     }
00002c  e8bd8070          POP      {r4-r6,pc}
                  |L1.48|
000030  e5955014          LDR      r5,[r5,#0x14]         ;55
                  |L1.52|
000034  e3550000          CMP      r5,#0                 ;48
000038  1afffff7          BNE      |L1.28|
00003c  e5940000          LDR      r0,[r4,#0]            ;58
000040  e3800901          ORR      r0,r0,#0x4000         ;58
000044  e5840000          STR      r0,[r4,#0]            ;58
000048  e59f0354          LDR      r0,|L1.932|
00004c  e5900000          LDR      r0,[r0,#0]            ;59  ; ed_remove_list
000050  e5840014          STR      r0,[r4,#0x14]         ;59
000054  e59f0348          LDR      r0,|L1.932|
000058  e5804000          STR      r4,[r0,#0]            ;60  ; ed_remove_list
00005c  e3a00018          MOV      r0,#0x18              ;61
000060  ebfffffe          BL       sysEnableInterrupt
000064  e3a00004          MOV      r0,#4                 ;62
000068  e59f1338          LDR      r1,|L1.936|
00006c  e5911000          LDR      r1,[r1,#0]            ;62  ; _ohci
000070  e581000c          STR      r0,[r1,#0xc]          ;62
000074  e59f032c          LDR      r0,|L1.936|
000078  e5900000          LDR      r0,[r0,#0]            ;63  ; _ohci
00007c  e5900010          LDR      r0,[r0,#0x10]         ;63
000080  e3800004          ORR      r0,r0,#4              ;63
000084  e59f131c          LDR      r1,|L1.936|
000088  e5911000          LDR      r1,[r1,#0]            ;63  ; _ohci
00008c  e5810010          STR      r0,[r1,#0x10]         ;63
000090  e3a00e7d          MOV      r0,#0x7d0             ;64
000094  ebfffffe          BL       delay_us
000098  e1a00000          MOV      r0,r0
00009c  eaffffe2          B        |L1.44|
;;;66     
                          ENDP

                  ohci_reset PROC
;;;67     static int ohci_reset(void)
0000a0  e92d4010          PUSH     {r4,lr}
;;;68     {
;;;69         volatile int  t0;
;;;70     
;;;71         /* Disable HC interrupts  */
;;;72         _ohci->HcInterruptDisable = USBH_HcInterruptDisable_MIE_Msk;
0000a4  e3a00102          MOV      r0,#0x80000000
0000a8  e59f12f8          LDR      r1,|L1.936|
0000ac  e5911000          LDR      r1,[r1,#0]  ; _ohci
0000b0  e5810014          STR      r0,[r1,#0x14]
;;;73     
;;;74         /* HC Reset requires max 10 ms delay  */
;;;75         _ohci->HcControl = 0;
0000b4  e3a00000          MOV      r0,#0
0000b8  e59f12e8          LDR      r1,|L1.936|
0000bc  e5911000          LDR      r1,[r1,#0]  ; _ohci
0000c0  e5810004          STR      r0,[r1,#4]
;;;76         _ohci->HcCommandStatus = USBH_HcCommandStatus_HCR_Msk;
0000c4  e3a00001          MOV      r0,#1
0000c8  e59f12d8          LDR      r1,|L1.936|
0000cc  e5911000          LDR      r1,[r1,#0]  ; _ohci
0000d0  e5810008          STR      r0,[r1,#8]
;;;77     
;;;78         delay_us(10000);
0000d4  e59f02d0          LDR      r0,|L1.940|
0000d8  ebfffffe          BL       delay_us
;;;79     
;;;80         /* Check if OHCI reset completed? */
;;;81         if ((USBH->HcCommandStatus & USBH_HcCommandStatus_HCR_Msk) != 0)
0000dc  e59f02cc          LDR      r0,|L1.944|
0000e0  e5900008          LDR      r0,[r0,#8]
0000e4  e3100001          TST      r0,#1
0000e8  0a000003          BEQ      |L1.252|
;;;82         {
;;;83             USB_error("Error! - USB OHCI reset timed out!\n");
0000ec  e28f0d0b          ADR      r0,|L1.948|
0000f0  ebfffffe          BL       sysprintf
;;;84             return -1;
0000f4  e3e00000          MVN      r0,#0
                  |L1.248|
;;;85         }
;;;86     
;;;87         USBH->HcRhStatus = USBH_HcRhStatus_OCI_Msk | USBH_HcRhStatus_LPS_Msk;
;;;88     
;;;89         USBH->HcControl = HCFS_RESET;
;;;90     
;;;91         delay_us(10000);
;;;92     
;;;93         /* Check if OHCI reset completed? */
;;;94         if ((USBH->HcCommandStatus & USBH_HcCommandStatus_HCR_Msk) != 0)
;;;95         {
;;;96             USB_error("Error! - USB HC reset timed out!\n");
;;;97             return -1;
;;;98         }
;;;99         return 0;
;;;100    }
0000f8  e8bd8010          POP      {r4,pc}
                  |L1.252|
0000fc  e3a00003          MOV      r0,#3                 ;87
000100  e59f12a8          LDR      r1,|L1.944|
000104  e5810050          STR      r0,[r1,#0x50]         ;87
000108  e3a00000          MOV      r0,#0                 ;89
00010c  e5810004          STR      r0,[r1,#4]            ;89
000110  e59f0294          LDR      r0,|L1.940|
000114  ebfffffe          BL       delay_us
000118  e59f0290          LDR      r0,|L1.944|
00011c  e5900008          LDR      r0,[r0,#8]            ;94
000120  e3100001          TST      r0,#1                 ;94
000124  0a000003          BEQ      |L1.312|
000128  e28f0faa          ADR      r0,|L1.984|
00012c  ebfffffe          BL       sysprintf
000130  e3e00000          MVN      r0,#0                 ;97
000134  eaffffef          B        |L1.248|
                  |L1.312|
000138  e3a00000          MOV      r0,#0                 ;99
00013c  eaffffed          B        |L1.248|
;;;101    
                          ENDP

                  init_hcca_int_table PROC
;;;102    static void init_hcca_int_table()
000140  e92d41f0          PUSH     {r4-r8,lr}
;;;103    {
;;;104        ED_T   *ed_p;
;;;105        int    i, idx, interval;
;;;106    
;;;107        memset(_hcca->int_table, 0, sizeof(_hcca->int_table));
000144  e3a01080          MOV      r1,#0x80
000148  e59f02ac          LDR      r0,|L1.1020|
00014c  e5900000          LDR      r0,[r0,#0]  ; _hcca
000150  ebfffffe          BL       __aeabi_memclr4
;;;108    
;;;109        for (i = 5; i >= 0; i--)                /* interval = i^2                             */
000154  e3a04005          MOV      r4,#5
000158  ea00002b          B        |L1.524|
                  |L1.348|
;;;110        {
;;;111            _Ied[i] = alloc_ohci_ED();
00015c  ebfffffe          BL       alloc_ohci_ED
000160  e59f1298          LDR      r1,|L1.1024|
000164  e7810104          STR      r0,[r1,r4,LSL #2]
;;;112            _Ied[i]->Info = ED_SKIP;
000168  e3a00901          MOV      r0,#0x4000
00016c  e7911104          LDR      r1,[r1,r4,LSL #2]
000170  e5810000          STR      r0,[r1,#0]
;;;113    
;;;114            interval = 0x1 << i;
000174  e3a00001          MOV      r0,#1
000178  e1a07410          LSL      r7,r0,r4
;;;115    
;;;116            for (idx = interval - 1; idx < 32; idx += interval)
00017c  e2475001          SUB      r5,r7,#1
000180  ea00001e          B        |L1.512|
                  |L1.388|
;;;117            {
;;;118                if (_hcca->int_table[idx] == 0)       /* is empty list, insert directly        */
000184  e59f0270          LDR      r0,|L1.1020|
000188  e5900000          LDR      r0,[r0,#0]  ; _hcca
00018c  e7900105          LDR      r0,[r0,r5,LSL #2]
000190  e3500000          CMP      r0,#0
000194  1a000005          BNE      |L1.432|
;;;119                {
;;;120                    _hcca->int_table[idx] = (uint32_t)_Ied[i];
000198  e59f0260          LDR      r0,|L1.1024|
00019c  e7900104          LDR      r0,[r0,r4,LSL #2]
0001a0  e59f1254          LDR      r1,|L1.1020|
0001a4  e5911000          LDR      r1,[r1,#0]  ; _hcca
0001a8  e7810105          STR      r0,[r1,r5,LSL #2]
0001ac  ea000012          B        |L1.508|
                  |L1.432|
;;;121                }
;;;122                else
;;;123                {
;;;124                    ed_p = (ED_T *)_hcca->int_table[idx];
0001b0  e59f0244          LDR      r0,|L1.1020|
0001b4  e5900000          LDR      r0,[r0,#0]  ; _hcca
0001b8  e7906105          LDR      r6,[r0,r5,LSL #2]
;;;125    
;;;126                    while (1)
0001bc  ea00000c          B        |L1.500|
                  |L1.448|
;;;127                    {
;;;128                        if (ed_p == _Ied[i])
0001c0  e59f0238          LDR      r0,|L1.1024|
0001c4  e7900104          LDR      r0,[r0,r4,LSL #2]
0001c8  e1500006          CMP      r0,r6
0001cc  1a000000          BNE      |L1.468|
;;;129                            break;                   /* already chained by previous visit     */
0001d0  ea000008          B        |L1.504|
                  |L1.468|
;;;130    
;;;131                        if (ed_p->NextED == 0)       /* reach end of list?                    */
0001d4  e596000c          LDR      r0,[r6,#0xc]
0001d8  e3500000          CMP      r0,#0
0001dc  1a000003          BNE      |L1.496|
;;;132                        {
;;;133                            ed_p->NextED = (uint32_t)_Ied[i];
0001e0  e59f0218          LDR      r0,|L1.1024|
0001e4  e7900104          LDR      r0,[r0,r4,LSL #2]
0001e8  e586000c          STR      r0,[r6,#0xc]
;;;134                            break;
0001ec  ea000001          B        |L1.504|
                  |L1.496|
;;;135                        }
;;;136                        ed_p = (ED_T *)ed_p->NextED;
0001f0  e596600c          LDR      r6,[r6,#0xc]
                  |L1.500|
0001f4  eafffff1          B        |L1.448|
                  |L1.504|
0001f8  e1a00000          MOV      r0,r0                 ;129
                  |L1.508|
0001fc  e0855007          ADD      r5,r5,r7              ;116
                  |L1.512|
000200  e3550020          CMP      r5,#0x20              ;116
000204  baffffde          BLT      |L1.388|
000208  e2444001          SUB      r4,r4,#1              ;109
                  |L1.524|
00020c  e3540000          CMP      r4,#0                 ;109
000210  aaffffd1          BGE      |L1.348|
;;;137                    }
;;;138                }
;;;139            }
;;;140        }
;;;141    }
000214  e8bd81f0          POP      {r4-r8,pc}
;;;142    
                          ENDP

                  get_int_tree_head_node PROC
;;;143    static ED_T * get_int_tree_head_node(int interval)
000218  e1a01000          MOV      r1,r0
;;;144    {
;;;145        int    i;
;;;146    
;;;147        for (i = 0; i < 5; i++)
00021c  e3a02000          MOV      r2,#0
000220  ea000006          B        |L1.576|
                  |L1.548|
;;;148        {
;;;149            interval >>= 1;
000224  e1a010c1          ASR      r1,r1,#1
;;;150            if (interval == 0)
000228  e3510000          CMP      r1,#0
00022c  1a000002          BNE      |L1.572|
;;;151                return _Ied[i];
000230  e59f01c8          LDR      r0,|L1.1024|
000234  e7900102          LDR      r0,[r0,r2,LSL #2]
                  |L1.568|
;;;152        }
;;;153        return _Ied[5];                         /* for interval >= 32                         */
;;;154    }
000238  e12fff1e          BX       lr
                  |L1.572|
00023c  e2822001          ADD      r2,r2,#1              ;147
                  |L1.576|
000240  e3520005          CMP      r2,#5                 ;147
000244  bafffff6          BLT      |L1.548|
000248  e59f01b0          LDR      r0,|L1.1024|
00024c  e5900014          LDR      r0,[r0,#0x14]         ;153  ; _Ied
000250  eafffff8          B        |L1.568|
;;;155    
                          ENDP

                  get_ohci_interval PROC
;;;156    static int get_ohci_interval(int interval)
000254  e1a01000          MOV      r1,r0
;;;157    {
;;;158        int    i, bInterval = 1;
000258  e3a03001          MOV      r3,#1
;;;159    
;;;160        for (i = 0; i < 5; i++)
00025c  e3a02000          MOV      r2,#0
000260  ea000006          B        |L1.640|
                  |L1.612|
;;;161        {
;;;162            interval >>= 1;
000264  e1a010c1          ASR      r1,r1,#1
;;;163            if (interval == 0)
000268  e3510000          CMP      r1,#0
00026c  1a000001          BNE      |L1.632|
;;;164                return bInterval;
000270  e1a00003          MOV      r0,r3
                  |L1.628|
;;;165            bInterval *= 2;
;;;166        }
;;;167        return 32;                              /* for interval >= 32                         */
;;;168    }
000274  e12fff1e          BX       lr
                  |L1.632|
000278  e1a03083          LSL      r3,r3,#1              ;165
00027c  e2822001          ADD      r2,r2,#1              ;160
                  |L1.640|
000280  e3520005          CMP      r2,#5                 ;160
000284  bafffff6          BLT      |L1.612|
000288  e3a00020          MOV      r0,#0x20              ;167
00028c  eafffff8          B        |L1.628|
;;;169    
                          ENDP

                  ohci_init PROC
;;;170    
;;;171    static int  ohci_init(void)
000290  e92d4010          PUSH     {r4,lr}
;;;172    {
;;;173        uint32_t    fminterval;
;;;174        volatile int    i;
;;;175    
;;;176        _hcca = (HCCA_T *)((uint32_t)_hcca_mem | NON_CACHE_MASK);
000294  e59f0168          LDR      r0,|L1.1028|
000298  e3800102          ORR      r0,r0,#0x80000000
00029c  e59f1158          LDR      r1,|L1.1020|
0002a0  e5810000          STR      r0,[r1,#0]  ; _hcca
;;;177    
;;;178        if (ohci_reset() < 0)
0002a4  ebfffffe          BL       ohci_reset
0002a8  e3500000          CMP      r0,#0
0002ac  aa000001          BGE      |L1.696|
;;;179            return -1;
0002b0  e3e00000          MVN      r0,#0
                  |L1.692|
;;;180    
;;;181        ed_remove_list = NULL;
;;;182    
;;;183        init_hcca_int_table();
;;;184    
;;;185        /* Tell the controller where the control and bulk lists are
;;;186         * The lists are empty now. */
;;;187        _ohci->HcControlHeadED = 0;             /* control ED list head                       */
;;;188        _ohci->HcBulkHeadED = 0;                /* bulk ED list head                          */
;;;189    
;;;190        _ohci->HcHCCA = (uint32_t)_hcca;        /* HCCA area                                  */
;;;191    
;;;192        /* periodic start 90% of frame interval       */
;;;193        fminterval = 0x2edf;                    /* 11,999                                     */
;;;194        _ohci->HcPeriodicStart = (fminterval*9)/10;
;;;195    
;;;196        /* set FSLargestDataPacket, 10,104 for 0x2edf frame interval */
;;;197        fminterval |= ((((fminterval - 210) * 6) / 7) << 16);
;;;198        _ohci->HcFmInterval = fminterval;
;;;199    
;;;200        _ohci->HcLSThreshold = 0x628;
;;;201    
;;;202        /* start controller operations                */
;;;203        _ohci->HcControl = HCFS_OPER | (0x3 << USBH_HcControl_CBSR_Pos);
;;;204    
;;;205    #ifdef OHCI_PER_PORT_POWER
;;;206        _ohci->HcRhDescriptorB = 0x60000;
;;;207        _ohci->HcRhPortStatus[0] = USBH_HcRhPortStatus_PPS_Msk;
;;;208        _ohci->HcRhPortStatus[1] = USBH_HcRhPortStatus_PPS_Msk;
;;;209    #else
;;;210        _ohci->HcRhDescriptorA = (USBH->HcRhDescriptorA | (1<<9)) & ~USBH_HcRhDescriptorA_PSM_Msk;
;;;211        _ohci->HcRhStatus = USBH_HcRhStatus_LPSC_Msk;
;;;212    #endif
;;;213    
;;;214        _ohci->HcInterruptEnable = USBH_HcInterruptEnable_MIE_Msk | USBH_HcInterruptEnable_WDH_Msk | USBH_HcInterruptEnable_SF_Msk;
;;;215    
;;;216        /* POTPGT delay is bits 24-31, in 20 ms units.                                         */
;;;217        delay_us(20000);
;;;218        return 0;
;;;219    }
0002b4  e8bd8010          POP      {r4,pc}
                  |L1.696|
0002b8  e3a00000          MOV      r0,#0                 ;181
0002bc  e59f10e0          LDR      r1,|L1.932|
0002c0  e5810000          STR      r0,[r1,#0]            ;181  ; ed_remove_list
0002c4  ebfffffe          BL       init_hcca_int_table
0002c8  e3a00000          MOV      r0,#0                 ;187
0002cc  e59f10d4          LDR      r1,|L1.936|
0002d0  e5911000          LDR      r1,[r1,#0]            ;187  ; _ohci
0002d4  e5810020          STR      r0,[r1,#0x20]         ;187
0002d8  e59f10c8          LDR      r1,|L1.936|
0002dc  e5911000          LDR      r1,[r1,#0]            ;188  ; _ohci
0002e0  e5810028          STR      r0,[r1,#0x28]         ;188
0002e4  e59f0110          LDR      r0,|L1.1020|
0002e8  e5900000          LDR      r0,[r0,#0]            ;190  ; _hcca
0002ec  e59f10b4          LDR      r1,|L1.936|
0002f0  e5911000          LDR      r1,[r1,#0]            ;190  ; _ohci
0002f4  e5810018          STR      r0,[r1,#0x18]         ;190
0002f8  e59f4108          LDR      r4,|L1.1032|
0002fc  e0840184          ADD      r0,r4,r4,LSL #3       ;194
000300  e3a0100a          MOV      r1,#0xa               ;194
000304  ebfffffe          BL       __aeabi_uidivmod
000308  e59f1098          LDR      r1,|L1.936|
00030c  e5911000          LDR      r1,[r1,#0]            ;194  ; _ohci
000310  e5810040          STR      r0,[r1,#0x40]         ;194
000314  e24410d2          SUB      r1,r4,#0xd2           ;197
000318  e0811081          ADD      r1,r1,r1,LSL #1       ;197
00031c  e1a00081          LSL      r0,r1,#1              ;197
000320  e3a01007          MOV      r1,#7                 ;197
000324  ebfffffe          BL       __aeabi_uidivmod
000328  e1844800          ORR      r4,r4,r0,LSL #16      ;197
00032c  e59f0074          LDR      r0,|L1.936|
000330  e5900000          LDR      r0,[r0,#0]            ;198  ; _ohci
000334  e5804034          STR      r4,[r0,#0x34]         ;198
000338  e59f00cc          LDR      r0,|L1.1036|
00033c  e59f1064          LDR      r1,|L1.936|
000340  e5911000          LDR      r1,[r1,#0]            ;200  ; _ohci
000344  e5810044          STR      r0,[r1,#0x44]         ;200
000348  e3a00083          MOV      r0,#0x83              ;203
00034c  e59f1054          LDR      r1,|L1.936|
000350  e5911000          LDR      r1,[r1,#0]            ;203  ; _ohci
000354  e5810004          STR      r0,[r1,#4]            ;203
000358  e59f0050          LDR      r0,|L1.944|
00035c  e5900048          LDR      r0,[r0,#0x48]         ;210
000360  e3c00c01          BIC      r0,r0,#0x100          ;210
000364  e3800c02          ORR      r0,r0,#0x200          ;210
000368  e59f1038          LDR      r1,|L1.936|
00036c  e5911000          LDR      r1,[r1,#0]            ;210  ; _ohci
000370  e5810048          STR      r0,[r1,#0x48]         ;210
000374  e3a00801          MOV      r0,#0x10000           ;211
000378  e59f1028          LDR      r1,|L1.936|
00037c  e5911000          LDR      r1,[r1,#0]            ;211  ; _ohci
000380  e5810050          STR      r0,[r1,#0x50]         ;211
000384  e3a0011a          MOV      r0,#0x80000006        ;214
000388  e59f1018          LDR      r1,|L1.936|
00038c  e5911000          LDR      r1,[r1,#0]            ;214  ; _ohci
000390  e5810010          STR      r0,[r1,#0x10]         ;214
000394  e59f0074          LDR      r0,|L1.1040|
000398  ebfffffe          BL       delay_us
00039c  e3a00000          MOV      r0,#0                 ;218
0003a0  eaffffc3          B        |L1.692|
                  |L1.932|
                          DCD      ed_remove_list
                  |L1.936|
                          DCD      _ohci
                  |L1.940|
                          DCD      0x00002710
                  |L1.944|
                          DCD      0xb0007000
                  |L1.948|
0003b4  4572726f          DCB      "Error! - USB OHCI reset timed out!\n",0
0003b8  7221202d
0003bc  20555342
0003c0  204f4843
0003c4  49207265
0003c8  73657420
0003cc  74696d65
0003d0  64206f75
0003d4  74210a00
                  |L1.984|
0003d8  4572726f          DCB      "Error! - USB HC reset timed out!\n",0
0003dc  7221202d
0003e0  20555342
0003e4  20484320
0003e8  72657365
0003ec  74207469
0003f0  6d656420
0003f4  6f757421
0003f8  0a00    
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L1.1020|
                          DCD      _hcca
                  |L1.1024|
                          DCD      _Ied
                  |L1.1028|
                          DCD      _hcca_mem
                  |L1.1032|
                          DCD      0x00002edf
                  |L1.1036|
                          DCD      0x00000628
                  |L1.1040|
                          DCD      0x00004e20
                          ENDP

                  ohci_suspend PROC
;;;220    
;;;221    static void ohci_suspend(void)
000414  e51f0074          LDR      r0,|L1.936|
;;;222    {
;;;223        /* set port suspend if connected */
;;;224        if (_ohci->HcRhPortStatus[0] & 0x1)
000418  e5900000          LDR      r0,[r0,#0]  ; _ohci
00041c  e5900054          LDR      r0,[r0,#0x54]
000420  e3100001          TST      r0,#1
000424  0a000003          BEQ      |L1.1080|
;;;225            _ohci->HcRhPortStatus[0] = 0x4;
000428  e3a00004          MOV      r0,#4
00042c  e51f108c          LDR      r1,|L1.936|
000430  e5911000          LDR      r1,[r1,#0]  ; _ohci
000434  e5810054          STR      r0,[r1,#0x54]
                  |L1.1080|
;;;226    
;;;227        if (_ohci->HcRhPortStatus[1] & 0x1)
000438  e51f0098          LDR      r0,|L1.936|
00043c  e5900000          LDR      r0,[r0,#0]  ; _ohci
000440  e5900058          LDR      r0,[r0,#0x58]
000444  e3100001          TST      r0,#1
000448  0a000003          BEQ      |L1.1116|
;;;228            _ohci->HcRhPortStatus[1] = 0x4;
00044c  e3a00004          MOV      r0,#4
000450  e51f10b0          LDR      r1,|L1.936|
000454  e5911000          LDR      r1,[r1,#0]  ; _ohci
000458  e5810058          STR      r0,[r1,#0x58]
                  |L1.1116|
;;;229    
;;;230        /* enable Device Remote Wakeup */
;;;231        _ohci->HcRhStatus |= USBH_HcRhStatus_DRWE_Msk;
00045c  e51f00bc          LDR      r0,|L1.936|
000460  e5900000          LDR      r0,[r0,#0]  ; _ohci
000464  e5900050          LDR      r0,[r0,#0x50]
000468  e3800902          ORR      r0,r0,#0x8000
00046c  e51f10cc          LDR      r1,|L1.936|
000470  e5911000          LDR      r1,[r1,#0]  ; _ohci
000474  e5810050          STR      r0,[r1,#0x50]
;;;232    
;;;233        /* enable USBH RHSC interrupt for system wakeup */
;;;234        _ohci->HcInterruptEnable |=  USBH_HcInterruptEnable_RHSC_Msk | USBH_HcInterruptEnable_RD_Msk;
000478  e51f00d8          LDR      r0,|L1.936|
00047c  e5900000          LDR      r0,[r0,#0]  ; _ohci
000480  e5900010          LDR      r0,[r0,#0x10]
000484  e3800048          ORR      r0,r0,#0x48
000488  e51f10e8          LDR      r1,|L1.936|
00048c  e5911000          LDR      r1,[r1,#0]  ; _ohci
000490  e5810010          STR      r0,[r1,#0x10]
;;;235    
;;;236        /* set Host Controller enter suspend state */
;;;237        _ohci->HcControl = (USBH->HcControl & ~USBH_HcControl_HCFS_Msk) | (3 << USBH_HcControl_HCFS_Pos);
000494  e51f00ec          LDR      r0,|L1.944|
000498  e5900004          LDR      r0,[r0,#4]
00049c  e38000c0          ORR      r0,r0,#0xc0
0004a0  e51f1100          LDR      r1,|L1.936|
0004a4  e5911000          LDR      r1,[r1,#0]  ; _ohci
0004a8  e5810004          STR      r0,[r1,#4]
;;;238    }
0004ac  e12fff1e          BX       lr
;;;239    
                          ENDP

                  ohci_resume PROC
;;;240    static void ohci_resume(void)
0004b0  e51f0108          LDR      r0,|L1.944|
;;;241    {
;;;242        _ohci->HcControl = (USBH->HcControl & ~USBH_HcControl_HCFS_Msk) | (1 << USBH_HcControl_HCFS_Pos);
0004b4  e5900004          LDR      r0,[r0,#4]
0004b8  e3c000c0          BIC      r0,r0,#0xc0
0004bc  e3800040          ORR      r0,r0,#0x40
0004c0  e51f1120          LDR      r1,|L1.936|
0004c4  e5911000          LDR      r1,[r1,#0]  ; _ohci
0004c8  e5810004          STR      r0,[r1,#4]
;;;243        _ohci->HcControl = (USBH->HcControl & ~USBH_HcControl_HCFS_Msk) | (2 << USBH_HcControl_HCFS_Pos);
0004cc  e51f0124          LDR      r0,|L1.944|
0004d0  e5900004          LDR      r0,[r0,#4]
0004d4  e3c000c0          BIC      r0,r0,#0xc0
0004d8  e3800080          ORR      r0,r0,#0x80
0004dc  e51f113c          LDR      r1,|L1.936|
0004e0  e5911000          LDR      r1,[r1,#0]  ; _ohci
0004e4  e5810004          STR      r0,[r1,#4]
;;;244    
;;;245        if (_ohci->HcRhPortStatus[0] & 0x4)
0004e8  e51f0148          LDR      r0,|L1.936|
0004ec  e5900000          LDR      r0,[r0,#0]  ; _ohci
0004f0  e5900054          LDR      r0,[r0,#0x54]
0004f4  e3100004          TST      r0,#4
0004f8  0a000003          BEQ      |L1.1292|
;;;246            _ohci->HcRhPortStatus[0] = 0x8;
0004fc  e3a00008          MOV      r0,#8
000500  e51f1160          LDR      r1,|L1.936|
000504  e5911000          LDR      r1,[r1,#0]  ; _ohci
000508  e5810054          STR      r0,[r1,#0x54]
                  |L1.1292|
;;;247        if (_ohci->HcRhPortStatus[1] & 0x4)
00050c  e51f016c          LDR      r0,|L1.936|
000510  e5900000          LDR      r0,[r0,#0]  ; _ohci
000514  e5900058          LDR      r0,[r0,#0x58]
000518  e3100004          TST      r0,#4
00051c  0a000003          BEQ      |L1.1328|
;;;248            _ohci->HcRhPortStatus[1] = 0x8;
000520  e3a00008          MOV      r0,#8
000524  e51f1184          LDR      r1,|L1.936|
000528  e5911000          LDR      r1,[r1,#0]  ; _ohci
00052c  e5810058          STR      r0,[r1,#0x58]
                  |L1.1328|
;;;249    }
000530  e12fff1e          BX       lr
;;;250    
                          ENDP

                  ohci_shutdown PROC
;;;251    static void ohci_shutdown(void)
000534  e92d4010          PUSH     {r4,lr}
;;;252    {
;;;253        ohci_suspend();
000538  ebfffffe          BL       ohci_suspend
;;;254        DISABLE_OHCI_IRQ();
00053c  e3a00018          MOV      r0,#0x18
000540  ebfffffe          BL       sysDisableInterrupt
;;;255    #ifndef OHCI_PER_PORT_POWER
;;;256        _ohci->HcRhStatus = USBH_HcRhStatus_LPS_Msk;
000544  e3a00001          MOV      r0,#1
000548  e51f11a8          LDR      r1,|L1.936|
00054c  e5911000          LDR      r1,[r1,#0]  ; _ohci
000550  e5810050          STR      r0,[r1,#0x50]
;;;257    #endif
;;;258    }
000554  e8bd8010          POP      {r4,pc}
;;;259    
                          ENDP

                  ohci_quit_xfer PROC
;;;263     */
;;;264    static int ohci_quit_xfer(UTR_T *utr, EP_INFO_T *ep)
000558  e92d4070          PUSH     {r4-r6,lr}
;;;265    {
00055c  e1a04000          MOV      r4,r0
000560  e1a05001          MOV      r5,r1
;;;266        ED_T       *ed;
;;;267    
;;;268        if (utr != NULL)
000564  e3540000          CMP      r4,#0
000568  0a00000f          BEQ      |L1.1452|
;;;269        {
;;;270            if (utr->ep == NULL)
00056c  e594000c          LDR      r0,[r4,#0xc]
000570  e3500000          CMP      r0,#0
000574  1a000001          BNE      |L1.1408|
;;;271                return USBH_ERR_NOT_FOUND;
000578  e3e00069          MVN      r0,#0x69
                  |L1.1404|
;;;272    
;;;273            ed = (ED_T *)(utr->ep->hw_pipe);
;;;274    
;;;275            if (!ed)
;;;276                return USBH_ERR_NOT_FOUND;
;;;277    
;;;278            /* add the endpoint to remove list, it will be removed on the next start of frame */
;;;279            add_to_ED_remove_list(ed);
;;;280            utr->ep->hw_pipe = NULL;
;;;281        }
;;;282    
;;;283        if ((ep != NULL) && (ep->hw_pipe != NULL))
;;;284        {
;;;285            ed = (ED_T *)(ep->hw_pipe);
;;;286            /* add the endpoint to remove list, it will be removed on the next start of frame */
;;;287            add_to_ED_remove_list(ed);
;;;288            ep->hw_pipe = NULL;
;;;289        }
;;;290    
;;;291        return 0;
;;;292    }
00057c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1408|
000580  e594000c          LDR      r0,[r4,#0xc]          ;273
000584  e5906008          LDR      r6,[r0,#8]            ;273
000588  e3560000          CMP      r6,#0                 ;275
00058c  1a000001          BNE      |L1.1432|
000590  e3e00069          MVN      r0,#0x69              ;276
000594  eafffff8          B        |L1.1404|
                  |L1.1432|
000598  e1a00006          MOV      r0,r6                 ;279
00059c  ebfffffe          BL       add_to_ED_remove_list
0005a0  e3a00000          MOV      r0,#0                 ;280
0005a4  e594100c          LDR      r1,[r4,#0xc]          ;280
0005a8  e5810008          STR      r0,[r1,#8]            ;280
                  |L1.1452|
0005ac  e3550000          CMP      r5,#0                 ;283
0005b0  0a000007          BEQ      |L1.1492|
0005b4  e5950008          LDR      r0,[r5,#8]            ;283
0005b8  e3500000          CMP      r0,#0                 ;283
0005bc  0a000004          BEQ      |L1.1492|
0005c0  e5956008          LDR      r6,[r5,#8]            ;285
0005c4  e1a00006          MOV      r0,r6                 ;287
0005c8  ebfffffe          BL       add_to_ED_remove_list
0005cc  e3a00000          MOV      r0,#0                 ;288
0005d0  e5850008          STR      r0,[r5,#8]            ;288
                  |L1.1492|
0005d4  e3a00000          MOV      r0,#0                 ;291
0005d8  eaffffe7          B        |L1.1404|
;;;293    
                          ENDP

                  ed_make_info PROC
;;;294    uint32_t ed_make_info(UDEV_T *udev, EP_INFO_T *ep)
0005dc  e1a02000          MOV      r2,r0
;;;295    {
;;;296        uint32_t  info;
;;;297    
;;;298        if (ep == NULL)                             /* is acontrol endpoint                   */
0005e0  e3510000          CMP      r1,#0
0005e4  1a00000e          BNE      |L1.1572|
;;;299        {
;;;300            /* control endpoint direction is from TD  */
;;;301            if (udev->descriptor.bMaxPacketSize0 == 0)   /* is 0 if device descriptor still not obtained. */
0005e8  e5d23007          LDRB     r3,[r2,#7]
0005ec  e3530000          CMP      r3,#0
0005f0  1a000007          BNE      |L1.1556|
;;;302            {
;;;303                if (udev->speed == SPEED_LOW)       /* give a default maximum packet size     */
0005f4  e5d2301b          LDRB     r3,[r2,#0x1b]
0005f8  e3530000          CMP      r3,#0
0005fc  1a000002          BNE      |L1.1548|
;;;304                    udev->descriptor.bMaxPacketSize0 = 8;
000600  e3a03008          MOV      r3,#8
000604  e5c23007          STRB     r3,[r2,#7]
000608  ea000001          B        |L1.1556|
                  |L1.1548|
;;;305                else
;;;306                    udev->descriptor.bMaxPacketSize0 = 64;
00060c  e3a03040          MOV      r3,#0x40
000610  e5c23007          STRB     r3,[r2,#7]
                  |L1.1556|
;;;307            }
;;;308            info = (udev->descriptor.bMaxPacketSize0 << 16) /* Control endpoint Maximum Packet Size from device descriptor */
000614  e5d23007          LDRB     r3,[r2,#7]
000618  e3a0c000          MOV      r12,#0
00061c  e18c0803          ORR      r0,r12,r3,LSL #16
000620  ea000012          B        |L1.1648|
                  |L1.1572|
;;;309                   | ED_DIR_BY_TD                   /* Direction (Get direction From TD)      */
;;;310                   | ED_FORMAT_GENERAL              /* General format                         */
;;;311                   | (0 << ED_CTRL_EN_Pos);         /* Endpoint address 0                     */
;;;312        }
;;;313        else                                        /* Other endpoint direction is from endpoint descriptor */
;;;314        {
;;;315            info = (ep->wMaxPacketSize << 16);      /* Maximum Packet Size from endpoint      */
000624  e1d130b4          LDRH     r3,[r1,#4]
000628  e1a00803          LSL      r0,r3,#16
;;;316    
;;;317            info |= ((ep->bEndpointAddress & 0xf) << ED_CTRL_EN_Pos);   /* Enpoint Number     */
00062c  e5d13000          LDRB     r3,[r1,#0]
000630  e203300f          AND      r3,r3,#0xf
000634  e1800383          ORR      r0,r0,r3,LSL #7
;;;318    
;;;319            if ((ep->bEndpointAddress & EP_ADDR_DIR_MASK) == EP_ADDR_DIR_IN)
000638  e5d13000          LDRB     r3,[r1,#0]
00063c  e2033080          AND      r3,r3,#0x80
000640  e3530080          CMP      r3,#0x80
000644  1a000001          BNE      |L1.1616|
;;;320                info |= ED_DIR_IN;
000648  e3800a01          ORR      r0,r0,#0x1000
00064c  ea000000          B        |L1.1620|
                  |L1.1616|
;;;321            else
;;;322                info |= ED_DIR_OUT;
000650  e3800b02          ORR      r0,r0,#0x800
                  |L1.1620|
;;;323    
;;;324            if ((ep->bmAttributes & EP_ATTR_TT_MASK) == EP_ATTR_TT_ISO)
000654  e5d13001          LDRB     r3,[r1,#1]
000658  e2033003          AND      r3,r3,#3
00065c  e3530001          CMP      r3,#1
000660  1a000001          BNE      |L1.1644|
;;;325                info |= ED_FORMAT_ISO;
000664  e3800902          ORR      r0,r0,#0x8000
000668  ea000000          B        |L1.1648|
                  |L1.1644|
;;;326            else
;;;327                info |= ED_FORMAT_GENERAL;
00066c  e1a00000          MOV      r0,r0
                  |L1.1648|
;;;328        }
;;;329    
;;;330        info |= ((udev->speed == SPEED_LOW)  ? ED_SPEED_LOW : ED_SPEED_FULL);  /* Speed       */
000670  e5d2301b          LDRB     r3,[r2,#0x1b]
000674  e3530000          CMP      r3,#0
000678  1a000001          BNE      |L1.1668|
00067c  e3a03a02          MOV      r3,#0x2000
000680  ea000000          B        |L1.1672|
                  |L1.1668|
000684  e3a03000          MOV      r3,#0
                  |L1.1672|
000688  e1800003          ORR      r0,r0,r3
;;;331        info |= (udev->dev_num);                  /* Function Address                         */
00068c  e5d23019          LDRB     r3,[r2,#0x19]
000690  e1800003          ORR      r0,r0,r3
;;;332    
;;;333        return info;
;;;334    }
000694  e12fff1e          BX       lr
;;;335    
                          ENDP

                  write_td PROC
;;;336    static void write_td(TD_T *td, uint32_t info, uint8_t *buff, uint32_t data_len)
000698  e5801000          STR      r1,[r0,#0]
;;;337    {
;;;338        td->Info = info;
;;;339        td->CBP  = (uint32_t)((!buff || !data_len) ? 0 : buff);
00069c  e3520000          CMP      r2,#0
0006a0  0a000001          BEQ      |L1.1708|
0006a4  e3530000          CMP      r3,#0
0006a8  1a000001          BNE      |L1.1716|
                  |L1.1708|
0006ac  e3a0c000          MOV      r12,#0
0006b0  ea000000          B        |L1.1720|
                  |L1.1716|
0006b4  e1a0c002          MOV      r12,r2
                  |L1.1720|
0006b8  e580c004          STR      r12,[r0,#4]
;;;340        td->BE   = (uint32_t)((!buff || !data_len ) ? 0 : (uint32_t)buff + data_len - 1);
0006bc  e3520000          CMP      r2,#0
0006c0  0a000001          BEQ      |L1.1740|
0006c4  e3530000          CMP      r3,#0
0006c8  1a000001          BNE      |L1.1748|
                  |L1.1740|
0006cc  e3a0c000          MOV      r12,#0
0006d0  ea000001          B        |L1.1756|
                  |L1.1748|
0006d4  e082c003          ADD      r12,r2,r3
0006d8  e24cc001          SUB      r12,r12,#1
                  |L1.1756|
0006dc  e580c00c          STR      r12,[r0,#0xc]
;;;341        td->buff_start = td->CBP;
0006e0  e590c004          LDR      r12,[r0,#4]
0006e4  e580c020          STR      r12,[r0,#0x20]
;;;342        // TD_debug("TD [0x%x]: 0x%x, 0x%x, 0x%x\n", (int)td, td->Info, td->CBP, td->BE);
;;;343    }
0006e8  e12fff1e          BX       lr
;;;344    
                          ENDP

                  ohci_ctrl_xfer PROC
;;;345    static int ohci_ctrl_xfer(UTR_T *utr)
0006ec  e92d47f0          PUSH     {r4-r10,lr}
;;;346    {
0006f0  e1a04000          MOV      r4,r0
;;;347        UDEV_T  *udev;
;;;348        ED_T    *ed;
;;;349        TD_T    *td_setup, *td_data, *td_status;
;;;350        uint32_t  info;
;;;351    
;;;352        udev = utr->udev;
0006f4  e5949000          LDR      r9,[r4,#0]
;;;353    
;;;354        /*------------------------------------------------------------------------------------*/
;;;355        /*  Allocate ED and TDs                                                               */
;;;356        /*------------------------------------------------------------------------------------*/
;;;357        td_setup = alloc_ohci_TD(utr);
0006f8  e1a00004          MOV      r0,r4
0006fc  ebfffffe          BL       alloc_ohci_TD
000700  e1a08000          MOV      r8,r0
;;;358    
;;;359        if (utr->data_len > 0)
000704  e5940018          LDR      r0,[r4,#0x18]
000708  e3500000          CMP      r0,#0
00070c  0a000003          BEQ      |L1.1824|
;;;360            td_data = alloc_ohci_TD(utr);
000710  e1a00004          MOV      r0,r4
000714  ebfffffe          BL       alloc_ohci_TD
000718  e1a07000          MOV      r7,r0
00071c  ea000000          B        |L1.1828|
                  |L1.1824|
;;;361        else
;;;362            td_data = NULL;
000720  e3a07000          MOV      r7,#0
                  |L1.1828|
;;;363    
;;;364        td_status = alloc_ohci_TD(utr);
000724  e1a00004          MOV      r0,r4
000728  ebfffffe          BL       alloc_ohci_TD
00072c  e1a06000          MOV      r6,r0
;;;365    
;;;366        if (td_status == NULL)
000730  e3560000          CMP      r6,#0
000734  1a000008          BNE      |L1.1884|
;;;367        {
;;;368            free_ohci_TD(td_setup);
000738  e1a00008          MOV      r0,r8
00073c  ebfffffe          BL       free_ohci_TD
;;;369            if (utr->data_len > 0)
000740  e5940018          LDR      r0,[r4,#0x18]
000744  e3500000          CMP      r0,#0
000748  0a000001          BEQ      |L1.1876|
;;;370                free_ohci_TD(td_data);
00074c  e1a00007          MOV      r0,r7
000750  ebfffffe          BL       free_ohci_TD
                  |L1.1876|
;;;371            return USBH_ERR_MEMORY_OUT;
000754  e3e00009          MVN      r0,#9
                  |L1.1880|
;;;372        }
;;;373    
;;;374        /* Check if there's any transfer pending on this endpoint... */
;;;375        if (udev->ep0.hw_pipe == NULL)
;;;376        {
;;;377            ed = alloc_ohci_ED();
;;;378            if (ed == NULL)
;;;379            {
;;;380                free_ohci_TD(td_setup);
;;;381                free_ohci_TD(td_status);
;;;382                if (utr->data_len > 0)
;;;383                    free_ohci_TD(td_data);
;;;384                return USBH_ERR_MEMORY_OUT;
;;;385            }
;;;386        }
;;;387        else
;;;388            ed = (ED_T *)udev->ep0.hw_pipe;
;;;389    
;;;390        /*------------------------------------------------------------------------------------*/
;;;391        /* prepare SETUP stage TD                                                             */
;;;392        /*------------------------------------------------------------------------------------*/
;;;393        info = TD_CC | TD_T_DATA0 | TD_TYPE_CTRL;
;;;394        write_td(td_setup, info, (uint8_t *)&utr->setup, 8);
;;;395        td_setup->ed = ed;
;;;396    
;;;397        /*------------------------------------------------------------------------------------*/
;;;398        /* prepare DATA stage TD                                                              */
;;;399        /*------------------------------------------------------------------------------------*/
;;;400        if (utr->data_len > 0)
;;;401        {
;;;402            if ((utr->setup.bmRequestType & 0x80) == REQ_TYPE_OUT)
;;;403                info = (TD_CC | TD_R | TD_DP_OUT | TD_T_DATA1 | TD_TYPE_CTRL | TD_CTRL_DATA);
;;;404            else
;;;405                info = (TD_CC | TD_R | TD_DP_IN | TD_T_DATA1 | TD_TYPE_CTRL | TD_CTRL_DATA);
;;;406    
;;;407            write_td(td_data, info, utr->buff, utr->data_len);
;;;408            td_data->ed = ed;
;;;409            td_setup->NextTD = (uint32_t)td_data;
;;;410            td_setup->next   = td_data;
;;;411            td_data->NextTD  = (uint32_t)td_status;
;;;412            td_data->next    = td_status;
;;;413        }
;;;414        else
;;;415        {
;;;416            td_setup->NextTD = (uint32_t)td_status;
;;;417            td_setup->next = td_status;
;;;418        }
;;;419    
;;;420        /*------------------------------------------------------------------------------------*/
;;;421        /* prepare STATUS stage TD                                                            */
;;;422        /*------------------------------------------------------------------------------------*/
;;;423        ed->Info = ed_make_info(udev, NULL);
;;;424        if ((utr->setup.bmRequestType & 0x80) == REQ_TYPE_OUT)
;;;425            info = (TD_CC | TD_DP_IN | TD_T_DATA1 | TD_TYPE_CTRL);
;;;426        else
;;;427            info = (TD_CC | TD_DP_OUT | TD_T_DATA1 | TD_TYPE_CTRL);
;;;428    
;;;429        write_td(td_status, info, NULL, 0);
;;;430        td_status->ed = ed;
;;;431        td_status->NextTD = 0;
;;;432        td_status->next = 0;
;;;433    
;;;434        /*------------------------------------------------------------------------------------*/
;;;435        /* prepare ED                                                                         */
;;;436        /*------------------------------------------------------------------------------------*/
;;;437        ed->TailP = 0;
;;;438        ed->HeadP = (uint32_t)td_setup;
;;;439        ed->Info = ed_make_info(udev, NULL);
;;;440        ed->NextED = 0;
;;;441    
;;;442        //TD_debug("TD SETUP [0x%x]: 0x%x, 0x%x, 0x%x, 0x%x\n", (int)td_setup, td_setup->Info, td_setup->CBP, td_setup->BE, td_setup->NextTD);
;;;443        //if (td_data)
;;;444        //    TD_debug("TD DATA  [0x%x]: 0x%x, 0x%x, 0x%x, 0x%x\n", (int)td_data, td_data->Info, td_data->CBP, td_data->BE, td_data->NextTD);
;;;445        //TD_debug("TD STATUS [0x%x]: 0x%x, 0x%x, 0x%x, 0x%x\n", (int)td_status, td_status->Info, td_status->CBP, td_status->BE, td_status->NextTD);
;;;446        ED_debug("Xfer ED 0x%x: 0x%x 0x%x 0x%x 0x%x\n", (int)ed, ed->Info, ed->TailP, ed->HeadP, ed->NextED);
;;;447    
;;;448        if (utr->data_len > 0)
;;;449            utr->td_cnt = 3;
;;;450        else
;;;451            utr->td_cnt = 2;
;;;452    
;;;453        utr->ep = &udev->ep0;                   /* driver can find EP from UTR                */
;;;454        udev->ep0.hw_pipe = (void *)ed;         /* driver can find ED from EP                 */
;;;455    
;;;456        /*------------------------------------------------------------------------------------*/
;;;457        /*  Start transfer                                                                    */
;;;458        /*------------------------------------------------------------------------------------*/
;;;459        DISABLE_OHCI_IRQ();
;;;460        _ohci->HcControlHeadED = (uint32_t)ed;                   /* Link ED to OHCI           */
;;;461        _ohci->HcControl |= USBH_HcControl_CLE_Msk;              /* enable control list       */
;;;462        ENABLE_OHCI_IRQ();
;;;463        _ohci->HcCommandStatus = USBH_HcCommandStatus_CLF_Msk;   /* start Control list        */
;;;464    
;;;465        return 0;
;;;466    }
000758  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1884|
00075c  e5990028          LDR      r0,[r9,#0x28]         ;375
000760  e3500000          CMP      r0,#0                 ;375
000764  1a00000e          BNE      |L1.1956|
000768  ebfffffe          BL       alloc_ohci_ED
00076c  e1a05000          MOV      r5,r0                 ;377
000770  e3550000          CMP      r5,#0                 ;378
000774  1a00000b          BNE      |L1.1960|
000778  e1a00008          MOV      r0,r8                 ;380
00077c  ebfffffe          BL       free_ohci_TD
000780  e1a00006          MOV      r0,r6                 ;381
000784  ebfffffe          BL       free_ohci_TD
000788  e5940018          LDR      r0,[r4,#0x18]         ;382
00078c  e3500000          CMP      r0,#0                 ;382
000790  0a000001          BEQ      |L1.1948|
000794  e1a00007          MOV      r0,r7                 ;383
000798  ebfffffe          BL       free_ohci_TD
                  |L1.1948|
00079c  e3e00009          MVN      r0,#9                 ;384
0007a0  eaffffec          B        |L1.1880|
                  |L1.1956|
0007a4  e5995028          LDR      r5,[r9,#0x28]         ;388
                  |L1.1960|
0007a8  e3a0a4f2          MOV      r10,#0xf2000000       ;393
0007ac  e3a03008          MOV      r3,#8                 ;394
0007b0  e2842004          ADD      r2,r4,#4              ;394
0007b4  e1a0100a          MOV      r1,r10                ;394
0007b8  e1a00008          MOV      r0,r8                 ;394
0007bc  ebfffffe          BL       write_td
0007c0  e5885024          STR      r5,[r8,#0x24]         ;395
0007c4  e5940018          LDR      r0,[r4,#0x18]         ;400
0007c8  e3500000          CMP      r0,#0                 ;400
0007cc  0a000010          BEQ      |L1.2068|
0007d0  e5d40004          LDRB     r0,[r4,#4]            ;402
0007d4  e3100080          TST      r0,#0x80              ;402
0007d8  1a000001          BNE      |L1.2020|
0007dc  e59fabd8          LDR      r10,|L1.5052|
0007e0  ea000000          B        |L1.2024|
                  |L1.2020|
0007e4  e59fabd4          LDR      r10,|L1.5056|
                  |L1.2024|
0007e8  e1a0100a          MOV      r1,r10                ;407
0007ec  e1a00007          MOV      r0,r7                 ;407
0007f0  e5942010          LDR      r2,[r4,#0x10]         ;407
0007f4  e5943018          LDR      r3,[r4,#0x18]         ;407
0007f8  ebfffffe          BL       write_td
0007fc  e5875024          STR      r5,[r7,#0x24]         ;408
000800  e5887008          STR      r7,[r8,#8]            ;409
000804  e588702c          STR      r7,[r8,#0x2c]         ;410
000808  e5876008          STR      r6,[r7,#8]            ;411
00080c  e587602c          STR      r6,[r7,#0x2c]         ;412
000810  ea000001          B        |L1.2076|
                  |L1.2068|
000814  e5886008          STR      r6,[r8,#8]            ;416
000818  e588602c          STR      r6,[r8,#0x2c]         ;417
                  |L1.2076|
00081c  e3a01000          MOV      r1,#0                 ;423
000820  e1a00009          MOV      r0,r9                 ;423
000824  ebfffffe          BL       ed_make_info
000828  e5850000          STR      r0,[r5,#0]            ;423
00082c  e5d40004          LDRB     r0,[r4,#4]            ;424
000830  e3100080          TST      r0,#0x80              ;424
000834  1a000001          BNE      |L1.2112|
000838  e59fab84          LDR      r10,|L1.5060|
00083c  ea000000          B        |L1.2116|
                  |L1.2112|
000840  e59fab80          LDR      r10,|L1.5064|
                  |L1.2116|
000844  e3a03000          MOV      r3,#0                 ;429
000848  e1a02003          MOV      r2,r3                 ;429
00084c  e1a0100a          MOV      r1,r10                ;429
000850  e1a00006          MOV      r0,r6                 ;429
000854  ebfffffe          BL       write_td
000858  e5865024          STR      r5,[r6,#0x24]         ;430
00085c  e3a00000          MOV      r0,#0                 ;431
000860  e5860008          STR      r0,[r6,#8]            ;431
000864  e586002c          STR      r0,[r6,#0x2c]         ;432
000868  e5850004          STR      r0,[r5,#4]            ;437
00086c  e5858008          STR      r8,[r5,#8]            ;438
000870  e3a01000          MOV      r1,#0                 ;439
000874  e1a00009          MOV      r0,r9                 ;439
000878  ebfffffe          BL       ed_make_info
00087c  e5850000          STR      r0,[r5,#0]            ;439
000880  e3a00000          MOV      r0,#0                 ;440
000884  e585000c          STR      r0,[r5,#0xc]          ;440
000888  e5940018          LDR      r0,[r4,#0x18]         ;448
00088c  e3500000          CMP      r0,#0                 ;448
000890  0a000002          BEQ      |L1.2208|
000894  e3a00003          MOV      r0,#3                 ;449
000898  e5840074          STR      r0,[r4,#0x74]         ;449
00089c  ea000001          B        |L1.2216|
                  |L1.2208|
0008a0  e3a00002          MOV      r0,#2                 ;451
0008a4  e5840074          STR      r0,[r4,#0x74]         ;451
                  |L1.2216|
0008a8  e2890020          ADD      r0,r9,#0x20           ;453
0008ac  e584000c          STR      r0,[r4,#0xc]          ;453
0008b0  e5895028          STR      r5,[r9,#0x28]         ;454
0008b4  e3a00018          MOV      r0,#0x18              ;459
0008b8  ebfffffe          BL       sysDisableInterrupt
0008bc  e51f051c          LDR      r0,|L1.936|
0008c0  e5900000          LDR      r0,[r0,#0]            ;460  ; _ohci
0008c4  e5805020          STR      r5,[r0,#0x20]         ;460
0008c8  e51f0528          LDR      r0,|L1.936|
0008cc  e5900000          LDR      r0,[r0,#0]            ;461  ; _ohci
0008d0  e5900004          LDR      r0,[r0,#4]            ;461
0008d4  e3800010          ORR      r0,r0,#0x10           ;461
0008d8  e51f1538          LDR      r1,|L1.936|
0008dc  e5911000          LDR      r1,[r1,#0]            ;461  ; _ohci
0008e0  e5810004          STR      r0,[r1,#4]            ;461
0008e4  e3a00018          MOV      r0,#0x18              ;462
0008e8  ebfffffe          BL       sysEnableInterrupt
0008ec  e3a00002          MOV      r0,#2                 ;463
0008f0  e51f1550          LDR      r1,|L1.936|
0008f4  e5911000          LDR      r1,[r1,#0]            ;463  ; _ohci
0008f8  e5810008          STR      r0,[r1,#8]            ;463
0008fc  e3a00000          MOV      r0,#0                 ;465
000900  eaffff94          B        |L1.1880|
;;;467    
                          ENDP

                  ohci_bulk_xfer PROC
;;;468    static int ohci_bulk_xfer(UTR_T *utr)
000904  e92d5fff          PUSH     {r0-r12,lr}
;;;469    {
000908  e1a05000          MOV      r5,r0
;;;470        UDEV_T     *udev = utr->udev;
00090c  e5950000          LDR      r0,[r5,#0]
000910  e58d000c          STR      r0,[sp,#0xc]
;;;471        EP_INFO_T  *ep = utr->ep;
000914  e595a00c          LDR      r10,[r5,#0xc]
;;;472        ED_T       *ed;
;;;473        TD_T       *td, *td_p, *td_list = NULL;
000918  e3a07000          MOV      r7,#0
;;;474        uint32_t   info;
;;;475        uint32_t   data_len, xfer_len;
;;;476        int8_t     bIsNewED = 0;
00091c  e3a00000          MOV      r0,#0
000920  e58d0004          STR      r0,[sp,#4]
;;;477        uint8_t    *buff;
;;;478    
;;;479        /*------------------------------------------------------------------------------------*/
;;;480        /*  Check if there's uncompleted transfer on this endpoint...                         */
;;;481        /*  Prepare ED                                                                        */
;;;482        /*------------------------------------------------------------------------------------*/
;;;483        info = ed_make_info(udev, ep);
000924  e1a0100a          MOV      r1,r10
000928  e59d000c          LDR      r0,[sp,#0xc]
00092c  ebfffffe          BL       ed_make_info
000930  e1a09000          MOV      r9,r0
;;;484    
;;;485        /* Check if there's any transfer pending on this endpoint... */
;;;486        ed = (ED_T *)_ohci->HcBulkHeadED;       /* get the head of bulk endpoint list         */
000934  e51f0594          LDR      r0,|L1.936|
000938  e5900000          LDR      r0,[r0,#0]  ; _ohci
00093c  e5904028          LDR      r4,[r0,#0x28]
;;;487        while (ed != NULL)
000940  ea00000d          B        |L1.2428|
                  |L1.2372|
;;;488        {
;;;489            if (ed->Info == info)               /* have transfer of this EP not completed?    */
000944  e5940000          LDR      r0,[r4,#0]
000948  e1500009          CMP      r0,r9
00094c  1a000009          BNE      |L1.2424|
;;;490            {
;;;491                if ((ed->HeadP & 0xFFFFFFF0) != (ed->TailP & 0xFFFFFFF0))
000950  e5940008          LDR      r0,[r4,#8]
000954  e3c0000f          BIC      r0,r0,#0xf
000958  e5941004          LDR      r1,[r4,#4]
00095c  e3c1100f          BIC      r1,r1,#0xf
000960  e1500001          CMP      r0,r1
000964  0a000002          BEQ      |L1.2420|
;;;492                    return USBH_ERR_OHCI_EP_BUSY;     /* endpoint is busy                     */
000968  e59f0a5c          LDR      r0,|L1.5068|
                  |L1.2412|
00096c  e28dd010          ADD      sp,sp,#0x10
;;;493                else
;;;494                    break;                      /* ED already there...                        */
;;;495            }
;;;496            ed = (ED_T *)ed->NextED;
;;;497        }
;;;498    
;;;499        if (ed == NULL)
;;;500        {
;;;501            bIsNewED = 1;
;;;502            ed = alloc_ohci_ED();               /* allocate an Endpoint Descriptor            */
;;;503            if (ed == NULL)
;;;504                return USBH_ERR_MEMORY_OUT;
;;;505            ed->Info = info;
;;;506            ed->HeadP = 0;
;;;507            ED_debug("Link BULK ED 0x%x: 0x%x 0x%x 0x%x 0x%x\n", (int)ed, ed->Info, ed->TailP, ed->HeadP, ed->NextED);
;;;508        }
;;;509    
;;;510        ep->hw_pipe = (void *)ed;
;;;511    
;;;512        /*------------------------------------------------------------------------------------*/
;;;513        /*  Prepare TDs                                                                       */
;;;514        /*------------------------------------------------------------------------------------*/
;;;515        utr->td_cnt = 0;
;;;516        data_len = utr->data_len;
;;;517        buff = utr->buff;
;;;518    
;;;519        do
;;;520        {
;;;521            if ((ep->bEndpointAddress & EP_ADDR_DIR_MASK) == EP_ADDR_DIR_OUT)
;;;522                info = (TD_CC | TD_R | TD_DP_OUT | TD_TYPE_BULK);
;;;523            else
;;;524                info = (TD_CC | TD_R | TD_DP_IN | TD_TYPE_BULK);
;;;525    
;;;526            info &= ~(1 << 25);                 /* Data toggle from ED toggleCarry bit        */
;;;527    
;;;528            if (data_len > 4096)                /* maximum transfer length is 4K for each TD  */
;;;529                xfer_len = 4096;
;;;530            else
;;;531                xfer_len = data_len;            /* remaining data length < 4K                 */
;;;532    
;;;533            td = alloc_ohci_TD(utr);            /* allocate a TD                              */
;;;534            if (td == NULL)
;;;535                goto mem_out;
;;;536            /* fill this TD                               */
;;;537            write_td(td, info, buff, xfer_len);
;;;538            td->ed = ed;
;;;539    
;;;540            utr->td_cnt++;                      /* increase TD count, for recalim counter     */
;;;541    
;;;542            buff += xfer_len;                   /* advanced buffer pointer                    */
;;;543            data_len -= xfer_len;
;;;544    
;;;545            /* chain to end of TD list */
;;;546            if (td_list == NULL)
;;;547            {
;;;548                td_list = td;
;;;549            }
;;;550            else
;;;551            {
;;;552                td_p = td_list;
;;;553                while (td_p->NextTD != 0)
;;;554                    td_p = (TD_T *)td_p->NextTD;
;;;555                td_p->NextTD = (uint32_t)td;
;;;556            }
;;;557    
;;;558        }
;;;559        while (data_len > 0);
;;;560    
;;;561        /*------------------------------------------------------------------------------------*/
;;;562        /*  Start transfer                                                                    */
;;;563        /*------------------------------------------------------------------------------------*/
;;;564        utr->status = 0;
;;;565        DISABLE_OHCI_IRQ();
;;;566        ed->HeadP = (ed->HeadP & 0x2) | (uint32_t)td_list;       /* keep toggleCarry bit      */
;;;567        if (bIsNewED)
;;;568        {
;;;569            ed->HeadP = (uint32_t)td_list;
;;;570            /* Link ED to OHCI Bulk List */
;;;571            ed->NextED = _ohci->HcBulkHeadED;
;;;572            _ohci->HcBulkHeadED = (uint32_t)ed;
;;;573        }
;;;574        ENABLE_OHCI_IRQ();
;;;575        _ohci->HcControl |= USBH_HcControl_BLE_Msk;              /* enable bulk list          */
;;;576        _ohci->HcCommandStatus = USBH_HcCommandStatus_BLF_Msk;   /* start bulk list           */
;;;577    
;;;578        return 0;
;;;579    
;;;580    mem_out:
;;;581        while (td_list != NULL)
;;;582        {
;;;583            td = td_list;
;;;584            td_list = (TD_T *)td_list->NextTD;
;;;585            free_ohci_TD(td);
;;;586        }
;;;587        free_ohci_ED(ed);
;;;588        return USBH_ERR_MEMORY_OUT;
;;;589    }
000970  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2420|
000974  ea000002          B        |L1.2436|
                  |L1.2424|
000978  e594400c          LDR      r4,[r4,#0xc]          ;496
                  |L1.2428|
00097c  e3540000          CMP      r4,#0                 ;487
000980  1affffef          BNE      |L1.2372|
                  |L1.2436|
000984  e1a00000          MOV      r0,r0                 ;494
000988  e3540000          CMP      r4,#0                 ;499
00098c  1a00000a          BNE      |L1.2492|
000990  e3a00001          MOV      r0,#1                 ;501
000994  e58d0004          STR      r0,[sp,#4]            ;501
000998  ebfffffe          BL       alloc_ohci_ED
00099c  e1a04000          MOV      r4,r0                 ;502
0009a0  e3540000          CMP      r4,#0                 ;503
0009a4  1a000001          BNE      |L1.2480|
0009a8  e3e00009          MVN      r0,#9                 ;504
0009ac  eaffffee          B        |L1.2412|
                  |L1.2480|
0009b0  e5849000          STR      r9,[r4,#0]            ;505
0009b4  e3a00000          MOV      r0,#0                 ;506
0009b8  e5840008          STR      r0,[r4,#8]            ;506
                  |L1.2492|
0009bc  e58a4008          STR      r4,[r10,#8]           ;510
0009c0  e3a00000          MOV      r0,#0                 ;515
0009c4  e5850074          STR      r0,[r5,#0x74]         ;515
0009c8  e5958018          LDR      r8,[r5,#0x18]         ;516
0009cc  e5950010          LDR      r0,[r5,#0x10]         ;517
0009d0  e58d0000          STR      r0,[sp,#0]            ;517
0009d4  e1a00000          MOV      r0,r0                 ;519
                  |L1.2520|
0009d8  e5da0000          LDRB     r0,[r10,#0]           ;521
0009dc  e3100080          TST      r0,#0x80              ;521
0009e0  1a000001          BNE      |L1.2540|
0009e4  e59f99e4          LDR      r9,|L1.5072|
0009e8  ea000000          B        |L1.2544|
                  |L1.2540|
0009ec  e59f99e0          LDR      r9,|L1.5076|
                  |L1.2544|
0009f0  e3c99402          BIC      r9,r9,#0x2000000      ;526
0009f4  e3580a01          CMP      r8,#0x1000            ;528
0009f8  9a000002          BLS      |L1.2568|
0009fc  e3a00a01          MOV      r0,#0x1000            ;529
000a00  e58d0008          STR      r0,[sp,#8]            ;529
000a04  ea000000          B        |L1.2572|
                  |L1.2568|
000a08  e58d8008          STR      r8,[sp,#8]            ;531
                  |L1.2572|
000a0c  e1a00005          MOV      r0,r5                 ;533
000a10  ebfffffe          BL       alloc_ohci_TD
000a14  e1a06000          MOV      r6,r0                 ;533
000a18  e3560000          CMP      r6,#0                 ;534
000a1c  1a000000          BNE      |L1.2596|
000a20  ea00003d          B        |L1.2844|
                  |L1.2596|
000a24  e1a01009          MOV      r1,r9                 ;537
000a28  e1a00006          MOV      r0,r6                 ;537
000a2c  e59d2000          LDR      r2,[sp,#0]            ;537
000a30  e59d3008          LDR      r3,[sp,#8]            ;537
000a34  ebfffffe          BL       write_td
000a38  e5864024          STR      r4,[r6,#0x24]         ;538
000a3c  e5950074          LDR      r0,[r5,#0x74]         ;540
000a40  e2800001          ADD      r0,r0,#1              ;540
000a44  e5850074          STR      r0,[r5,#0x74]         ;540
000a48  e59d0000          LDR      r0,[sp,#0]            ;542
000a4c  e59d1008          LDR      r1,[sp,#8]            ;542
000a50  e0800001          ADD      r0,r0,r1              ;542
000a54  e58d0000          STR      r0,[sp,#0]            ;542
000a58  e59d0008          LDR      r0,[sp,#8]            ;543
000a5c  e0488000          SUB      r8,r8,r0              ;543
000a60  e3570000          CMP      r7,#0                 ;546
000a64  1a000001          BNE      |L1.2672|
000a68  e1a07006          MOV      r7,r6                 ;548
000a6c  ea000006          B        |L1.2700|
                  |L1.2672|
000a70  e1a0b007          MOV      r11,r7                ;552
000a74  ea000000          B        |L1.2684|
                  |L1.2680|
000a78  e59bb008          LDR      r11,[r11,#8]          ;554
                  |L1.2684|
000a7c  e59b0008          LDR      r0,[r11,#8]           ;553
000a80  e3500000          CMP      r0,#0                 ;553
000a84  1afffffb          BNE      |L1.2680|
000a88  e58b6008          STR      r6,[r11,#8]           ;555
                  |L1.2700|
000a8c  e3580000          CMP      r8,#0                 ;559
000a90  1affffd0          BNE      |L1.2520|
000a94  e3a00000          MOV      r0,#0                 ;564
000a98  e5850078          STR      r0,[r5,#0x78]         ;564
000a9c  e3a00018          MOV      r0,#0x18              ;565
000aa0  ebfffffe          BL       sysDisableInterrupt
000aa4  e5d40008          LDRB     r0,[r4,#8]            ;566
000aa8  e2000002          AND      r0,r0,#2              ;566
000aac  e1800007          ORR      r0,r0,r7              ;566
000ab0  e5840008          STR      r0,[r4,#8]            ;566
000ab4  e59d0004          LDR      r0,[sp,#4]            ;567
000ab8  e3500000          CMP      r0,#0                 ;567
000abc  0a000007          BEQ      |L1.2784|
000ac0  e5847008          STR      r7,[r4,#8]            ;569
000ac4  e51f0724          LDR      r0,|L1.936|
000ac8  e5900000          LDR      r0,[r0,#0]            ;571  ; _ohci
000acc  e5900028          LDR      r0,[r0,#0x28]         ;571
000ad0  e584000c          STR      r0,[r4,#0xc]          ;571
000ad4  e51f0734          LDR      r0,|L1.936|
000ad8  e5900000          LDR      r0,[r0,#0]            ;572  ; _ohci
000adc  e5804028          STR      r4,[r0,#0x28]         ;572
                  |L1.2784|
000ae0  e3a00018          MOV      r0,#0x18              ;574
000ae4  ebfffffe          BL       sysEnableInterrupt
000ae8  e51f0748          LDR      r0,|L1.936|
000aec  e5900000          LDR      r0,[r0,#0]            ;575  ; _ohci
000af0  e5900004          LDR      r0,[r0,#4]            ;575
000af4  e3800020          ORR      r0,r0,#0x20           ;575
000af8  e51f1758          LDR      r1,|L1.936|
000afc  e5911000          LDR      r1,[r1,#0]            ;575  ; _ohci
000b00  e5810004          STR      r0,[r1,#4]            ;575
000b04  e3a00004          MOV      r0,#4                 ;576
000b08  e51f1768          LDR      r1,|L1.936|
000b0c  e5911000          LDR      r1,[r1,#0]            ;576  ; _ohci
000b10  e5810008          STR      r0,[r1,#8]            ;576
000b14  e3a00000          MOV      r0,#0                 ;578
000b18  eaffff93          B        |L1.2412|
                  |L1.2844|
000b1c  e1a00000          MOV      r0,r0                 ;580
000b20  ea000003          B        |L1.2868|
                  |L1.2852|
000b24  e1a06007          MOV      r6,r7                 ;583
000b28  e5977008          LDR      r7,[r7,#8]            ;584
000b2c  e1a00006          MOV      r0,r6                 ;585
000b30  ebfffffe          BL       free_ohci_TD
                  |L1.2868|
000b34  e3570000          CMP      r7,#0                 ;581
000b38  1afffff9          BNE      |L1.2852|
000b3c  e1a00004          MOV      r0,r4                 ;587
000b40  ebfffffe          BL       free_ohci_ED
000b44  e3e00009          MVN      r0,#9                 ;588
000b48  eaffff87          B        |L1.2412|
;;;590    
                          ENDP

                  ohci_int_xfer PROC
;;;591    static int ohci_int_xfer(UTR_T *utr)
000b4c  e92d4ff8          PUSH     {r3-r11,lr}
;;;592    {
000b50  e1a05000          MOV      r5,r0
;;;593        UDEV_T     *udev = utr->udev;
000b54  e5950000          LDR      r0,[r5,#0]
000b58  e58d0000          STR      r0,[sp,#0]
;;;594        EP_INFO_T  *ep = utr->ep;
000b5c  e595800c          LDR      r8,[r5,#0xc]
;;;595        ED_T       *ed, *ied;
;;;596        TD_T       *td, *td_new;
;;;597        uint32_t   info;
;;;598        int8_t     bIsNewED = 0;
000b60  e3a0b000          MOV      r11,#0
;;;599    
;;;600        if (utr->data_len > 64)             /* USB 1.1 interrupt transfer maximum packet size is 64 */
000b64  e5950018          LDR      r0,[r5,#0x18]
000b68  e3500040          CMP      r0,#0x40
000b6c  9a000001          BLS      |L1.2936|
;;;601            return USBH_ERR_INVALID_PARAM;
000b70  e3e00068          MVN      r0,#0x68
                  |L1.2932|
;;;602    
;;;603        td_new = alloc_ohci_TD(utr);        /* allocate a TD for dummy TD                     */
;;;604        if (td_new == NULL)
;;;605            return USBH_ERR_MEMORY_OUT;
;;;606    
;;;607        ied = get_int_tree_head_node(ep->bInterval);  /* get head node of this interval       */
;;;608    
;;;609        /*------------------------------------------------------------------------------------*/
;;;610        /*  Find if this ED was already in the list                                           */
;;;611        /*------------------------------------------------------------------------------------*/
;;;612        info = ed_make_info(udev, ep);
;;;613        ed = ied;
;;;614        while (ed != NULL)
;;;615        {
;;;616            if (ed->Info == info)
;;;617                break;                          /* Endpoint found                             */
;;;618            ed = (ED_T *)ed->NextED;
;;;619        }
;;;620    
;;;621        if (ed == NULL)                         /* ED not found, create it                    */
;;;622        {
;;;623            bIsNewED = 1;
;;;624            ed = alloc_ohci_ED();               /* allocate an Endpoint Descriptor            */
;;;625            if (ed == NULL)
;;;626                return USBH_ERR_MEMORY_OUT;
;;;627            ed->Info = info;
;;;628            ed->HeadP = 0;
;;;629            ed->bInterval = ep->bInterval;
;;;630    
;;;631            td = alloc_ohci_TD(NULL);           /* allocate the initial  dummy TD for ED      */
;;;632            if (td == NULL)
;;;633            {
;;;634                free_ohci_ED(ed);
;;;635                free_ohci_TD(td_new);
;;;636                return USBH_ERR_MEMORY_OUT;
;;;637            }
;;;638            ed->HeadP = (uint32_t)td;           /* Let both HeadP and TailP point to dummy TD */
;;;639            ed->TailP = ed->HeadP;
;;;640        }
;;;641        else
;;;642        {
;;;643            td = (TD_T *)(ed->TailP & ~0xf);    /* TailP always point to the dummy TD         */
;;;644        }
;;;645        ep->hw_pipe = (void *)ed;
;;;646    
;;;647        /*------------------------------------------------------------------------------------*/
;;;648        /*  Prepare TD                                                                        */
;;;649        /*------------------------------------------------------------------------------------*/
;;;650        if ((ep->bEndpointAddress & EP_ADDR_DIR_MASK) == EP_ADDR_DIR_OUT)
;;;651            info = (TD_CC | TD_R | TD_DP_OUT | TD_TYPE_INT);
;;;652        else
;;;653            info = (TD_CC | TD_R | TD_DP_IN | TD_TYPE_INT);
;;;654    
;;;655        /* Keep data toggle                               */
;;;656        info = (info & ~(1<<25)) | (td->Info & (1<<25));
;;;657    
;;;658        /* fill this TD                                   */
;;;659        write_td(td, info, utr->buff, utr->data_len);
;;;660        td->ed = ed;
;;;661        td->NextTD = (uint32_t)td_new;
;;;662        td->utr = utr;
;;;663        utr->td_cnt = 1;                    /* increase TD count, for recalim counter     */
;;;664        utr->status = 0;
;;;665    
;;;666        /*------------------------------------------------------------------------------------*/
;;;667        /*  Hook ED and TD list to HCCA interrupt table                                       */
;;;668        /*------------------------------------------------------------------------------------*/
;;;669        DISABLE_OHCI_IRQ();
;;;670    
;;;671        ed->TailP = (uint32_t)td_new;
;;;672        if (bIsNewED)
;;;673        {
;;;674            /* Add to list of the same interval */
;;;675            ed->NextED = ied->NextED;
;;;676            ied->NextED = (uint32_t)ed;
;;;677        }
;;;678    
;;;679        ENABLE_OHCI_IRQ();
;;;680    
;;;681        //printf("Link INT ED 0x%x: 0x%x 0x%x 0x%x 0x%x\n", (int)ed, ed->Info, ed->TailP, ed->HeadP, ed->NextED);
;;;682    
;;;683        _ohci->HcControl |= USBH_HcControl_PLE_Msk;              /* periodic list enable      */
;;;684        return 0;
;;;685    }
000b74  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2936|
000b78  e1a00005          MOV      r0,r5                 ;603
000b7c  ebfffffe          BL       alloc_ohci_TD
000b80  e1a09000          MOV      r9,r0                 ;603
000b84  e3590000          CMP      r9,#0                 ;604
000b88  1a000001          BNE      |L1.2964|
000b8c  e3e00009          MVN      r0,#9                 ;605
000b90  eafffff7          B        |L1.2932|
                  |L1.2964|
000b94  e5d80002          LDRB     r0,[r8,#2]            ;607
000b98  ebfffffe          BL       get_int_tree_head_node
000b9c  e1a0a000          MOV      r10,r0                ;607
000ba0  e1a01008          MOV      r1,r8                 ;612
000ba4  e59d0000          LDR      r0,[sp,#0]            ;612
000ba8  ebfffffe          BL       ed_make_info
000bac  e1a07000          MOV      r7,r0                 ;612
000bb0  e1a0400a          MOV      r4,r10                ;613
000bb4  ea000004          B        |L1.3020|
                  |L1.3000|
000bb8  e5940000          LDR      r0,[r4,#0]            ;616
000bbc  e1500007          CMP      r0,r7                 ;616
000bc0  1a000000          BNE      |L1.3016|
000bc4  ea000002          B        |L1.3028|
                  |L1.3016|
000bc8  e594400c          LDR      r4,[r4,#0xc]          ;618
                  |L1.3020|
000bcc  e3540000          CMP      r4,#0                 ;614
000bd0  1afffff8          BNE      |L1.3000|
                  |L1.3028|
000bd4  e1a00000          MOV      r0,r0                 ;617
000bd8  e3540000          CMP      r4,#0                 ;621
000bdc  1a00001a          BNE      |L1.3148|
000be0  e3a0b001          MOV      r11,#1                ;623
000be4  ebfffffe          BL       alloc_ohci_ED
000be8  e1a04000          MOV      r4,r0                 ;624
000bec  e3540000          CMP      r4,#0                 ;625
000bf0  1a000001          BNE      |L1.3068|
000bf4  e3e00009          MVN      r0,#9                 ;626
000bf8  eaffffdd          B        |L1.2932|
                  |L1.3068|
000bfc  e5847000          STR      r7,[r4,#0]            ;627
000c00  e3a00000          MOV      r0,#0                 ;628
000c04  e5840008          STR      r0,[r4,#8]            ;628
000c08  e5d80002          LDRB     r0,[r8,#2]            ;629
000c0c  e5c40010          STRB     r0,[r4,#0x10]         ;629
000c10  e3a00000          MOV      r0,#0                 ;631
000c14  ebfffffe          BL       alloc_ohci_TD
000c18  e1a06000          MOV      r6,r0                 ;631
000c1c  e3560000          CMP      r6,#0                 ;632
000c20  1a000005          BNE      |L1.3132|
000c24  e1a00004          MOV      r0,r4                 ;634
000c28  ebfffffe          BL       free_ohci_ED
000c2c  e1a00009          MOV      r0,r9                 ;635
000c30  ebfffffe          BL       free_ohci_TD
000c34  e3e00009          MVN      r0,#9                 ;636
000c38  eaffffcd          B        |L1.2932|
                  |L1.3132|
000c3c  e5846008          STR      r6,[r4,#8]            ;638
000c40  e5940008          LDR      r0,[r4,#8]            ;639
000c44  e5840004          STR      r0,[r4,#4]            ;639
000c48  ea000001          B        |L1.3156|
                  |L1.3148|
000c4c  e5940004          LDR      r0,[r4,#4]            ;643
000c50  e3c0600f          BIC      r6,r0,#0xf            ;643
                  |L1.3156|
000c54  e5884008          STR      r4,[r8,#8]            ;645
000c58  e5d80000          LDRB     r0,[r8,#0]            ;650
000c5c  e3100080          TST      r0,#0x80              ;650
000c60  1a000001          BNE      |L1.3180|
000c64  e59f776c          LDR      r7,|L1.5080|
000c68  ea000000          B        |L1.3184|
                  |L1.3180|
000c6c  e59f7768          LDR      r7,|L1.5084|
                  |L1.3184|
000c70  e3c70402          BIC      r0,r7,#0x2000000      ;656
000c74  e5961000          LDR      r1,[r6,#0]            ;656
000c78  e2011402          AND      r1,r1,#0x2000000      ;656
000c7c  e1807001          ORR      r7,r0,r1              ;656
000c80  e1a01007          MOV      r1,r7                 ;659
000c84  e1a00006          MOV      r0,r6                 ;659
000c88  e5952010          LDR      r2,[r5,#0x10]         ;659
000c8c  e5953018          LDR      r3,[r5,#0x18]         ;659
000c90  ebfffffe          BL       write_td
000c94  e5864024          STR      r4,[r6,#0x24]         ;660
000c98  e5869008          STR      r9,[r6,#8]            ;661
000c9c  e5865028          STR      r5,[r6,#0x28]         ;662
000ca0  e3a00001          MOV      r0,#1                 ;663
000ca4  e5850074          STR      r0,[r5,#0x74]         ;663
000ca8  e3a00000          MOV      r0,#0                 ;664
000cac  e5850078          STR      r0,[r5,#0x78]         ;664
000cb0  e3a00018          MOV      r0,#0x18              ;669
000cb4  ebfffffe          BL       sysDisableInterrupt
000cb8  e5849004          STR      r9,[r4,#4]            ;671
000cbc  e35b0000          CMP      r11,#0                ;672
000cc0  0a000002          BEQ      |L1.3280|
000cc4  e59a000c          LDR      r0,[r10,#0xc]         ;675
000cc8  e584000c          STR      r0,[r4,#0xc]          ;675
000ccc  e58a400c          STR      r4,[r10,#0xc]         ;676
                  |L1.3280|
000cd0  e3a00018          MOV      r0,#0x18              ;679
000cd4  ebfffffe          BL       sysEnableInterrupt
000cd8  e51f0938          LDR      r0,|L1.936|
000cdc  e5900000          LDR      r0,[r0,#0]            ;683  ; _ohci
000ce0  e5900004          LDR      r0,[r0,#4]            ;683
000ce4  e3800004          ORR      r0,r0,#4              ;683
000ce8  e51f1948          LDR      r1,|L1.936|
000cec  e5911000          LDR      r1,[r1,#0]            ;683  ; _ohci
000cf0  e5810004          STR      r0,[r1,#4]            ;683
000cf4  e3a00000          MOV      r0,#0                 ;684
000cf8  eaffff9d          B        |L1.2932|
;;;686    
                          ENDP

                  ohci_iso_xfer PROC
;;;687    static int ohci_iso_xfer(UTR_T *utr)
000cfc  e92d5fff          PUSH     {r0-r12,lr}
;;;688    {
000d00  e1a06000          MOV      r6,r0
;;;689        UDEV_T     *udev = utr->udev;
000d04  e5960000          LDR      r0,[r6,#0]
000d08  e58d000c          STR      r0,[sp,#0xc]
;;;690        EP_INFO_T  *ep = utr->ep;
000d0c  e596900c          LDR      r9,[r6,#0xc]
;;;691        ED_T       *ed, *ied;
;;;692        TD_T       *td, *td_list, *last_td;
;;;693        int        i;
;;;694        uint32_t   info;
;;;695        uint32_t   buff_addr;
;;;696        int8_t     bIsNewED = 0;
000d10  e3a00000          MOV      r0,#0
000d14  e58d0000          STR      r0,[sp,#0]
;;;697    
;;;698        ied = get_int_tree_head_node(ep->bInterval);  /* get head node of this interval       */
000d18  e5d90002          LDRB     r0,[r9,#2]
000d1c  ebfffffe          BL       get_int_tree_head_node
000d20  e1a0b000          MOV      r11,r0
;;;699    
;;;700        /*------------------------------------------------------------------------------------*/
;;;701        /*  Find if this ED was already in the list                                           */
;;;702        /*------------------------------------------------------------------------------------*/
;;;703        info = ed_make_info(udev, ep);
000d24  e1a01009          MOV      r1,r9
000d28  e59d000c          LDR      r0,[sp,#0xc]
000d2c  ebfffffe          BL       ed_make_info
000d30  e58d0004          STR      r0,[sp,#4]
;;;704        ed = ied;
000d34  e1a0400b          MOV      r4,r11
;;;705        while (ed != NULL)
000d38  ea000005          B        |L1.3412|
                  |L1.3388|
;;;706        {
;;;707            if (ed->Info == info)
000d3c  e5941000          LDR      r1,[r4,#0]
000d40  e59d0004          LDR      r0,[sp,#4]
000d44  e1510000          CMP      r1,r0
000d48  1a000000          BNE      |L1.3408|
;;;708                break;                          /* Endpoint found                             */
000d4c  ea000002          B        |L1.3420|
                  |L1.3408|
;;;709            ed = (ED_T *)ed->NextED;
000d50  e594400c          LDR      r4,[r4,#0xc]
                  |L1.3412|
000d54  e3540000          CMP      r4,#0                 ;705
000d58  1afffff7          BNE      |L1.3388|
                  |L1.3420|
000d5c  e1a00000          MOV      r0,r0                 ;708
;;;710        }
;;;711    
;;;712        if (ed == NULL)                         /* ED not found, create it                    */
000d60  e3540000          CMP      r4,#0
000d64  1a00000f          BNE      |L1.3496|
;;;713        {
;;;714            bIsNewED = 1;
000d68  e3a00001          MOV      r0,#1
000d6c  e58d0000          STR      r0,[sp,#0]
;;;715            ed = alloc_ohci_ED();               /* allocate an Endpoint Descriptor            */
000d70  ebfffffe          BL       alloc_ohci_ED
000d74  e1a04000          MOV      r4,r0
;;;716            if (ed == NULL)
000d78  e3540000          CMP      r4,#0
000d7c  1a000002          BNE      |L1.3468|
;;;717                return USBH_ERR_MEMORY_OUT;
000d80  e3e00009          MVN      r0,#9
                  |L1.3460|
000d84  e28dd010          ADD      sp,sp,#0x10
;;;718            ed->Info = info;
;;;719            ed->HeadP = 0;
;;;720            ed->bInterval = ep->bInterval;
;;;721        }
;;;722        else
;;;723    
;;;724            ep->hw_pipe = (void *)ed;
;;;725    
;;;726        /*------------------------------------------------------------------------------------*/
;;;727        /*  Prepare TDs                                                                       */
;;;728        /*------------------------------------------------------------------------------------*/
;;;729        if (utr->bIsoNewSched)                   /* Is the starting of isochronous streaming?  */
;;;730            ed->next_sf = _hcca->frame_no + OHCI_ISO_DELAY;
;;;731    
;;;732        utr->td_cnt = 0;
;;;733        utr->iso_sf = ed->next_sf;
;;;734    
;;;735        last_td = NULL;
;;;736        td_list = NULL;
;;;737    
;;;738        for (i = 0; i < IF_PER_UTR; i++)
;;;739        {
;;;740            utr->iso_status[i] = USBH_ERR_NOT_ACCESS1;
;;;741    
;;;742            td = alloc_ohci_TD(utr);            /* allocate a TD                              */
;;;743            if (td == NULL)
;;;744                goto mem_out;
;;;745            /* fill this TD                               */
;;;746            buff_addr = (uint32_t)(utr->iso_buff[i]);
;;;747            td->Info = (TD_CC | TD_TYPE_ISO) | ed->next_sf;
;;;748            ed->next_sf += get_ohci_interval(ed->bInterval);
;;;749            td->CBP  = buff_addr & ~0xFFF;
;;;750            td->BE   = buff_addr + utr->iso_xlen[i] - 1;
;;;751            td->PSW[0] = 0xE000 | (buff_addr & 0xFFF);
;;;752    
;;;753            td->ed = ed;
;;;754            utr->td_cnt++;                      /* increase TD count, for recalim counter     */
;;;755    
;;;756            /* chain to end of TD list */
;;;757            if (td_list == NULL)
;;;758                td_list = td;
;;;759            else
;;;760                last_td->NextTD = (uint32_t)td;
;;;761    
;;;762            last_td = td;
;;;763        };
;;;764    
;;;765        /*------------------------------------------------------------------------------------*/
;;;766        /*  Hook ED and TD list to HCCA interrupt table                                       */
;;;767        /*------------------------------------------------------------------------------------*/
;;;768        utr->status = 0;
;;;769        DISABLE_OHCI_IRQ();
;;;770    
;;;771        if ((ed->HeadP & ~0x3) == 0)
;;;772            ed->HeadP = (ed->HeadP & 0x2) | (uint32_t)td_list;   /* keep toggleCarry bit      */
;;;773        else
;;;774        {
;;;775            /* find the tail of TDs under this ED */
;;;776            td = (TD_T *)(ed->HeadP & ~0x3);
;;;777            while (td->NextTD != 0)
;;;778            {
;;;779                td = (TD_T *)td->NextTD;
;;;780            }
;;;781            td->NextTD = (uint32_t)td_list;
;;;782        }
;;;783    
;;;784        if (bIsNewED)
;;;785        {
;;;786            /* Add to list of the same interval */
;;;787            ed->NextED = ied->NextED;
;;;788            ied->NextED = (uint32_t)ed;
;;;789        }
;;;790    
;;;791        ENABLE_OHCI_IRQ();
;;;792        ED_debug("Link ISO ED 0x%x: 0x%x 0x%x 0x%x 0x%x\n", (int)ed, ed->Info, ed->TailP, ed->HeadP, ed->NextED);
;;;793        _ohci->HcControl |= USBH_HcControl_PLE_Msk | USBH_HcControl_IE_Msk;  /* enable periodic list and isochronous transfer  */
;;;794    
;;;795        return 0;
;;;796    
;;;797    mem_out:
;;;798        while (td_list != NULL)
;;;799        {
;;;800            td = td_list;
;;;801            td_list = (TD_T *)td_list->NextTD;
;;;802            free_ohci_TD(td);
;;;803        }
;;;804        free_ohci_ED(ed);
;;;805        return USBH_ERR_MEMORY_OUT;
;;;806    }
000d88  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.3468|
000d8c  e59d0004          LDR      r0,[sp,#4]            ;718
000d90  e5840000          STR      r0,[r4,#0]            ;718
000d94  e3a00000          MOV      r0,#0                 ;719
000d98  e5840008          STR      r0,[r4,#8]            ;719
000d9c  e5d90002          LDRB     r0,[r9,#2]            ;720
000da0  e5c40010          STRB     r0,[r4,#0x10]         ;720
000da4  ea000000          B        |L1.3500|
                  |L1.3496|
000da8  e5894008          STR      r4,[r9,#8]            ;724
                  |L1.3500|
000dac  e5d60020          LDRB     r0,[r6,#0x20]         ;729
000db0  e3500000          CMP      r0,#0                 ;729
000db4  0a000005          BEQ      |L1.3536|
000db8  e51f09c4          LDR      r0,|L1.1020|
000dbc  e5900000          LDR      r0,[r0,#0]            ;730  ; _hcca
000dc0  e1d008b0          LDRH     r0,[r0,#0x80]         ;730
000dc4  e2800004          ADD      r0,r0,#4              ;730
000dc8  e3c00801          BIC      r0,r0,#0x10000        ;730
000dcc  e1c401b2          STRH     r0,[r4,#0x12]         ;730
                  |L1.3536|
000dd0  e3a00000          MOV      r0,#0                 ;732
000dd4  e5860074          STR      r0,[r6,#0x74]         ;732
000dd8  e1d401b2          LDRH     r0,[r4,#0x12]         ;733
000ddc  e1c602b2          STRH     r0,[r6,#0x22]         ;733
000de0  e3a00000          MOV      r0,#0                 ;735
000de4  e58d0008          STR      r0,[sp,#8]            ;735
000de8  e3a07000          MOV      r7,#0                 ;736
000dec  e3a08000          MOV      r8,#0                 ;738
000df0  ea00002c          B        |L1.3752|
                  |L1.3572|
000df4  e59f05e4          LDR      r0,|L1.5088|
000df8  e2861054          ADD      r1,r6,#0x54           ;740
000dfc  e7810108          STR      r0,[r1,r8,LSL #2]     ;740
000e00  e1a00006          MOV      r0,r6                 ;742
000e04  ebfffffe          BL       alloc_ohci_TD
000e08  e1a05000          MOV      r5,r0                 ;742
000e0c  e3550000          CMP      r5,#0                 ;743
000e10  1a000000          BNE      |L1.3608|
000e14  ea00004a          B        |L1.3908|
                  |L1.3608|
000e18  e2860034          ADD      r0,r6,#0x34           ;746
000e1c  e790a108          LDR      r10,[r0,r8,LSL #2]    ;746
000e20  e1d401b2          LDRH     r0,[r4,#0x12]         ;747
000e24  e380020f          ORR      r0,r0,#0xf0000000     ;747
000e28  e3800803          ORR      r0,r0,#0x30000        ;747
000e2c  e5850000          STR      r0,[r5,#0]            ;747
000e30  e5d40010          LDRB     r0,[r4,#0x10]         ;748
000e34  ebfffffe          BL       get_ohci_interval
000e38  e1d411b2          LDRH     r1,[r4,#0x12]         ;748
000e3c  e0800001          ADD      r0,r0,r1              ;748
000e40  e1c401b2          STRH     r0,[r4,#0x12]         ;748
000e44  e1a0062a          LSR      r0,r10,#12            ;749
000e48  e1a00600          LSL      r0,r0,#12             ;749
000e4c  e5850004          STR      r0,[r5,#4]            ;749
000e50  e2860024          ADD      r0,r6,#0x24           ;750
000e54  e0800088          ADD      r0,r0,r8,LSL #1       ;750
000e58  e1d000b0          LDRH     r0,[r0,#0]            ;750
000e5c  e080000a          ADD      r0,r0,r10             ;750
000e60  e2400001          SUB      r0,r0,#1              ;750
000e64  e585000c          STR      r0,[r5,#0xc]          ;750
000e68  e1a00a0a          LSL      r0,r10,#20            ;751
000e6c  e1a00a20          LSR      r0,r0,#20             ;751
000e70  e3800a0e          ORR      r0,r0,#0xe000         ;751
000e74  e5850010          STR      r0,[r5,#0x10]         ;751
000e78  e5854024          STR      r4,[r5,#0x24]         ;753
000e7c  e5960074          LDR      r0,[r6,#0x74]         ;754
000e80  e2800001          ADD      r0,r0,#1              ;754
000e84  e5860074          STR      r0,[r6,#0x74]         ;754
000e88  e3570000          CMP      r7,#0                 ;757
000e8c  1a000001          BNE      |L1.3736|
000e90  e1a07005          MOV      r7,r5                 ;758
000e94  ea000001          B        |L1.3744|
                  |L1.3736|
000e98  e59d0008          LDR      r0,[sp,#8]            ;760
000e9c  e5805008          STR      r5,[r0,#8]            ;760
                  |L1.3744|
000ea0  e58d5008          STR      r5,[sp,#8]            ;762
000ea4  e2888001          ADD      r8,r8,#1              ;738
                  |L1.3752|
000ea8  e3580008          CMP      r8,#8                 ;738
000eac  baffffd0          BLT      |L1.3572|
000eb0  e3a00000          MOV      r0,#0                 ;768
000eb4  e5860078          STR      r0,[r6,#0x78]         ;768
000eb8  e3a00018          MOV      r0,#0x18              ;769
000ebc  ebfffffe          BL       sysDisableInterrupt
000ec0  e5940008          LDR      r0,[r4,#8]            ;771
000ec4  e3d00003          BICS     r0,r0,#3              ;771
000ec8  1a000004          BNE      |L1.3808|
000ecc  e5d40008          LDRB     r0,[r4,#8]            ;772
000ed0  e2000002          AND      r0,r0,#2              ;772
000ed4  e1800007          ORR      r0,r0,r7              ;772
000ed8  e5840008          STR      r0,[r4,#8]            ;772
000edc  ea000007          B        |L1.3840|
                  |L1.3808|
000ee0  e5940008          LDR      r0,[r4,#8]            ;776
000ee4  e3c05003          BIC      r5,r0,#3              ;776
000ee8  ea000000          B        |L1.3824|
                  |L1.3820|
000eec  e5955008          LDR      r5,[r5,#8]            ;779
                  |L1.3824|
000ef0  e5950008          LDR      r0,[r5,#8]            ;777
000ef4  e3500000          CMP      r0,#0                 ;777
000ef8  1afffffb          BNE      |L1.3820|
000efc  e5857008          STR      r7,[r5,#8]            ;781
                  |L1.3840|
000f00  e59d0000          LDR      r0,[sp,#0]            ;784
000f04  e3500000          CMP      r0,#0                 ;784
000f08  0a000002          BEQ      |L1.3864|
000f0c  e59b000c          LDR      r0,[r11,#0xc]         ;787
000f10  e584000c          STR      r0,[r4,#0xc]          ;787
000f14  e58b400c          STR      r4,[r11,#0xc]         ;788
                  |L1.3864|
000f18  e3a00018          MOV      r0,#0x18              ;791
000f1c  ebfffffe          BL       sysEnableInterrupt
000f20  e51f0b80          LDR      r0,|L1.936|
000f24  e5900000          LDR      r0,[r0,#0]            ;793  ; _ohci
000f28  e5900004          LDR      r0,[r0,#4]            ;793
000f2c  e380000c          ORR      r0,r0,#0xc            ;793
000f30  e51f1b90          LDR      r1,|L1.936|
000f34  e5911000          LDR      r1,[r1,#0]            ;793  ; _ohci
000f38  e5810004          STR      r0,[r1,#4]            ;793
000f3c  e3a00000          MOV      r0,#0                 ;795
000f40  eaffff8f          B        |L1.3460|
                  |L1.3908|
000f44  e1a00000          MOV      r0,r0                 ;797
000f48  ea000003          B        |L1.3932|
                  |L1.3916|
000f4c  e1a05007          MOV      r5,r7                 ;800
000f50  e5977008          LDR      r7,[r7,#8]            ;801
000f54  e1a00005          MOV      r0,r5                 ;802
000f58  ebfffffe          BL       free_ohci_TD
                  |L1.3932|
000f5c  e3570000          CMP      r7,#0                 ;798
000f60  1afffff9          BNE      |L1.3916|
000f64  e1a00004          MOV      r0,r4                 ;804
000f68  ebfffffe          BL       free_ohci_ED
000f6c  e3e00009          MVN      r0,#9                 ;805
000f70  eaffff83          B        |L1.3460|
;;;807    
                          ENDP

                  ohci_find_device_by_port PROC
;;;808    static UDEV_T * ohci_find_device_by_port(int port)
000f74  e1a02000          MOV      r2,r0
;;;809    {
;;;810        UDEV_T  *udev;
;;;811    
;;;812        udev = g_udev_list;
000f78  e59f0464          LDR      r0,|L1.5092|
000f7c  e5901000          LDR      r1,[r0,#0]  ; g_udev_list
;;;813        while (udev != NULL)
000f80  ea00000e          B        |L1.4032|
                  |L1.3972|
;;;814        {
;;;815            if ((udev->parent == NULL) && (udev->port_num == port) &&
000f84  e5910014          LDR      r0,[r1,#0x14]
000f88  e3500000          CMP      r0,#0
000f8c  1a00000a          BNE      |L1.4028|
000f90  e5d10018          LDRB     r0,[r1,#0x18]
000f94  e1500002          CMP      r0,r2
000f98  1a000007          BNE      |L1.4028|
;;;816                    ((udev->speed == SPEED_LOW) || (udev->speed == SPEED_FULL)))
000f9c  e5d1001b          LDRB     r0,[r1,#0x1b]
000fa0  e3500000          CMP      r0,#0
000fa4  0a000002          BEQ      |L1.4020|
000fa8  e5d1001b          LDRB     r0,[r1,#0x1b]
000fac  e3500001          CMP      r0,#1
000fb0  1a000001          BNE      |L1.4028|
                  |L1.4020|
;;;817                return udev;
000fb4  e1a00001          MOV      r0,r1
                  |L1.4024|
;;;818            udev = udev->next;
;;;819        }
;;;820        return NULL;
;;;821    }
000fb8  e12fff1e          BX       lr
                  |L1.4028|
000fbc  e5911034          LDR      r1,[r1,#0x34]         ;818
                  |L1.4032|
000fc0  e3510000          CMP      r1,#0                 ;813
000fc4  1affffee          BNE      |L1.3972|
000fc8  e3a00000          MOV      r0,#0                 ;820
000fcc  eafffff9          B        |L1.4024|
;;;822    
                          ENDP

                  ohci_rh_port_reset PROC
;;;823    static int ohci_rh_port_reset(int port)
000fd0  e92d41f0          PUSH     {r4-r8,lr}
;;;824    {
000fd4  e1a04000          MOV      r4,r0
;;;825        int       retry;
;;;826        int       reset_time;
;;;827        uint32_t  t0;
;;;828    
;;;829        reset_time = PORT_RESET_TIME_MS;
000fd8  e3a07032          MOV      r7,#0x32
;;;830    
;;;831        for (retry = 0; retry < PORT_RESET_RETRY; retry++)
000fdc  e3a06000          MOV      r6,#0
000fe0  ea00001f          B        |L1.4196|
                  |L1.4068|
;;;832        {
;;;833            _ohci->HcRhPortStatus[port] = USBH_HcRhPortStatus_PRS_Msk;
000fe4  e3a00010          MOV      r0,#0x10
000fe8  e51f1c48          LDR      r1,|L1.936|
000fec  e5911000          LDR      r1,[r1,#0]  ; _ohci
000ff0  e2811054          ADD      r1,r1,#0x54
000ff4  e7810104          STR      r0,[r1,r4,LSL #2]
;;;834    
;;;835            t0 = get_ticks();
000ff8  ebfffffe          BL       get_ticks
000ffc  e1a05000          MOV      r5,r0
;;;836            while (get_ticks() - t0 < (reset_time/10)+1)
001000  ea00000d          B        |L1.4156|
                  |L1.4100|
;;;837            {
;;;838                /*
;;;839                 *  If device is disconnected or port enabled, we can stop port reset.
;;;840                 */
;;;841                if (((_ohci->HcRhPortStatus[port] & USBH_HcRhPortStatus_CCS_Msk) == 0) ||
001004  e51f0c64          LDR      r0,|L1.936|
001008  e5900000          LDR      r0,[r0,#0]  ; _ohci
00100c  e2800054          ADD      r0,r0,#0x54
001010  e7900104          LDR      r0,[r0,r4,LSL #2]
001014  e3100001          TST      r0,#1
001018  0a000006          BEQ      |L1.4152|
;;;842                        ((_ohci->HcRhPortStatus[port] & (USBH_HcRhPortStatus_PES_Msk | USBH_HcRhPortStatus_CCS_Msk)) == (USBH_HcRhPortStatus_PES_Msk | USBH_HcRhPortStatus_CCS_Msk)))
00101c  e51f0c7c          LDR      r0,|L1.936|
001020  e5900000          LDR      r0,[r0,#0]  ; _ohci
001024  e2800054          ADD      r0,r0,#0x54
001028  e7900104          LDR      r0,[r0,r4,LSL #2]
00102c  e2000003          AND      r0,r0,#3
001030  e3500003          CMP      r0,#3
001034  1a000000          BNE      |L1.4156|
                  |L1.4152|
;;;843                    goto port_reset_done;
001038  ea00000d          B        |L1.4212|
                  |L1.4156|
00103c  ebfffffe          BL       get_ticks
001040  e0408005          SUB      r8,r0,r5              ;836
001044  e3a0100a          MOV      r1,#0xa               ;836
001048  e1a00007          MOV      r0,r7                 ;836
00104c  ebfffffe          BL       __aeabi_idivmod
001050  e2800001          ADD      r0,r0,#1              ;836
001054  e1580000          CMP      r8,r0                 ;836
001058  3affffe9          BCC      |L1.4100|
;;;844            }
;;;845            reset_time += PORT_RESET_RETRY_INC_MS;
00105c  e28770fa          ADD      r7,r7,#0xfa
001060  e2866001          ADD      r6,r6,#1              ;831
                  |L1.4196|
001064  e3560003          CMP      r6,#3                 ;831
001068  baffffdd          BLT      |L1.4068|
;;;846        }
;;;847    
;;;848        USB_debug("OHCI port %d - port reset failed!\n", port+1);
;;;849        return USBH_ERR_PORT_RESET;
00106c  e3e000fe          MVN      r0,#0xfe
                  |L1.4208|
;;;850    
;;;851    port_reset_done:
;;;852        if ((_ohci->HcRhPortStatus[port] & USBH_HcRhPortStatus_CCS_Msk) == 0)   /* check again if device disconnected */
;;;853        {
;;;854            _ohci->HcRhPortStatus[port] = USBH_HcRhPortStatus_CSC_Msk;         /* clear CSC */
;;;855            return USBH_ERR_DISCONNECTED;
;;;856        }
;;;857        return USBH_OK;                                                        /* port reset success */
;;;858    }
001070  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4212|
001074  e1a00000          MOV      r0,r0                 ;851
001078  e51f0cd8          LDR      r0,|L1.936|
00107c  e5900000          LDR      r0,[r0,#0]            ;852  ; _ohci
001080  e2800054          ADD      r0,r0,#0x54           ;852
001084  e7900104          LDR      r0,[r0,r4,LSL #2]     ;852
001088  e3100001          TST      r0,#1                 ;852
00108c  1a000006          BNE      |L1.4268|
001090  e3a00801          MOV      r0,#0x10000           ;854
001094  e51f1cf4          LDR      r1,|L1.936|
001098  e5911000          LDR      r1,[r1,#0]            ;854  ; _ohci
00109c  e2811054          ADD      r1,r1,#0x54           ;854
0010a0  e7810104          STR      r0,[r1,r4,LSL #2]     ;854
0010a4  e59f033c          LDR      r0,|L1.5096|
0010a8  eafffff0          B        |L1.4208|
                  |L1.4268|
0010ac  e3a00000          MOV      r0,#0                 ;857
0010b0  eaffffee          B        |L1.4208|
;;;859    
                          ENDP

                  ohci_rh_polling PROC
;;;860    static int ohci_rh_polling(void)
0010b4  e92d41f0          PUSH     {r4-r8,lr}
;;;861    {
;;;862        int       i, change = 0;
0010b8  e3a07000          MOV      r7,#0
;;;863        UDEV_T    *udev;
;;;864        int       ret;
;;;865    
;;;866        for (i = 0; i < 2; i++)
0010bc  e3a04000          MOV      r4,#0
0010c0  ea000061          B        |L1.4684|
                  |L1.4292|
;;;867        {
;;;868            /* clear unwanted port change status */
;;;869            _ohci->HcRhPortStatus[i] = USBH_HcRhPortStatus_OCIC_Msk | USBH_HcRhPortStatus_PRSC_Msk |
0010c4  e3a0081e          MOV      r0,#0x1e0000
0010c8  e51f1d28          LDR      r1,|L1.936|
0010cc  e5911000          LDR      r1,[r1,#0]  ; _ohci
0010d0  e2811054          ADD      r1,r1,#0x54
0010d4  e7810104          STR      r0,[r1,r4,LSL #2]
;;;870                                       USBH_HcRhPortStatus_PSSC_Msk | USBH_HcRhPortStatus_PESC_Msk;
;;;871    
;;;872            if ((_ohci->HcRhPortStatus[i] & USBH_HcRhPortStatus_CSC_Msk) == 0)
0010d8  e51f0d38          LDR      r0,|L1.936|
0010dc  e5900000          LDR      r0,[r0,#0]  ; _ohci
0010e0  e2800054          ADD      r0,r0,#0x54
0010e4  e7900104          LDR      r0,[r0,r4,LSL #2]
0010e8  e3100801          TST      r0,#0x10000
0010ec  1a000000          BNE      |L1.4340|
;;;873                continue;
0010f0  ea000054          B        |L1.4680|
                  |L1.4340|
;;;874            sysprintf("OHCI port%d status change: 0x%x\n", i+1, _ohci->HcRhPortStatus[i]);
0010f4  e51f0d54          LDR      r0,|L1.936|
0010f8  e5900000          LDR      r0,[r0,#0]  ; _ohci
0010fc  e2800054          ADD      r0,r0,#0x54
001100  e7902104          LDR      r2,[r0,r4,LSL #2]
001104  e2841001          ADD      r1,r4,#1
001108  e28f0fb7          ADR      r0,|L1.5100|
00110c  ebfffffe          BL       sysprintf
;;;875    
;;;876            /*--------------------------------------------------------------------------------*/
;;;877            /*  connect status change                                                         */
;;;878            /*--------------------------------------------------------------------------------*/
;;;879            _ohci->HcRhPortStatus[i] = USBH_HcRhPortStatus_CSC_Msk;     /* clear CSC          */
001110  e3a00801          MOV      r0,#0x10000
001114  e51f1d74          LDR      r1,|L1.936|
001118  e5911000          LDR      r1,[r1,#0]  ; _ohci
00111c  e2811054          ADD      r1,r1,#0x54
001120  e7810104          STR      r0,[r1,r4,LSL #2]
;;;880    
;;;881            if (_ohci->HcRhPortStatus[i] & USBH_HcRhPortStatus_CCS_Msk)
001124  e51f0d84          LDR      r0,|L1.936|
001128  e5900000          LDR      r0,[r0,#0]  ; _ohci
00112c  e2800054          ADD      r0,r0,#0x54
001130  e7900104          LDR      r0,[r0,r4,LSL #2]
001134  e3100001          TST      r0,#1
001138  0a000033          BEQ      |L1.4620|
;;;882            {
;;;883                /*----------------------------------------------------------------------------*/
;;;884                /*  First of all, check if there's any previously connected device.           */
;;;885                /*----------------------------------------------------------------------------*/
;;;886                while (1)
00113c  ea000007          B        |L1.4448|
                  |L1.4416|
;;;887                {
;;;888                    udev = ohci_find_device_by_port(i+1);
001140  e2840001          ADD      r0,r4,#1
001144  ebfffffe          BL       ohci_find_device_by_port
001148  e1a05000          MOV      r5,r0
;;;889                    if (udev == NULL)
00114c  e3550000          CMP      r5,#0
001150  1a000000          BNE      |L1.4440|
;;;890                        break;
001154  ea000002          B        |L1.4452|
                  |L1.4440|
;;;891                    disconnect_device(udev);
001158  e1a00005          MOV      r0,r5
00115c  ebfffffe          BL       disconnect_device
                  |L1.4448|
001160  eafffff6          B        |L1.4416|
                  |L1.4452|
001164  e1a00000          MOV      r0,r0                 ;890
;;;892                }
;;;893    
;;;894                sysprintf("OHCI connect device.\n");
001168  e28f0e2a          ADR      r0,|L1.5136|
00116c  ebfffffe          BL       sysprintf
;;;895    
;;;896                if (ohci_rh_port_reset(i) != USBH_OK)
001170  e1a00004          MOV      r0,r4
001174  ebfffffe          BL       ohci_rh_port_reset
001178  e3500000          CMP      r0,#0
00117c  0a000000          BEQ      |L1.4484|
;;;897                    continue;
001180  ea000030          B        |L1.4680|
                  |L1.4484|
;;;898    
;;;899                /*
;;;900                 *  Port reset success...
;;;901                 */
;;;902                udev = alloc_device();
001184  ebfffffe          BL       alloc_device
001188  e1a05000          MOV      r5,r0
;;;903                if (udev == NULL)
00118c  e3550000          CMP      r5,#0
001190  1a000000          BNE      |L1.4504|
;;;904                    continue;
001194  ea00002b          B        |L1.4680|
                  |L1.4504|
;;;905    
;;;906                udev->parent = NULL;
001198  e3a00000          MOV      r0,#0
00119c  e5850014          STR      r0,[r5,#0x14]
;;;907                udev->port_num = i+1;
0011a0  e2840001          ADD      r0,r4,#1
0011a4  e5c50018          STRB     r0,[r5,#0x18]
;;;908                if (_ohci->HcRhPortStatus[i] & USBH_HcRhPortStatus_LSDA_Msk)
0011a8  e51f0e08          LDR      r0,|L1.936|
0011ac  e5900000          LDR      r0,[r0,#0]  ; _ohci
0011b0  e2800054          ADD      r0,r0,#0x54
0011b4  e7900104          LDR      r0,[r0,r4,LSL #2]
0011b8  e3100c02          TST      r0,#0x200
0011bc  0a000002          BEQ      |L1.4556|
;;;909                    udev->speed = SPEED_LOW;
0011c0  e3a00000          MOV      r0,#0
0011c4  e5c5001b          STRB     r0,[r5,#0x1b]
0011c8  ea000001          B        |L1.4564|
                  |L1.4556|
;;;910                else
;;;911                    udev->speed = SPEED_FULL;
0011cc  e3a00001          MOV      r0,#1
0011d0  e5c5001b          STRB     r0,[r5,#0x1b]
                  |L1.4564|
;;;912                udev->hc_driver = &ohci_driver;
0011d4  e59f024c          LDR      r0,|L1.5160|
0011d8  e585002c          STR      r0,[r5,#0x2c]
;;;913    
;;;914                ret = connect_device(udev);
0011dc  e1a00005          MOV      r0,r5
0011e0  ebfffffe          BL       connect_device
0011e4  e1a06000          MOV      r6,r0
;;;915                if (ret < 0)
0011e8  e3560000          CMP      r6,#0
0011ec  aa000004          BGE      |L1.4612|
;;;916                {
;;;917                    USB_error("connect_device error! [%d]\n", ret);
0011f0  e1a01006          MOV      r1,r6
0011f4  e28f0e23          ADR      r0,|L1.5164|
0011f8  ebfffffe          BL       sysprintf
;;;918                    free_device(udev);
0011fc  e1a00005          MOV      r0,r5
001200  ebfffffe          BL       free_device
                  |L1.4612|
;;;919                }
;;;920    
;;;921                change = 1;
001204  e3a07001          MOV      r7,#1
001208  ea00000d          B        |L1.4676|
                  |L1.4620|
;;;922            }
;;;923            else
;;;924            {
;;;925                /*
;;;926                 *  Device disconnected
;;;927                 */
;;;928                sysprintf("OHCI disconnect device.\n");
00120c  e28f0f8d          ADR      r0,|L1.5192|
001210  ebfffffe          BL       sysprintf
;;;929                while (1)
001214  ea000007          B        |L1.4664|
                  |L1.4632|
;;;930                {
;;;931                    udev = ohci_find_device_by_port(i+1);
001218  e2840001          ADD      r0,r4,#1
00121c  ebfffffe          BL       ohci_find_device_by_port
001220  e1a05000          MOV      r5,r0
;;;932                    if (udev == NULL)
001224  e3550000          CMP      r5,#0
001228  1a000000          BNE      |L1.4656|
;;;933                    {
;;;934                        break;
00122c  ea000002          B        |L1.4668|
                  |L1.4656|
;;;935                    }
;;;936                    disconnect_device(udev);
001230  e1a00005          MOV      r0,r5
001234  ebfffffe          BL       disconnect_device
                  |L1.4664|
001238  eafffff6          B        |L1.4632|
                  |L1.4668|
00123c  e1a00000          MOV      r0,r0                 ;934
;;;937                }
;;;938                change = 1;
001240  e3a07001          MOV      r7,#1
                  |L1.4676|
001244  e1a00000          MOV      r0,r0                 ;873
                  |L1.4680|
001248  e2844001          ADD      r4,r4,#1              ;866
                  |L1.4684|
00124c  e3540002          CMP      r4,#2                 ;866
001250  baffff9b          BLT      |L1.4292|
;;;939            }
;;;940        }
;;;941        return change;
001254  e1a00007          MOV      r0,r7
;;;942    }
001258  e8bd81f0          POP      {r4-r8,pc}
;;;943    
                          ENDP

                  td_done PROC
;;;944    void td_done(TD_T *td)
00125c  e92d47f0          PUSH     {r4-r10,lr}
;;;945    {
001260  e1a05000          MOV      r5,r0
;;;946        UTR_T       *utr = td->utr;
001264  e5954028          LDR      r4,[r5,#0x28]
;;;947        uint32_t    info;
;;;948        int         cc;
;;;949    
;;;950        info = td->Info;
001268  e5957000          LDR      r7,[r5,#0]
;;;951    
;;;952        TD_debug("td_done: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n", (int)td, td->Info, td->CBP, td->NextTD, td->BE);
;;;953    
;;;954        /* ISO ... drivers see per-TD length/status */
;;;955        if ((info & TD_TYPE_Msk) == TD_TYPE_ISO)
00126c  e2070803          AND      r0,r7,#0x30000
001270  e3500803          CMP      r0,#0x30000
001274  1a000030          BNE      |L1.4924|
;;;956        {
;;;957            uint16_t    sf;
;;;958            int         idx;
;;;959    
;;;960            sf = info & 0xFFFF;
001278  e1a09807          LSL      r9,r7,#16
00127c  e1a09829          LSR      r9,r9,#16
;;;961            idx = ((sf + 0x10000 - utr->iso_sf) & 0xFFFF) / get_ohci_interval(td->ed->bInterval);
001280  e5951024          LDR      r1,[r5,#0x24]
001284  e5d10010          LDRB     r0,[r1,#0x10]
001288  ebfffffe          BL       get_ohci_interval
00128c  e1a0a000          MOV      r10,r0
001290  e1d412b2          LDRH     r1,[r4,#0x22]
001294  e2892801          ADD      r2,r9,#0x10000
001298  e0421001          SUB      r1,r2,r1
00129c  e1a00801          LSL      r0,r1,#16
0012a0  e1a00820          LSR      r0,r0,#16
0012a4  e1a0100a          MOV      r1,r10
0012a8  ebfffffe          BL       __aeabi_idivmod
0012ac  e1a08000          MOV      r8,r0
;;;962            if (idx >= IF_PER_UTR)
0012b0  e3580008          CMP      r8,#8
0012b4  ba000004          BLT      |L1.4812|
;;;963            {
;;;964                USB_error("ISO invalid index!! %d, %d\n", sf, utr->iso_sf);
0012b8  e1d422b2          LDRH     r2,[r4,#0x22]
0012bc  e1a01009          MOV      r1,r9
0012c0  e28f0f67          ADR      r0,|L1.5220|
0012c4  ebfffffe          BL       sysprintf
;;;965                goto td_out;
0012c8  ea000090          B        |L1.5392|
                  |L1.4812|
;;;966            }
;;;967    
;;;968            cc = (td->PSW[0] >> 12) & 0xF;
0012cc  e3a0100f          MOV      r1,#0xf
0012d0  e5950010          LDR      r0,[r5,#0x10]
0012d4  e0016620          AND      r6,r1,r0,LSR #12
;;;969            if (cc == 0xF)                      /* this frame was not transferred             */
0012d8  e356000f          CMP      r6,#0xf
0012dc  1a000003          BNE      |L1.4848|
;;;970            {
;;;971                USB_debug("ISO F %d N/A!\n", sf);
;;;972                utr->iso_status[idx] = USBH_ERR_SCH_OVERRUN;
0012e0  e3e00c01          MVN      r0,#0x100
0012e4  e2841054          ADD      r1,r4,#0x54
0012e8  e7810108          STR      r0,[r1,r8,LSL #2]
;;;973                goto td_out;
0012ec  ea000087          B        |L1.5392|
                  |L1.4848|
;;;974            }
;;;975            if ((cc != 0) && (cc != CC_DATA_UNDERRUN))
0012f0  e3560000          CMP      r6,#0
0012f4  0a000006          BEQ      |L1.4884|
0012f8  e3560009          CMP      r6,#9
0012fc  0a000004          BEQ      |L1.4884|
;;;976            {
;;;977                utr->iso_status[idx] = USBH_ERR_CC_NO_ERR - cc;
001300  e59f0178          LDR      r0,|L1.5248|
001304  e0400006          SUB      r0,r0,r6
001308  e2841054          ADD      r1,r4,#0x54
00130c  e7810108          STR      r0,[r1,r8,LSL #2]
;;;978                goto td_out;
001310  ea00007e          B        |L1.5392|
                  |L1.4884|
;;;979            }
;;;980            utr->iso_status[idx] = 0;
001314  e3a00000          MOV      r0,#0
001318  e2841054          ADD      r1,r4,#0x54
00131c  e7810108          STR      r0,[r1,r8,LSL #2]
;;;981            utr->iso_xlen[idx] = td->PSW[0] & 0x7FF;
001320  e1d501b0          LDRH     r0,[r5,#0x10]
001324  e1a00a80          LSL      r0,r0,#21
001328  e1a00aa0          LSR      r0,r0,#21
00132c  e2841024          ADD      r1,r4,#0x24
001330  e0811088          ADD      r1,r1,r8,LSL #1
001334  e1c100b0          STRH     r0,[r1,#0]
;;;982        }
001338  ea000073          B        |L1.5388|
                  |L1.4924|
;;;983        else
;;;984        {
;;;985            cc = TD_CC_GET(info);
00133c  e3a0000f          MOV      r0,#0xf
001340  e0006e27          AND      r6,r0,r7,LSR #28
;;;986    
;;;987            /* short packet is fine */
;;;988            if ((cc != CC_NOERROR) && (cc != CC_DATA_UNDERRUN))
001344  e3560000          CMP      r6,#0
001348  0a000006          BEQ      |L1.4968|
00134c  e3560009          CMP      r6,#9
001350  0a000004          BEQ      |L1.4968|
;;;989            {
;;;990                USB_error("TD error, CC = 0x%x\n", cc);
001354  e1a01006          MOV      r1,r6
001358  e28f0f49          ADR      r0,|L1.5252|
00135c  ebfffffe          BL       sysprintf
;;;991                utr->status = USBH_ERR_TRANSFER;
001360  e3e000c8          MVN      r0,#0xc8
001364  e5840078          STR      r0,[r4,#0x78]
                  |L1.4968|
;;;992            }
;;;993    
;;;994            switch (info & TD_TYPE_Msk)
001368  e2170803          ANDS     r0,r7,#0x30000
00136c  0a000004          BEQ      |L1.4996|
001370  e3500801          CMP      r0,#0x10000
001374  0a00004f          BEQ      |L1.5304|
001378  e3500802          CMP      r0,#0x20000
00137c  1a000061          BNE      |L1.5384|
001380  ea00004e          B        |L1.5312|
                  |L1.4996|
;;;995            {
;;;996            case TD_TYPE_CTRL:
001384  e1a00000          MOV      r0,r0
;;;997                if (info & TD_CTRL_DATA)
001388  e3170902          TST      r7,#0x8000
00138c  0a000048          BEQ      |L1.5300|
;;;998                {
;;;999                    if (td->CBP == 0)
001390  e5950004          LDR      r0,[r5,#4]
001394  e3500000          CMP      r0,#0
001398  1a00003f          BNE      |L1.5276|
;;;1000                       utr->xfer_len += td->BE - td->buff_start + 1;
00139c  e595000c          LDR      r0,[r5,#0xc]
0013a0  e5951020          LDR      r1,[r5,#0x20]
0013a4  e0400001          SUB      r0,r0,r1
0013a8  e2800001          ADD      r0,r0,#1
0013ac  e594101c          LDR      r1,[r4,#0x1c]
0013b0  e0800001          ADD      r0,r0,r1
0013b4  e584001c          STR      r0,[r4,#0x1c]
0013b8  ea00003d          B        |L1.5300|
                  |L1.5052|
                          DCD      0xf30c8000
                  |L1.5056|
                          DCD      0xf3148000
                  |L1.5060|
                          DCD      0xf3100000
                  |L1.5064|
                          DCD      0xf3080000
                  |L1.5068|
                          DCD      0xfffffed1
                  |L1.5072|
                          DCD      0xf00d0000
                  |L1.5076|
                          DCD      0xf0150000
                  |L1.5080|
                          DCD      0xf00e0000
                  |L1.5084|
                          DCD      0xf0160000
                  |L1.5088|
                          DCD      0xfffffed9
                  |L1.5092|
                          DCD      g_udev_list
                  |L1.5096|
                          DCD      0xfffffefd
                  |L1.5100|
0013ec  4f484349          DCB      "OHCI port%d status change: 0x%x\n",0
0013f0  20706f72
0013f4  74256420
0013f8  73746174
0013fc  75732063
001400  68616e67
001404  653a2030
001408  7825780a
00140c  00      
00140d  00                DCB      0
00140e  00                DCB      0
00140f  00                DCB      0
                  |L1.5136|
001410  4f484349          DCB      "OHCI connect device.\n",0
001414  20636f6e
001418  6e656374
00141c  20646576
001420  6963652e
001424  0a00    
001426  00                DCB      0
001427  00                DCB      0
                  |L1.5160|
                          DCD      ohci_driver
                  |L1.5164|
00142c  636f6e6e          DCB      "connect_device error! [%d]\n",0
001430  6563745f
001434  64657669
001438  63652065
00143c  72726f72
001440  21205b25
001444  645d0a00
                  |L1.5192|
001448  4f484349          DCB      "OHCI disconnect device.\n",0
00144c  20646973
001450  636f6e6e
001454  65637420
001458  64657669
00145c  63652e0a
001460  00      
001461  00                DCB      0
001462  00                DCB      0
001463  00                DCB      0
                  |L1.5220|
001464  49534f20          DCB      "ISO invalid index!! %d, %d\n",0
001468  696e7661
00146c  6c696420
001470  696e6465
001474  78212120
001478  25642c20
00147c  25640a00
                  |L1.5248|
                          DCD      0xfffffee8
                  |L1.5252|
001484  54442065          DCB      "TD error, CC = 0x%x\n",0
001488  72726f72
00148c  2c204343
001490  203d2030
001494  7825780a
001498  00      
001499  00                DCB      0
00149a  00                DCB      0
00149b  00                DCB      0
                  |L1.5276|
;;;1001                   else
;;;1002                       utr->xfer_len += td->CBP - td->buff_start;
00149c  e5950004          LDR      r0,[r5,#4]
0014a0  e5951020          LDR      r1,[r5,#0x20]
0014a4  e0400001          SUB      r0,r0,r1
0014a8  e594101c          LDR      r1,[r4,#0x1c]
0014ac  e0800001          ADD      r0,r0,r1
0014b0  e584001c          STR      r0,[r4,#0x1c]
                  |L1.5300|
;;;1003               }
;;;1004               break;
0014b4  ea000013          B        |L1.5384|
                  |L1.5304|
;;;1005   
;;;1006           case TD_TYPE_BULK:
0014b8  e1a00000          MOV      r0,r0
;;;1007           case TD_TYPE_INT:
0014bc  e1a00000          MOV      r0,r0
                  |L1.5312|
;;;1008               if (td->CBP == 0)
0014c0  e5950004          LDR      r0,[r5,#4]
0014c4  e3500000          CMP      r0,#0
0014c8  1a000007          BNE      |L1.5356|
;;;1009                   utr->xfer_len += td->BE - td->buff_start + 1;
0014cc  e595000c          LDR      r0,[r5,#0xc]
0014d0  e5951020          LDR      r1,[r5,#0x20]
0014d4  e0400001          SUB      r0,r0,r1
0014d8  e2800001          ADD      r0,r0,#1
0014dc  e594101c          LDR      r1,[r4,#0x1c]
0014e0  e0800001          ADD      r0,r0,r1
0014e4  e584001c          STR      r0,[r4,#0x1c]
0014e8  ea000005          B        |L1.5380|
                  |L1.5356|
;;;1010               else
;;;1011                   utr->xfer_len += td->CBP - td->buff_start;
0014ec  e5950004          LDR      r0,[r5,#4]
0014f0  e5951020          LDR      r1,[r5,#0x20]
0014f4  e0400001          SUB      r0,r0,r1
0014f8  e594101c          LDR      r1,[r4,#0x1c]
0014fc  e0800001          ADD      r0,r0,r1
001500  e584001c          STR      r0,[r4,#0x1c]
                  |L1.5380|
;;;1012               break;
001504  e1a00000          MOV      r0,r0
                  |L1.5384|
001508  e1a00000          MOV      r0,r0                 ;1004
                  |L1.5388|
;;;1013           }
;;;1014       }
;;;1015   
;;;1016   td_out:
00150c  e1a00000          MOV      r0,r0
                  |L1.5392|
;;;1017   
;;;1018       utr->td_cnt--;
001510  e5940074          LDR      r0,[r4,#0x74]
001514  e2400001          SUB      r0,r0,#1
001518  e5840074          STR      r0,[r4,#0x74]
;;;1019   
;;;1020       /* If all TDs are done, call-back to requester. */
;;;1021       if (utr->td_cnt == 0)
00151c  e5940074          LDR      r0,[r4,#0x74]
001520  e3500000          CMP      r0,#0
001524  1a000007          BNE      |L1.5448|
;;;1022       {
;;;1023           utr->bIsTransferDone = 1;
001528  e3a00001          MOV      r0,#1
00152c  e5c40014          STRB     r0,[r4,#0x14]
;;;1024           if (utr->func)
001530  e5940084          LDR      r0,[r4,#0x84]
001534  e3500000          CMP      r0,#0
001538  0a000002          BEQ      |L1.5448|
;;;1025               utr->func(utr);
00153c  e5941084          LDR      r1,[r4,#0x84]
001540  e1a00004          MOV      r0,r4
001544  e12fff31          BLX      r1
                  |L1.5448|
;;;1026       }
;;;1027   }
001548  e8bd87f0          POP      {r4-r10,pc}
;;;1028   
                          ENDP

                  remove_ed PROC
;;;1029   /* in IRQ context */
;;;1030   static void remove_ed()
00154c  e92d47f0          PUSH     {r4-r10,lr}
;;;1031   {
;;;1032       ED_T      *ed, *ed_p, *ied;
;;;1033       TD_T      *td, *td_next;
;;;1034       UTR_T     *utr;
;;;1035       int       found;
;;;1036   
;;;1037       while (ed_remove_list != NULL)
001550  ea00006d          B        |L1.5900|
                  |L1.5460|
;;;1038       {
;;;1039           ED_debug("Remove ED: 0x%x, %d\n", (int)ed_remove_list, ed_remove_list->bInterval);
;;;1040           ed_p = ed_remove_list;
001554  e59f02c8          LDR      r0,|L1.6180|
001558  e5904000          LDR      r4,[r0,#0]  ; ed_remove_list
;;;1041           found = 0;
00155c  e3a0a000          MOV      r10,#0
;;;1042   
;;;1043           /*--------------------------------------------------------------------------------*/
;;;1044           /*  Remove endpoint from Control List if found                                    */
;;;1045           /*--------------------------------------------------------------------------------*/
;;;1046           if ((ed_p->Info & ED_EP_ADDR_Msk) == 0)
001560  e1d400b0          LDRH     r0,[r4,#0]
001564  e3100d1e          TST      r0,#0x780
001568  1a000018          BNE      |L1.5584|
;;;1047           {
;;;1048               if (_ohci->HcControlHeadED == (uint32_t)ed_p)
00156c  e59f02b4          LDR      r0,|L1.6184|
001570  e5900000          LDR      r0,[r0,#0]  ; _ohci
001574  e5900020          LDR      r0,[r0,#0x20]
001578  e1500004          CMP      r0,r4
00157c  1a000005          BNE      |L1.5528|
;;;1049               {
;;;1050                   _ohci->HcControlHeadED = (uint32_t)ed_p->NextED;
001580  e59f12a0          LDR      r1,|L1.6184|
001584  e594000c          LDR      r0,[r4,#0xc]
001588  e5911000          LDR      r1,[r1,#0]  ; _ohci
00158c  e5810020          STR      r0,[r1,#0x20]
;;;1051                   found = 1;
001590  e3a0a001          MOV      r10,#1
001594  ea000039          B        |L1.5760|
                  |L1.5528|
;;;1052               }
;;;1053               else
;;;1054               {
;;;1055                   ed = (ED_T *)_ohci->HcControlHeadED;
001598  e59f0288          LDR      r0,|L1.6184|
00159c  e5900000          LDR      r0,[r0,#0]  ; _ohci
0015a0  e5905020          LDR      r5,[r0,#0x20]
;;;1056                   while (ed != NULL)
0015a4  ea000006          B        |L1.5572|
                  |L1.5544|
;;;1057                   {
;;;1058                       if (ed->NextED == (uint32_t)ed_p)
0015a8  e595000c          LDR      r0,[r5,#0xc]
0015ac  e1500004          CMP      r0,r4
0015b0  1a000002          BNE      |L1.5568|
;;;1059                       {
;;;1060                           ed->NextED = ed_p->NextED;
0015b4  e594000c          LDR      r0,[r4,#0xc]
0015b8  e585000c          STR      r0,[r5,#0xc]
;;;1061                           found = 1;
0015bc  e3a0a001          MOV      r10,#1
                  |L1.5568|
;;;1062                       }
;;;1063                       ed = (ED_T *)ed->NextED;
0015c0  e595500c          LDR      r5,[r5,#0xc]
                  |L1.5572|
0015c4  e3550000          CMP      r5,#0                 ;1056
0015c8  1afffff6          BNE      |L1.5544|
0015cc  ea00002b          B        |L1.5760|
                  |L1.5584|
;;;1064                   }
;;;1065               }
;;;1066           }
;;;1067   
;;;1068           /*--------------------------------------------------------------------------------*/
;;;1069           /*  Remove INT or ISO endpoint from HCCA interrupt table                          */
;;;1070           /*--------------------------------------------------------------------------------*/
;;;1071           else if (ed_p->bInterval > 0)
0015d0  e5d40010          LDRB     r0,[r4,#0x10]
0015d4  e3500000          CMP      r0,#0
0015d8  da00000f          BLE      |L1.5660|
;;;1072           {
;;;1073               ied = get_int_tree_head_node(ed_p->bInterval);
0015dc  e5d40010          LDRB     r0,[r4,#0x10]
0015e0  ebfffffe          BL       get_int_tree_head_node
0015e4  e1a08000          MOV      r8,r0
;;;1074   
;;;1075               ed = ied;
0015e8  e1a05008          MOV      r5,r8
;;;1076               while (ed != NULL)
0015ec  ea000007          B        |L1.5648|
                  |L1.5616|
;;;1077               {
;;;1078                   if (ed->NextED == (uint32_t)ed_p)
0015f0  e595000c          LDR      r0,[r5,#0xc]
0015f4  e1500004          CMP      r0,r4
0015f8  1a000003          BNE      |L1.5644|
;;;1079                   {
;;;1080                       ed->NextED = ed_p->NextED;
0015fc  e594000c          LDR      r0,[r4,#0xc]
001600  e585000c          STR      r0,[r5,#0xc]
;;;1081                       found = 1;
001604  e3a0a001          MOV      r10,#1
;;;1082                       break;
001608  ea000002          B        |L1.5656|
                  |L1.5644|
;;;1083                   }
;;;1084                   ed = (ED_T *)ed->NextED;
00160c  e595500c          LDR      r5,[r5,#0xc]
                  |L1.5648|
001610  e3550000          CMP      r5,#0                 ;1076
001614  1afffff5          BNE      |L1.5616|
                  |L1.5656|
001618  ea000018          B        |L1.5760|
                  |L1.5660|
;;;1085               }
;;;1086           }
;;;1087   
;;;1088           /*--------------------------------------------------------------------------------*/
;;;1089           /*  Remove endpoint from Bulk List if found                                       */
;;;1090           /*--------------------------------------------------------------------------------*/
;;;1091           else
;;;1092           {
;;;1093               if (_ohci->HcBulkHeadED == (uint32_t)ed_p)
00161c  e59f0204          LDR      r0,|L1.6184|
001620  e5900000          LDR      r0,[r0,#0]  ; _ohci
001624  e5900028          LDR      r0,[r0,#0x28]
001628  e1500004          CMP      r0,r4
00162c  1a000006          BNE      |L1.5708|
;;;1094               {
;;;1095                   ed = (ED_T *)ed_p;
001630  e1a05004          MOV      r5,r4
;;;1096                   _ohci->HcBulkHeadED = ed_p->NextED;
001634  e59f11ec          LDR      r1,|L1.6184|
001638  e594000c          LDR      r0,[r4,#0xc]
00163c  e5911000          LDR      r1,[r1,#0]  ; _ohci
001640  e5810028          STR      r0,[r1,#0x28]
;;;1097                   found = 1;
001644  e3a0a001          MOV      r10,#1
001648  ea00000c          B        |L1.5760|
                  |L1.5708|
;;;1098               }
;;;1099               else
;;;1100               {
;;;1101                   ed = (ED_T *)_ohci->HcBulkHeadED;
00164c  e59f01d4          LDR      r0,|L1.6184|
001650  e5900000          LDR      r0,[r0,#0]  ; _ohci
001654  e5905028          LDR      r5,[r0,#0x28]
;;;1102                   while (ed != NULL)
001658  ea000006          B        |L1.5752|
                  |L1.5724|
;;;1103                   {
;;;1104                       if (ed->NextED == (uint32_t)ed_p)
00165c  e595000c          LDR      r0,[r5,#0xc]
001660  e1500004          CMP      r0,r4
001664  1a000002          BNE      |L1.5748|
;;;1105                       {
;;;1106                           ed->NextED = ed_p->NextED;
001668  e594000c          LDR      r0,[r4,#0xc]
00166c  e585000c          STR      r0,[r5,#0xc]
;;;1107                           found = 1;
001670  e3a0a001          MOV      r10,#1
                  |L1.5748|
;;;1108                       }
;;;1109                       ed = (ED_T *)ed->NextED;
001674  e595500c          LDR      r5,[r5,#0xc]
                  |L1.5752|
001678  e3550000          CMP      r5,#0                 ;1102
00167c  1afffff6          BNE      |L1.5724|
                  |L1.5760|
;;;1110                   }
;;;1111               }
;;;1112           }
;;;1113   
;;;1114           /*--------------------------------------------------------------------------------*/
;;;1115           /*  Remove and free all TDs under this endpoint                                   */
;;;1116           /*--------------------------------------------------------------------------------*/
;;;1117           if (found)
001680  e35a0000          CMP      r10,#0
001684  0a00001b          BEQ      |L1.5880|
;;;1118           {
;;;1119               td = (TD_T *)(ed_p->HeadP & ~0x3);
001688  e5940008          LDR      r0,[r4,#8]
00168c  e3c07003          BIC      r7,r0,#3
;;;1120               if (td != NULL)
001690  e3570000          CMP      r7,#0
001694  0a000017          BEQ      |L1.5880|
;;;1121               {
;;;1122                   while (td != NULL)
001698  ea000014          B        |L1.5872|
                  |L1.5788|
;;;1123                   {
;;;1124                       utr = td->utr;
00169c  e5976028          LDR      r6,[r7,#0x28]
;;;1125                       td_next = (TD_T *)td->NextTD;
0016a0  e5979008          LDR      r9,[r7,#8]
;;;1126                       free_ohci_TD(td);
0016a4  e1a00007          MOV      r0,r7
0016a8  ebfffffe          BL       free_ohci_TD
;;;1127                       td = td_next;
0016ac  e1a07009          MOV      r7,r9
;;;1128   
;;;1129                       utr->td_cnt--;
0016b0  e5960074          LDR      r0,[r6,#0x74]
0016b4  e2400001          SUB      r0,r0,#1
0016b8  e5860074          STR      r0,[r6,#0x74]
;;;1130                       if (utr->td_cnt == 0)
0016bc  e5960074          LDR      r0,[r6,#0x74]
0016c0  e3500000          CMP      r0,#0
0016c4  1a000009          BNE      |L1.5872|
;;;1131                       {
;;;1132                           utr->status = USBH_ERR_ABORT;
0016c8  e3e000cc          MVN      r0,#0xcc
0016cc  e5860078          STR      r0,[r6,#0x78]
;;;1133                           utr->bIsTransferDone = 1;
0016d0  e3a00001          MOV      r0,#1
0016d4  e5c60014          STRB     r0,[r6,#0x14]
;;;1134                           if (utr->func)
0016d8  e5960084          LDR      r0,[r6,#0x84]
0016dc  e3500000          CMP      r0,#0
0016e0  0a000002          BEQ      |L1.5872|
;;;1135                               utr->func(utr);
0016e4  e5961084          LDR      r1,[r6,#0x84]
0016e8  e1a00006          MOV      r0,r6
0016ec  e12fff31          BLX      r1
                  |L1.5872|
0016f0  e3570000          CMP      r7,#0                 ;1122
0016f4  1affffe8          BNE      |L1.5788|
                  |L1.5880|
;;;1136                       }
;;;1137                   }
;;;1138               }
;;;1139           }
;;;1140   
;;;1141           /*
;;;1142            *  Done. Remove this ED from [ed_remove_list] and free it.
;;;1143            */
;;;1144           ed_remove_list = ed_p->next;
0016f8  e59f1124          LDR      r1,|L1.6180|
0016fc  e5940014          LDR      r0,[r4,#0x14]
001700  e5810000          STR      r0,[r1,#0]  ; ed_remove_list
;;;1145           free_ohci_ED(ed_p);
001704  e1a00004          MOV      r0,r4
001708  ebfffffe          BL       free_ohci_ED
                  |L1.5900|
00170c  e59f0110          LDR      r0,|L1.6180|
001710  e5900000          LDR      r0,[r0,#0]            ;1037  ; ed_remove_list
001714  e3500000          CMP      r0,#0                 ;1037
001718  1affff8d          BNE      |L1.5460|
;;;1146       }
;;;1147   }
00171c  e8bd87f0          POP      {r4-r10,pc}
;;;1148   
                          ENDP

                  OHCI_IRQHandler PROC
;;;1150   //static irqreturn_t ohci_irq (struct usb_hcd *hcd)
;;;1151   void OHCI_IRQHandler(void)
001720  e92d41f0          PUSH     {r4-r8,lr}
;;;1152   {
;;;1153       TD_T       *td, *td_prev, *td_next;
;;;1154       uint32_t   int_sts;
;;;1155   
;;;1156       int_sts = _ohci->HcInterruptStatus;
001724  e59f00fc          LDR      r0,|L1.6184|
001728  e5900000          LDR      r0,[r0,#0]  ; _ohci
00172c  e590500c          LDR      r5,[r0,#0xc]
;;;1157   
;;;1158       //USB_debug("ohci int_sts = 0x%x\n", int_sts);
;;;1159   
;;;1160       if ((_ohci->HcInterruptEnable & USBH_HcInterruptEnable_SF_Msk) &&
001730  e59f00f0          LDR      r0,|L1.6184|
001734  e5900000          LDR      r0,[r0,#0]  ; _ohci
001738  e5900010          LDR      r0,[r0,#0x10]
00173c  e3100004          TST      r0,#4
001740  0a00000b          BEQ      |L1.6004|
;;;1161               (int_sts & USBH_HcInterruptStatus_SF_Msk))
001744  e3150004          TST      r5,#4
001748  0a000009          BEQ      |L1.6004|
;;;1162       {
;;;1163           int_sts &= ~USBH_HcInterruptStatus_SF_Msk;
00174c  e3c55004          BIC      r5,r5,#4
;;;1164   
;;;1165           _ohci->HcInterruptDisable = USBH_HcInterruptDisable_SF_Msk;
001750  e3a00004          MOV      r0,#4
001754  e59f10cc          LDR      r1,|L1.6184|
001758  e5911000          LDR      r1,[r1,#0]  ; _ohci
00175c  e5810014          STR      r0,[r1,#0x14]
;;;1166           remove_ed();
001760  ebfffffe          BL       remove_ed
;;;1167           _ohci->HcInterruptStatus = USBH_HcInterruptStatus_SF_Msk;
001764  e3a00004          MOV      r0,#4
001768  e59f10b8          LDR      r1,|L1.6184|
00176c  e5911000          LDR      r1,[r1,#0]  ; _ohci
001770  e581000c          STR      r0,[r1,#0xc]
                  |L1.6004|
;;;1168       }
;;;1169   
;;;1170       if (int_sts & USBH_HcInterruptStatus_WDH_Msk)
001774  e3150002          TST      r5,#2
001778  0a00001f          BEQ      |L1.6140|
;;;1171       {
;;;1172           int_sts &= ~USBH_HcInterruptStatus_WDH_Msk;
00177c  e3c55002          BIC      r5,r5,#2
;;;1173           /*
;;;1174            *  reverse done list
;;;1175            */
;;;1176           td = (TD_T *)(_hcca->done_head & TD_ADDR_MASK);
001780  e59f00a4          LDR      r0,|L1.6188|
001784  e5900000          LDR      r0,[r0,#0]  ; _hcca
001788  e5900084          LDR      r0,[r0,#0x84]
00178c  e3c04003          BIC      r4,r0,#3
;;;1177           _hcca->done_head = 0;
001790  e3a00000          MOV      r0,#0
001794  e59f1090          LDR      r1,|L1.6188|
001798  e5911000          LDR      r1,[r1,#0]  ; _hcca
00179c  e5810084          STR      r0,[r1,#0x84]
;;;1178           td_prev = NULL;
0017a0  e3a06000          MOV      r6,#0
;;;1179           _ohci->HcInterruptStatus = USBH_HcInterruptStatus_WDH_Msk;
0017a4  e3a00002          MOV      r0,#2
0017a8  e59f1078          LDR      r1,|L1.6184|
0017ac  e5911000          LDR      r1,[r1,#0]  ; _ohci
0017b0  e581000c          STR      r0,[r1,#0xc]
;;;1180   
;;;1181           while (td != NULL)
0017b4  ea000004          B        |L1.6092|
                  |L1.6072|
;;;1182           {
;;;1183               //TD_debug("Done list TD 0x%x => 0x%x\n", (int)td, (int)td->NextTD);
;;;1184               td_next = (TD_T *)(td->NextTD & TD_ADDR_MASK);
0017b8  e5940008          LDR      r0,[r4,#8]
0017bc  e3c07003          BIC      r7,r0,#3
;;;1185               td->NextTD = (uint32_t)td_prev;
0017c0  e5846008          STR      r6,[r4,#8]
;;;1186               td_prev = td;
0017c4  e1a06004          MOV      r6,r4
;;;1187               td = td_next;
0017c8  e1a04007          MOV      r4,r7
                  |L1.6092|
0017cc  e3540000          CMP      r4,#0                 ;1181
0017d0  1afffff8          BNE      |L1.6072|
;;;1188           }
;;;1189           td = td_prev;               /* first TD of the reversed done list */
0017d4  e1a04006          MOV      r4,r6
;;;1190   
;;;1191           /*
;;;1192            *  reclaim TDs
;;;1193            */
;;;1194           while (td != NULL)
0017d8  ea000005          B        |L1.6132|
                  |L1.6108|
;;;1195           {
;;;1196               TD_debug("Reclaim TD 0x%x, next 0x%x\n", (int)td, td->NextTD);
;;;1197               td_next = (TD_T *)td->NextTD;
0017dc  e5947008          LDR      r7,[r4,#8]
;;;1198               td_done(td);
0017e0  e1a00004          MOV      r0,r4
0017e4  ebfffffe          BL       td_done
;;;1199               free_ohci_TD(td);
0017e8  e1a00004          MOV      r0,r4
0017ec  ebfffffe          BL       free_ohci_TD
;;;1200               td = td_next;
0017f0  e1a04007          MOV      r4,r7
                  |L1.6132|
0017f4  e3540000          CMP      r4,#0                 ;1194
0017f8  1afffff7          BNE      |L1.6108|
                  |L1.6140|
;;;1201           }
;;;1202       }
;;;1203   
;;;1204       if (int_sts & USBH_HcInterruptStatus_RHSC_Msk)
0017fc  e3150040          TST      r5,#0x40
001800  0a000003          BEQ      |L1.6164|
;;;1205       {
;;;1206           _ohci->HcInterruptDisable = USBH_HcInterruptDisable_RHSC_Msk;
001804  e3a00040          MOV      r0,#0x40
001808  e59f1018          LDR      r1,|L1.6184|
00180c  e5911000          LDR      r1,[r1,#0]  ; _ohci
001810  e5810014          STR      r0,[r1,#0x14]
                  |L1.6164|
;;;1207       }
;;;1208   
;;;1209       _ohci->HcInterruptStatus = int_sts;
001814  e59f000c          LDR      r0,|L1.6184|
001818  e5900000          LDR      r0,[r0,#0]  ; _ohci
00181c  e580500c          STR      r5,[r0,#0xc]
;;;1210   }
001820  e8bd81f0          POP      {r4-r8,pc}
;;;1211   
                          ENDP

                  |L1.6180|
                          DCD      ed_remove_list
                  |L1.6184|
                          DCD      _ohci
                  |L1.6188|
                          DCD      _hcca

                          AREA ||.bss||, DATA, NOINIT, ALIGN=8

                  _hcca_mem
                          %        256
                  _Ied
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  ohci_driver
                          DCD      ohci_init
                          DCD      ohci_shutdown
                          DCD      ohci_suspend
                          DCD      ohci_resume
                          DCD      ohci_ctrl_xfer
                          DCD      ohci_bulk_xfer
                          DCD      ohci_int_xfer
                          DCD      ohci_iso_xfer
                          DCD      ohci_quit_xfer
                          DCD      ohci_rh_port_reset
                          DCD      ohci_rh_polling
                  _hcca
                          DCD      0x00000000
                  ed_remove_list
                          DCD      0x00000000
