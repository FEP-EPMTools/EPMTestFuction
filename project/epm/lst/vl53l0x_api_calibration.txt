; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\vl53l0x_api_calibration.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vl53l0x_api_calibration.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\vl53l0x_api_calibration.crf src\UserDrv\vl53l0x\core\src\vl53l0x_api_calibration.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  VL53L0X_perform_xtalk_calibration PROC
;;;50     
;;;51     VL53L0X_Error VL53L0X_perform_xtalk_calibration(VL53L0X_DEV Dev,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;52     			FixPoint1616_t XTalkCalDistance,
;;;53     			FixPoint1616_t *pXTalkCompensationRateMegaCps)
;;;54     {
000004  e24dd038          SUB      sp,sp,#0x38
000008  e1a05001          MOV      r5,r1
;;;55     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00000c  e3a04000          MOV      r4,#0
;;;56     	uint16_t sum_ranging = 0;
000010  e3a00000          MOV      r0,#0
000014  e58d0034          STR      r0,[sp,#0x34]
;;;57     	uint16_t sum_spads = 0;
000018  e58d0030          STR      r0,[sp,#0x30]
;;;58     	FixPoint1616_t sum_signalRate = 0;
00001c  e58d002c          STR      r0,[sp,#0x2c]
;;;59     	FixPoint1616_t total_count = 0;
000020  e3a07000          MOV      r7,#0
;;;60     	uint8_t xtalk_meas = 0;
000024  e58d0028          STR      r0,[sp,#0x28]
;;;61     	VL53L0X_RangingMeasurementData_t RangingMeasurementData;
;;;62     	FixPoint1616_t xTalkStoredMeanSignalRate;
;;;63     	FixPoint1616_t xTalkStoredMeanRange;
;;;64     	FixPoint1616_t xTalkStoredMeanRtnSpads;
;;;65     	uint32_t signalXTalkTotalPerSpad;
;;;66     	uint32_t xTalkStoredMeanRtnSpadsAsInt;
;;;67     	uint32_t xTalkCalDistanceAsInt;
;;;68     	FixPoint1616_t XTalkCompensationRateMegaCps;
;;;69     
;;;70     	if (XTalkCalDistance <= 0)
000028  e3550000          CMP      r5,#0
00002c  1a000000          BNE      |L1.52|
;;;71     		Status = VL53L0X_ERROR_INVALID_PARAMS;
000030  e3e04003          MVN      r4,#3
                  |L1.52|
;;;72     
;;;73     	/* Disable the XTalk compensation */
;;;74     	if (Status == VL53L0X_ERROR_NONE)
000034  e3540000          CMP      r4,#0
000038  1a000003          BNE      |L1.76|
;;;75     		Status = VL53L0X_SetXTalkCompensationEnable(Dev, 0);
00003c  e3a01000          MOV      r1,#0
000040  e59d0038          LDR      r0,[sp,#0x38]
000044  ebfffffe          BL       VL53L0X_SetXTalkCompensationEnable
000048  e1a04000          MOV      r4,r0
                  |L1.76|
;;;76     
;;;77     	/* Disable the RIT */
;;;78     	if (Status == VL53L0X_ERROR_NONE) {
00004c  e3540000          CMP      r4,#0
000050  1a000004          BNE      |L1.104|
;;;79     		Status = VL53L0X_SetLimitCheckEnable(Dev,
000054  e3a02000          MOV      r2,#0
000058  e3a01003          MOV      r1,#3
00005c  e59d0038          LDR      r0,[sp,#0x38]
000060  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
000064  e1a04000          MOV      r4,r0
                  |L1.104|
;;;80     				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD, 0);
;;;81     	}
;;;82     
;;;83     	/* Perform 50 measurements and compute the averages */
;;;84     	if (Status == VL53L0X_ERROR_NONE) {
000068  e3540000          CMP      r4,#0
00006c  1a00002f          BNE      |L1.304|
;;;85     		sum_ranging = 0;
000070  e3a00000          MOV      r0,#0
000074  e58d0034          STR      r0,[sp,#0x34]
;;;86     		sum_spads = 0;
000078  e58d0030          STR      r0,[sp,#0x30]
;;;87     		sum_signalRate = 0;
00007c  e58d002c          STR      r0,[sp,#0x2c]
;;;88     		total_count = 0;
000080  e3a07000          MOV      r7,#0
;;;89     		for (xtalk_meas = 0; xtalk_meas < 50; xtalk_meas++) {
000084  e58d0028          STR      r0,[sp,#0x28]
000088  ea000021          B        |L1.276|
                  |L1.140|
;;;90     			Status = VL53L0X_PerformSingleRangingMeasurement(Dev,
00008c  e28d100c          ADD      r1,sp,#0xc
000090  e59d0038          LDR      r0,[sp,#0x38]
000094  ebfffffe          BL       VL53L0X_PerformSingleRangingMeasurement
000098  e1a04000          MOV      r4,r0
;;;91     				&RangingMeasurementData);
;;;92     
;;;93     			if (Status != VL53L0X_ERROR_NONE)
00009c  e3540000          CMP      r4,#0
0000a0  0a000000          BEQ      |L1.168|
;;;94     				break;
0000a4  ea00001d          B        |L1.288|
                  |L1.168|
;;;95     
;;;96     			/* The range is valid when RangeStatus = 0 */
;;;97     			if (RangingMeasurementData.RangeStatus == 0) {
0000a8  e5dd0024          LDRB     r0,[sp,#0x24]
0000ac  e3500000          CMP      r0,#0
0000b0  1a000013          BNE      |L1.260|
;;;98     				sum_ranging = sum_ranging +
0000b4  e1dd11b4          LDRH     r1,[sp,#0x14]
0000b8  e59d0034          LDR      r0,[sp,#0x34]
0000bc  e0800001          ADD      r0,r0,r1
0000c0  e1a00800          LSL      r0,r0,#16
0000c4  e1a00820          LSR      r0,r0,#16
0000c8  e58d0034          STR      r0,[sp,#0x34]
;;;99     					RangingMeasurementData.RangeMilliMeter;
;;;100    				sum_signalRate = sum_signalRate +
0000cc  e59d002c          LDR      r0,[sp,#0x2c]
0000d0  e59d1018          LDR      r1,[sp,#0x18]
0000d4  e0800001          ADD      r0,r0,r1
0000d8  e58d002c          STR      r0,[sp,#0x2c]
;;;101    				RangingMeasurementData.SignalRateRtnMegaCps;
;;;102    				sum_spads = sum_spads +
0000dc  e1dd02b0          LDRH     r0,[sp,#0x20]
0000e0  e1a01fc0          ASR      r1,r0,#31
0000e4  e0801c21          ADD      r1,r0,r1,LSR #24
0000e8  e1a02441          ASR      r2,r1,#8
0000ec  e59d1030          LDR      r1,[sp,#0x30]
0000f0  e0811002          ADD      r1,r1,r2
0000f4  e1a01801          LSL      r1,r1,#16
0000f8  e1a01821          LSR      r1,r1,#16
0000fc  e58d1030          STR      r1,[sp,#0x30]
;;;103    				RangingMeasurementData.EffectiveSpadRtnCount
;;;104    					/ 256;
;;;105    				total_count = total_count + 1;
000100  e2877001          ADD      r7,r7,#1
                  |L1.260|
000104  e59d0028          LDR      r0,[sp,#0x28]         ;89
000108  e2800001          ADD      r0,r0,#1              ;89
00010c  e20000ff          AND      r0,r0,#0xff           ;89
000110  e58d0028          STR      r0,[sp,#0x28]         ;89
                  |L1.276|
000114  e59d0028          LDR      r0,[sp,#0x28]         ;89
000118  e3500032          CMP      r0,#0x32              ;89
00011c  baffffda          BLT      |L1.140|
                  |L1.288|
000120  e1a00000          MOV      r0,r0                 ;94
;;;106    			}
;;;107    		}
;;;108    
;;;109    		/* no valid values found */
;;;110    		if (total_count == 0)
000124  e3570000          CMP      r7,#0
000128  1a000000          BNE      |L1.304|
;;;111    			Status = VL53L0X_ERROR_RANGE_ERROR;
00012c  e3e04005          MVN      r4,#5
                  |L1.304|
;;;112    
;;;113    	}
;;;114    
;;;115    
;;;116    	if (Status == VL53L0X_ERROR_NONE) {
000130  e3540000          CMP      r4,#0
000134  1a000037          BNE      |L1.536|
;;;117    		/* FixPoint1616_t / uint16_t = FixPoint1616_t */
;;;118    		xTalkStoredMeanSignalRate = sum_signalRate / total_count;
000138  e1a01007          MOV      r1,r7
00013c  e59d002c          LDR      r0,[sp,#0x2c]
000140  ebfffffe          BL       __aeabi_uidivmod
000144  e58d0008          STR      r0,[sp,#8]
;;;119    		xTalkStoredMeanRange = (FixPoint1616_t)((uint32_t)(
000148  e59d1034          LDR      r1,[sp,#0x34]
00014c  e1a00801          LSL      r0,r1,#16
000150  e1a01007          MOV      r1,r7
000154  ebfffffe          BL       __aeabi_uidivmod
000158  e1a08000          MOV      r8,r0
;;;120    			sum_ranging << 16) / total_count);
;;;121    		xTalkStoredMeanRtnSpads = (FixPoint1616_t)((uint32_t)(
00015c  e59d1030          LDR      r1,[sp,#0x30]
000160  e1a00801          LSL      r0,r1,#16
000164  e1a01007          MOV      r1,r7
000168  ebfffffe          BL       __aeabi_uidivmod
00016c  e1a09000          MOV      r9,r0
;;;122    			sum_spads << 16) / total_count);
;;;123    
;;;124    		/* Round Mean Spads to Whole Number.
;;;125    		 * Typically the calculated mean SPAD count is a whole number
;;;126    		 * or very close to a whole
;;;127    		 * number, therefore any truncation will not result in a
;;;128    		 * significant loss in accuracy.
;;;129    		 * Also, for a grey target at a typical distance of around
;;;130    		 * 400mm, around 220 SPADs will
;;;131    		 * be enabled, therefore, any truncation will result in a loss
;;;132    		 * of accuracy of less than
;;;133    		 * 0.5%.
;;;134    		 */
;;;135    		xTalkStoredMeanRtnSpadsAsInt = (xTalkStoredMeanRtnSpads +
000170  e2890902          ADD      r0,r9,#0x8000
000174  e1a0a820          LSR      r10,r0,#16
;;;136    			0x8000) >> 16;
;;;137    
;;;138    		/* Round Cal Distance to Whole Number.
;;;139    		 * Note that the cal distance is in mm, therefore no resolution
;;;140    		 * is lost.*/
;;;141    		 xTalkCalDistanceAsInt = (XTalkCalDistance + 0x8000) >> 16;
000178  e2850902          ADD      r0,r5,#0x8000
00017c  e1a0b820          LSR      r11,r0,#16
;;;142    
;;;143    		if (xTalkStoredMeanRtnSpadsAsInt == 0 ||
000180  e35a0000          CMP      r10,#0
000184  0a000003          BEQ      |L1.408|
;;;144    		   xTalkCalDistanceAsInt == 0 ||
000188  e35b0000          CMP      r11,#0
00018c  0a000001          BEQ      |L1.408|
;;;145    		   xTalkStoredMeanRange >= XTalkCalDistance) {
000190  e1580005          CMP      r8,r5
000194  3a000001          BCC      |L1.416|
                  |L1.408|
;;;146    			XTalkCompensationRateMegaCps = 0;
000198  e3a06000          MOV      r6,#0
00019c  ea00000f          B        |L1.480|
                  |L1.416|
;;;147    		} else {
;;;148    			/* Round Cal Distance to Whole Number.
;;;149    			   Note that the cal distance is in mm, therefore no
;;;150    			   resolution is lost.*/
;;;151    			xTalkCalDistanceAsInt = (XTalkCalDistance +
0001a0  e2850902          ADD      r0,r5,#0x8000
0001a4  e1a0b820          LSR      r11,r0,#16
;;;152    				0x8000) >> 16;
;;;153    
;;;154    			/* Apply division by mean spad count early in the
;;;155    			 * calculation to keep the numbers small.
;;;156    			 * This ensures we can maintain a 32bit calculation.
;;;157    			 * Fixed1616 / int := Fixed1616 */
;;;158    			signalXTalkTotalPerSpad = (xTalkStoredMeanSignalRate) /
0001a8  e1a0100a          MOV      r1,r10
0001ac  e59d0008          LDR      r0,[sp,#8]
0001b0  ebfffffe          BL       __aeabi_uidivmod
0001b4  e58d0004          STR      r0,[sp,#4]
;;;159    				xTalkStoredMeanRtnSpadsAsInt;
;;;160    
;;;161    			/* Complete the calculation for total Signal XTalk per
;;;162    			 * SPAD
;;;163    			 * Fixed1616 * (Fixed1616 - Fixed1616/int) :=
;;;164    			 * (2^16 * Fixed1616)
;;;165    			 */
;;;166    			signalXTalkTotalPerSpad *= ((1 << 16) -
0001b8  e1a0100b          MOV      r1,r11
0001bc  e1a00008          MOV      r0,r8
0001c0  ebfffffe          BL       __aeabi_uidivmod
0001c4  e2601801          RSB      r1,r0,#0x10000
0001c8  e59d0004          LDR      r0,[sp,#4]
0001cc  e0000091          MUL      r0,r1,r0
0001d0  e58d0004          STR      r0,[sp,#4]
;;;167    				(xTalkStoredMeanRange / xTalkCalDistanceAsInt));
;;;168    
;;;169    			/* Round from 2^16 * Fixed1616, to Fixed1616. */
;;;170    			XTalkCompensationRateMegaCps = (signalXTalkTotalPerSpad
0001d4  e59d0004          LDR      r0,[sp,#4]
0001d8  e2800902          ADD      r0,r0,#0x8000
0001dc  e1a06820          LSR      r6,r0,#16
                  |L1.480|
;;;171    				+ 0x8000) >> 16;
;;;172    		}
;;;173    
;;;174    		*pXTalkCompensationRateMegaCps = XTalkCompensationRateMegaCps;
0001e0  e59d0040          LDR      r0,[sp,#0x40]
0001e4  e5806000          STR      r6,[r0,#0]
;;;175    
;;;176    		/* Enable the XTalk compensation */
;;;177    		if (Status == VL53L0X_ERROR_NONE)
0001e8  e3540000          CMP      r4,#0
0001ec  1a000003          BNE      |L1.512|
;;;178    			Status = VL53L0X_SetXTalkCompensationEnable(Dev, 1);
0001f0  e3a01001          MOV      r1,#1
0001f4  e59d0038          LDR      r0,[sp,#0x38]
0001f8  ebfffffe          BL       VL53L0X_SetXTalkCompensationEnable
0001fc  e1a04000          MOV      r4,r0
                  |L1.512|
;;;179    
;;;180    		/* Enable the XTalk compensation */
;;;181    		if (Status == VL53L0X_ERROR_NONE)
000200  e3540000          CMP      r4,#0
000204  1a000003          BNE      |L1.536|
;;;182    			Status = VL53L0X_SetXTalkCompensationRateMegaCps(Dev,
000208  e1a01006          MOV      r1,r6
00020c  e59d0038          LDR      r0,[sp,#0x38]
000210  ebfffffe          BL       VL53L0X_SetXTalkCompensationRateMegaCps
000214  e1a04000          MOV      r4,r0
                  |L1.536|
;;;183    					XTalkCompensationRateMegaCps);
;;;184    
;;;185    	}
;;;186    
;;;187    	return Status;
000218  e1a00004          MOV      r0,r4
00021c  e28dd044          ADD      sp,sp,#0x44
;;;188    }
000220  e8bd8ff0          POP      {r4-r11,pc}
;;;189    
                          ENDP

                  VL53L0X_perform_offset_calibration PROC
;;;190    VL53L0X_Error VL53L0X_perform_offset_calibration(VL53L0X_DEV Dev,
000224  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;191    			FixPoint1616_t CalDistanceMilliMeter,
;;;192    			int32_t *pOffsetMicroMeter)
;;;193    {
000228  e24dd028          SUB      sp,sp,#0x28
00022c  e1a06001          MOV      r6,r1
000230  e1a05002          MOV      r5,r2
;;;194    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000234  e3a04000          MOV      r4,#0
;;;195    	uint16_t sum_ranging = 0;
000238  e3a09000          MOV      r9,#0
;;;196    	FixPoint1616_t total_count = 0;
00023c  e3a07000          MOV      r7,#0
;;;197    	VL53L0X_RangingMeasurementData_t RangingMeasurementData;
;;;198    	FixPoint1616_t StoredMeanRange;
;;;199    	uint32_t StoredMeanRangeAsInt;
;;;200    	uint32_t CalDistanceAsInt_mm;
;;;201    	uint8_t SequenceStepEnabled;
;;;202    	int meas = 0;
000240  e3a00000          MOV      r0,#0
000244  e58d0004          STR      r0,[sp,#4]
;;;203    
;;;204    	if (CalDistanceMilliMeter <= 0)
000248  e3560000          CMP      r6,#0
00024c  1a000000          BNE      |L1.596|
;;;205    		Status = VL53L0X_ERROR_INVALID_PARAMS;
000250  e3e04003          MVN      r4,#3
                  |L1.596|
;;;206    
;;;207    	if (Status == VL53L0X_ERROR_NONE)
000254  e3540000          CMP      r4,#0
000258  1a000003          BNE      |L1.620|
;;;208    		Status = VL53L0X_SetOffsetCalibrationDataMicroMeter(Dev, 0);
00025c  e3a01000          MOV      r1,#0
000260  e59d0028          LDR      r0,[sp,#0x28]
000264  ebfffffe          BL       VL53L0X_SetOffsetCalibrationDataMicroMeter
000268  e1a04000          MOV      r4,r0
                  |L1.620|
;;;209    
;;;210    
;;;211    	/* Get the value of the TCC */
;;;212    	if (Status == VL53L0X_ERROR_NONE)
00026c  e3540000          CMP      r4,#0
000270  1a000004          BNE      |L1.648|
;;;213    		Status = VL53L0X_GetSequenceStepEnable(Dev,
000274  e28d2008          ADD      r2,sp,#8
000278  e3a01000          MOV      r1,#0
00027c  e59d0028          LDR      r0,[sp,#0x28]
000280  ebfffffe          BL       VL53L0X_GetSequenceStepEnable
000284  e1a04000          MOV      r4,r0
                  |L1.648|
;;;214    				VL53L0X_SEQUENCESTEP_TCC, &SequenceStepEnabled);
;;;215    
;;;216    
;;;217    	/* Disable the TCC */
;;;218    	if (Status == VL53L0X_ERROR_NONE)
000288  e3540000          CMP      r4,#0
00028c  1a000004          BNE      |L1.676|
;;;219    		Status = VL53L0X_SetSequenceStepEnable(Dev,
000290  e3a02000          MOV      r2,#0
000294  e1a01002          MOV      r1,r2
000298  e59d0028          LDR      r0,[sp,#0x28]
00029c  ebfffffe          BL       VL53L0X_SetSequenceStepEnable
0002a0  e1a04000          MOV      r4,r0
                  |L1.676|
;;;220    				VL53L0X_SEQUENCESTEP_TCC, 0);
;;;221    
;;;222    
;;;223    	/* Disable the RIT */
;;;224    	if (Status == VL53L0X_ERROR_NONE)
0002a4  e3540000          CMP      r4,#0
0002a8  1a000004          BNE      |L1.704|
;;;225    		Status = VL53L0X_SetLimitCheckEnable(Dev,
0002ac  e3a02000          MOV      r2,#0
0002b0  e3a01003          MOV      r1,#3
0002b4  e59d0028          LDR      r0,[sp,#0x28]
0002b8  ebfffffe          BL       VL53L0X_SetLimitCheckEnable
0002bc  e1a04000          MOV      r4,r0
                  |L1.704|
;;;226    				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD, 0);
;;;227    
;;;228    	/* Perform 50 measurements and compute the averages */
;;;229    	if (Status == VL53L0X_ERROR_NONE) {
0002c0  e3540000          CMP      r4,#0
0002c4  1a00001d          BNE      |L1.832|
;;;230    		sum_ranging = 0;
0002c8  e3a09000          MOV      r9,#0
;;;231    		total_count = 0;
0002cc  e3a07000          MOV      r7,#0
;;;232    		for (meas = 0; meas < 50; meas++) {
0002d0  e3a00000          MOV      r0,#0
0002d4  e58d0004          STR      r0,[sp,#4]
0002d8  ea000011          B        |L1.804|
                  |L1.732|
;;;233    			Status = VL53L0X_PerformSingleRangingMeasurement(Dev,
0002dc  e28d100c          ADD      r1,sp,#0xc
0002e0  e59d0028          LDR      r0,[sp,#0x28]
0002e4  ebfffffe          BL       VL53L0X_PerformSingleRangingMeasurement
0002e8  e1a04000          MOV      r4,r0
;;;234    					&RangingMeasurementData);
;;;235    
;;;236    			if (Status != VL53L0X_ERROR_NONE)
0002ec  e3540000          CMP      r4,#0
0002f0  0a000000          BEQ      |L1.760|
;;;237    				break;
0002f4  ea00000d          B        |L1.816|
                  |L1.760|
;;;238    
;;;239    			/* The range is valid when RangeStatus = 0 */
;;;240    			if (RangingMeasurementData.RangeStatus == 0) {
0002f8  e5dd0024          LDRB     r0,[sp,#0x24]
0002fc  e3500000          CMP      r0,#0
000300  1a000004          BNE      |L1.792|
;;;241    				sum_ranging = sum_ranging +
000304  e1dd01b4          LDRH     r0,[sp,#0x14]
000308  e0800009          ADD      r0,r0,r9
00030c  e1a09800          LSL      r9,r0,#16
000310  e1a09829          LSR      r9,r9,#16
;;;242    					RangingMeasurementData.RangeMilliMeter;
;;;243    				total_count = total_count + 1;
000314  e2877001          ADD      r7,r7,#1
                  |L1.792|
000318  e59d0004          LDR      r0,[sp,#4]            ;232
00031c  e2800001          ADD      r0,r0,#1              ;232
000320  e58d0004          STR      r0,[sp,#4]            ;232
                  |L1.804|
000324  e59d0004          LDR      r0,[sp,#4]            ;232
000328  e3500032          CMP      r0,#0x32              ;232
00032c  baffffea          BLT      |L1.732|
                  |L1.816|
000330  e1a00000          MOV      r0,r0                 ;237
;;;244    			}
;;;245    		}
;;;246    
;;;247    		/* no valid values found */
;;;248    		if (total_count == 0)
000334  e3570000          CMP      r7,#0
000338  1a000000          BNE      |L1.832|
;;;249    			Status = VL53L0X_ERROR_RANGE_ERROR;
00033c  e3e04005          MVN      r4,#5
                  |L1.832|
;;;250    	}
;;;251    
;;;252    
;;;253    	if (Status == VL53L0X_ERROR_NONE) {
000340  e3540000          CMP      r4,#0
000344  1a000014          BNE      |L1.924|
;;;254    		/* FixPoint1616_t / uint16_t = FixPoint1616_t */
;;;255    		StoredMeanRange = (FixPoint1616_t)((uint32_t)(sum_ranging << 16)
000348  e1a00809          LSL      r0,r9,#16
00034c  e1a01007          MOV      r1,r7
000350  ebfffffe          BL       __aeabi_uidivmod
000354  e1a08000          MOV      r8,r0
;;;256    			/ total_count);
;;;257    
;;;258    		StoredMeanRangeAsInt = (StoredMeanRange + 0x8000) >> 16;
000358  e2880902          ADD      r0,r8,#0x8000
00035c  e1a0a820          LSR      r10,r0,#16
;;;259    
;;;260    		/* Round Cal Distance to Whole Number.
;;;261    		 * Note that the cal distance is in mm, therefore no resolution
;;;262    		 * is lost.*/
;;;263    		 CalDistanceAsInt_mm = (CalDistanceMilliMeter + 0x8000) >> 16;
000360  e2860902          ADD      r0,r6,#0x8000
000364  e1a0b820          LSR      r11,r0,#16
;;;264    
;;;265    		 *pOffsetMicroMeter = (CalDistanceAsInt_mm -
000368  e04b000a          SUB      r0,r11,r10
00036c  e3a01ffa          MOV      r1,#0x3e8
000370  e0000091          MUL      r0,r1,r0
000374  e5850000          STR      r0,[r5,#0]
;;;266    				 StoredMeanRangeAsInt) * 1000;
;;;267    
;;;268    		/* Apply the calculated offset */
;;;269    		if (Status == VL53L0X_ERROR_NONE) {
000378  e3540000          CMP      r4,#0
00037c  1a000006          BNE      |L1.924|
;;;270    			VL53L0X_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters,
000380  e5951000          LDR      r1,[r5,#0]
000384  e59d0028          LDR      r0,[sp,#0x28]
000388  e5801024          STR      r1,[r0,#0x24]
;;;271    					*pOffsetMicroMeter);
;;;272    			Status = VL53L0X_SetOffsetCalibrationDataMicroMeter(Dev,
00038c  e5951000          LDR      r1,[r5,#0]
000390  e59d0028          LDR      r0,[sp,#0x28]
000394  ebfffffe          BL       VL53L0X_SetOffsetCalibrationDataMicroMeter
000398  e1a04000          MOV      r4,r0
                  |L1.924|
;;;273    					*pOffsetMicroMeter);
;;;274    		}
;;;275    
;;;276    	}
;;;277    
;;;278    	/* Restore the TCC */
;;;279    	if (Status == VL53L0X_ERROR_NONE) {
00039c  e3540000          CMP      r4,#0
0003a0  1a000007          BNE      |L1.964|
;;;280    		if (SequenceStepEnabled != 0)
0003a4  e5dd0008          LDRB     r0,[sp,#8]
0003a8  e3500000          CMP      r0,#0
0003ac  0a000004          BEQ      |L1.964|
;;;281    			Status = VL53L0X_SetSequenceStepEnable(Dev,
0003b0  e3a02001          MOV      r2,#1
0003b4  e3a01000          MOV      r1,#0
0003b8  e59d0028          LDR      r0,[sp,#0x28]
0003bc  ebfffffe          BL       VL53L0X_SetSequenceStepEnable
0003c0  e1a04000          MOV      r4,r0
                  |L1.964|
;;;282    					VL53L0X_SEQUENCESTEP_TCC, 1);
;;;283    	}
;;;284    
;;;285    	return Status;
0003c4  e1a00004          MOV      r0,r4
0003c8  e28dd034          ADD      sp,sp,#0x34
;;;286    }
0003cc  e8bd8ff0          POP      {r4-r11,pc}
;;;287    
                          ENDP

                  VL53L0X_set_offset_calibration_data_micro_meter PROC
;;;288    
;;;289    VL53L0X_Error VL53L0X_set_offset_calibration_data_micro_meter(VL53L0X_DEV Dev,
0003d0  e92d47f0          PUSH     {r4-r10,lr}
;;;290    		int32_t OffsetCalibrationDataMicroMeter)
;;;291    {
0003d4  e1a08000          MOV      r8,r0
0003d8  e1a04001          MOV      r4,r1
;;;292    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0003dc  e3a09000          MOV      r9,#0
;;;293    	int32_t cMaxOffsetMicroMeter = 511000;
0003e0  e59f6eb0          LDR      r6,|L1.4760|
;;;294    	int32_t cMinOffsetMicroMeter = -512000;
0003e4  e2497a7d          SUB      r7,r9,#0x7d000
;;;295    	int16_t cOffsetRange = 4096;
0003e8  e3a0aa01          MOV      r10,#0x1000
;;;296    	uint32_t encodedOffsetVal;
;;;297    
;;;298    	LOG_FUNCTION_START("");
;;;299    
;;;300    	if (OffsetCalibrationDataMicroMeter > cMaxOffsetMicroMeter)
0003ec  e1540006          CMP      r4,r6
0003f0  da000001          BLE      |L1.1020|
;;;301    		OffsetCalibrationDataMicroMeter = cMaxOffsetMicroMeter;
0003f4  e1a04006          MOV      r4,r6
0003f8  ea000002          B        |L1.1032|
                  |L1.1020|
;;;302    	else if (OffsetCalibrationDataMicroMeter < cMinOffsetMicroMeter)
0003fc  e1540007          CMP      r4,r7
000400  aa000000          BGE      |L1.1032|
;;;303    		OffsetCalibrationDataMicroMeter = cMinOffsetMicroMeter;
000404  e1a04007          MOV      r4,r7
                  |L1.1032|
;;;304    
;;;305    	/* The offset register is 10.2 format and units are mm
;;;306    	 * therefore conversion is applied by a division of
;;;307    	 * 250.
;;;308    	 */
;;;309    	if (OffsetCalibrationDataMicroMeter >= 0) {
000408  e3540000          CMP      r4,#0
00040c  ba000004          BLT      |L1.1060|
;;;310    		encodedOffsetVal =
000410  e3a010fa          MOV      r1,#0xfa
000414  e1a00004          MOV      r0,r4
000418  ebfffffe          BL       __aeabi_idivmod
00041c  e1a05000          MOV      r5,r0
000420  ea000003          B        |L1.1076|
                  |L1.1060|
;;;311    			OffsetCalibrationDataMicroMeter/250;
;;;312    	} else {
;;;313    		encodedOffsetVal =
000424  e3a010fa          MOV      r1,#0xfa
000428  e1a00004          MOV      r0,r4
00042c  ebfffffe          BL       __aeabi_idivmod
000430  e080500a          ADD      r5,r0,r10
                  |L1.1076|
;;;314    			cOffsetRange +
;;;315    			OffsetCalibrationDataMicroMeter/250;
;;;316    	}
;;;317    
;;;318    	Status = VL53L0X_WrWord(Dev,
000434  e1a02805          LSL      r2,r5,#16
000438  e1a02822          LSR      r2,r2,#16
00043c  e3a01028          MOV      r1,#0x28
000440  e1a00008          MOV      r0,r8
000444  ebfffffe          BL       VL53L0X_WrWord
000448  e1a09000          MOV      r9,r0
;;;319    		VL53L0X_REG_ALGO_PART_TO_PART_RANGE_OFFSET_MM,
;;;320    		encodedOffsetVal);
;;;321    
;;;322    	LOG_FUNCTION_END(Status);
;;;323    	return Status;
00044c  e1a00009          MOV      r0,r9
;;;324    }
000450  e8bd87f0          POP      {r4-r10,pc}
;;;325    
                          ENDP

                  VL53L0X_get_offset_calibration_data_micro_meter PROC
;;;326    VL53L0X_Error VL53L0X_get_offset_calibration_data_micro_meter(VL53L0X_DEV Dev,
000454  e92d43f8          PUSH     {r3-r9,lr}
;;;327    		int32_t *pOffsetCalibrationDataMicroMeter)
;;;328    {
000458  e1a06000          MOV      r6,r0
00045c  e1a04001          MOV      r4,r1
;;;329    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000460  e3a05000          MOV      r5,#0
;;;330    	uint16_t RangeOffsetRegister;
;;;331    	int16_t cMaxOffset = 2047;
000464  e59f7e30          LDR      r7,|L1.4764|
;;;332    	int16_t cOffsetRange = 4096;
000468  e3a08a01          MOV      r8,#0x1000
;;;333    
;;;334    	/* Note that offset has 10.2 format */
;;;335    
;;;336    	Status = VL53L0X_RdWord(Dev,
00046c  e1a0200d          MOV      r2,sp
000470  e3a01028          MOV      r1,#0x28
000474  e1a00006          MOV      r0,r6
000478  ebfffffe          BL       VL53L0X_RdWord
00047c  e1a05000          MOV      r5,r0
;;;337    				VL53L0X_REG_ALGO_PART_TO_PART_RANGE_OFFSET_MM,
;;;338    				&RangeOffsetRegister);
;;;339    
;;;340    	if (Status == VL53L0X_ERROR_NONE) {
000480  e3550000          CMP      r5,#0
000484  1a00000f          BNE      |L1.1224|
;;;341    		RangeOffsetRegister = (RangeOffsetRegister & 0x0fff);
000488  e1dd00b0          LDRH     r0,[sp,#0]
00048c  e3c00a0f          BIC      r0,r0,#0xf000
000490  e58d0000          STR      r0,[sp,#0]
;;;342    
;;;343    		/* Apply 12 bit 2's compliment conversion */
;;;344    		if (RangeOffsetRegister > cMaxOffset)
000494  e1dd00b0          LDRH     r0,[sp,#0]
000498  e1500007          CMP      r0,r7
00049c  da000005          BLE      |L1.1208|
;;;345    			*pOffsetCalibrationDataMicroMeter =
0004a0  e1dd00b0          LDRH     r0,[sp,#0]
0004a4  e0400008          SUB      r0,r0,r8
0004a8  e3a010fa          MOV      r1,#0xfa
0004ac  e1600180          SMULBB   r0,r0,r1
0004b0  e5840000          STR      r0,[r4,#0]
0004b4  ea000003          B        |L1.1224|
                  |L1.1208|
;;;346    				(int16_t)(RangeOffsetRegister - cOffsetRange)
;;;347    					* 250;
;;;348    		else
;;;349    			*pOffsetCalibrationDataMicroMeter =
0004b8  e1dd00b0          LDRH     r0,[sp,#0]
0004bc  e3a010fa          MOV      r1,#0xfa
0004c0  e1600180          SMULBB   r0,r0,r1
0004c4  e5840000          STR      r0,[r4,#0]
                  |L1.1224|
;;;350    				(int16_t)RangeOffsetRegister * 250;
;;;351    
;;;352    	}
;;;353    
;;;354    	return Status;
0004c8  e1a00005          MOV      r0,r5
;;;355    }
0004cc  e8bd83f8          POP      {r3-r9,pc}
;;;356    
                          ENDP

                  VL53L0X_apply_offset_adjustment PROC
;;;357    
;;;358    VL53L0X_Error VL53L0X_apply_offset_adjustment(VL53L0X_DEV Dev)
0004d0  e92d40f8          PUSH     {r3-r7,lr}
;;;359    {
0004d4  e1a04000          MOV      r4,r0
;;;360    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0004d8  e3a05000          MOV      r5,#0
;;;361    	int32_t CorrectedOffsetMicroMeters;
;;;362    	int32_t CurrentOffsetMicroMeters;
;;;363    
;;;364    	/* if we run on this function we can read all the NVM info
;;;365    	 * used by the API */
;;;366    	Status = VL53L0X_get_info_from_device(Dev, 7);
0004dc  e3a01007          MOV      r1,#7
0004e0  e1a00004          MOV      r0,r4
0004e4  ebfffffe          BL       VL53L0X_get_info_from_device
0004e8  e1a05000          MOV      r5,r0
;;;367    
;;;368    	/* Read back current device offset */
;;;369    	if (Status == VL53L0X_ERROR_NONE) {
0004ec  e3550000          CMP      r5,#0
0004f0  1a000003          BNE      |L1.1284|
;;;370    		Status = VL53L0X_GetOffsetCalibrationDataMicroMeter(Dev,
0004f4  e1a0100d          MOV      r1,sp
0004f8  e1a00004          MOV      r0,r4
0004fc  ebfffffe          BL       VL53L0X_GetOffsetCalibrationDataMicroMeter
000500  e1a05000          MOV      r5,r0
                  |L1.1284|
;;;371    					&CurrentOffsetMicroMeters);
;;;372    	}
;;;373    
;;;374    	/* Apply Offset Adjustment derived from 400mm measurements */
;;;375    	if (Status == VL53L0X_ERROR_NONE) {
000504  e3550000          CMP      r5,#0
000508  1a00000b          BNE      |L1.1340|
;;;376    
;;;377    		/* Store initial device offset */
;;;378    		PALDevDataSet(Dev, Part2PartOffsetNVMMicroMeter,
00050c  e59d0000          LDR      r0,[sp,#0]
000510  e5840008          STR      r0,[r4,#8]
;;;379    			CurrentOffsetMicroMeters);
;;;380    
;;;381    		CorrectedOffsetMicroMeters = CurrentOffsetMicroMeters +
000514  e594000c          LDR      r0,[r4,#0xc]
000518  e59d1000          LDR      r1,[sp,#0]
00051c  e0806001          ADD      r6,r0,r1
;;;382    			(int32_t)PALDevDataGet(Dev,
;;;383    				Part2PartOffsetAdjustmentNVMMicroMeter);
;;;384    
;;;385    		Status = VL53L0X_SetOffsetCalibrationDataMicroMeter(Dev,
000520  e1a01006          MOV      r1,r6
000524  e1a00004          MOV      r0,r4
000528  ebfffffe          BL       VL53L0X_SetOffsetCalibrationDataMicroMeter
00052c  e1a05000          MOV      r5,r0
;;;386    					CorrectedOffsetMicroMeters);
;;;387    
;;;388    		/* store current, adjusted offset */
;;;389    		if (Status == VL53L0X_ERROR_NONE) {
000530  e3550000          CMP      r5,#0
000534  1a000000          BNE      |L1.1340|
;;;390    			VL53L0X_SETPARAMETERFIELD(Dev, RangeOffsetMicroMeters,
000538  e5846024          STR      r6,[r4,#0x24]
                  |L1.1340|
;;;391    					CorrectedOffsetMicroMeters);
;;;392    		}
;;;393    	}
;;;394    
;;;395    	return Status;
00053c  e1a00005          MOV      r0,r5
;;;396    }
000540  e8bd80f8          POP      {r3-r7,pc}
;;;397    
                          ENDP

                  get_next_good_spad PROC
;;;398    void get_next_good_spad(uint8_t goodSpadArray[], uint32_t size,
000544  e92d4fff          PUSH     {r0-r11,lr}
;;;399    			uint32_t curr, int32_t *next)
;;;400    {
000548  e24dd00c          SUB      sp,sp,#0xc
00054c  e1a09000          MOV      r9,r0
000550  e1a0a001          MOV      r10,r1
000554  e1a05003          MOV      r5,r3
;;;401    	uint32_t startIndex;
;;;402    	uint32_t fineOffset;
;;;403    	uint32_t cSpadsPerByte = 8;
000558  e3a06008          MOV      r6,#8
;;;404    	uint32_t coarseIndex;
;;;405    	uint32_t fineIndex;
;;;406    	uint8_t dataByte;
;;;407    	uint8_t success = 0;
00055c  e3a00000          MOV      r0,#0
000560  e58d0004          STR      r0,[sp,#4]
;;;408    
;;;409    	/*
;;;410    	 * Starting with the current good spad, loop through the array to find
;;;411    	 * the next. i.e. the next bit set in the sequence.
;;;412    	 *
;;;413    	 * The coarse index is the byte index of the array and the fine index is
;;;414    	 * the index of the bit within each byte.
;;;415    	 */
;;;416    
;;;417    	*next = -1;
000564  e3e00000          MVN      r0,#0
000568  e5850000          STR      r0,[r5,#0]
;;;418    
;;;419    	startIndex = curr / cSpadsPerByte;
00056c  e1a01006          MOV      r1,r6
000570  e59d0014          LDR      r0,[sp,#0x14]
000574  ebfffffe          BL       __aeabi_uidivmod
000578  e58d0008          STR      r0,[sp,#8]
;;;420    	fineOffset = curr % cSpadsPerByte;
00057c  e1a01006          MOV      r1,r6
000580  e59d0014          LDR      r0,[sp,#0x14]
000584  ebfffffe          BL       __aeabi_uidivmod
000588  e1a0b001          MOV      r11,r1
;;;421    
;;;422    	for (coarseIndex = startIndex; ((coarseIndex < size) && !success);
00058c  e59d4008          LDR      r4,[sp,#8]
000590  ea000014          B        |L1.1512|
                  |L1.1428|
;;;423    				coarseIndex++) {
;;;424    		fineIndex = 0;
000594  e3a07000          MOV      r7,#0
;;;425    		dataByte = goodSpadArray[coarseIndex];
000598  e7d98004          LDRB     r8,[r9,r4]
;;;426    
;;;427    		if (coarseIndex == startIndex) {
00059c  e59d0008          LDR      r0,[sp,#8]
0005a0  e1540000          CMP      r4,r0
0005a4  1a000001          BNE      |L1.1456|
;;;428    			/* locate the bit position of the provided current
;;;429    			 * spad bit before iterating */
;;;430    			dataByte >>= fineOffset;
0005a8  e1a08b58          ASR      r8,r8,r11
;;;431    			fineIndex = fineOffset;
0005ac  e1a0700b          MOV      r7,r11
                  |L1.1456|
;;;432    		}
;;;433    
;;;434    		while (fineIndex < cSpadsPerByte) {
0005b0  ea000008          B        |L1.1496|
                  |L1.1460|
;;;435    			if ((dataByte & 0x1) == 1) {
0005b4  e3180001          TST      r8,#1
0005b8  0a000004          BEQ      |L1.1488|
;;;436    				success = 1;
0005bc  e3a00001          MOV      r0,#1
0005c0  e58d0004          STR      r0,[sp,#4]
;;;437    				*next = coarseIndex * cSpadsPerByte + fineIndex;
0005c4  e0207694          MLA      r0,r4,r6,r7
0005c8  e5850000          STR      r0,[r5,#0]
;;;438    				break;
0005cc  ea000003          B        |L1.1504|
                  |L1.1488|
;;;439    			}
;;;440    			dataByte >>= 1;
0005d0  e1a080c8          ASR      r8,r8,#1
;;;441    			fineIndex++;
0005d4  e2877001          ADD      r7,r7,#1
                  |L1.1496|
0005d8  e1570006          CMP      r7,r6                 ;434
0005dc  3afffff4          BCC      |L1.1460|
                  |L1.1504|
0005e0  e1a00000          MOV      r0,r0                 ;438
0005e4  e2844001          ADD      r4,r4,#1              ;423
                  |L1.1512|
0005e8  e154000a          CMP      r4,r10                ;422
0005ec  2a000002          BCS      |L1.1532|
0005f0  e59d0004          LDR      r0,[sp,#4]            ;422
0005f4  e3500000          CMP      r0,#0                 ;422
0005f8  0affffe5          BEQ      |L1.1428|
                  |L1.1532|
;;;442    		}
;;;443    	}
;;;444    }
0005fc  e28dd01c          ADD      sp,sp,#0x1c
000600  e8bd8ff0          POP      {r4-r11,pc}
;;;445    
                          ENDP

                  is_aperture PROC
;;;446    
;;;447    uint8_t is_aperture(uint32_t spadIndex)
000604  e1a01000          MOV      r1,r0
;;;448    {
;;;449    	/*
;;;450    	 * This function reports if a given spad index is an aperture SPAD by
;;;451    	 * deriving the quadrant.
;;;452    	 */
;;;453    	uint32_t quadrant;
;;;454    	uint8_t isAperture = 1;
000608  e3a00001          MOV      r0,#1
;;;455    	quadrant = spadIndex >> 6;
00060c  e1a02321          LSR      r2,r1,#6
;;;456    	if (refArrayQuadrants[quadrant] == REF_ARRAY_SPAD_0)
000610  e59f3c88          LDR      r3,|L1.4768|
000614  e7933102          LDR      r3,[r3,r2,LSL #2]
000618  e3530000          CMP      r3,#0
00061c  1a000000          BNE      |L1.1572|
;;;457    		isAperture = 0;
000620  e3a00000          MOV      r0,#0
                  |L1.1572|
;;;458    
;;;459    	return isAperture;
;;;460    }
000624  e12fff1e          BX       lr
;;;461    
                          ENDP

                  enable_spad_bit PROC
;;;462    
;;;463    VL53L0X_Error enable_spad_bit(uint8_t spadArray[], uint32_t size,
000628  e92d47f0          PUSH     {r4-r10,lr}
;;;464    	uint32_t spadIndex)
;;;465    {
00062c  e1a04000          MOV      r4,r0
000630  e1a06001          MOV      r6,r1
000634  e1a07002          MOV      r7,r2
;;;466    	VL53L0X_Error status = VL53L0X_ERROR_NONE;
000638  e3a08000          MOV      r8,#0
;;;467    	uint32_t cSpadsPerByte = 8;
00063c  e3a09008          MOV      r9,#8
;;;468    	uint32_t coarseIndex;
;;;469    	uint32_t fineIndex;
;;;470    
;;;471    	coarseIndex = spadIndex / cSpadsPerByte;
000640  e1a01009          MOV      r1,r9
000644  e1a00007          MOV      r0,r7
000648  ebfffffe          BL       __aeabi_uidivmod
00064c  e1a05000          MOV      r5,r0
;;;472    	fineIndex = spadIndex % cSpadsPerByte;
000650  e1a01009          MOV      r1,r9
000654  e1a00007          MOV      r0,r7
000658  ebfffffe          BL       __aeabi_uidivmod
00065c  e1a0a001          MOV      r10,r1
;;;473    	if (coarseIndex >= size)
000660  e1550006          CMP      r5,r6
000664  3a000001          BCC      |L1.1648|
;;;474    		status = VL53L0X_ERROR_REF_SPAD_INIT;
000668  e3e08031          MVN      r8,#0x31
00066c  ea000003          B        |L1.1664|
                  |L1.1648|
;;;475    	else
;;;476    		spadArray[coarseIndex] |= (1 << fineIndex);
000670  e7d40005          LDRB     r0,[r4,r5]
000674  e3a01001          MOV      r1,#1
000678  e1800a11          ORR      r0,r0,r1,LSL r10
00067c  e7c40005          STRB     r0,[r4,r5]
                  |L1.1664|
;;;477    
;;;478    	return status;
000680  e1a00008          MOV      r0,r8
;;;479    }
000684  e8bd87f0          POP      {r4-r10,pc}
;;;480    
                          ENDP

                  count_enabled_spads PROC
;;;481    VL53L0X_Error count_enabled_spads(uint8_t spadArray[],
000688  e92d5fff          PUSH     {r0-r12,lr}
;;;482    		uint32_t byteCount, uint32_t maxSpads,
;;;483    		uint32_t *pTotalSpadsEnabled, uint8_t *pIsAperture)
;;;484    {
00068c  e1a07000          MOV      r7,r0
000690  e1a0a001          MOV      r10,r1
000694  e1a0b002          MOV      r11,r2
000698  e1a04003          MOV      r4,r3
;;;485    	VL53L0X_Error status = VL53L0X_ERROR_NONE;
00069c  e3a00000          MOV      r0,#0
0006a0  e58d000c          STR      r0,[sp,#0xc]
;;;486    	uint32_t cSpadsPerByte = 8;
0006a4  e3a00008          MOV      r0,#8
0006a8  e58d0008          STR      r0,[sp,#8]
;;;487    	uint32_t lastByte;
;;;488    	uint32_t lastBit;
;;;489    	uint32_t byteIndex = 0;
0006ac  e3a06000          MOV      r6,#0
;;;490    	uint32_t bitIndex = 0;
0006b0  e3a05000          MOV      r5,#0
;;;491    	uint8_t tempByte;
;;;492    	uint8_t spadTypeIdentified = 0;
0006b4  e3a00000          MOV      r0,#0
0006b8  e58d0000          STR      r0,[sp,#0]
;;;493    
;;;494    	/* The entire array will not be used for spads, therefore the last
;;;495    	 * byte and last bit is determined from the max spads value.
;;;496    	 */
;;;497    
;;;498    	lastByte = maxSpads / cSpadsPerByte;
0006bc  e1a0000b          MOV      r0,r11
0006c0  e59d1008          LDR      r1,[sp,#8]
0006c4  ebfffffe          BL       __aeabi_uidivmod
0006c8  e1a08000          MOV      r8,r0
;;;499    	lastBit = maxSpads % cSpadsPerByte;
0006cc  e1a0000b          MOV      r0,r11
0006d0  e59d1008          LDR      r1,[sp,#8]
0006d4  ebfffffe          BL       __aeabi_uidivmod
0006d8  e58d1004          STR      r1,[sp,#4]
;;;500    
;;;501    	/* Check that the max spads value does not exceed the array bounds. */
;;;502    	if (lastByte >= byteCount)
0006dc  e158000a          CMP      r8,r10
0006e0  3a000001          BCC      |L1.1772|
;;;503    		status = VL53L0X_ERROR_REF_SPAD_INIT;
0006e4  e3e00031          MVN      r0,#0x31
0006e8  e58d000c          STR      r0,[sp,#0xc]
                  |L1.1772|
;;;504    
;;;505    	*pTotalSpadsEnabled = 0;
0006ec  e3a00000          MOV      r0,#0
0006f0  e5840000          STR      r0,[r4,#0]
;;;506    
;;;507    	/* Count the bits enabled in the whole bytes */
;;;508    	for (byteIndex = 0; byteIndex <= (lastByte - 1); byteIndex++) {
0006f4  e3a06000          MOV      r6,#0
0006f8  ea00001c          B        |L1.1904|
                  |L1.1788|
;;;509    		tempByte = spadArray[byteIndex];
0006fc  e7d79006          LDRB     r9,[r7,r6]
;;;510    
;;;511    		for (bitIndex = 0; bitIndex <= cSpadsPerByte; bitIndex++) {
000700  e3a05000          MOV      r5,#0
000704  ea000015          B        |L1.1888|
                  |L1.1800|
;;;512    			if ((tempByte & 0x01) == 1) {
000708  e3190001          TST      r9,#1
00070c  0a000011          BEQ      |L1.1880|
;;;513    				(*pTotalSpadsEnabled)++;
000710  e5940000          LDR      r0,[r4,#0]
000714  e2800001          ADD      r0,r0,#1
000718  e5840000          STR      r0,[r4,#0]
;;;514    
;;;515    				if (!spadTypeIdentified) {
00071c  e59d0000          LDR      r0,[sp,#0]
000720  e3500000          CMP      r0,#0
000724  1a00000b          BNE      |L1.1880|
;;;516    					*pIsAperture = 1;
000728  e3a01001          MOV      r1,#1
00072c  e59d0038          LDR      r0,[sp,#0x38]
000730  e5c01000          STRB     r1,[r0,#0]
;;;517    					if ((byteIndex < 2) && (bitIndex < 4))
000734  e3560002          CMP      r6,#2
000738  2a000004          BCS      |L1.1872|
00073c  e3550004          CMP      r5,#4
000740  2a000002          BCS      |L1.1872|
;;;518    							*pIsAperture = 0;
000744  e3a01000          MOV      r1,#0
000748  e59d0038          LDR      r0,[sp,#0x38]
00074c  e5c01000          STRB     r1,[r0,#0]
                  |L1.1872|
;;;519    					spadTypeIdentified = 1;
000750  e3a00001          MOV      r0,#1
000754  e58d0000          STR      r0,[sp,#0]
                  |L1.1880|
;;;520    				}
;;;521    			}
;;;522    			tempByte >>= 1;
000758  e1a090c9          ASR      r9,r9,#1
00075c  e2855001          ADD      r5,r5,#1              ;511
                  |L1.1888|
000760  e59d0008          LDR      r0,[sp,#8]            ;511
000764  e1550000          CMP      r5,r0                 ;511
000768  9affffe6          BLS      |L1.1800|
00076c  e2866001          ADD      r6,r6,#1              ;508
                  |L1.1904|
000770  e2480001          SUB      r0,r8,#1              ;508
000774  e1500006          CMP      r0,r6                 ;508
000778  2affffdf          BCS      |L1.1788|
;;;523    		}
;;;524    	}
;;;525    
;;;526    	/* Count the number of bits enabled in the last byte accounting
;;;527    	 * for the fact that not all bits in the byte may be used.
;;;528    	 */
;;;529    	tempByte = spadArray[lastByte];
00077c  e7d79008          LDRB     r9,[r7,r8]
;;;530    
;;;531    	for (bitIndex = 0; bitIndex <= lastBit; bitIndex++) {
000780  e3a05000          MOV      r5,#0
000784  ea000005          B        |L1.1952|
                  |L1.1928|
;;;532    		if ((tempByte & 0x01) == 1)
000788  e3190001          TST      r9,#1
00078c  0a000002          BEQ      |L1.1948|
;;;533    			(*pTotalSpadsEnabled)++;
000790  e5940000          LDR      r0,[r4,#0]
000794  e2800001          ADD      r0,r0,#1
000798  e5840000          STR      r0,[r4,#0]
                  |L1.1948|
00079c  e2855001          ADD      r5,r5,#1              ;531
                  |L1.1952|
0007a0  e59d0004          LDR      r0,[sp,#4]            ;531
0007a4  e1550000          CMP      r5,r0                 ;531
0007a8  9afffff6          BLS      |L1.1928|
;;;534    	}
;;;535    
;;;536    	return status;
0007ac  e59d000c          LDR      r0,[sp,#0xc]
0007b0  e28dd010          ADD      sp,sp,#0x10
;;;537    }
0007b4  e8bd9ff0          POP      {r4-r12,pc}
;;;538    
                          ENDP

                  set_ref_spad_map PROC
;;;539    VL53L0X_Error set_ref_spad_map(VL53L0X_DEV Dev, uint8_t *refSpadArray)
0007b8  e92d4070          PUSH     {r4-r6,lr}
;;;540    {
0007bc  e1a05000          MOV      r5,r0
0007c0  e1a04001          MOV      r4,r1
;;;541    	VL53L0X_Error status = VL53L0X_WriteMulti(Dev,
0007c4  e3a03006          MOV      r3,#6
0007c8  e1a02004          MOV      r2,r4
0007cc  e3a010b0          MOV      r1,#0xb0
0007d0  e1a00005          MOV      r0,r5
0007d4  ebfffffe          BL       VL53L0X_WriteMulti
0007d8  e1a06000          MOV      r6,r0
;;;542    				VL53L0X_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_0,
;;;543    				refSpadArray, 6);
;;;544    	return status;
0007dc  e1a00006          MOV      r0,r6
;;;545    }
0007e0  e8bd8070          POP      {r4-r6,pc}
;;;546    
                          ENDP

                  get_ref_spad_map PROC
;;;547    VL53L0X_Error get_ref_spad_map(VL53L0X_DEV Dev, uint8_t *refSpadArray)
0007e4  e92d4070          PUSH     {r4-r6,lr}
;;;548    {
0007e8  e1a05000          MOV      r5,r0
0007ec  e1a04001          MOV      r4,r1
;;;549    	VL53L0X_Error status = VL53L0X_ReadMulti(Dev,
0007f0  e3a03006          MOV      r3,#6
0007f4  e1a02004          MOV      r2,r4
0007f8  e3a010b0          MOV      r1,#0xb0
0007fc  e1a00005          MOV      r0,r5
000800  ebfffffe          BL       VL53L0X_ReadMulti
000804  e1a06000          MOV      r6,r0
;;;550    				VL53L0X_REG_GLOBAL_CONFIG_SPAD_ENABLES_REF_0,
;;;551    				refSpadArray,
;;;552    				6);
;;;553    	return status;
000808  e1a00006          MOV      r0,r6
;;;554    }
00080c  e8bd8070          POP      {r4-r6,pc}
;;;555    
                          ENDP

                  enable_ref_spads PROC
;;;556    VL53L0X_Error enable_ref_spads(VL53L0X_DEV Dev,
000810  e92d4fff          PUSH     {r0-r11,lr}
;;;557    				uint8_t apertureSpads,
;;;558    				uint8_t goodSpadArray[],
;;;559    				uint8_t spadArray[],
;;;560    				uint32_t size,
;;;561    				uint32_t start,
;;;562    				uint32_t offset,
;;;563    				uint32_t spadCount,
;;;564    				uint32_t *lastSpad)
;;;565    {
000814  e24dd014          SUB      sp,sp,#0x14
000818  e1a08001          MOV      r8,r1
00081c  e1a09002          MOV      r9,r2
000820  e1a05003          MOV      r5,r3
000824  e59da048          LDR      r10,[sp,#0x48]
000828  e59db050          LDR      r11,[sp,#0x50]
;;;566    	VL53L0X_Error status = VL53L0X_ERROR_NONE;
00082c  e3a06000          MOV      r6,#0
;;;567    	uint32_t index;
;;;568    	uint32_t i;
;;;569    	int32_t nextGoodSpad = offset;
000830  e58db00c          STR      r11,[sp,#0xc]
;;;570    	uint32_t currentSpad;
;;;571    	uint8_t checkSpadArray[6];
;;;572    
;;;573    	/*
;;;574    	 * This function takes in a spad array which may or may not have SPADS
;;;575    	 * already enabled and appends from a given offset a requested number
;;;576    	 * of new SPAD enables. The 'good spad map' is applied to
;;;577    	 * determine the next SPADs to enable.
;;;578    	 *
;;;579    	 * This function applies to only aperture or only non-aperture spads.
;;;580    	 * Checks are performed to ensure this.
;;;581    	 */
;;;582    
;;;583    	currentSpad = offset;
000834  e1a0700b          MOV      r7,r11
;;;584    	for (index = 0; index < spadCount; index++) {
000838  e3a00000          MOV      r0,#0
00083c  e58d0010          STR      r0,[sp,#0x10]
000840  ea00001a          B        |L1.2224|
                  |L1.2116|
;;;585    		get_next_good_spad(goodSpadArray, size, currentSpad,
000844  e28d300c          ADD      r3,sp,#0xc
000848  e1a02007          MOV      r2,r7
00084c  e1a0100a          MOV      r1,r10
000850  e1a00009          MOV      r0,r9
000854  ebfffffe          BL       get_next_good_spad
;;;586    			&nextGoodSpad);
;;;587    
;;;588    		if (nextGoodSpad == -1) {
000858  e59d000c          LDR      r0,[sp,#0xc]
00085c  e3700001          CMN      r0,#1
000860  1a000001          BNE      |L1.2156|
;;;589    			status = VL53L0X_ERROR_REF_SPAD_INIT;
000864  e3e06031          MVN      r6,#0x31
;;;590    			break;
000868  ea000014          B        |L1.2240|
                  |L1.2156|
;;;591    		}
;;;592    
;;;593    		/* Confirm that the next good SPAD is non-aperture */
;;;594    		if (is_aperture(start + nextGoodSpad) != apertureSpads) {
00086c  e59d104c          LDR      r1,[sp,#0x4c]
000870  e59d200c          LDR      r2,[sp,#0xc]
000874  e0810002          ADD      r0,r1,r2
000878  ebfffffe          BL       is_aperture
00087c  e1500008          CMP      r0,r8
000880  0a000001          BEQ      |L1.2188|
;;;595    			/* if we can't get the required number of good aperture
;;;596    			 * spads from the current quadrant then this is an error
;;;597    			 */
;;;598    			status = VL53L0X_ERROR_REF_SPAD_INIT;
000884  e3e06031          MVN      r6,#0x31
;;;599    			break;
000888  ea00000c          B        |L1.2240|
                  |L1.2188|
;;;600    		}
;;;601    		currentSpad = (uint32_t)nextGoodSpad;
00088c  e59d700c          LDR      r7,[sp,#0xc]
;;;602    		enable_spad_bit(spadArray, size, currentSpad);
000890  e1a02007          MOV      r2,r7
000894  e1a0100a          MOV      r1,r10
000898  e1a00005          MOV      r0,r5
00089c  ebfffffe          BL       enable_spad_bit
;;;603    		currentSpad++;
0008a0  e2877001          ADD      r7,r7,#1
0008a4  e59d0010          LDR      r0,[sp,#0x10]         ;584
0008a8  e2800001          ADD      r0,r0,#1              ;584
0008ac  e58d0010          STR      r0,[sp,#0x10]         ;584
                  |L1.2224|
0008b0  e59d0010          LDR      r0,[sp,#0x10]         ;584
0008b4  e59d1054          LDR      r1,[sp,#0x54]         ;584
0008b8  e1500001          CMP      r0,r1                 ;584
0008bc  3affffe0          BCC      |L1.2116|
                  |L1.2240|
0008c0  e1a00000          MOV      r0,r0                 ;590
;;;604    	}
;;;605    	*lastSpad = currentSpad;
0008c4  e59d0058          LDR      r0,[sp,#0x58]
0008c8  e5807000          STR      r7,[r0,#0]
;;;606    
;;;607    	if (status == VL53L0X_ERROR_NONE)
0008cc  e3560000          CMP      r6,#0
0008d0  1a000003          BNE      |L1.2276|
;;;608    		status = set_ref_spad_map(Dev, spadArray);
0008d4  e1a01005          MOV      r1,r5
0008d8  e59d0014          LDR      r0,[sp,#0x14]
0008dc  ebfffffe          BL       set_ref_spad_map
0008e0  e1a06000          MOV      r6,r0
                  |L1.2276|
;;;609    
;;;610    
;;;611    	if (status == VL53L0X_ERROR_NONE) {
0008e4  e3560000          CMP      r6,#0
0008e8  1a000010          BNE      |L1.2352|
;;;612    		status = get_ref_spad_map(Dev, checkSpadArray);
0008ec  e28d1004          ADD      r1,sp,#4
0008f0  e59d0014          LDR      r0,[sp,#0x14]
0008f4  ebfffffe          BL       get_ref_spad_map
0008f8  e1a06000          MOV      r6,r0
;;;613    
;;;614    		i = 0;
0008fc  e3a04000          MOV      r4,#0
;;;615    
;;;616    		/* Compare spad maps. If not equal report error. */
;;;617    		while (i < size) {
000900  ea000007          B        |L1.2340|
                  |L1.2308|
;;;618    			if (spadArray[i] != checkSpadArray[i]) {
000904  e7d50004          LDRB     r0,[r5,r4]
000908  e28d1004          ADD      r1,sp,#4
00090c  e7d11004          LDRB     r1,[r1,r4]
000910  e1500001          CMP      r0,r1
000914  0a000001          BEQ      |L1.2336|
;;;619    				status = VL53L0X_ERROR_REF_SPAD_INIT;
000918  e3e06031          MVN      r6,#0x31
;;;620    				break;
00091c  ea000002          B        |L1.2348|
                  |L1.2336|
;;;621    			}
;;;622    			i++;
000920  e2844001          ADD      r4,r4,#1
                  |L1.2340|
000924  e154000a          CMP      r4,r10                ;617
000928  3afffff5          BCC      |L1.2308|
                  |L1.2348|
00092c  e1a00000          MOV      r0,r0                 ;620
                  |L1.2352|
;;;623    		}
;;;624    	}
;;;625    	return status;
000930  e1a00006          MOV      r0,r6
000934  e28dd024          ADD      sp,sp,#0x24
;;;626    }
000938  e8bd8ff0          POP      {r4-r11,pc}
;;;627    
                          ENDP

                  perform_ref_signal_measurement PROC
;;;628    
;;;629    VL53L0X_Error perform_ref_signal_measurement(VL53L0X_DEV Dev,
00093c  e92d40f0          PUSH     {r4-r7,lr}
;;;630    		uint16_t *refSignalRate)
;;;631    {
000940  e24dd01c          SUB      sp,sp,#0x1c
000944  e1a05000          MOV      r5,r0
000948  e1a06001          MOV      r6,r1
;;;632    	VL53L0X_Error status = VL53L0X_ERROR_NONE;
00094c  e3a04000          MOV      r4,#0
;;;633    	VL53L0X_RangingMeasurementData_t rangingMeasurementData;
;;;634    
;;;635    	uint8_t SequenceConfig = 0;
000950  e3a07000          MOV      r7,#0
;;;636    
;;;637    	/* store the value of the sequence config,
;;;638    	 * this will be reset before the end of the function
;;;639    	 */
;;;640    
;;;641    	SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
000954  e5d57130          LDRB     r7,[r5,#0x130]
;;;642    
;;;643    	/*
;;;644    	 * This function performs a reference signal rate measurement.
;;;645    	 */
;;;646    	if (status == VL53L0X_ERROR_NONE)
000958  e3540000          CMP      r4,#0
00095c  1a000004          BNE      |L1.2420|
;;;647    		status = VL53L0X_WrByte(Dev,
000960  e3a020c0          MOV      r2,#0xc0
000964  e3a01001          MOV      r1,#1
000968  e1a00005          MOV      r0,r5
00096c  ebfffffe          BL       VL53L0X_WrByte
000970  e1a04000          MOV      r4,r0
                  |L1.2420|
;;;648    			VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, 0xC0);
;;;649    
;;;650    	if (status == VL53L0X_ERROR_NONE)
000974  e3540000          CMP      r4,#0
000978  1a000003          BNE      |L1.2444|
;;;651    		status = VL53L0X_PerformSingleRangingMeasurement(Dev,
00097c  e1a0100d          MOV      r1,sp
000980  e1a00005          MOV      r0,r5
000984  ebfffffe          BL       VL53L0X_PerformSingleRangingMeasurement
000988  e1a04000          MOV      r4,r0
                  |L1.2444|
;;;652    				&rangingMeasurementData);
;;;653    
;;;654    	if (status == VL53L0X_ERROR_NONE)
00098c  e3540000          CMP      r4,#0
000990  1a000004          BNE      |L1.2472|
;;;655    		status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
000994  e3a02001          MOV      r2,#1
000998  e3a010ff          MOV      r1,#0xff
00099c  e1a00005          MOV      r0,r5
0009a0  ebfffffe          BL       VL53L0X_WrByte
0009a4  e1a04000          MOV      r4,r0
                  |L1.2472|
;;;656    
;;;657    	if (status == VL53L0X_ERROR_NONE)
0009a8  e3540000          CMP      r4,#0
0009ac  1a000004          BNE      |L1.2500|
;;;658    		status = VL53L0X_RdWord(Dev,
0009b0  e1a02006          MOV      r2,r6
0009b4  e3a010b6          MOV      r1,#0xb6
0009b8  e1a00005          MOV      r0,r5
0009bc  ebfffffe          BL       VL53L0X_RdWord
0009c0  e1a04000          MOV      r4,r0
                  |L1.2500|
;;;659    			VL53L0X_REG_RESULT_PEAK_SIGNAL_RATE_REF,
;;;660    			refSignalRate);
;;;661    
;;;662    	if (status == VL53L0X_ERROR_NONE)
0009c4  e3540000          CMP      r4,#0
0009c8  1a000004          BNE      |L1.2528|
;;;663    		status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
0009cc  e3a02000          MOV      r2,#0
0009d0  e3a010ff          MOV      r1,#0xff
0009d4  e1a00005          MOV      r0,r5
0009d8  ebfffffe          BL       VL53L0X_WrByte
0009dc  e1a04000          MOV      r4,r0
                  |L1.2528|
;;;664    
;;;665    	if (status == VL53L0X_ERROR_NONE) {
0009e0  e3540000          CMP      r4,#0
0009e4  1a000007          BNE      |L1.2568|
;;;666    		/* restore the previous Sequence Config */
;;;667    		status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
0009e8  e1a02007          MOV      r2,r7
0009ec  e3a01001          MOV      r1,#1
0009f0  e1a00005          MOV      r0,r5
0009f4  ebfffffe          BL       VL53L0X_WrByte
0009f8  e1a04000          MOV      r4,r0
;;;668    				SequenceConfig);
;;;669    		if (status == VL53L0X_ERROR_NONE)
0009fc  e3540000          CMP      r4,#0
000a00  1a000000          BNE      |L1.2568|
;;;670    			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
000a04  e5c57130          STRB     r7,[r5,#0x130]
                  |L1.2568|
;;;671    	}
;;;672    
;;;673    	return status;
000a08  e1a00004          MOV      r0,r4
000a0c  e28dd01c          ADD      sp,sp,#0x1c
;;;674    }
000a10  e8bd80f0          POP      {r4-r7,pc}
;;;675    
                          ENDP

                  VL53L0X_ref_calibration_io PROC
;;;1084   
;;;1085   VL53L0X_Error VL53L0X_ref_calibration_io(VL53L0X_DEV Dev, uint8_t read_not_write,
000a14  e92d4ff8          PUSH     {r3-r11,lr}
;;;1086   	uint8_t VhvSettings, uint8_t PhaseCal,
;;;1087   	uint8_t *pVhvSettings, uint8_t *pPhaseCal,
;;;1088   	const uint8_t vhv_enable, const uint8_t phase_enable)
;;;1089   {
000a18  e1a08000          MOV      r8,r0
000a1c  e1a05001          MOV      r5,r1
000a20  e1a09002          MOV      r9,r2
000a24  e1a0a003          MOV      r10,r3
000a28  e1cd63d0          LDRD     r6,r7,[sp,#0x30]
000a2c  e59db02c          LDR      r11,[sp,#0x2c]
;;;1090   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000a30  e3a04000          MOV      r4,#0
;;;1091   	uint8_t PhaseCalint = 0;
000a34  e3a00000          MOV      r0,#0
000a38  e58d0000          STR      r0,[sp,#0]
;;;1092   
;;;1093   	/* Read VHV from device */
;;;1094   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x01);
000a3c  e3a02001          MOV      r2,#1
000a40  e3a010ff          MOV      r1,#0xff
000a44  e1a00008          MOV      r0,r8
000a48  ebfffffe          BL       VL53L0X_WrByte
000a4c  e1844000          ORR      r4,r4,r0
;;;1095   	Status |= VL53L0X_WrByte(Dev, 0x00, 0x00);
000a50  e3a02000          MOV      r2,#0
000a54  e1a01002          MOV      r1,r2
000a58  e1a00008          MOV      r0,r8
000a5c  ebfffffe          BL       VL53L0X_WrByte
000a60  e1844000          ORR      r4,r4,r0
;;;1096   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
000a64  e3a02000          MOV      r2,#0
000a68  e3a010ff          MOV      r1,#0xff
000a6c  e1a00008          MOV      r0,r8
000a70  ebfffffe          BL       VL53L0X_WrByte
000a74  e1844000          ORR      r4,r4,r0
;;;1097   
;;;1098   	if (read_not_write) {
000a78  e3550000          CMP      r5,#0
000a7c  0a00000e          BEQ      |L1.2748|
;;;1099   		if (vhv_enable)
000a80  e3560000          CMP      r6,#0
000a84  0a000004          BEQ      |L1.2716|
;;;1100   			Status |= VL53L0X_RdByte(Dev, 0xCB, pVhvSettings);
000a88  e3a010cb          MOV      r1,#0xcb
000a8c  e1a00008          MOV      r0,r8
000a90  e59d2028          LDR      r2,[sp,#0x28]
000a94  ebfffffe          BL       VL53L0X_RdByte
000a98  e1844000          ORR      r4,r4,r0
                  |L1.2716|
;;;1101   		if (phase_enable)
000a9c  e3570000          CMP      r7,#0
000aa0  0a000014          BEQ      |L1.2808|
;;;1102   			Status |= VL53L0X_RdByte(Dev, 0xEE, &PhaseCalint);
000aa4  e1a0200d          MOV      r2,sp
000aa8  e3a010ee          MOV      r1,#0xee
000aac  e1a00008          MOV      r0,r8
000ab0  ebfffffe          BL       VL53L0X_RdByte
000ab4  e1844000          ORR      r4,r4,r0
000ab8  ea00000e          B        |L1.2808|
                  |L1.2748|
;;;1103   	} else {
;;;1104   		if (vhv_enable)
000abc  e3560000          CMP      r6,#0
000ac0  0a000004          BEQ      |L1.2776|
;;;1105   			Status |= VL53L0X_WrByte(Dev, 0xCB, VhvSettings);
000ac4  e1a02009          MOV      r2,r9
000ac8  e3a010cb          MOV      r1,#0xcb
000acc  e1a00008          MOV      r0,r8
000ad0  ebfffffe          BL       VL53L0X_WrByte
000ad4  e1844000          ORR      r4,r4,r0
                  |L1.2776|
;;;1106   		if (phase_enable)
000ad8  e3570000          CMP      r7,#0
000adc  0a000005          BEQ      |L1.2808|
;;;1107   			Status |= VL53L0X_UpdateByte(Dev, 0xEE, 0x80, PhaseCal);
000ae0  e1a0300a          MOV      r3,r10
000ae4  e3a02080          MOV      r2,#0x80
000ae8  e3a010ee          MOV      r1,#0xee
000aec  e1a00008          MOV      r0,r8
000af0  ebfffffe          BL       VL53L0X_UpdateByte
000af4  e1844000          ORR      r4,r4,r0
                  |L1.2808|
;;;1108   	}
;;;1109   
;;;1110   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x01);
000af8  e3a02001          MOV      r2,#1
000afc  e3a010ff          MOV      r1,#0xff
000b00  e1a00008          MOV      r0,r8
000b04  ebfffffe          BL       VL53L0X_WrByte
000b08  e1844000          ORR      r4,r4,r0
;;;1111   	Status |= VL53L0X_WrByte(Dev, 0x00, 0x01);
000b0c  e3a02001          MOV      r2,#1
000b10  e3a01000          MOV      r1,#0
000b14  e1a00008          MOV      r0,r8
000b18  ebfffffe          BL       VL53L0X_WrByte
000b1c  e1844000          ORR      r4,r4,r0
;;;1112   	Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
000b20  e3a02000          MOV      r2,#0
000b24  e3a010ff          MOV      r1,#0xff
000b28  e1a00008          MOV      r0,r8
000b2c  ebfffffe          BL       VL53L0X_WrByte
000b30  e1844000          ORR      r4,r4,r0
;;;1113   
;;;1114   	*pPhaseCal = (uint8_t)(PhaseCalint&0xEF);
000b34  e5dd0000          LDRB     r0,[sp,#0]
000b38  e20000ef          AND      r0,r0,#0xef
000b3c  e5cb0000          STRB     r0,[r11,#0]
;;;1115   
;;;1116   	return Status;
000b40  e1a00004          MOV      r0,r4
;;;1117   }
000b44  e8bd8ff8          POP      {r3-r11,pc}
;;;1118   
                          ENDP

                  VL53L0X_perform_single_ref_calibration PROC
;;;1061   
;;;1062   VL53L0X_Error VL53L0X_perform_single_ref_calibration(VL53L0X_DEV Dev,
000b48  e92d4070          PUSH     {r4-r6,lr}
;;;1063   		uint8_t vhv_init_byte)
;;;1064   {
000b4c  e1a06000          MOV      r6,r0
000b50  e1a05001          MOV      r5,r1
;;;1065   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000b54  e3a04000          MOV      r4,#0
;;;1066   
;;;1067   	if (Status == VL53L0X_ERROR_NONE)
000b58  e3540000          CMP      r4,#0
000b5c  1a000004          BNE      |L1.2932|
;;;1068   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSRANGE_START,
000b60  e3852001          ORR      r2,r5,#1
000b64  e3a01000          MOV      r1,#0
000b68  e1a00006          MOV      r0,r6
000b6c  ebfffffe          BL       VL53L0X_WrByte
000b70  e1a04000          MOV      r4,r0
                  |L1.2932|
;;;1069   				VL53L0X_REG_SYSRANGE_MODE_START_STOP |
;;;1070   				vhv_init_byte);
;;;1071   
;;;1072   	if (Status == VL53L0X_ERROR_NONE)
000b74  e3540000          CMP      r4,#0
000b78  1a000002          BNE      |L1.2952|
;;;1073   		Status = VL53L0X_measurement_poll_for_completion(Dev);
000b7c  e1a00006          MOV      r0,r6
000b80  ebfffffe          BL       VL53L0X_measurement_poll_for_completion
000b84  e1a04000          MOV      r4,r0
                  |L1.2952|
;;;1074   
;;;1075   	if (Status == VL53L0X_ERROR_NONE)
000b88  e3540000          CMP      r4,#0
000b8c  1a000003          BNE      |L1.2976|
;;;1076   		Status = VL53L0X_ClearInterruptMask(Dev, 0);
000b90  e3a01000          MOV      r1,#0
000b94  e1a00006          MOV      r0,r6
000b98  ebfffffe          BL       VL53L0X_ClearInterruptMask
000b9c  e1a04000          MOV      r4,r0
                  |L1.2976|
;;;1077   
;;;1078   	if (Status == VL53L0X_ERROR_NONE)
000ba0  e3540000          CMP      r4,#0
000ba4  1a000004          BNE      |L1.3004|
;;;1079   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSRANGE_START, 0x00);
000ba8  e3a02000          MOV      r2,#0
000bac  e1a01002          MOV      r1,r2
000bb0  e1a00006          MOV      r0,r6
000bb4  ebfffffe          BL       VL53L0X_WrByte
000bb8  e1a04000          MOV      r4,r0
                  |L1.3004|
;;;1080   
;;;1081   	return Status;
000bbc  e1a00004          MOV      r0,r4
;;;1082   }
000bc0  e8bd8070          POP      {r4-r6,pc}
;;;1083   
                          ENDP

                  VL53L0X_perform_phase_calibration PROC
;;;1164   
;;;1165   VL53L0X_Error VL53L0X_perform_phase_calibration(VL53L0X_DEV Dev,
000bc4  e92d4ff0          PUSH     {r4-r11,lr}
;;;1166   	uint8_t *pPhaseCal, const uint8_t get_data_enable,
;;;1167   	const uint8_t restore_config)
;;;1168   {
000bc8  e24dd014          SUB      sp,sp,#0x14
000bcc  e1a05000          MOV      r5,r0
000bd0  e1a06001          MOV      r6,r1
000bd4  e1a08002          MOV      r8,r2
000bd8  e1a07003          MOV      r7,r3
;;;1169   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000bdc  e3a04000          MOV      r4,#0
;;;1170   	uint8_t SequenceConfig = 0;
000be0  e3a09000          MOV      r9,#0
;;;1171   	uint8_t VhvSettings = 0;
000be4  e3a0a000          MOV      r10,#0
;;;1172   	uint8_t PhaseCal = 0;
000be8  e3a0b000          MOV      r11,#0
;;;1173   	uint8_t VhvSettingsint;
;;;1174   
;;;1175   	/* store the value of the sequence config,
;;;1176   	 * this will be reset before the end of the function
;;;1177   	 */
;;;1178   
;;;1179   	if (restore_config)
000bec  e3570000          CMP      r7,#0
000bf0  0a000000          BEQ      |L1.3064|
;;;1180   		SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
000bf4  e5d59130          LDRB     r9,[r5,#0x130]
                  |L1.3064|
;;;1181   
;;;1182   	/* Run PhaseCal */
;;;1183   	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, 0x02);
000bf8  e3a02002          MOV      r2,#2
000bfc  e3a01001          MOV      r1,#1
000c00  e1a00005          MOV      r0,r5
000c04  ebfffffe          BL       VL53L0X_WrByte
000c08  e1a04000          MOV      r4,r0
;;;1184   
;;;1185   	if (Status == VL53L0X_ERROR_NONE)
000c0c  e3540000          CMP      r4,#0
000c10  1a000003          BNE      |L1.3108|
;;;1186   		Status = VL53L0X_perform_single_ref_calibration(Dev, 0x0);
000c14  e3a01000          MOV      r1,#0
000c18  e1a00005          MOV      r0,r5
000c1c  ebfffffe          BL       VL53L0X_perform_single_ref_calibration
000c20  e1a04000          MOV      r4,r0
                  |L1.3108|
;;;1187   
;;;1188   	/* Read PhaseCal from device */
;;;1189   	if ((Status == VL53L0X_ERROR_NONE) && (get_data_enable == 1)) {
000c24  e3540000          CMP      r4,#0
000c28  1a00000e          BNE      |L1.3176|
000c2c  e3580001          CMP      r8,#1
000c30  1a00000c          BNE      |L1.3176|
;;;1190   		Status = VL53L0X_ref_calibration_io(Dev, 1,
000c34  e3a00001          MOV      r0,#1
000c38  e3a01000          MOV      r1,#0
000c3c  e28d2010          ADD      r2,sp,#0x10
000c40  e1a0300b          MOV      r3,r11
000c44  e88d0044          STM      sp,{r2,r6}
000c48  e1a0200a          MOV      r2,r10
000c4c  e58d000c          STR      r0,[sp,#0xc]
000c50  e58d1008          STR      r1,[sp,#8]
000c54  e1a01000          MOV      r1,r0
000c58  e1a00005          MOV      r0,r5
000c5c  ebfffffe          BL       VL53L0X_ref_calibration_io
000c60  e1a04000          MOV      r4,r0
000c64  ea000001          B        |L1.3184|
                  |L1.3176|
;;;1191   			VhvSettings, PhaseCal, /* Not used here */
;;;1192   			&VhvSettingsint, pPhaseCal,
;;;1193   			0, 1);
;;;1194   	} else
;;;1195   		*pPhaseCal = 0;
000c68  e3a00000          MOV      r0,#0
000c6c  e5c60000          STRB     r0,[r6,#0]
                  |L1.3184|
;;;1196   
;;;1197   
;;;1198   	if ((Status == VL53L0X_ERROR_NONE) && restore_config) {
000c70  e3540000          CMP      r4,#0
000c74  1a000009          BNE      |L1.3232|
000c78  e3570000          CMP      r7,#0
000c7c  0a000007          BEQ      |L1.3232|
;;;1199   		/* restore the previous Sequence Config */
;;;1200   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
000c80  e1a02009          MOV      r2,r9
000c84  e3a01001          MOV      r1,#1
000c88  e1a00005          MOV      r0,r5
000c8c  ebfffffe          BL       VL53L0X_WrByte
000c90  e1a04000          MOV      r4,r0
;;;1201   				SequenceConfig);
;;;1202   		if (Status == VL53L0X_ERROR_NONE)
000c94  e3540000          CMP      r4,#0
000c98  1a000000          BNE      |L1.3232|
;;;1203   			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
000c9c  e5c59130          STRB     r9,[r5,#0x130]
                  |L1.3232|
;;;1204   
;;;1205   	}
;;;1206   
;;;1207   	return Status;
000ca0  e1a00004          MOV      r0,r4
000ca4  e28dd014          ADD      sp,sp,#0x14
;;;1208   }
000ca8  e8bd8ff0          POP      {r4-r11,pc}
;;;1209   
                          ENDP

                  VL53L0X_perform_vhv_calibration PROC
;;;1119   
;;;1120   VL53L0X_Error VL53L0X_perform_vhv_calibration(VL53L0X_DEV Dev,
000cac  e92d4ff0          PUSH     {r4-r11,lr}
;;;1121   	uint8_t *pVhvSettings, const uint8_t get_data_enable,
;;;1122   	const uint8_t restore_config)
;;;1123   {
000cb0  e24dd014          SUB      sp,sp,#0x14
000cb4  e1a05000          MOV      r5,r0
000cb8  e1a06001          MOV      r6,r1
000cbc  e1a08002          MOV      r8,r2
000cc0  e1a07003          MOV      r7,r3
;;;1124   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000cc4  e3a04000          MOV      r4,#0
;;;1125   	uint8_t SequenceConfig = 0;
000cc8  e3a09000          MOV      r9,#0
;;;1126   	uint8_t VhvSettings = 0;
000ccc  e3a0a000          MOV      r10,#0
;;;1127   	uint8_t PhaseCal = 0;
000cd0  e3a0b000          MOV      r11,#0
;;;1128   	uint8_t PhaseCalInt = 0;
000cd4  e3a00000          MOV      r0,#0
000cd8  e58d0010          STR      r0,[sp,#0x10]
;;;1129   
;;;1130   	/* store the value of the sequence config,
;;;1131   	 * this will be reset before the end of the function
;;;1132   	 */
;;;1133   
;;;1134   	if (restore_config)
000cdc  e3570000          CMP      r7,#0
000ce0  0a000000          BEQ      |L1.3304|
;;;1135   		SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
000ce4  e5d59130          LDRB     r9,[r5,#0x130]
                  |L1.3304|
;;;1136   
;;;1137   	/* Run VHV */
;;;1138   	Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG, 0x01);
000ce8  e3a02001          MOV      r2,#1
000cec  e1a01002          MOV      r1,r2
000cf0  e1a00005          MOV      r0,r5
000cf4  ebfffffe          BL       VL53L0X_WrByte
000cf8  e1a04000          MOV      r4,r0
;;;1139   
;;;1140   	if (Status == VL53L0X_ERROR_NONE)
000cfc  e3540000          CMP      r4,#0
000d00  1a000003          BNE      |L1.3348|
;;;1141   		Status = VL53L0X_perform_single_ref_calibration(Dev, 0x40);
000d04  e3a01040          MOV      r1,#0x40
000d08  e1a00005          MOV      r0,r5
000d0c  ebfffffe          BL       VL53L0X_perform_single_ref_calibration
000d10  e1a04000          MOV      r4,r0
                  |L1.3348|
;;;1142   
;;;1143   	/* Read VHV from device */
;;;1144   	if ((Status == VL53L0X_ERROR_NONE) && (get_data_enable == 1)) {
000d14  e3540000          CMP      r4,#0
000d18  1a00000e          BNE      |L1.3416|
000d1c  e3580001          CMP      r8,#1
000d20  1a00000c          BNE      |L1.3416|
;;;1145   		Status = VL53L0X_ref_calibration_io(Dev, 1,
000d24  e3a00000          MOV      r0,#0
000d28  e3a01001          MOV      r1,#1
000d2c  e28d2010          ADD      r2,sp,#0x10
000d30  e1a0300b          MOV      r3,r11
000d34  e58d2004          STR      r2,[sp,#4]
000d38  e1a0200a          MOV      r2,r10
000d3c  e58d000c          STR      r0,[sp,#0xc]
000d40  e1a00005          MOV      r0,r5
000d44  e58d1008          STR      r1,[sp,#8]
000d48  e58d6000          STR      r6,[sp,#0]
000d4c  ebfffffe          BL       VL53L0X_ref_calibration_io
000d50  e1a04000          MOV      r4,r0
000d54  ea000001          B        |L1.3424|
                  |L1.3416|
;;;1146   			VhvSettings, PhaseCal, /* Not used here */
;;;1147   			pVhvSettings, &PhaseCalInt,
;;;1148   			1, 0);
;;;1149   	} else
;;;1150   		*pVhvSettings = 0;
000d58  e3a00000          MOV      r0,#0
000d5c  e5c60000          STRB     r0,[r6,#0]
                  |L1.3424|
;;;1151   
;;;1152   
;;;1153   	if ((Status == VL53L0X_ERROR_NONE) && restore_config) {
000d60  e3540000          CMP      r4,#0
000d64  1a000009          BNE      |L1.3472|
000d68  e3570000          CMP      r7,#0
000d6c  0a000007          BEQ      |L1.3472|
;;;1154   		/* restore the previous Sequence Config */
;;;1155   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
000d70  e1a02009          MOV      r2,r9
000d74  e3a01001          MOV      r1,#1
000d78  e1a00005          MOV      r0,r5
000d7c  ebfffffe          BL       VL53L0X_WrByte
000d80  e1a04000          MOV      r4,r0
;;;1156   				SequenceConfig);
;;;1157   		if (Status == VL53L0X_ERROR_NONE)
000d84  e3540000          CMP      r4,#0
000d88  1a000000          BNE      |L1.3472|
;;;1158   			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
000d8c  e5c59130          STRB     r9,[r5,#0x130]
                  |L1.3472|
;;;1159   
;;;1160   	}
;;;1161   
;;;1162   	return Status;
000d90  e1a00004          MOV      r0,r4
000d94  e28dd014          ADD      sp,sp,#0x14
;;;1163   }
000d98  e8bd8ff0          POP      {r4-r11,pc}
;;;1164   
                          ENDP

                  VL53L0X_perform_ref_calibration PROC
;;;1209   
;;;1210   VL53L0X_Error VL53L0X_perform_ref_calibration(VL53L0X_DEV Dev,
000d9c  e92d47f0          PUSH     {r4-r10,lr}
;;;1211   	uint8_t *pVhvSettings, uint8_t *pPhaseCal, uint8_t get_data_enable)
;;;1212   {
000da0  e1a05000          MOV      r5,r0
000da4  e1a09001          MOV      r9,r1
000da8  e1a06002          MOV      r6,r2
000dac  e1a07003          MOV      r7,r3
;;;1213   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000db0  e3a04000          MOV      r4,#0
;;;1214   	uint8_t SequenceConfig = 0;
000db4  e3a08000          MOV      r8,#0
;;;1215   
;;;1216   	/* store the value of the sequence config,
;;;1217   	 * this will be reset before the end of the function
;;;1218   	 */
;;;1219   
;;;1220   	SequenceConfig = PALDevDataGet(Dev, SequenceConfig);
000db8  e5d58130          LDRB     r8,[r5,#0x130]
;;;1221   
;;;1222   	/* In the following function we don't save the config to optimize
;;;1223   	 * writes on device. Config is saved and restored only once. */
;;;1224   	Status = VL53L0X_perform_vhv_calibration(
000dbc  e3a03000          MOV      r3,#0
000dc0  e1a02007          MOV      r2,r7
000dc4  e1a01009          MOV      r1,r9
000dc8  e1a00005          MOV      r0,r5
000dcc  ebfffffe          BL       VL53L0X_perform_vhv_calibration
000dd0  e1a04000          MOV      r4,r0
;;;1225   			Dev, pVhvSettings, get_data_enable, 0);
;;;1226   
;;;1227   
;;;1228   	if (Status == VL53L0X_ERROR_NONE)
000dd4  e3540000          CMP      r4,#0
000dd8  1a000005          BNE      |L1.3572|
;;;1229   		Status = VL53L0X_perform_phase_calibration(
000ddc  e3a03000          MOV      r3,#0
000de0  e1a02007          MOV      r2,r7
000de4  e1a01006          MOV      r1,r6
000de8  e1a00005          MOV      r0,r5
000dec  ebfffffe          BL       VL53L0X_perform_phase_calibration
000df0  e1a04000          MOV      r4,r0
                  |L1.3572|
;;;1230   			Dev, pPhaseCal, get_data_enable, 0);
;;;1231   
;;;1232   
;;;1233   	if (Status == VL53L0X_ERROR_NONE) {
000df4  e3540000          CMP      r4,#0
000df8  1a000007          BNE      |L1.3612|
;;;1234   		/* restore the previous Sequence Config */
;;;1235   		Status = VL53L0X_WrByte(Dev, VL53L0X_REG_SYSTEM_SEQUENCE_CONFIG,
000dfc  e1a02008          MOV      r2,r8
000e00  e3a01001          MOV      r1,#1
000e04  e1a00005          MOV      r0,r5
000e08  ebfffffe          BL       VL53L0X_WrByte
000e0c  e1a04000          MOV      r4,r0
;;;1236   				SequenceConfig);
;;;1237   		if (Status == VL53L0X_ERROR_NONE)
000e10  e3540000          CMP      r4,#0
000e14  1a000000          BNE      |L1.3612|
;;;1238   			PALDevDataSet(Dev, SequenceConfig, SequenceConfig);
000e18  e5c58130          STRB     r8,[r5,#0x130]
                  |L1.3612|
;;;1239   
;;;1240   	}
;;;1241   
;;;1242   	return Status;
000e1c  e1a00004          MOV      r0,r4
;;;1243   }
000e20  e8bd87f0          POP      {r4-r10,pc}
;;;1244   
                          ENDP

                  VL53L0X_perform_ref_spad_management PROC
;;;675    
;;;676    VL53L0X_Error VL53L0X_perform_ref_spad_management(VL53L0X_DEV Dev,
000e24  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;677    				uint32_t *refSpadCount,
;;;678    				uint8_t *isApertureSpads)
;;;679    {
000e28  e24dd050          SUB      sp,sp,#0x50
000e2c  e1a04000          MOV      r4,r0
;;;680    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000e30  e3a05000          MOV      r5,#0
;;;681    	uint8_t lastSpadArray[6];
;;;682    	uint8_t startSelect = 0xB4;
000e34  e3a0b0b4          MOV      r11,#0xb4
;;;683    	uint32_t minimumSpadCount = 3;
000e38  e3a00003          MOV      r0,#3
000e3c  e58d0044          STR      r0,[sp,#0x44]
;;;684    	uint32_t maxSpadCount = 44;
000e40  e3a0002c          MOV      r0,#0x2c
000e44  e58d0040          STR      r0,[sp,#0x40]
;;;685    	uint32_t currentSpadIndex = 0;
000e48  e3a06000          MOV      r6,#0
;;;686    	uint32_t lastSpadIndex = 0;
000e4c  e3a00000          MOV      r0,#0
000e50  e58d003c          STR      r0,[sp,#0x3c]
;;;687    	int32_t nextGoodSpad = 0;
000e54  e58d0038          STR      r0,[sp,#0x38]
;;;688    	uint16_t targetRefRate = 0x0A00; /* 20 MCPS in 9:7 format */
000e58  e3a07c0a          MOV      r7,#0xa00
;;;689    	uint16_t peakSignalRateRef;
;;;690    	uint32_t needAptSpads = 0;
000e5c  e3a08000          MOV      r8,#0
;;;691    	uint32_t index = 0;
000e60  e3a09000          MOV      r9,#0
;;;692    	uint32_t spadArraySize = 6;
000e64  e3a0a006          MOV      r10,#6
;;;693    	uint32_t signalRateDiff = 0;
000e68  e58d0030          STR      r0,[sp,#0x30]
;;;694    	uint32_t lastSignalRateDiff = 0;
000e6c  e58d002c          STR      r0,[sp,#0x2c]
;;;695    	uint8_t complete = 0;
000e70  e58d0028          STR      r0,[sp,#0x28]
;;;696    	uint8_t VhvSettings = 0;
000e74  e58d0024          STR      r0,[sp,#0x24]
;;;697    	uint8_t PhaseCal = 0;
000e78  e58d0020          STR      r0,[sp,#0x20]
;;;698    	uint32_t refSpadCount_int = 0;
000e7c  e58d001c          STR      r0,[sp,#0x1c]
;;;699    	uint8_t	 isApertureSpads_int = 0;
000e80  e58d0018          STR      r0,[sp,#0x18]
;;;700    
;;;701    	/*
;;;702    	 * The reference SPAD initialization procedure determines the minimum
;;;703    	 * amount of reference spads to be enables to achieve a target reference
;;;704    	 * signal rate and should be performed once during initialization.
;;;705    	 *
;;;706    	 * Either aperture or non-aperture spads are applied but never both.
;;;707    	 * Firstly non-aperture spads are set, begining with 5 spads, and
;;;708    	 * increased one spad at a time until the closest measurement to the
;;;709    	 * target rate is achieved.
;;;710    	 *
;;;711    	 * If the target rate is exceeded when 5 non-aperture spads are enabled,
;;;712    	 * initialization is performed instead with aperture spads.
;;;713    	 *
;;;714    	 * When setting spads, a 'Good Spad Map' is applied.
;;;715    	 *
;;;716    	 * This procedure operates within a SPAD window of interest of a maximum
;;;717    	 * 44 spads.
;;;718    	 * The start point is currently fixed to 180, which lies towards the end
;;;719    	 * of the non-aperture quadrant and runs in to the adjacent aperture
;;;720    	 * quadrant.
;;;721    	 */
;;;722    
;;;723    
;;;724    	targetRefRate = PALDevDataGet(Dev, targetRefRate);
000e84  e3a00f4f          MOV      r0,#0x13c
000e88  e19070b4          LDRH     r7,[r0,r4]
;;;725    
;;;726    	/*
;;;727    	 * Initialize Spad arrays.
;;;728    	 * Currently the good spad map is initialised to 'All good'.
;;;729    	 * This is a short term implementation. The good spad map will be
;;;730    	 * provided as an input.
;;;731    	 * Note that there are 6 bytes. Only the first 44 bits will be used to
;;;732    	 * represent spads.
;;;733    	 */
;;;734    	for (index = 0; index < spadArraySize; index++)
000e8c  e1a00000          MOV      r0,r0
000e90  ea000003          B        |L1.3748|
                  |L1.3732|
;;;735    		Dev->Data.SpadData.RefSpadEnables[index] = 0;
000e94  e3a00000          MOV      r0,#0
000e98  e2841f49          ADD      r1,r4,#0x124
000e9c  e7c10009          STRB     r0,[r1,r9]
000ea0  e2899001          ADD      r9,r9,#1              ;734
                  |L1.3748|
000ea4  e159000a          CMP      r9,r10                ;734
000ea8  3afffff9          BCC      |L1.3732|
;;;736    
;;;737    
;;;738    	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
000eac  e3a02001          MOV      r2,#1
000eb0  e3a010ff          MOV      r1,#0xff
000eb4  e1a00004          MOV      r0,r4
000eb8  ebfffffe          BL       VL53L0X_WrByte
000ebc  e1a05000          MOV      r5,r0
;;;739    
;;;740    	if (Status == VL53L0X_ERROR_NONE)
000ec0  e3550000          CMP      r5,#0
000ec4  1a000004          BNE      |L1.3804|
;;;741    		Status = VL53L0X_WrByte(Dev,
000ec8  e3a02000          MOV      r2,#0
000ecc  e3a0104f          MOV      r1,#0x4f
000ed0  e1a00004          MOV      r0,r4
000ed4  ebfffffe          BL       VL53L0X_WrByte
000ed8  e1a05000          MOV      r5,r0
                  |L1.3804|
;;;742    			VL53L0X_REG_DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
;;;743    
;;;744    	if (Status == VL53L0X_ERROR_NONE)
000edc  e3550000          CMP      r5,#0
000ee0  1a000004          BNE      |L1.3832|
;;;745    		Status = VL53L0X_WrByte(Dev,
000ee4  e3a0202c          MOV      r2,#0x2c
000ee8  e3a0104e          MOV      r1,#0x4e
000eec  e1a00004          MOV      r0,r4
000ef0  ebfffffe          BL       VL53L0X_WrByte
000ef4  e1a05000          MOV      r5,r0
                  |L1.3832|
;;;746    			VL53L0X_REG_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
;;;747    
;;;748    	if (Status == VL53L0X_ERROR_NONE)
000ef8  e3550000          CMP      r5,#0
000efc  1a000004          BNE      |L1.3860|
;;;749    		Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
000f00  e3a02000          MOV      r2,#0
000f04  e3a010ff          MOV      r1,#0xff
000f08  e1a00004          MOV      r0,r4
000f0c  ebfffffe          BL       VL53L0X_WrByte
000f10  e1a05000          MOV      r5,r0
                  |L1.3860|
;;;750    
;;;751    	if (Status == VL53L0X_ERROR_NONE)
000f14  e3550000          CMP      r5,#0
000f18  1a000004          BNE      |L1.3888|
;;;752    		Status = VL53L0X_WrByte(Dev,
000f1c  e1a0200b          MOV      r2,r11
000f20  e3a010b6          MOV      r1,#0xb6
000f24  e1a00004          MOV      r0,r4
000f28  ebfffffe          BL       VL53L0X_WrByte
000f2c  e1a05000          MOV      r5,r0
                  |L1.3888|
;;;753    			VL53L0X_REG_GLOBAL_CONFIG_REF_EN_START_SELECT,
;;;754    			startSelect);
;;;755    
;;;756    
;;;757    	if (Status == VL53L0X_ERROR_NONE)
000f30  e3550000          CMP      r5,#0
000f34  1a000004          BNE      |L1.3916|
;;;758    		Status = VL53L0X_WrByte(Dev,
000f38  e3a02000          MOV      r2,#0
000f3c  e3a01080          MOV      r1,#0x80
000f40  e1a00004          MOV      r0,r4
000f44  ebfffffe          BL       VL53L0X_WrByte
000f48  e1a05000          MOV      r5,r0
                  |L1.3916|
;;;759    				VL53L0X_REG_POWER_MANAGEMENT_GO1_POWER_FORCE, 0);
;;;760    
;;;761    	/* Perform ref calibration */
;;;762    	if (Status == VL53L0X_ERROR_NONE)
000f4c  e3550000          CMP      r5,#0
000f50  1a000005          BNE      |L1.3948|
;;;763    		Status = VL53L0X_perform_ref_calibration(Dev, &VhvSettings,
000f54  e3a03000          MOV      r3,#0
000f58  e28d2020          ADD      r2,sp,#0x20
000f5c  e28d1024          ADD      r1,sp,#0x24
000f60  e1a00004          MOV      r0,r4
000f64  ebfffffe          BL       VL53L0X_perform_ref_calibration
000f68  e1a05000          MOV      r5,r0
                  |L1.3948|
;;;764    			&PhaseCal, 0);
;;;765    
;;;766    	if (Status == VL53L0X_ERROR_NONE) {
000f6c  e3550000          CMP      r5,#0
000f70  1a00000f          BNE      |L1.4020|
;;;767    		/* Enable Minimum NON-APERTURE Spads */
;;;768    		currentSpadIndex = 0;
000f74  e3a06000          MOV      r6,#0
;;;769    		lastSpadIndex = currentSpadIndex;
000f78  e58d603c          STR      r6,[sp,#0x3c]
;;;770    		needAptSpads = 0;
000f7c  e3a08000          MOV      r8,#0
;;;771    		Status = enable_ref_spads(Dev,
000f80  e28d103c          ADD      r1,sp,#0x3c
000f84  e59d0044          LDR      r0,[sp,#0x44]
000f88  e58d000c          STR      r0,[sp,#0xc]
000f8c  e58d1010          STR      r1,[sp,#0x10]
000f90  e1a01008          MOV      r1,r8
000f94  e2843f49          ADD      r3,r4,#0x124
000f98  e2842c01          ADD      r2,r4,#0x100
000f9c  e282202a          ADD      r2,r2,#0x2a
000fa0  e1a00004          MOV      r0,r4
000fa4  e58d6008          STR      r6,[sp,#8]
000fa8  e1cda0f0          STRD     r10,r11,[sp,#0]
000fac  ebfffffe          BL       enable_ref_spads
000fb0  e1a05000          MOV      r5,r0
                  |L1.4020|
;;;772    					needAptSpads,
;;;773    					Dev->Data.SpadData.RefGoodSpadMap,
;;;774    					Dev->Data.SpadData.RefSpadEnables,
;;;775    					spadArraySize,
;;;776    					startSelect,
;;;777    					currentSpadIndex,
;;;778    					minimumSpadCount,
;;;779    					&lastSpadIndex);
;;;780    	}
;;;781    
;;;782    	if (Status == VL53L0X_ERROR_NONE) {
000fb4  e3550000          CMP      r5,#0
000fb8  1a00003a          BNE      |L1.4264|
;;;783    		currentSpadIndex = lastSpadIndex;
000fbc  e59d603c          LDR      r6,[sp,#0x3c]
;;;784    
;;;785    		Status = perform_ref_signal_measurement(Dev,
000fc0  e28d1034          ADD      r1,sp,#0x34
000fc4  e1a00004          MOV      r0,r4
000fc8  ebfffffe          BL       perform_ref_signal_measurement
000fcc  e1a05000          MOV      r5,r0
;;;786    			&peakSignalRateRef);
;;;787    		if ((Status == VL53L0X_ERROR_NONE) &&
000fd0  e3550000          CMP      r5,#0
000fd4  1a000032          BNE      |L1.4260|
;;;788    			(peakSignalRateRef > targetRefRate)) {
000fd8  e1dd03b4          LDRH     r0,[sp,#0x34]
000fdc  e1500007          CMP      r0,r7
000fe0  da00002f          BLE      |L1.4260|
;;;789    			/* Signal rate measurement too high,
;;;790    			 * switch to APERTURE SPADs */
;;;791    
;;;792    			for (index = 0; index < spadArraySize; index++)
000fe4  e3a09000          MOV      r9,#0
000fe8  ea000003          B        |L1.4092|
                  |L1.4076|
;;;793    				Dev->Data.SpadData.RefSpadEnables[index] = 0;
000fec  e3a00000          MOV      r0,#0
000ff0  e2841f49          ADD      r1,r4,#0x124
000ff4  e7c10009          STRB     r0,[r1,r9]
000ff8  e2899001          ADD      r9,r9,#1              ;792
                  |L1.4092|
000ffc  e159000a          CMP      r9,r10                ;792
001000  3afffff9          BCC      |L1.4076|
;;;794    
;;;795    
;;;796    			/* Increment to the first APERTURE spad */
;;;797    			while ((is_aperture(startSelect + currentSpadIndex)
001004  ea000000          B        |L1.4108|
                  |L1.4104|
;;;798    				== 0) && (currentSpadIndex < maxSpadCount)) {
;;;799    				currentSpadIndex++;
001008  e2866001          ADD      r6,r6,#1
                  |L1.4108|
00100c  e08b0006          ADD      r0,r11,r6             ;797
001010  ebfffffe          BL       is_aperture
001014  e3500000          CMP      r0,#0                 ;797
001018  1a000002          BNE      |L1.4136|
00101c  e59d0040          LDR      r0,[sp,#0x40]         ;798
001020  e1560000          CMP      r6,r0                 ;798
001024  3afffff7          BCC      |L1.4104|
                  |L1.4136|
;;;800    			}
;;;801    
;;;802    			needAptSpads = 1;
001028  e3a08001          MOV      r8,#1
;;;803    
;;;804    			Status = enable_ref_spads(Dev,
00102c  e28d103c          ADD      r1,sp,#0x3c
001030  e59d0044          LDR      r0,[sp,#0x44]
001034  e58d000c          STR      r0,[sp,#0xc]
001038  e58d1010          STR      r1,[sp,#0x10]
00103c  e1a01008          MOV      r1,r8
001040  e2843f49          ADD      r3,r4,#0x124
001044  e2842c01          ADD      r2,r4,#0x100
001048  e282202a          ADD      r2,r2,#0x2a
00104c  e1a00004          MOV      r0,r4
001050  e58d6008          STR      r6,[sp,#8]
001054  e1cda0f0          STRD     r10,r11,[sp,#0]
001058  ebfffffe          BL       enable_ref_spads
00105c  e1a05000          MOV      r5,r0
;;;805    					needAptSpads,
;;;806    					Dev->Data.SpadData.RefGoodSpadMap,
;;;807    					Dev->Data.SpadData.RefSpadEnables,
;;;808    					spadArraySize,
;;;809    					startSelect,
;;;810    					currentSpadIndex,
;;;811    					minimumSpadCount,
;;;812    					&lastSpadIndex);
;;;813    
;;;814    			if (Status == VL53L0X_ERROR_NONE) {
001060  e3550000          CMP      r5,#0
001064  1a00000f          BNE      |L1.4264|
;;;815    				currentSpadIndex = lastSpadIndex;
001068  e59d603c          LDR      r6,[sp,#0x3c]
;;;816    				Status = perform_ref_signal_measurement(Dev,
00106c  e28d1034          ADD      r1,sp,#0x34
001070  e1a00004          MOV      r0,r4
001074  ebfffffe          BL       perform_ref_signal_measurement
001078  e1a05000          MOV      r5,r0
;;;817    						&peakSignalRateRef);
;;;818    
;;;819    				if ((Status == VL53L0X_ERROR_NONE) &&
00107c  e3550000          CMP      r5,#0
001080  1a000008          BNE      |L1.4264|
;;;820    					(peakSignalRateRef > targetRefRate)) {
001084  e1dd03b4          LDRH     r0,[sp,#0x34]
001088  e1500007          CMP      r0,r7
00108c  da000005          BLE      |L1.4264|
;;;821    					/* Signal rate still too high after
;;;822    					 * setting the minimum number of
;;;823    					 * APERTURE spads. Can do no more
;;;824    					 * therefore set the min number of
;;;825    					 * aperture spads as the result.
;;;826    					 */
;;;827    					isApertureSpads_int = 1;
001090  e3a00001          MOV      r0,#1
001094  e58d0018          STR      r0,[sp,#0x18]
;;;828    					refSpadCount_int = minimumSpadCount;
001098  e59d0044          LDR      r0,[sp,#0x44]
00109c  e58d001c          STR      r0,[sp,#0x1c]
0010a0  ea000000          B        |L1.4264|
                  |L1.4260|
;;;829    				}
;;;830    			}
;;;831    		} else {
;;;832    			needAptSpads = 0;
0010a4  e3a08000          MOV      r8,#0
                  |L1.4264|
;;;833    		}
;;;834    	}
;;;835    
;;;836    	if ((Status == VL53L0X_ERROR_NONE) &&
0010a8  e3550000          CMP      r5,#0
0010ac  1a000066          BNE      |L1.4684|
;;;837    		(peakSignalRateRef < targetRefRate)) {
0010b0  e1dd03b4          LDRH     r0,[sp,#0x34]
0010b4  e1500007          CMP      r0,r7
0010b8  aa000063          BGE      |L1.4684|
;;;838    		/* At this point, the minimum number of either aperture
;;;839    		 * or non-aperture spads have been set. Proceed to add
;;;840    		 * spads and perform measurements until the target
;;;841    		 * reference is reached.
;;;842    		 */
;;;843    		isApertureSpads_int = needAptSpads;
0010bc  e20800ff          AND      r0,r8,#0xff
0010c0  e58d0018          STR      r0,[sp,#0x18]
;;;844    		refSpadCount_int	= minimumSpadCount;
0010c4  e59d0044          LDR      r0,[sp,#0x44]
0010c8  e58d001c          STR      r0,[sp,#0x1c]
;;;845    
;;;846    		memcpy(lastSpadArray, Dev->Data.SpadData.RefSpadEnables,
0010cc  e1a0200a          MOV      r2,r10
0010d0  e2841f49          ADD      r1,r4,#0x124
0010d4  e28d0048          ADD      r0,sp,#0x48
0010d8  ebfffffe          BL       __aeabi_memcpy4
;;;847    				spadArraySize);
;;;848    		lastSignalRateDiff = abs(peakSignalRateRef -
0010dc  e1dd13b4          LDRH     r1,[sp,#0x34]
0010e0  e0510007          SUBS     r0,r1,r7
0010e4  4a000001          BMI      |L1.4336|
0010e8  e1a01000          MOV      r1,r0
0010ec  ea000000          B        |L1.4340|
                  |L1.4336|
0010f0  e2601000          RSB      r1,r0,#0
                  |L1.4340|
0010f4  e58d102c          STR      r1,[sp,#0x2c]
;;;849    			targetRefRate);
;;;850    		complete = 0;
0010f8  e3a00000          MOV      r0,#0
0010fc  e58d0028          STR      r0,[sp,#0x28]
;;;851    
;;;852    		while (!complete) {
001100  ea00004d          B        |L1.4668|
                  |L1.4356|
;;;853    			get_next_good_spad(
001104  e28d3038          ADD      r3,sp,#0x38
001108  e1a02006          MOV      r2,r6
00110c  e1a0100a          MOV      r1,r10
001110  e2840c01          ADD      r0,r4,#0x100
001114  e280002a          ADD      r0,r0,#0x2a
001118  ebfffffe          BL       get_next_good_spad
;;;854    				Dev->Data.SpadData.RefGoodSpadMap,
;;;855    				spadArraySize, currentSpadIndex,
;;;856    				&nextGoodSpad);
;;;857    
;;;858    			if (nextGoodSpad == -1) {
00111c  e59d0038          LDR      r0,[sp,#0x38]
001120  e3700001          CMN      r0,#1
001124  1a000001          BNE      |L1.4400|
;;;859    				Status = VL53L0X_ERROR_REF_SPAD_INIT;
001128  e3e05031          MVN      r5,#0x31
;;;860    				break;
00112c  ea000045          B        |L1.4680|
                  |L1.4400|
;;;861    			}
;;;862    
;;;863    			(refSpadCount_int)++;
001130  e59d001c          LDR      r0,[sp,#0x1c]
001134  e2800001          ADD      r0,r0,#1
001138  e58d001c          STR      r0,[sp,#0x1c]
;;;864    
;;;865    			/* Cannot combine Aperture and Non-Aperture spads, so
;;;866    			 * ensure the current spad is of the correct type.
;;;867    			 */
;;;868    			if (is_aperture((uint32_t)startSelect + nextGoodSpad) !=
00113c  e59d1038          LDR      r1,[sp,#0x38]
001140  e08b0001          ADD      r0,r11,r1
001144  ebfffffe          BL       is_aperture
001148  e1500008          CMP      r0,r8
00114c  0a000001          BEQ      |L1.4440|
;;;869    					needAptSpads) {
;;;870    				Status = VL53L0X_ERROR_REF_SPAD_INIT;
001150  e3e05031          MVN      r5,#0x31
;;;871    				break;
001154  ea00003b          B        |L1.4680|
                  |L1.4440|
;;;872    			}
;;;873    
;;;874    			currentSpadIndex = nextGoodSpad;
001158  e59d6038          LDR      r6,[sp,#0x38]
;;;875    			Status = enable_spad_bit(
00115c  e1a02006          MOV      r2,r6
001160  e1a0100a          MOV      r1,r10
001164  e2840f49          ADD      r0,r4,#0x124
001168  ebfffffe          BL       enable_spad_bit
00116c  e1a05000          MOV      r5,r0
;;;876    					Dev->Data.SpadData.RefSpadEnables,
;;;877    					spadArraySize, currentSpadIndex);
;;;878    
;;;879    			if (Status == VL53L0X_ERROR_NONE) {
001170  e3550000          CMP      r5,#0
001174  1a000004          BNE      |L1.4492|
;;;880    				currentSpadIndex++;
001178  e2866001          ADD      r6,r6,#1
;;;881    				/* Proceed to apply the additional spad and
;;;882    				 * perform measurement. */
;;;883    				Status = set_ref_spad_map(Dev,
00117c  e2841f49          ADD      r1,r4,#0x124
001180  e1a00004          MOV      r0,r4
001184  ebfffffe          BL       set_ref_spad_map
001188  e1a05000          MOV      r5,r0
                  |L1.4492|
;;;884    					Dev->Data.SpadData.RefSpadEnables);
;;;885    			}
;;;886    
;;;887    			if (Status != VL53L0X_ERROR_NONE)
00118c  e3550000          CMP      r5,#0
001190  0a000000          BEQ      |L1.4504|
;;;888    				break;
001194  ea00002b          B        |L1.4680|
                  |L1.4504|
;;;889    
;;;890    			Status = perform_ref_signal_measurement(Dev,
001198  e28d1034          ADD      r1,sp,#0x34
00119c  e1a00004          MOV      r0,r4
0011a0  ebfffffe          BL       perform_ref_signal_measurement
0011a4  e1a05000          MOV      r5,r0
;;;891    					&peakSignalRateRef);
;;;892    
;;;893    			if (Status != VL53L0X_ERROR_NONE)
0011a8  e3550000          CMP      r5,#0
0011ac  0a000000          BEQ      |L1.4532|
;;;894    				break;
0011b0  ea000024          B        |L1.4680|
                  |L1.4532|
;;;895    
;;;896    			signalRateDiff = abs(peakSignalRateRef - targetRefRate);
0011b4  e1dd13b4          LDRH     r1,[sp,#0x34]
0011b8  e0510007          SUBS     r0,r1,r7
0011bc  4a000001          BMI      |L1.4552|
0011c0  e1a01000          MOV      r1,r0
0011c4  ea000000          B        |L1.4556|
                  |L1.4552|
0011c8  e2601000          RSB      r1,r0,#0
                  |L1.4556|
0011cc  e58d1030          STR      r1,[sp,#0x30]
;;;897    
;;;898    			if (peakSignalRateRef > targetRefRate) {
0011d0  e1dd03b4          LDRH     r0,[sp,#0x34]
0011d4  e1500007          CMP      r0,r7
0011d8  da000011          BLE      |L1.4644|
;;;899    				/* Select the spad map that provides the
;;;900    				 * measurement closest to the target rate,
;;;901    				 * either above or below it.
;;;902    				 */
;;;903    				if (signalRateDiff > lastSignalRateDiff) {
0011dc  e59d0030          LDR      r0,[sp,#0x30]
0011e0  e59d102c          LDR      r1,[sp,#0x2c]
0011e4  e1500001          CMP      r0,r1
0011e8  9a00000a          BLS      |L1.4632|
;;;904    					/* Previous spad map produced a closer
;;;905    					 * measurement, so choose this. */
;;;906    					Status = set_ref_spad_map(Dev,
0011ec  e28d1048          ADD      r1,sp,#0x48
0011f0  e1a00004          MOV      r0,r4
0011f4  ebfffffe          BL       set_ref_spad_map
0011f8  e1a05000          MOV      r5,r0
;;;907    							lastSpadArray);
;;;908    					memcpy(
0011fc  e1a0200a          MOV      r2,r10
001200  e28d1048          ADD      r1,sp,#0x48
001204  e2840f49          ADD      r0,r4,#0x124
001208  ebfffffe          BL       __aeabi_memcpy4
;;;909    					Dev->Data.SpadData.RefSpadEnables,
;;;910    					lastSpadArray, spadArraySize);
;;;911    
;;;912    					(refSpadCount_int)--;
00120c  e59d001c          LDR      r0,[sp,#0x1c]
001210  e2400001          SUB      r0,r0,#1
001214  e58d001c          STR      r0,[sp,#0x1c]
                  |L1.4632|
;;;913    				}
;;;914    				complete = 1;
001218  e3a00001          MOV      r0,#1
00121c  e58d0028          STR      r0,[sp,#0x28]
001220  ea000005          B        |L1.4668|
                  |L1.4644|
;;;915    			} else {
;;;916    				/* Continue to add spads */
;;;917    				lastSignalRateDiff = signalRateDiff;
001224  e59d0030          LDR      r0,[sp,#0x30]
001228  e58d002c          STR      r0,[sp,#0x2c]
;;;918    				memcpy(lastSpadArray,
00122c  e1a0200a          MOV      r2,r10
001230  e2841f49          ADD      r1,r4,#0x124
001234  e28d0048          ADD      r0,sp,#0x48
001238  ebfffffe          BL       __aeabi_memcpy4
                  |L1.4668|
00123c  e59d0028          LDR      r0,[sp,#0x28]         ;852
001240  e3500000          CMP      r0,#0                 ;852
001244  0affffae          BEQ      |L1.4356|
                  |L1.4680|
001248  e1a00000          MOV      r0,r0                 ;860
                  |L1.4684|
;;;919    					Dev->Data.SpadData.RefSpadEnables,
;;;920    					spadArraySize);
;;;921    			}
;;;922    
;;;923    		} /* while */
;;;924    	}
;;;925    
;;;926    	if (Status == VL53L0X_ERROR_NONE) {
00124c  e3550000          CMP      r5,#0
001250  1a00000d          BNE      |L1.4748|
;;;927    		*refSpadCount = refSpadCount_int;
001254  e59d001c          LDR      r0,[sp,#0x1c]
001258  e59d1054          LDR      r1,[sp,#0x54]
00125c  e5810000          STR      r0,[r1,#0]
;;;928    		*isApertureSpads = isApertureSpads_int;
001260  e59d0018          LDR      r0,[sp,#0x18]
001264  e59d1058          LDR      r1,[sp,#0x58]
001268  e5c10000          STRB     r0,[r1,#0]
;;;929    
;;;930    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, RefSpadsInitialised, 1);
00126c  e3a00001          MOV      r0,#1
001270  e5c40115          STRB     r0,[r4,#0x115]
;;;931    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
001274  e59d0054          LDR      r0,[sp,#0x54]
001278  e5d00000          LDRB     r0,[r0,#0]
00127c  e5c40113          STRB     r0,[r4,#0x113]
;;;932    			ReferenceSpadCount, (uint8_t)(*refSpadCount));
;;;933    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
001280  e59d0058          LDR      r0,[sp,#0x58]
001284  e5d00000          LDRB     r0,[r0,#0]
001288  e5c40114          STRB     r0,[r4,#0x114]
                  |L1.4748|
;;;934    			ReferenceSpadType, *isApertureSpads);
;;;935    	}
;;;936    
;;;937    	return Status;
00128c  e1a00005          MOV      r0,r5
001290  e28dd05c          ADD      sp,sp,#0x5c
;;;938    }
001294  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4760|
                          DCD      0x0007cc18
                  |L1.4764|
                          DCD      0x000007ff
                  |L1.4768|
                          DCD      refArrayQuadrants
                          ENDP

                  VL53L0X_set_reference_spads PROC
;;;939    
;;;940    VL53L0X_Error VL53L0X_set_reference_spads(VL53L0X_DEV Dev,
0012a4  e92d4ff0          PUSH     {r4-r11,lr}
;;;941    				 uint32_t count, uint8_t isApertureSpads)
;;;942    {
0012a8  e24dd01c          SUB      sp,sp,#0x1c
0012ac  e1a04000          MOV      r4,r0
0012b0  e1a09001          MOV      r9,r1
0012b4  e1a06002          MOV      r6,r2
;;;943    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0012b8  e3a05000          MOV      r5,#0
;;;944    	uint32_t currentSpadIndex = 0;
0012bc  e3a07000          MOV      r7,#0
;;;945    	uint8_t startSelect = 0xB4;
0012c0  e3a0a0b4          MOV      r10,#0xb4
;;;946    	uint32_t spadArraySize = 6;
0012c4  e3a0b006          MOV      r11,#6
;;;947    	uint32_t maxSpadCount = 44;
0012c8  e3a0002c          MOV      r0,#0x2c
0012cc  e58d0018          STR      r0,[sp,#0x18]
;;;948    	uint32_t lastSpadIndex;
;;;949    	uint32_t index;
;;;950    
;;;951    	/*
;;;952    	 * This function applies a requested number of reference spads, either
;;;953    	 * aperture or
;;;954    	 * non-aperture, as requested.
;;;955    	 * The good spad map will be applied.
;;;956    	 */
;;;957    
;;;958    	Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
0012d0  e3a02001          MOV      r2,#1
0012d4  e3a010ff          MOV      r1,#0xff
0012d8  e1a00004          MOV      r0,r4
0012dc  ebfffffe          BL       VL53L0X_WrByte
0012e0  e1a05000          MOV      r5,r0
;;;959    
;;;960    	if (Status == VL53L0X_ERROR_NONE)
0012e4  e3550000          CMP      r5,#0
0012e8  1a000004          BNE      |L1.4864|
;;;961    		Status = VL53L0X_WrByte(Dev,
0012ec  e3a02000          MOV      r2,#0
0012f0  e3a0104f          MOV      r1,#0x4f
0012f4  e1a00004          MOV      r0,r4
0012f8  ebfffffe          BL       VL53L0X_WrByte
0012fc  e1a05000          MOV      r5,r0
                  |L1.4864|
;;;962    			VL53L0X_REG_DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
;;;963    
;;;964    	if (Status == VL53L0X_ERROR_NONE)
001300  e3550000          CMP      r5,#0
001304  1a000004          BNE      |L1.4892|
;;;965    		Status = VL53L0X_WrByte(Dev,
001308  e3a0202c          MOV      r2,#0x2c
00130c  e3a0104e          MOV      r1,#0x4e
001310  e1a00004          MOV      r0,r4
001314  ebfffffe          BL       VL53L0X_WrByte
001318  e1a05000          MOV      r5,r0
                  |L1.4892|
;;;966    			VL53L0X_REG_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
;;;967    
;;;968    	if (Status == VL53L0X_ERROR_NONE)
00131c  e3550000          CMP      r5,#0
001320  1a000004          BNE      |L1.4920|
;;;969    		Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
001324  e3a02000          MOV      r2,#0
001328  e3a010ff          MOV      r1,#0xff
00132c  e1a00004          MOV      r0,r4
001330  ebfffffe          BL       VL53L0X_WrByte
001334  e1a05000          MOV      r5,r0
                  |L1.4920|
;;;970    
;;;971    	if (Status == VL53L0X_ERROR_NONE)
001338  e3550000          CMP      r5,#0
00133c  1a000004          BNE      |L1.4948|
;;;972    		Status = VL53L0X_WrByte(Dev,
001340  e1a0200a          MOV      r2,r10
001344  e3a010b6          MOV      r1,#0xb6
001348  e1a00004          MOV      r0,r4
00134c  ebfffffe          BL       VL53L0X_WrByte
001350  e1a05000          MOV      r5,r0
                  |L1.4948|
;;;973    			VL53L0X_REG_GLOBAL_CONFIG_REF_EN_START_SELECT,
;;;974    			startSelect);
;;;975    
;;;976    	for (index = 0; index < spadArraySize; index++)
001354  e3a08000          MOV      r8,#0
001358  ea000003          B        |L1.4972|
                  |L1.4956|
;;;977    		Dev->Data.SpadData.RefSpadEnables[index] = 0;
00135c  e3a00000          MOV      r0,#0
001360  e2841f49          ADD      r1,r4,#0x124
001364  e7c10008          STRB     r0,[r1,r8]
001368  e2888001          ADD      r8,r8,#1              ;976
                  |L1.4972|
00136c  e158000b          CMP      r8,r11                ;976
001370  3afffff9          BCC      |L1.4956|
;;;978    
;;;979    	if (isApertureSpads) {
001374  e3560000          CMP      r6,#0
001378  0a000008          BEQ      |L1.5024|
;;;980    		/* Increment to the first APERTURE spad */
;;;981    		while ((is_aperture(startSelect + currentSpadIndex) == 0) &&
00137c  ea000000          B        |L1.4996|
                  |L1.4992|
;;;982    			  (currentSpadIndex < maxSpadCount)) {
;;;983    			currentSpadIndex++;
001380  e2877001          ADD      r7,r7,#1
                  |L1.4996|
001384  e08a0007          ADD      r0,r10,r7             ;981
001388  ebfffffe          BL       is_aperture
00138c  e3500000          CMP      r0,#0                 ;981
001390  1a000002          BNE      |L1.5024|
001394  e59d0018          LDR      r0,[sp,#0x18]         ;982
001398  e1570000          CMP      r7,r0                 ;982
00139c  3afffff7          BCC      |L1.4992|
                  |L1.5024|
;;;984    		}
;;;985    	}
;;;986    	Status = enable_ref_spads(Dev,
0013a0  e28d0014          ADD      r0,sp,#0x14
0013a4  e2843f49          ADD      r3,r4,#0x124
0013a8  e2842c01          ADD      r2,r4,#0x100
0013ac  e282202a          ADD      r2,r2,#0x2a
0013b0  e1a01006          MOV      r1,r6
0013b4  e58d0010          STR      r0,[sp,#0x10]
0013b8  e1a00004          MOV      r0,r4
0013bc  e58d7008          STR      r7,[sp,#8]
0013c0  e58d900c          STR      r9,[sp,#0xc]
0013c4  e58da004          STR      r10,[sp,#4]
0013c8  e58db000          STR      r11,[sp,#0]
0013cc  ebfffffe          BL       enable_ref_spads
0013d0  e1a05000          MOV      r5,r0
;;;987    				isApertureSpads,
;;;988    				Dev->Data.SpadData.RefGoodSpadMap,
;;;989    				Dev->Data.SpadData.RefSpadEnables,
;;;990    				spadArraySize,
;;;991    				startSelect,
;;;992    				currentSpadIndex,
;;;993    				count,
;;;994    				&lastSpadIndex);
;;;995    
;;;996    	if (Status == VL53L0X_ERROR_NONE) {
0013d4  e3550000          CMP      r5,#0
0013d8  1a000003          BNE      |L1.5100|
;;;997    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, RefSpadsInitialised, 1);
0013dc  e3a00001          MOV      r0,#1
0013e0  e5c40115          STRB     r0,[r4,#0x115]
;;;998    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
0013e4  e5c49113          STRB     r9,[r4,#0x113]
;;;999    			ReferenceSpadCount, (uint8_t)(count));
;;;1000   		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
0013e8  e5c46114          STRB     r6,[r4,#0x114]
                  |L1.5100|
;;;1001   			ReferenceSpadType, isApertureSpads);
;;;1002   	}
;;;1003   
;;;1004   	return Status;
0013ec  e1a00005          MOV      r0,r5
0013f0  e28dd01c          ADD      sp,sp,#0x1c
;;;1005   }
0013f4  e8bd8ff0          POP      {r4-r11,pc}
;;;1006   
                          ENDP

                  VL53L0X_get_reference_spads PROC
;;;1007   VL53L0X_Error VL53L0X_get_reference_spads(VL53L0X_DEV Dev,
0013f8  e92d47f0          PUSH     {r4-r10,lr}
;;;1008   			uint32_t *pSpadCount, uint8_t *pIsApertureSpads)
;;;1009   {
0013fc  e24dd018          SUB      sp,sp,#0x18
001400  e1a04000          MOV      r4,r0
001404  e1a05001          MOV      r5,r1
001408  e1a06002          MOV      r6,r2
;;;1010   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00140c  e3a07000          MOV      r7,#0
;;;1011   	uint8_t refSpadsInitialised;
;;;1012   	uint8_t refSpadArray[6];
;;;1013   	uint32_t cMaxSpadCount = 44;
001410  e3a0902c          MOV      r9,#0x2c
;;;1014   	uint32_t cSpadArraySize = 6;
001414  e3a0a006          MOV      r10,#6
;;;1015   	uint32_t spadsEnabled;
;;;1016   	uint8_t isApertureSpads = 0;
001418  e3a00000          MOV      r0,#0
00141c  e58d0008          STR      r0,[sp,#8]
;;;1017   
;;;1018   	refSpadsInitialised = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
001420  e5d48115          LDRB     r8,[r4,#0x115]
;;;1019   					RefSpadsInitialised);
;;;1020   
;;;1021   	if (refSpadsInitialised == 1) {
001424  e3580001          CMP      r8,#1
001428  1a000004          BNE      |L1.5184|
;;;1022   
;;;1023   		*pSpadCount = (uint32_t)VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
00142c  e5d40113          LDRB     r0,[r4,#0x113]
001430  e5850000          STR      r0,[r5,#0]
;;;1024   			ReferenceSpadCount);
;;;1025   		*pIsApertureSpads = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
001434  e5d40114          LDRB     r0,[r4,#0x114]
001438  e5c60000          STRB     r0,[r6,#0]
00143c  ea000019          B        |L1.5288|
                  |L1.5184|
;;;1026   			ReferenceSpadType);
;;;1027   	} else {
;;;1028   
;;;1029   		/* obtain spad info from device.*/
;;;1030   		Status = get_ref_spad_map(Dev, refSpadArray);
001440  e28d1010          ADD      r1,sp,#0x10
001444  e1a00004          MOV      r0,r4
001448  ebfffffe          BL       get_ref_spad_map
00144c  e1a07000          MOV      r7,r0
;;;1031   
;;;1032   		if (Status == VL53L0X_ERROR_NONE) {
001450  e3570000          CMP      r7,#0
001454  1a000013          BNE      |L1.5288|
;;;1033   			/* count enabled spads within spad map array and
;;;1034   			 * determine if Aperture or Non-Aperture.
;;;1035   			 */
;;;1036   			Status = count_enabled_spads(refSpadArray,
001458  e28d0008          ADD      r0,sp,#8
00145c  e58d0000          STR      r0,[sp,#0]
001460  e28d300c          ADD      r3,sp,#0xc
001464  e1a02009          MOV      r2,r9
001468  e1a0100a          MOV      r1,r10
00146c  e28d0010          ADD      r0,sp,#0x10
001470  ebfffffe          BL       count_enabled_spads
001474  e1a07000          MOV      r7,r0
;;;1037   							cSpadArraySize,
;;;1038   							cMaxSpadCount,
;;;1039   							&spadsEnabled,
;;;1040   							&isApertureSpads);
;;;1041   
;;;1042   			if (Status == VL53L0X_ERROR_NONE) {
001478  e3570000          CMP      r7,#0
00147c  1a000009          BNE      |L1.5288|
;;;1043   
;;;1044   				*pSpadCount = spadsEnabled;
001480  e59d000c          LDR      r0,[sp,#0xc]
001484  e5850000          STR      r0,[r5,#0]
;;;1045   				*pIsApertureSpads = isApertureSpads;
001488  e5dd0008          LDRB     r0,[sp,#8]
00148c  e5c60000          STRB     r0,[r6,#0]
;;;1046   
;;;1047   				VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
001490  e3a00001          MOV      r0,#1
001494  e5c40115          STRB     r0,[r4,#0x115]
;;;1048   					RefSpadsInitialised, 1);
;;;1049   				VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
001498  e59d000c          LDR      r0,[sp,#0xc]
00149c  e5c40113          STRB     r0,[r4,#0x113]
;;;1050   					ReferenceSpadCount,
;;;1051   					(uint8_t)spadsEnabled);
;;;1052   				VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
0014a0  e5dd0008          LDRB     r0,[sp,#8]
0014a4  e5c40114          STRB     r0,[r4,#0x114]
                  |L1.5288|
;;;1053   					ReferenceSpadType, isApertureSpads);
;;;1054   			}
;;;1055   		}
;;;1056   	}
;;;1057   
;;;1058   	return Status;
0014a8  e1a00007          MOV      r0,r7
0014ac  e28dd018          ADD      sp,sp,#0x18
;;;1059   }
0014b0  e8bd87f0          POP      {r4-r10,pc}
;;;1060   
                          ENDP

                  VL53L0X_set_ref_calibration PROC
;;;1244   
;;;1245   VL53L0X_Error VL53L0X_set_ref_calibration(VL53L0X_DEV Dev,
0014b4  e92d40f0          PUSH     {r4-r7,lr}
;;;1246   		uint8_t VhvSettings, uint8_t PhaseCal)
;;;1247   {
0014b8  e24dd01c          SUB      sp,sp,#0x1c
0014bc  e1a06000          MOV      r6,r0
0014c0  e1a04001          MOV      r4,r1
0014c4  e1a05002          MOV      r5,r2
;;;1248   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0014c8  e3a07000          MOV      r7,#0
;;;1249   	uint8_t pVhvSettings;
;;;1250   	uint8_t pPhaseCal;
;;;1251   
;;;1252   	Status = VL53L0X_ref_calibration_io(Dev, 0,
0014cc  e3a00001          MOV      r0,#1
0014d0  e28d2014          ADD      r2,sp,#0x14
0014d4  e28d3018          ADD      r3,sp,#0x18
0014d8  e58d0008          STR      r0,[sp,#8]
0014dc  e58d2004          STR      r2,[sp,#4]
0014e0  e58d3000          STR      r3,[sp,#0]
0014e4  e1a03005          MOV      r3,r5
0014e8  e1a02004          MOV      r2,r4
0014ec  e3a01000          MOV      r1,#0
0014f0  e58d000c          STR      r0,[sp,#0xc]
0014f4  e1a00006          MOV      r0,r6
0014f8  ebfffffe          BL       VL53L0X_ref_calibration_io
0014fc  e1a07000          MOV      r7,r0
;;;1253   		VhvSettings, PhaseCal,
;;;1254   		&pVhvSettings, &pPhaseCal,
;;;1255   		1, 1);
;;;1256   
;;;1257   	return Status;
001500  e1a00007          MOV      r0,r7
001504  e28dd01c          ADD      sp,sp,#0x1c
;;;1258   }
001508  e8bd80f0          POP      {r4-r7,pc}
;;;1259   
                          ENDP

                  VL53L0X_get_ref_calibration PROC
;;;1260   VL53L0X_Error VL53L0X_get_ref_calibration(VL53L0X_DEV Dev,
00150c  e92d47ff          PUSH     {r0-r10,lr}
;;;1261   		uint8_t *pVhvSettings, uint8_t *pPhaseCal)
;;;1262   {
001510  e1a06000          MOV      r6,r0
001514  e1a04001          MOV      r4,r1
001518  e1a05002          MOV      r5,r2
;;;1263   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00151c  e3a07000          MOV      r7,#0
;;;1264   	uint8_t VhvSettings = 0;
001520  e3a08000          MOV      r8,#0
;;;1265   	uint8_t PhaseCal = 0;
001524  e3a09000          MOV      r9,#0
;;;1266   
;;;1267   	Status = VL53L0X_ref_calibration_io(Dev, 1,
001528  e3a00001          MOV      r0,#1
00152c  e58d0008          STR      r0,[sp,#8]
001530  e1cd40f0          STRD     r4,r5,[sp,#0]
001534  e1a03009          MOV      r3,r9
001538  e1a02008          MOV      r2,r8
00153c  e58d000c          STR      r0,[sp,#0xc]
001540  e1a01000          MOV      r1,r0
001544  e1a00006          MOV      r0,r6
001548  ebfffffe          BL       VL53L0X_ref_calibration_io
00154c  e1a07000          MOV      r7,r0
;;;1268   		VhvSettings, PhaseCal,
;;;1269   		pVhvSettings, pPhaseCal,
;;;1270   		1, 1);
;;;1271   
;;;1272   	return Status;
001550  e1a00007          MOV      r0,r7
001554  e28dd010          ADD      sp,sp,#0x10
;;;1273   }
001558  e8bd87f0          POP      {r4-r10,pc}
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  refArrayQuadrants
                          DCD      0x0000000a
                          DCD      0x00000005
                          DCD      0x00000000
                          DCD      0x00000005
