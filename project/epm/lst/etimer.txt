; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\etimer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\etimer.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\etimer.crf ..\..\common\src\BSP\Driver\Source\etimer.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ETIMER_GetModuleClock PROC
;;;20       */
;;;21     static UINT ETIMER_GetModuleClock(UINT timer)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;22     {
000004  e1a05000          MOV      r5,r0
;;;23         UINT src;
;;;24     
;;;25         src = (inpw(REG_CLK_DIVCTL8) >> (16 + timer * 4)) & 0x3;
000008  e3a0020b          MOV      r0,#0xb0000000
00000c  e5900240          LDR      r0,[r0,#0x240]
000010  e3a01010          MOV      r1,#0x10
000014  e0811105          ADD      r1,r1,r5,LSL #2
000018  e1a00130          LSR      r0,r0,r1
00001c  e2004003          AND      r4,r0,#3
;;;26     
;;;27         if(src == 0)
000020  e3540000          CMP      r4,#0
000024  1a000001          BNE      |L1.48|
;;;28             return 12000000;
000028  e59f056c          LDR      r0,|L1.1436|
                  |L1.44|
;;;29         else if (src == 1)
;;;30             return sysGetClock(SYS_PCLK);
;;;31         else if (src == 2)
;;;32             return sysGetClock(SYS_PCLK) / 4096;
;;;33         else
;;;34             return 32768;
;;;35     
;;;36     }
00002c  e8bd8070          POP      {r4-r6,pc}
                  |L1.48|
000030  e3540001          CMP      r4,#1                 ;29
000034  1a000002          BNE      |L1.68|
000038  e3a00006          MOV      r0,#6                 ;30
00003c  ebfffffe          BL       sysGetClock
000040  eafffff9          B        |L1.44|
                  |L1.68|
000044  e3540002          CMP      r4,#2                 ;31
000048  1a000003          BNE      |L1.92|
00004c  e3a00006          MOV      r0,#6                 ;32
000050  ebfffffe          BL       sysGetClock
000054  e1a00620          LSR      r0,r0,#12             ;32
000058  eafffff3          B        |L1.44|
                  |L1.92|
00005c  e3a00902          MOV      r0,#0x8000            ;34
000060  eafffff1          B        |L1.44|
;;;37     
                          ENDP

                  ETIMER_Open PROC
;;;67       */
;;;68     UINT ETIMER_Open(UINT timer, UINT u32Mode, UINT u32Freq)
000064  e92d47f0          PUSH     {r4-r10,lr}
;;;69     {
000068  e1a08000          MOV      r8,r0
00006c  e1a05001          MOV      r5,r1
000070  e1a09002          MOV      r9,r2
;;;70         UINT u32Clk = ETIMER_GetModuleClock(timer);
000074  e1a00008          MOV      r0,r8
000078  ebfffffe          BL       ETIMER_GetModuleClock
00007c  e1a04000          MOV      r4,r0
;;;71         UINT u32Cmpr = 0, u32Prescale = 0;
000080  e3a06000          MOV      r6,#0
000084  e3a07000          MOV      r7,#0
;;;72     
;;;73         // Fastest possible timer working freq is u32Clk / 2. While cmpr = 2, pre-scale = 0
;;;74         if(u32Freq > (u32Clk / 2)) {
000088  e15900a4          CMP      r9,r4,LSR #1
00008c  9a000001          BLS      |L1.152|
;;;75             u32Cmpr = 2;
000090  e3a06002          MOV      r6,#2
000094  ea000011          B        |L1.224|
                  |L1.152|
;;;76         } else {
;;;77             if(u32Clk >= 0x4000000) {
000098  e3540301          CMP      r4,#0x4000000
00009c  3a000002          BCC      |L1.172|
;;;78                 u32Prescale = 7;    // real prescaler value is 8
0000a0  e3a07007          MOV      r7,#7
;;;79                 u32Clk >>= 3;
0000a4  e1a041a4          LSR      r4,r4,#3
0000a8  ea000008          B        |L1.208|
                  |L1.172|
;;;80             } else if(u32Clk >= 0x2000000) {
0000ac  e3540402          CMP      r4,#0x2000000
0000b0  3a000002          BCC      |L1.192|
;;;81                 u32Prescale = 3;    // real prescaler value is 4
0000b4  e3a07003          MOV      r7,#3
;;;82                 u32Clk >>= 2;
0000b8  e1a04124          LSR      r4,r4,#2
0000bc  ea000003          B        |L1.208|
                  |L1.192|
;;;83             } else if(u32Clk >= 0x1000000) {
0000c0  e3540401          CMP      r4,#0x1000000
0000c4  3a000001          BCC      |L1.208|
;;;84                 u32Prescale = 1;    // real prescaler value is 2
0000c8  e3a07001          MOV      r7,#1
;;;85                 u32Clk >>= 1;
0000cc  e1a040a4          LSR      r4,r4,#1
                  |L1.208|
;;;86             }
;;;87             u32Cmpr = u32Clk / u32Freq;
0000d0  e1a01009          MOV      r1,r9
0000d4  e1a00004          MOV      r0,r4
0000d8  ebfffffe          BL       __aeabi_uidivmod
0000dc  e1a06000          MOV      r6,r0
                  |L1.224|
;;;88         }
;;;89     
;;;90         if(timer == 0) {
0000e0  e3580000          CMP      r8,#0
0000e4  1a000007          BNE      |L1.264|
;;;91             outpw(REG_ETMR0_CMPR, u32Cmpr);
0000e8  e59f04b0          LDR      r0,|L1.1440|
0000ec  e5806000          STR      r6,[r0,#0]
;;;92             outpw(REG_ETMR0_PRECNT, u32Prescale);
0000f0  e2400004          SUB      r0,r0,#4
0000f4  e5807000          STR      r7,[r0,#0]
;;;93             outpw(REG_ETMR0_CTL, 1 | u32Mode);
0000f8  e3850001          ORR      r0,r5,#1
0000fc  e59f14a0          LDR      r1,|L1.1444|
000100  e5810000          STR      r0,[r1,#0]
000104  ea00001a          B        |L1.372|
                  |L1.264|
;;;94         } else if(timer == 1) {
000108  e3580001          CMP      r8,#1
00010c  1a000007          BNE      |L1.304|
;;;95             outpw(REG_ETMR1_CMPR, u32Cmpr);
000110  e59f0490          LDR      r0,|L1.1448|
000114  e5806000          STR      r6,[r0,#0]
;;;96             outpw(REG_ETMR1_PRECNT, u32Prescale);
000118  e2400004          SUB      r0,r0,#4
00011c  e5807000          STR      r7,[r0,#0]
;;;97             outpw(REG_ETMR1_CTL, 1 | u32Mode);
000120  e3850001          ORR      r0,r5,#1
000124  e59f1480          LDR      r1,|L1.1452|
000128  e5810000          STR      r0,[r1,#0]
00012c  ea000010          B        |L1.372|
                  |L1.304|
;;;98         } else if(timer == 2) {
000130  e3580002          CMP      r8,#2
000134  1a000007          BNE      |L1.344|
;;;99             outpw(REG_ETMR2_CMPR, u32Cmpr);
000138  e59f0470          LDR      r0,|L1.1456|
00013c  e5806000          STR      r6,[r0,#0]
;;;100            outpw(REG_ETMR2_PRECNT, u32Prescale);
000140  e2400004          SUB      r0,r0,#4
000144  e5807000          STR      r7,[r0,#0]
;;;101            outpw(REG_ETMR2_CTL, 1 | u32Mode);
000148  e3850001          ORR      r0,r5,#1
00014c  e59f1460          LDR      r1,|L1.1460|
000150  e5810000          STR      r0,[r1,#0]
000154  ea000006          B        |L1.372|
                  |L1.344|
;;;102        } else {
;;;103            outpw(REG_ETMR3_CMPR, u32Cmpr);
000158  e59f0458          LDR      r0,|L1.1464|
00015c  e5806000          STR      r6,[r0,#0]
;;;104            outpw(REG_ETMR3_PRECNT, u32Prescale);
000160  e2400004          SUB      r0,r0,#4
000164  e5807000          STR      r7,[r0,#0]
;;;105            outpw(REG_ETMR3_CTL, 1 | u32Mode);
000168  e3850001          ORR      r0,r5,#1
00016c  e59f1448          LDR      r1,|L1.1468|
000170  e5810000          STR      r0,[r1,#0]
                  |L1.372|
;;;106        }
;;;107    
;;;108        return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000174  e2870001          ADD      r0,r7,#1
000178  e0010096          MUL      r1,r6,r0
00017c  e1a00004          MOV      r0,r4
000180  ebfffffe          BL       __aeabi_uidivmod
;;;109    }
000184  e8bd87f0          POP      {r4-r10,pc}
;;;110    
                          ENDP

                  ETIMER_Close PROC
;;;115      */
;;;116    void ETIMER_Close(UINT timer)
000188  e3500000          CMP      r0,#0
;;;117    {
;;;118        if(timer == 0) {
00018c  1a000005          BNE      |L1.424|
;;;119            outpw(REG_ETMR0_CTL, 0);
000190  e3a01000          MOV      r1,#0
000194  e59f2408          LDR      r2,|L1.1444|
000198  e5821000          STR      r1,[r2,#0]
;;;120            outpw(REG_ETMR0_IER, 0);
00019c  e282200c          ADD      r2,r2,#0xc
0001a0  e5821000          STR      r1,[r2,#0]
0001a4  ea000014          B        |L1.508|
                  |L1.424|
;;;121        } else if(timer == 1) {
0001a8  e3500001          CMP      r0,#1
0001ac  1a000005          BNE      |L1.456|
;;;122            outpw(REG_ETMR1_CTL, 0);
0001b0  e3a01000          MOV      r1,#0
0001b4  e59f23f0          LDR      r2,|L1.1452|
0001b8  e5821000          STR      r1,[r2,#0]
;;;123            outpw(REG_ETMR1_IER, 0);
0001bc  e282200c          ADD      r2,r2,#0xc
0001c0  e5821000          STR      r1,[r2,#0]
0001c4  ea00000c          B        |L1.508|
                  |L1.456|
;;;124        } else if(timer == 2) {
0001c8  e3500002          CMP      r0,#2
0001cc  1a000005          BNE      |L1.488|
;;;125            outpw(REG_ETMR2_CTL, 0);
0001d0  e3a01000          MOV      r1,#0
0001d4  e59f23d8          LDR      r2,|L1.1460|
0001d8  e5821000          STR      r1,[r2,#0]
;;;126            outpw(REG_ETMR2_IER, 0);
0001dc  e282200c          ADD      r2,r2,#0xc
0001e0  e5821000          STR      r1,[r2,#0]
0001e4  ea000004          B        |L1.508|
                  |L1.488|
;;;127        } else {
;;;128            outpw(REG_ETMR3_CTL, 0);
0001e8  e3a01000          MOV      r1,#0
0001ec  e59f23c8          LDR      r2,|L1.1468|
0001f0  e5821000          STR      r1,[r2,#0]
;;;129            outpw(REG_ETMR3_IER, 0);
0001f4  e282200c          ADD      r2,r2,#0xc
0001f8  e5821000          STR      r1,[r2,#0]
                  |L1.508|
;;;130        }
;;;131    }
0001fc  e12fff1e          BX       lr
;;;132    
                          ENDP

                  ETIMER_Delay PROC
;;;140      */
;;;141    void ETIMER_Delay(UINT timer, UINT u32Usec)
000200  e92d4ff0          PUSH     {r4-r11,lr}
;;;142    {
000204  e24dd01c          SUB      sp,sp,#0x1c
000208  e1a04000          MOV      r4,r0
00020c  e1a06001          MOV      r6,r1
;;;143        UINT u32Clk = ETIMER_GetModuleClock(timer);
000210  e1a00004          MOV      r0,r4
000214  ebfffffe          BL       ETIMER_GetModuleClock
000218  e1a05000          MOV      r5,r0
;;;144        UINT u32Prescale = 0, delay = 300000000 / u32Clk;
00021c  e3a09000          MOV      r9,#0
000220  e1a01005          MOV      r1,r5
000224  e59f0394          LDR      r0,|L1.1472|
000228  ebfffffe          BL       __aeabi_uidivmod
00022c  e1a0a000          MOV      r10,r0
;;;145        float fCmpr;
;;;146    
;;;147        // Clear current timer configuration
;;;148        if(timer == 0) {
000230  e3540000          CMP      r4,#0
000234  1a000003          BNE      |L1.584|
;;;149            outpw(REG_ETMR0_CTL, 0);
000238  e3a00000          MOV      r0,#0
00023c  e59f1360          LDR      r1,|L1.1444|
000240  e5810000          STR      r0,[r1,#0]
000244  ea00000e          B        |L1.644|
                  |L1.584|
;;;150        } else if(timer == 1) {
000248  e3540001          CMP      r4,#1
00024c  1a000003          BNE      |L1.608|
;;;151            outpw(REG_ETMR1_CTL, 0);
000250  e3a00000          MOV      r0,#0
000254  e59f1350          LDR      r1,|L1.1452|
000258  e5810000          STR      r0,[r1,#0]
00025c  ea000008          B        |L1.644|
                  |L1.608|
;;;152        } else if(timer == 2) {
000260  e3540002          CMP      r4,#2
000264  1a000003          BNE      |L1.632|
;;;153            outpw(REG_ETMR2_CTL, 0);
000268  e3a00000          MOV      r0,#0
00026c  e59f1340          LDR      r1,|L1.1460|
000270  e5810000          STR      r0,[r1,#0]
000274  ea000002          B        |L1.644|
                  |L1.632|
;;;154        } else {
;;;155            outpw(REG_ETMR3_CTL, 0);
000278  e3a00000          MOV      r0,#0
00027c  e59f1338          LDR      r1,|L1.1468|
000280  e5810000          STR      r0,[r1,#0]
                  |L1.644|
;;;156        }
;;;157    
;;;158        if(u32Clk == 10000) {         // min delay is 100us if timer clock source is LIRC 10k
000284  e2450a02          SUB      r0,r5,#0x2000
000288  e2500e71          SUBS     r0,r0,#0x710
00028c  1a000005          BNE      |L1.680|
;;;159            u32Usec = ((u32Usec + 99) / 100) * 100;
000290  e3a01064          MOV      r1,#0x64
000294  e2860063          ADD      r0,r6,#0x63
000298  ebfffffe          BL       __aeabi_uidivmod
00029c  e3a01064          MOV      r1,#0x64
0002a0  e0060190          MUL      r6,r0,r1
0002a4  ea000004          B        |L1.700|
                  |L1.680|
;;;160        } else {    // 10 usec every step
;;;161            u32Usec = ((u32Usec + 9) / 10) * 10;
0002a8  e3a0100a          MOV      r1,#0xa
0002ac  e2860009          ADD      r0,r6,#9
0002b0  ebfffffe          BL       __aeabi_uidivmod
0002b4  e0800100          ADD      r0,r0,r0,LSL #2
0002b8  e1a06080          LSL      r6,r0,#1
                  |L1.700|
;;;162        }
;;;163    
;;;164        if(u32Clk >= 0x4000000) {
0002bc  e3550301          CMP      r5,#0x4000000
0002c0  3a000002          BCC      |L1.720|
;;;165            u32Prescale = 7;    // real prescaler value is 8
0002c4  e3a09007          MOV      r9,#7
;;;166            u32Clk >>= 3;
0002c8  e1a051a5          LSR      r5,r5,#3
0002cc  ea000008          B        |L1.756|
                  |L1.720|
;;;167        } else if(u32Clk >= 0x2000000) {
0002d0  e3550402          CMP      r5,#0x2000000
0002d4  3a000002          BCC      |L1.740|
;;;168            u32Prescale = 3;    // real prescaler value is 4
0002d8  e3a09003          MOV      r9,#3
;;;169            u32Clk >>= 2;
0002dc  e1a05125          LSR      r5,r5,#2
0002e0  ea000003          B        |L1.756|
                  |L1.740|
;;;170        } else if(u32Clk >= 0x1000000) {
0002e4  e3550401          CMP      r5,#0x1000000
0002e8  3a000001          BCC      |L1.756|
;;;171            u32Prescale = 1;    // real prescaler value is 2
0002ec  e3a09001          MOV      r9,#1
;;;172            u32Clk >>= 1;
0002f0  e1a050a5          LSR      r5,r5,#1
                  |L1.756|
;;;173        }
;;;174    
;;;175        // u32Usec * u32Clk might overflow if using UINT
;;;176        fCmpr = ((float)u32Usec * (float)u32Clk) / 1000000.0;
0002f4  e1a00005          MOV      r0,r5
0002f8  ebfffffe          BL       __aeabi_ui2f
0002fc  e58d0008          STR      r0,[sp,#8]
000300  e1a00006          MOV      r0,r6
000304  ebfffffe          BL       __aeabi_ui2f
000308  e58d0004          STR      r0,[sp,#4]
00030c  e59d1008          LDR      r1,[sp,#8]
000310  ebfffffe          BL       __aeabi_fmul
000314  e58d000c          STR      r0,[sp,#0xc]
000318  ebfffffe          BL       __aeabi_f2d
00031c  e3a02000          MOV      r2,#0
000320  e1cd01f0          STRD     r0,r1,[sp,#0x10]
000324  e59f3298          LDR      r3,|L1.1476|
000328  ebfffffe          BL       __aeabi_ddiv
00032c  e1a07000          MOV      r7,r0
000330  ebfffffe          BL       __aeabi_d2f
000334  e1a0b000          MOV      r11,r0
;;;177    
;;;178        if(timer == 0) {
000338  e3540000          CMP      r4,#0
00033c  1a000009          BNE      |L1.872|
;;;179            outpw(REG_ETMR0_CMPR, (UINT)fCmpr);
000340  e1a0000b          MOV      r0,r11
000344  ebfffffe          BL       __aeabi_f2uiz
000348  e59f1250          LDR      r1,|L1.1440|
00034c  e5810000          STR      r0,[r1,#0]
;;;180            outpw(REG_ETMR0_PRECNT, u32Prescale);
000350  e2410004          SUB      r0,r1,#4
000354  e5809000          STR      r9,[r0,#0]
;;;181            outpw(REG_ETMR0_CTL, 1);
000358  e3a00001          MOV      r0,#1
00035c  e1c11180          BIC      r1,r1,r0,LSL #3
000360  e5810000          STR      r0,[r1,#0]
000364  ea000020          B        |L1.1004|
                  |L1.872|
;;;182        } else if(timer == 1) {
000368  e3540001          CMP      r4,#1
00036c  1a000009          BNE      |L1.920|
;;;183            outpw(REG_ETMR1_CMPR, (UINT)fCmpr);
000370  e1a0000b          MOV      r0,r11
000374  ebfffffe          BL       __aeabi_f2uiz
000378  e59f1228          LDR      r1,|L1.1448|
00037c  e5810000          STR      r0,[r1,#0]
;;;184            outpw(REG_ETMR1_PRECNT, u32Prescale);
000380  e2410004          SUB      r0,r1,#4
000384  e5809000          STR      r9,[r0,#0]
;;;185            outpw(REG_ETMR1_CTL, 1);
000388  e3a00001          MOV      r0,#1
00038c  e1c11180          BIC      r1,r1,r0,LSL #3
000390  e5810000          STR      r0,[r1,#0]
000394  ea000014          B        |L1.1004|
                  |L1.920|
;;;186        } else if(timer == 2) {
000398  e3540002          CMP      r4,#2
00039c  1a000009          BNE      |L1.968|
;;;187            outpw(REG_ETMR2_CMPR, (UINT)fCmpr);
0003a0  e1a0000b          MOV      r0,r11
0003a4  ebfffffe          BL       __aeabi_f2uiz
0003a8  e59f1200          LDR      r1,|L1.1456|
0003ac  e5810000          STR      r0,[r1,#0]
;;;188            outpw(REG_ETMR2_PRECNT, u32Prescale);
0003b0  e2410004          SUB      r0,r1,#4
0003b4  e5809000          STR      r9,[r0,#0]
;;;189            outpw(REG_ETMR2_CTL, 1);
0003b8  e3a00001          MOV      r0,#1
0003bc  e1c11180          BIC      r1,r1,r0,LSL #3
0003c0  e5810000          STR      r0,[r1,#0]
0003c4  ea000008          B        |L1.1004|
                  |L1.968|
;;;190        } else {
;;;191            outpw(REG_ETMR3_CMPR, (UINT)fCmpr);
0003c8  e1a0000b          MOV      r0,r11
0003cc  ebfffffe          BL       __aeabi_f2uiz
0003d0  e59f11e0          LDR      r1,|L1.1464|
0003d4  e5810000          STR      r0,[r1,#0]
;;;192            outpw(REG_ETMR3_PRECNT, u32Prescale);
0003d8  e2410004          SUB      r0,r1,#4
0003dc  e5809000          STR      r9,[r0,#0]
;;;193            outpw(REG_ETMR3_CTL, 1);
0003e0  e3a00001          MOV      r0,#1
0003e4  e1c11180          BIC      r1,r1,r0,LSL #3
0003e8  e5810000          STR      r0,[r1,#0]
                  |L1.1004|
;;;194        }
;;;195    
;;;196        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;197        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;198        for(; delay > 0; delay--) {
0003ec  ea000001          B        |L1.1016|
                  |L1.1008|
;;;199            __asm {
;;;200                NOP
0003f0  e1a00000          MOV      r0,r0
0003f4  e24aa001          SUB      r10,r10,#1            ;198
                  |L1.1016|
0003f8  e35a0000          CMP      r10,#0                ;198
0003fc  1afffffb          BNE      |L1.1008|
;;;201            }
;;;202        }
;;;203    
;;;204        if(timer == 0) {
000400  e3540000          CMP      r4,#0
000404  1a000005          BNE      |L1.1056|
;;;205            while(inpw(REG_ETMR0_CTL) & 0x80);
000408  e1a00000          MOV      r0,r0
                  |L1.1036|
00040c  e59f0190          LDR      r0,|L1.1444|
000410  e5900000          LDR      r0,[r0,#0]
000414  e3100080          TST      r0,#0x80
000418  1afffffb          BNE      |L1.1036|
00041c  ea000014          B        |L1.1140|
                  |L1.1056|
;;;206        } else if(timer == 1) {
000420  e3540001          CMP      r4,#1
000424  1a000005          BNE      |L1.1088|
;;;207            while(inpw(REG_ETMR1_CTL) & 0x80);
000428  e1a00000          MOV      r0,r0
                  |L1.1068|
00042c  e59f0178          LDR      r0,|L1.1452|
000430  e5900000          LDR      r0,[r0,#0]
000434  e3100080          TST      r0,#0x80
000438  1afffffb          BNE      |L1.1068|
00043c  ea00000c          B        |L1.1140|
                  |L1.1088|
;;;208        } else if(timer == 2) {
000440  e3540002          CMP      r4,#2
000444  1a000005          BNE      |L1.1120|
;;;209            while(inpw(REG_ETMR2_CTL) & 0x80);
000448  e1a00000          MOV      r0,r0
                  |L1.1100|
00044c  e59f0160          LDR      r0,|L1.1460|
000450  e5900000          LDR      r0,[r0,#0]
000454  e3100080          TST      r0,#0x80
000458  1afffffb          BNE      |L1.1100|
00045c  ea000004          B        |L1.1140|
                  |L1.1120|
;;;210        } else {
;;;211            while(inpw(REG_ETMR3_CTL) & 0x80);
000460  e1a00000          MOV      r0,r0
                  |L1.1124|
000464  e59f0150          LDR      r0,|L1.1468|
000468  e5900000          LDR      r0,[r0,#0]
00046c  e3100080          TST      r0,#0x80
000470  1afffffb          BNE      |L1.1124|
                  |L1.1140|
;;;212        }
;;;213    }
000474  e28dd01c          ADD      sp,sp,#0x1c
000478  e8bd8ff0          POP      {r4-r11,pc}
;;;214    
                          ENDP

                  ETIMER_EnableCapture PROC
;;;229      */
;;;230    void ETIMER_EnableCapture(UINT timer, UINT u32CapMode, UINT u32Edge)
00047c  e3500000          CMP      r0,#0
;;;231    {
;;;232        if(timer == 0) {
000480  1a000008          BNE      |L1.1192|
;;;233            outpw(REG_ETMR0_CTL, (inpw(REG_ETMR0_CTL) & ~0x1E0000) | u32CapMode | u32Edge | 0x10000);
000484  e59f3118          LDR      r3,|L1.1444|
000488  e5933000          LDR      r3,[r3,#0]
00048c  e3c3381e          BIC      r3,r3,#0x1e0000
000490  e1833001          ORR      r3,r3,r1
000494  e1833002          ORR      r3,r3,r2
000498  e3833801          ORR      r3,r3,#0x10000
00049c  e59fc100          LDR      r12,|L1.1444|
0004a0  e58c3000          STR      r3,[r12,#0]
0004a4  ea00001d          B        |L1.1312|
                  |L1.1192|
;;;234        } else if(timer == 1) {
0004a8  e3500001          CMP      r0,#1
0004ac  1a000008          BNE      |L1.1236|
;;;235            outpw(REG_ETMR1_CTL, (inpw(REG_ETMR1_CTL) & ~0x1E0000) | u32CapMode | u32Edge | 0x10000);
0004b0  e59f30f4          LDR      r3,|L1.1452|
0004b4  e5933000          LDR      r3,[r3,#0]
0004b8  e3c3381e          BIC      r3,r3,#0x1e0000
0004bc  e1833001          ORR      r3,r3,r1
0004c0  e1833002          ORR      r3,r3,r2
0004c4  e3833801          ORR      r3,r3,#0x10000
0004c8  e59fc0dc          LDR      r12,|L1.1452|
0004cc  e58c3000          STR      r3,[r12,#0]
0004d0  ea000012          B        |L1.1312|
                  |L1.1236|
;;;236        } else if(timer == 2) {
0004d4  e3500002          CMP      r0,#2
0004d8  1a000008          BNE      |L1.1280|
;;;237            outpw(REG_ETMR2_CTL, (inpw(REG_ETMR2_CTL) & ~0x1E0000) | u32CapMode | u32Edge | 0x10000);
0004dc  e59f30d0          LDR      r3,|L1.1460|
0004e0  e5933000          LDR      r3,[r3,#0]
0004e4  e3c3381e          BIC      r3,r3,#0x1e0000
0004e8  e1833001          ORR      r3,r3,r1
0004ec  e1833002          ORR      r3,r3,r2
0004f0  e3833801          ORR      r3,r3,#0x10000
0004f4  e59fc0b8          LDR      r12,|L1.1460|
0004f8  e58c3000          STR      r3,[r12,#0]
0004fc  ea000007          B        |L1.1312|
                  |L1.1280|
;;;238        } else {
;;;239            outpw(REG_ETMR3_CTL, (inpw(REG_ETMR3_CTL) & ~0x1E0000) | u32CapMode | u32Edge | 0x10000);
000500  e59f30b4          LDR      r3,|L1.1468|
000504  e5933000          LDR      r3,[r3,#0]
000508  e3c3381e          BIC      r3,r3,#0x1e0000
00050c  e1833001          ORR      r3,r3,r1
000510  e1833002          ORR      r3,r3,r2
000514  e3833801          ORR      r3,r3,#0x10000
000518  e59fc09c          LDR      r12,|L1.1468|
00051c  e58c3000          STR      r3,[r12,#0]
                  |L1.1312|
;;;240        }
;;;241    }
000520  e12fff1e          BX       lr
;;;242    
                          ENDP

                  ETIMER_DisableCapture PROC
;;;247      */
;;;248    void ETIMER_DisableCapture(UINT timer)
000524  e3500000          CMP      r0,#0
;;;249    {
;;;250        if(timer == 0) {
000528  1a000005          BNE      |L1.1348|
;;;251            outpw(REG_ETMR0_CTL, inpw(REG_ETMR0_CTL) & ~0x10000);
00052c  e59f1070          LDR      r1,|L1.1444|
000530  e5911000          LDR      r1,[r1,#0]
000534  e3c11801          BIC      r1,r1,#0x10000
000538  e59f2064          LDR      r2,|L1.1444|
00053c  e5821000          STR      r1,[r2,#0]
000540  ea000014          B        |L1.1432|
                  |L1.1348|
;;;252        } else if(timer == 1) {
000544  e3500001          CMP      r0,#1
000548  1a000005          BNE      |L1.1380|
;;;253            outpw(REG_ETMR1_CTL, inpw(REG_ETMR1_CTL) & ~0x10000);
00054c  e59f1058          LDR      r1,|L1.1452|
000550  e5911000          LDR      r1,[r1,#0]
000554  e3c11801          BIC      r1,r1,#0x10000
000558  e59f204c          LDR      r2,|L1.1452|
00055c  e5821000          STR      r1,[r2,#0]
000560  ea00000c          B        |L1.1432|
                  |L1.1380|
;;;254        } else if(timer == 2) {
000564  e3500002          CMP      r0,#2
000568  1a000005          BNE      |L1.1412|
;;;255            outpw(REG_ETMR2_CTL, inpw(REG_ETMR2_CTL) & ~0x10000);
00056c  e59f1040          LDR      r1,|L1.1460|
000570  e5911000          LDR      r1,[r1,#0]
000574  e3c11801          BIC      r1,r1,#0x10000
000578  e59f2034          LDR      r2,|L1.1460|
00057c  e5821000          STR      r1,[r2,#0]
000580  ea000004          B        |L1.1432|
                  |L1.1412|
;;;256        } else {
;;;257            outpw(REG_ETMR3_CTL, inpw(REG_ETMR3_CTL) & ~0x10000);
000584  e59f1030          LDR      r1,|L1.1468|
000588  e5911000          LDR      r1,[r1,#0]
00058c  e3c11801          BIC      r1,r1,#0x10000
000590  e59f2024          LDR      r2,|L1.1468|
000594  e5821000          STR      r1,[r2,#0]
                  |L1.1432|
;;;258        }
;;;259    
;;;260    }
000598  e12fff1e          BX       lr
;;;261    
                          ENDP

                  |L1.1436|
                          DCD      0x00b71b00
                  |L1.1440|
                          DCD      0xb8001408
                  |L1.1444|
                          DCD      0xb8001400
                  |L1.1448|
                          DCD      0xb8001508
                  |L1.1452|
                          DCD      0xb8001500
                  |L1.1456|
                          DCD      0xb8001608
                  |L1.1460|
                          DCD      0xb8001600
                  |L1.1464|
                          DCD      0xb8001708
                  |L1.1468|
                          DCD      0xb8001700
                  |L1.1472|
                          DCD      0x11e1a300
                  |L1.1476|
                          DCD      0x412e8480
