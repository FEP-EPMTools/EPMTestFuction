L 1 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c"
N/**************************************************************************//**
N * @file     ehci_iso.c
N * @version  V1.10
N * $Revision: 11 $
N * $Date: 14/10/03 1:54p $
N * @brief   USB EHCI isochornous transfer driver.
N *
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#include <stdio.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 13 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 14 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 15 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N
N#include "nuc970.h"
L 1 "..\..\common\src\BSP\Driver\Include\nuc970.h" 1
N/**************************************************************************//**
N * @file     nuc970.h
N * @version  V1.00
N * $Revision: 30 $
N * $Date: 15/06/12 2:51p $
N * @brief    NUC970 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro NUC970 MCU.
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro NUC970 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of NUC970 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N   */
N/**
N  * \page pg1 Revision History
N  *
N  * <b>Revision 1.00.000</b>
N  * \li Added 2D, CAN, CAP, JPEG, KPI, LCD, NAND, RTC, SC, SCUART drivers and sample codes
N  * \li Added USBH UAC class support
N  * \li Fixed compilation warnings
N  *
N  * <b>Revision 0.09.000</b>
N  * \li Preliminary release.
N*/
N#ifndef __NUC970_H__
N#define __NUC970_H__
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 67 "..\..\common\src\BSP\Driver\Include\nuc970.h" 2
N
N/** @addtogroup NUC970_PERIPHERAL_MEM_MAP NUC970 Peripheral Memory Base
N  Memory Mapped Structure for NUC970 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N#define    CRPT_BA   0xB000F000  /*!< Crypto Engine Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    KPI_BA    0xB8008000  /*!< Keypad Interface Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N#define    MTP_BA    0xB800C000  /*!< MTP Control */
N
N/*@}*/ /* end of group NUC970_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup NUC970_Peripherals NUC970 Control Register
N  NUC970 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N/*---------------------- Cryptographic Accelerator -------------------------*/
N/**
N    @addtogroup CRYPTO Cryptographic Accelerator(CRYPTO)
N    Memory Mapped Structure for Cryptographic Accelerator registers
N@{ */
N
N/* Crypto Control Registers */
N#define     CRPT_INTEN          (CRPT_BA+0x000)  /*!< Crypto Interrupt Enable Control Register      */
N#define     CRPT_INTSTS         (CRPT_BA+0x004)  /*!< Crypto Interrupt Flag                         */
N
N/* PRNG Registers */
N#define     CRPT_PRNG_CTL       (CRPT_BA+0x008)  /*!< PRNG Control Register                         */
N#define     CRPT_PRNG_SEED      (CRPT_BA+0x00C)  /*!< Seed for PRNG                                 */
N#define     CRPT_PRNG_KEY0      (CRPT_BA+0x010)  /*!< PRNG Generated Key 0                          */
N#define     CRPT_PRNG_KEY1      (CRPT_BA+0x014)  /*!< PRNG Generated Key 1                          */
N#define     CRPT_PRNG_KEY2      (CRPT_BA+0x018)  /*!< PRNG Generated Key 2                          */
N#define     CRPT_PRNG_KEY3      (CRPT_BA+0x01C)  /*!< PRNG Generated Key 3                          */
N#define     CRPT_PRNG_KEY4      (CRPT_BA+0x020)  /*!< PRNG Generated Key 4                          */
N#define     CRPT_PRNG_KEY5      (CRPT_BA+0x024)  /*!< PRNG Generated Key 5                          */
N#define     CRPT_PRNG_KEY6      (CRPT_BA+0x028)  /*!< PRNG Generated Key 6                          */
N#define     CRPT_PRNG_KEY7      (CRPT_BA+0x02C)  /*!< PRNG Generated Key 7                          */
N
N/* AES/TDES feedback Registers */
N#define     CRPT_AES_FDBCK0     (CRPT_BA+0x050)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK1     (CRPT_BA+0x054)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK2     (CRPT_BA+0x058)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_AES_FDBCK3     (CRPT_BA+0x05C)  /*!< AES Engine Output Feedback Data after Cryptographic Operation   */
N#define     CRPT_TDES_FDBCKH    (CRPT_BA+0x060)  /*!< TDES/DES Engine Output Feedback High Word Data after Cryptographic Operation  */
N#define     CRPT_TDES_FDBCKL    (CRPT_BA+0x064)  /*!< TDES/DES Engine Output Feedback Low Word Data after Cryptographic Operation   */
N
N/* AES Control Registers */
N#define     CRPT_AES_CTL        (CRPT_BA+0x100)   /*!< AES Control Register                               */
N#define     CRPT_AES_STS        (CRPT_BA+0x104)   /*!< AES Engine Flag                                    */
N#define     CRPT_AES_DATIN      (CRPT_BA+0x108)   /*!< AES Engine Data Input Port Register                */
N#define     CRPT_AES_DATOUT     (CRPT_BA+0x10C)   /*!< AES Engine Data Output Port Register               */
N#define     CRPT_AES0_KEY0      (CRPT_BA+0x110)   /*!< AES Key Word 0 Register for Channel 0              */
N#define     CRPT_AES0_KEY1      (CRPT_BA+0x114)   /*!< AES Key Word 1 Register for Channel 0              */
N#define     CRPT_AES0_KEY2      (CRPT_BA+0x118)   /*!< AES Key Word 2 Register for Channel 0              */
N#define     CRPT_AES0_KEY3      (CRPT_BA+0x11C)   /*!< AES Key Word 3 Register for Channel 0              */
N#define     CRPT_AES0_KEY4      (CRPT_BA+0x120)   /*!< AES Key Word 4 Register for Channel 0              */
N#define     CRPT_AES0_KEY5      (CRPT_BA+0x124)   /*!< AES Key Word 5 Register for Channel 0              */
N#define     CRPT_AES0_KEY6      (CRPT_BA+0x128)   /*!< AES Key Word 6 Register for Channel 0              */
N#define     CRPT_AES0_KEY7      (CRPT_BA+0x12C)   /*!< AES Key Word 7 Register for Channel 0              */
N#define     CRPT_AES0_IV0       (CRPT_BA+0x130)   /*!< AES Initial Vector Word 0 Register for Channel 0   */
N#define     CRPT_AES0_IV1       (CRPT_BA+0x134)   /*!< AES Initial Vector Word 1 Register for Channel 0   */
N#define     CRPT_AES0_IV2       (CRPT_BA+0x138)   /*!< AES Initial Vector Word 2 Register for Channel 0   */
N#define     CRPT_AES0_IV3       (CRPT_BA+0x13C)   /*!< AES Initial Vector Word 3 Register for Channel 0   */
N#define     CRPT_AES0_SADDR     (CRPT_BA+0x140)   /*!< AES DMA Source Address Register for Channel 0      */
N#define     CRPT_AES0_DADDR     (CRPT_BA+0x144)   /*!< AES DMA Destination Address Register for Channel 0 */
N#define     CRPT_AES0_CNT       (CRPT_BA+0x148)   /*!< AES Byte Count Register for Channel 0              */
N#define     CRPT_AES1_KEY0      (CRPT_BA+0x14C)   /*!< AES Key Word 0 Register for Channel 1              */
N#define     CRPT_AES1_KEY1      (CRPT_BA+0x150)   /*!< AES Key Word 1 Register for Channel 1              */
N#define     CRPT_AES1_KEY2      (CRPT_BA+0x154)   /*!< AES Key Word 2 Register for Channel 1              */
N#define     CRPT_AES1_KEY3      (CRPT_BA+0x158)   /*!< AES Key Word 3 Register for Channel 1              */
N#define     CRPT_AES1_KEY4      (CRPT_BA+0x15C)   /*!< AES Key Word 4 Register for Channel 1              */
N#define     CRPT_AES1_KEY5      (CRPT_BA+0x160)   /*!< AES Key Word 5 Register for Channel 1              */
N#define     CRPT_AES1_KEY6      (CRPT_BA+0x164)   /*!< AES Key Word 6 Register for Channel 1              */
N#define     CRPT_AES1_KEY7      (CRPT_BA+0x168)   /*!< AES Key Word 7 Register for Channel 1              */
N#define     CRPT_AES1_IV0       (CRPT_BA+0x16C)   /*!< AES Initial Vector Word 0 Register for Channel 1   */
N#define     CRPT_AES1_IV1       (CRPT_BA+0x170)   /*!< AES Initial Vector Word 1 Register for Channel 1   */
N#define     CRPT_AES1_IV2       (CRPT_BA+0x174)   /*!< AES Initial Vector Word 2 Register for Channel 1   */
N#define     CRPT_AES1_IV3       (CRPT_BA+0x178)   /*!< AES Initial Vector Word 3 Register for Channel 1   */
N#define     CRPT_AES1_SADDR     (CRPT_BA+0x17C)   /*!< AES DMA Source Address Register for Channel 1      */
N#define     CRPT_AES1_DADDR     (CRPT_BA+0x180)   /*!< AES DMA Destination Address Register for Channel 1 */
N#define     CRPT_AES1_CNT       (CRPT_BA+0x184)   /*!< AES Byte Count Register for Channel 1              */
N#define     CRPT_AES2_KEY0      (CRPT_BA+0x188)   /*!< AES Key Word 0 Register for Channel 2              */
N#define     CRPT_AES2_KEY1      (CRPT_BA+0x18C)   /*!< AES Key Word 1 Register for Channel 2              */
N#define     CRPT_AES2_KEY2      (CRPT_BA+0x190)   /*!< AES Key Word 2 Register for Channel 2              */
N#define     CRPT_AES2_KEY3      (CRPT_BA+0x194)   /*!< AES Key Word 3 Register for Channel 2              */
N#define     CRPT_AES2_KEY4      (CRPT_BA+0x198)   /*!< AES Key Word 4 Register for Channel 2              */
N#define     CRPT_AES2_KEY5      (CRPT_BA+0x19C)   /*!< AES Key Word 5 Register for Channel 2              */
N#define     CRPT_AES2_KEY6      (CRPT_BA+0x1A0)   /*!< AES Key Word 6 Register for Channel 2              */
N#define     CRPT_AES2_KEY7      (CRPT_BA+0x1A4)   /*!< AES Key Word 7 Register for Channel 2              */
N#define     CRPT_AES2_IV0       (CRPT_BA+0x1A8)   /*!< AES Initial Vector Word 0 Register for Channel 2   */
N#define     CRPT_AES2_IV1       (CRPT_BA+0x1AC)   /*!< AES Initial Vector Word 1 Register for Channel 2   */
N#define     CRPT_AES2_IV2       (CRPT_BA+0x1B0)   /*!< AES Initial Vector Word 2 Register for Channel 2   */
N#define     CRPT_AES2_IV3       (CRPT_BA+0x1B4)   /*!< AES Initial Vector Word 3 Register for Channel 2   */
N#define     CRPT_AES2_SADDR     (CRPT_BA+0x1B8)   /*!< AES DMA Source Address Register for Channel 2      */
N#define     CRPT_AES2_DADDR     (CRPT_BA+0x1BC)   /*!< AES DMA Destination Address Register for Channel 2 */
N#define     CRPT_AES2_CNT       (CRPT_BA+0x1C0)   /*!< AES Byte Count Register for Channel 2              */
N#define     CRPT_AES3_KEY0      (CRPT_BA+0x1C4)   /*!< AES Key Word 0 Register for Channel 3              */
N#define     CRPT_AES3_KEY1      (CRPT_BA+0x1C8)   /*!< AES Key Word 1 Register for Channel 3              */
N#define     CRPT_AES3_KEY2      (CRPT_BA+0x1CC)   /*!< AES Key Word 2 Register for Channel 3              */
N#define     CRPT_AES3_KEY3      (CRPT_BA+0x1D0)   /*!< AES Key Word 3 Register for Channel 3              */
N#define     CRPT_AES3_KEY4      (CRPT_BA+0x1D4)   /*!< AES Key Word 4 Register for Channel 3              */
N#define     CRPT_AES3_KEY5      (CRPT_BA+0x1D8)   /*!< AES Key Word 5 Register for Channel 3              */
N#define     CRPT_AES3_KEY6      (CRPT_BA+0x1DC)   /*!< AES Key Word 6 Register for Channel 3              */
N#define     CRPT_AES3_KEY7      (CRPT_BA+0x1E0)   /*!< AES Key Word 7 Register for Channel 3              */
N#define     CRPT_AES3_IV0       (CRPT_BA+0x1E4)   /*!< AES Initial Vector Word 0 Register for Channel 3   */
N#define     CRPT_AES3_IV1       (CRPT_BA+0x1E8)   /*!< AES Initial Vector Word 1 Register for Channel 3   */
N#define     CRPT_AES3_IV2       (CRPT_BA+0x1EC)   /*!< AES Initial Vector Word 2 Register for Channel 3   */
N#define     CRPT_AES3_IV3       (CRPT_BA+0x1F0)   /*!< AES Initial Vector Word 3 Register for Channel 3   */
N#define     CRPT_AES3_SADDR     (CRPT_BA+0x1F4)   /*!< AES DMA Source Address Register for Channel 3      */
N#define     CRPT_AES3_DADDR     (CRPT_BA+0x1F8)   /*!< AES DMA Destination Address Register for Channel 3 */
N#define     CRPT_AES3_CNT       (CRPT_BA+0x1FC)   /*!< AES Byte Count Register for Channel 3              */
N
N/* DES/TDES Control Registers */
N#define     CRPT_TDES_CTL       (CRPT_BA+0x200)   /*!< TDES/DES Control Register                          */
N#define     CRPT_TDES_STS       (CRPT_BA+0x204)   /*!< TDES/DES Engine Flag                               */
N#define     CRPT_TDES0_KEY1H    (CRPT_BA+0x208)   /*!< TDES/DES Key 1 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY1L    (CRPT_BA+0x20C)   /*!< TDES/DES Key 1 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY2H    (CRPT_BA+0x210)   /*!< TDES/DES Key 2 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY2L    (CRPT_BA+0x214)   /*!< TDES/DES Key 2 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_KEY3H    (CRPT_BA+0x218)   /*!< TDES/DES Key 3 High Word Register for Channel 0    */
N#define     CRPT_TDES0_KEY3L    (CRPT_BA+0x21C)   /*!< TDES/DES Key 3 Low Word Register for Channel 0     */
N#define     CRPT_TDES0_IVH      (CRPT_BA+0x220)   /*!< TDES/DES Initial Vector High Word Register for Channel 0 */
N#define     CRPT_TDES0_IVL      (CRPT_BA+0x224)   /*!< TDES/DES Initial Vector Low Word Register for Channel 0  */
N#define     CRPT_TDES0_SADDR    (CRPT_BA+0x228)   /*!< TDES/DES DMA Source Address Register for Channel 0       */
N#define     CRPT_TDES0_DADDR    (CRPT_BA+0x22C)   /*!< TDES/DES DMA Destination Address Register for Channel 0  */
N#define     CRPT_TDES0_CNT      (CRPT_BA+0x230)   /*!< TDES/DES Byte Count Register for Channel 0         */
N#define     CRPT_TDES_DATIN     (CRPT_BA+0x234)   /*!< TDES/DES Engine Input data Word Register           */
N#define     CRPT_TDES_DATOUT    (CRPT_BA+0x238)   /*!< TDES/DES Engine Output data Word Register          */
N#define     CRPT_TDES1_KEY1H    (CRPT_BA+0x248)   /*!< TDES/DES Key 1 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY1L    (CRPT_BA+0x24C)   /*!< TDES/DES Key 1 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY2H    (CRPT_BA+0x250)   /*!< TDES/DES Key 2 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY2L    (CRPT_BA+0x254)   /*!< TDES/DES Key 2 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_KEY3H    (CRPT_BA+0x258)   /*!< TDES/DES Key 3 High Word Register for Channel 1    */
N#define     CRPT_TDES1_KEY3L    (CRPT_BA+0x25C)   /*!< TDES/DES Key 3 Low Word Register for Channel 1     */
N#define     CRPT_TDES1_IVH      (CRPT_BA+0x260)   /*!< TDES/DES Initial Vector High Word Register for Channel 1 */
N#define     CRPT_TDES1_IVL      (CRPT_BA+0x264)   /*!< TDES/DES Initial Vector Low Word Register for Channel 1  */
N#define     CRPT_TDES1_SADDR    (CRPT_BA+0x268)   /*!< TDES/DES DMA Source Address Register for Channel 1       */
N#define     CRPT_TDES1_DADDR    (CRPT_BA+0x26C)   /*!< TDES/DES DMA Destination Address Register for Channel 1  */
N#define     CRPT_TDES1_CNT      (CRPT_BA+0x270)   /*!< TDES/DES Byte Count Register for Channel 1         */
N#define     CRPT_TDES2_KEY1H    (CRPT_BA+0x288)   /*!< TDES/DES Key 1 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY1L    (CRPT_BA+0x28C)   /*!< TDES/DES Key 1 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY2H    (CRPT_BA+0x290)   /*!< TDES/DES Key 2 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY2L    (CRPT_BA+0x294)   /*!< TDES/DES Key 2 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_KEY3H    (CRPT_BA+0x298)   /*!< TDES/DES Key 3 High Word Register for Channel 2    */
N#define     CRPT_TDES2_KEY3L    (CRPT_BA+0x29C)   /*!< TDES/DES Key 3 Low Word Register for Channel 2     */
N#define     CRPT_TDES2_IVH      (CRPT_BA+0x2A0)   /*!< TDES/DES Initial Vector High Word Register for Channel 2 */
N#define     CRPT_TDES2_IVL      (CRPT_BA+0x2A4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 2  */
N#define     CRPT_TDES2_SADDR    (CRPT_BA+0x2A8)   /*!< TDES/DES DMA Source Address Register for Channel 2       */
N#define     CRPT_TDES2_DADDR    (CRPT_BA+0x2AC)   /*!< TDES/DES DMA Destination Address Register for Channel 2  */
N#define     CRPT_TDES2_CNT      (CRPT_BA+0x2B0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N#define     CRPT_TDES3_KEY1H    (CRPT_BA+0x2C8)   /*!< TDES/DES Key 1 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY1L    (CRPT_BA+0x2CC)   /*!< TDES/DES Key 1 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY2H    (CRPT_BA+0x2D0)   /*!< TDES/DES Key 2 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY2L    (CRPT_BA+0x2D4)   /*!< TDES/DES Key 2 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_KEY3H    (CRPT_BA+0x2D8)   /*!< TDES/DES Key 3 High Word Register for Channel 3    */
N#define     CRPT_TDES3_KEY3L    (CRPT_BA+0x2DC)   /*!< TDES/DES Key 3 Low Word Register for Channel 3     */
N#define     CRPT_TDES3_IVH      (CRPT_BA+0x2E0)   /*!< TDES/DES Initial Vector High Word Register for Channel 3 */
N#define     CRPT_TDES3_IVL      (CRPT_BA+0x2E4)   /*!< TDES/DES Initial Vector Low Word Register for Channel 3  */
N#define     CRPT_TDES3_SADDR    (CRPT_BA+0x2E8)   /*!< TDES/DES DMA Source Address Register for Channel 3       */
N#define     CRPT_TDES3_DADDR    (CRPT_BA+0x2EC)   /*!< TDES/DES DMA Destination Address Register for Channel 3  */
N#define     CRPT_TDES3_CNT      (CRPT_BA+0x2F0)   /*!< TDES/DES Byte Count Register for Channel 3         */
N
N/* SHA/HMAC Control Registers */
N#define     CRPT_HMAC_CTL       (CRPT_BA+0x300)   /*!< SHA/HMAC Control Register                          */
N#define     CRPT_HMAC_STS       (CRPT_BA+0x304)   /*!< SHA/HMAC Status Flag                               */
N#define     CRPT_HMAC_DGST0     (CRPT_BA+0x308)   /*!< SHA/HMAC Digest Message 0                          */
N#define     CRPT_HMAC_DGST1     (CRPT_BA+0x30C)   /*!< SHA/HMAC Digest Message 1                          */
N#define     CRPT_HMAC_DGST2     (CRPT_BA+0x310)   /*!< SHA/HMAC Digest Message 2                          */
N#define     CRPT_HMAC_DGST3     (CRPT_BA+0x314)   /*!< SHA/HMAC Digest Message 3                          */
N#define     CRPT_HMAC_DGST4     (CRPT_BA+0x318)   /*!< SHA/HMAC Digest Message 4                          */
N#define     CRPT_HMAC_DGST5     (CRPT_BA+0x31C)   /*!< SHA/HMAC Digest Message 5                          */
N#define     CRPT_HMAC_DGST6     (CRPT_BA+0x320)   /*!< SHA/HMAC Digest Message 6                          */
N#define     CRPT_HMAC_DGST7     (CRPT_BA+0x324)   /*!< SHA/HMAC Digest Message 7                          */
N#define     CRPT_HMAC_DGST8     (CRPT_BA+0x328)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST9     (CRPT_BA+0x32C)   /*!< SHA/HMAC Digest Message 8                          */
N#define     CRPT_HMAC_DGST10    (CRPT_BA+0x330)   /*!< SHA/HMAC Digest Message 10                         */
N#define     CRPT_HMAC_DGST11    (CRPT_BA+0x334)   /*!< SHA/HMAC Digest Message 11                         */
N#define     CRPT_HMAC_DGST12    (CRPT_BA+0x338)   /*!< SHA/HMAC Digest Message 12                         */
N#define     CRPT_HMAC_DGST13    (CRPT_BA+0x33C)   /*!< SHA/HMAC Digest Message 13                         */
N#define     CRPT_HMAC_DGST14    (CRPT_BA+0x340)   /*!< SHA/HMAC Digest Message 14                         */
N#define     CRPT_HMAC_DGST15    (CRPT_BA+0x344)   /*!< SHA/HMAC Digest Message 15                         */
N#define     CRPT_HMAC_KEYCNT    (CRPT_BA+0x348)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_SADDR     (CRPT_BA+0x34C)   /*!< SHA/HMAC Key Byte Count                            */
N#define     CRPT_HMAC_DMACNT    (CRPT_BA+0x350)   /*!< SHA/HMAC Byte Count Register                       */
N#define     CRPT_HMAC_DATIN     (CRPT_BA+0x354)   /*!< SHA/HMAC Engine Non-DMA Mode Data Input Port Register  */
N
N/**@}*/ /* end of Cryptographic Accelerator register group */
N
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Keypad Interface -------------------------*/
N/**
N    @addtogroup KPI Keypad Interface(KPI)
N    Memory Mapped Structure for KPI Controller
N@{ */
N
N#define     REG_KPI_CONF    (KPI_BA+0x00)  /*!< Keypad controller configuration Register */
N#define     REG_KPI_3KCONF  (KPI_BA+0x04)  /*!< Keypad controller 3-keys configuration register */
N#define     REG_KPI_STATUS  (KPI_BA+0x08)  /*!< Keypad status register */
N#define     REG_KPI_RSTC    (KPI_BA+0x0C)  /*!< Keypad  Reset Period Controller register */
N#define     REG_KPI_KEST        (KPI_BA+0x10)  /*!< Keypad Key State Indicator */
N#define     REG_KPI_KPE         (KPI_BA+0x18)  /*!< Press Key Event Indicator */
N#define     REG_KPI_KRE         (KPI_BA+0x20)  /*!< Release Key Event Indicator */
N#define     REG_KPI_PRESCALDIV  (KPI_BA+0x28)  /*!< Pre-Scale Divider */
N
N/**@}*/ /* end of KPI register group */
N
N
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- Multi-Time Programmable Controller --------------------*/
N/**
N    @addtogroup MTP Multi-Time Programmable Controller (MTP)
N    Memory Mapped Structure for MTP Controller
N@{ */
N
N#define     MTP_KEYEN           (MTP_BA+0x000)   /*!< MTP Key Enable Register                       */
N#define     MTP_USERDATA        (MTP_BA+0x00C)   /*!< MTP User Defined Data Register                */
N#define     MTP_KEY0            (MTP_BA+0x010)   /*!< MTP KEY 0 Register                            */
N#define     MTP_KEY1            (MTP_BA+0x014)   /*!< MTP KEY 1 Register                            */
N#define     MTP_KEY2            (MTP_BA+0x018)   /*!< MTP KEY 2 Register                            */
N#define     MTP_KEY3            (MTP_BA+0x01C)   /*!< MTP KEY 3 Register                            */
N#define     MTP_KEY4            (MTP_BA+0x020)   /*!< MTP KEY 4 Register                            */
N#define     MTP_KEY5            (MTP_BA+0x024)   /*!< MTP KEY 5 Register                            */
N#define     MTP_KEY6            (MTP_BA+0x028)   /*!< MTP KEY 6 Register                            */
N#define     MTP_KEY7            (MTP_BA+0x02C)   /*!< MTP KEY 7 Register                            */
N#define     MTP_PCYCLE          (MTP_BA+0x030)   /*!< MTP Program Cycle Program Count Register      */
N#define     MTP_CTL             (MTP_BA+0x034)   /*!< MTP Control Register                          */
N#define     MTP_PSTART          (MTP_BA+0x038)   /*!< MTP Program Start Registe                     */
N#define     MTP_STATUS          (MTP_BA+0x040)   /*!< MTP Status Registe                            */
N#define     MTP_REGLCTL         (MTP_BA+0x050)   /*!< MTP Register Write-Protection Control Register*/
N
N/**@}*/ /* end of MTP register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group NUC970_Peripherals */
N
N
N/** @addtogroup NUC970_IO_ROUTINE NUC970 I/O Routines
N  The Declaration of NUC970 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group NUC970_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup NUC970_legacy_Constants NUC970 Legacy Constants
N  NUC970 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define SPECIAL        (2)
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __NUC970_H__ */
N
N/*@}*/ /* end of group NUC970_legacy_Constants */
L 17 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N
N#include "usb.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\usb.h" 1
N/**************************************************************************//**
N * @file     usb.h
N * @version  V1.00
N * @brief    USB Host library header file.
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef _USBH_H_
N#define _USBH_H_
N
N#include "config.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\config.h" 1
N/**************************************************************************//**
N * @file     config.h
N * @version  V1.00
N * @brief    This header file defines the configuration of USB Host library.
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef  _USBH_CONFIG_H_
N#define  _USBH_CONFIG_H_
N
N/// @cond HIDDEN_SYMBOLS
N
N#include "nuc970.h"
N#include "sys.h"
L 1 "..\..\common\src\BSP\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @version  V1.00
N* $Revision: 6 $
N* $Date: 15/06/12 9:25a $
N* @brief    NUC970 SYS driver header file
N*
N* @note
N* Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Device_Driver NUC970 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup NUC970_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  NUC970 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    CRPT_IRQn               = 35,      /*!< Cryptographic Accelerator Interrupt        */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N    KPI_IRQn                = 61,      /*!< KPI Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N/* Define constants for use external IO in service parameters.  */
N#define EXT0            0
N#define EXT1            1
N#define EXT2            2
N#define EXT3            3
N#define EXT4            4
N
N#define SIZE_256K       4
N#define SIZE_512K       5
N#define SIZE_1M         6
N#define SIZE_2M         7
N#define SIZE_4M         8
N#define SIZE_8M         9
N#define SIZE_16M        10
N#define SIZE_32M        11
N
N#define BUS_DISABLE     12
N#define BUS_BIT_8       13
N#define BUS_BIT_16      14
N#define BUS_BIT_32      15
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    setPrintfFlag(BOOL flag);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    terninalPrintf(PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
N/* Define system library External IO functions */
NINT32   sysSetExternalIO(INT extNo, UINT32 extBaseAddr, UINT32 extSize, INT extBusWidth); /*!< set External IO \hideinitializer */
NINT32   sysSetExternalIOTiming1(INT extNo, INT tACC, INT tACS); /*!< set External IO timing1 \hideinitializer */
NINT32   sysSetExternalIOTiming2(INT extNo, INT tCOH, INT tCOS); /*!< set External IO timing2 \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group NUC970_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_SYS_Driver */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
L 16 "..\..\common\src\BSP\Library\USB_HOST\Inc\config.h" 2
N
N
N/*----------------------------------------------------------------------------------------*/
N/*   Hardware settings                                                                    */
N/*----------------------------------------------------------------------------------------*/
N#define HCLK_MHZ               300          /* used for loop-delay. must be larger than 
N                                               true HCLK clock MHz                        */
N
N#define NON_CACHE_MASK         (0x80000000)
N
N#define ENABLE_OHCI_IRQ()      sysEnableInterrupt(OHCI_IRQn)
N#define DISABLE_OHCI_IRQ()     sysDisableInterrupt(OHCI_IRQn)
N#define IS_OHCI_IRQ_ENABLED()  ((inpw(REG_AIC_IMR)>>OHCI_IRQn) & 0x1)
N#define ENABLE_EHCI_IRQ()      sysEnableInterrupt(EHCI_IRQn)
N#define DISABLE_EHCI_IRQ()     sysDisableInterrupt(EHCI_IRQn)
N#define IS_EHCI_IRQ_ENABLED()  ((inpw(REG_AIC_IMR)>>EHCI_IRQn) & 0x1)
N
N#define ENABLE_OHCI                         /* Enable OHCI host controller                */
N#define ENABLE_EHCI                         /* Enable EHCI host controller                */
N
N#define EHCI_PORT_CNT          2            /* Number of EHCI roothub ports               */
N#define OHCI_PORT_CNT          2            /* Number of OHCI roothub ports               */
N//#define OHCI_PER_PORT_POWER               /* OHCI root hub per port powered             */
N
N#define OHCI_ISO_DELAY         4            /* preserved number frames while scheduling 
N                                               OHCI isochronous transfer                  */
N
N#define EHCI_ISO_DELAY         2            /* preserved number of frames while 
N                                               scheduling EHCI isochronous transfer       */
N
N#define EHCI_ISO_RCLM_RANGE    32           /* When inspecting activated iTD/siTD, 
N                                               unconditionally reclaim iTD/isTD scheduled
N                                               in just elapsed EHCI_ISO_RCLM_RANGE ms.    */
N
N#define MAX_DESC_BUFF_SIZE     4096         /* To hold the configuration descriptor, USB 
N                                               core will allocate a buffer with this size
N                                               for each connected device. USB core does 
N                                               not release it until device disconnected.  */
N
N/*----------------------------------------------------------------------------------------*/
N/*   Memory allocation settings                                                           */
N/*----------------------------------------------------------------------------------------*/
N
N#define STATIC_MEMORY_ALLOC    0       /* pre-allocate static memory blocks. No dynamic memory aloocation.
N                                          But the maximum number of connected devices and transfers are
N                                          limited.  */
N
N#define MAX_UDEV_DRIVER        8       /*!< Maximum number of registered drivers                      */
N#define MAX_ALT_PER_IFACE      12      /*!< maximum number of alternative interfaces per interface    */
N#define MAX_EP_PER_IFACE       8       /*!< maximum number of endpoints per interface                 */
N#define MAX_HUB_DEVICE         8       /*!< Maximum number of hub devices                             */
N
N/* Host controller hardware transfer descriptors memory pool. ED/TD/ITD of OHCI and QH/QTD of EHCI
N   are all allocated from this pool. Allocated unit size is determined by MEM_POOL_UNIT_SIZE.
N   May allocate one or more units depend on hardware descriptor type.                                 */
N
N#define MEM_POOL_UNIT_SIZE     128     /*!< A fixed hard coding setting. Do not change it!            */
N#define MEM_POOL_UNIT_NUM      256     /*!< Increase this or heap size if memory allocate failed.     */
N
N/*----------------------------------------------------------------------------------------*/
N/*   Re-defined staff for various compiler                                                */
N/*----------------------------------------------------------------------------------------*/
N#ifdef __ICCARM__
S#define   __inline    inline
N#endif
N
N
N/*----------------------------------------------------------------------------------------*/
N/*   Debug settings                                                                       */
N/*----------------------------------------------------------------------------------------*/
N#define ENABLE_ERROR_MSG                    /* enable debug messages                      */
N//#define ENABLE_DEBUG_MSG                    /* enable debug messages                      */
N//#define ENABLE_VERBOSE_DEBUG              /* verbos debug messages                      */
N//#define DUMP_DESCRIPTOR                   /* dump descriptors                           */
N
N#ifdef ENABLE_ERROR_MSG
N#define USB_error            sysprintf
N#else
S#define USB_error(...)
N#endif
N
N#ifdef ENABLE_DEBUG_MSG
S#define USB_debug            sysprintf
S#ifdef ENABLE_VERBOSE_DEBUG
S#define USB_vdebug         sysprintf
S#else
S#define USB_vdebug(...)
S#endif
N#else
N#define USB_debug(...)
N#define USB_vdebug(...)
N#endif
N
N
N#define   __I     volatile const       /*!< Defines 'read only' permissions */
N#define   __IO    volatile             /*!< Defines 'read / write' permissions */
N
N
N//typedef unsigned int     uint32_t;
N//typedef unsigned short   uint16_t;
N//typedef unsigned char    uint8_t;
N
N
N
N/*---------------------- USB Host Controller -------------------------*/
N/**
N    @addtogroup USBH USB Host Controller(USBH)
N    Memory Mapped Structure for USBH Controller
N@{ */
N
Ntypedef struct
N{
N
N    /**
N     * @var USBH_T::HcRevision
N     * Offset: 0x00  Host Controller Revision Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |REV       |Revision Number
N     * |        |          |Indicates the Open HCI Specification revision number implemented by the Hardware
N     * |        |          |Host Controller supports 1.1 specification.
N     * |        |          |(X.Y = XYh).
N     * @var USBH_T::HcControl
N     * Offset: 0x04  Host Controller Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |CBSR      |Control Bulk Service Ratio
N     * |        |          |This specifies the service ratio between Control and Bulk EDs
N     * |        |          |Before processing any of the non-periodic lists, HC must compare the ratio specified with its internal count on how many nonempty Control EDs have been processed, in determining whether to continue serving another Control ED or switching to Bulk EDs
N     * |        |          |The internal count will be retained when crossing the frame boundary
N     * |        |          |In case of reset, HCD is responsible for restoring this
N     * |        |          |Value.
N     * |        |          |00 = Number of Control EDs over Bulk EDs served is 1:1.
N     * |        |          |01 = Number of Control EDs over Bulk EDs served is 2:1.
N     * |        |          |10 = Number of Control EDs over Bulk EDs served is 3:1.
N     * |        |          |11 = Number of Control EDs over Bulk EDs served is 4:1.
N     * |[2]     |PLE       |Periodic List Enable Bit
N     * |        |          |When set, this bit enables processing of the Periodic (interrupt and isochronous) list
N     * |        |          |The Host Controller checks this bit prior to attempting any periodic transfers in a frame.
N     * |        |          |0 = Processing of the Periodic (Interrupt and Isochronous) list after next SOF (Start-Of-Frame) Disabled.
N     * |        |          |1 = Processing of the Periodic (Interrupt and Isochronous) list in the next frame Enabled.
N     * |        |          |Note: To enable the processing of the Isochronous list, user has to set both PLE and IE (HcControl[3]) high.
N     * |[3]     |IE        |Isochronous List Enable Bit
N     * |        |          |Both ISOEn and PLE (HcControl[2]) high enables Host Controller to process the Isochronous list
N     * |        |          |Either ISOEn or PLE (HcControl[2]) is low disables Host Controller to process the Isochronous list.
N     * |        |          |0 = Processing of the Isochronous list after next SOF (Start-Of-Frame) Disabled.
N     * |        |          |1 = Processing of the Isochronous list in the next frame Enabled, if the PLE (HcControl[2]) is high, too.
N     * |[4]     |CLE       |Control List Enable Bit
N     * |        |          |0 = Processing of the Control list after next SOF (Start-Of-Frame) Disabled.
N     * |        |          |1 = Processing of the Control list in the next frame Enabled.
N     * |[5]     |BLE       |Bulk List Enable Bit
N     * |        |          |0 = Processing of the Bulk list after next SOF (Start-Of-Frame) Disabled.
N     * |        |          |1 = Processing of the Bulk list in the next frame Enabled.
N     * |[7:6]   |HCFS      |Host Controller Functional State
N     * |        |          |This field sets the Host Controller state
N     * |        |          |The Controller may force a state change from USBSUSPEND to USBRESUME after detecting resume signaling from a downstream port
N     * |        |          |States are:
N     * |        |          |00 = USBSUSPEND.
N     * |        |          |01 = USBOPERATIONAL.
N     * |        |          |10 = USBRESUME.
N     * |        |          |11 = USBRESET.
N     * @var USBH_T::HcCommandStatus
N     * Offset: 0x08  Host Controller Command Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HCR       |Host Controller Reset
N     * |        |          |This bit is set to initiate the software reset of Host Controller
N     * |        |          |This bit is cleared by the Host Controller, upon completed of the reset operation.
N     * |        |          |This bit, when set, didn't reset the Root Hub and no subsequent reset signaling be asserted to its downstream ports.
N     * |        |          |0 = Host Controller is not in software reset state.
N     * |        |          |1 = Host Controller is in software reset state.
N     * |[1]     |CLF       |Control List Filled
N     * |        |          |Set high to indicate there is an active TD on the Control List
N     * |        |          |It may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Control List.
N     * |        |          |0 = No active TD found or Host Controller begins to process the head of the Control list.
N     * |        |          |1 = An active TD added or found on the Control list.
N     * |[2]     |BLF       |Bulk List Filled
N     * |        |          |Set high to indicate there is an active TD on the Bulk list
N     * |        |          |This bit may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Bulk list.
N     * |        |          |0 = No active TD found or Host Controller begins to process the head of the Bulk list.
N     * |        |          |1 = An active TD added or found on the Bulk list.
N     * |[17:16] |SOC       |Schedule Overrun Count
N     * |        |          |These bits are incremented on each scheduling overrun error
N     * |        |          |It is initialized to 00b and wraps around at 11b
N     * |        |          |This will be incremented when a scheduling overrun is detected even if SO (HcInterruptStatus[0]) has already been set.
N     * @var USBH_T::HcInterruptStatus
N     * Offset: 0x0C  Host Controller Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SO        |Scheduling Overrun
N     * |        |          |Set when the List Processor determines a Schedule Overrun has occurred.
N     * |        |          |0 = Schedule Overrun didn't occur.
N     * |        |          |1 = Schedule Overrun has occurred.
N     * |[1]     |WDH       |Write Back Done Head
N     * |        |          |Set after the Host Controller has written HcDoneHead to HccaDoneHead
N     * |        |          |Further updates of the HccaDoneHead will not occur until this bit has been cleared.
N     * |        |          |0 =.Host Controller didn't update HccaDoneHead.
N     * |        |          |1 =.Host Controller has written HcDoneHead to HccaDoneHead.
N     * |[2]     |SF        |Start of Frame
N     * |        |          |Set when the Frame Management functional block signals a 'Start of Frame' event
N     * |        |          |Host Control generates a SOF token at the same time.
N     * |        |          |0 =.Not the start of a frame.
N     * |        |          |1 =.Indicate the start of a frame and Host Controller generates a SOF token.
N     * |[3]     |RD        |Resume Detected
N     * |        |          |Set when Host Controller detects resume signaling on a downstream port.
N     * |        |          |0 = No resume signaling detected on a downstream port.
N     * |        |          |1 = Resume signaling detected on a downstream port.
N     * |[5]     |FNO       |Frame Number Overflow
N     * |        |          |This bit is set when bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
N     * |        |          |0 = The bit 15 of Frame Number didn't change.
N     * |        |          |1 = The bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
N     * |[6]     |RHSC      |Root Hub Status Change
N     * |        |          |This bit is set when the content of HcRhStatus or the content of HcRhPortStatus register has changed.
N     * |        |          |0 = The content of HcRhStatus and the content of HcRhPortStatus register didn't change.
N     * |        |          |1 = The content of HcRhStatus or the content of HcRhPortStatus register has changed.
N     * @var USBH_T::HcInterruptEnable
N     * Offset: 0x10  Host Controller Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SO        |Scheduling Overrun Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to SO (HcInterruptStatus[0]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to SO (HcInterruptStatus[0]) Disabled.
N     * |        |          |1 = Interrupt generation due to SO (HcInterruptStatus[0]) Enabled.
N     * |[1]     |WDH       |Write Back Done Head Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to WDH (HcInterruptStatus[1]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to WDH (HcInterruptStatus[1]) Disabled.
N     * |        |          |1 = Interrupt generation due to WDH (HcInterruptStatus[1]) Enabled.
N     * |[2]     |SF        |Start of Frame Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to SF (HcInterruptStatus[2]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to SF (HcInterruptStatus[2]) Disabled.
N     * |        |          |1 = Interrupt generation due to SF (HcInterruptStatus[2]) Enabled.
N     * |[3]     |RD        |Resume Detected Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RD (HcInterruptStatus[3]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RD (HcInterruptStatus[3]) Disabled.
N     * |        |          |1 = Interrupt generation due to RD (HcInterruptStatus[3]) Enabled.
N     * |[5]     |FNO       |Frame Number Overflow Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to FNO (HcInterruptStatus[5]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to FNO (HcInterruptStatus[5]) Disabled.
N     * |        |          |1 = Interrupt generation due to FNO (HcInterruptStatus[5]) Enabled.
N     * |[6]     |RHSC      |Root Hub Status Change Enable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Disabled.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Enabled.
N     * |[31]    |MIE       |Master Interrupt Enable Bit
N     * |        |          |This bit is a global interrupt enable
N     * |        |          |A write of '1' allows interrupts to be enabled via the specific enable bits listed above.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Enabled if the corresponding bit in HcInterruptEnable is high.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Disabled even if the corresponding bit in HcInterruptEnable is high.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Enabled if the corresponding bit in HcInterruptEnable is high.
N     * @var USBH_T::HcInterruptDisable
N     * Offset: 0x14  Host Controller Interrupt Disable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SO        |Scheduling Overrun Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to SO (HcInterruptStatus[0]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to SO (HcInterruptStatus[0]) Disabled.
N     * |        |          |1 = Interrupt generation due to SO (HcInterruptStatus[0]) Enabled.
N     * |[1]     |WDH       |Write Back Done Head Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to WDH (HcInterruptStatus[1]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to WDH (HcInterruptStatus[1]) Disabled.
N     * |        |          |1 = Interrupt generation due to WDH (HcInterruptStatus[1]) Enabled.
N     * |[2]     |SF        |Start of Frame Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to SF (HcInterruptStatus[2]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to SF (HcInterruptStatus[2]) Disabled.
N     * |        |          |1 = Interrupt generation due to SF (HcInterruptStatus[2]) Enabled.
N     * |[3]     |RD        |Resume Detected Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RD (HcInterruptStatus[3]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RD (HcInterruptStatus[3]) Disabled.
N     * |        |          |1 = Interrupt generation due to RD (HcInterruptStatus[3]) Enabled.
N     * |[5]     |FNO       |Frame Number Overflow Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to FNO (HcInterruptStatus[5]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to FNO (HcInterruptStatus[5]) Disabled.
N     * |        |          |1 = Interrupt generation due to FNO (HcInterruptStatus[5]) Enabled.
N     * |[6]     |RHSC      |Root Hub Status Change Disable Bit
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Disabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Disabled.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]) Enabled.
N     * |[31]    |MIE       |Master Interrupt Disable Bit
N     * |        |          |Global interrupt disable. Writing '1' to disable all interrupts.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Disabled if the corresponding bit in HcInterruptEnable is high.
N     * |        |          |Read Operation:
N     * |        |          |0 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Disabled even if the corresponding bit in HcInterruptEnable is high.
N     * |        |          |1 = Interrupt generation due to RHSC (HcInterruptStatus[6]), FNO (HcInterruptStatus[5]), RD (HcInterruptStatus[3]), SF (HcInterruptStatus[2]), WDH (HcInterruptStatus[1]) or SO (HcInterruptStatus[0]) Enabled if the corresponding bit in HcInterruptEnable is high.
N     * @var USBH_T::HcHCCA
N     * Offset: 0x18  Host Controller Communication Area Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:8]  |HCCA      |Host Controller Communication Area
N     * |        |          |Pointer to indicate base address of the Host Controller Communication Area (HCCA).
N     * @var USBH_T::HcPeriodCurrentED
N     * Offset: 0x1C  Host Controller Period Current ED Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |PCED      |Periodic Current ED
N     * |        |          |Pointer to indicate physical address of the current Isochronous or Interrupt Endpoint Descriptor.
N     * @var USBH_T::HcControlHeadED
N     * Offset: 0x20  Host Controller Control Head ED Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |CHED      |Control Head ED
N     * |        |          |Pointer to indicate physical address of the first Endpoint Descriptor of the Control list.
N     * @var USBH_T::HcControlCurrentED
N     * Offset: 0x24  Host Controller Control Current ED Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |CCED      |Control Current Head ED
N     * |        |          |Pointer to indicate the physical address of the current Endpoint Descriptor of the Control list.
N     * @var USBH_T::HcBulkHeadED
N     * Offset: 0x28  Host Controller Bulk Head ED Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |BHED      |Bulk Head ED
N     * |        |          |Pointer to indicate the physical address of the first Endpoint Descriptor of the Bulk list.
N     * @var USBH_T::HcBulkCurrentED
N     * Offset: 0x2C  Host Controller Bulk Current ED Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |BCED      |Bulk Current Head ED
N     * |        |          |Pointer to indicate the physical address of the current endpoint of the Bulk list.
N     * @var USBH_T::HcDoneHead
N     * Offset: 0x30  Host Controller Done Head Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:4]  |DH        |Done Head
N     * |        |          |Pointer to indicate the physical address of the last completed Transfer Descriptor that was added to the Done queue.
N     * @var USBH_T::HcFmInterval
N     * Offset: 0x34  Host Controller Frame Interval Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[13:0]  |FI        |Frame Interval
N     * |        |          |This field specifies the length of a frame as (bit times - 1)
N     * |        |          |For 12,000 bit times in a frame, a value of 11,999 is stored here.
N     * |[30:16] |FSMPS     |FS Largest Data Packet
N     * |        |          |This field specifies a value that is loaded into the Largest Data Packet Counter at the beginning of each frame.
N     * |[31]    |FIT       |Frame Interval Toggle
N     * |        |          |This bit is toggled by Host Controller Driver when it loads a new value into FI (HcFmInterval[13:0]).
N     * |        |          |0 = Host Controller Driver didn't load new value into FI (HcFmInterval[13:0]).
N     * |        |          |1 = Host Controller Driver loads a new value into FI (HcFmInterval[13:0]).
N     * @var USBH_T::HcFmRemaining
N     * Offset: 0x38  Host Controller Frame Remaining Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[13:0]  |FR        |Frame Remaining
N     * |        |          |When the Host Controller is in the USBOPERATIONAL state, this 14-bit field decrements each 12 MHz clock period
N     * |        |          |When the count reaches 0, (end of frame) the counter reloads with Frame Interval
N     * |        |          |In addition, the counter loads when the Host Controller transitions into USBOPERATIONAL.
N     * |[31]    |FRT       |Frame Remaining Toggle
N     * |        |          |This bit is loaded from the FIT (HcFmInterval[31]) whenever FR (HcFmRemaining[13:0]) reaches 0.
N     * @var USBH_T::HcFmNumber
N     * Offset: 0x3C  Host Controller Frame Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FN        |Frame Number
N     * |        |          |This 16-bit incrementing counter field is incremented coincident with the re-load of FR (HcFmRemaining[13:0])
N     * |        |          |The count rolls over from 'FFFFh' to '0h.'
N     * @var USBH_T::HcPeriodicStart
N     * Offset: 0x40  Host Controller Periodic Start Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[13:0]  |PS        |Periodic Start
N     * |        |          |This field contains a value used by the List Processor to determine where in a frame the Periodic List processing must begin.
N     * @var USBH_T::HcLSThreshold
N     * Offset: 0x44  Host Controller Low-speed Threshold Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |LST       |Low-speed Threshold
N     * |        |          |This field contains a value which is compared to the FR (HcFmRemaining[13:0]) field prior to initiating a Low-speed transaction
N     * |        |          |The transaction is started only if FR (HcFmRemaining[13:0]) >= this field
N     * |        |          |The value is calculated by Host Controller Driver with the consideration of transmission and setup overhead.
N     * @var USBH_T::HcRhDescriptorA
N     * Offset: 0x48  Host Controller Root Hub Descriptor A Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |NDP       |Number Downstream Ports
N     * |        |          |USB host control supports two downstream ports and only one port is available in this series of chip.
N     * |[8]     |PSM       |Power Switching Mode
N     * |        |          |This bit is used to specify how the power switching of the Root Hub ports is controlled.
N     * |        |          |0 = Global Switching.
N     * |        |          |1 = Individual Switching.
N     * |[11]    |OCPM      |over Current Protection Mode
N     * |        |          |This bit describes how the over current status for the Root Hub ports reported
N     * |        |          |This bit is only valid when NOCP (HcRhDescriptorA[12]) is cleared.
N     * |        |          |0 = Global Over current.
N     * |        |          |1 = Individual Over current.
N     * |[12]    |NOCP      |No over Current Protection
N     * |        |          |This bit describes how the over current status for the Root Hub ports reported.
N     * |        |          |0 = Over current status is reported.
N     * |        |          |1 = Over current status is not reported.
N     * @var USBH_T::HcRhDescriptorB
N     * Offset: 0x4C  Host Controller Root Hub Descriptor B Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:16] |PPCM      |Port Power Control Mask
N     * |        |          |Global power switching
N     * |        |          |This field is only valid if PowerSwitchingMode is set (individual port switching)
N     * |        |          |When set, the port only responds to individual port power switching commands (Set/ClearPortPower)
N     * |        |          |When cleared, the port only responds to global power switching commands (Set/ClearGlobalPower).
N     * |        |          |0 = Port power controlled by global power switching.
N     * |        |          |1 = Port power controlled by port power switching.
N     * |        |          |Note: PPCM[15:2] and PPCM[0] are reserved.
N     * @var USBH_T::HcRhStatus
N     * Offset: 0x50  Host Controller Root Hub Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LPS       |Clear Global Power
N     * |        |          |In global power mode (PSM (HcRhDescriptorA[8]) = 0), this bit is written to one to clear all ports' power.
N     * |        |          |This bit always read as zero.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear global power.
N     * |[1]     |OCI       |over Current Indicator
N     * |        |          |This bit reflects the state of the over current status pin
N     * |        |          |This field is only valid if NOCP (HcRhDesA[12]) and OCPM (HcRhDesA[11]) are cleared.
N     * |        |          |0 = No over current condition.
N     * |        |          |1 = Over current condition.
N     * |[15]    |DRWE      |Device Remote Wakeup Enable Bit
N     * |        |          |This bit controls if port's Connect Status Change as a remote wake-up event.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Connect Status Change as a remote wake-up event Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Connect Status Change as a remote wake-up event Disabled.
N     * |        |          |1 = Connect Status Change as a remote wake-up event Enabled.
N     * |[16]    |LPSC      |Set Global Power
N     * |        |          |In global power mode (PSM (HcRhDescriptorA[8]) = 0), this bit is written to one to enable power to all ports.
N     * |        |          |This bit always read as zero.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set global power.
N     * |[17]    |OCIC      |over Current Indicator Change
N     * |        |          |This bit is set by hardware when a change has occurred in OCI (HcRhStatus[1]).
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = OCI (HcRhStatus[1]) didn't change.
N     * |        |          |1 = OCI (HcRhStatus[1]) change.
N     * |[31]    |CRWE      |Clear Remote Wake-up Enable Bit
N     * |        |          |This bit is use to clear DRWE (HcRhStatus[15]).
N     * |        |          |This bit always read as zero.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear DRWE (HcRhStatus[15]).
N     * @var USBH_T::HcRhPortStatus[2]
N     * Offset: 0x54  Host Controller Root Hub Port Status
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CCS       |CurrentConnectStatus (Read) or ClearPortEnable Bit (Write)
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear port enable.
N     * |        |          |Read Operation:
N     * |        |          |0 = No device connected.
N     * |        |          |1 = Device connected.
N     * |[1]     |PES       |Port Enable Status
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set port enable.
N     * |        |          |Read Operation:
N     * |        |          |0 = Port Disabled.
N     * |        |          |1 = Port Enabled.
N     * |[2]     |PSS       |Port Suspend Status
N     * |        |          |This bit indicates the port is suspended
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set port suspend.
N     * |        |          |Read Operation:
N     * |        |          |0 = Port is not suspended.
N     * |        |          |1 = Port is selectively suspended.
N     * |[3]     |POCI      |Port over Current Indicator (Read) or Clear Port Suspend (Write)
N     * |        |          |This bit reflects the state of the over current status pin dedicated to this port
N     * |        |          |This field is only valid if NOCP (HcRhDescriptorA[12]) is cleared and OCPM (HcRhDescriptorA[11]) is set.
N     * |        |          |This bit is also used to initiate the selective result sequence for the port.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear port suspend.
N     * |        |          |Read Operation:
N     * |        |          |0 = No over current condition.
N     * |        |          |1 = Over current condition.
N     * |[4]     |PRS       |Port Reset Status
N     * |        |          |This bit reflects the reset state of the port.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Set port reset.
N     * |        |          |Read Operation
N     * |        |          |0 = Port reset signal is not active.
N     * |        |          |1 = Port reset signal is active.
N     * |[8]     |PPS       |Port Power Status
N     * |        |          |This bit reflects the power state of the port regardless of the power switching mode.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Port Power Enabled.
N     * |        |          |Read Operation:
N     * |        |          |0 = Port power is Disabled.
N     * |        |          |1 = Port power is Enabled.
N     * |[9]     |LSDA      |Low Speed Device Attached (Read) or Clear Port Power (Write)
N     * |        |          |This bit defines the speed (and bud idle) of the attached device
N     * |        |          |It is only valid when CCS (HcRhPortStatus1[0]) is set.
N     * |        |          |This bit is also used to clear port power.
N     * |        |          |Write Operation:
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear PPS (HcRhPortStatus1[8]).
N     * |        |          |Read Operation:
N     * |        |          |0 = Full Speed device.
N     * |        |          |1 = Low-speed device.
N     * |[16]    |CSC       |Connect Status Change
N     * |        |          |This bit indicates connect or disconnect event has been detected (CCS (HcRhPortStatus1[0]) changed).
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = No connect/disconnect event (CCS (HcRhPortStatus1[0]) didn't change).
N     * |        |          |1 = Hardware detection of connect/disconnect event (CCS (HcRhPortStatus1[0]) changed).
N     * |[17]    |PESC      |Port Enable Status Change
N     * |        |          |This bit indicates that the port has been disabled (PES (HcRhPortStatus1[1]) cleared) due to a hardware event.
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = PES (HcRhPortStatus1[1]) didn't change.
N     * |        |          |1 = PES (HcRhPortStatus1[1]) changed.
N     * |[18]    |PSSC      |Port Suspend Status Change
N     * |        |          |This bit indicates the completion of the selective resume sequence for the port.
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = Port resume is not completed.
N     * |        |          |1 = Port resume completed.
N     * |[19]    |OCIC      |Port over Current Indicator Change
N     * |        |          |This bit is set when POCI (HcRhPortStatus1[3]) changes.
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = POCI (HcRhPortStatus1[3]) didn't change.
N     * |        |          |1 = POCI (HcRhPortStatus1[3]) changes.
N     * |[20]    |PRSC      |Port Reset Status Change
N     * |        |          |This bit indicates that the port reset signal has completed.
N     * |        |          |Write 1 to clear this bit to zero.
N     * |        |          |0 = Port reset is not complete.
N     * |        |          |1 = Port reset is complete.
N     * @var USBH_T::HcPhyControl
N     * Offset: 0x200  Host Controller PHY Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[27]    |STBYEN    |USB Transceiver Standby Enable Bit
N     * |        |          |This bit controls if USB transceiver could enter the standby mode to reduce power consumption.
N     * |        |          |0 = The USB transceiver would never enter the standby mode.
N     * |        |          |1 = The USB transceiver will enter standby mode while port is in power off state (port power is inactive).
N     * @var USBH_T::HcMiscControl
N     * Offset: 0x204  Host Controller Miscellaneous Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |ABORT     |AHB Bus ERROR Response
N     * |        |          |This bit indicates there is an ERROR response received in AHB bus.
N     * |        |          |0 = No ERROR response received.
N     * |        |          |1 = ERROR response received.
N     * |[3]     |OCAL      |over Current Active Low
N     * |        |          |This bit controls the polarity of over current flag from external power IC.
N     * |        |          |0 = Over current flag is high active.
N     * |        |          |1 = Over current flag is low active.
N     * |[16]    |DPRT1     |Disable Port 1
N     * |        |          |This bit controls if the connection between USB host controller and transceiver of port 1 is disabled
N     * |        |          |If the connection is disabled, the USB host controller will not recognize any event of USB bus.
N     * |        |          |Set this bit high, the transceiver of port 1 will also be forced into the standby mode no matter what USB host controller operation is.
N     * |        |          |0 = The connection between USB host controller and transceiver of port 1 Enabled.
N     * |        |          |1 = The connection between USB host controller and transceiver of port 1 Disabled and the transceiver of port 1 will also be forced into the standby mode.
N     */
N    __I  uint32_t HcRevision;            /*!< [0x0000] Host Controller Revision Register                                */
X    volatile const  uint32_t HcRevision;             
N    __IO uint32_t HcControl;             /*!< [0x0004] Host Controller Control Register                                 */
X    volatile uint32_t HcControl;              
N    __IO uint32_t HcCommandStatus;       /*!< [0x0008] Host Controller Command Status Register                          */
X    volatile uint32_t HcCommandStatus;        
N    __IO uint32_t HcInterruptStatus;     /*!< [0x000c] Host Controller Interrupt Status Register                        */
X    volatile uint32_t HcInterruptStatus;      
N    __IO uint32_t HcInterruptEnable;     /*!< [0x0010] Host Controller Interrupt Enable Register                        */
X    volatile uint32_t HcInterruptEnable;      
N    __IO uint32_t HcInterruptDisable;    /*!< [0x0014] Host Controller Interrupt Disable Register                       */
X    volatile uint32_t HcInterruptDisable;     
N    __IO uint32_t HcHCCA;                /*!< [0x0018] Host Controller Communication Area Register                      */
X    volatile uint32_t HcHCCA;                 
N    __IO uint32_t HcPeriodCurrentED;     /*!< [0x001c] Host Controller Period Current ED Register                       */
X    volatile uint32_t HcPeriodCurrentED;      
N    __IO uint32_t HcControlHeadED;       /*!< [0x0020] Host Controller Control Head ED Register                         */
X    volatile uint32_t HcControlHeadED;        
N    __IO uint32_t HcControlCurrentED;    /*!< [0x0024] Host Controller Control Current ED Register                      */
X    volatile uint32_t HcControlCurrentED;     
N    __IO uint32_t HcBulkHeadED;          /*!< [0x0028] Host Controller Bulk Head ED Register                            */
X    volatile uint32_t HcBulkHeadED;           
N    __IO uint32_t HcBulkCurrentED;       /*!< [0x002c] Host Controller Bulk Current ED Register                         */
X    volatile uint32_t HcBulkCurrentED;        
N    __IO uint32_t HcDoneHead;            /*!< [0x0030] Host Controller Done Head Register                               */
X    volatile uint32_t HcDoneHead;             
N    __IO uint32_t HcFmInterval;          /*!< [0x0034] Host Controller Frame Interval Register                          */
X    volatile uint32_t HcFmInterval;           
N    __I  uint32_t HcFmRemaining;         /*!< [0x0038] Host Controller Frame Remaining Register                         */
X    volatile const  uint32_t HcFmRemaining;          
N    __I  uint32_t HcFmNumber;            /*!< [0x003c] Host Controller Frame Number Register                            */
X    volatile const  uint32_t HcFmNumber;             
N    __IO uint32_t HcPeriodicStart;       /*!< [0x0040] Host Controller Periodic Start Register                          */
X    volatile uint32_t HcPeriodicStart;        
N    __IO uint32_t HcLSThreshold;         /*!< [0x0044] Host Controller Low-speed Threshold Register                     */
X    volatile uint32_t HcLSThreshold;          
N    __IO uint32_t HcRhDescriptorA;       /*!< [0x0048] Host Controller Root Hub Descriptor A Register                   */
X    volatile uint32_t HcRhDescriptorA;        
N    __IO uint32_t HcRhDescriptorB;       /*!< [0x004c] Host Controller Root Hub Descriptor B Register                   */
X    volatile uint32_t HcRhDescriptorB;        
N    __IO uint32_t HcRhStatus;            /*!< [0x0050] Host Controller Root Hub Status Register                         */
X    volatile uint32_t HcRhStatus;             
N    __IO uint32_t HcRhPortStatus[2];     /*!< [0x0054] Host Controller Root Hub Port Status [1]                         */
X    volatile uint32_t HcRhPortStatus[2];      
N    __I  uint32_t RESERVE0[105];
X    volatile const  uint32_t RESERVE0[105];
N    __IO uint32_t HcPhyControl;          /*!< [0x0200] Host Controller PHY Control Register                             */
X    volatile uint32_t HcPhyControl;           
N    __IO uint32_t HcMiscControl;         /*!< [0x0204] Host Controller Miscellaneous Control Register                   */
X    volatile uint32_t HcMiscControl;          
N
N} USBH_T;
N
N/**
N    @addtogroup USBH_CONST USBH Bit Field Definition
N    Constant Definitions for USBH Controller
N@{ */
N
N#define USBH_HcRevision_REV_Pos          (0)                                               /*!< USBH_T::HcRevision: REV Position       */
N#define USBH_HcRevision_REV_Msk          (0xfful << USBH_HcRevision_REV_Pos)               /*!< USBH_T::HcRevision: REV Mask           */
N
N#define USBH_HcControl_CBSR_Pos          (0)                                               /*!< USBH_T::HcControl: CBSR Position       */
N#define USBH_HcControl_CBSR_Msk          (0x3ul << USBH_HcControl_CBSR_Pos)                /*!< USBH_T::HcControl: CBSR Mask           */
N
N#define USBH_HcControl_PLE_Pos           (2)                                               /*!< USBH_T::HcControl: PLE Position        */
N#define USBH_HcControl_PLE_Msk           (0x1ul << USBH_HcControl_PLE_Pos)                 /*!< USBH_T::HcControl: PLE Mask            */
N
N#define USBH_HcControl_IE_Pos            (3)                                               /*!< USBH_T::HcControl: IE Position         */
N#define USBH_HcControl_IE_Msk            (0x1ul << USBH_HcControl_IE_Pos)                  /*!< USBH_T::HcControl: IE Mask             */
N
N#define USBH_HcControl_CLE_Pos           (4)                                               /*!< USBH_T::HcControl: CLE Position        */
N#define USBH_HcControl_CLE_Msk           (0x1ul << USBH_HcControl_CLE_Pos)                 /*!< USBH_T::HcControl: CLE Mask            */
N
N#define USBH_HcControl_BLE_Pos           (5)                                               /*!< USBH_T::HcControl: BLE Position        */
N#define USBH_HcControl_BLE_Msk           (0x1ul << USBH_HcControl_BLE_Pos)                 /*!< USBH_T::HcControl: BLE Mask            */
N
N#define USBH_HcControl_HCFS_Pos          (6)                                               /*!< USBH_T::HcControl: HCFS Position       */
N#define USBH_HcControl_HCFS_Msk          (0x3ul << USBH_HcControl_HCFS_Pos)                /*!< USBH_T::HcControl: HCFS Mask           */
N
N#define USBH_HcCommandStatus_HCR_Pos     (0)                                               /*!< USBH_T::HcCommandStatus: HCR Position  */
N#define USBH_HcCommandStatus_HCR_Msk     (0x1ul << USBH_HcCommandStatus_HCR_Pos)           /*!< USBH_T::HcCommandStatus: HCR Mask      */
N
N#define USBH_HcCommandStatus_CLF_Pos     (1)                                               /*!< USBH_T::HcCommandStatus: CLF Position  */
N#define USBH_HcCommandStatus_CLF_Msk     (0x1ul << USBH_HcCommandStatus_CLF_Pos)           /*!< USBH_T::HcCommandStatus: CLF Mask      */
N
N#define USBH_HcCommandStatus_BLF_Pos     (2)                                               /*!< USBH_T::HcCommandStatus: BLF Position  */
N#define USBH_HcCommandStatus_BLF_Msk     (0x1ul << USBH_HcCommandStatus_BLF_Pos)           /*!< USBH_T::HcCommandStatus: BLF Mask      */
N
N#define USBH_HcCommandStatus_SOC_Pos     (16)                                              /*!< USBH_T::HcCommandStatus: SOC Position  */
N#define USBH_HcCommandStatus_SOC_Msk     (0x3ul << USBH_HcCommandStatus_SOC_Pos)           /*!< USBH_T::HcCommandStatus: SOC Mask      */
N
N#define USBH_HcInterruptStatus_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptStatus: SO Position */
N#define USBH_HcInterruptStatus_SO_Msk    (0x1ul << USBH_HcInterruptStatus_SO_Pos)          /*!< USBH_T::HcInterruptStatus: SO Mask     */
N
N#define USBH_HcInterruptStatus_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptStatus: WDH Position*/
N#define USBH_HcInterruptStatus_WDH_Msk   (0x1ul << USBH_HcInterruptStatus_WDH_Pos)         /*!< USBH_T::HcInterruptStatus: WDH Mask    */
N
N#define USBH_HcInterruptStatus_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptStatus: SF Position */
N#define USBH_HcInterruptStatus_SF_Msk    (0x1ul << USBH_HcInterruptStatus_SF_Pos)          /*!< USBH_T::HcInterruptStatus: SF Mask     */
N
N#define USBH_HcInterruptStatus_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptStatus: RD Position */
N#define USBH_HcInterruptStatus_RD_Msk    (0x1ul << USBH_HcInterruptStatus_RD_Pos)          /*!< USBH_T::HcInterruptStatus: RD Mask     */
N
N#define USBH_HcInterruptStatus_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptStatus: FNO Position*/
N#define USBH_HcInterruptStatus_FNO_Msk   (0x1ul << USBH_HcInterruptStatus_FNO_Pos)         /*!< USBH_T::HcInterruptStatus: FNO Mask    */
N
N#define USBH_HcInterruptStatus_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptStatus: RHSC Position*/
N#define USBH_HcInterruptStatus_RHSC_Msk  (0x1ul << USBH_HcInterruptStatus_RHSC_Pos)        /*!< USBH_T::HcInterruptStatus: RHSC Mask   */
N
N#define USBH_HcInterruptEnable_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptEnable: SO Position */
N#define USBH_HcInterruptEnable_SO_Msk    (0x1ul << USBH_HcInterruptEnable_SO_Pos)          /*!< USBH_T::HcInterruptEnable: SO Mask     */
N
N#define USBH_HcInterruptEnable_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptEnable: WDH Position*/
N#define USBH_HcInterruptEnable_WDH_Msk   (0x1ul << USBH_HcInterruptEnable_WDH_Pos)         /*!< USBH_T::HcInterruptEnable: WDH Mask    */
N
N#define USBH_HcInterruptEnable_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptEnable: SF Position */
N#define USBH_HcInterruptEnable_SF_Msk    (0x1ul << USBH_HcInterruptEnable_SF_Pos)          /*!< USBH_T::HcInterruptEnable: SF Mask     */
N
N#define USBH_HcInterruptEnable_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptEnable: RD Position */
N#define USBH_HcInterruptEnable_RD_Msk    (0x1ul << USBH_HcInterruptEnable_RD_Pos)          /*!< USBH_T::HcInterruptEnable: RD Mask     */
N
N#define USBH_HcInterruptEnable_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptEnable: FNO Position*/
N#define USBH_HcInterruptEnable_FNO_Msk   (0x1ul << USBH_HcInterruptEnable_FNO_Pos)         /*!< USBH_T::HcInterruptEnable: FNO Mask    */
N
N#define USBH_HcInterruptEnable_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptEnable: RHSC Position*/
N#define USBH_HcInterruptEnable_RHSC_Msk  (0x1ul << USBH_HcInterruptEnable_RHSC_Pos)        /*!< USBH_T::HcInterruptEnable: RHSC Mask   */
N
N#define USBH_HcInterruptEnable_MIE_Pos   (31)                                              /*!< USBH_T::HcInterruptEnable: MIE Position*/
N#define USBH_HcInterruptEnable_MIE_Msk   (0x1ul << USBH_HcInterruptEnable_MIE_Pos)         /*!< USBH_T::HcInterruptEnable: MIE Mask    */
N
N#define USBH_HcInterruptDisable_SO_Pos   (0)                                               /*!< USBH_T::HcInterruptDisable: SO Position*/
N#define USBH_HcInterruptDisable_SO_Msk   (0x1ul << USBH_HcInterruptDisable_SO_Pos)         /*!< USBH_T::HcInterruptDisable: SO Mask    */
N
N#define USBH_HcInterruptDisable_WDH_Pos  (1)                                               /*!< USBH_T::HcInterruptDisable: WDH Position*/
N#define USBH_HcInterruptDisable_WDH_Msk  (0x1ul << USBH_HcInterruptDisable_WDH_Pos)        /*!< USBH_T::HcInterruptDisable: WDH Mask   */
N
N#define USBH_HcInterruptDisable_SF_Pos   (2)                                               /*!< USBH_T::HcInterruptDisable: SF Position*/
N#define USBH_HcInterruptDisable_SF_Msk   (0x1ul << USBH_HcInterruptDisable_SF_Pos)         /*!< USBH_T::HcInterruptDisable: SF Mask    */
N
N#define USBH_HcInterruptDisable_RD_Pos   (3)                                               /*!< USBH_T::HcInterruptDisable: RD Position*/
N#define USBH_HcInterruptDisable_RD_Msk   (0x1ul << USBH_HcInterruptDisable_RD_Pos)         /*!< USBH_T::HcInterruptDisable: RD Mask    */
N
N#define USBH_HcInterruptDisable_FNO_Pos  (5)                                               /*!< USBH_T::HcInterruptDisable: FNO Position*/
N#define USBH_HcInterruptDisable_FNO_Msk  (0x1ul << USBH_HcInterruptDisable_FNO_Pos)        /*!< USBH_T::HcInterruptDisable: FNO Mask   */
N
N#define USBH_HcInterruptDisable_RHSC_Pos (6)                                               /*!< USBH_T::HcInterruptDisable: RHSC Position*/
N#define USBH_HcInterruptDisable_RHSC_Msk (0x1ul << USBH_HcInterruptDisable_RHSC_Pos)       /*!< USBH_T::HcInterruptDisable: RHSC Mask  */
N
N#define USBH_HcInterruptDisable_MIE_Pos  (31)                                              /*!< USBH_T::HcInterruptDisable: MIE Position*/
N#define USBH_HcInterruptDisable_MIE_Msk  (0x1ul << USBH_HcInterruptDisable_MIE_Pos)        /*!< USBH_T::HcInterruptDisable: MIE Mask   */
N
N#define USBH_HcHCCA_HCCA_Pos             (8)                                               /*!< USBH_T::HcHCCA: HCCA Position          */
N#define USBH_HcHCCA_HCCA_Msk             (0xfffffful << USBH_HcHCCA_HCCA_Pos)              /*!< USBH_T::HcHCCA: HCCA Mask              */
N
N#define USBH_HcPeriodCurrentED_PCED_Pos  (4)                                               /*!< USBH_T::HcPeriodCurrentED: PCED Position*/
N#define USBH_HcPeriodCurrentED_PCED_Msk  (0xffffffful << USBH_HcPeriodCurrentED_PCED_Pos)  /*!< USBH_T::HcPeriodCurrentED: PCED Mask   */
N
N#define USBH_HcControlHeadED_CHED_Pos    (4)                                               /*!< USBH_T::HcControlHeadED: CHED Position */
N#define USBH_HcControlHeadED_CHED_Msk    (0xffffffful << USBH_HcControlHeadED_CHED_Pos)    /*!< USBH_T::HcControlHeadED: CHED Mask     */
N
N#define USBH_HcControlCurrentED_CCED_Pos (4)                                               /*!< USBH_T::HcControlCurrentED: CCED Position*/
N#define USBH_HcControlCurrentED_CCED_Msk (0xffffffful << USBH_HcControlCurrentED_CCED_Pos) /*!< USBH_T::HcControlCurrentED: CCED Mask  */
N
N#define USBH_HcBulkHeadED_BHED_Pos       (4)                                               /*!< USBH_T::HcBulkHeadED: BHED Position    */
N#define USBH_HcBulkHeadED_BHED_Msk       (0xffffffful << USBH_HcBulkHeadED_BHED_Pos)       /*!< USBH_T::HcBulkHeadED: BHED Mask        */
N
N#define USBH_HcBulkCurrentED_BCED_Pos    (4)                                               /*!< USBH_T::HcBulkCurrentED: BCED Position */
N#define USBH_HcBulkCurrentED_BCED_Msk    (0xffffffful << USBH_HcBulkCurrentED_BCED_Pos)    /*!< USBH_T::HcBulkCurrentED: BCED Mask     */
N
N#define USBH_HcDoneHead_DH_Pos           (4)                                               /*!< USBH_T::HcDoneHead: DH Position        */
N#define USBH_HcDoneHead_DH_Msk           (0xffffffful << USBH_HcDoneHead_DH_Pos)           /*!< USBH_T::HcDoneHead: DH Mask            */
N
N#define USBH_HcFmInterval_FI_Pos         (0)                                               /*!< USBH_T::HcFmInterval: FI Position      */
N#define USBH_HcFmInterval_FI_Msk         (0x3ffful << USBH_HcFmInterval_FI_Pos)            /*!< USBH_T::HcFmInterval: FI Mask          */
N
N#define USBH_HcFmInterval_FSMPS_Pos      (16)                                              /*!< USBH_T::HcFmInterval: FSMPS Position   */
N#define USBH_HcFmInterval_FSMPS_Msk      (0x7ffful << USBH_HcFmInterval_FSMPS_Pos)         /*!< USBH_T::HcFmInterval: FSMPS Mask       */
N
N#define USBH_HcFmInterval_FIT_Pos        (31)                                              /*!< USBH_T::HcFmInterval: FIT Position     */
N#define USBH_HcFmInterval_FIT_Msk        (0x1ul << USBH_HcFmInterval_FIT_Pos)              /*!< USBH_T::HcFmInterval: FIT Mask         */
N
N#define USBH_HcFmRemaining_FR_Pos        (0)                                               /*!< USBH_T::HcFmRemaining: FR Position     */
N#define USBH_HcFmRemaining_FR_Msk        (0x3ffful << USBH_HcFmRemaining_FR_Pos)           /*!< USBH_T::HcFmRemaining: FR Mask         */
N
N#define USBH_HcFmRemaining_FRT_Pos       (31)                                              /*!< USBH_T::HcFmRemaining: FRT Position    */
N#define USBH_HcFmRemaining_FRT_Msk       (0x1ul << USBH_HcFmRemaining_FRT_Pos)             /*!< USBH_T::HcFmRemaining: FRT Mask        */
N
N#define USBH_HcFmNumber_FN_Pos           (0)                                               /*!< USBH_T::HcFmNumber: FN Position        */
N#define USBH_HcFmNumber_FN_Msk           (0xfffful << USBH_HcFmNumber_FN_Pos)              /*!< USBH_T::HcFmNumber: FN Mask            */
N
N#define USBH_HcPeriodicStart_PS_Pos      (0)                                               /*!< USBH_T::HcPeriodicStart: PS Position   */
N#define USBH_HcPeriodicStart_PS_Msk      (0x3ffful << USBH_HcPeriodicStart_PS_Pos)         /*!< USBH_T::HcPeriodicStart: PS Mask       */
N
N#define USBH_HcLSThreshold_LST_Pos       (0)                                               /*!< USBH_T::HcLSThreshold: LST Position    */
N#define USBH_HcLSThreshold_LST_Msk       (0xffful << USBH_HcLSThreshold_LST_Pos)           /*!< USBH_T::HcLSThreshold: LST Mask        */
N
N#define USBH_HcRhDescriptorA_NDP_Pos     (0)                                               /*!< USBH_T::HcRhDescriptorA: NDP Position  */
N#define USBH_HcRhDescriptorA_NDP_Msk     (0xfful << USBH_HcRhDescriptorA_NDP_Pos)          /*!< USBH_T::HcRhDescriptorA: NDP Mask      */
N
N#define USBH_HcRhDescriptorA_PSM_Pos     (8)                                               /*!< USBH_T::HcRhDescriptorA: PSM Position  */
N#define USBH_HcRhDescriptorA_PSM_Msk     (0x1ul << USBH_HcRhDescriptorA_PSM_Pos)           /*!< USBH_T::HcRhDescriptorA: PSM Mask      */
N
N#define USBH_HcRhDescriptorA_OCPM_Pos    (11)                                              /*!< USBH_T::HcRhDescriptorA: OCPM Position */
N#define USBH_HcRhDescriptorA_OCPM_Msk    (0x1ul << USBH_HcRhDescriptorA_OCPM_Pos)          /*!< USBH_T::HcRhDescriptorA: OCPM Mask     */
N
N#define USBH_HcRhDescriptorA_NOCP_Pos    (12)                                              /*!< USBH_T::HcRhDescriptorA: NOCP Position */
N#define USBH_HcRhDescriptorA_NOCP_Msk    (0x1ul << USBH_HcRhDescriptorA_NOCP_Pos)          /*!< USBH_T::HcRhDescriptorA: NOCP Mask     */
N
N#define USBH_HcRhDescriptorB_PPCM_Pos    (16)                                              /*!< USBH_T::HcRhDescriptorB: PPCM Position */
N#define USBH_HcRhDescriptorB_PPCM_Msk    (0xfffful << USBH_HcRhDescriptorB_PPCM_Pos)       /*!< USBH_T::HcRhDescriptorB: PPCM Mask     */
N
N#define USBH_HcRhStatus_LPS_Pos          (0)                                               /*!< USBH_T::HcRhStatus: LPS Position       */
N#define USBH_HcRhStatus_LPS_Msk          (0x1ul << USBH_HcRhStatus_LPS_Pos)                /*!< USBH_T::HcRhStatus: LPS Mask           */
N
N#define USBH_HcRhStatus_OCI_Pos          (1)                                               /*!< USBH_T::HcRhStatus: OCI Position       */
N#define USBH_HcRhStatus_OCI_Msk          (0x1ul << USBH_HcRhStatus_OCI_Pos)                /*!< USBH_T::HcRhStatus: OCI Mask           */
N
N#define USBH_HcRhStatus_DRWE_Pos         (15)                                              /*!< USBH_T::HcRhStatus: DRWE Position      */
N#define USBH_HcRhStatus_DRWE_Msk         (0x1ul << USBH_HcRhStatus_DRWE_Pos)               /*!< USBH_T::HcRhStatus: DRWE Mask          */
N
N#define USBH_HcRhStatus_LPSC_Pos         (16)                                              /*!< USBH_T::HcRhStatus: LPSC Position      */
N#define USBH_HcRhStatus_LPSC_Msk         (0x1ul << USBH_HcRhStatus_LPSC_Pos)               /*!< USBH_T::HcRhStatus: LPSC Mask          */
N
N#define USBH_HcRhStatus_OCIC_Pos         (17)                                              /*!< USBH_T::HcRhStatus: OCIC Position      */
N#define USBH_HcRhStatus_OCIC_Msk         (0x1ul << USBH_HcRhStatus_OCIC_Pos)               /*!< USBH_T::HcRhStatus: OCIC Mask          */
N
N#define USBH_HcRhStatus_CRWE_Pos         (31)                                              /*!< USBH_T::HcRhStatus: CRWE Position      */
N#define USBH_HcRhStatus_CRWE_Msk         (0x1ul << USBH_HcRhStatus_CRWE_Pos)               /*!< USBH_T::HcRhStatus: CRWE Mask          */
N
N#define USBH_HcRhPortStatus_CCS_Pos      (0)                                               /*!< USBH_T::HcRhPortStatus1: CCS Position  */
N#define USBH_HcRhPortStatus_CCS_Msk      (0x1ul << USBH_HcRhPortStatus_CCS_Pos)            /*!< USBH_T::HcRhPortStatus1: CCS Mask      */
N
N#define USBH_HcRhPortStatus_PES_Pos      (1)                                               /*!< USBH_T::HcRhPortStatus1: PES Position  */
N#define USBH_HcRhPortStatus_PES_Msk      (0x1ul << USBH_HcRhPortStatus_PES_Pos)            /*!< USBH_T::HcRhPortStatus1: PES Mask      */
N
N#define USBH_HcRhPortStatus_PSS_Pos      (2)                                               /*!< USBH_T::HcRhPortStatus1: PSS Position  */
N#define USBH_HcRhPortStatus_PSS_Msk      (0x1ul << USBH_HcRhPortStatus_PSS_Pos)            /*!< USBH_T::HcRhPortStatus1: PSS Mask      */
N
N#define USBH_HcRhPortStatus_POCI_Pos     (3)                                               /*!< USBH_T::HcRhPortStatus1: POCI Position */
N#define USBH_HcRhPortStatus_POCI_Msk     (0x1ul << USBH_HcRhPortStatus_POCI_Pos)           /*!< USBH_T::HcRhPortStatus1: POCI Mask     */
N
N#define USBH_HcRhPortStatus_PRS_Pos      (4)                                               /*!< USBH_T::HcRhPortStatus1: PRS Position  */
N#define USBH_HcRhPortStatus_PRS_Msk      (0x1ul << USBH_HcRhPortStatus_PRS_Pos)            /*!< USBH_T::HcRhPortStatus1: PRS Mask      */
N
N#define USBH_HcRhPortStatus_PPS_Pos      (8)                                               /*!< USBH_T::HcRhPortStatus1: PPS Position  */
N#define USBH_HcRhPortStatus_PPS_Msk      (0x1ul << USBH_HcRhPortStatus_PPS_Pos)            /*!< USBH_T::HcRhPortStatus1: PPS Mask      */
N
N#define USBH_HcRhPortStatus_LSDA_Pos     (9)                                               /*!< USBH_T::HcRhPortStatus1: LSDA Position */
N#define USBH_HcRhPortStatus_LSDA_Msk     (0x1ul << USBH_HcRhPortStatus_LSDA_Pos)           /*!< USBH_T::HcRhPortStatus1: LSDA Mask     */
N
N#define USBH_HcRhPortStatus_CSC_Pos      (16)                                              /*!< USBH_T::HcRhPortStatus1: CSC Position  */
N#define USBH_HcRhPortStatus_CSC_Msk      (0x1ul << USBH_HcRhPortStatus_CSC_Pos)            /*!< USBH_T::HcRhPortStatus1: CSC Mask      */
N
N#define USBH_HcRhPortStatus_PESC_Pos     (17)                                              /*!< USBH_T::HcRhPortStatus1: PESC Position */
N#define USBH_HcRhPortStatus_PESC_Msk     (0x1ul << USBH_HcRhPortStatus_PESC_Pos)           /*!< USBH_T::HcRhPortStatus1: PESC Mask     */
N
N#define USBH_HcRhPortStatus_PSSC_Pos     (18)                                              /*!< USBH_T::HcRhPortStatus1: PSSC Position */
N#define USBH_HcRhPortStatus_PSSC_Msk     (0x1ul << USBH_HcRhPortStatus_PSSC_Pos)           /*!< USBH_T::HcRhPortStatus1: PSSC Mask     */
N
N#define USBH_HcRhPortStatus_OCIC_Pos     (19)                                              /*!< USBH_T::HcRhPortStatus1: OCIC Position */
N#define USBH_HcRhPortStatus_OCIC_Msk     (0x1ul << USBH_HcRhPortStatus_OCIC_Pos)           /*!< USBH_T::HcRhPortStatus1: OCIC Mask     */
N
N#define USBH_HcRhPortStatus_PRSC_Pos     (20)                                              /*!< USBH_T::HcRhPortStatus1: PRSC Position */
N#define USBH_HcRhPortStatus_PRSC_Msk     (0x1ul << USBH_HcRhPortStatus_PRSC_Pos)           /*!< USBH_T::HcRhPortStatus1: PRSC Mask     */
N
N#define USBH_HcPhyControl_STBYEN_Pos     (27)                                              /*!< USBH_T::HcPhyControl: STBYEN Position  */
N#define USBH_HcPhyControl_STBYEN_Msk     (0x1ul << USBH_HcPhyControl_STBYEN_Pos)           /*!< USBH_T::HcPhyControl: STBYEN Mask      */
N
N#define USBH_HcMiscControl_ABORT_Pos     (1)                                               /*!< USBH_T::HcMiscControl: ABORT Position  */
N#define USBH_HcMiscControl_ABORT_Msk     (0x1ul << USBH_HcMiscControl_ABORT_Pos)           /*!< USBH_T::HcMiscControl: ABORT Mask      */
N
N#define USBH_HcMiscControl_OCAL_Pos      (3)                                               /*!< USBH_T::HcMiscControl: OCAL Position   */
N#define USBH_HcMiscControl_OCAL_Msk      (0x1ul << USBH_HcMiscControl_OCAL_Pos)            /*!< USBH_T::HcMiscControl: OCAL Mask       */
N
N#define USBH_HcMiscControl_DPRT1_Pos     (16)                                              /*!< USBH_T::HcMiscControl: DPRT1 Position  */
N#define USBH_HcMiscControl_DPRT1_Msk     (0x1ul << USBH_HcMiscControl_DPRT1_Pos)           /*!< USBH_T::HcMiscControl: DPRT1 Mask      */
N
N/**@}*/ /* USBH_CONST */
N/**@}*/ /* end of USBH register group */
N
N
N/*---------------------- HSUSBH HSUSB Host Controller -------------------------*/
N/**
N    @addtogroup HSUSBH High Speed USB Host Controller (HSUSBH)
N    Memory Mapped Structure for HSUSBH Controller
N@{ */
N
Ntypedef struct
N{
N
N
N    /**
N     * @var HSUSBH_T::EHCVNR
N     * Offset: 0x00  EHCI Version Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CRLEN     |Capability Registers Length
N     * |        |          |This register is used as an offset to add to register base to find the beginning of the Operational Register Space.
N     * |[31:16] |VERSION   |Host Controller Interface Version Number
N     * |        |          |This is a two-byte register containing a BCD encoding of the EHCI revision number supported by this host controller
N     * |        |          |The most significant byte of this register represents a major revision and the least significant byte is the minor revision.
N     * @var HSUSBH_T::EHCSPR
N     * Offset: 0x04  EHCI Structural Parameters Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |N_PORTS   |Number of Physical Downstream Ports
N     * |        |          |This field specifies the number of physical downstream ports implemented on this host controller
N     * |        |          |The value of this field determines how many port registers are addressable in the Operational Register Space (see Table 2-8)
N     * |        |          |Valid values are in the range of 1H to FH.
N     * |        |          |A zero in this field is undefined.
N     * |[4]     |PPC       |Port Power Control
N     * |        |          |This field indicates whether the host controller implementation includes port power control
N     * |        |          |A one in this bit indicates the ports have port power switches
N     * |        |          |A zero in this bit indicates the port do not have port power stitches
N     * |        |          |The value of this field affects the functionality of the Port Power field in each port status and control register.
N     * |[11:8]  |N_PCC     |Number of Ports Per Companion Controller
N     * |        |          |This field indicates the number of ports supported per companion host controller
N     * |        |          |It is used to indicate the port routing configuration to system software.
N     * |        |          |For example, if N_PORTS has a value of 6 and N_CC has a value of 2 then N_PCC could have a value of 3
N     * |        |          |The convention is that the first N_PCC ports are assumed to be routed to companion controller 1, the next N_PCC ports to companion controller 2, etc
N     * |        |          |In the previous example, the N_PCC could have been 4, where the first 4 are routed to companion controller 1 and the last two are routed to companion controller 2.
N     * |        |          |The number in this field must be consistent with N_PORTS and N_CC.
N     * |[15:12] |N_CC      |Number of Companion Controller
N     * |        |          |This field indicates the number of companion controllers associated with this USB 2.0 host controller.
N     * |        |          |A zero in this field indicates there are no companion host controllers
N     * |        |          |Port-ownership hand-off is not supported
N     * |        |          |Only high-speed devices are supported on the host controller root ports.
N     * |        |          |A value larger than zero in this field indicates there are companion USB 1.1 host controller(s)
N     * |        |          |Port-ownership hand-offs are supported
N     * |        |          |High, Full- and Low-speed devices are supported on the host controller root ports.
N     * @var HSUSBH_T::EHCCPR
N     * Offset: 0x08  EHCI Capability Parameters Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |AC64      |64-bit Addressing Capability
N     * |        |          |0 = Data structure using 32-bit address memory pointers.
N     * |[1]     |PFLF      |Programmable Frame List Flag
N     * |        |          |0 = System software must use a frame list length of 1024 elements with this EHCI host controller.
N     * |[2]     |ASPC      |Asynchronous Schedule Park Capability
N     * |        |          |0 = This EHCI host controller doesn't support park feature of high-speed queue heads in the Asynchronous Schedule.
N     * |[7:4]   |IST       |Isochronous Scheduling Threshold
N     * |        |          |This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule.
N     * |        |          |When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures (one or more) before flushing the state.
N     * |[15:8]  |EECP      |EHCI Extended Capabilities Pointer (EECP)
N     * |        |          |0 = No extended capabilities are implemented.
N     * @var HSUSBH_T::UCMDR
N     * Offset: 0x20  USB Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RUN       |Run/Stop (R/W)
N     * |        |          |When set to a 1, the Host Controller proceeds with execution of the schedule
N     * |        |          |The Host Controller continues execution as long as this bit is set to a 1
N     * |        |          |When this bit is set to 0, the Host Controller completes the current and any actively pipelined transactions on the USB and then halts
N     * |        |          |The Host Controller must halt within 16 micro-frames after software clears the Run bit
N     * |        |          |The HC Halted bit in the status register indicates when the Host Controller has finished its pending pipelined transactions and has entered the stopped state
N     * |        |          |Software must not write a one to this field unless the host controller is in the Halted state (i.e.
N     * |        |          |HCHalted in the USBSTS register is a one)
N     * |        |          |Doing so will yield undefined results.
N     * |        |          |0 = Stop.
N     * |        |          |1 = Run.
N     * |[1]     |HCRST     |Host Controller Reset (HCRESET) (R/W)
N     * |        |          |This control bit is used by software to reset the host controller
N     * |        |          |The effects of this on Root Hub registers are similar to a Chip Hardware Reset.
N     * |        |          |When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines, etc
N     * |        |          |to their initial value
N     * |        |          |Any transaction currently in progress on USB is immediately terminated
N     * |        |          |A USB reset is not driven on downstream ports.
N     * |        |          |All operational registers, including port registers and port state machines are set to their initial values
N     * |        |          |Port ownership reverts to the companion host controller(s), with the side effects
N     * |        |          |Software must reinitialize the host controller in order to return the host controller to an operational state.
N     * |        |          |This bit is set to zero by the Host Controller when the reset process is complete
N     * |        |          |Software cannot terminate the reset process early by writing a zero to this register.
N     * |        |          |Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero
N     * |        |          |Attempting to reset an actively running host controller will result in undefined behavior.
N     * |[3:2]   |FLSZ      |Frame List Size (R/W or RO)
N     * |        |          |This field is R/W only if Programmable Frame List Flag in the HCCPARAMS registers is set to a one
N     * |        |          |This field specifies the size of the frame list
N     * |        |          |The size the frame list controls which bits in the Frame Index Register should be used for the Frame List Current index
N     * |        |          |Values mean:
N     * |        |          |00 = 1024 elements (4096 bytes) Default value.
N     * |        |          |01 = 512 elements (2048 bytes).
N     * |        |          |10 = 256 elements (1024 bytes) u2013 for resource-constrained environment.
N     * |        |          |11 = Reserved.
N     * |[4]     |PSEN      |Periodic Schedule Enable (R/W)
N     * |        |          |This bit controls whether the host controller skips processing the Periodic Schedule. Values mean:
N     * |        |          |0 = Do not process the Periodic Schedule.
N     * |        |          |1 = Use the PERIODICLISTBASE register to access the Periodic Schedule.
N     * |[5]     |ASEN      |Asynchronous Schedule Enable (R/W)
N     * |        |          |This bit controls whether the host controller skips processing the Asynchronous Schedule. Values mean:
N     * |        |          |0 = Do not process the Asynchronous Schedule.
N     * |        |          |1 = Use the ASYNCLISTADDR register to access the Asynchronous Schedule.
N     * |[6]     |IAAD      |Interrupt on Asynchronous Advance Doorbell (R/W)
N     * |        |          |This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule
N     * |        |          |Software must write a 1 to this bit to ring the doorbell.
N     * |        |          |When the host controller has evicted all appropriate cached schedule state, it sets the Interrupt on Asynchronous Advance status bit in the USBSTS register
N     * |        |          |If the Interrupt on Asynchronous Advance Enable bit in the USBINTR register is a one then the host controller will assert an interrupt at the next interrupt threshold.
N     * |        |          |The host controller sets this bit to a zero after it has set the Interrupt on Asynchronous Advance status bit in the USBSTS register to a one.
N     * |        |          |Software should not write a one to this bit when the asynchronous schedule is disabled
N     * |        |          |Doing so will yield undefined results.
N     * |[23:16] |ITC       |Interrupt Threshold Control (R/W)
N     * |        |          |This field is used by system software to select the maximum rate at which the host controller will issue interrupts
N     * |        |          |The only valid values are defined below
N     * |        |          |If software writes an invalid value to this register, the results are undefined
N     * |        |          |Value Maximum Interrupt Interval
N     * |        |          |0x00 = Reserved.
N     * |        |          |0x01 = 1 micro-frame.
N     * |        |          |0x02 = 2 micro-frames.
N     * |        |          |0x04 = 4 micro-frames.
N     * |        |          |0x08 = 8 micro-frames (default, equates to 1 ms).
N     * |        |          |0x10 = 16 micro-frames (2 ms).
N     * |        |          |0x20 = 32 micro-frames (4 ms).
N     * |        |          |0x40 = 64 micro-frames (8 ms).
N     * |        |          |Any other value in this register yields undefined results.
N     * |        |          |Software modifications to this bit while HCHalted bit is equal to zero results in undefined behavior.
N     * @var HSUSBH_T::USTSR
N     * Offset: 0x24  USB Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |USBINT    |USB Interrupt (USBINT) (R/WC)
N     * |        |          |The Host Controller sets this bit to 1 on the completion of a USB transaction, which results in the retirement of a Transfer Descriptor that had its IOC bit set.
N     * |        |          |The Host Controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes).
N     * |[1]     |UERRINT   |USB Error Interrupt (USBERRINT) (R/WC)
N     * |        |          |The Host Controller sets this bit to 1 when completion of a USB transaction results in an error condition (e.g., error counter underflow)
N     * |        |          |If the TD on which the error interrupt occurred also had its IOC bit set, both this bit and USBINT bit are set.
N     * |[2]     |PCD       |Port Change Detect (R/WC)
N     * |        |          |The Host Controller sets this bit to a one when any port for which the Port Owner bit is set to zero has a change bit transition from a zero to a one or a Force Port Resume bit transition from a zero to a one as a result of a J-K transition detected on a suspended port
N     * |        |          |This bit will also be set as a result of the Connect Status Change being set to a one after system software has relinquished ownership of a connected port by writing a one to a port's Port Owner bit.
N     * |        |          |This bit is allowed to be maintained in the Auxiliary power well
N     * |        |          |Alternatively, it is also acceptable that on a D3 to D0 transition of the EHCI HC device, this bit is loaded with the OR of all of the PORTSC change bits (including: Force port resume, over-current change, enable/disable change and connect status change).
N     * |[3]     |FLR       |Frame List Rollover (R/WC)
N     * |        |          |The Host Controller sets this bit to a one when the Frame List Index rolls over from its maximum value to zero
N     * |        |          |The exact value at which the rollover occurs depends on the frame list size
N     * |        |          |For example, if the frame list size (as programmed in the Frame List Size field of the USBCMD register) is 1024, the Frame Index Register rolls over every time FRINDEX[13] toggles
N     * |        |          |Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX[12] toggles.
N     * |[4]     |HSERR     |Host System Error (R/WC)
N     * |        |          |The Host Controller sets this bit to 1 when a serious error occurs during a host system access involving the Host Controller module.
N     * |[5]     |IAA       |Interrupt on Asynchronous Advance (R/WC)
N     * |        |          |System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Asynchronous Advance Doorbell bit in the USBCMD register
N     * |        |          |This status bit indicates the assertion of that interrupt source.
N     * |[12]    |HCHalted  |HCHalted (RO)
N     * |        |          |This bit is a zero whenever the Run/Stop bit is a one
N     * |        |          |The Host Controller sets this bit to one after it has stopped executing as a result of the Run/Stop bit being set to 0, either by software or by the Host Controller hardware (e.g.
N     * |        |          |internal error).
N     * |[13]    |RECLA     |Reclamation (RO)
N     * |        |          |This is a read-only status bit, which is used to detect an empty asynchronous schedule.
N     * |[14]    |PSS       |Periodic Schedule Status (RO)
N     * |        |          |The bit reports the current real status of the Periodic Schedule
N     * |        |          |If this bit is a zero then the status of the Periodic Schedule is disabled
N     * |        |          |If this bit is a one then the status of the Periodic Schedule is enabled
N     * |        |          |The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register
N     * |        |          |When this bit and the Periodic Schedule Enable bit are the same value, the Periodic Schedule is either enabled (1) or disabled (0).
N     * |[15]    |ASS       |Asynchronous Schedule Status (RO)
N     * |        |          |The bit reports the current real status of the Asynchronous Schedule
N     * |        |          |If this bit is a zero then the status of them Asynchronous Schedule is disabled
N     * |        |          |If this bit is a one then the status of the Asynchronous Schedule is enabled
N     * |        |          |The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register
N     * |        |          |When this bit and the Asynchronous Schedule Enable bit are the same value, the Asynchronous Schedule is either enabled (1) or disabled (0).
N     * @var HSUSBH_T::UIENR
N     * Offset: 0x28  USB Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |USBIEN    |USB Interrupt Enable or Disable Bit
N     * |        |          |When this bit is a one, and the USBINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold
N     * |        |          |The interrupt is acknowledged by software clearing the USBINT bit.
N     * |        |          |0 = USB interrupt Disabled.
N     * |        |          |1 = USB interrupt Enabled.
N     * |[1]     |UERRIEN   |USB Error Interrupt Enable or Disable Bit
N     * |        |          |When this bit is a one, and the USBERRINT bit in the USBSTS register is a one, the host t controller will issue an interrupt at the next interrupt threshold
N     * |        |          |The interrupt is acknowledged by software clearing the USBERRINT bit.
N     * |        |          |0 = USB Error interrupt Disabled.
N     * |        |          |1 = USB Error interrupt Enabled.
N     * |[2]     |PCIEN     |Port Change Interrupt Enable or Disable Bit
N     * |        |          |When this bit is a one, and the Port Change Detect bit in the USBSTS register is a one, the host controller will issue an interrupt
N     * |        |          |The interrupt is acknowledged by software clearing the Port Change Detect bit.
N     * |        |          |0 = Port Change interrupt Disabled.
N     * |        |          |1 = Port Change interrupt Enabled.
N     * |[3]     |FLREN     |Frame List Rollover Enable or Disable Bit
N     * |        |          |When this bit is a one, and the Frame List Rollover bit in the USBSTS register is a one, the host controller will issue an interrupt
N     * |        |          |The interrupt is acknowledged by software clearing the Frame List Rollover bit.
N     * |        |          |0 = Frame List Rollover interrupt Disabled.
N     * |        |          |1 = Frame List Rollover interrupt Enabled.
N     * |[4]     |HSERREN   |Host System Error Enable or Disable Bit
N     * |        |          |When this bit is a one, and the Host System Error Status bit in the USBSTS register is a one, the host controller will issue an interrupt
N     * |        |          |The interrupt is acknowledged by software clearing the Host System Error bit.
N     * |        |          |0 = Host System Error interrupt Disabled.
N     * |        |          |1 = Host System Error interrupt Enabled.
N     * |[5]     |IAAEN     |Interrupt on Asynchronous Advance Enable or Disable Bit
N     * |        |          |When this bit is a one, and the Interrupt on Asynchronous Advance bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold
N     * |        |          |The interrupt is acknowledged by software clearing the Interrupt on Asynchronous Advance bit.
N     * |        |          |0 = Interrupt on Asynchronous Advance Disabled.
N     * |        |          |1 = Interrupt on Asynchronous Advance Enabled.
N     * @var HSUSBH_T::UFINDR
N     * Offset: 0x2C  USB Frame Index Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[13:0]  |FI        |Frame Index
N     * |        |          |The value in this register increment at the end of each time frame (e.g.
N     * |        |          |micro-frame)
N     * |        |          |Bits [N:3] are used for the Frame List current index
N     * |        |          |This means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index
N     * |        |          |The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register.
N     * |        |          |FLSZ (UCMDR[3:2] Number Elements N
N     * |        |          |0x0 1024 12
N     * |        |          |0x1 512 11
N     * |        |          |0x2 256 10
N     * |        |          |0x3 Reserved
N     * @var HSUSBH_T::UPFLBAR
N     * Offset: 0x34  USB Periodic Frame List Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:12] |BADDR     |Base Address
N     * |        |          |These bits correspond to memory address signals [31:12], respectively.
N     * @var HSUSBH_T::UCALAR
N     * Offset: 0x38  USB Current Asynchronous List Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:5]  |LPL       |Link Pointer Low (LPL)
N     * |        |          |These bits correspond to memory address signals [31:5], respectively
N     * |        |          |This field may only reference a Queue Head (QH).
N     * @var HSUSBH_T::UASSTR
N     * Offset: 0x3C  USB Asynchronous Schedule Sleep Timer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |ASSTMR    |Asynchronous Schedule Sleep Timer
N     * |        |          |This field defines the AsyncSchedSleepTime of EHCI spec.
N     * |        |          |The asynchronous schedule sleep timer is used to control how often the host controller fetches asynchronous schedule list from system memory while the asynchronous schedule is empty.
N     * |        |          |The default value of this timer is 12'hBD6
N     * |        |          |Because this timer is implemented in UTMI clock (30MHz) domain, the default sleeping time will be about 100us.
N     * @var HSUSBH_T::UCFGR
N     * Offset: 0x60  USB Configure Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CF        |Configure Flag (CF)
N     * |        |          |Host software sets this bit as the last action in its process of configuring the Host Controller
N     * |        |          |This bit controls the default port-routing control logic
N     * |        |          |Bit values and side-effects are listed below.
N     * |        |          |0 = Port routing control logic default-routes each port to an implementation dependent classic host controller.
N     * |        |          |1 = Port routing control logic default-routes all ports to this host controller.
N     * @var HSUSBH_T::UPSCR[2]
N     * Offset: 0x64~0x68  USB Port 0~1 Status and Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CCS       |Current Connect Status (RO)
N     * |        |          |This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = No device is present.
N     * |        |          |1 = Device is present on port.
N     * |[1]     |CSC       |Connect Status Change (R/W)
N     * |        |          |Indicates a change has occurred in the port's Current Connect Status
N     * |        |          |The host controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change
N     * |        |          |For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be "setting" an already-set bit (i.e., the bit will remain set).Software sets this bit to 0 by writing a 1 to it.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = No change.
N     * |        |          |1 = Change in Current Connect Status.
N     * |[2]     |PE        |Port Enabled/Disabled (R/W)
N     * |        |          |Ports can only be enabled by the host controller as a part of the reset and enable
N     * |        |          |Software cannot enable a port by writing a one to this field
N     * |        |          |The host controller will only set this bit to a one when the reset sequence determines that the attached device is a high-speed device.
N     * |        |          |Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software
N     * |        |          |Note that the bit status does not change until the port state actually changes
N     * |        |          |There may be a delay in disabling or enabling a port due to other host controller and bus events.
N     * |        |          |When the port is disabled (0b) downstream propagation of data is blocked on this port, except for reset.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = Port Disabled.
N     * |        |          |1 = Port Enabled.
N     * |[3]     |PEC       |Port Enable/Disable Change (R/WC)
N     * |        |          |For the root hub, this bit gets set to a one only when a port is disabled due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification for the definition of a Port Error)
N     * |        |          |Software clears this bit by writing a 1 to it.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = No change.
N     * |        |          |1 = Port enabled/disabled status has changed.
N     * |[4]     |OCA       |Over-current Active (RO)
N     * |        |          |This bit will automatically transition from a one to a zero when the over current condition is removed.
N     * |        |          |0 = This port does not have an over-current condition.
N     * |        |          |1 = This port currently has an over-current condition.
N     * |[5]     |OCC       |Over-current Change (R/WC)
N     * |        |          |1 = This bit gets set to a one when there is a change to Over-current Active
N     * |        |          |Software clears this bit by writing a one to this bit position.
N     * |[6]     |FPR       |Force Port Resume (R/W)
N     * |        |          |This functionality defined for manipulating this bit depends on the value of the Suspend bit
N     * |        |          |For example, if the port is not suspended (Suspend and Enabled bits are a one) and software transitions this bit to a one, then the effects on the bus are undefined.
N     * |        |          |Software sets this bit to a 1 to drive resume signaling
N     * |        |          |The Host Controller sets this bit to a 1 if a J-to-K transition is detected while the port is in the Suspend state
N     * |        |          |When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to a one
N     * |        |          |If software sets this bit to a one, the host controller must not set the Port Change Detect bit.
N     * |        |          |Note that when the EHCI controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0
N     * |        |          |The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one
N     * |        |          |Software must appropriately time the Resume and set this bit to a zero when the appropriate amount of time has elapsed
N     * |        |          |Writing a zero (from one) causes the port to return to high-speed mode (forcing the bus below the port into a high-speed idle)
N     * |        |          |This bit will remain a one until the port has switched to the high-speed idle
N     * |        |          |The host controller must complete this transition within 2 milliseconds of software setting this bit to a zero.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = No resume (K-state) detected/driven on port.
N     * |        |          |1 = Resume detected/driven on port.
N     * |[7]     |SUSPEND   |Suspend (R/W)
N     * |        |          |Port Enabled Bit and Suspend bit of this register define the port states as follows:
N     * |        |          |Port enable is 0 and suspend is 0 = Disable.
N     * |        |          |Port enable is 0 and suspend is 1 = Disable.
N     * |        |          |Port enable is 1 and suspend is 0 = Enable.
N     * |        |          |Port enable is 1 and suspend is 1 = Suspend.
N     * |        |          |When in suspend state, downstream propagation of data is blocked on this port, except for port reset
N     * |        |          |The blocking occurs at the end of the current transaction, if a transaction was in progress when this bit was written to 1
N     * |        |          |In the suspend state, the port is sensitive to resume detection
N     * |        |          |Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB.
N     * |        |          |A write of zero to this bit is ignored by the host controller
N     * |        |          |The host controller will unconditionally set this bit to a zero when:
N     * |        |          |Software sets the Force Port Resume bit to a zero (from a one).
N     * |        |          |Software sets the Port Reset bit to a one (from a zero).
N     * |        |          |If host software sets this bit to a one when the port is not enabled (i.e.
N     * |        |          |Port enabled bit is a zero) the results are undefined.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = Port not in suspend state.
N     * |        |          |1 = Port in suspend state.
N     * |[8]     |PRST      |Port Reset (R/W)
N     * |        |          |When software writes a one to this bit (from a zero), the bus reset sequence as defined in the USB Specification Revision 2.0 is started
N     * |        |          |Software writes a zero to this bit to terminate the bus reset sequence
N     * |        |          |Software must keep this bit at a one long enough to ensure the reset sequence, as specified in the USB Specification Revision 2.0, completes
N     * |        |          |Note: when software writes this bit to a one, it must also write a zero to the Port Enable bit.
N     * |        |          |Note that when software writes a zero to this bit there may be a delay before the bit status changes to a zero
N     * |        |          |The bit status will not read as a zero until after the reset has completed
N     * |        |          |If the port is in high-speed mode after reset is complete, the host controller will automatically enable this port (e.g.
N     * |        |          |set the Port Enable bit to a one)
N     * |        |          |A host controller must terminate the reset and stabilize the state of the port within 2 milliseconds of software transitioning this bit from a one to a zero
N     * |        |          |For example: if the port detects that the attached device is high-speed during reset, then the host controller must have the port in the enabled state within 2ms of software writing this bit to a zero.
N     * |        |          |The HCHalted bit in the USBSTS register should be a zero before software attempts to use this bit
N     * |        |          |The host controller may hold Port Reset asserted to a one when the HCHalted bit is a one.
N     * |        |          |This field is zero if Port Power is zero.
N     * |        |          |0 = Port is not in Reset.
N     * |        |          |1 = Port is in Reset.
N     * |[11:10] |LSTS      |Line Status (RO)
N     * |        |          |These bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines
N     * |        |          |These bits are used for detection of low-speed USB devices prior to the port reset and enable sequence
N     * |        |          |This field is valid only when the port enable bit is zero and the current connect status bit is set to a one.
N     * |        |          |The encoding of the bits are:
N     * |        |          |Bits[11:10] USB State Interpretation
N     * |        |          |00 = SE0 Not Low-speed device, perform EHCI reset.
N     * |        |          |01 = K-state Low-speed device, release ownership of port.
N     * |        |          |10 = J-state Not Low-speed device, perform EHCI reset.
N     * |        |          |11 = Undefined Not Low-speed device, perform EHCI reset.
N     * |        |          |This value of this field is undefined if Port Power is zero.
N     * |[12]    |PP        |Port Power (PP)
N     * |        |          |Host controller has port power control switches
N     * |        |          |This bit represents the Current setting of the switch (0 = off, 1 = on)
N     * |        |          |When power is not available on a port (i.e.
N     * |        |          |PP equals a 0), the port is nonfunctional and will not report attaches, detaches, etc.
N     * |        |          |When an over-current condition is detected on a powered port and PPC is a one, the PP bit in each affected port may be transitioned by the host controller from a 1 to 0 (removing power from the port).
N     * |[13]    |PO        |Port Owner (R/W)
N     * |        |          |This bit unconditionally goes to a 0b when the Configured bit in the CONFIGFLAG register makes a 0 to 1 transition
N     * |        |          |This bit unconditionally goes to 1 whenever the Configured bit is zero.
N     * |        |          |System software uses this field to release ownership of the port to a selected host controller (in the event that the attached device is not a high-speed device)
N     * |        |          |Software writes a one to this bit when the attached device is not a high-speed device
N     * |        |          |A one in this bit means that a companion host controller owns and controls the port.
N     * |[19:16] |PTC       |Port Test Control (R/W)
N     * |        |          |When this field is zero, the port is NOT operating in a test mode
N     * |        |          |A non-zero value indicates that it is operating in test mode and the specific test mode is indicated by the specific value
N     * |        |          |The encoding of the test mode bits are (0x6 ~ 0xF are reserved):
N     * |        |          |Bits Test Mode
N     * |        |          |0x0 = Test mode not enabled.
N     * |        |          |0x1 = Test J_STATE.
N     * |        |          |0x2 = Test K_STATE.
N     * |        |          |0x3 = Test SE0_NAK.
N     * |        |          |0x4 = Test Packet.
N     * |        |          |0x5 = Test FORCE_ENABLE.
N     * @var HSUSBH_T::USBPCR0
N     * Offset: 0xC4  USB PHY 0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |SUSPEND   |Suspend Assertion
N     * |        |          |This bit controls the suspend mode of USB PHY 0.
N     * |        |          |While PHY was suspended, all circuits of PHY were powered down and outputs are tri-state.
N     * |        |          |This bit is 1'b0 in default
N     * |        |          |This means the USB PHY 0 is suspended in default
N     * |        |          |It is necessary to set this bit 1'b1 to make USB PHY 0 leave suspend mode before doing configuration of USB host.
N     * |        |          |0 = USB PHY 0 was suspended.
N     * |        |          |1 = USB PHY 0 was not suspended.
N     * |[11]    |CLKVALID  |UTMI Clock Valid
N     * |        |          |This bit is a flag to indicate if the UTMI clock from USB 2.0 PHY is ready
N     * |        |          |S/W program must prevent to write other control registers before this UTMI clock valid flag is active.
N     * |        |          |0 = UTMI clock is not valid.
N     * |        |          |1 = UTMI clock is valid.
N     * @var HSUSBH_T::USBPCR1
N     * Offset: 0xC8  USB PHY 1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |SUSPEND   |Suspend Assertion
N     * |        |          |This bit controls the suspend mode of USB PHY 1.
N     * |        |          |While PHY was suspended, all circuits of PHY were powered down and outputs are tri-state.
N     * |        |          |This bit is 1'b0 in default
N     * |        |          |This means the USB PHY 0 is suspended in default
N     * |        |          |It is necessary to set this bit 1'b1 to make USB PHY 0 leave suspend mode before doing configuration of USB host.
N     * |        |          |0 = USB PHY 1 was suspended.
N     * |        |          |1 = USB PHY 1 was not suspended.
N     */
N    __I  uint32_t EHCVNR;                /*!< [0x0000] EHCI Version Number Register                                     */
X    volatile const  uint32_t EHCVNR;                 
N    __I  uint32_t EHCSPR;                /*!< [0x0004] EHCI Structural Parameters Register                              */
X    volatile const  uint32_t EHCSPR;                 
N    __I  uint32_t EHCCPR;                /*!< [0x0008] EHCI Capability Parameters Register                              */
X    volatile const  uint32_t EHCCPR;                 
N    __I  uint32_t RESERVE0[5];
X    volatile const  uint32_t RESERVE0[5];
N    __IO uint32_t UCMDR;                 /*!< [0x0020] USB Command Register                                             */
X    volatile uint32_t UCMDR;                  
N    __IO uint32_t USTSR;                 /*!< [0x0024] USB Status Register                                              */
X    volatile uint32_t USTSR;                  
N    __IO uint32_t UIENR;                 /*!< [0x0028] USB Interrupt Enable Register                                    */
X    volatile uint32_t UIENR;                  
N    __IO uint32_t UFINDR;                /*!< [0x002c] USB Frame Index Register                                         */
X    volatile uint32_t UFINDR;                 
N    __I  uint32_t RESERVE1[1];
X    volatile const  uint32_t RESERVE1[1];
N    __IO uint32_t UPFLBAR;               /*!< [0x0034] USB Periodic Frame List Base Address Register                    */
X    volatile uint32_t UPFLBAR;                
N    __IO uint32_t UCALAR;                /*!< [0x0038] USB Current Asynchronous List Address Register                   */
X    volatile uint32_t UCALAR;                 
N    __IO uint32_t UASSTR;                /*!< [0x003c] USB Asynchronous Schedule Sleep Timer Register                   */
X    volatile uint32_t UASSTR;                 
N    __I  uint32_t RESERVE2[8];
X    volatile const  uint32_t RESERVE2[8];
N    __IO uint32_t UCFGR;                 /*!< [0x0060] USB Configure Flag Register                                      */
X    volatile uint32_t UCFGR;                  
N    __IO uint32_t UPSCR[2];              /*!< [0x0064] ~ [0x0068] USB Port 0 & 1 Status and Control Register            */
X    volatile uint32_t UPSCR[2];               
N    __I  uint32_t RESERVE3[22];
X    volatile const  uint32_t RESERVE3[22];
N    __IO uint32_t USBPCR0;               /*!< [0x00c4] USB PHY 0 Control Register                                       */
X    volatile uint32_t USBPCR0;                
N    __IO uint32_t USBPCR1;               /*!< [0x00c8] USB PHY 1 Control Register                                       */
X    volatile uint32_t USBPCR1;                
N
N} HSUSBH_T;
N
N/**
N    @addtogroup HSUSBH_CONST HSUSBH Bit Field Definition
N    Constant Definitions for HSUSBH Controller
N@{ */
N
N#define HSUSBH_EHCVNR_CRLEN_Pos          (0)                                               /*!< HSUSBH_T::EHCVNR: CRLEN Position       */
N#define HSUSBH_EHCVNR_CRLEN_Msk          (0xfful << HSUSBH_EHCVNR_CRLEN_Pos)               /*!< HSUSBH_T::EHCVNR: CRLEN Mask           */
N
N#define HSUSBH_EHCVNR_VERSION_Pos        (16)                                              /*!< HSUSBH_T::EHCVNR: VERSION Position     */
N#define HSUSBH_EHCVNR_VERSION_Msk        (0xfffful << HSUSBH_EHCVNR_VERSION_Pos)           /*!< HSUSBH_T::EHCVNR: VERSION Mask         */
N
N#define HSUSBH_EHCSPR_N_PORTS_Pos        (0)                                               /*!< HSUSBH_T::EHCSPR: N_PORTS Position     */
N#define HSUSBH_EHCSPR_N_PORTS_Msk        (0xful << HSUSBH_EHCSPR_N_PORTS_Pos)              /*!< HSUSBH_T::EHCSPR: N_PORTS Mask         */
N
N#define HSUSBH_EHCSPR_PPC_Pos            (4)                                               /*!< HSUSBH_T::EHCSPR: PPC Position         */
N#define HSUSBH_EHCSPR_PPC_Msk            (0x1ul << HSUSBH_EHCSPR_PPC_Pos)                  /*!< HSUSBH_T::EHCSPR: PPC Mask             */
N
N#define HSUSBH_EHCSPR_N_PCC_Pos          (8)                                               /*!< HSUSBH_T::EHCSPR: N_PCC Position       */
N#define HSUSBH_EHCSPR_N_PCC_Msk          (0xful << HSUSBH_EHCSPR_N_PCC_Pos)                /*!< HSUSBH_T::EHCSPR: N_PCC Mask           */
N
N#define HSUSBH_EHCSPR_N_CC_Pos           (12)                                              /*!< HSUSBH_T::EHCSPR: N_CC Position        */
N#define HSUSBH_EHCSPR_N_CC_Msk           (0xful << HSUSBH_EHCSPR_N_CC_Pos)                 /*!< HSUSBH_T::EHCSPR: N_CC Mask            */
N
N#define HSUSBH_EHCCPR_AC64_Pos           (0)                                               /*!< HSUSBH_T::EHCCPR: AC64 Position        */
N#define HSUSBH_EHCCPR_AC64_Msk           (0x1ul << HSUSBH_EHCCPR_AC64_Pos)                 /*!< HSUSBH_T::EHCCPR: AC64 Mask            */
N
N#define HSUSBH_EHCCPR_PFLF_Pos           (1)                                               /*!< HSUSBH_T::EHCCPR: PFLF Position        */
N#define HSUSBH_EHCCPR_PFLF_Msk           (0x1ul << HSUSBH_EHCCPR_PFLF_Pos)                 /*!< HSUSBH_T::EHCCPR: PFLF Mask            */
N
N#define HSUSBH_EHCCPR_ASPC_Pos           (2)                                               /*!< HSUSBH_T::EHCCPR: ASPC Position        */
N#define HSUSBH_EHCCPR_ASPC_Msk           (0x1ul << HSUSBH_EHCCPR_ASPC_Pos)                 /*!< HSUSBH_T::EHCCPR: ASPC Mask            */
N
N#define HSUSBH_EHCCPR_IST_Pos            (4)                                               /*!< HSUSBH_T::EHCCPR: IST Position         */
N#define HSUSBH_EHCCPR_IST_Msk            (0xful << HSUSBH_EHCCPR_IST_Pos)                  /*!< HSUSBH_T::EHCCPR: IST Mask             */
N
N#define HSUSBH_EHCCPR_EECP_Pos           (8)                                               /*!< HSUSBH_T::EHCCPR: EECP Position        */
N#define HSUSBH_EHCCPR_EECP_Msk           (0xfful << HSUSBH_EHCCPR_EECP_Pos)                /*!< HSUSBH_T::EHCCPR: EECP Mask            */
N
N#define HSUSBH_UCMDR_RUN_Pos             (0)                                               /*!< HSUSBH_T::UCMDR: RUN Position          */
N#define HSUSBH_UCMDR_RUN_Msk             (0x1ul << HSUSBH_UCMDR_RUN_Pos)                   /*!< HSUSBH_T::UCMDR: RUN Mask              */
N
N#define HSUSBH_UCMDR_HCRST_Pos           (1)                                               /*!< HSUSBH_T::UCMDR: HCRST Position        */
N#define HSUSBH_UCMDR_HCRST_Msk           (0x1ul << HSUSBH_UCMDR_HCRST_Pos)                 /*!< HSUSBH_T::UCMDR: HCRST Mask            */
N
N#define HSUSBH_UCMDR_FLSZ_Pos            (2)                                               /*!< HSUSBH_T::UCMDR: FLSZ Position         */
N#define HSUSBH_UCMDR_FLSZ_Msk            (0x3ul << HSUSBH_UCMDR_FLSZ_Pos)                  /*!< HSUSBH_T::UCMDR: FLSZ Mask             */
N
N#define HSUSBH_UCMDR_PSEN_Pos            (4)                                               /*!< HSUSBH_T::UCMDR: PSEN Position         */
N#define HSUSBH_UCMDR_PSEN_Msk            (0x1ul << HSUSBH_UCMDR_PSEN_Pos)                  /*!< HSUSBH_T::UCMDR: PSEN Mask             */
N
N#define HSUSBH_UCMDR_ASEN_Pos            (5)                                               /*!< HSUSBH_T::UCMDR: ASEN Position         */
N#define HSUSBH_UCMDR_ASEN_Msk            (0x1ul << HSUSBH_UCMDR_ASEN_Pos)                  /*!< HSUSBH_T::UCMDR: ASEN Mask             */
N
N#define HSUSBH_UCMDR_IAAD_Pos            (6)                                               /*!< HSUSBH_T::UCMDR: IAAD Position         */
N#define HSUSBH_UCMDR_IAAD_Msk            (0x1ul << HSUSBH_UCMDR_IAAD_Pos)                  /*!< HSUSBH_T::UCMDR: IAAD Mask             */
N
N#define HSUSBH_UCMDR_ITC_Pos             (16)                                              /*!< HSUSBH_T::UCMDR: ITC Position          */
N#define HSUSBH_UCMDR_ITC_Msk             (0xfful << HSUSBH_UCMDR_ITC_Pos)                  /*!< HSUSBH_T::UCMDR: ITC Mask              */
N
N#define HSUSBH_USTSR_USBINT_Pos          (0)                                               /*!< HSUSBH_T::USTSR: USBINT Position       */
N#define HSUSBH_USTSR_USBINT_Msk          (0x1ul << HSUSBH_USTSR_USBINT_Pos)                /*!< HSUSBH_T::USTSR: USBINT Mask           */
N
N#define HSUSBH_USTSR_UERRINT_Pos         (1)                                               /*!< HSUSBH_T::USTSR: UERRINT Position      */
N#define HSUSBH_USTSR_UERRINT_Msk         (0x1ul << HSUSBH_USTSR_UERRINT_Pos)               /*!< HSUSBH_T::USTSR: UERRINT Mask          */
N
N#define HSUSBH_USTSR_PCD_Pos             (2)                                               /*!< HSUSBH_T::USTSR: PCD Position          */
N#define HSUSBH_USTSR_PCD_Msk             (0x1ul << HSUSBH_USTSR_PCD_Pos)                   /*!< HSUSBH_T::USTSR: PCD Mask              */
N
N#define HSUSBH_USTSR_FLR_Pos             (3)                                               /*!< HSUSBH_T::USTSR: FLR Position          */
N#define HSUSBH_USTSR_FLR_Msk             (0x1ul << HSUSBH_USTSR_FLR_Pos)                   /*!< HSUSBH_T::USTSR: FLR Mask              */
N
N#define HSUSBH_USTSR_HSERR_Pos           (4)                                               /*!< HSUSBH_T::USTSR: HSERR Position        */
N#define HSUSBH_USTSR_HSERR_Msk           (0x1ul << HSUSBH_USTSR_HSERR_Pos)                 /*!< HSUSBH_T::USTSR: HSERR Mask            */
N
N#define HSUSBH_USTSR_IAA_Pos             (5)                                               /*!< HSUSBH_T::USTSR: IAA Position          */
N#define HSUSBH_USTSR_IAA_Msk             (0x1ul << HSUSBH_USTSR_IAA_Pos)                   /*!< HSUSBH_T::USTSR: IAA Mask              */
N
N#define HSUSBH_USTSR_HCHalted_Pos        (12)                                              /*!< HSUSBH_T::USTSR: HCHalted Position     */
N#define HSUSBH_USTSR_HCHalted_Msk        (0x1ul << HSUSBH_USTSR_HCHalted_Pos)              /*!< HSUSBH_T::USTSR: HCHalted Mask         */
N
N#define HSUSBH_USTSR_RECLA_Pos           (13)                                              /*!< HSUSBH_T::USTSR: RECLA Position        */
N#define HSUSBH_USTSR_RECLA_Msk           (0x1ul << HSUSBH_USTSR_RECLA_Pos)                 /*!< HSUSBH_T::USTSR: RECLA Mask            */
N
N#define HSUSBH_USTSR_PSS_Pos             (14)                                              /*!< HSUSBH_T::USTSR: PSS Position          */
N#define HSUSBH_USTSR_PSS_Msk             (0x1ul << HSUSBH_USTSR_PSS_Pos)                   /*!< HSUSBH_T::USTSR: PSS Mask              */
N
N#define HSUSBH_USTSR_ASS_Pos             (15)                                              /*!< HSUSBH_T::USTSR: ASS Position          */
N#define HSUSBH_USTSR_ASS_Msk             (0x1ul << HSUSBH_USTSR_ASS_Pos)                   /*!< HSUSBH_T::USTSR: ASS Mask              */
N
N#define HSUSBH_UIENR_USBIEN_Pos          (0)                                               /*!< HSUSBH_T::UIENR: USBIEN Position       */
N#define HSUSBH_UIENR_USBIEN_Msk          (0x1ul << HSUSBH_UIENR_USBIEN_Pos)                /*!< HSUSBH_T::UIENR: USBIEN Mask           */
N
N#define HSUSBH_UIENR_UERRIEN_Pos         (1)                                               /*!< HSUSBH_T::UIENR: UERRIEN Position      */
N#define HSUSBH_UIENR_UERRIEN_Msk         (0x1ul << HSUSBH_UIENR_UERRIEN_Pos)               /*!< HSUSBH_T::UIENR: UERRIEN Mask          */
N
N#define HSUSBH_UIENR_PCIEN_Pos           (2)                                               /*!< HSUSBH_T::UIENR: PCIEN Position        */
N#define HSUSBH_UIENR_PCIEN_Msk           (0x1ul << HSUSBH_UIENR_PCIEN_Pos)                 /*!< HSUSBH_T::UIENR: PCIEN Mask            */
N
N#define HSUSBH_UIENR_FLREN_Pos           (3)                                               /*!< HSUSBH_T::UIENR: FLREN Position        */
N#define HSUSBH_UIENR_FLREN_Msk           (0x1ul << HSUSBH_UIENR_FLREN_Pos)                 /*!< HSUSBH_T::UIENR: FLREN Mask            */
N
N#define HSUSBH_UIENR_HSERREN_Pos         (4)                                               /*!< HSUSBH_T::UIENR: HSERREN Position      */
N#define HSUSBH_UIENR_HSERREN_Msk         (0x1ul << HSUSBH_UIENR_HSERREN_Pos)               /*!< HSUSBH_T::UIENR: HSERREN Mask          */
N
N#define HSUSBH_UIENR_IAAEN_Pos           (5)                                               /*!< HSUSBH_T::UIENR: IAAEN Position        */
N#define HSUSBH_UIENR_IAAEN_Msk           (0x1ul << HSUSBH_UIENR_IAAEN_Pos)                 /*!< HSUSBH_T::UIENR: IAAEN Mask            */
N
N#define HSUSBH_UFINDR_FI_Pos             (0)                                               /*!< HSUSBH_T::UFINDR: FI Position          */
N#define HSUSBH_UFINDR_FI_Msk             (0x3ffful << HSUSBH_UFINDR_FI_Pos)                /*!< HSUSBH_T::UFINDR: FI Mask              */
N
N#define HSUSBH_UPFLBAR_BADDR_Pos         (12)                                              /*!< HSUSBH_T::UPFLBAR: BADDR Position      */
N#define HSUSBH_UPFLBAR_BADDR_Msk         (0xffffful << HSUSBH_UPFLBAR_BADDR_Pos)           /*!< HSUSBH_T::UPFLBAR: BADDR Mask          */
N
N#define HSUSBH_UCALAR_LPL_Pos            (5)                                               /*!< HSUSBH_T::UCALAR: LPL Position         */
N#define HSUSBH_UCALAR_LPL_Msk            (0x7fffffful << HSUSBH_UCALAR_LPL_Pos)            /*!< HSUSBH_T::UCALAR: LPL Mask             */
N
N#define HSUSBH_UASSTR_ASSTMR_Pos         (0)                                               /*!< HSUSBH_T::UASSTR: ASSTMR Position      */
N#define HSUSBH_UASSTR_ASSTMR_Msk         (0xffful << HSUSBH_UASSTR_ASSTMR_Pos)             /*!< HSUSBH_T::UASSTR: ASSTMR Mask          */
N
N#define HSUSBH_UCFGR_CF_Pos              (0)                                               /*!< HSUSBH_T::UCFGR: CF Position           */
N#define HSUSBH_UCFGR_CF_Msk              (0x1ul << HSUSBH_UCFGR_CF_Pos)                    /*!< HSUSBH_T::UCFGR: CF Mask               */
N
N#define HSUSBH_UPSCR_CCS_Pos             (0)                                               /*!< HSUSBH_T::UPSCR[2]: CCS Position       */
N#define HSUSBH_UPSCR_CCS_Msk             (0x1ul << HSUSBH_UPSCR_CCS_Pos)                   /*!< HSUSBH_T::UPSCR[2]: CCS Mask           */
N
N#define HSUSBH_UPSCR_CSC_Pos             (1)                                               /*!< HSUSBH_T::UPSCR[2]: CSC Position       */
N#define HSUSBH_UPSCR_CSC_Msk             (0x1ul << HSUSBH_UPSCR_CSC_Pos)                   /*!< HSUSBH_T::UPSCR[2]: CSC Mask           */
N
N#define HSUSBH_UPSCR_PE_Pos              (2)                                               /*!< HSUSBH_T::UPSCR[2]: PE Position        */
N#define HSUSBH_UPSCR_PE_Msk              (0x1ul << HSUSBH_UPSCR_PE_Pos)                    /*!< HSUSBH_T::UPSCR[2]: PE Mask            */
N
N#define HSUSBH_UPSCR_PEC_Pos             (3)                                               /*!< HSUSBH_T::UPSCR[2]: PEC Position       */
N#define HSUSBH_UPSCR_PEC_Msk             (0x1ul << HSUSBH_UPSCR_PEC_Pos)                   /*!< HSUSBH_T::UPSCR[2]: PEC Mask           */
N
N#define HSUSBH_UPSCR_OCA_Pos             (4)                                               /*!< HSUSBH_T::UPSCR[2]: OCA Position       */
N#define HSUSBH_UPSCR_OCA_Msk             (0x1ul << HSUSBH_UPSCR_OCA_Pos)                   /*!< HSUSBH_T::UPSCR[2]: OCA Mask           */
N
N#define HSUSBH_UPSCR_OCC_Pos             (5)                                               /*!< HSUSBH_T::UPSCR[2]: OCC Position       */
N#define HSUSBH_UPSCR_OCC_Msk             (0x1ul << HSUSBH_UPSCR_OCC_Pos)                   /*!< HSUSBH_T::UPSCR[2]: OCC Mask           */
N
N#define HSUSBH_UPSCR_FPR_Pos             (6)                                               /*!< HSUSBH_T::UPSCR[2]: FPR Position       */
N#define HSUSBH_UPSCR_FPR_Msk             (0x1ul << HSUSBH_UPSCR_FPR_Pos)                   /*!< HSUSBH_T::UPSCR[2]: FPR Mask           */
N
N#define HSUSBH_UPSCR_SUSPEND_Pos         (7)                                               /*!< HSUSBH_T::UPSCR[2]: SUSPEND Position   */
N#define HSUSBH_UPSCR_SUSPEND_Msk         (0x1ul << HSUSBH_UPSCR_SUSPEND_Pos)               /*!< HSUSBH_T::UPSCR[2]: SUSPEND Mask       */
N
N#define HSUSBH_UPSCR_PRST_Pos            (8)                                               /*!< HSUSBH_T::UPSCR[2]: PRST Position      */
N#define HSUSBH_UPSCR_PRST_Msk            (0x1ul << HSUSBH_UPSCR_PRST_Pos)                  /*!< HSUSBH_T::UPSCR[2]: PRST Mask          */
N
N#define HSUSBH_UPSCR_LSTS_Pos            (10)                                              /*!< HSUSBH_T::UPSCR[2]: LSTS Position      */
N#define HSUSBH_UPSCR_LSTS_Msk            (0x3ul << HSUSBH_UPSCR_LSTS_Pos)                  /*!< HSUSBH_T::UPSCR[2]: LSTS Mask          */
N
N#define HSUSBH_UPSCR_PP_Pos              (12)                                              /*!< HSUSBH_T::UPSCR[2]: PP Position        */
N#define HSUSBH_UPSCR_PP_Msk              (0x1ul << HSUSBH_UPSCR_PP_Pos)                    /*!< HSUSBH_T::UPSCR[2]: PP Mask            */
N
N#define HSUSBH_UPSCR_PO_Pos              (13)                                              /*!< HSUSBH_T::UPSCR[2]: PO Position        */
N#define HSUSBH_UPSCR_PO_Msk              (0x1ul << HSUSBH_UPSCR_PO_Pos)                    /*!< HSUSBH_T::UPSCR[2]: PO Mask            */
N
N#define HSUSBH_UPSCR_PTC_Pos             (16)                                              /*!< HSUSBH_T::UPSCR[2]: PTC Position       */
N#define HSUSBH_UPSCR_PTC_Msk             (0xful << HSUSBH_UPSCR_PTC_Pos)                   /*!< HSUSBH_T::UPSCR[2]: PTC Mask           */
N
N#define HSUSBH_USBPCR0_SUSPEND_Pos       (8)                                               /*!< HSUSBH_T::USBPCR0: SUSPEND Position    */
N#define HSUSBH_USBPCR0_SUSPEND_Msk       (0x1ul << HSUSBH_USBPCR0_SUSPEND_Pos)             /*!< HSUSBH_T::USBPCR0: SUSPEND Mask        */
N
N#define HSUSBH_USBPCR0_CLKVALID_Pos      (11)                                              /*!< HSUSBH_T::USBPCR0: CLKVALID Position   */
N#define HSUSBH_USBPCR0_CLKVALID_Msk      (0x1ul << HSUSBH_USBPCR0_CLKVALID_Pos)            /*!< HSUSBH_T::USBPCR0: CLKVALID Mask       */
N
N#define HSUSBH_USBPCR1_SUSPEND_Pos       (8)                                               /*!< HSUSBH_T::USBPCR1: SUSPEND Position    */
N#define HSUSBH_USBPCR1_SUSPEND_Msk       (0x1ul << HSUSBH_USBPCR1_SUSPEND_Pos)             /*!< HSUSBH_T::USBPCR1: SUSPEND Mask        */
N
N/**@}*/ /* HSUSBH_CONST */
N/**@}*/ /* end of HSUSBH register group */
N
N#define USBH                 ((USBH_T *)0xB0007000)
N#define HSUSBH               ((HSUSBH_T *)0xB0005000)
N
N
N/// @endcond /*HIDDEN_SYMBOLS*/
N
N#endif  /* _USBH_CONFIG_H_ */
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
N
L 13 "..\..\common\src\BSP\Library\USB_HOST\Inc\usb.h" 2
N#include "usbh_lib.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\usbh_lib.h" 1
N/**************************************************************************//**
N * @file     usbh_lib.h
N * @version  V1.10
N * $Revision: 4 $
N * $Date: 15/06/10 2:06p $
N * @brief    USB Host library exported header file.
N *
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef  _USBH_LIB_H_
N#define  _USBH_LIB_H_
N
N#include "nuc970.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC970_Library NUC970 Library
N  @{
N*/
N
N/** @addtogroup NUC970_USBH_Library USB Host Library
N  @{
N*/
N
N/** @addtogroup NUC970_USBH_EXPORTED_CONSTANTS USB Host Exported Constants
N  @{
N*/
N
N#define USBH_OK                     0      /*!< No error.                                       */
N#define USBH_ERR_MEMORY_OUT         -10    /*!< Out of memory.                                  */
N#define USBH_ERR_IF_ALT_LIMIT       -11    /*!< Number of alternative interface > MAX_ALT_PER_IFACE */
N#define USBH_ERR_IF_EP_LIMIT        -15    /*!< Number of endpoints > MAX_EP_PER_IFACE          */
N#define USBH_ERR_NOT_SUPPORTED      -101   /*!< Device/Class/Transfer not supported             */
N#define USBH_ERR_NOT_MATCHED        -103   /*!< Not macthed                                     */
N#define USBH_ERR_NOT_EXPECTED       -104   /*!< Unknown or unexpected                           */
N#define USBH_ERR_INVALID_PARAM      -105   /*!< Invalid parameter                               */
N#define USBH_ERR_NOT_FOUND          -106   /*!< Device or interface not found                   */
N#define USBH_ERR_EP_NOT_FOUND       -107   /*!< Endpoint not found                              */
N#define USBH_ERR_DESCRIPTOR         -137   /*!< Failed to parse USB descriptors                 */
N#define USBH_ERR_SET_DEV_ADDR       -139   /*!< Failed to set device address                    */
N#define USBH_ERR_SET_CONFIG         -151   /*!< Failed to set device configuration              */
N
N#define USBH_ERR_TRANSFER           -201   /*!< USB transfer error                              */
N#define USBH_ERR_TIMEOUT            -203   /*!< USB transfer time-out                           */
N#define USBH_ERR_ABORT              -205   /*!< USB transfer aborted due to disconnect or reset */
N#define USBH_ERR_PORT_RESET         -255   /*!< Hub port reset failed                           */
N#define USBH_ERR_SCH_OVERRUN        -257   /*!< USB isochronous schedule overrun                */
N#define USBH_ERR_DISCONNECTED       -259   /*!< USB device was disconnected                     */
N
N#define USBH_ERR_TRANSACTION        -271   /*!< USB transaction timeout, CRC, Bad PID, etc.     */
N#define USBH_ERR_BABBLE_DETECTED    -272   /*!< A babble is detected during the transaction   */
N#define USBH_ERR_DATA_BUFF          -274   /*!< Data buffer overrun or underrun                 */
N
N#define USBH_ERR_CC_NO_ERR          -280   /*!< OHCI CC code - no error                         */
N#define USBH_ERR_CRC                -281   /*!< USB trasfer CRC error                           */
N#define USBH_ERR_BIT_STUFF          -282   /*!< USB transfer bit stuffing error                 */
N#define USBH_ERR_DATA_TOGGLE        -283   /*!< USB trasfer data toggle error                   */
N#define USBH_ERR_STALL              -284   /*!< USB trasfer STALL error                         */
N#define USBH_ERR_DEV_NO_RESP        -285   /*!< USB trasfer device no response error            */
N#define USBH_ERR_PID_CHECK          -286   /*!< USB trasfer PID check failure                   */
N#define USBH_ERR_UNEXPECT_PID       -287   /*!< USB trasfer unexpected PID error                */
N#define USBH_ERR_DATA_OVERRUN       -288   /*!< USB trasfer data overrun error                  */
N#define USBH_ERR_DATA_UNDERRUN      -289   /*!< USB trasfer data underrun error                 */
N#define USBH_ERR_BUFF_OVERRUN       -292   /*!< USB trasfer buffer overrun error                */
N#define USBH_ERR_BUFF_UNDERRUN      -293   /*!< USB trasfer buffer underrun error               */
N#define USBH_ERR_NOT_ACCESS0        -294   /*!< USB trasfer not accessed error                  */
N#define USBH_ERR_NOT_ACCESS1        -295   /*!< USB trasfer not accessed error                  */
N
N#define USBH_ERR_OHCI_INIT          -301   /*!< Failed to initialize OHIC controller.           */
N#define USBH_ERR_OHCI_EP_BUSY       -303   /*!< The endpoint is under transfer.                 */
N
N#define USBH_ERR_EHCI_INIT          -501   /*!< Failed to initialize EHCI controller.           */
N#define USBH_ERR_EHCI_QH_BUSY       -503   /*!< the Queue Head is busy.                         */
N
N#define UMAS_OK                     0      /*!< No error.                                       */
N#define UMAS_ERR_NO_DEVICE          -1031  /*!< No Mass Stroage Device found.                   */
N#define UMAS_ERR_IO                 -1033  /*!< Device read/write failed.                       */
N#define UMAS_ERR_INIT_DEVICE        -1035  /*!< failed to init MSC device                       */
N#define UMAS_ERR_CMD_STATUS         -1037  /*!< SCSI command status failed                      */
N#define UMAS_ERR_IVALID_PARM        -1038  /*!< Invalid parameter.                              */
N#define UMAS_ERR_DRIVE_NOT_FOUND    -1039  /*!< drive not found                                 */
N
N#define HID_RET_OK                  0      /*!< Return with no errors.                          */
N#define HID_RET_DEV_NOT_FOUND       -1081  /*!< HID device not found or removed.                */
N#define HID_RET_IO_ERR              -1082  /*!< USB transfer failed.                            */
N#define HID_RET_INVALID_PARAMETER   -1083  /*!< Invalid parameter.                              */
N#define HID_RET_OUT_OF_MEMORY       -1084  /*!< Out of memory.                                  */
N#define HID_RET_NOT_SUPPORTED       -1085  /*!< Function not supported.                         */
N#define HID_RET_EP_NOT_FOUND        -1086  /*!< Endpoint not found.                             */
N#define HID_RET_XFER_IS_RUNNING     -1089  /*!< The transfer has been enabled.                  */
N
N#define UAC_RET_OK                   0     /*!< Return with no errors.                          */
N#define UAC_RET_DEV_NOT_FOUND       -2001  /*!< Audio Class device not found or removed.        */
N#define UAC_RET_FUNC_NOT_FOUND      -2002  /*!< Audio device has no this function.              */
N#define UAC_RET_IO_ERR              -2003  /*!< USB transfer failed.                            */
N#define UAC_RET_DATA_LEN            -2004  /*!< Unexpected transfer length                      */
N#define UAC_RET_INVALID             -2005  /*!< Invalid parameter or usage.                     */
N#define UAC_RET_OUT_OF_MEMORY       -2007  /*!< Out of memory.                                  */
N#define UAC_RET_DRV_NOT_SUPPORTED   -2009  /*!< Function not supported by this UAC driver.      */
N#define UAC_RET_DEV_NOT_SUPPORTED   -2011  /*!< Function not supported by the UAC device.       */
N#define UAC_RET_PARSER              -2013  /*!< Failed to parse UAC descriptor                  */
N#define UAC_RET_IS_STREAMING        -2015  /*!< Audio pipe is on streaming.                     */
N
N#define UVC_RET_OK                   0     /*!< Return with no errors.                          */
N#define UVC_RET_DEV_NOT_FOUND       -3001  /*!< Video Class device not found or removed.        */
N#define UVC_RET_FUNC_NOT_FOUND      -3002  /*!< video device has no this function.              */
N#define UVC_RET_IO_ERR              -3003  /*!< USB transfer failed.                            */
N#define UVC_RET_DATA_LEN            -3004  /*!< Unexpected transfer length                      */
N#define UVC_RET_INVALID             -3005  /*!< Invalid parameter or usage.                     */
N#define UVC_RET_OUT_OF_MEMORY       -3007  /*!< Out of memory.                                  */
N#define UVC_RET_DRV_NOT_SUPPORTED   -3009  /*!< Function not supported by this UVC driver.      */
N#define UVC_RET_DEV_NOT_SUPPORTED   -3011  /*!< Function not supported by the UVC device.       */
N#define UVC_RET_NOT_SUPPORT         -3012  /*!< Not supported.                                  */
N#define UVC_RET_PARSER              -3013  /*!< Failed to parse UVC descriptor                  */
N#define UVC_RET_IS_STREAMING        -3015  /*!< Video pipe is on streaming.                     */
N
N/*@}*/ /* end of group NUC970_USBH_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC970_USBH_EXPORTED_STRUCT Data structure
N  @{
N*/
Nstruct udev_t;
Ntypedef void (CONN_FUNC)(struct udev_t *udev, int param);
N
Nstruct line_coding_t;
Nstruct cdc_dev_t;
Ntypedef void (CDC_CB_FUNC)(struct cdc_dev_t *cdev, uint8_t *rdata, int data_len);
N
Nstruct usbhid_dev;
Ntypedef void (HID_IR_FUNC)(struct usbhid_dev *hdev, uint16_t ep_addr, int status, uint8_t *rdata, uint32_t data_len);    /*!< interrupt in callback function \hideinitializer */
Ntypedef void (HID_IW_FUNC)(struct usbhid_dev *hdev, uint16_t ep_addr, int status, uint8_t *wbuff, uint32_t *data_len);   /*!< interrupt out callback function \hideinitializer */
N
Nstruct uac_dev_t;
Ntypedef int (UAC_CB_FUNC)(struct uac_dev_t *dev, uint8_t *data, int len);    /*!< audio in callback function \hideinitializer */
N
Nstruct uvc_dev_t;
Ntypedef int (UVC_CB_FUNC)(struct uvc_dev_t *dev, uint8_t *data, int len);    /*!< video callback function \hideinitializer */
N
Ntypedef enum image_format_e
N{
N    UVC_FORMAT_INVALID = 0,
N    UVC_FORMAT_YUY2    = 1,
N    UVC_FORMAT_NV12    = 2,
N    UVC_FORMAT_M420    = 3,
N    UVC_FORMAT_I420    = 4,
N    UVC_FORMAT_MJPEG   = 11,
N}  IMAGE_FORMAT_E;
N
N/*@}*/ /* end of group NUC970_USBH_EXPORTED_STRUCT */
N
N
N
N
N/** @addtogroup NUC970_USBH_EXPORTED_FUNCTIONS USB Host Exported Functions
N  @{
N*/
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Core Library APIs                                           */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern void usbh_core_init(void);
Nextern int  usbh_pooling_hubs(void);
Nextern void usbh_install_conn_callback(CONN_FUNC *conn_func, CONN_FUNC *disconn_func);
Nextern void usbh_suspend(void);
Nextern void usbh_resume(void);
Nextern struct udev_t * usbh_find_device(char *hub_id, int port);
Nextern uint32_t get_ticks(void);   /* This function must be provided by user application. */
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Communication Device Class Library APIs                     */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern void     usbh_cdc_init(void);
Nextern struct cdc_dev_t * usbh_cdc_get_device_list(void);
N/// @cond HIDDEN_SYMBOLS
Nextern int32_t  usbh_cdc_get_line_coding(struct cdc_dev_t *cdev, struct line_coding_t *line_code);
Nextern int32_t  usbh_cdc_set_line_coding(struct cdc_dev_t *cdev, struct line_coding_t *line_code);
N/// @endcond HIDDEN_SYMBOLS
Nextern int32_t  usbh_cdc_set_control_line_state(struct cdc_dev_t *cdev, int active_carrier, int DTE_present);
Nextern int32_t  usbh_cdc_start_polling_status(struct cdc_dev_t *cdev, CDC_CB_FUNC *func);
Nextern int32_t  usbh_cdc_start_to_receive_data(struct cdc_dev_t *cdev, CDC_CB_FUNC *func);
Nextern int32_t  usbh_cdc_send_data(struct cdc_dev_t *cdev, uint8_t *buff, int buff_len);
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Human Interface Class Library APIs                          */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern void     usbh_hid_init(void);
Nextern struct usbhid_dev * usbh_hid_get_device_list(void);
Nextern int32_t  usbh_hid_get_report_descriptor(struct usbhid_dev *hdev, uint8_t *desc_buf, int buf_max_len);
Nextern int32_t  usbh_hid_get_report(struct usbhid_dev *hdev, int rtp_typ, int rtp_id, uint8_t *data, int len);
Nextern int32_t  usbh_hid_set_report(struct usbhid_dev *hdev, int rtp_typ, int rtp_id, uint8_t *data, int len);
Nextern int32_t  usbh_hid_get_idle(struct usbhid_dev *hdev, int rtp_id, uint8_t *idle_rate);
Nextern int32_t  usbh_hid_set_idle(struct usbhid_dev *hdev, int rtp_id, uint8_t idle_rate);
Nextern int32_t  usbh_hid_get_protocol(struct usbhid_dev *hdev, uint8_t *protocol);
Nextern int32_t  usbh_hid_set_protocol(struct usbhid_dev *hdev, uint8_t protocol);
Nextern int32_t  usbh_hid_start_int_read(struct usbhid_dev *hdev, uint8_t ep_addr, HID_IR_FUNC *func);
Nextern int32_t  usbh_hid_stop_int_read(struct usbhid_dev *hdev, uint8_t ep_addr);
Nextern int32_t  usbh_hid_start_int_write(struct usbhid_dev *hdev, uint8_t ep_addr, HID_IW_FUNC *func);
Nextern int32_t  usbh_hid_stop_int_write(struct usbhid_dev *hdev, uint8_t ep_addr);
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Mass Storage Class Library APIs                             */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern int  usbh_umas_init(void);
Nextern int  usbh_umas_disk_status(int drv_no);
Nextern int  usbh_umas_read(int drv_no, uint32_t sec_no, int sec_cnt, uint8_t *buff);
Nextern int  usbh_umas_write(int drv_no, uint32_t sec_no, int sec_cnt, uint8_t *buff);
Nextern int  usbh_umas_ioctl(int drv_no, int cmd, void *buff);
Nextern int  usbh_umas_reset_disk(int drv_no);
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Audio Class Library APIs                                    */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern void usbh_uac_init(void);
Nextern int usbh_uac_open(struct uac_dev_t *audev);
Nextern struct uac_dev_t * usbh_uac_get_device_list(void);
Nextern int usbh_uac_get_channel_number(struct uac_dev_t *audev, uint8_t target);
Nextern int usbh_uac_get_bit_resolution(struct uac_dev_t *audev, uint8_t target, uint8_t *byte_cnt);
Nextern int usbh_uac_get_sampling_rate(struct uac_dev_t *audev, uint8_t target, uint32_t *srate_list, int max_cnt, uint8_t *type);
Nextern int usbh_uac_sampling_rate_control(struct uac_dev_t *audev, uint8_t target, uint8_t req, uint32_t *srate);
Nextern int usbh_uac_mute_control(struct uac_dev_t *audev, uint8_t target, uint8_t req, uint16_t chn, uint8_t *mute);
Nextern int usbh_uac_vol_control(struct uac_dev_t *audev, uint8_t target, uint8_t req, uint16_t chn, uint16_t *volume);
Nextern int usbh_uac_auto_gain_control(struct uac_dev_t *audev, uint8_t target, uint8_t req, uint16_t chn, uint8_t *bAGC);
Nextern int usbh_uac_start_audio_in(struct uac_dev_t *uac, UAC_CB_FUNC *func);
Nextern int usbh_uac_stop_audio_in(struct uac_dev_t *audev);
Nextern int usbh_uac_start_audio_out(struct uac_dev_t *uac, UAC_CB_FUNC *func);
Nextern int usbh_uac_stop_audio_out(struct uac_dev_t *audev);
N
N/*------------------------------------------------------------------*/
N/*                                                                  */
N/*  USB Video Class Library APIs                                    */
N/*                                                                  */
N/*------------------------------------------------------------------*/
Nextern void usbh_uvc_init(void);
Nextern struct uvc_dev_t * usbh_uvc_get_device_list(void);
Nextern int  usbh_get_video_format(struct uvc_dev_t *vdev, int index, IMAGE_FORMAT_E *format, int *width, int *height);
Nextern int  usbh_set_video_format(struct uvc_dev_t *vdev, IMAGE_FORMAT_E format, int width, int height);
Nextern void usbh_uvc_set_video_buffer(struct uvc_dev_t *vdev, uint8_t *image_buff, int img_buff_size);
Nextern int usbh_uvc_start_streaming(struct uvc_dev_t *vdev, UVC_CB_FUNC *func);
Nextern int usbh_uvc_stop_streaming(struct uvc_dev_t *vdev);
N
N/// @cond HIDDEN_SYMBOLS
N
Nextern void dump_ohci_regs(void);
Nextern void dump_ehci_regs(void);
Nextern void dump_ohci_ports(void);
Nextern void dump_ehci_ports(void);
Nextern uint32_t  usbh_memory_used(void);
N
N/// @endcond HIDDEN_SYMBOLS
N
N
N/*@}*/ /* end of group NUC970_USBH_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC970_USBH_Library */
N
N/*@}*/ /* end of group NUC970_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* _USBH_LIB_H_ */
N
N/*** (C) COPYRIGHT 2017 Nuvoton Technology Corp. ***/
N
N
N
L 14 "..\..\common\src\BSP\Library\USB_HOST\Inc\usb.h" 2
N#include "ehci.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\ehci.h" 1
N/**************************************************************************//**
N * @file     ehci.h
N * @version  V1.00
N * @brief    USB EHCI host controller driver header file.
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef _USBH_EHCI_H_
N#define _USBH_EHCI_H_
N
N/// @cond HIDDEN_SYMBOLS
N
Nstruct utr_t;
Nstruct udev_t;
Nstruct qh_t;
Nstruct iso_ep_t;
Nstruct ep_info_t;
N
N/*----------------------------------------------------------------------------------------*/
N/*  Periodic Frame List Size (256, 512, or 1024)                                          */
N/*----------------------------------------------------------------------------------------*/
N#define FL_SIZE              1024            /* frame list size can be 256, 512, or 1024   */
N#define NUM_IQH              11              /* depends on FL_SIZE, 256:9, 512:10, 1024:11 */
N
N
N/*----------------------------------------------------------------------------------------*/
N/*  Interrupt Threshold Control (1, 2, 4, 6, .. 64)                                       */
N/*----------------------------------------------------------------------------------------*/
N#define UCMDR_INT_THR_CTRL     (0x1<<HSUSBH_UCMDR_ITC_Pos)     /* 1 micro-frames          */
N
N
N/*----------------------------------------------------------------------------------------*/
N/*  Queue Element Transfer Descriptor (qTD)                                               */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct qTD_t
N{
N    uint32_t      Next_qTD;                 /* Next qTD Pointer                           */
N    uint32_t      Alt_Next_qTD;             /* Alternate Next qTD Pointer                 */
N    uint32_t      Token;                    /* qTD Token                                  */
N    uint32_t      Bptr[5];                  /* qTD Buffer Page Pointer List               */
N    /*
N     * The following members are used by USB Host libary.
N     */
N    struct utr_t  *utr;                     /* associated UTR                             */
N    uint32_t      xfer_len;                 /* assigned transfer transfer length          */
N    struct qh_t   *qh;                      /* The QH that this qTD belong to.            */
N    struct qTD_t  *next;                    /* link for <qtd_list> of QH                  */
N}  qTD_T;
N
N
N#define QTD_LIST_END              0x1       /* Indicate the terminate of qTD list.        */
N#define QTD_PTR(x)                ((qTD_T *)((uint32_t)(x) & ~0x1F))
N
N/*
N *  Status: qTD Token[7:0]
N */
N#define QTD_STS_PS_OUT            (0<<0)    /* directs the HC to issue an OUT PID         */
N#define QTD_STS_PS_PING           (1<<0)    /* directs the HC to issue an PING PID        */
N#define QTD_STS_SPLIT_STRAT       (0<<1)    /* directs the HC to issue an Start split     */
N#define QTD_STS_SPLIT_COMPLETE    (1<<1)    /* directs the HC to issue an Complete split  */
N#define QTD_STS_MISS_MF           (1<<2)    /* miss a required complete-split transaction */
N#define QTD_STS_XactErr           (1<<3)    /* Transaction Error occurred                 */
N#define QTD_STS_BABBLE            (1<<4)    /* Babble Detected                            */
N#define QTD_STS_DATA_BUFF_ERR     (1<<5)    /* Data Buffer Error                          */
N#define QTD_STS_HALT              (1<<6)    /* Halted                                     */
N#define QTD_STS_ACTIVE            (1<<7)    /* Active                                     */
N
N/*
N *  PID: qTD Token[9:8]
N */
N#define QTD_PID_Msk              (0x3<<8)
N#define QTD_PID_OUT               (0<<8)    /* generates token (E1H)                      */
N#define QTD_PID_IN                (1<<8)    /* generates token (69H)                      */
N#define QTD_PID_SETUP             (2<<8)    /* generates token (2DH)                      */
N
N#define QTD_ERR_COUNTER           (3<<10)   /* Token[11:10]                               */
N#define QTD_IOC                   (1<<15)   /* Token[15] - Interrupt On Complete          */
N#define QTD_TODO_LEN_Pos          16        /* Token[31:16] - Total Bytes to Transfer     */
N#define QTD_TODO_LEN(x)           (((x)>>16) & 0x7FFF)
N#define QTD_DT                    (1UL<<31) /* Token[31] - Data Toggle                    */
N
N/*----------------------------------------------------------------------------------------*/
N/*  Queue Head (QH)                                                                       */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct qh_t
N{
N    /* OHCI spec. Endpoint descriptor  */
N    uint32_t    HLink;                      /* Queue Head Horizontal Link Pointer         */
N    uint32_t    Chrst;                      /* Endpoint Characteristics: QH DWord 1       */
N    uint32_t    Cap;                        /* Endpoint Capabilities: QH DWord 2          */
N    uint32_t    Curr_qTD;                   /* Current qTD Pointer                        */
N    /*
N     * The followings are qTD Transfer Overlay
N     */
N    uint32_t    OL_Next_qTD;                /* Next qTD Pointer                           */
N    uint32_t    OL_Alt_Next_qTD;            /* Alternate Next qTD Pointer                 */
N    uint32_t    OL_Token;                   /* qTD Token                                  */
N    uint32_t    OL_Bptr[5];                 /* qTD Buffer Page Pointer List               */
N    /*
N     * The following members are used by USB Host libary.
N     */
N    qTD_T       *qtd_list;                  /* currently linked qTD transfers             */
N    qTD_T       *done_list;                 /* currently linked qTD transfers             */
N    struct qh_t *next;                      /* point to the next QH in remove list        */
N}  QH_T;
N
N/*  HLink[0] T field of "Queue Head Horizontal Link Pointer" */
N#define QH_HLNK_END               0x1
N
N/*
N *  HLink[2:1] Typ field of "Queue Head Horizontal Link Pointer"
N */
N#define QH_HLNK_ITD(x)            (((uint32_t)(x) & ~0x1F) | 0x0)
N#define QH_HLNK_QH(x)             (((uint32_t)(x) & ~0x1F) | 0x2)
N#define QH_HLNK_SITD(x)           (((uint32_t)(x) & ~0x1F) | 0x4)
N#define QH_HLNK_FSTN(x)           (((uint32_t)(x) & ~0x1F) | 0x6)
N#define QH_PTR(x)                 ((QH_T *)((uint32_t)(x) & ~0x1F))
N
N/*
N *  Bit fields of "Endpoint Characteristics"
N */
N#define QH_NAK_RL                 (4L<<28)  /* Chrst[31:28] - NAK Count Reload            */
N#define QH_CTRL_EP_FLAG           (1<<27)   /* Chrst[27] - Control Endpoint Flag          */
N#define QH_RCLM_LIST_HEAD         (1<<15)   /* Chrst[15] - Head of Reclamation List Flag  */
N#define QH_DTC                    (1<<14)   /* Chrst[14] - Data Toggle Control            */
N#define QH_EPS_FULL               (0<<12)   /* Chrst[13:12] - Endpoint Speed (Full)       */
N#define QH_EPS_LOW                (1<<12)   /* Chrst[13:12] - Endpoint Speed (Low)        */
N#define QH_EPS_HIGH               (2<<12)   /* Chrst[13:12] - Endpoint Speed (High)       */
N#define QH_I_NEXT                 (1<<7)    /* Chrst[7] - Inactivate on Next Transaction  */
N
N/*
N *  Bit fields of "Endpoint Capabilities"
N */
N#define QH_MULT_Pos               30        /* Cap[31:30] - High-Bandwidth Pipe Multiplier */
N#define QH_HUB_PORT_Pos           23        /* Cap[29:23] - Hub Port Number               */
N#define QH_HUB_ADDR_Pos           16        /* Cap[22:16] - Hub Addr                      */
N#define QH_C_MASK_Msk             0xFF00    /* Cap[15:8]  - uFrame C-mask                 */
N#define QH_S_MASK_Msk             0x00FF    /* Cap[7:0]   - uFrame S-mask                 */
N
N
N/*----------------------------------------------------------------------------------------*/
N/*  Isochronous (High-Speed) Transfer Descriptor (iTD)                                    */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct itd_t
N{
N    uint32_t      Next_Link;                /* Next Link Pointer                          */
N    uint32_t      Transaction[8];           /* Transaction Status and Control             */
N    uint32_t      Bptr[7];                  /* Buffer Page Pointer List                   */
N    /*
N     * The following members are used by USB Host libary.
N     */
N    struct iso_ep_t *iso_ep;                /* associated isochronous information block   */
N    struct utr_t  *utr;                     /* associated UTR                             */
N    uint32_t      buff_base;                /* buffer base address                        */
N    uint8_t       fidx;                     /* iTD's first index to UTR iso frames        */
N    uint8_t       trans_mask;               /* mask of activated transactions in iTD      */
N    uint32_t      sched_frnidx;             /* scheduled frame index                      */
N    struct itd_t  *next;                    /* used by software to maintain iTD list      */
N}  iTD_T;
N
N/*
N *  Next_Link[2:1] Typ field of "Next Schedule Element Pointer"  Typ field
N */
N#define ITD_HLNK_ITD(x)           (((uint32_t)(x) & ~0x1F) | 0x0)
N#define ITD_HLNK_QH(x)            (((uint32_t)(x) & ~0x1F) | 0x2)
N#define ITD_HLNK_SITD(x)          (((uint32_t)(x) & ~0x1F) | 0x4)
N#define ITD_HLNK_FSTN(x)          (((uint32_t)(x) & ~0x1F) | 0x6)
N#define ITD_PTR(x)                ((iTD_T *)((uint32_t)(x) & ~0x1F))
N
N/*
N *  Transaction[8]
N */
N#define ITD_STATUS(x)             (((x)>>28)&0xF)
N#define ITD_STATUS_ACTIVE         (0x80000000UL)      /* Active                           */
N#define ITD_STATUS_BUFF_ERR       (0x40000000UL)      /* Data Buffer Error                */
N#define ITD_STATUS_BABBLE         (0x20000000UL)      /* Babble Detected                  */
N#define ITD_STATUS_XACT_ERR       (0x10000000UL)      /* Transcation Error                */
N
N#define ITD_XLEN_Pos              16
N#define ITD_XFER_LEN(x)           (((x)>>16)&0xFFF)
N#define ITD_IOC                   (1<<15)
N#define ITD_PG_Pos                12
N#define ITD_XFER_OFF_Msk          0xFFF
N
N/*
N *  Bptr[7]
N */
N#define ITD_BUFF_PAGE_Pos         12
N/* Bptr[0] */
N#define ITD_EP_NUM_Pos            8
N#define ITD_EP_NUM(itd)           (((itd)->Bptr[0]>>8)&0xF)
N#define ITD_DEV_ADDR_Pos          0
N#define ITD_DEV_ADDR(itd)         ((itd)->Bptr[0]&0x7F)
N/* Bptr[1] */
N#define ITD_DIR_IN                (1<<11)
N#define ITD_DIR_OUT               (0<<11)
N#define ITD_MAX_PKTSZ_Pos         0
N#define ITD_MAX_PKTSZ(itd)        ((itd)->Bptr[1]&0x7FF)
N
N/*----------------------------------------------------------------------------------------*/
N/*  Split Isochronous (Full-Speed) Transfer Descriptor (siTD)                             */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct sitd_t
N{
N    uint32_t      Next_Link;                /* Next Link Pointer                          */
N    uint32_t      Chrst;                    /* Endpoint and Transaction Translator Characteristics */
N    uint32_t      Sched;                    /* Micro-frame Schedule Control               */
N    uint32_t      StsCtrl;                  /* siTD Transfer Status and Control           */
N    uint32_t      Bptr[2];                  /* Buffer Page Pointer List                   */
N    uint32_t      BackLink;                 /* siTD Back Link Pointer                     */
N    /*
N     * The following members are used by USB Host libary.
N     */
N    struct iso_ep_t *iso_ep;                /* associated isochronous information block   */
N    struct utr_t  *utr;                     /* associated UTR                             */
N    uint8_t       fidx;                     /* iTD's first index to UTR iso frames        */
N    uint32_t      sched_frnidx;             /* scheduled frame index                      */
N    struct sitd_t *next;                    /* used by software to maintain siTD list     */
N}  siTD_T;
N
N#define SITD_LIST_END              0x1      /* Indicate the terminate of siTD list.       */
N
N#define SITD_XFER_IO_Msk           (1UL<<31)
N#define SITD_XFER_IN               (1UL<<31)
N#define SITD_XFER_OUT              (0UL<<31)
N
N#define SITD_PORT_NUM_Pos          24
N#define SITD_HUB_ADDR_Pos          16
N#define SITD_EP_NUM_Pos            8
N#define SITD_DEV_ADDR_Pos          0
N
N#define SITD_IOC                   (1UL<<31)
N#define SITD_XFER_CNT_Pos          16
N#define SITD_XFER_CNT_Msk          (0x3FF<<SITD_XFER_CNT_Pos)
N
N#define SITD_STATUS(x)             ((x)&0xFC)
N#define SITD_STATUS_ACTIVE         0x80
N#define SITD_STATUS_ERR            0x40
N#define SITD_STATUS_BUFF_ERR       0x20
N#define SITD_BABBLE_DETECTED       0x10
N#define SITD_STATUS_XFER_ERR       0x08
N#define SITD_STATUS_MISSED_MF      0x04
N#define SITD_STATUS_ERROR_MASK     0x78
N
N
N/*
N *  Next_Link[2:1] Typ field of "Next Schedule Element Pointer"  Typ field
N */
N#define SITD_HLNK_ITD(x)          (((uint32_t)(x) & ~0x1F) | 0x0)
N#define SITD_HLNK_QH(x)           (((uint32_t)(x) & ~0x1F) | 0x2)
N#define SITD_HLNK_SITD(x)         (((uint32_t)(x) & ~0x1F) | 0x4)
N#define SITD_HLNK_FSTN(x)         (((uint32_t)(x) & ~0x1F) | 0x6)
N#define SITD_PTR(x)               ((siTD_T *)((uint32_t)(x) & ~0x1F))
N
N#define HLINK_IS_TERMINATED(x)    (((uint32_t)(x) & 0x1) ? 1 : 0)
N#define HLINK_IS_SITD(x)          ((((uint32_t)(x) & 0x6) == 0x4) ? 1 : 0)
N
N/*----------------------------------------------------------------------------------------*/
N/*  Isochronous endpoint transfer information block. (Software only)                      */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct iso_ep_t
N{
N    struct ep_info_t  *ep;
N    uint32_t      next_frame;               /* frame number of next scheduling            */
N    iTD_T         *itd_list;                /* Reference to a list of installed iTDs      */
N    iTD_T         *itd_done_list;           /* Reference to a list of completed iTDs      */
N    siTD_T        *sitd_list;               /* Reference to a list of installed siTDs     */
N    siTD_T        *sitd_done_list;          /* Reference to a list of completed siTDs     */
N    struct iso_ep_t  *next;                 /* used by software to maintain ISO EP list   */
N} ISO_EP_T;
N
Nextern void scan_isochronous_list(void);
N
N/// @endcond
N
N#endif  /* _USBH_EHCI_H_ */
N
L 15 "..\..\common\src\BSP\Library\USB_HOST\Inc\usb.h" 2
N#include "ohci.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\ohci.h" 1
N/**************************************************************************//**
N * @file     ohci.h
N * @version  V1.00
N * @brief    USB OHCI host controller driver header file.
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef _USBH_OHCI_H_
N#define _USBH_OHCI_H_
N
N/// @cond HIDDEN_SYMBOLS
N
Nstruct utr_t;
Nstruct udev_t;
N
N/* OHCI CONTROL AND STATUS REGISTER MASKS */
N
N/*
N * Host controller functional state.
N * for HCFS(HcControl[7:6])
N */
N#define HCFS_RESET                (0UL << USBH_HcControl_HCFS_Pos)
N#define HCFS_RESUME               (1UL << USBH_HcControl_HCFS_Pos)
N#define HCFS_OPER                 (2UL << USBH_HcControl_HCFS_Pos)
N#define HCFS_SUSPEND              (3UL << USBH_HcControl_HCFS_Pos)
N
N
N/*----------------------------------------------------------------------------------------*/
N/*   Endpoint descriptor                                                                  */
N/*----------------------------------------------------------------------------------------*/
Ntypedef struct ed_t
N{
N    /* OHCI spec. Endpoint descriptor  */
N    uint32_t    Info;
N    uint32_t    TailP;
N    uint32_t    HeadP;
N    uint32_t    NextED;
N    /* The following members are used by USB Host libary.   */
N    uint8_t     bInterval;
N    uint16_t    next_sf;          /* for isochronous transfer, recording the next SF      */
N    struct ed_t * next;           /* point to the next ED in remove list                  */
N} ED_T;
N
N#define ED_CTRL_FA_Pos            0         /* Info[6:0]   - Function address             */
N#define ED_CTRL_EN_Pos            7         /* Info[10:7]  - Endpoint number              */
N#define ED_CTRL_DIR_Pos           11        /* Info[12:11] - Direction                    */
N#define ED_CTRL_MPS_Pos           16        /* Info[26:16] - Maximum packet size          */
N
N#define ED_FUNC_ADDR_Msk          (0x7f)
N#define ED_EP_ADDR_Msk            (0xf<<7)
N#define ED_DIR_Msk                (0x3<<11)
N#define ED_SPEED_Msk              (1<<13)
N#define ED_MAX_PK_SIZE_Msk        (0x7ff<<16)
N
N#define ED_DIR_BY_TD              (0<<ED_CTRL_DIR_Pos)
N#define ED_DIR_OUT                (1<<ED_CTRL_DIR_Pos)
N#define ED_DIR_IN                 (2<<ED_CTRL_DIR_Pos)
N#define ED_SPEED_FULL             (0<<13)   /* Info[13] - 0: is full speed device         */
N#define ED_SPEED_LOW              (1<<13)   /* Info[13] - 1: is low speed device          */
N#define ED_SKIP                   (1<<14)   /* Info[14] - 1: HC skip this ED              */
N#define ED_FORMAT_GENERAL         (0<<15)   /* Info[15] - 0: is a general TD              */
N#define ED_FORMAT_ISO             (1<<15)   /* Info[15] - 1: is an isochronous TD         */
N#define ED_HEADP_HALT             (1<<0)    /* HeadP[0] - 1: Halt; 0: Not                 */
N
N
N/*----------------------------------------------------------------------------------------*/
N/*   Transfer descriptor                                                                  */
N/*----------------------------------------------------------------------------------------*/
N/* general transfer descriptor  */
Ntypedef struct td_t
N{
N    uint32_t    Info;
N    uint32_t    CBP;                        /* Current Buffer Pointer                     */
N    uint32_t    NextTD;                     /* Next TD                                    */
N    uint32_t    BE;                         /* Buffer End                                 */
N    uint32_t    PSW[4];                     /* PSW 0~7                                    */
N    /* The following members are used by USB Host libary.   */
N    uint32_t    buff_start;                 /* Buffer Start                               */
N    ED_T        *ed;                        /* The ED that this TD belong to.             */
N    struct utr_t  *utr;                     /* associated UTR                             */
N    struct td_t *next;                      /* point to next TD of the same UTR           */
N} TD_T;
N
N#define TD_ADDR_MASK              0xFFFFFFFC
N
N/* Completion codes */
Nenum OCHI_CC_CODE
N{
N    /* mapping of the OHCI CC status to error codes */
N    CC_NOERROR,                             /* No  Error                                  */
N    CC_CRC,                                 /* CRC Error                                  */
N    CC_BITSTUFF,                            /* Bit Stuff                                  */
N    CC_DATA_TOGGLE,                         /* Data Toggle                                */
N    CC_STALL,                               /* Stall                                      */
N    CC_NOTRESPONSE,                         /* DevNotResp                                 */
N    CC_PID_CHECK,                           /* PIDCheck                                   */
N    CC_UNEXPECTED_PID,                      /* UnExpPID                                   */
N    CC_DATA_OVERRUN,                        /* DataOver                                   */
N    CC_DATA_UNDERRUN,                       /* DataUnder                                  */
N    CC_RESERVED1,                           /* reserved                                   */
N    CC_RESERVED2,                           /* reserved                                   */
N    CC_BUFFER_OVERRUN,                      /* BufferOver                                 */
N    CC_BUFFER_UNDERRUN,                     /* BuffUnder                                  */
N    CC_NOT_ACCESS                           /* Not Access                                 */
N};
N
N/* TD control field */
N#define TD_CC                     0xF0000000
N#define TD_CC_GET(td)             ((td >>28) & 0x0F)
N#define TD_CC_SET(td, cc)         (td) = ((td) & 0x0FFFFFFF) | (((cc) & 0x0F) << 28)
N#define TD_T_DATA0                0x02000000
N#define TD_T_DATA1                0x03000000
N#define TD_R                      0x00040000
N#define TD_DP                     0x00180000
N#define TD_DP_IN                  0x00100000
N#define TD_DP_OUT                 0x00080000
N#define MAXPSW                    8
N/* steel TD reserved bits to keep driver data */
N#define TD_TYPE_Msk               (0x3<<16)
N#define TD_TYPE_CTRL              (0x0<<16)
N#define TD_TYPE_BULK              (0x1<<16)
N#define TD_TYPE_INT               (0x2<<16)
N#define TD_TYPE_ISO               (0x3<<16)
N#define TD_CTRL_Msk               (0x7<<15)
N#define TD_CTRL_DATA              (1<<15)
N
N
N/*
N * The HCCA (Host Controller Communications Area) is a 256 byte
N * structure defined in the OHCI spec. that the host controller is
N * told the base address of.  It must be 256-byte aligned.
N */
Ntypedef struct
N{
N    uint32_t   int_table[32];               /* Interrupt ED table                         */
N    uint16_t   frame_no;                    /* current frame number                       */
N    uint16_t   pad1;                        /* set to 0 on each frame_no change           */
N    uint32_t   done_head;                   /* info returned for an interrupt             */
N    uint8_t    reserved_for_hc[116];
N} HCCA_T;
N
N
N/// @endcond
N
N#endif  /* _USBH_OHCI_H_ */
L 16 "..\..\common\src\BSP\Library\USB_HOST\Inc\usb.h" 2
N
N/// @cond HIDDEN_SYMBOLS
N
Nstruct utr_t;
Nstruct udev_t;
Nstruct hub_dev_t;
Nstruct iface_t;
Nstruct ep_info_t;
N
N/*----------------------------------------------------------------------------------*/
N/*   USB device request setup packet                                                */
N/*----------------------------------------------------------------------------------*/
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t  bmRequestType;
N    uint8_t  bRequest;
N    uint16_t wValue;
N    uint16_t wIndex;
N    uint16_t wLength;
N}
NDEV_REQ_T;
N
N/*
N *  bmRequestType[7]    - Data transfer direction
N */
N#define REQ_TYPE_OUT                   0x00
N#define REQ_TYPE_IN                    0x80
N/*
N *  bmRequestType[6:5]  - Type
N */
N#define REQ_TYPE_STD_DEV               0x00
N#define REQ_TYPE_CLASS_DEV             0x20
N#define REQ_TYPE_VENDOR_DEV            0x40
N/*
N *  bmRequestType[4:0]  - Recipient
N */
N#define REQ_TYPE_TO_DEV                0x00
N#define REQ_TYPE_TO_IFACE              0x01
N#define REQ_TYPE_TO_EP                 0x02
N#define REQ_TYPE_TO_OTHER              0x03
N/*
N *  Standard Requests
N */
N#define USB_REQ_GET_STATUS             0x00
N#define USB_REQ_CLEAR_FEATURE          0x01
N#define USB_REQ_SET_FEATURE            0x03
N#define USB_REQ_SET_ADDRESS            0x05
N#define USB_REQ_GET_DESCRIPTOR         0x06
N#define USB_REQ_SET_CONFIGURATION      0x09
N#define USB_REQ_SET_INTERFACE          0x0B
N/*
N *  Descriptor Types
N */
N#define USB_DT_STANDARD                0x00
N#define USB_DT_CLASS                   0x20
N#define USB_DT_VENDOR                  0x40
N
N#define USB_DT_DEVICE                  0x01
N#define USB_DT_CONFIGURATION           0x02
N#define USB_DT_STRING                  0x03
N#define USB_DT_INTERFACE               0x04
N#define USB_DT_ENDPOINT                0x05
N#define USB_DT_DEVICE_QUALIFIER        0x06
N#define USB_DT_OTHER_SPEED_CONF        0x07
N#define USB_DT_IFACE_POWER             0x08
N
N
N
N/*----------------------------------------------------------------------------------*/
N/*  USB standard descriptors                                                        */
N/*----------------------------------------------------------------------------------*/
N
N/* Descriptor header */
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t  bLength;
N    uint8_t  bDescriptorType;
N}
NDESC_HDR_T;
N
N/*----------------------------------------------------------------------------------*/
N/*  USB device descriptor                                                           */
N/*----------------------------------------------------------------------------------*/
Ntypedef struct __attribute__((__packed__))  /*!< device descriptor structure        */
N{
N    uint8_t  bLength;                   /*!< Length of device descriptor            */
N    uint8_t  bDescriptorType;           /*!< Device descriptor type                 */
N    uint16_t bcdUSB;                    /*!< USB version number                     */
N    uint8_t  bDeviceClass;              /*!< Device class code                      */
N    uint8_t  bDeviceSubClass;           /*!< Device subclass code                   */
N    uint8_t  bDeviceProtocol;           /*!< Device protocol code                   */
N    uint8_t  bMaxPacketSize0;           /*!< Maximum packet size of control endpoint*/
N    uint16_t idVendor;                  /*!< Vendor ID                              */
N    uint16_t idProduct;                 /*!< Product ID                             */
N    uint16_t bcdDevice;                 /*!< Device ID                              */
N    uint8_t  iManufacturer;             /*!< Manufacture description string ID      */
N    uint8_t  iProduct;                  /*!< Product description string ID          */
N    uint8_t  iSerialNumber;             /*!< Serial number description string ID    */
N    uint8_t  bNumConfigurations;        /*!< Total number of configurations         */
N}
NDESC_DEV_T;                           /*!< device descriptor structure            */
N
N/*
N *  Configuration Descriptor
N */
Ntypedef struct __attribute__((__packed__)) usb_config_descriptor  /*!< Configuration descriptor structure     */
N{
N    uint8_t   bLength;                  /*!< Length of configuration descriptor     */
N    uint8_t   bDescriptorType;          /*!< Descriptor type                        */
N    uint16_t  wTotalLength;             /*!< Total length of this configuration     */
N    uint8_t   bNumInterfaces;           /*!< Total number of interfaces             */
N    uint8_t   bConfigurationValue;      /*!< Configuration descriptor number        */
N    uint8_t   iConfiguration;           /*!< String descriptor ID                   */
N    uint8_t   bmAttributes;             /*!< Configuration characteristics          */
N    uint8_t   MaxPower;                 /*!< Maximum power consumption              */
N} DESC_CONF_T;                          /*!< Configuration descriptor structure     */
N
N/*
N *  Interface Descriptor
N */
Ntypedef struct __attribute__((__packed__)) usb_interface_descriptor  /*!< Interface descriptor structure       */
N{
N    uint8_t  bLength;                   /*!< Length of interface descriptor         */
N    uint8_t  bDescriptorType;           /*!< Descriptor type                        */
N    uint8_t  bInterfaceNumber;          /*!< Interface number                       */
N    uint8_t  bAlternateSetting;         /*!< Alternate setting number               */
N    uint8_t  bNumEndpoints;             /*!< Number of endpoints                    */
N    uint8_t  bInterfaceClass;           /*!< Interface class code                   */
N    uint8_t  bInterfaceSubClass;        /*!< Interface subclass code                */
N    uint8_t  bInterfaceProtocol;        /*!< Interface protocol code                */
N    uint8_t  iInterface;                /*!< Interface ID                           */
N} DESC_IF_T;                            /*!< Interface descriptor structure         */
N
N/*
N *  Interface descriptor bInterfaceClass[7:0]
N */
N#define USB_CLASS_AUDIO                0x01
N#define USB_CLASS_COMM                 0x02
N#define USB_CLASS_HID                  0x03
N#define USB_CLASS_PRINTER              0x07
N#define USB_CLASS_MASS_STORAGE         0x08
N#define USB_CLASS_HUB                  0x09
N#define USB_CLASS_DATA                 0x0A
N#define USB_CLASS_VIDEO                0x0E
N
N/*
N *  Endpoint Descriptor
N */
Ntypedef struct __attribute__((__packed__)) usb_endpoint_descriptor  /*!< Endpoint descriptor structure         */
N{
N    uint8_t  bLength;                   /*!< Length of endpoint descriptor          */
N    uint8_t  bDescriptorType;           /*!< Descriptor type                        */
N    uint8_t  bEndpointAddress;          /*!< Endpoint address                       */
N    uint8_t  bmAttributes;              /*!< Endpoint attribute                     */
N    uint16_t wMaxPacketSize;            /*!< Maximum packet size                    */
N    uint8_t  bInterval;                 /*!< Synchronous transfer interval          */
N    uint8_t  bRefresh;                  /*!< Refresh                                */
N    uint8_t  bSynchAddress;             /*!< Sync address                           */
N} DESC_EP_T;                            /*!< Endpoint descriptor structure          */
N
N/*
N *  Endpoint descriptor bEndpointAddress[7] - direction
N */
N#define EP_ADDR_DIR_MASK               0x80
N#define EP_ADDR_DIR_IN                 0x80
N#define EP_ADDR_DIR_OUT                0x00
N
N/*
N *  Endpoint descriptor bmAttributes[1:0] - transfer type
N */
N#define EP_ATTR_TT_MASK                0x03
N#define EP_ATTR_TT_CTRL                0x00
N#define EP_ATTR_TT_ISO                 0x01
N#define EP_ATTR_TT_BULK                0x02
N#define EP_ATTR_TT_INT                 0x03
N
N
N/*----------------------------------------------------------------------------------*/
N/*  USB Host controller driver                                                      */
N/*----------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    int   (*init) (void);
N    void  (*shutdown) (void);
N    void  (*suspend) (void);
N    void  (*resume) (void);
N    int   (*ctrl_xfer)(struct utr_t *utr);
N    int   (*bulk_xfer)(struct utr_t *utr);
N    int   (*int_xfer)(struct utr_t *utr);
N    int   (*iso_xfer)(struct utr_t *utr);
N    int   (*quit_xfer)(struct utr_t *utr, struct ep_info_t *ep);
N
N    /* root hub support */
N    int   (*rthub_port_reset)(int port);
N    int   (*rthub_polling) (void);
N} HC_DRV_T;
N
N
N/*----------------------------------------------------------------------------------*/
N/*  USB device driver                                                               */
N/*----------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    int   (*probe) (struct iface_t *iface);
N    void  (*disconnect) (struct iface_t *iface);
N    void  (*suspend) (struct iface_t *iface);
N    void  (*resume) (struct iface_t *iface);
N} UDEV_DRV_T;
N
N
N/*----------------------------------------------------------------------------------*/
N/*  USB device                                                                      */
N/*----------------------------------------------------------------------------------*/
N
Ntypedef enum
N{
N    SPEED_LOW,
N    SPEED_FULL,
N    SPEED_HIGH
N} SPEED_E;
N
Ntypedef struct ep_info_t
N{
N    uint8_t     bEndpointAddress;
N    uint8_t     bmAttributes;
N    uint8_t     bInterval;
N    uint8_t     bToggle;
N    uint16_t    wMaxPacketSize;
N    void        *hw_pipe;               /*!< point to the HC assocaied endpoint    \hideinitializer */
N}   EP_INFO_T;
N
Ntypedef struct udev_t
N{
N    DESC_DEV_T    descriptor;           /*!< Device descriptor.                    \hideinitializer */
N    struct hub_dev_t *parent;           /*!< parent hub device                     \hideinitializer */
N    uint8_t       port_num;             /*!< The hub port this device connected on \hideinitializer */
N    uint8_t       dev_num;              /*!< device number                         \hideinitializer */
N    int8_t        cur_conf;             /*!< Currentll selected configuration      \hideinitializer */
N    SPEED_E       speed;                /*!< device speed (low/full/high)          \hideinitializer */
N    /*
N     *  The followings are lightweight USB stack internal used .
N    */
N    uint8_t       *cfd_buff;            /*!< Configuration descriptor buffer.      \hideinitializer */
N    EP_INFO_T     ep0;                  /*!< Endpoint 0                            \hideinitializer */
N    HC_DRV_T      *hc_driver;           /*!< host controller driver                \hideinitializer */
N    struct iface_t  *iface_list;        /*!< Working interface list                \hideinitializer */
N    struct udev_t *next;                /*!< link for global usb device list       \hideinitializer */
N} UDEV_T;
N
Ntypedef struct alt_iface_t
N{
N    DESC_IF_T     *ifd;                 /*!< point to the location of this alternative interface descriptor in UDEV_T->cfd_buff */
N    EP_INFO_T     ep[MAX_EP_PER_IFACE]; /*!< endpoints of this alternative interface                */
X    EP_INFO_T     ep[8];  
N} ALT_IFACE_T;
N
Ntypedef struct iface_t
N{
N    UDEV_T        *udev;                /*!< USB device                            \hideinitializer */
N    uint8_t       if_num;               /*!< Interface number                      \hideinitializer */
N    uint8_t       num_alt;              /*!< Number of alternative interface       \hideinitializer */
N    ALT_IFACE_T   *aif;                 /*!< Point to the active alternative interface              */
N    ALT_IFACE_T   alt[MAX_ALT_PER_IFACE];  /*!< List of alternative interface      \hideinitializer */
X    ALT_IFACE_T   alt[12];   
N    UDEV_DRV_T    *driver;              /*!< Interface associated driver           \hideinitializer */
N    void          *context;             /*!< Reference to device context           \hideinitializer */
N    struct iface_t  *next;              /*!< Point to next interface of the same device. Started from UDEV_T->iface_list   \hideinitializer */
N} IFACE_T;
N
N
N/*----------------------------------------------------------------------------------*/
N/*  URB (USB Request Block)                                                         */
N/*----------------------------------------------------------------------------------*/
N
N#define IF_PER_UTR             8      /* number of frames per UTR isochronous transfer (DO NOT modify it!)  */
N
Ntypedef void (*FUNC_UTR_T)(struct utr_t *);
N
Ntypedef struct utr_t
N{
N    UDEV_T      *udev;                /*!< point to associated USB device        \hideinitializer */
N    DEV_REQ_T   setup;                /*!< buffer for setup packet               \hideinitializer */
N    EP_INFO_T   *ep;                  /*!< associated endpoint                   \hideinitializer */
N    uint8_t     *buff;                /*!< transfer buffer                       \hideinitializer */
N    uint8_t     bIsTransferDone;      /*!< tansfer done?                         \hideinitializer */
N    uint32_t    data_len;             /*!< length of data to be transferred      \hideinitializer */
N    uint32_t    xfer_len;             /*!< length of transferred data            \hideinitializer */
N    uint8_t     bIsoNewSched;         /*!< New schedule isochronous transfer     \hideinitializer */
N    uint16_t    iso_sf;               /*!< Isochronous start frame number        \hideinitializer */
N    uint16_t    iso_xlen[IF_PER_UTR]; /*!< transfer length of isochronous frames \hideinitializer */
X    uint16_t    iso_xlen[8];  
N    uint8_t *   iso_buff[IF_PER_UTR]; /*!< transfer buffer address of isochronous frames \hideinitializer */
X    uint8_t *   iso_buff[8];  
N    int         iso_status[IF_PER_UTR]; /*!< transfer status of isochronous frames \hideinitializer */
X    int         iso_status[8];  
N    int         td_cnt;               /*!< number of transfer descriptors        \hideinitializer */
N    int         status;               /*!< return status                         \hideinitializer */
N    int         interval;             /*!< interrupt/isochronous interval        \hideinitializer */
N    void        *context;             /*!< point to deivce proprietary data area \hideinitializer */
N    FUNC_UTR_T  func;                 /*!< tansfer done call-back function       \hideinitializer */
N    struct utr_t  *next;              /* point to the next UTR of the same endpoint. \hideinitializer */
N} UTR_T;
N
N
N/*----------------------------------------------------------------------------------*/
N/*  Global variables                                                                */
N/*----------------------------------------------------------------------------------*/
Nextern USBH_T      *_ohci;
Nextern HSUSBH_T    *_ehci;
N
Nextern HC_DRV_T    ohci_driver;
Nextern HC_DRV_T    ehci_driver;
N
Nextern UDEV_T * g_udev_list;
N
Nextern volatile int _IsInUsbInterrupt;
N
N/*----------------------------------------------------------------------------------*/
N/*  USB stack exported functions                                                    */
N/*----------------------------------------------------------------------------------*/
Nextern void delay_us(int usec);
N
Nextern void dump_ohci_regs(void);
Nextern void dump_ohci_ports(void);
Nextern void dump_ohci_int_table(void);
Nextern void dump_ehci_regs(void);
Nextern void dump_ehci_qtd(qTD_T *qtd);
Nextern void dump_ehci_asynclist(void);
Nextern void dump_ehci_period_frame_list_simple(void);
Nextern void usbh_dump_buff_bytes(uint8_t *buff, int nSize);
Nextern void usbh_dump_interface_descriptor(DESC_IF_T *if_desc);
Nextern void usbh_dump_endpoint_descriptor(DESC_EP_T *ep_desc);
Nextern void usbh_dump_iface(IFACE_T *iface);
Nextern void usbh_dump_ep_info(EP_INFO_T *ep);
N
N/*
N *  Memory management functions
N */
Nextern void USB_InitializeMemoryPool(void);
Nextern void * USB_malloc(int wanted_size, int boundary);
Nextern void USB_free(void *);
Nextern int  USB_available_memory(void);
Nextern int  USB_allocated_memory(void);
Nextern void usbh_memory_init(void);
Nextern uint32_t  usbh_memory_used(void);
Nextern void * usbh_alloc_mem(int size);
Nextern void usbh_free_mem(void *p, int size);
Nextern int  alloc_dev_address(void);
Nextern void free_dev_address(int dev_addr);
Nextern UDEV_T * alloc_device(void);
Nextern void free_device(UDEV_T *udev);
Nextern UTR_T * alloc_utr(UDEV_T *udev);
Nextern void free_utr(UTR_T *utr);
Nextern ED_T * alloc_ohci_ED(void);
Nextern void free_ohci_ED(ED_T *ed);
Nextern TD_T * alloc_ohci_TD(UTR_T *utr);
Nextern void free_ohci_TD(TD_T *td);
Nextern QH_T * alloc_ehci_QH(void);
Nextern void free_ehci_QH(QH_T *qh);
Nextern qTD_T * alloc_ehci_qTD(UTR_T *utr);
Nextern void free_ehci_qTD(qTD_T *qtd);
Nextern iTD_T * alloc_ehci_iTD(void);
Nextern void free_ehci_iTD(iTD_T *itd);
Nextern siTD_T * alloc_ehci_siTD(void);
Nextern void free_ehci_siTD(siTD_T *sitd);
N
N
Nextern void usbh_hub_init(void);
Nextern int  connect_device(UDEV_T *);
Nextern void disconnect_device(UDEV_T *);
Nextern int  usbh_register_driver(UDEV_DRV_T *driver);
Nextern EP_INFO_T * usbh_iface_find_ep(IFACE_T *iface, uint8_t ep_addr, uint8_t dir_type);
Nextern int  usbh_reset_device(UDEV_T *);
N
N/*
N *  USB Standard Request functions
N */
Nextern int usbh_get_device_descriptor(UDEV_T *udev, DESC_DEV_T *desc_buff);
Nextern int usbh_get_config_descriptor(UDEV_T *udev, uint8_t *desc_buff, int buff_len);
Nextern int usbh_set_configuration(UDEV_T *udev, uint8_t conf_val);
Nextern int usbh_set_interface(IFACE_T *iface, uint16_t alt_setting);
Nextern int usbh_clear_halt(UDEV_T *udev, uint16_t ep_addr);
N
Nextern int usbh_ctrl_xfer(UDEV_T *udev, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, uint8_t *buff, uint32_t *xfer_len, uint32_t timeout);
Nextern int usbh_bulk_xfer(UTR_T *utr);
Nextern int usbh_int_xfer(UTR_T *utr);
Nextern int usbh_iso_xfer(UTR_T *utr);
Nextern int usbh_quit_utr(UTR_T *utr);
Nextern int usbh_quit_xfer(UDEV_T *udev, EP_INFO_T *ep);
N
N
N/// @endcond HIDDEN_SYMBOLS
N
N#endif  /* _USBH_H_ */
L 19 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N#include "hub.h"
L 1 "..\..\common\src\BSP\Library\USB_HOST\Inc\hub.h" 1
N/**************************************************************************//**
N * @file     hub.h
N * @version  V1.00
N * @brief    USB Host hub class driver header file.
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#ifndef _USBH_HUB_H_
N#define _USBH_HUB_H_
N
N
N/// @cond HIDDEN_SYMBOLS
N
N
N/*--------------------------------------------------------------------------*/
N/*   Hub class feature selectors (Table 11-17)                              */
N/*--------------------------------------------------------------------------*/
N#define FS_C_HUB_LOCAL_POWER           0
N#define FS_C_HUB_OVER_CURRENT          1
N
N#define FS_PORT_CONNECTION             0
N#define FS_PORT_ENABLE                 1
N#define FS_PORT_SUSPEND                2
N#define FS_PORT_OVER_CURRENT           3
N#define FS_PORT_RESET                  4
N#define FS_PORT_POWER                  8
N#define FS_C_PORT_CONNECTION           16
N#define FS_C_PORT_ENABLE               17
N#define FS_C_PORT_SUSPEND              18
N#define FS_C_PORT_OVER_CURRENT         19
N#define FS_C_PORT_RESET                20
N
N/*--------------------------------------------------------------------------*/
N/*   Hub/Port staus and change bits                                         */
N/*--------------------------------------------------------------------------*/
N#define HUB_S_LOCAL_POWER              (1UL << 0)
N#define HUB_S_OVERCURRENT              (1UL << 1)
N
N#define HUB_C_LOCAL_POWER              (1UL << 0)
N#define HUB_C_OVERCURRENT              (1UL << 1)
N
N#define PORT_S_CONNECTION              (1UL << 0)
N#define PORT_S_ENABLE                  (1UL << 1)
N#define PORT_S_SUSPEND                 (1UL << 2)
N#define PORT_S_OVERCURRENT             (1UL << 3)
N#define PORT_S_RESET                   (1UL << 4)
N#define PORT_S_PORT_POWER              (1UL << 8)
N#define PORT_S_LOW_SPEED               (1UL << 9)
N#define PORT_S_HIGH_SPEED              (1UL << 10)
N#define PORT_S_TEST                    (1UL << 11)
N#define PORT_S_INDICATOR               (1UL << 12)
N
N#define PORT_C_CONNECTION              (1UL << 0)
N#define PORT_C_ENABLE                  (1UL << 1)
N#define PORT_C_SUSPEND                 (1UL << 2)
N#define PORT_C_OVERCURRENT             (1UL << 3)
N#define PORT_C_RESET                   (1UL << 4)
N
N
N/*--------------------------------------------------------------------------*/
N/*   Hub descriptor                                                         */
N/*--------------------------------------------------------------------------*/
Ntypedef struct __attribute__((__packed__))
N{
N    uint8_t  bDescLength;
N    uint8_t  bDescriptorType;
N    uint8_t  bNbrPorts;
N    uint16_t wHubCharacteristics;
N    uint8_t  bPwrOn2PwrGood;
N    uint8_t  bHubContrCurrent;
N    uint8_t  bDeviceRemovble;
N    uint8_t  PortPwrCtrlMask[16];
N}
NDESC_HUB_T;
N
N/*
N *   wHubCharacteristics bit field mask
N */
N#define HUB_CHAR_LPSM                  0x0003   /* 00b: global port power, 01b: per port power, 1x: reserved */
N#define HUB_CHAR_COMPOUND              0x0004   /* 1: is part of a compond device, 0: is not.       */
N#define HUB_CHAR_OCPM                  0x0018   /* 00b: global over-current protection, 01b: per port, 1x: reserved  */
N#define HUB_CHAR_TTTT                  0x0060   /* TT think time. 00b: 8FS, 01b: 16FS, 10b: 24FS, 11b: 32FS  */
N#define HUB_CHAR_PORTIND               0x0080   /* 1: port indicator (LED) supported, 0: not      */
N
N/* port indicator status selectors */
N#define HUB_LED_AUTO                   0
N#define HUB_LED_AMBER                  1
N#define HUB_LED_GREEN                  2
N#define HUB_LED_OFF                    3
N
N
N/*--------------------------------------------------------------------------*/
N/*   Port reset retry and time-out settings                                 */
N/*--------------------------------------------------------------------------*/
N#define HUB_DEBOUNCE_TIME              800      /* Hub connect/disconnect de-bounce time in ms     */
N#define PORT_RESET_RETRY               3        /* port reset retry times                          */
N#define PORT_RESET_TIME_MS             50       /* port reset time (ms)                            */
N#define PORT_RESET_RETRY_INC_MS        250      /* increased reset time (ms) after reset failed    */
N
N
N#define HUB_STATUS_MAX_BYTE            2        /* maximum number of interrupt-in status bytes     */
N/* 2 can support up to 16 port hubs                */
N/* 4 can support up to 32 port hubs                */
N/* Note!! If modeifed to 4, "uint16_t sc_bitmap"   */
N/*        MUST be changed as "uint32_t sc_bitmap"  */
Ntypedef struct hub_dev_t
N{
N    IFACE_T    *iface;                 /*!< Interface device of this hub          \hideinitializer */
N    UTR_T      *utr;                   /*!< Interrupt in UTR of this hub          \hideinitializer */
N    // uint8_t    buff[HUB_STATUS_MAX_BYTE];   /*!< Interrupt in buffer              \hideinitializer */
N    uint16_t   sc_bitmap;              /*!< Hub and Port Status Change Bitmap     \hideinitializer */
N    uint8_t    bNbrPorts;              /*!< Number of ports                       \hideinitializer */
N    uint8_t    bPwrOn2PwrGood;         /*!< Hub power on to power good time       \hideinitializer */
N    char       pos_id[MAX_HUB_DEVICE+1];   /*!< Hub position identifier           \hideinitializer */
X    char       pos_id[8+1];    
N    int        (*port_reset)(struct hub_dev_t *hub, int port);/*!< Port reset function                   \hideinitializer */
N    UDEV_T     *children;              /*!< Child device list.                    \hideinitializer */
N} HUB_DEV_T;
N
N
N/// @endcond
N
N#endif  /* _USBH_HUB_H_ */
L 20 "..\..\common\src\BSP\Library\USB_HOST\src_core\ehci_iso.c" 2
N
N
N/// @cond HIDDEN_SYMBOLS
N
Nuint32_t  g_flr_cnt;                        /* frame list rollover counter                */
N
NISO_EP_T  *iso_ep_list;                     /* list of activated isochronous pipes        */
N
Nextern uint32_t *_PFList;                   /* Periodic frame list                        */
N
Nstatic const uint16_t sitd_OUT_Smask [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
N
Nstatic int ehci_iso_split_xfer(UTR_T *utr, ISO_EP_T *iso_ep);
N
N/*
N *  Inspect the iTD can be reclaimed or not. If yes, collect the transaction results.
N *  Return:  1 - reclaimed
N *           0 - not completed
N */
Nstatic int  review_itd(iTD_T *itd)
N{
N    UTR_T      *utr;
N    uint32_t   frnidx = itd->sched_frnidx;
N    uint32_t   now_frame = (_ehci->UFINDR >> 3) & 0x3FF;
N    int        i, fidx;
N
N    // sysprintf("R - %d %d, 0x%x\n", now_frame, frnidx, itd->Transaction[0]);
N
N    if (now_frame == frnidx)
N    {
N        for (i = 0; i < 8; i++)
N        {
N            if (itd->Transaction[i] & ITD_STATUS_ACTIVE)
X            if (itd->Transaction[i] & (0x80000000UL))
N                return 0;                   /* have any not completed frames              */
N        }
N    }
N    else if (now_frame > frnidx)
N    {
N        if ((now_frame - frnidx) > EHCI_ISO_RCLM_RANGE)
X        if ((now_frame - frnidx) > 32)
N            return 0;                       /* don't touch it                             */
N    }
N    else
N    {
N        if (now_frame + FL_SIZE - frnidx > EHCI_ISO_RCLM_RANGE)
X        if (now_frame + 1024 - frnidx > 32)
N            return 0;                       /* don't touch it                             */
N    }
N
N    /*
N     *  Reclaim this iTD
N     */
N    utr = itd->utr;
N    fidx = itd->fidx;
N    for (i = 0; i < 8; i++)
N    {
N        if (!(itd->trans_mask & (0x1<<i)))
N            continue;                       /* not scheduled micro-frame                  */
N
N        if (ITD_STATUS(itd->Transaction[i]))
X        if ((((itd->Transaction[i])>>28)&0xF))
N        {
N            if (itd->Transaction[i] & ITD_STATUS_ACTIVE)
X            if (itd->Transaction[i] & (0x80000000UL))
N            {
N                utr->iso_status[fidx] = USBH_ERR_NOT_ACCESS0;
X                utr->iso_status[fidx] = -294;
N                utr->status = USBH_ERR_NOT_ACCESS0;
X                utr->status = -294;
N            }
N            else if (itd->Transaction[i] & ITD_STATUS_BABBLE)
X            else if (itd->Transaction[i] & (0x20000000UL))
N            {
N                utr->iso_status[fidx] = USBH_ERR_BABBLE_DETECTED;
X                utr->iso_status[fidx] = -272;
N                utr->status = USBH_ERR_TRANSFER;
X                utr->status = -201;
N            }
N            else if (itd->Transaction[i] & ITD_STATUS_BUFF_ERR)
X            else if (itd->Transaction[i] & (0x40000000UL))
N            {
N                utr->iso_status[fidx] = USBH_ERR_DATA_BUFF;
X                utr->iso_status[fidx] = -274;
N                utr->status = USBH_ERR_TRANSFER;
X                utr->status = -201;
N            }
N            else
N            {
N                utr->iso_status[fidx] = USBH_ERR_TRANSACTION;
X                utr->iso_status[fidx] = -271;
N                utr->status = USBH_ERR_TRANSFER;
X                utr->status = -201;
N            }
N        }
N        else
N        {
N            utr->iso_status[fidx] = 0;
N            utr->iso_xlen[fidx] = ITD_XFER_LEN(itd->Transaction[i]);
X            utr->iso_xlen[fidx] = (((itd->Transaction[i])>>16)&0xFFF);
N        }
N        fidx++;
N    }
N    utr->td_cnt--;
N
N    if (utr->td_cnt == 0)                   /* All iTD of this UTR done                   */
N    {
N        utr->bIsTransferDone = 1;
N        if (utr->func)
N            utr->func(utr);
N    }
N
N    return 1;                               /* to be reclaimed                            */
N}
N
N/*
N *  Inspect the siTD can be reclaimed or not. If yes, collect the transaction results.
N *  Return:  1 - reclaimed
N *           0 - not completed
N */
Nstatic int  review_sitd(siTD_T *sitd)
N{
N    UTR_T      *utr;
N    uint32_t   frnidx = sitd->sched_frnidx;
N    uint32_t   now_frame = (_ehci->UFINDR >> 3) & 0x3FF;
N    int        fidx;
N    uint32_t   TotalBytesToTransfer;
N
N    if (now_frame == frnidx)
N    {
N        if (SITD_STATUS(sitd->StsCtrl) == SITD_STATUS_ACTIVE)
X        if (((sitd->StsCtrl)&0xFC) == 0x80)
N            return 0;
N    }
N    else if (now_frame > frnidx)
N    {
N        if ((now_frame - frnidx) > EHCI_ISO_RCLM_RANGE)
X        if ((now_frame - frnidx) > 32)
N            return 0;                       /* don't touch it                             */
N    }
N    else
N    {
N        if (now_frame + FL_SIZE - frnidx > EHCI_ISO_RCLM_RANGE)
X        if (now_frame + 1024 - frnidx > 32)
N            return 0;                       /* don't touch it                             */
N    }
N
N    /*
N     *  Reclaim this siTD
N     */
N    utr = sitd->utr;
N    fidx = sitd->fidx;
N
N    if (SITD_STATUS(sitd->StsCtrl))
X    if (((sitd->StsCtrl)&0xFC))
N    {
N        if (sitd->StsCtrl & SITD_STATUS_ACTIVE)
X        if (sitd->StsCtrl & 0x80)
N        {
N            utr->iso_status[fidx] = USBH_ERR_NOT_ACCESS0;
X            utr->iso_status[fidx] = -294;
N        }
N        else if (sitd->StsCtrl & SITD_BABBLE_DETECTED)
X        else if (sitd->StsCtrl & 0x10)
N        {
N            utr->iso_status[fidx] = USBH_ERR_BABBLE_DETECTED;
X            utr->iso_status[fidx] = -272;
N            utr->status = USBH_ERR_TRANSFER;
X            utr->status = -201;
N        }
N        else if (sitd->StsCtrl & SITD_STATUS_BUFF_ERR)
X        else if (sitd->StsCtrl & 0x20)
N        {
N            utr->iso_status[fidx] = USBH_ERR_DATA_BUFF;
X            utr->iso_status[fidx] = -274;
N            utr->status = USBH_ERR_TRANSFER;
X            utr->status = -201;
N        }
N        else
N        {
N            utr->iso_status[fidx] = USBH_ERR_TRANSACTION;
X            utr->iso_status[fidx] = -271;
N            utr->status = USBH_ERR_TRANSFER;
X            utr->status = -201;
N        }
N    }
N    else
N    {
N        TotalBytesToTransfer = (sitd->StsCtrl & SITD_XFER_CNT_Msk) >> SITD_XFER_CNT_Pos;
X        TotalBytesToTransfer = (sitd->StsCtrl & (0x3FF<<16)) >> 16;
N        utr->iso_xlen[fidx] =  utr->iso_xlen[fidx] - TotalBytesToTransfer;
N        utr->iso_status[fidx] = 0;
N    }
N    utr->td_cnt--;
N
N    if (utr->td_cnt == 0)                   /* All iTD of this UTR done                   */
N    {
N        utr->bIsTransferDone = 1;
N        if (utr->func)
N            utr->func(utr);
N    }
N    return 1;                               /* to be reclaimed                            */
N}
N
N/*
N *  Some iTD/siTD may be scheduled but not serviced due to time missed.
N *  This function scan several earlier frames and drop unserviced iTD/siTD if found.
N */
Nvoid scan_isochronous_list(void)
N{
N    ISO_EP_T   *iso_ep = iso_ep_list;
N    iTD_T      *itd, *itd_pre, *p;
N    siTD_T     *sitd, *sitd_pre, *sp;
N    uint32_t   frnidx;
N
N    DISABLE_EHCI_IRQ();
X    sysDisableInterrupt(EHCI_IRQn);
N
N    while (iso_ep != NULL)                  /* Search all activated iso endpoints         */
X    while (iso_ep != 0)                   
N    {
N        /*--------------------------------------------------------------------------------*/
N        /*  Scan all iTDs                                                                 */
N        /*--------------------------------------------------------------------------------*/
N        itd = iso_ep->itd_list;             /* get the first iTD from iso_ep's iTD list   */
N        itd_pre = NULL;
X        itd_pre = 0;
N        while (itd != NULL)                 /* traverse all iTDs of itd list              */
X        while (itd != 0)                  
N        {
N            if (review_itd(itd))            /* inspect and reclaim iTD                    */
N            {
N                /*------------------------------------------------------------------------*/
N                /*  Remove this iTD from period frame list                                */
N                /*------------------------------------------------------------------------*/
N                frnidx = itd->sched_frnidx;
N                if (_PFList[frnidx] == ITD_HLNK_ITD(itd))
X                if (_PFList[frnidx] == (((uint32_t)(itd) & ~0x1F) | 0x0))
N                {
N                    /* is the first entry, just change to next     */
N                    _PFList[frnidx] = itd->Next_Link;
N                }
N                else
N                {
N                    p = ITD_PTR(_PFList[frnidx]);     /* find the preceding iTD            */
X                    p = ((iTD_T *)((uint32_t)(_PFList[frnidx]) & ~0x1F));      
N                    while ((ITD_PTR(p->Next_Link) != itd) && (p != NULL))
X                    while ((((iTD_T *)((uint32_t)(p->Next_Link) & ~0x1F)) != itd) && (p != 0))
N                    {
N                        p = ITD_PTR(p->Next_Link);
X                        p = ((iTD_T *)((uint32_t)(p->Next_Link) & ~0x1F));
N                    }
N
N                    if (p == NULL)                    /* link list out of control!         */
X                    if (p == 0)                     
N                    {
N                        USB_error("An iTD lost refernece to periodic frame list! 0x%x -> %d\n", (int)itd, frnidx);
X                        sysprintf("An iTD lost refernece to periodic frame list! 0x%x -> %d\n", (int)itd, frnidx);
N                    }
N                    else                              /* remove iTD from list              */
N                    {
N                        p->Next_Link = itd->Next_Link;
N                    }
N                }
N
N                /*------------------------------------------------------------------------*/
N                /*  Remove this iTD from iso_ep's iTD list                                */
N                /*------------------------------------------------------------------------*/
N                if (itd_pre == NULL)
X                if (itd_pre == 0)
N                {
N                    iso_ep->itd_list = itd->next;
N                }
N                else
N                {
N                    itd_pre->next = itd->next;
N                }
N                p = itd->next;
N                free_ehci_iTD(itd);
N                itd = p;
N            }
N            else
N            {
N                itd_pre = itd;
N                itd = itd->next;            /* traverse to the next iTD of iTD list       */
N            }
N        }
N
N        /*--------------------------------------------------------------------------------*/
N        /*  Scan all siTDs                                                                */
N        /*--------------------------------------------------------------------------------*/
N        sitd = iso_ep->sitd_list;           /* get the first siTD from iso_ep's siTD list */
N        sitd_pre = NULL;
X        sitd_pre = 0;
N        while (sitd != NULL)                /* traverse all siTDs of sitd list            */
X        while (sitd != 0)                 
N        {
N            if (review_sitd(sitd))          /* inspect and reclaim siTD                   */
N            {
N                /*------------------------------------------------------------------------*/
N                /*  Remove this siTD from period frame list                               */
N                /*------------------------------------------------------------------------*/
N                frnidx = sitd->sched_frnidx;
N                if (_PFList[frnidx] == SITD_HLNK_SITD(sitd))
X                if (_PFList[frnidx] == (((uint32_t)(sitd) & ~0x1F) | 0x4))
N                {
N                    /* is the first entry, just change to next     */
N                    _PFList[frnidx] = sitd->Next_Link;
N                }
N                else
N                {
N                    sp = SITD_PTR(_PFList[frnidx]);   /* find the preceding siTD           */
X                    sp = ((siTD_T *)((uint32_t)(_PFList[frnidx]) & ~0x1F));    
N                    while ((SITD_PTR(sp->Next_Link) != sitd) && (sp != NULL))
X                    while ((((siTD_T *)((uint32_t)(sp->Next_Link) & ~0x1F)) != sitd) && (sp != 0))
N                    {
N                        sp = SITD_PTR(sp->Next_Link);
X                        sp = ((siTD_T *)((uint32_t)(sp->Next_Link) & ~0x1F));
N                    }
N
N                    if (sp == NULL)                   /* link list out of control!         */
X                    if (sp == 0)                    
N                    {
N                        USB_error("An siTD lost reference to periodic frame list! 0x%x -> %d\n", (int)sitd, frnidx);
X                        sysprintf("An siTD lost reference to periodic frame list! 0x%x -> %d\n", (int)sitd, frnidx);
N                    }
N                    else                              /* remove iTD from list              */
N                    {
N                        sp->Next_Link = sitd->Next_Link;
N                    }
N                }
N
N                /*------------------------------------------------------------------------*/
N                /*  Remove this siTD from iso_ep's siTD list                              */
N                /*------------------------------------------------------------------------*/
N                if (sitd_pre == NULL)
X                if (sitd_pre == 0)
N                {
N                    iso_ep->sitd_list = sitd->next;
N                }
N                else
N                {
N                    sitd_pre->next = sitd->next;
N                }
N                sp = sitd->next;
N                free_ehci_siTD(sitd);
N                sitd = sp;
N            }
N            else
N            {
N                sitd_pre = sitd;
N                sitd = sitd->next;           /* traverse to the next siTD of siTD list     */
N            }
N        }
N
N        iso_ep = iso_ep->next;
N    }
N
N    ENABLE_EHCI_IRQ();
X    sysEnableInterrupt(EHCI_IRQn);
N}
N
N
Nstatic void  write_itd_info(UTR_T *utr, iTD_T *itd)
N{
N    UDEV_T     *udev = utr->udev;
N    EP_INFO_T  *ep = utr->ep;               /* reference to isochronous endpoint          */
N    uint32_t   buff_page_addr;
N    int        i;
N
N    buff_page_addr = itd->buff_base & 0xFFFFF000;     /* 4K page                          */
N
N    for (i = 0; i < 7; i++)
N    {
N        itd->Bptr[i] = buff_page_addr + (0x1000 * i);
N    }
N    /* EndPtr  R  Device Address        */
N    itd->Bptr[0] |= (udev->dev_num) | ((ep->bEndpointAddress & 0xF) << ITD_EP_NUM_Pos);
X    itd->Bptr[0] |= (udev->dev_num) | ((ep->bEndpointAddress & 0xF) << 8);
N    itd->Bptr[1] |= ep->wMaxPacketSize;               /* Maximum Packet Size              */
N
N    if ((ep->bEndpointAddress & EP_ADDR_DIR_MASK) == EP_ADDR_DIR_IN) /* I/O               */
X    if ((ep->bEndpointAddress & 0x80) == 0x80)  
N        itd->Bptr[1] |= ITD_DIR_IN;
X        itd->Bptr[1] |= (1<<11);
N    else
N        itd->Bptr[1] |= ITD_DIR_OUT;
X        itd->Bptr[1] |= (0<<11);
N
N    itd->Bptr[2] |= (ep->wMaxPacketSize + 1023)/1024;                /* Mult              */
N}
N
Nstatic void  write_itd_micro_frame(UTR_T *utr, int fidx, iTD_T *itd, int mf)
N{
N    uint32_t   buff_addr;
N
N    buff_addr = (uint32_t)(utr->iso_buff[fidx]); /* xfer buffer start address of this frame */
N
N    itd->Transaction[mf] = ITD_STATUS_ACTIVE |                                            /* Status */
X    itd->Transaction[mf] = (0x80000000UL) |                                             
N                           ((utr->iso_xlen[fidx] & 0xFFF) << ITD_XLEN_Pos) |              /* Transaction Length */
X                           ((utr->iso_xlen[fidx] & 0xFFF) << 16) |               
N                           ((buff_addr & 0xFFFFF000) - (itd->buff_base & 0xFFFFF000)) |   /* PG */
N                           (buff_addr & 0xFFF);                                           /* Transaction offset */
N}
N
N
Nstatic void remove_iso_ep_from_list(ISO_EP_T *iso_ep)
N{
N    ISO_EP_T  *p;
N
N    if (iso_ep_list == iso_ep)
N    {
N        iso_ep_list = iso_ep->next;         /* it's the first entry, remove it            */
N        return;
N    }
N
N    p = iso_ep_list;                        /* find the previous entry of iso_ep          */
N    while (p->next != NULL)
X    while (p->next != 0)
N    {
N        if (p->next == iso_ep)
N        {
N            break;
N        }
N        p = p->next;
N    }
N
N    if (p->next == NULL)
X    if (p->next == 0)
N    {
N        return;                             /* not found                                  */
N    }
N    p->next = iso_ep->next;                 /* remove iso_ep from list                    */
N}
N
N
Nstatic __inline void  add_itd_to_iso_ep(ISO_EP_T *iso_ep, iTD_T *itd)
N{
N    iTD_T   *p;
N
N    itd->next = NULL;
X    itd->next = 0;
N
N    if (iso_ep->itd_list == NULL)
X    if (iso_ep->itd_list == 0)
N    {
N        iso_ep->itd_list = itd;
N        return;
N    }
N
N    /*
N     * Find the tail entry of iso_ep->itd_list
N     */
N    p = iso_ep->itd_list;
N    while (p->next != NULL)
X    while (p->next != 0)
N    {
N        p = p->next;
N    }
N    p->next = itd;
N}
N
Nint ehci_iso_xfer(UTR_T *utr)
N{
N    EP_INFO_T  *ep = utr->ep;               /* reference to isochronous endpoint          */
N    ISO_EP_T   *iso_ep;                     /* software iso endpoint descriptor           */
N    iTD_T      *itd, *itd_next, *itd_list = NULL;
X    iTD_T      *itd, *itd_next, *itd_list = 0;
N    int        i, itd_cnt;
N    int        trans_mask;                  /* bit mask of used xfer in an iTD            */
N    int        fidx;                        /* index to the 8 iso frames of UTR           */
N    int        interval;                    /* frame interval of iTD                      */
N
N    if (ep->hw_pipe != NULL)
X    if (ep->hw_pipe != 0)
N    {
N        iso_ep = (ISO_EP_T *)ep->hw_pipe;   /* get reference of the isochronous endpoint  */
N
N        if (utr->bIsoNewSched)
N            iso_ep->next_frame = (((_ehci->UFINDR + (EHCI_ISO_DELAY * 8)) & HSUSBH_UFINDR_FI_Msk) >> 3) & 0x3FF;
X            iso_ep->next_frame = (((_ehci->UFINDR + (2 * 8)) & (0x3ffful << (0))) >> 3) & 0x3FF;
N    }
N    else
N    {
N        /* first time transfer of this iso endpoint   */
N        iso_ep = usbh_alloc_mem(sizeof(*iso_ep));
N        if (iso_ep == NULL)
X        if (iso_ep == 0)
N            return USBH_ERR_MEMORY_OUT;
X            return -10;
N
N        memset(iso_ep, 0, sizeof(*iso_ep));
N        iso_ep->ep = ep;
N        iso_ep->next_frame = (((_ehci->UFINDR + (EHCI_ISO_DELAY * 8)) & HSUSBH_UFINDR_FI_Msk) >> 3) & 0x3FF;
X        iso_ep->next_frame = (((_ehci->UFINDR + (2 * 8)) & (0x3ffful << (0))) >> 3) & 0x3FF;
N
N        ep->hw_pipe = iso_ep;
N
N        /*
N         *  Add this iso_ep into iso_ep_list
N         */
N        DISABLE_EHCI_IRQ();
X        sysDisableInterrupt(EHCI_IRQn);
N        iso_ep->next = iso_ep_list;
N        iso_ep_list = iso_ep;
N        ENABLE_EHCI_IRQ();
X        sysEnableInterrupt(EHCI_IRQn);
N    }
N
N    if (utr->udev->speed == SPEED_FULL)
N        return ehci_iso_split_xfer(utr, iso_ep);
N
N    /*------------------------------------------------------------------------------------*/
N    /*  Allocate iTDs                                                                     */
N    /*------------------------------------------------------------------------------------*/
N
N    if (ep->bInterval < 2)                  /* transfer interval is 1 micro-frame         */
N    {
N        trans_mask = 0xFF;
N        itd_cnt = 1;                        /* required 1 iTD for one UTR                 */
N        interval = 1;                       /* iTD frame interval of this ednpoint        */
N    }
N    else if (ep->bInterval < 4)             /* transfer interval is 2 micro-frames        */
N    {
N        trans_mask = 0x55;
N        itd_cnt = 2;                        /* required 2 iTDs for one UTR                */
N        interval = 1;                       /* iTD frame interval of this ednpoint        */
N    }
N    else if (ep->bInterval < 8)             /* transfer interval is 4 micro-frames        */
N    {
N        trans_mask = 0x44;
N        itd_cnt = 4;                        /* required 4 iTDs for one UTR                */
N        interval = 1;                       /* iTD frame interval of this ednpoint        */
N    }
N    else if (ep->bInterval < 16)            /* transfer interval is 8 micro-frames        */
N    {
N        trans_mask = 0x08;                  /* there's 1 transfer in one iTD              */
N        itd_cnt = 8;                        /* required 8 iTDs for one UTR                */
N        interval = 1;                       /* iTD frame interval of this ednpoint        */
N    }
N    else if (ep->bInterval < 32)            /* transfer interval is 16 micro-frames       */
N    {
N        trans_mask = 0x10;                  /* there's 1 transfer in one iTD              */
N        itd_cnt = 8;                        /* required 8 iTDs for one UTR                */
N        interval = 2;                       /* iTD frame interval of this ednpoint        */
N    }
N    else if (ep->bInterval < 64)            /* transfer interval is 32 micro-frames       */
N    {
N        trans_mask = 0x02;                  /* there's 1 transfer in one iTD              */
N        itd_cnt = 8;                        /* required 8 iTDs for one UTR                */
N        interval = 4;                       /* iTD frame interval of this ednpoint        */
N    }
N    else                                    /* transfer interval is 64 micro-frames       */
N    {
N        trans_mask = 0x04;                  /* there's 1 transfer in one iTD              */
N        itd_cnt = 8;                        /* required 8 iTDs for one UTR                */
N        interval = 8;                       /* iTD frame interval of this ednpoint        */
N    }
N
N    for (i = 0; i < itd_cnt; i++)           /* allocate all iTDs required by UTR          */
N    {
N        itd = alloc_ehci_iTD();
N        if (itd == NULL)
X        if (itd == 0)
N            goto malloc_failed;
N
N        if (itd_list == NULL)               /* link all iTDs                              */
X        if (itd_list == 0)                
N        {
N            itd_list = itd;
N        }
N        else
N        {
N            itd->next = itd_list;
N            itd_list = itd;
N        }
N    }
N
N    utr->td_cnt = itd_cnt;
N
N    /*------------------------------------------------------------------------------------*/
N    /*  Fill and link all iTDs                                                            */
N    /*------------------------------------------------------------------------------------*/
N
N    utr->iso_sf = iso_ep->next_frame;
N    fidx = 0;                               /* index to UTR iso frmes (total IF_PER_UTR)  */
N
N    for (itd = itd_list; (itd != NULL); )
X    for (itd = itd_list; (itd != 0); )
N    {
N        if (fidx >= IF_PER_UTR)             /* unlikely                                   */
X        if (fidx >= 8)              
N        {
N            USB_error("EHCI driver ITD bug!?\n");
X            sysprintf("EHCI driver ITD bug!?\n");
N            goto malloc_failed;
N        }
N
N        itd->utr = utr;
N        itd->fidx = fidx;                   /* index to UTR's n'th IF_PER_UTR frame       */
N        itd->buff_base = (uint32_t)(utr->iso_buff[fidx]);    /* iTD buffer base is buffer of the first UTR iso frame serviced by this iTD */
N        itd->trans_mask = trans_mask;
N
N        write_itd_info(utr, itd);
N
N        for (i = 0; i < 8; i++)             /* settle xfer into micro-frames              */
N        {
N            if (!(trans_mask & (0x1<<i)))
N            {
N                itd->Transaction[i] = 0;    /* not accesed                                */
N                continue;                   /* not scheduled micro-frame                  */
N            }
N
N            write_itd_micro_frame(utr, fidx, itd, i);
N
N            fidx++;                         /* preceed to next UTR iso frame              */
N
N            if (fidx == IF_PER_UTR)         /* is the last scheduled micro-frame?         */
X            if (fidx == 8)          
N            {
N                /* raise interrupt on completed               */
N                itd->Transaction[i] |= ITD_IOC;
X                itd->Transaction[i] |= (1<<15);
N                break;
N            }
N        }
N
N        itd_next = itd->next;               /* remember the next itd                      */
N
N        // USB_debug("Link iTD 0x%x, %d\n", (int)itd, iso_ep->next_frame);
N        /*
N         *  Link iTD to period frame list
N         */
N        DISABLE_EHCI_IRQ();
X        sysDisableInterrupt(EHCI_IRQn);
N        itd->sched_frnidx = iso_ep->next_frame;       /* remember it for reclamation scan */
N        add_itd_to_iso_ep(iso_ep, itd);               /* add to software itd list         */
N        itd->Next_Link = _PFList[itd->sched_frnidx];  /* keep the next link               */
N        _PFList[itd->sched_frnidx] = ITD_HLNK_ITD(itd);
X        _PFList[itd->sched_frnidx] = (((uint32_t)(itd) & ~0x1F) | 0x0);
N        iso_ep->next_frame = (iso_ep->next_frame + interval) % FL_SIZE;
X        iso_ep->next_frame = (iso_ep->next_frame + interval) % 1024;
N        ENABLE_EHCI_IRQ();
X        sysEnableInterrupt(EHCI_IRQn);
N
N        itd = itd_next;
N    }
N
N    _ehci->UCMDR |= HSUSBH_UCMDR_PSEN_Msk;      /* periodic list enable                   */
X    _ehci->UCMDR |= (0x1ul << (4));       
N    return 0;
N
Nmalloc_failed:
N
N    while (itd_list != NULL)
X    while (itd_list != 0)
N    {
N        itd = itd_list;
N        itd_list = itd->next;
N        free_ehci_iTD(itd);
N    }
N    return USBH_ERR_MEMORY_OUT;
X    return -10;
N}
N
Nstatic __inline void  add_sitd_to_iso_ep(ISO_EP_T *iso_ep, siTD_T *sitd)
N{
N    siTD_T   *p;
N
N    sitd->next = NULL;
X    sitd->next = 0;
N
N    if (iso_ep->sitd_list == NULL)
X    if (iso_ep->sitd_list == 0)
N    {
N        iso_ep->sitd_list = sitd;
N        return;
N    }
N
N    /*
N     * Find the tail entry of iso_ep->itd_list
N     */
N    p = iso_ep->sitd_list;
N    while (p->next != NULL)
X    while (p->next != 0)
N    {
N        p = p->next;
N    }
N    p->next = sitd;
N}
N
Nstatic void  write_sitd_info(UTR_T *utr, siTD_T *sitd)
N{
N    UDEV_T     *udev = utr->udev;
N    EP_INFO_T  *ep = utr->ep;               /* reference to isochronous endpoint          */
N    uint32_t   buff_page_addr;
N    int        xlen = utr->iso_xlen[sitd->fidx];
N    int        scnt;
N
N    sitd->Chrst = (udev->port_num << SITD_PORT_NUM_Pos) |
X    sitd->Chrst = (udev->port_num << 24) |
N                  (udev->parent->iface->udev->dev_num << SITD_HUB_ADDR_Pos) |
X                  (udev->parent->iface->udev->dev_num << 16) |
N                  ((ep->bEndpointAddress & 0xF) << SITD_EP_NUM_Pos) |
X                  ((ep->bEndpointAddress & 0xF) << 8) |
N                  (udev->dev_num << SITD_DEV_ADDR_Pos);
X                  (udev->dev_num << 0);
N
N    buff_page_addr = ((uint32_t)utr->iso_buff[sitd->fidx]) & 0xFFFFF000;
N    sitd->Bptr[0] = (uint32_t)(utr->iso_buff[sitd->fidx]);
N    sitd->Bptr[1] = buff_page_addr + 0x1000;
N
N    scnt = (xlen + 187) / 188;
N
N    if ((ep->bEndpointAddress & EP_ADDR_DIR_MASK) == EP_ADDR_DIR_IN)   /* I/O               */
X    if ((ep->bEndpointAddress & 0x80) == 0x80)    
N    {
N        sitd->Chrst |= SITD_XFER_IN;
X        sitd->Chrst |= (1UL<<31);
N        sitd->Sched = (1 << (scnt + 2)) - 1;
N        sitd->Sched = (sitd->Sched << 10) | 0x1;
N        //sitd->Sched <<= 1;
N    }
N    else
N    {
N        sitd->Chrst |= SITD_XFER_OUT;
X        sitd->Chrst |= (0UL<<31);
N        sitd->Sched = sitd_OUT_Smask[scnt-1];
N        if (scnt > 1)
N        {
N            sitd->Bptr[1] |= (0x1 << 3);        /* Transaction position (TP)  01b: Begin  */
N        }
N        sitd->Bptr[1] |= scnt;                  /* Transaction count (T-Count)            */
N    }
N
N    if (sitd->fidx == IF_PER_UTR)
X    if (sitd->fidx == 8)
N    {
N        sitd->Sched |= SITD_IOC;
X        sitd->Sched |= (1UL<<31);
N    }
N
N    sitd->StsCtrl = (xlen << SITD_XFER_CNT_Pos) | SITD_STATUS_ACTIVE;
X    sitd->StsCtrl = (xlen << 16) | 0x80;
N
N    sitd->BackLink = SITD_LIST_END;
X    sitd->BackLink = 0x1;
N}
N
N
Nstatic void ehci_sitd_adjust_schedule(siTD_T *sitd)
N{
N    siTD_T     *hlink = (siTD_T  *)_PFList[sitd->sched_frnidx];
N    uint32_t   uframe_mask = 0x00;
N
N    while (hlink && !HLINK_IS_TERMINATED(hlink) && HLINK_IS_SITD(hlink))
X    while (hlink && !(((uint32_t)(hlink) & 0x1) ? 1 : 0) && ((((uint32_t)(hlink) & 0x6) == 0x4) ? 1 : 0))
N    {
N        hlink = SITD_PTR(hlink);
X        hlink = ((siTD_T *)((uint32_t)(hlink) & ~0x1F));
N        if (hlink != sitd)
N        {
N            if ((hlink->Chrst & SITD_XFER_IO_Msk) == SITD_XFER_IN)
X            if ((hlink->Chrst & (1UL<<31)) == (1UL<<31))
N            {
N                uframe_mask |= (hlink->Sched & 0xFF);         /* mark micro-frames used by IN S-mask   */
N                uframe_mask |= ((hlink->Sched >> 8) & 0xFF);  /* mark micro-frames used by IN C-mask   */
N            }
N            else
N            {
N                uframe_mask |= (hlink->Sched & 0xFF);         /* mark micro-frames used by OUT S-mask  */
N            }
N        }
N        hlink = SITD_PTR(hlink->Next_Link);
X        hlink = ((siTD_T *)((uint32_t)(hlink->Next_Link) & ~0x1F));
N    }
N
N    uframe_mask = uframe_mask | (uframe_mask << 8);           /* mark both S-mask and C-mask           */
N
N    if (uframe_mask)
N    {
N        /*
N         *  Shift afterward one micro-frame until no conflicts.
N         */
N        while (1)
N        {
N            if (sitd->Sched & uframe_mask)
N            {
N                sitd->Sched = (sitd->Sched & 0xFFFF0000) | ((sitd->Sched << 1) & 0xFFFF);
N            }
N            else
N            {
N                break;                      /* no conflit, done.                          */
N            }
N        }
N    }
N}
N
N
Nstatic int ehci_iso_split_xfer(UTR_T *utr, ISO_EP_T *iso_ep)
N{
N    EP_INFO_T  *ep = utr->ep;               /* reference to isochronous endpoint          */
N    siTD_T     *sitd, *sitd_next, *sitd_list = NULL;
X    siTD_T     *sitd, *sitd_next, *sitd_list = 0;
N    int        i;
N    int        fidx;                        /* index to the 8 iso frames of UTR           */
N
N    if (utr->udev->parent == NULL)
X    if (utr->udev->parent == 0)
N    {
N        USB_error("siso xfer - parent lost!\n");
X        sysprintf("siso xfer - parent lost!\n");
N        return USBH_ERR_INVALID_PARAM;
X        return -105;
N    }
N
N    /*------------------------------------------------------------------------------------*/
N    /*  Allocate siTDs                                                                    */
N    /*------------------------------------------------------------------------------------*/
N    for (i = 0; i < IF_PER_UTR; i++)        /* allocate all siTDs required by UTR         */
X    for (i = 0; i < 8; i++)         
N    {
N        sitd = alloc_ehci_siTD();
N        if (sitd == NULL)
X        if (sitd == 0)
N            goto malloc_failed;
N
N        if (sitd_list == NULL)               /* link all siTDs                             */
X        if (sitd_list == 0)                
N        {
N            sitd_list = sitd;
N        }
N        else
N        {
N            sitd->next = sitd_list;
N            sitd_list = sitd;
N        }
N    }
N
N    utr->td_cnt = IF_PER_UTR;
X    utr->td_cnt = 8;
N
N    /*------------------------------------------------------------------------------------*/
N    /*  Fill and link all siTDs                                                           */
N    /*------------------------------------------------------------------------------------*/
N
N    utr->iso_sf = iso_ep->next_frame;
N    fidx = 0;                               /* index to UTR iso frmes (total IF_PER_UTR)  */
N
N    for (sitd = sitd_list; (sitd != NULL); fidx++)
X    for (sitd = sitd_list; (sitd != 0); fidx++)
N    {
N        if (fidx >= IF_PER_UTR)             /* unlikely                                   */
X        if (fidx >= 8)              
N        {
N            USB_error("EHCI driver siTD bug!?\n");
X            sysprintf("EHCI driver siTD bug!?\n");
N            goto malloc_failed;
N        }
N
N        sitd->utr = utr;
N        sitd->fidx = fidx;                   /* index to UTR's n'th IF_PER_UTR frame       */
N
N        write_sitd_info(utr, sitd);
N
N        sitd_next = sitd->next;              /* remember the next itd                      */
N
N        // USB_debug("Link iTD 0x%x, %d\n", (int)itd, iso_ep->next_frame);
N        /*
N         *  Link iTD to period frame list
N         */
N        sitd->sched_frnidx = iso_ep->next_frame;      /* remember it for reclamation scan */
N        DISABLE_EHCI_IRQ();
X        sysDisableInterrupt(EHCI_IRQn);
N        ehci_sitd_adjust_schedule(sitd);
N        add_sitd_to_iso_ep(iso_ep, sitd);             /* add to software itd list         */
N        sitd->Next_Link = _PFList[sitd->sched_frnidx];/* keep the next link               */
N        _PFList[sitd->sched_frnidx] = SITD_HLNK_SITD(sitd);
X        _PFList[sitd->sched_frnidx] = (((uint32_t)(sitd) & ~0x1F) | 0x4);
N        iso_ep->next_frame = (iso_ep->next_frame + ep->bInterval) % FL_SIZE;
X        iso_ep->next_frame = (iso_ep->next_frame + ep->bInterval) % 1024;
N        ENABLE_EHCI_IRQ();
X        sysEnableInterrupt(EHCI_IRQn);
N
N        sitd = sitd_next;
N    }
N
N    _ehci->UCMDR |= HSUSBH_UCMDR_PSEN_Msk;      /* periodic list enable                   */
X    _ehci->UCMDR |= (0x1ul << (4));       
N    return 0;
N
Nmalloc_failed:
N
N    while (sitd_list != NULL)
X    while (sitd_list != 0)
N    {
N        sitd = sitd_list;
N        sitd_list = sitd->next;
N        free_ehci_siTD(sitd);
N    }
N    return USBH_ERR_MEMORY_OUT;
X    return -10;
N}
N
N/*
N *  If it's an isochronous endpoint, quit current trasnfer via UTR or hardware EP.
N */
Nint ehci_quit_iso_xfer(UTR_T *utr, EP_INFO_T *ep)
N{
N    ISO_EP_T   *iso_ep;
N    iTD_T      *itd, *itd_next, *p;
N    uint32_t   frnidx;
N    uint32_t   now_frame;
N
N    if (ep == NULL)
X    if (ep == 0)
N    {
N        if (utr == NULL)
X        if (utr == 0)
N            return USBH_ERR_NOT_FOUND;
X            return -106;
N
N        if (utr->ep == NULL)
X        if (utr->ep == 0)
N            return USBH_ERR_NOT_FOUND;
X            return -106;
N
N        ep = utr->ep;
N    }
N
N    if ((ep->bmAttributes & EP_ATTR_TT_MASK) != EP_ATTR_TT_ISO)
X    if ((ep->bmAttributes & 0x03) != 0x01)
N        return USBH_ERR_NOT_FOUND;          /* not isochronous endpoint                   */
X        return -106;           
N
N    /*------------------------------------------------------------------------------------*/
N    /*  It's an iso endpoint. Remove it as required.                                      */
N    /*------------------------------------------------------------------------------------*/
N    iso_ep = iso_ep_list;
N    while (iso_ep != NULL)                  /* Search all activated iso endpoints         */
X    while (iso_ep != 0)                   
N    {
N        if (iso_ep->ep == ep)
N            break;
N        iso_ep = iso_ep->next;
N    }
N    if (iso_ep == NULL)
X    if (iso_ep == 0)
N        return 0;                           /* should have been removed                   */
N
N    itd = iso_ep->itd_list;                 /* get the first iTD from iso_ep's iTD list   */
N
N    while (itd != NULL)                     /* traverse all iTDs of itd list              */
X    while (itd != 0)                      
N    {
N        itd_next = itd->next;               /* remember the next iTD                      */
N        utr = itd->utr;
N
N        /*--------------------------------------------------------------------------------*/
N        /*  Remove this iTD from period frame list                                        */
N        /*--------------------------------------------------------------------------------*/
N        frnidx = itd->sched_frnidx;
N
N        /*
N         *  Prevent to race with Host Controller. If the iTD to be removed is located in
N         *  current or next frame, wait until HC passed through it.
N         */
N        while (1)
N        {
N            now_frame = (_ehci->UFINDR >> 3) & 0x3FF;
N            if ((now_frame == frnidx) || (((now_frame+1)%1024) == frnidx))
N                continue;
N            break;
N        }
N
N        if (_PFList[frnidx] == ITD_HLNK_ITD(itd))
X        if (_PFList[frnidx] == (((uint32_t)(itd) & ~0x1F) | 0x0))
N        {
N            /* is the first entry, just change to next     */
N            _PFList[frnidx] = itd->Next_Link;
N        }
N        else
N        {
N            /*
N             * find the preceding iTD
N             */
N            p = ITD_PTR(_PFList[frnidx]);   /* find the preceding iTD                     */
X            p = ((iTD_T *)((uint32_t)(_PFList[frnidx]) & ~0x1F));    
N            while ((ITD_PTR(p->Next_Link) != itd) && (p != NULL))
X            while ((((iTD_T *)((uint32_t)(p->Next_Link) & ~0x1F)) != itd) && (p != 0))
N            {
N                p = ITD_PTR(p->Next_Link);
X                p = ((iTD_T *)((uint32_t)(p->Next_Link) & ~0x1F));
N            }
N
N            if (p == NULL)                  /* link list out of control!                  */
X            if (p == 0)                   
N            {
N                USB_error("ehci_quit_iso_xfer - An iTD lost reference to periodic frame list! 0x%x on %d\n", (int)itd, frnidx);
X                sysprintf("ehci_quit_iso_xfer - An iTD lost reference to periodic frame list! 0x%x on %d\n", (int)itd, frnidx);
N            }
N            else                            /* remove iTD from list                       */
N            {
N                p->Next_Link = itd->Next_Link;
N            }
N        }
N
N        utr->td_cnt--;
N        if (utr->td_cnt == 0)
N        {
N            /* All iTD of this UTR done                   */
N            utr->bIsTransferDone = 1;
N            if (utr->func)
N                utr->func(utr);
N            utr->status = USBH_ERR_ABORT;
X            utr->status = -205;
N        }
N
N        free_ehci_iTD(itd);
N        itd = itd_next;
N    }
N
N    /*
N     *  Remove iso_ep from iso_ep_list
N     */
N    remove_iso_ep_from_list(iso_ep);
N    usbh_free_mem(iso_ep, sizeof(*iso_ep));      /* free this iso_ep                      */
N    ep->hw_pipe = NULL;
X    ep->hw_pipe = 0;
N
N    if (iso_ep_list == NULL)
X    if (iso_ep_list == 0)
N        _ehci->UCMDR &= ~HSUSBH_UCMDR_PSEN_Msk;
X        _ehci->UCMDR &= ~(0x1ul << (4));
N
N    return 0;
N}
N
N
N/// @endcond HIDDEN_SYMBOLS
N
N/*** (C) COPYRIGHT 2017 Nuvoton Technology Corp. ***/
