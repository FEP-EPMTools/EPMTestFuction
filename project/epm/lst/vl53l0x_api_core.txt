; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\vl53l0x_api_core.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\vl53l0x_api_core.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\vl53l0x_api_core.crf src\UserDrv\vl53l0x\core\src\vl53l0x_api_core.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  VL53L0X_reverse_bytes PROC
;;;43     
;;;44     VL53L0X_Error VL53L0X_reverse_bytes(uint8_t *data, uint32_t size)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;45     {
000004  e1a02000          MOV      r2,r0
000008  e1a03001          MOV      r3,r1
;;;46     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00000c  e3a00000          MOV      r0,#0
;;;47     	uint8_t tempData;
;;;48     	uint32_t mirrorIndex;
;;;49     	uint32_t middle = size/2;
000010  e1a050a3          LSR      r5,r3,#1
;;;50     	uint32_t index;
;;;51     
;;;52     	for (index = 0; index < middle; index++) {
000014  e3a01000          MOV      r1,#0
000018  ea000006          B        |L1.56|
                  |L1.28|
;;;53     		mirrorIndex		 = size - index - 1;
00001c  e0436001          SUB      r6,r3,r1
000020  e246c001          SUB      r12,r6,#1
;;;54     		tempData		 = data[index];
000024  e7d24001          LDRB     r4,[r2,r1]
;;;55     		data[index]		 = data[mirrorIndex];
000028  e7d2600c          LDRB     r6,[r2,r12]
00002c  e7c26001          STRB     r6,[r2,r1]
;;;56     		data[mirrorIndex] = tempData;
000030  e7c2400c          STRB     r4,[r2,r12]
000034  e2811001          ADD      r1,r1,#1              ;52
                  |L1.56|
000038  e1510005          CMP      r1,r5                 ;52
00003c  3afffff6          BCC      |L1.28|
;;;57     	}
;;;58     	return Status;
;;;59     }
000040  e8bd8070          POP      {r4-r6,pc}
;;;60     
                          ENDP

                  VL53L0X_measurement_poll_for_completion PROC
;;;61     VL53L0X_Error VL53L0X_measurement_poll_for_completion(VL53L0X_DEV Dev)
000044  e92d40f8          PUSH     {r3-r7,lr}
;;;62     {
000048  e1a06000          MOV      r6,r0
;;;63     	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00004c  e3a04000          MOV      r4,#0
;;;64     	uint8_t NewDataReady = 0;
000050  e3a00000          MOV      r0,#0
000054  e58d0000          STR      r0,[sp,#0]
;;;65     	uint32_t LoopNb;
;;;66     
;;;67     	LOG_FUNCTION_START("");
;;;68     
;;;69     	LoopNb = 0;
000058  e3a05000          MOV      r5,#0
;;;70     
;;;71     	do {
00005c  e1a00000          MOV      r0,r0
                  |L1.96|
;;;72     		Status = VL53L0X_GetMeasurementDataReady(Dev, &NewDataReady);
000060  e1a0100d          MOV      r1,sp
000064  e1a00006          MOV      r0,r6
000068  ebfffffe          BL       VL53L0X_GetMeasurementDataReady
00006c  e1a04000          MOV      r4,r0
;;;73     		if (Status != 0)
000070  e3540000          CMP      r4,#0
000074  0a000000          BEQ      |L1.124|
;;;74     			break; /* the error is set */
000078  ea00000b          B        |L1.172|
                  |L1.124|
;;;75     
;;;76     		if (NewDataReady == 1)
00007c  e5dd0000          LDRB     r0,[sp,#0]
000080  e3500001          CMP      r0,#1
000084  1a000000          BNE      |L1.140|
;;;77     			break; /* done note that status == 0 */
000088  ea000007          B        |L1.172|
                  |L1.140|
;;;78     
;;;79     		LoopNb++;
00008c  e2855001          ADD      r5,r5,#1
;;;80     		if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP) {
000090  e3550019          CMP      r5,#0x19
000094  3a000001          BCC      |L1.160|
;;;81     			Status = VL53L0X_ERROR_TIME_OUT;
000098  e3e04006          MVN      r4,#6
;;;82     			break;
00009c  ea000002          B        |L1.172|
                  |L1.160|
;;;83     		}
;;;84     
;;;85     		VL53L0X_PollingDelay(Dev);
0000a0  e1a00006          MOV      r0,r6
0000a4  ebfffffe          BL       VL53L0X_PollingDelay
;;;86     	} while (1);
0000a8  eaffffec          B        |L1.96|
                  |L1.172|
0000ac  e1a00000          MOV      r0,r0                 ;74
;;;87     
;;;88     	LOG_FUNCTION_END(Status);
;;;89     
;;;90     	return Status;
0000b0  e1a00004          MOV      r0,r4
;;;91     }
0000b4  e8bd80f8          POP      {r3-r7,pc}
;;;92     
                          ENDP

                  VL53L0X_decode_vcsel_period PROC
;;;93     
;;;94     uint8_t VL53L0X_decode_vcsel_period(uint8_t vcsel_period_reg)
0000b8  e1a01000          MOV      r1,r0
;;;95     {
;;;96     	/*!
;;;97     	 * Converts the encoded VCSEL period register value into the real
;;;98     	 * period in PLL clocks
;;;99     	 */
;;;100    
;;;101    	uint8_t vcsel_period_pclks = 0;
0000bc  e3a00000          MOV      r0,#0
;;;102    
;;;103    	vcsel_period_pclks = (vcsel_period_reg + 1) << 1;
0000c0  e2812001          ADD      r2,r1,#1
0000c4  e1a02c82          LSL      r2,r2,#25
0000c8  e1a00c22          LSR      r0,r2,#24
;;;104    
;;;105    	return vcsel_period_pclks;
;;;106    }
0000cc  e12fff1e          BX       lr
;;;107    
                          ENDP

                  VL53L0X_encode_vcsel_period PROC
;;;108    uint8_t VL53L0X_encode_vcsel_period(uint8_t vcsel_period_pclks)
0000d0  e1a01000          MOV      r1,r0
;;;109    {
;;;110    	/*!
;;;111    	 * Converts the encoded VCSEL period register value into the real period
;;;112    	 * in PLL clocks
;;;113    	 */
;;;114    
;;;115    	uint8_t vcsel_period_reg = 0;
0000d4  e3a00000          MOV      r0,#0
;;;116    
;;;117    	vcsel_period_reg = (vcsel_period_pclks >> 1) - 1;
0000d8  e3a02001          MOV      r2,#1
0000dc  e06220c1          RSB      r2,r2,r1,ASR #1
0000e0  e20200ff          AND      r0,r2,#0xff
;;;118    
;;;119    	return vcsel_period_reg;
;;;120    }
0000e4  e12fff1e          BX       lr
;;;121    
                          ENDP

                  VL53L0X_isqrt PROC
;;;122    
;;;123    uint32_t VL53L0X_isqrt(uint32_t num)
0000e8  e1a02000          MOV      r2,r0
;;;124    {
;;;125    	/*
;;;126    	 * Implements an integer square root
;;;127    	 *
;;;128    	 * From: http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
;;;129    	 */
;;;130    
;;;131    	uint32_t  res = 0;
0000ec  e3a00000          MOV      r0,#0
;;;132    	uint32_t  bit = 1 << 30;
0000f0  e3a01101          MOV      r1,#0x40000000
;;;133    	/* The second-to-top bit is set:
;;;134    	 *	1 << 14 for 16-bits, 1 << 30 for 32 bits */
;;;135    
;;;136    	 /* "bit" starts at the highest power of four <= the argument. */
;;;137    	while (bit > num)
0000f4  ea000000          B        |L1.252|
                  |L1.248|
;;;138    		bit >>= 2;
0000f8  e1a01121          LSR      r1,r1,#2
                  |L1.252|
0000fc  e1510002          CMP      r1,r2                 ;137
000100  8afffffc          BHI      |L1.248|
;;;139    
;;;140    
;;;141    	while (bit != 0) {
000104  ea000008          B        |L1.300|
                  |L1.264|
;;;142    		if (num >= res + bit) {
000108  e0803001          ADD      r3,r0,r1
00010c  e1530002          CMP      r3,r2
000110  8a000003          BHI      |L1.292|
;;;143    			num -= res + bit;
000114  e0803001          ADD      r3,r0,r1
000118  e0422003          SUB      r2,r2,r3
;;;144    			res = (res >> 1) + bit;
00011c  e08100a0          ADD      r0,r1,r0,LSR #1
000120  ea000000          B        |L1.296|
                  |L1.292|
;;;145    		} else
;;;146    			res >>= 1;
000124  e1a000a0          LSR      r0,r0,#1
                  |L1.296|
;;;147    
;;;148    		bit >>= 2;
000128  e1a01121          LSR      r1,r1,#2
                  |L1.300|
00012c  e3510000          CMP      r1,#0                 ;141
000130  1afffff4          BNE      |L1.264|
;;;149    	}
;;;150    
;;;151    	return res;
;;;152    }
000134  e12fff1e          BX       lr
;;;153    
                          ENDP

                  VL53L0X_quadrature_sum PROC
;;;154    
;;;155    uint32_t VL53L0X_quadrature_sum(uint32_t a, uint32_t b)
000138  e92d4070          PUSH     {r4-r6,lr}
;;;156    {
00013c  e1a05000          MOV      r5,r0
000140  e1a04001          MOV      r4,r1
;;;157    	/*
;;;158    	 * Implements a quadrature sum
;;;159    	 *
;;;160    	 * rea = sqrt(a^2 + b^2)
;;;161    	 *
;;;162    	 * Trap overflow case max input value is 65535 (16-bit value)
;;;163    	 * as internal calc are 32-bit wide
;;;164    	 *
;;;165    	 * If overflow then seta output to maximum
;;;166    	 */
;;;167    	uint32_t  res = 0;
000144  e3a06000          MOV      r6,#0
;;;168    
;;;169    	if (a > 65535 || b > 65535)
000148  e3550801          CMP      r5,#0x10000
00014c  2a000001          BCS      |L1.344|
000150  e3540801          CMP      r4,#0x10000
000154  3a000001          BCC      |L1.352|
                  |L1.344|
;;;170    		res = 65535;
000158  e59f6ee4          LDR      r6,|L1.4164|
00015c  ea000003          B        |L1.368|
                  |L1.352|
;;;171    	else
;;;172    		res = VL53L0X_isqrt(a * a + b * b);
000160  e0020595          MUL      r2,r5,r5
000164  e0202494          MLA      r0,r4,r4,r2
000168  ebfffffe          BL       VL53L0X_isqrt
00016c  e1a06000          MOV      r6,r0
                  |L1.368|
;;;173    
;;;174    	return res;
000170  e1a00006          MOV      r0,r6
;;;175    }
000174  e8bd8070          POP      {r4-r6,pc}
;;;176    
                          ENDP

                  VL53L0X_device_read_strobe PROC
;;;299    
;;;179    VL53L0X_Error VL53L0X_device_read_strobe(VL53L0X_DEV Dev)
000178  e92d40f8          PUSH     {r3-r7,lr}
;;;180    {
00017c  e1a06000          MOV      r6,r0
;;;181    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000180  e3a04000          MOV      r4,#0
;;;182    	uint8_t strobe;
;;;183    	uint32_t LoopNb;
;;;184    	LOG_FUNCTION_START("");
;;;185        //sysprintf ("VL53L0X_device_read_strobe enter:  Status = 0x%02x\n", Status);
;;;186    	Status |= VL53L0X_WrByte(Dev, 0x83, 0x00);
000184  e3a02000          MOV      r2,#0
000188  e3a01083          MOV      r1,#0x83
00018c  e1a00006          MOV      r0,r6
000190  ebfffffe          BL       VL53L0X_WrByte
000194  e1844000          ORR      r4,r4,r0
;;;187        //sysprintf ("VL53L0X_device_read_strobe enter 2:  Status = 0x%02x\n", Status);
;;;188    	/* polling
;;;189    	 * use timeout to avoid deadlock*/
;;;190    	if (Status == VL53L0X_ERROR_NONE) 
000198  e3540000          CMP      r4,#0
00019c  1a000013          BNE      |L1.496|
;;;191        {
;;;192    		LoopNb = 0;
0001a0  e3a05000          MOV      r5,#0
;;;193    		do {
0001a4  e1a00000          MOV      r0,r0
                  |L1.424|
;;;194    			Status = VL53L0X_RdByte(Dev, 0x83, &strobe);
0001a8  e1a0200d          MOV      r2,sp
0001ac  e3a01083          MOV      r1,#0x83
0001b0  e1a00006          MOV      r0,r6
0001b4  ebfffffe          BL       VL53L0X_RdByte
0001b8  e1a04000          MOV      r4,r0
;;;195    			if ((strobe != 0x00) || Status != VL53L0X_ERROR_NONE)
0001bc  e5dd0000          LDRB     r0,[sp,#0]
0001c0  e3500000          CMP      r0,#0
0001c4  1a000001          BNE      |L1.464|
0001c8  e3540000          CMP      r4,#0
0001cc  0a000000          BEQ      |L1.468|
                  |L1.464|
;;;196    					break;
0001d0  ea000002          B        |L1.480|
                  |L1.468|
;;;197    
;;;198    			LoopNb = LoopNb + 1;
0001d4  e2855001          ADD      r5,r5,#1
;;;199    		} while (LoopNb < VL53L0X_DEFAULT_MAX_LOOP);
0001d8  e3550019          CMP      r5,#0x19
0001dc  3afffff1          BCC      |L1.424|
                  |L1.480|
0001e0  e1a00000          MOV      r0,r0                 ;196
;;;200    
;;;201    		if (LoopNb >= VL53L0X_DEFAULT_MAX_LOOP)
0001e4  e3550019          CMP      r5,#0x19
0001e8  3a000000          BCC      |L1.496|
;;;202    			Status = VL53L0X_ERROR_TIME_OUT;
0001ec  e3e04006          MVN      r4,#6
                  |L1.496|
;;;203    
;;;204    	}
;;;205    
;;;206    	Status |= VL53L0X_WrByte(Dev, 0x83, 0x01);
0001f0  e3a02001          MOV      r2,#1
0001f4  e3a01083          MOV      r1,#0x83
0001f8  e1a00006          MOV      r0,r6
0001fc  ebfffffe          BL       VL53L0X_WrByte
000200  e1844000          ORR      r4,r4,r0
;;;207        //sysprintf ("VL53L0X_device_read_strobe exit:  Status = 0x%02x\n", Status);
;;;208    	LOG_FUNCTION_END(Status);
;;;209    	return Status;
000204  e1a00004          MOV      r0,r4
;;;210    
;;;211    }
000208  e8bd80f8          POP      {r3-r7,pc}
;;;212    
                          ENDP

                  VL53L0X_get_info_from_device PROC
;;;213    VL53L0X_Error VL53L0X_get_info_from_device(VL53L0X_DEV Dev, uint8_t option)
00020c  e92d4ff0          PUSH     {r4-r11,lr}
;;;214    {
000210  e24dd04c          SUB      sp,sp,#0x4c
000214  e1a05000          MOV      r5,r0
000218  e1a07001          MOV      r7,r1
;;;215    
;;;216    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00021c  e3a04000          MOV      r4,#0
;;;217    	uint8_t byte;
;;;218    	uint32_t TmpDWord;
;;;219    	uint8_t ModuleId;
;;;220    	uint8_t Revision;
;;;221    	uint8_t ReferenceSpadCount = 0;
000220  e3a00000          MOV      r0,#0
000224  e58d0038          STR      r0,[sp,#0x38]
;;;222    	uint8_t ReferenceSpadType = 0;
000228  e58d0034          STR      r0,[sp,#0x34]
;;;223    	uint32_t PartUIDUpper = 0;
00022c  e58d0030          STR      r0,[sp,#0x30]
;;;224    	uint32_t PartUIDLower = 0;
000230  e58d002c          STR      r0,[sp,#0x2c]
;;;225    	uint32_t OffsetFixed1104_mm = 0;
000234  e3a0a000          MOV      r10,#0
;;;226    	int16_t OffsetMicroMeters = 0;
000238  e3a0b000          MOV      r11,#0
;;;227    	uint32_t DistMeasTgtFixed1104_mm = 400 << 4;
00023c  e3a00c19          MOV      r0,#0x1900
000240  e58d0028          STR      r0,[sp,#0x28]
;;;228    	uint32_t DistMeasFixed1104_400_mm = 0;
000244  e3a09000          MOV      r9,#0
;;;229    	uint32_t SignalRateMeasFixed1104_400_mm = 0;
000248  e3a00000          MOV      r0,#0
00024c  e58d0024          STR      r0,[sp,#0x24]
;;;230    	char ProductId[19];
;;;231    	char *ProductId_tmp;
;;;232    	uint8_t ReadDataFromDeviceDone;
;;;233    	FixPoint1616_t SignalRateMeasFixed400mmFix = 0;
000250  e58d0008          STR      r0,[sp,#8]
;;;234    	uint8_t NvmRefGoodSpadMap[VL53L0X_REF_SPAD_BUFFER_SIZE];
;;;235    	int i;
;;;236    
;;;237    
;;;238    	LOG_FUNCTION_START("");
;;;239    
;;;240    	ReadDataFromDeviceDone = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
000254  e5d560f0          LDRB     r6,[r5,#0xf0]
;;;241    			ReadDataFromDeviceDone);
;;;242    
;;;243    	/* This access is done only once after that a GetDeviceInfo or
;;;244    	 * datainit is done*/
;;;245    	if (ReadDataFromDeviceDone != 7) {
000258  e3560007          CMP      r6,#7
00025c  0a0001a4          BEQ      |L1.2292|
;;;246    
;;;247    		Status |= VL53L0X_WrByte(Dev, 0x80, 0x01);
000260  e3a02001          MOV      r2,#1
000264  e3a01080          MOV      r1,#0x80
000268  e1a00005          MOV      r0,r5
00026c  ebfffffe          BL       VL53L0X_WrByte
000270  e1844000          ORR      r4,r4,r0
;;;248    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x01);
000274  e3a02001          MOV      r2,#1
000278  e3a010ff          MOV      r1,#0xff
00027c  e1a00005          MOV      r0,r5
000280  ebfffffe          BL       VL53L0X_WrByte
000284  e1844000          ORR      r4,r4,r0
;;;249    		Status |= VL53L0X_WrByte(Dev, 0x00, 0x00);
000288  e3a02000          MOV      r2,#0
00028c  e1a01002          MOV      r1,r2
000290  e1a00005          MOV      r0,r5
000294  ebfffffe          BL       VL53L0X_WrByte
000298  e1844000          ORR      r4,r4,r0
;;;250    
;;;251    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x06);
00029c  e3a02006          MOV      r2,#6
0002a0  e3a010ff          MOV      r1,#0xff
0002a4  e1a00005          MOV      r0,r5
0002a8  ebfffffe          BL       VL53L0X_WrByte
0002ac  e1844000          ORR      r4,r4,r0
;;;252    		Status |= VL53L0X_RdByte(Dev, 0x83, &byte);
0002b0  e28d2048          ADD      r2,sp,#0x48
0002b4  e3a01083          MOV      r1,#0x83
0002b8  e1a00005          MOV      r0,r5
0002bc  ebfffffe          BL       VL53L0X_RdByte
0002c0  e1844000          ORR      r4,r4,r0
;;;253    		Status |= VL53L0X_WrByte(Dev, 0x83, byte|4);
0002c4  e5dd0048          LDRB     r0,[sp,#0x48]
0002c8  e3802004          ORR      r2,r0,#4
0002cc  e3a01083          MOV      r1,#0x83
0002d0  e1a00005          MOV      r0,r5
0002d4  ebfffffe          BL       VL53L0X_WrByte
0002d8  e1844000          ORR      r4,r4,r0
;;;254    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x07);
0002dc  e3a02007          MOV      r2,#7
0002e0  e3a010ff          MOV      r1,#0xff
0002e4  e1a00005          MOV      r0,r5
0002e8  ebfffffe          BL       VL53L0X_WrByte
0002ec  e1844000          ORR      r4,r4,r0
;;;255    		Status |= VL53L0X_WrByte(Dev, 0x81, 0x01);
0002f0  e3a02001          MOV      r2,#1
0002f4  e3a01081          MOV      r1,#0x81
0002f8  e1a00005          MOV      r0,r5
0002fc  ebfffffe          BL       VL53L0X_WrByte
000300  e1844000          ORR      r4,r4,r0
;;;256    
;;;257    		Status |= VL53L0X_PollingDelay(Dev);
000304  e1a00005          MOV      r0,r5
000308  ebfffffe          BL       VL53L0X_PollingDelay
00030c  e1844000          ORR      r4,r4,r0
;;;258    
;;;259    		Status |= VL53L0X_WrByte(Dev, 0x80, 0x01);
000310  e3a02001          MOV      r2,#1
000314  e3a01080          MOV      r1,#0x80
000318  e1a00005          MOV      r0,r5
00031c  ebfffffe          BL       VL53L0X_WrByte
000320  e1844000          ORR      r4,r4,r0
;;;260    
;;;261    		if (((option & 1) == 1) &&
000324  e3170001          TST      r7,#1
000328  0a000044          BEQ      |L1.1088|
;;;262    			((ReadDataFromDeviceDone & 1) == 0)) {
00032c  e3160001          TST      r6,#1
000330  1a000042          BNE      |L1.1088|
;;;263    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x6b);
000334  e3a0206b          MOV      r2,#0x6b
000338  e3a01094          MOV      r1,#0x94
00033c  e1a00005          MOV      r0,r5
000340  ebfffffe          BL       VL53L0X_WrByte
000344  e1844000          ORR      r4,r4,r0
;;;264    			Status |= VL53L0X_device_read_strobe(Dev);
000348  e1a00005          MOV      r0,r5
00034c  ebfffffe          BL       VL53L0X_device_read_strobe
000350  e1844000          ORR      r4,r4,r0
;;;265    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
000354  e28d2044          ADD      r2,sp,#0x44
000358  e3a01090          MOV      r1,#0x90
00035c  e1a00005          MOV      r0,r5
000360  ebfffffe          BL       VL53L0X_RdDWord
000364  e1844000          ORR      r4,r4,r0
;;;266    
;;;267    			ReferenceSpadCount = (uint8_t)((TmpDWord >> 8) & 0x07f);
000368  e3a0107f          MOV      r1,#0x7f
00036c  e59d0044          LDR      r0,[sp,#0x44]
000370  e0010420          AND      r0,r1,r0,LSR #8
000374  e58d0038          STR      r0,[sp,#0x38]
;;;268    			ReferenceSpadType  = (uint8_t)((TmpDWord >> 15) & 0x01);
000378  e3a01001          MOV      r1,#1
00037c  e59d0044          LDR      r0,[sp,#0x44]
000380  e00107a0          AND      r0,r1,r0,LSR #15
000384  e58d0034          STR      r0,[sp,#0x34]
;;;269    
;;;270    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x24);
000388  e3a02024          MOV      r2,#0x24
00038c  e3a01094          MOV      r1,#0x94
000390  e1a00005          MOV      r0,r5
000394  ebfffffe          BL       VL53L0X_WrByte
000398  e1844000          ORR      r4,r4,r0
;;;271    			Status |= VL53L0X_device_read_strobe(Dev);
00039c  e1a00005          MOV      r0,r5
0003a0  ebfffffe          BL       VL53L0X_device_read_strobe
0003a4  e1844000          ORR      r4,r4,r0
;;;272    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
0003a8  e28d2044          ADD      r2,sp,#0x44
0003ac  e3a01090          MOV      r1,#0x90
0003b0  e1a00005          MOV      r0,r5
0003b4  ebfffffe          BL       VL53L0X_RdDWord
0003b8  e1844000          ORR      r4,r4,r0
;;;273    
;;;274    
;;;275    			NvmRefGoodSpadMap[0] = (uint8_t)((TmpDWord >> 24)
0003bc  e59d0044          LDR      r0,[sp,#0x44]
0003c0  e1a00c20          LSR      r0,r0,#24
0003c4  e5cd0000          STRB     r0,[sp,#0]
;;;276    				& 0xff);
;;;277    			NvmRefGoodSpadMap[1] = (uint8_t)((TmpDWord >> 16)
0003c8  e59d0044          LDR      r0,[sp,#0x44]
0003cc  e1a00400          LSL      r0,r0,#8
0003d0  e1a00c20          LSR      r0,r0,#24
0003d4  e5cd0001          STRB     r0,[sp,#1]
;;;278    				& 0xff);
;;;279    			NvmRefGoodSpadMap[2] = (uint8_t)((TmpDWord >> 8)
0003d8  e59d0044          LDR      r0,[sp,#0x44]
0003dc  e1a00800          LSL      r0,r0,#16
0003e0  e1a00c20          LSR      r0,r0,#24
0003e4  e5cd0002          STRB     r0,[sp,#2]
;;;280    				& 0xff);
;;;281    			NvmRefGoodSpadMap[3] = (uint8_t)(TmpDWord & 0xff);
0003e8  e59d0044          LDR      r0,[sp,#0x44]
0003ec  e5cd0003          STRB     r0,[sp,#3]
;;;282    
;;;283    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x25);
0003f0  e3a02025          MOV      r2,#0x25
0003f4  e3a01094          MOV      r1,#0x94
0003f8  e1a00005          MOV      r0,r5
0003fc  ebfffffe          BL       VL53L0X_WrByte
000400  e1844000          ORR      r4,r4,r0
;;;284    			Status |= VL53L0X_device_read_strobe(Dev);
000404  e1a00005          MOV      r0,r5
000408  ebfffffe          BL       VL53L0X_device_read_strobe
00040c  e1844000          ORR      r4,r4,r0
;;;285    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
000410  e28d2044          ADD      r2,sp,#0x44
000414  e3a01090          MOV      r1,#0x90
000418  e1a00005          MOV      r0,r5
00041c  ebfffffe          BL       VL53L0X_RdDWord
000420  e1844000          ORR      r4,r4,r0
;;;286    
;;;287    			NvmRefGoodSpadMap[4] = (uint8_t)((TmpDWord >> 24)
000424  e59d0044          LDR      r0,[sp,#0x44]
000428  e1a00c20          LSR      r0,r0,#24
00042c  e5cd0004          STRB     r0,[sp,#4]
;;;288    				& 0xff);
;;;289    			NvmRefGoodSpadMap[5] = (uint8_t)((TmpDWord >> 16)
000430  e59d0044          LDR      r0,[sp,#0x44]
000434  e1a00400          LSL      r0,r0,#8
000438  e1a00c20          LSR      r0,r0,#24
00043c  e5cd0005          STRB     r0,[sp,#5]
                  |L1.1088|
;;;290    				& 0xff);
;;;291    		}
;;;292    
;;;293    		if (((option & 2) == 2) &&
000440  e2070002          AND      r0,r7,#2
000444  e3500002          CMP      r0,#2
000448  1a0000a0          BNE      |L1.1744|
;;;294    			((ReadDataFromDeviceDone & 2) == 0)) {
00044c  e3160002          TST      r6,#2
000450  1a00009e          BNE      |L1.1744|
;;;295    
;;;296    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x02);
000454  e3a02002          MOV      r2,#2
000458  e3a01094          MOV      r1,#0x94
00045c  e1a00005          MOV      r0,r5
000460  ebfffffe          BL       VL53L0X_WrByte
000464  e1844000          ORR      r4,r4,r0
;;;297    			Status |= VL53L0X_device_read_strobe(Dev);
000468  e1a00005          MOV      r0,r5
00046c  ebfffffe          BL       VL53L0X_device_read_strobe
000470  e1844000          ORR      r4,r4,r0
;;;298    			Status |= VL53L0X_RdByte(Dev, 0x90, &ModuleId);
000474  e28d2040          ADD      r2,sp,#0x40
000478  e3a01090          MOV      r1,#0x90
00047c  e1a00005          MOV      r0,r5
000480  ebfffffe          BL       VL53L0X_RdByte
000484  e1844000          ORR      r4,r4,r0
;;;299    
;;;300    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x7B);
000488  e3a0207b          MOV      r2,#0x7b
00048c  e3a01094          MOV      r1,#0x94
000490  e1a00005          MOV      r0,r5
000494  ebfffffe          BL       VL53L0X_WrByte
000498  e1844000          ORR      r4,r4,r0
;;;301    			Status |= VL53L0X_device_read_strobe(Dev);
00049c  e1a00005          MOV      r0,r5
0004a0  ebfffffe          BL       VL53L0X_device_read_strobe
0004a4  e1844000          ORR      r4,r4,r0
;;;302    			Status |= VL53L0X_RdByte(Dev, 0x90, &Revision);
0004a8  e28d203c          ADD      r2,sp,#0x3c
0004ac  e3a01090          MOV      r1,#0x90
0004b0  e1a00005          MOV      r0,r5
0004b4  ebfffffe          BL       VL53L0X_RdByte
0004b8  e1844000          ORR      r4,r4,r0
;;;303    
;;;304    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x77);
0004bc  e3a02077          MOV      r2,#0x77
0004c0  e3a01094          MOV      r1,#0x94
0004c4  e1a00005          MOV      r0,r5
0004c8  ebfffffe          BL       VL53L0X_WrByte
0004cc  e1844000          ORR      r4,r4,r0
;;;305    			Status |= VL53L0X_device_read_strobe(Dev);
0004d0  e1a00005          MOV      r0,r5
0004d4  ebfffffe          BL       VL53L0X_device_read_strobe
0004d8  e1844000          ORR      r4,r4,r0
;;;306    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
0004dc  e28d2044          ADD      r2,sp,#0x44
0004e0  e3a01090          MOV      r1,#0x90
0004e4  e1a00005          MOV      r0,r5
0004e8  ebfffffe          BL       VL53L0X_RdDWord
0004ec  e1844000          ORR      r4,r4,r0
;;;307    
;;;308    			ProductId[0] = (char)((TmpDWord >> 25) & 0x07f);
0004f0  e3a0107f          MOV      r1,#0x7f
0004f4  e59d0044          LDR      r0,[sp,#0x44]
0004f8  e0010ca0          AND      r0,r1,r0,LSR #25
0004fc  e5cd0010          STRB     r0,[sp,#0x10]
;;;309    			ProductId[1] = (char)((TmpDWord >> 18) & 0x07f);
000500  e59d0044          LDR      r0,[sp,#0x44]
000504  e0010920          AND      r0,r1,r0,LSR #18
000508  e5cd0011          STRB     r0,[sp,#0x11]
;;;310    			ProductId[2] = (char)((TmpDWord >> 11) & 0x07f);
00050c  e59d0044          LDR      r0,[sp,#0x44]
000510  e00105a0          AND      r0,r1,r0,LSR #11
000514  e5cd0012          STRB     r0,[sp,#0x12]
;;;311    			ProductId[3] = (char)((TmpDWord >> 4) & 0x07f);
000518  e59d0044          LDR      r0,[sp,#0x44]
00051c  e0010220          AND      r0,r1,r0,LSR #4
000520  e5cd0013          STRB     r0,[sp,#0x13]
;;;312    
;;;313    			byte = (uint8_t)((TmpDWord & 0x00f) << 3);
000524  e59d0044          LDR      r0,[sp,#0x44]
000528  e1a00e00          LSL      r0,r0,#28
00052c  e1a00ca0          LSR      r0,r0,#25
000530  e58d0048          STR      r0,[sp,#0x48]
;;;314    
;;;315    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x78);
000534  e3a02078          MOV      r2,#0x78
000538  e3a01094          MOV      r1,#0x94
00053c  e1a00005          MOV      r0,r5
000540  ebfffffe          BL       VL53L0X_WrByte
000544  e1844000          ORR      r4,r4,r0
;;;316    			Status |= VL53L0X_device_read_strobe(Dev);
000548  e1a00005          MOV      r0,r5
00054c  ebfffffe          BL       VL53L0X_device_read_strobe
000550  e1844000          ORR      r4,r4,r0
;;;317    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
000554  e28d2044          ADD      r2,sp,#0x44
000558  e3a01090          MOV      r1,#0x90
00055c  e1a00005          MOV      r0,r5
000560  ebfffffe          BL       VL53L0X_RdDWord
000564  e1844000          ORR      r4,r4,r0
;;;318    
;;;319    			ProductId[4] = (char)(byte +
000568  e3a0107f          MOV      r1,#0x7f
00056c  e59d0044          LDR      r0,[sp,#0x44]
000570  e0010ea0          AND      r0,r1,r0,LSR #29
000574  e5dd1048          LDRB     r1,[sp,#0x48]
000578  e0800001          ADD      r0,r0,r1
00057c  e5cd0014          STRB     r0,[sp,#0x14]
;;;320    					((TmpDWord >> 29) & 0x07f));
;;;321    			ProductId[5] = (char)((TmpDWord >> 22) & 0x07f);
000580  e3a0107f          MOV      r1,#0x7f
000584  e59d0044          LDR      r0,[sp,#0x44]
000588  e0010b20          AND      r0,r1,r0,LSR #22
00058c  e5cd0015          STRB     r0,[sp,#0x15]
;;;322    			ProductId[6] = (char)((TmpDWord >> 15) & 0x07f);
000590  e59d0044          LDR      r0,[sp,#0x44]
000594  e00107a0          AND      r0,r1,r0,LSR #15
000598  e5cd0016          STRB     r0,[sp,#0x16]
;;;323    			ProductId[7] = (char)((TmpDWord >> 8) & 0x07f);
00059c  e59d0044          LDR      r0,[sp,#0x44]
0005a0  e0010420          AND      r0,r1,r0,LSR #8
0005a4  e5cd0017          STRB     r0,[sp,#0x17]
;;;324    			ProductId[8] = (char)((TmpDWord >> 1) & 0x07f);
0005a8  e59d0044          LDR      r0,[sp,#0x44]
0005ac  e00100a0          AND      r0,r1,r0,LSR #1
0005b0  e5cd0018          STRB     r0,[sp,#0x18]
;;;325    
;;;326    			byte = (uint8_t)((TmpDWord & 0x001) << 6);
0005b4  e59d0044          LDR      r0,[sp,#0x44]
0005b8  e1a00f80          LSL      r0,r0,#31
0005bc  e1a00ca0          LSR      r0,r0,#25
0005c0  e58d0048          STR      r0,[sp,#0x48]
;;;327    
;;;328    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x79);
0005c4  e3a02079          MOV      r2,#0x79
0005c8  e3a01094          MOV      r1,#0x94
0005cc  e1a00005          MOV      r0,r5
0005d0  ebfffffe          BL       VL53L0X_WrByte
0005d4  e1844000          ORR      r4,r4,r0
;;;329    
;;;330    			Status |= VL53L0X_device_read_strobe(Dev);
0005d8  e1a00005          MOV      r0,r5
0005dc  ebfffffe          BL       VL53L0X_device_read_strobe
0005e0  e1844000          ORR      r4,r4,r0
;;;331    
;;;332    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
0005e4  e28d2044          ADD      r2,sp,#0x44
0005e8  e3a01090          MOV      r1,#0x90
0005ec  e1a00005          MOV      r0,r5
0005f0  ebfffffe          BL       VL53L0X_RdDWord
0005f4  e1844000          ORR      r4,r4,r0
;;;333    
;;;334    			ProductId[9] = (char)(byte +
0005f8  e3a0107f          MOV      r1,#0x7f
0005fc  e59d0044          LDR      r0,[sp,#0x44]
000600  e0010d20          AND      r0,r1,r0,LSR #26
000604  e5dd1048          LDRB     r1,[sp,#0x48]
000608  e0800001          ADD      r0,r0,r1
00060c  e5cd0019          STRB     r0,[sp,#0x19]
;;;335    					((TmpDWord >> 26) & 0x07f));
;;;336    			ProductId[10] = (char)((TmpDWord >> 19) & 0x07f);
000610  e3a0107f          MOV      r1,#0x7f
000614  e59d0044          LDR      r0,[sp,#0x44]
000618  e00109a0          AND      r0,r1,r0,LSR #19
00061c  e5cd001a          STRB     r0,[sp,#0x1a]
;;;337    			ProductId[11] = (char)((TmpDWord >> 12) & 0x07f);
000620  e59d0044          LDR      r0,[sp,#0x44]
000624  e0010620          AND      r0,r1,r0,LSR #12
000628  e5cd001b          STRB     r0,[sp,#0x1b]
;;;338    			ProductId[12] = (char)((TmpDWord >> 5) & 0x07f);
00062c  e59d0044          LDR      r0,[sp,#0x44]
000630  e00102a0          AND      r0,r1,r0,LSR #5
000634  e5cd001c          STRB     r0,[sp,#0x1c]
;;;339    
;;;340    			byte = (uint8_t)((TmpDWord & 0x01f) << 2);
000638  e59d0044          LDR      r0,[sp,#0x44]
00063c  e1a00d80          LSL      r0,r0,#27
000640  e1a00ca0          LSR      r0,r0,#25
000644  e58d0048          STR      r0,[sp,#0x48]
;;;341    
;;;342    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x7A);
000648  e3a0207a          MOV      r2,#0x7a
00064c  e3a01094          MOV      r1,#0x94
000650  e1a00005          MOV      r0,r5
000654  ebfffffe          BL       VL53L0X_WrByte
000658  e1844000          ORR      r4,r4,r0
;;;343    
;;;344    			Status |= VL53L0X_device_read_strobe(Dev);
00065c  e1a00005          MOV      r0,r5
000660  ebfffffe          BL       VL53L0X_device_read_strobe
000664  e1844000          ORR      r4,r4,r0
;;;345    
;;;346    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
000668  e28d2044          ADD      r2,sp,#0x44
00066c  e3a01090          MOV      r1,#0x90
000670  e1a00005          MOV      r0,r5
000674  ebfffffe          BL       VL53L0X_RdDWord
000678  e1844000          ORR      r4,r4,r0
;;;347    
;;;348    			ProductId[13] = (char)(byte +
00067c  e3a0107f          MOV      r1,#0x7f
000680  e59d0044          LDR      r0,[sp,#0x44]
000684  e0010f20          AND      r0,r1,r0,LSR #30
000688  e5dd1048          LDRB     r1,[sp,#0x48]
00068c  e0800001          ADD      r0,r0,r1
000690  e5cd001d          STRB     r0,[sp,#0x1d]
;;;349    					((TmpDWord >> 30) & 0x07f));
;;;350    			ProductId[14] = (char)((TmpDWord >> 23) & 0x07f);
000694  e3a0107f          MOV      r1,#0x7f
000698  e59d0044          LDR      r0,[sp,#0x44]
00069c  e0010ba0          AND      r0,r1,r0,LSR #23
0006a0  e5cd001e          STRB     r0,[sp,#0x1e]
;;;351    			ProductId[15] = (char)((TmpDWord >> 16) & 0x07f);
0006a4  e59d0044          LDR      r0,[sp,#0x44]
0006a8  e0010820          AND      r0,r1,r0,LSR #16
0006ac  e5cd001f          STRB     r0,[sp,#0x1f]
;;;352    			ProductId[16] = (char)((TmpDWord >> 9) & 0x07f);
0006b0  e59d0044          LDR      r0,[sp,#0x44]
0006b4  e00104a0          AND      r0,r1,r0,LSR #9
0006b8  e5cd0020          STRB     r0,[sp,#0x20]
;;;353    			ProductId[17] = (char)((TmpDWord >> 2) & 0x07f);
0006bc  e59d0044          LDR      r0,[sp,#0x44]
0006c0  e0010120          AND      r0,r1,r0,LSR #2
0006c4  e5cd0021          STRB     r0,[sp,#0x21]
;;;354    			ProductId[18] = '\0';
0006c8  e3a00000          MOV      r0,#0
0006cc  e5cd0022          STRB     r0,[sp,#0x22]
                  |L1.1744|
;;;355    
;;;356    		}
;;;357    
;;;358    		if (((option & 4) == 4) &&
0006d0  e2070004          AND      r0,r7,#4
0006d4  e3500004          CMP      r0,#4
0006d8  1a00005c          BNE      |L1.2128|
;;;359    			((ReadDataFromDeviceDone & 4) == 0)) {
0006dc  e3160004          TST      r6,#4
0006e0  1a00005a          BNE      |L1.2128|
;;;360    
;;;361    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x7B);
0006e4  e3a0207b          MOV      r2,#0x7b
0006e8  e3a01094          MOV      r1,#0x94
0006ec  e1a00005          MOV      r0,r5
0006f0  ebfffffe          BL       VL53L0X_WrByte
0006f4  e1844000          ORR      r4,r4,r0
;;;362    			Status |= VL53L0X_device_read_strobe(Dev);
0006f8  e1a00005          MOV      r0,r5
0006fc  ebfffffe          BL       VL53L0X_device_read_strobe
000700  e1844000          ORR      r4,r4,r0
;;;363    			Status |= VL53L0X_RdDWord(Dev, 0x90, &PartUIDUpper);
000704  e28d2030          ADD      r2,sp,#0x30
000708  e3a01090          MOV      r1,#0x90
00070c  e1a00005          MOV      r0,r5
000710  ebfffffe          BL       VL53L0X_RdDWord
000714  e1844000          ORR      r4,r4,r0
;;;364    
;;;365    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x7C);
000718  e3a0207c          MOV      r2,#0x7c
00071c  e3a01094          MOV      r1,#0x94
000720  e1a00005          MOV      r0,r5
000724  ebfffffe          BL       VL53L0X_WrByte
000728  e1844000          ORR      r4,r4,r0
;;;366    			Status |= VL53L0X_device_read_strobe(Dev);
00072c  e1a00005          MOV      r0,r5
000730  ebfffffe          BL       VL53L0X_device_read_strobe
000734  e1844000          ORR      r4,r4,r0
;;;367    			Status |= VL53L0X_RdDWord(Dev, 0x90, &PartUIDLower);
000738  e28d202c          ADD      r2,sp,#0x2c
00073c  e3a01090          MOV      r1,#0x90
000740  e1a00005          MOV      r0,r5
000744  ebfffffe          BL       VL53L0X_RdDWord
000748  e1844000          ORR      r4,r4,r0
;;;368    
;;;369    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x73);
00074c  e3a02073          MOV      r2,#0x73
000750  e3a01094          MOV      r1,#0x94
000754  e1a00005          MOV      r0,r5
000758  ebfffffe          BL       VL53L0X_WrByte
00075c  e1844000          ORR      r4,r4,r0
;;;370    			Status |= VL53L0X_device_read_strobe(Dev);
000760  e1a00005          MOV      r0,r5
000764  ebfffffe          BL       VL53L0X_device_read_strobe
000768  e1844000          ORR      r4,r4,r0
;;;371    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
00076c  e28d2044          ADD      r2,sp,#0x44
000770  e3a01090          MOV      r1,#0x90
000774  e1a00005          MOV      r0,r5
000778  ebfffffe          BL       VL53L0X_RdDWord
00077c  e1844000          ORR      r4,r4,r0
;;;372    
;;;373    			SignalRateMeasFixed1104_400_mm = (TmpDWord &
000780  e59d0044          LDR      r0,[sp,#0x44]
000784  e1a00c00          LSL      r0,r0,#24
000788  e1a00820          LSR      r0,r0,#16
00078c  e58d0024          STR      r0,[sp,#0x24]
;;;374    				0x0000000ff) << 8;
;;;375    
;;;376    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x74);
000790  e3a02074          MOV      r2,#0x74
000794  e3a01094          MOV      r1,#0x94
000798  e1a00005          MOV      r0,r5
00079c  ebfffffe          BL       VL53L0X_WrByte
0007a0  e1844000          ORR      r4,r4,r0
;;;377    			Status |= VL53L0X_device_read_strobe(Dev);
0007a4  e1a00005          MOV      r0,r5
0007a8  ebfffffe          BL       VL53L0X_device_read_strobe
0007ac  e1844000          ORR      r4,r4,r0
;;;378    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
0007b0  e28d2044          ADD      r2,sp,#0x44
0007b4  e3a01090          MOV      r1,#0x90
0007b8  e1a00005          MOV      r0,r5
0007bc  ebfffffe          BL       VL53L0X_RdDWord
0007c0  e1844000          ORR      r4,r4,r0
;;;379    
;;;380    			SignalRateMeasFixed1104_400_mm |= ((TmpDWord &
0007c4  e59d0044          LDR      r0,[sp,#0x44]
0007c8  e59d1024          LDR      r1,[sp,#0x24]
0007cc  e1810c20          ORR      r0,r1,r0,LSR #24
0007d0  e58d0024          STR      r0,[sp,#0x24]
;;;381    				0xff000000) >> 24);
;;;382    
;;;383    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x75);
0007d4  e3a02075          MOV      r2,#0x75
0007d8  e3a01094          MOV      r1,#0x94
0007dc  e1a00005          MOV      r0,r5
0007e0  ebfffffe          BL       VL53L0X_WrByte
0007e4  e1844000          ORR      r4,r4,r0
;;;384    			Status |= VL53L0X_device_read_strobe(Dev);
0007e8  e1a00005          MOV      r0,r5
0007ec  ebfffffe          BL       VL53L0X_device_read_strobe
0007f0  e1844000          ORR      r4,r4,r0
;;;385    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
0007f4  e28d2044          ADD      r2,sp,#0x44
0007f8  e3a01090          MOV      r1,#0x90
0007fc  e1a00005          MOV      r0,r5
000800  ebfffffe          BL       VL53L0X_RdDWord
000804  e1844000          ORR      r4,r4,r0
;;;386    
;;;387    			DistMeasFixed1104_400_mm = (TmpDWord & 0x0000000ff)
000808  e59d0044          LDR      r0,[sp,#0x44]
00080c  e1a00c00          LSL      r0,r0,#24
000810  e1a09820          LSR      r9,r0,#16
;;;388    							<< 8;
;;;389    
;;;390    			Status |= VL53L0X_WrByte(Dev, 0x94, 0x76);
000814  e3a02076          MOV      r2,#0x76
000818  e3a01094          MOV      r1,#0x94
00081c  e1a00005          MOV      r0,r5
000820  ebfffffe          BL       VL53L0X_WrByte
000824  e1844000          ORR      r4,r4,r0
;;;391    			Status |= VL53L0X_device_read_strobe(Dev);
000828  e1a00005          MOV      r0,r5
00082c  ebfffffe          BL       VL53L0X_device_read_strobe
000830  e1844000          ORR      r4,r4,r0
;;;392    			Status |= VL53L0X_RdDWord(Dev, 0x90, &TmpDWord);
000834  e28d2044          ADD      r2,sp,#0x44
000838  e3a01090          MOV      r1,#0x90
00083c  e1a00005          MOV      r0,r5
000840  ebfffffe          BL       VL53L0X_RdDWord
000844  e1844000          ORR      r4,r4,r0
;;;393    
;;;394    			DistMeasFixed1104_400_mm |= ((TmpDWord & 0xff000000)
000848  e59d0044          LDR      r0,[sp,#0x44]
00084c  e1899c20          ORR      r9,r9,r0,LSR #24
                  |L1.2128|
;;;395    							>> 24);
;;;396    		}
;;;397    
;;;398    		Status |= VL53L0X_WrByte(Dev, 0x81, 0x00);
000850  e3a02000          MOV      r2,#0
000854  e3a01081          MOV      r1,#0x81
000858  e1a00005          MOV      r0,r5
00085c  ebfffffe          BL       VL53L0X_WrByte
000860  e1844000          ORR      r4,r4,r0
;;;399    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x06);
000864  e3a02006          MOV      r2,#6
000868  e3a010ff          MOV      r1,#0xff
00086c  e1a00005          MOV      r0,r5
000870  ebfffffe          BL       VL53L0X_WrByte
000874  e1844000          ORR      r4,r4,r0
;;;400    		Status |= VL53L0X_RdByte(Dev, 0x83, &byte);
000878  e28d2048          ADD      r2,sp,#0x48
00087c  e3a01083          MOV      r1,#0x83
000880  e1a00005          MOV      r0,r5
000884  ebfffffe          BL       VL53L0X_RdByte
000888  e1844000          ORR      r4,r4,r0
;;;401    		Status |= VL53L0X_WrByte(Dev, 0x83, byte&0xfb);
00088c  e5dd0048          LDRB     r0,[sp,#0x48]
000890  e20020fb          AND      r2,r0,#0xfb
000894  e3a01083          MOV      r1,#0x83
000898  e1a00005          MOV      r0,r5
00089c  ebfffffe          BL       VL53L0X_WrByte
0008a0  e1844000          ORR      r4,r4,r0
;;;402    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x01);
0008a4  e3a02001          MOV      r2,#1
0008a8  e3a010ff          MOV      r1,#0xff
0008ac  e1a00005          MOV      r0,r5
0008b0  ebfffffe          BL       VL53L0X_WrByte
0008b4  e1844000          ORR      r4,r4,r0
;;;403    		Status |= VL53L0X_WrByte(Dev, 0x00, 0x01);
0008b8  e3a02001          MOV      r2,#1
0008bc  e3a01000          MOV      r1,#0
0008c0  e1a00005          MOV      r0,r5
0008c4  ebfffffe          BL       VL53L0X_WrByte
0008c8  e1844000          ORR      r4,r4,r0
;;;404    
;;;405    		Status |= VL53L0X_WrByte(Dev, 0xFF, 0x00);
0008cc  e3a02000          MOV      r2,#0
0008d0  e3a010ff          MOV      r1,#0xff
0008d4  e1a00005          MOV      r0,r5
0008d8  ebfffffe          BL       VL53L0X_WrByte
0008dc  e1844000          ORR      r4,r4,r0
;;;406    		Status |= VL53L0X_WrByte(Dev, 0x80, 0x00);
0008e0  e3a02000          MOV      r2,#0
0008e4  e3a01080          MOV      r1,#0x80
0008e8  e1a00005          MOV      r0,r5
0008ec  ebfffffe          BL       VL53L0X_WrByte
0008f0  e1844000          ORR      r4,r4,r0
                  |L1.2292|
;;;407    	}
;;;408    
;;;409    	if ((Status == VL53L0X_ERROR_NONE) &&
0008f4  e3540000          CMP      r4,#0
0008f8  1a00003e          BNE      |L1.2552|
;;;410    		(ReadDataFromDeviceDone != 7)) {
0008fc  e3560007          CMP      r6,#7
000900  0a00003c          BEQ      |L1.2552|
;;;411    		/* Assign to variable if status is ok */
;;;412    		if (((option & 1) == 1) &&
000904  e3170001          TST      r7,#1
000908  0a00000e          BEQ      |L1.2376|
;;;413    			((ReadDataFromDeviceDone & 1) == 0)) {
00090c  e3160001          TST      r6,#1
000910  1a00000c          BNE      |L1.2376|
;;;414    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000914  e59d0038          LDR      r0,[sp,#0x38]
000918  e5c50113          STRB     r0,[r5,#0x113]
;;;415    				ReferenceSpadCount, ReferenceSpadCount);
;;;416    
;;;417    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
00091c  e59d0034          LDR      r0,[sp,#0x34]
000920  e5c50114          STRB     r0,[r5,#0x114]
;;;418    				ReferenceSpadType, ReferenceSpadType);
;;;419    
;;;420    			for (i = 0; i < VL53L0X_REF_SPAD_BUFFER_SIZE; i++) {
000924  e3a08000          MOV      r8,#0
000928  ea000004          B        |L1.2368|
                  |L1.2348|
;;;421    				Dev->Data.SpadData.RefGoodSpadMap[i] =
00092c  e7dd0008          LDRB     r0,[sp,r8]
000930  e2851c01          ADD      r1,r5,#0x100
000934  e281102a          ADD      r1,r1,#0x2a
000938  e7c10008          STRB     r0,[r1,r8]
00093c  e2888001          ADD      r8,r8,#1              ;420
                  |L1.2368|
000940  e3580006          CMP      r8,#6                 ;420
000944  bafffff8          BLT      |L1.2348|
                  |L1.2376|
;;;422    					NvmRefGoodSpadMap[i];
;;;423    			}
;;;424    		}
;;;425    
;;;426    		if (((option & 2) == 2) &&
000948  e2070002          AND      r0,r7,#2
00094c  e3500002          CMP      r0,#2
000950  1a00000a          BNE      |L1.2432|
;;;427    			((ReadDataFromDeviceDone & 2) == 0)) {
000954  e3160002          TST      r6,#2
000958  1a000008          BNE      |L1.2432|
;;;428    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
00095c  e5dd0040          LDRB     r0,[sp,#0x40]
000960  e5c500f1          STRB     r0,[r5,#0xf1]
;;;429    					ModuleId, ModuleId);
;;;430    
;;;431    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000964  e5dd003c          LDRB     r0,[sp,#0x3c]
000968  e5c500f2          STRB     r0,[r5,#0xf2]
;;;432    					Revision, Revision);
;;;433    
;;;434    			ProductId_tmp = VL53L0X_GETDEVICESPECIFICPARAMETER(Dev,
00096c  e28500f3          ADD      r0,r5,#0xf3
000970  e58d000c          STR      r0,[sp,#0xc]
;;;435    					ProductId);
;;;436    			VL53L0X_COPYSTRING(ProductId_tmp, ProductId);
000974  e28d1010          ADD      r1,sp,#0x10
000978  e59d000c          LDR      r0,[sp,#0xc]
00097c  ebfffffe          BL       strcpy
                  |L1.2432|
;;;437    
;;;438    		}
;;;439    
;;;440    		if (((option & 4) == 4) &&
000980  e2070004          AND      r0,r7,#4
000984  e3500004          CMP      r0,#4
000988  1a000016          BNE      |L1.2536|
;;;441    			((ReadDataFromDeviceDone & 4) == 0)) {
00098c  e3160004          TST      r6,#4
000990  1a000014          BNE      |L1.2536|
;;;442    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000994  e59d0030          LDR      r0,[sp,#0x30]
000998  e5850118          STR      r0,[r5,#0x118]
;;;443    						PartUIDUpper, PartUIDUpper);
;;;444    
;;;445    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
00099c  e59d002c          LDR      r0,[sp,#0x2c]
0009a0  e585011c          STR      r0,[r5,#0x11c]
;;;446    						PartUIDLower, PartUIDLower);
;;;447    
;;;448    			SignalRateMeasFixed400mmFix =
0009a4  e59d0024          LDR      r0,[sp,#0x24]
0009a8  e1a00480          LSL      r0,r0,#9
0009ac  e58d0008          STR      r0,[sp,#8]
;;;449    				VL53L0X_FIXPOINT97TOFIXPOINT1616(
;;;450    					SignalRateMeasFixed1104_400_mm);
;;;451    
;;;452    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
0009b0  e59d0008          LDR      r0,[sp,#8]
0009b4  e5850120          STR      r0,[r5,#0x120]
;;;453    				SignalRateMeasFixed400mm,
;;;454    				SignalRateMeasFixed400mmFix);
;;;455    
;;;456    			OffsetMicroMeters = 0;
0009b8  e3a0b000          MOV      r11,#0
;;;457    			if (DistMeasFixed1104_400_mm != 0) {
0009bc  e3590000          CMP      r9,#0
0009c0  0a000007          BEQ      |L1.2532|
;;;458    					OffsetFixed1104_mm =
0009c4  e59d0028          LDR      r0,[sp,#0x28]
0009c8  e049a000          SUB      r10,r9,r0
;;;459    						DistMeasFixed1104_400_mm -
;;;460    						DistMeasTgtFixed1104_mm;
;;;461    					OffsetMicroMeters = (OffsetFixed1104_mm
0009cc  e3a00ffa          MOV      r0,#0x3e8
0009d0  e000009a          MUL      r0,r10,r0
0009d4  e1a0b220          LSR      r11,r0,#4
;;;462    						* 1000) >> 4;
;;;463    					OffsetMicroMeters *= -1;
0009d8  e26b0000          RSB      r0,r11,#0
0009dc  e1a00800          LSL      r0,r0,#16
0009e0  e1a0b840          ASR      r11,r0,#16
                  |L1.2532|
;;;464    			}
;;;465    
;;;466    			PALDevDataSet(Dev,
0009e4  e585b00c          STR      r11,[r5,#0xc]
                  |L1.2536|
;;;467    				Part2PartOffsetAdjustmentNVMMicroMeter,
;;;468    				OffsetMicroMeters);
;;;469    		}
;;;470    		byte = (uint8_t)(ReadDataFromDeviceDone|option);
0009e8  e1860007          ORR      r0,r6,r7
0009ec  e58d0048          STR      r0,[sp,#0x48]
;;;471    		VL53L0X_SETDEVICESPECIFICPARAMETER(Dev, ReadDataFromDeviceDone,
0009f0  e5dd0048          LDRB     r0,[sp,#0x48]
0009f4  e5c500f0          STRB     r0,[r5,#0xf0]
                  |L1.2552|
;;;472    				byte);
;;;473    	}
;;;474    
;;;475    	LOG_FUNCTION_END(Status);
;;;476    	return Status;
0009f8  e1a00004          MOV      r0,r4
0009fc  e28dd04c          ADD      sp,sp,#0x4c
;;;477    }
000a00  e8bd8ff0          POP      {r4-r11,pc}
;;;478    
                          ENDP

                  VL53L0X_calc_macro_period_ps PROC
;;;479    
;;;480    uint32_t VL53L0X_calc_macro_period_ps(VL53L0X_DEV Dev, uint8_t vcsel_period_pclks)
000a04  e92d40e0          PUSH     {r5-r7,lr}
;;;481    {
000a08  e1a05000          MOV      r5,r0
000a0c  e59f3634          LDR      r3,|L1.4168|
;;;482    	uint64_t PLL_period_ps;
;;;483    	uint32_t macro_period_vclks;
;;;484    	uint32_t macro_period_ps;
;;;485    
;;;486    	LOG_FUNCTION_START("");
;;;487    
;;;488    	/* The above calculation will produce rounding errors,
;;;489    	   therefore set fixed value
;;;490    	*/
;;;491    	PLL_period_ps = 1655;
;;;492    
;;;493    	macro_period_vclks = 2304;
000a10  e3a02c09          MOV      r2,#0x900
;;;494    	macro_period_ps = (uint32_t)(macro_period_vclks
000a14  e00c0192          MUL      r12,r2,r1
000a18  e087039c          UMULL    r0,r7,r12,r3
;;;495    			* vcsel_period_pclks * PLL_period_ps);
;;;496    
;;;497    	LOG_FUNCTION_END("");
;;;498    	return macro_period_ps;
;;;499    }
000a1c  e8bd80e0          POP      {r5-r7,pc}
;;;500    
                          ENDP

                  VL53L0X_encode_timeout PROC
;;;501    uint16_t VL53L0X_encode_timeout(uint32_t timeout_macro_clks)
000a20  e1a01000          MOV      r1,r0
;;;502    {
;;;503    	/*!
;;;504    	 * Encode timeout in macro periods in (LSByte * 2^MSByte) + 1 format
;;;505    	 */
;;;506    
;;;507    	uint16_t encoded_timeout = 0;
000a24  e3a00000          MOV      r0,#0
;;;508    	uint32_t ls_byte = 0;
000a28  e3a02000          MOV      r2,#0
;;;509    	uint16_t ms_byte = 0;
000a2c  e3a03000          MOV      r3,#0
;;;510    
;;;511    	if (timeout_macro_clks > 0) {
000a30  e3510000          CMP      r1,#0
000a34  0a00000b          BEQ      |L1.2664|
;;;512    		ls_byte = timeout_macro_clks - 1;
000a38  e2412001          SUB      r2,r1,#1
;;;513    
;;;514    		while ((ls_byte & 0xFFFFFF00) > 0) {
000a3c  ea000003          B        |L1.2640|
                  |L1.2624|
;;;515    			ls_byte = ls_byte >> 1;
000a40  e1a020a2          LSR      r2,r2,#1
;;;516    			ms_byte++;
000a44  e283c001          ADD      r12,r3,#1
000a48  e1a0380c          LSL      r3,r12,#16
000a4c  e1a03823          LSR      r3,r3,#16
                  |L1.2640|
000a50  e3d2c0ff          BICS     r12,r2,#0xff          ;514
000a54  1afffff9          BNE      |L1.2624|
;;;517    		}
;;;518    
;;;519    		encoded_timeout = (ms_byte << 8)
000a58  e202c0ff          AND      r12,r2,#0xff
000a5c  e08cc403          ADD      r12,r12,r3,LSL #8
000a60  e1a0080c          LSL      r0,r12,#16
000a64  e1a00820          LSR      r0,r0,#16
                  |L1.2664|
;;;520    				+ (uint16_t) (ls_byte & 0x000000FF);
;;;521    	}
;;;522    
;;;523    	return encoded_timeout;
;;;524    
;;;525    }
000a68  e12fff1e          BX       lr
;;;526    
                          ENDP

                  VL53L0X_decode_timeout PROC
;;;527    uint32_t VL53L0X_decode_timeout(uint16_t encoded_timeout)
000a6c  e1a01000          MOV      r1,r0
;;;528    {
;;;529    	/*!
;;;530    	 * Decode 16-bit timeout register value - format (LSByte * 2^MSByte) + 1
;;;531    	 */
;;;532    
;;;533    	uint32_t timeout_macro_clks = 0;
000a70  e3a00000          MOV      r0,#0
;;;534    
;;;535    	timeout_macro_clks = ((uint32_t) (encoded_timeout & 0x00FF)
000a74  e20120ff          AND      r2,r1,#0xff
000a78  e1a03441          ASR      r3,r1,#8
000a7c  e1a02312          LSL      r2,r2,r3
000a80  e2820001          ADD      r0,r2,#1
;;;536    			<< (uint32_t) ((encoded_timeout & 0xFF00) >> 8)) + 1;
;;;537    
;;;538    	return timeout_macro_clks;
;;;539    }
000a84  e12fff1e          BX       lr
;;;540    
                          ENDP

                  VL53L0X_calc_timeout_mclks PROC
;;;542    /* To convert ms into register value */
;;;543    uint32_t VL53L0X_calc_timeout_mclks(VL53L0X_DEV Dev,
000a88  e92d47f0          PUSH     {r4-r10,lr}
;;;544    		uint32_t timeout_period_us,
;;;545    		uint8_t vcsel_period_pclks)
;;;546    {
000a8c  e1a07000          MOV      r7,r0
000a90  e1a04001          MOV      r4,r1
000a94  e1a05002          MOV      r5,r2
;;;547    	uint32_t macro_period_ps;
;;;548    	uint32_t macro_period_ns;
;;;549    	uint32_t timeout_period_mclks = 0;
000a98  e1a00000          MOV      r0,r0
;;;550    
;;;551    	macro_period_ps = VL53L0X_calc_macro_period_ps(Dev, vcsel_period_pclks);
000a9c  e1a01005          MOV      r1,r5
000aa0  e1a00007          MOV      r0,r7
000aa4  ebfffffe          BL       VL53L0X_calc_macro_period_ps
000aa8  e1a08000          MOV      r8,r0
;;;552    	macro_period_ns = (macro_period_ps + 500) / 1000;
000aac  e3a01ffa          MOV      r1,#0x3e8
000ab0  e2880f7d          ADD      r0,r8,#0x1f4
000ab4  ebfffffe          BL       __aeabi_uidivmod
000ab8  e1a06000          MOV      r6,r0
;;;553    
;;;554    	timeout_period_mclks =
000abc  e3a01ffa          MOV      r1,#0x3e8
000ac0  e0010194          MUL      r1,r4,r1
000ac4  e08100a6          ADD      r0,r1,r6,LSR #1
000ac8  e1a01006          MOV      r1,r6
000acc  ebfffffe          BL       __aeabi_uidivmod
000ad0  e1a09000          MOV      r9,r0
;;;555    		(uint32_t) (((timeout_period_us * 1000)
;;;556    		+ (macro_period_ns / 2)) / macro_period_ns);
;;;557    
;;;558    	return timeout_period_mclks;
000ad4  e1a00009          MOV      r0,r9
;;;559    }
000ad8  e8bd87f0          POP      {r4-r10,pc}
;;;560    
                          ENDP

                  VL53L0X_calc_timeout_us PROC
;;;561    /* To convert register value into us */
;;;562    uint32_t VL53L0X_calc_timeout_us(VL53L0X_DEV Dev,
000adc  e92d47f0          PUSH     {r4-r10,lr}
;;;563    		uint16_t timeout_period_mclks,
;;;564    		uint8_t vcsel_period_pclks)
;;;565    {
000ae0  e1a07000          MOV      r7,r0
000ae4  e1a04001          MOV      r4,r1
000ae8  e1a05002          MOV      r5,r2
;;;566    	uint32_t macro_period_ps;
;;;567    	uint32_t macro_period_ns;
;;;568    	uint32_t actual_timeout_period_us = 0;
000aec  e3a09000          MOV      r9,#0
;;;569    
;;;570    	macro_period_ps = VL53L0X_calc_macro_period_ps(Dev, vcsel_period_pclks);
000af0  e1a01005          MOV      r1,r5
000af4  e1a00007          MOV      r0,r7
000af8  ebfffffe          BL       VL53L0X_calc_macro_period_ps
000afc  e1a08000          MOV      r8,r0
;;;571    	macro_period_ns = (macro_period_ps + 500) / 1000;
000b00  e3a01ffa          MOV      r1,#0x3e8
000b04  e2880f7d          ADD      r0,r8,#0x1f4
000b08  ebfffffe          BL       __aeabi_uidivmod
000b0c  e1a06000          MOV      r6,r0
;;;572    
;;;573    	actual_timeout_period_us =
000b10  e0010694          MUL      r1,r4,r6
000b14  e08100a6          ADD      r0,r1,r6,LSR #1
000b18  e3a01ffa          MOV      r1,#0x3e8
000b1c  ebfffffe          BL       __aeabi_uidivmod
000b20  e1a09000          MOV      r9,r0
;;;574    		((timeout_period_mclks * macro_period_ns)
;;;575    		+ (macro_period_ns / 2)) / 1000;
;;;576    
;;;577    	return actual_timeout_period_us;
000b24  e1a00009          MOV      r0,r9
;;;578    }
000b28  e8bd87f0          POP      {r4-r10,pc}
;;;579    
                          ENDP

                  get_sequence_step_timeout PROC
;;;580    
;;;581    VL53L0X_Error get_sequence_step_timeout(VL53L0X_DEV Dev,
000b2c  e92d4ff0          PUSH     {r4-r11,lr}
;;;582    				VL53L0X_SequenceStepId SequenceStepId,
;;;583    				uint32_t *pTimeOutMicroSecs)
;;;584    {
000b30  e24dd01c          SUB      sp,sp,#0x1c
000b34  e1a0a000          MOV      r10,r0
000b38  e1a05001          MOV      r5,r1
000b3c  e1a07002          MOV      r7,r2
;;;585    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000b40  e3a04000          MOV      r4,#0
;;;586    	uint8_t CurrentVCSELPulsePeriodPClk;
;;;587    	uint8_t EncodedTimeOutByte = 0;
000b44  e3a00000          MOV      r0,#0
000b48  e58d0014          STR      r0,[sp,#0x14]
;;;588    	uint32_t TimeoutMicroSeconds = 0;
000b4c  e3a0b000          MOV      r11,#0
;;;589    	uint16_t PreRangeEncodedTimeOut = 0;
000b50  e58d0010          STR      r0,[sp,#0x10]
;;;590    	uint16_t MsrcTimeOutMClks;
;;;591    	uint16_t PreRangeTimeOutMClks;
;;;592    	uint16_t FinalRangeTimeOutMClks = 0;
000b54  e3a09000          MOV      r9,#0
;;;593    	uint16_t FinalRangeEncodedTimeOut;
;;;594    	VL53L0X_SchedulerSequenceSteps_t SchedulerSequenceSteps;
;;;595    
;;;596    	if ((SequenceStepId == VL53L0X_SEQUENCESTEP_TCC)	 ||
000b58  e3550000          CMP      r5,#0
000b5c  0a000003          BEQ      |L1.2928|
;;;597    		(SequenceStepId == VL53L0X_SEQUENCESTEP_DSS)	 ||
000b60  e3550001          CMP      r5,#1
000b64  0a000001          BEQ      |L1.2928|
;;;598    		(SequenceStepId == VL53L0X_SEQUENCESTEP_MSRC)) {
000b68  e3550002          CMP      r5,#2
000b6c  1a000015          BNE      |L1.3016|
                  |L1.2928|
;;;599    
;;;600    		Status = VL53L0X_GetVcselPulsePeriod(Dev,
000b70  e28d2018          ADD      r2,sp,#0x18
000b74  e3a01000          MOV      r1,#0
000b78  e1a0000a          MOV      r0,r10
000b7c  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000b80  e1a04000          MOV      r4,r0
;;;601    					VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;602    					&CurrentVCSELPulsePeriodPClk);
;;;603    		if (Status == VL53L0X_ERROR_NONE) {
000b84  e3540000          CMP      r4,#0
000b88  1a000004          BNE      |L1.2976|
;;;604    			Status = VL53L0X_RdByte(Dev,
000b8c  e28d2014          ADD      r2,sp,#0x14
000b90  e3a01046          MOV      r1,#0x46
000b94  e1a0000a          MOV      r0,r10
000b98  ebfffffe          BL       VL53L0X_RdByte
000b9c  e1a04000          MOV      r4,r0
                  |L1.2976|
;;;605    					VL53L0X_REG_MSRC_CONFIG_TIMEOUT_MACROP,
;;;606    					&EncodedTimeOutByte);
;;;607    		}
;;;608    		MsrcTimeOutMClks = VL53L0X_decode_timeout(EncodedTimeOutByte);
000ba0  e5dd0014          LDRB     r0,[sp,#0x14]
000ba4  ebfffffe          BL       VL53L0X_decode_timeout
000ba8  e1a08800          LSL      r8,r0,#16
000bac  e1a08828          LSR      r8,r8,#16
;;;609    
;;;610    		TimeoutMicroSeconds = VL53L0X_calc_timeout_us(Dev,
000bb0  e5dd2018          LDRB     r2,[sp,#0x18]
000bb4  e1a01008          MOV      r1,r8
000bb8  e1a0000a          MOV      r0,r10
000bbc  ebfffffe          BL       VL53L0X_calc_timeout_us
000bc0  e1a0b000          MOV      r11,r0
000bc4  ea000051          B        |L1.3344|
                  |L1.3016|
;;;611    						MsrcTimeOutMClks,
;;;612    						CurrentVCSELPulsePeriodPClk);
;;;613    	} else if (SequenceStepId == VL53L0X_SEQUENCESTEP_PRE_RANGE) {
000bc8  e3550003          CMP      r5,#3
000bcc  1a00001c          BNE      |L1.3140|
;;;614    		/* Retrieve PRE-RANGE VCSEL Period */
;;;615    		Status = VL53L0X_GetVcselPulsePeriod(Dev,
000bd0  e28d2018          ADD      r2,sp,#0x18
000bd4  e3a01000          MOV      r1,#0
000bd8  e1a0000a          MOV      r0,r10
000bdc  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000be0  e1a04000          MOV      r4,r0
;;;616    						VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;617    						&CurrentVCSELPulsePeriodPClk);
;;;618    
;;;619    		/* Retrieve PRE-RANGE Timeout in Macro periods (MCLKS) */
;;;620    		if (Status == VL53L0X_ERROR_NONE) {
000be4  e3540000          CMP      r4,#0
000be8  1a000048          BNE      |L1.3344|
;;;621    
;;;622    			/* Retrieve PRE-RANGE VCSEL Period */
;;;623    			Status = VL53L0X_GetVcselPulsePeriod(Dev,
000bec  e28d2018          ADD      r2,sp,#0x18
000bf0  e3a01000          MOV      r1,#0
000bf4  e1a0000a          MOV      r0,r10
000bf8  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000bfc  e1a04000          MOV      r4,r0
;;;624    					VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;625    					&CurrentVCSELPulsePeriodPClk);
;;;626    
;;;627    			if (Status == VL53L0X_ERROR_NONE) {
000c00  e3540000          CMP      r4,#0
000c04  1a000004          BNE      |L1.3100|
;;;628    				Status = VL53L0X_RdWord(Dev,
000c08  e28d2010          ADD      r2,sp,#0x10
000c0c  e3a01051          MOV      r1,#0x51
000c10  e1a0000a          MOV      r0,r10
000c14  ebfffffe          BL       VL53L0X_RdWord
000c18  e1a04000          MOV      r4,r0
                  |L1.3100|
;;;629    				VL53L0X_REG_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI,
;;;630    				&PreRangeEncodedTimeOut);
;;;631    			}
;;;632    
;;;633    			PreRangeTimeOutMClks = VL53L0X_decode_timeout(
000c1c  e1dd01b0          LDRH     r0,[sp,#0x10]
000c20  ebfffffe          BL       VL53L0X_decode_timeout
000c24  e1a06800          LSL      r6,r0,#16
000c28  e1a06826          LSR      r6,r6,#16
;;;634    					PreRangeEncodedTimeOut);
;;;635    
;;;636    			TimeoutMicroSeconds = VL53L0X_calc_timeout_us(Dev,
000c2c  e5dd2018          LDRB     r2,[sp,#0x18]
000c30  e1a01006          MOV      r1,r6
000c34  e1a0000a          MOV      r0,r10
000c38  ebfffffe          BL       VL53L0X_calc_timeout_us
000c3c  e1a0b000          MOV      r11,r0
000c40  ea000032          B        |L1.3344|
                  |L1.3140|
;;;637    					PreRangeTimeOutMClks,
;;;638    					CurrentVCSELPulsePeriodPClk);
;;;639    		}
;;;640    	} else if (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE) {
000c44  e3550004          CMP      r5,#4
000c48  1a000030          BNE      |L1.3344|
;;;641    
;;;642    		VL53L0X_GetSequenceStepEnables(Dev, &SchedulerSequenceSteps);
000c4c  e28d1004          ADD      r1,sp,#4
000c50  e1a0000a          MOV      r0,r10
000c54  ebfffffe          BL       VL53L0X_GetSequenceStepEnables
;;;643    		PreRangeTimeOutMClks = 0;
000c58  e3a06000          MOV      r6,#0
;;;644    
;;;645    		if (SchedulerSequenceSteps.PreRangeOn) {
000c5c  e5dd0007          LDRB     r0,[sp,#7]
000c60  e3500000          CMP      r0,#0
000c64  0a00000f          BEQ      |L1.3240|
;;;646    			/* Retrieve PRE-RANGE VCSEL Period */
;;;647    			Status = VL53L0X_GetVcselPulsePeriod(Dev,
000c68  e28d2018          ADD      r2,sp,#0x18
000c6c  e3a01000          MOV      r1,#0
000c70  e1a0000a          MOV      r0,r10
000c74  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000c78  e1a04000          MOV      r4,r0
;;;648    				VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;649    				&CurrentVCSELPulsePeriodPClk);
;;;650    
;;;651    			/* Retrieve PRE-RANGE Timeout in Macro periods
;;;652    			 * (MCLKS) */
;;;653    			if (Status == VL53L0X_ERROR_NONE) {
000c7c  e3540000          CMP      r4,#0
000c80  1a000008          BNE      |L1.3240|
;;;654    				Status = VL53L0X_RdWord(Dev,
000c84  e28d2010          ADD      r2,sp,#0x10
000c88  e3a01051          MOV      r1,#0x51
000c8c  e1a0000a          MOV      r0,r10
000c90  ebfffffe          BL       VL53L0X_RdWord
000c94  e1a04000          MOV      r4,r0
;;;655    				VL53L0X_REG_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI,
;;;656    				&PreRangeEncodedTimeOut);
;;;657    				PreRangeTimeOutMClks = VL53L0X_decode_timeout(
000c98  e1dd01b0          LDRH     r0,[sp,#0x10]
000c9c  ebfffffe          BL       VL53L0X_decode_timeout
000ca0  e1a06800          LSL      r6,r0,#16
000ca4  e1a06826          LSR      r6,r6,#16
                  |L1.3240|
;;;658    						PreRangeEncodedTimeOut);
;;;659    			}
;;;660    		}
;;;661    
;;;662    		if (Status == VL53L0X_ERROR_NONE) {
000ca8  e3540000          CMP      r4,#0
000cac  1a000004          BNE      |L1.3268|
;;;663    			/* Retrieve FINAL-RANGE VCSEL Period */
;;;664    			Status = VL53L0X_GetVcselPulsePeriod(Dev,
000cb0  e28d2018          ADD      r2,sp,#0x18
000cb4  e3a01001          MOV      r1,#1
000cb8  e1a0000a          MOV      r0,r10
000cbc  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000cc0  e1a04000          MOV      r4,r0
                  |L1.3268|
;;;665    					VL53L0X_VCSEL_PERIOD_FINAL_RANGE,
;;;666    					&CurrentVCSELPulsePeriodPClk);
;;;667    		}
;;;668    
;;;669    		/* Retrieve FINAL-RANGE Timeout in Macro periods (MCLKS) */
;;;670    		if (Status == VL53L0X_ERROR_NONE) {
000cc4  e3540000          CMP      r4,#0
000cc8  1a000008          BNE      |L1.3312|
;;;671    			Status = VL53L0X_RdWord(Dev,
000ccc  e28d200c          ADD      r2,sp,#0xc
000cd0  e3a01071          MOV      r1,#0x71
000cd4  e1a0000a          MOV      r0,r10
000cd8  ebfffffe          BL       VL53L0X_RdWord
000cdc  e1a04000          MOV      r4,r0
;;;672    				VL53L0X_REG_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI,
;;;673    				&FinalRangeEncodedTimeOut);
;;;674    			FinalRangeTimeOutMClks = VL53L0X_decode_timeout(
000ce0  e1dd00bc          LDRH     r0,[sp,#0xc]
000ce4  ebfffffe          BL       VL53L0X_decode_timeout
000ce8  e1a09800          LSL      r9,r0,#16
000cec  e1a09829          LSR      r9,r9,#16
                  |L1.3312|
;;;675    					FinalRangeEncodedTimeOut);
;;;676    		}
;;;677    
;;;678    		FinalRangeTimeOutMClks -= PreRangeTimeOutMClks;
000cf0  e0490006          SUB      r0,r9,r6
000cf4  e1a09800          LSL      r9,r0,#16
000cf8  e1a09829          LSR      r9,r9,#16
;;;679    		TimeoutMicroSeconds = VL53L0X_calc_timeout_us(Dev,
000cfc  e5dd2018          LDRB     r2,[sp,#0x18]
000d00  e1a01009          MOV      r1,r9
000d04  e1a0000a          MOV      r0,r10
000d08  ebfffffe          BL       VL53L0X_calc_timeout_us
000d0c  e1a0b000          MOV      r11,r0
                  |L1.3344|
;;;680    						FinalRangeTimeOutMClks,
;;;681    						CurrentVCSELPulsePeriodPClk);
;;;682    	}
;;;683    
;;;684    	*pTimeOutMicroSecs = TimeoutMicroSeconds;
000d10  e587b000          STR      r11,[r7,#0]
;;;685    
;;;686    	return Status;
000d14  e1a00004          MOV      r0,r4
000d18  e28dd01c          ADD      sp,sp,#0x1c
;;;687    }
000d1c  e8bd8ff0          POP      {r4-r11,pc}
;;;688    
                          ENDP

                  set_sequence_step_timeout PROC
;;;689    
;;;690    VL53L0X_Error set_sequence_step_timeout(VL53L0X_DEV Dev,
000d20  e92d4ff0          PUSH     {r4-r11,lr}
;;;691    					VL53L0X_SequenceStepId SequenceStepId,
;;;692    					uint32_t TimeOutMicroSecs)
;;;693    {
000d24  e24dd014          SUB      sp,sp,#0x14
000d28  e1a06000          MOV      r6,r0
000d2c  e1a05001          MOV      r5,r1
000d30  e1a07002          MOV      r7,r2
;;;694    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000d34  e3a04000          MOV      r4,#0
;;;695    	uint8_t CurrentVCSELPulsePeriodPClk;
;;;696    	uint8_t MsrcEncodedTimeOut;
;;;697    	uint16_t PreRangeEncodedTimeOut;
;;;698    	uint16_t PreRangeTimeOutMClks;
;;;699    	uint16_t MsrcRangeTimeOutMClks;
;;;700    	uint16_t FinalRangeTimeOutMClks;
;;;701    	uint16_t FinalRangeEncodedTimeOut;
;;;702    	VL53L0X_SchedulerSequenceSteps_t SchedulerSequenceSteps;
;;;703    
;;;704    	if ((SequenceStepId == VL53L0X_SEQUENCESTEP_TCC)	 ||
000d38  e3550000          CMP      r5,#0
000d3c  0a000003          BEQ      |L1.3408|
;;;705    		(SequenceStepId == VL53L0X_SEQUENCESTEP_DSS)	 ||
000d40  e3550001          CMP      r5,#1
000d44  0a000001          BEQ      |L1.3408|
;;;706    		(SequenceStepId == VL53L0X_SEQUENCESTEP_MSRC)) {
000d48  e3550002          CMP      r5,#2
000d4c  1a00001b          BNE      |L1.3520|
                  |L1.3408|
;;;707    
;;;708    		Status = VL53L0X_GetVcselPulsePeriod(Dev,
000d50  e28d2010          ADD      r2,sp,#0x10
000d54  e3a01000          MOV      r1,#0
000d58  e1a00006          MOV      r0,r6
000d5c  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000d60  e1a04000          MOV      r4,r0
;;;709    					VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;710    					&CurrentVCSELPulsePeriodPClk);
;;;711    
;;;712    		if (Status == VL53L0X_ERROR_NONE) {
000d64  e3540000          CMP      r4,#0
000d68  1a00000c          BNE      |L1.3488|
;;;713    			MsrcRangeTimeOutMClks = VL53L0X_calc_timeout_mclks(Dev,
000d6c  e5dd2010          LDRB     r2,[sp,#0x10]
000d70  e1a01007          MOV      r1,r7
000d74  e1a00006          MOV      r0,r6
000d78  ebfffffe          BL       VL53L0X_calc_timeout_mclks
000d7c  e1a0a800          LSL      r10,r0,#16
000d80  e1a0a82a          LSR      r10,r10,#16
;;;714    					TimeOutMicroSecs,
;;;715    					(uint8_t)CurrentVCSELPulsePeriodPClk);
;;;716    
;;;717    			if (MsrcRangeTimeOutMClks > 256)
000d84  e35a0c01          CMP      r10,#0x100
000d88  da000001          BLE      |L1.3476|
;;;718    				MsrcEncodedTimeOut = 255;
000d8c  e3a080ff          MOV      r8,#0xff
000d90  ea000001          B        |L1.3484|
                  |L1.3476|
;;;719    			else
;;;720    				MsrcEncodedTimeOut =
000d94  e24a0001          SUB      r0,r10,#1
000d98  e20080ff          AND      r8,r0,#0xff
                  |L1.3484|
;;;721    					(uint8_t)MsrcRangeTimeOutMClks - 1;
;;;722    
;;;723    			VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000d9c  e1c68db8          STRH     r8,[r6,#0xd8]
                  |L1.3488|
;;;724    				LastEncodedTimeout,
;;;725    				MsrcEncodedTimeOut);
;;;726    		}
;;;727    
;;;728    		if (Status == VL53L0X_ERROR_NONE) {
000da0  e3540000          CMP      r4,#0
000da4  1a00005e          BNE      |L1.3876|
;;;729    			Status = VL53L0X_WrByte(Dev,
000da8  e1a02008          MOV      r2,r8
000dac  e3a01046          MOV      r1,#0x46
000db0  e1a00006          MOV      r0,r6
000db4  ebfffffe          BL       VL53L0X_WrByte
000db8  e1a04000          MOV      r4,r0
000dbc  ea000058          B        |L1.3876|
                  |L1.3520|
;;;730    				VL53L0X_REG_MSRC_CONFIG_TIMEOUT_MACROP,
;;;731    				MsrcEncodedTimeOut);
;;;732    		}
;;;733    	} else {
;;;734    
;;;735    		if (SequenceStepId == VL53L0X_SEQUENCESTEP_PRE_RANGE) {
000dc0  e3550003          CMP      r5,#3
000dc4  1a00001c          BNE      |L1.3644|
;;;736    
;;;737    			if (Status == VL53L0X_ERROR_NONE) {
000dc8  e3540000          CMP      r4,#0
000dcc  1a00000f          BNE      |L1.3600|
;;;738    				Status = VL53L0X_GetVcselPulsePeriod(Dev,
000dd0  e28d2010          ADD      r2,sp,#0x10
000dd4  e3a01000          MOV      r1,#0
000dd8  e1a00006          MOV      r0,r6
000ddc  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000de0  e1a04000          MOV      r4,r0
;;;739    						VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;740    						&CurrentVCSELPulsePeriodPClk);
;;;741    				PreRangeTimeOutMClks =
000de4  e5dd2010          LDRB     r2,[sp,#0x10]
000de8  e1a01007          MOV      r1,r7
000dec  e1a00006          MOV      r0,r6
000df0  ebfffffe          BL       VL53L0X_calc_timeout_mclks
000df4  e1a09800          LSL      r9,r0,#16
000df8  e1a09829          LSR      r9,r9,#16
;;;742    					VL53L0X_calc_timeout_mclks(Dev,
;;;743    					TimeOutMicroSecs,
;;;744    					(uint8_t)CurrentVCSELPulsePeriodPClk);
;;;745    				PreRangeEncodedTimeOut = VL53L0X_encode_timeout(
000dfc  e1a00009          MOV      r0,r9
000e00  ebfffffe          BL       VL53L0X_encode_timeout
000e04  e58d000c          STR      r0,[sp,#0xc]
;;;746    					PreRangeTimeOutMClks);
;;;747    
;;;748    				VL53L0X_SETDEVICESPECIFICPARAMETER(Dev,
000e08  e1dd00bc          LDRH     r0,[sp,#0xc]
000e0c  e1c60db8          STRH     r0,[r6,#0xd8]
                  |L1.3600|
;;;749    					LastEncodedTimeout,
;;;750    					PreRangeEncodedTimeOut);
;;;751    			}
;;;752    
;;;753    			if (Status == VL53L0X_ERROR_NONE) {
000e10  e3540000          CMP      r4,#0
000e14  1a000004          BNE      |L1.3628|
;;;754    				Status = VL53L0X_WrWord(Dev,
000e18  e1dd20bc          LDRH     r2,[sp,#0xc]
000e1c  e3a01051          MOV      r1,#0x51
000e20  e1a00006          MOV      r0,r6
000e24  ebfffffe          BL       VL53L0X_WrWord
000e28  e1a04000          MOV      r4,r0
                  |L1.3628|
;;;755    				VL53L0X_REG_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI,
;;;756    				PreRangeEncodedTimeOut);
;;;757    			}
;;;758    
;;;759    			if (Status == VL53L0X_ERROR_NONE) {
000e2c  e3540000          CMP      r4,#0
000e30  1a00003b          BNE      |L1.3876|
;;;760    				VL53L0X_SETDEVICESPECIFICPARAMETER(
000e34  e58670e4          STR      r7,[r6,#0xe4]
000e38  ea000039          B        |L1.3876|
                  |L1.3644|
;;;761    					Dev,
;;;762    					PreRangeTimeoutMicroSecs,
;;;763    					TimeOutMicroSecs);
;;;764    			}
;;;765    		} else if (SequenceStepId == VL53L0X_SEQUENCESTEP_FINAL_RANGE) {
000e3c  e3550004          CMP      r5,#4
000e40  1a000036          BNE      |L1.3872|
;;;766    
;;;767    			/* For the final range timeout, the pre-range timeout
;;;768    			 * must be added. To do this both final and pre-range
;;;769    			 * timeouts must be expressed in macro periods MClks
;;;770    			 * because they have different vcsel periods.
;;;771    			 */
;;;772    
;;;773    			VL53L0X_GetSequenceStepEnables(Dev,
000e44  e1a0100d          MOV      r1,sp
000e48  e1a00006          MOV      r0,r6
000e4c  ebfffffe          BL       VL53L0X_GetSequenceStepEnables
;;;774    					&SchedulerSequenceSteps);
;;;775    			PreRangeTimeOutMClks = 0;
000e50  e3a09000          MOV      r9,#0
;;;776    			if (SchedulerSequenceSteps.PreRangeOn) {
000e54  e5dd0003          LDRB     r0,[sp,#3]
000e58  e3500000          CMP      r0,#0
000e5c  0a00000f          BEQ      |L1.3744|
;;;777    
;;;778    				/* Retrieve PRE-RANGE VCSEL Period */
;;;779    				Status = VL53L0X_GetVcselPulsePeriod(Dev,
000e60  e28d2010          ADD      r2,sp,#0x10
000e64  e3a01000          MOV      r1,#0
000e68  e1a00006          MOV      r0,r6
000e6c  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000e70  e1a04000          MOV      r4,r0
;;;780    					VL53L0X_VCSEL_PERIOD_PRE_RANGE,
;;;781    					&CurrentVCSELPulsePeriodPClk);
;;;782    
;;;783    				/* Retrieve PRE-RANGE Timeout in Macro periods
;;;784    				 * (MCLKS) */
;;;785    				if (Status == VL53L0X_ERROR_NONE) {
000e74  e3540000          CMP      r4,#0
000e78  1a000008          BNE      |L1.3744|
;;;786    					Status = VL53L0X_RdWord(Dev, 0x51,
000e7c  e28d200c          ADD      r2,sp,#0xc
000e80  e3a01051          MOV      r1,#0x51
000e84  e1a00006          MOV      r0,r6
000e88  ebfffffe          BL       VL53L0X_RdWord
000e8c  e1a04000          MOV      r4,r0
;;;787    						&PreRangeEncodedTimeOut);
;;;788    					PreRangeTimeOutMClks =
000e90  e1dd00bc          LDRH     r0,[sp,#0xc]
000e94  ebfffffe          BL       VL53L0X_decode_timeout
000e98  e1a09800          LSL      r9,r0,#16
000e9c  e1a09829          LSR      r9,r9,#16
                  |L1.3744|
;;;789    						VL53L0X_decode_timeout(
;;;790    							PreRangeEncodedTimeOut);
;;;791    				}
;;;792    			}
;;;793    
;;;794    			/* Calculate FINAL RANGE Timeout in Macro Periods
;;;795    			 * (MCLKS) and add PRE-RANGE value
;;;796    			 */
;;;797    			if (Status == VL53L0X_ERROR_NONE) {
000ea0  e3540000          CMP      r4,#0
000ea4  1a000004          BNE      |L1.3772|
;;;798    
;;;799    				Status = VL53L0X_GetVcselPulsePeriod(Dev,
000ea8  e28d2010          ADD      r2,sp,#0x10
000eac  e3a01001          MOV      r1,#1
000eb0  e1a00006          MOV      r0,r6
000eb4  ebfffffe          BL       VL53L0X_GetVcselPulsePeriod
000eb8  e1a04000          MOV      r4,r0
                  |L1.3772|
;;;800    						VL53L0X_VCSEL_PERIOD_FINAL_RANGE,
;;;801    						&CurrentVCSELPulsePeriodPClk);
;;;802    			}
;;;803    			if (Status == VL53L0X_ERROR_NONE) {
000ebc  e3540000          CMP      r4,#0
000ec0  1a000017          BNE      |L1.3876|
;;;804    
;;;805    				FinalRangeTimeOutMClks =
000ec4  e5dd2010          LDRB     r2,[sp,#0x10]
000ec8  e1a01007          MOV      r1,r7
000ecc  e1a00006          MOV      r0,r6
000ed0  ebfffffe          BL       VL53L0X_calc_timeout_mclks
000ed4  e1a0b800          LSL      r11,r0,#16
000ed8  e1a0b82b          LSR      r11,r11,#16
;;;806    					VL53L0X_calc_timeout_mclks(Dev,
;;;807    					TimeOutMicroSecs,
;;;808    					(uint8_t) CurrentVCSELPulsePeriodPClk);
;;;809    
;;;810    				FinalRangeTimeOutMClks += PreRangeTimeOutMClks;
000edc  e08b0009          ADD      r0,r11,r9
000ee0  e1a0b800          LSL      r11,r0,#16
000ee4  e1a0b82b          LSR      r11,r11,#16
;;;811    
;;;812    				FinalRangeEncodedTimeOut =
000ee8  e1a0000b          MOV      r0,r11
000eec  ebfffffe          BL       VL53L0X_encode_timeout
000ef0  e58d0008          STR      r0,[sp,#8]
;;;813    				VL53L0X_encode_timeout(FinalRangeTimeOutMClks);
;;;814    
;;;815    				if (Status == VL53L0X_ERROR_NONE) {
000ef4  e3540000          CMP      r4,#0
000ef8  1a000004          BNE      |L1.3856|
;;;816    					Status = VL53L0X_WrWord(Dev, 0x71,
000efc  e3a01071          MOV      r1,#0x71
000f00  e1a00006          MOV      r0,r6
000f04  e59d2008          LDR      r2,[sp,#8]
000f08  ebfffffe          BL       VL53L0X_WrWord
000f0c  e1a04000          MOV      r4,r0
                  |L1.3856|
;;;817    					FinalRangeEncodedTimeOut);
;;;818    				}
;;;819    
;;;820    				if (Status == VL53L0X_ERROR_NONE) {
000f10  e3540000          CMP      r4,#0
000f14  1a000002          BNE      |L1.3876|
;;;821    					VL53L0X_SETDEVICESPECIFICPARAMETER(
000f18  e58670dc          STR      r7,[r6,#0xdc]
000f1c  ea000000          B        |L1.3876|
                  |L1.3872|
;;;822    						Dev,
;;;823    						FinalRangeTimeoutMicroSecs,
;;;824    						TimeOutMicroSecs);
;;;825    				}
;;;826    			}
;;;827    		} else
;;;828    			Status = VL53L0X_ERROR_INVALID_PARAMS;
000f20  e3e04003          MVN      r4,#3
                  |L1.3876|
;;;829    
;;;830    	}
;;;831    	return Status;
000f24  e1a00004          MOV      r0,r4
000f28  e28dd014          ADD      sp,sp,#0x14
;;;832    }
000f2c  e8bd8ff0          POP      {r4-r11,pc}
;;;833    
                          ENDP

                  VL53L0X_set_vcsel_pulse_period PROC
;;;834    VL53L0X_Error VL53L0X_set_vcsel_pulse_period(VL53L0X_DEV Dev,
000f30  e92d4ff0          PUSH     {r4-r11,lr}
;;;835    	VL53L0X_VcselPeriod VcselPeriodType, uint8_t VCSELPulsePeriodPCLK)
;;;836    {
000f34  e24dd01c          SUB      sp,sp,#0x1c
000f38  e1a07000          MOV      r7,r0
000f3c  e1a06001          MOV      r6,r1
000f40  e1a05002          MOV      r5,r2
;;;837    	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
000f44  e3a04000          MOV      r4,#0
;;;838    	uint8_t vcsel_period_reg;
;;;839    	uint8_t MinPreVcselPeriodPCLK = 12;
000f48  e3a0900c          MOV      r9,#0xc
;;;840    	uint8_t MaxPreVcselPeriodPCLK = 18;
000f4c  e3a0a012          MOV      r10,#0x12
;;;841    	uint8_t MinFinalVcselPeriodPCLK = 8;
000f50  e3a0b008          MOV      r11,#8
;;;842    	uint8_t MaxFinalVcselPeriodPCLK = 14;
000f54  e3a0000e          MOV      r0,#0xe
000f58  e58d0014          STR      r0,[sp,#0x14]
;;;843    	uint32_t MeasurementTimingBudgetMicroSeconds;
;;;844    	uint32_t FinalRangeTimeoutMicroSeconds;
;;;845    	uint32_t PreRangeTimeoutMicroSeconds;
;;;846    	uint32_t MsrcTimeoutMicroSeconds;
;;;847    	uint8_t PhaseCalInt = 0;
000f5c  e3a00000          MOV      r0,#0
000f60  e58d0004          STR      r0,[sp,#4]
;;;848    
;;;849    	/* Check if valid clock period requested */
;;;850    
;;;851    	if ((VCSELPulsePeriodPCLK % 2) != 0) {
000f64  e1a00005          MOV      r0,r5
000f68  e0851fa0          ADD      r1,r5,r0,LSR #31
000f6c  e1a010c1          ASR      r1,r1,#1
000f70  e0551081          SUBS     r1,r5,r1,LSL #1
000f74  0a000001          BEQ      |L1.3968|
;;;852    		/* Value must be an even number */
;;;853    		Status = VL53L0X_ERROR_INVALID_PARAMS;
000f78  e3e04003          MVN      r4,#3
000f7c  ea00000f          B        |L1.4032|
                  |L1.3968|
;;;854    	} else if (VcselPeriodType == VL53L0X_VCSEL_PERIOD_PRE_RANGE &&
000f80  e3560000          CMP      r6,#0
000f84  1a000005          BNE      |L1.4000|
;;;855    		(VCSELPulsePeriodPCLK < MinPreVcselPeriodPCLK ||
000f88  e1550009          CMP      r5,r9
000f8c  ba000001          BLT      |L1.3992|
;;;856    		VCSELPulsePeriodPCLK > MaxPreVcselPeriodPCLK)) {
000f90  e155000a          CMP      r5,r10
000f94  da000001          BLE      |L1.4000|
                  |L1.3992|
;;;857    		Status = VL53L0X_ERROR_INVALID_PARAMS;
000f98  e3e04003          MVN      r4,#3
000f9c  ea000007          B        |L1.4032|
                  |L1.4000|
;;;858    	} else if (VcselPeriodType == VL53L0X_VCSEL_PERIOD_FINAL_RANGE &&
000fa0  e3560001          CMP      r6,#1
000fa4  1a000005          BNE      |L1.4032|
;;;859    		(VCSELPulsePeriodPCLK < MinFinalVcselPeriodPCLK ||
000fa8  e155000b          CMP      r5,r11
000fac  ba000002          BLT      |L1.4028|
;;;860    		 VCSELPulsePeriodPCLK > MaxFinalVcselPeriodPCLK)) {
000fb0  e59d0014          LDR      r0,[sp,#0x14]
000fb4  e1550000          CMP      r5,r0
000fb8  da000000          BLE      |L1.4032|
                  |L1.4028|
;;;861    
;;;862    		Status = VL53L0X_ERROR_INVALID_PARAMS;
000fbc  e3e04003          MVN      r4,#3
                  |L1.4032|
;;;863    	}
;;;864    
;;;865    	/* Apply specific settings for the requested clock period */
;;;866    
;;;867    	if (Status != VL53L0X_ERROR_NONE)
000fc0  e3540000          CMP      r4,#0
000fc4  0a000002          BEQ      |L1.4052|
;;;868    		return Status;
000fc8  e1a00004          MOV      r0,r4
                  |L1.4044|
000fcc  e28dd01c          ADD      sp,sp,#0x1c
;;;869    
;;;870    
;;;871    	if (VcselPeriodType == VL53L0X_VCSEL_PERIOD_PRE_RANGE) {
;;;872    
;;;873    		/* Set phase check limits */
;;;874    		if (VCSELPulsePeriodPCLK == 12) {
;;;875    
;;;876    			Status = VL53L0X_WrByte(Dev,
;;;877    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;878    				0x18);
;;;879    			Status = VL53L0X_WrByte(Dev,
;;;880    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_LOW,
;;;881    				0x08);
;;;882    		} else if (VCSELPulsePeriodPCLK == 14) {
;;;883    
;;;884    			Status = VL53L0X_WrByte(Dev,
;;;885    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;886    				0x30);
;;;887    			Status = VL53L0X_WrByte(Dev,
;;;888    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_LOW,
;;;889    				0x08);
;;;890    		} else if (VCSELPulsePeriodPCLK == 16) {
;;;891    
;;;892    			Status = VL53L0X_WrByte(Dev,
;;;893    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;894    				0x40);
;;;895    			Status = VL53L0X_WrByte(Dev,
;;;896    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_LOW,
;;;897    				0x08);
;;;898    		} else if (VCSELPulsePeriodPCLK == 18) {
;;;899    
;;;900    			Status = VL53L0X_WrByte(Dev,
;;;901    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;902    				0x50);
;;;903    			Status = VL53L0X_WrByte(Dev,
;;;904    				VL53L0X_REG_PRE_RANGE_CONFIG_VALID_PHASE_LOW,
;;;905    				0x08);
;;;906    		}
;;;907    	} else if (VcselPeriodType == VL53L0X_VCSEL_PERIOD_FINAL_RANGE) {
;;;908    
;;;909    		if (VCSELPulsePeriodPCLK == 8) {
;;;910    
;;;911    			Status = VL53L0X_WrByte(Dev,
;;;912    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;913    				0x10);
;;;914    			Status = VL53L0X_WrByte(Dev,
;;;915    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_LOW,
;;;916    				0x08);
;;;917    
;;;918    			Status |= VL53L0X_WrByte(Dev,
;;;919    				VL53L0X_REG_GLOBAL_CONFIG_VCSEL_WIDTH, 0x02);
;;;920    			Status |= VL53L0X_WrByte(Dev,
;;;921    				VL53L0X_REG_ALGO_PHASECAL_CONFIG_TIMEOUT, 0x0C);
;;;922    
;;;923    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
;;;924    			Status |= VL53L0X_WrByte(Dev,
;;;925    				VL53L0X_REG_ALGO_PHASECAL_LIM,
;;;926    				0x30);
;;;927    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
;;;928    		} else if (VCSELPulsePeriodPCLK == 10) {
;;;929    
;;;930    			Status = VL53L0X_WrByte(Dev,
;;;931    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;932    				0x28);
;;;933    			Status = VL53L0X_WrByte(Dev,
;;;934    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_LOW,
;;;935    				0x08);
;;;936    
;;;937    			Status |= VL53L0X_WrByte(Dev,
;;;938    				VL53L0X_REG_GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);
;;;939    			Status |= VL53L0X_WrByte(Dev,
;;;940    				VL53L0X_REG_ALGO_PHASECAL_CONFIG_TIMEOUT, 0x09);
;;;941    
;;;942    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
;;;943    			Status |= VL53L0X_WrByte(Dev,
;;;944    				VL53L0X_REG_ALGO_PHASECAL_LIM,
;;;945    				0x20);
;;;946    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
;;;947    		} else if (VCSELPulsePeriodPCLK == 12) {
;;;948    
;;;949    			Status = VL53L0X_WrByte(Dev,
;;;950    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;951    				0x38);
;;;952    			Status = VL53L0X_WrByte(Dev,
;;;953    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_LOW,
;;;954    				0x08);
;;;955    
;;;956    			Status |= VL53L0X_WrByte(Dev,
;;;957    				VL53L0X_REG_GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);
;;;958    			Status |= VL53L0X_WrByte(Dev,
;;;959    				VL53L0X_REG_ALGO_PHASECAL_CONFIG_TIMEOUT, 0x08);
;;;960    
;;;961    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
;;;962    			Status |= VL53L0X_WrByte(Dev,
;;;963    				VL53L0X_REG_ALGO_PHASECAL_LIM,
;;;964    				0x20);
;;;965    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
;;;966    		} else if (VCSELPulsePeriodPCLK == 14) {
;;;967    
;;;968    			Status = VL53L0X_WrByte(Dev,
;;;969    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_HIGH,
;;;970    				0x048);
;;;971    			Status = VL53L0X_WrByte(Dev,
;;;972    				VL53L0X_REG_FINAL_RANGE_CONFIG_VALID_PHASE_LOW,
;;;973    				0x08);
;;;974    
;;;975    			Status |= VL53L0X_WrByte(Dev,
;;;976    				VL53L0X_REG_GLOBAL_CONFIG_VCSEL_WIDTH, 0x03);
;;;977    			Status |= VL53L0X_WrByte(Dev,
;;;978    				VL53L0X_REG_ALGO_PHASECAL_CONFIG_TIMEOUT, 0x07);
;;;979    
;;;980    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x01);
;;;981    			Status |= VL53L0X_WrByte(Dev,
;;;982    				VL53L0X_REG_ALGO_PHASECAL_LIM,
;;;983    				0x20);
;;;984    			Status |= VL53L0X_WrByte(Dev, 0xff, 0x00);
;;;985    		}
;;;986    	}
;;;987    
;;;988    
;;;989    	/* Re-calculate and apply timeouts, in macro periods */
;;;990    
;;;991    	if (Status == VL53L0X_ERROR_NONE) {
;;;992    		vcsel_period_reg = VL53L0X_encode_vcsel_period((uint8_t)
;;;993    			VCSELPulsePeriodPCLK);
;;;994    
;;;995    		/* When the VCSEL period for the pre or final range is changed,
;;;996    		* the corresponding timeout must be read from the device using
;;;997    		* the current VCSEL period, then the new VCSEL period can be
;;;998    		* applied. The timeout then must be written back to the device
;;;999    		* using the new VCSEL period.
;;;1000   		*
;;;1001   		* For the MSRC timeout, the same applies - this timeout being
;;;1002   		* dependant on the pre-range vcsel period.
;;;1003   		*/
;;;1004   		switch (VcselPeriodType) {
;;;1005   		case VL53L0X_VCSEL_PERIOD_PRE_RANGE:
;;;1006   			Status = get_sequence_step_timeout(Dev,
;;;1007   				VL53L0X_SEQUENCESTEP_PRE_RANGE,
;;;1008   				&PreRangeTimeoutMicroSeconds);
;;;1009   
;;;1010   			if (Status == VL53L0X_ERROR_NONE)
;;;1011   				Status = get_sequence_step_timeout(Dev,
;;;1012   					VL53L0X_SEQUENCESTEP_MSRC,
;;;1013   					&MsrcTimeoutMicroSeconds);
;;;1014   
;;;1015   			if (Status == VL53L0X_ERROR_NONE)
;;;1016   				Status = VL53L0X_WrByte(Dev,
;;;1017   				VL53L0X_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD,
;;;1018   					vcsel_period_reg);
;;;1019   
;;;1020   
;;;1021   			if (Status == VL53L0X_ERROR_NONE)
;;;1022   				Status = set_sequence_step_timeout(Dev,
;;;1023   					VL53L0X_SEQUENCESTEP_PRE_RANGE,
;;;1024   					PreRangeTimeoutMicroSeconds);
;;;1025   
;;;1026   
;;;1027   			if (Status == VL53L0X_ERROR_NONE)
;;;1028   				Status = set_sequence_step_timeout(Dev,
;;;1029   					VL53L0X_SEQUENCESTEP_MSRC,
;;;1030   					MsrcTimeoutMicroSeconds);
;;;1031   
;;;1032   			VL53L0X_SETDEVICESPECIFICPARAMETER(
;;;1033   				Dev,
;;;1034   				PreRangeVcselPulsePeriod,
;;;1035   				VCSELPulsePeriodPCLK);
;;;1036   			break;
;;;1037   		case VL53L0X_VCSEL_PERIOD_FINAL_RANGE:
;;;1038   			Status = get_sequence_step_timeout(Dev,
;;;1039   				VL53L0X_SEQUENCESTEP_FINAL_RANGE,
;;;1040   				&FinalRangeTimeoutMicroSeconds);
;;;1041   
;;;1042   			if (Status == VL53L0X_ERROR_NONE)
;;;1043   				Status = VL53L0X_WrByte(Dev,
;;;1044   				VL53L0X_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD,
;;;1045   					vcsel_period_reg);
;;;1046   
;;;1047   
;;;1048   			if (Status == VL53L0X_ERROR_NONE)
;;;1049   				Status = set_sequence_step_timeout(Dev,
;;;1050   					VL53L0X_SEQUENCESTEP_FINAL_RANGE,
;;;1051   					FinalRangeTimeoutMicroSeconds);
;;;1052   
;;;1053   			VL53L0X_SETDEVICESPECIFICPARAMETER(
;;;1054   				Dev,
;;;1055   				FinalRangeVcselPulsePeriod,
;;;1056   				VCSELPulsePeriodPCLK);
;;;1057   			break;
;;;1058   		default:
;;;1059   			Status = VL53L0X_ERROR_INVALID_PARAMS;
;;;1060   		}
;;;1061   	}
;;;1062   
;;;1063   	/* Finally, the timing budget must be re-applied */
;;;1064   	if (Status == VL53L0X_ERROR_NONE) {
;;;1065   		VL53L0X_GETPARAMETERFIELD(Dev,
;;;1066   			MeasurementTimingBudgetMicroSeconds,
;;;1067   			MeasurementTimingBudgetMicroSeconds);
;;;1068   
;;;1069   		Status = VL53L0X_SetMeasurementTimingBudgetMicroSeconds(Dev,
;;;1070   				MeasurementTimingBudgetMicroSeconds);
;;;1071   	}
;;;1072   
;;;1073   	/* Perform the phase calibration. This is needed after changing on
;;;1074   	 * vcsel period.
;;;1075   	 * get_data_enable = 0, restore_config = 1 */
;;;1076   	if (Status == VL53L0X_ERROR_NONE)
;;;1077   		Status = VL53L0X_perform_phase_calibration(
;;;1078   			Dev, &PhaseCalInt, 0, 1);
;;;1079   
;;;1080   	return Status;
;;;1081   }
000fd0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4052|
000fd4  e3560000          CMP      r6,#0                 ;871
000fd8  1a000035          BNE      |L1.4276|
000fdc  e355000c          CMP      r5,#0xc               ;874
000fe0  1a00000a          BNE      |L1.4112|
000fe4  e3a02018          MOV      r2,#0x18              ;876
000fe8  e3a01057          MOV      r1,#0x57              ;876
000fec  e1a00007          MOV      r0,r7                 ;876
000ff0  ebfffffe          BL       VL53L0X_WrByte
000ff4  e1a04000          MOV      r4,r0                 ;876
000ff8  e3a02008          MOV      r2,#8                 ;879
000ffc  e3a01056          MOV      r1,#0x56              ;879
001000  e1a00007          MOV      r0,r7                 ;879
001004  ebfffffe          BL       VL53L0X_WrByte
001008  e1a04000          MOV      r4,r0                 ;879
00100c  ea0000c1          B        |L1.4888|
                  |L1.4112|
001010  e355000e          CMP      r5,#0xe               ;882
001014  1a00000c          BNE      |L1.4172|
001018  e3a02030          MOV      r2,#0x30              ;884
00101c  e3a01057          MOV      r1,#0x57              ;884
001020  e1a00007          MOV      r0,r7                 ;884
001024  ebfffffe          BL       VL53L0X_WrByte
001028  e1a04000          MOV      r4,r0                 ;884
00102c  e3a02008          MOV      r2,#8                 ;887
001030  e3a01056          MOV      r1,#0x56              ;887
001034  e1a00007          MOV      r0,r7                 ;887
001038  ebfffffe          BL       VL53L0X_WrByte
00103c  e1a04000          MOV      r4,r0                 ;887
001040  ea0000b4          B        |L1.4888|
                  |L1.4164|
                          DCD      0x0000ffff
                  |L1.4168|
                          DCD      0x00000677
                  |L1.4172|
00104c  e3550010          CMP      r5,#0x10              ;890
001050  1a00000a          BNE      |L1.4224|
001054  e3a02040          MOV      r2,#0x40              ;892
001058  e3a01057          MOV      r1,#0x57              ;892
00105c  e1a00007          MOV      r0,r7                 ;892
001060  ebfffffe          BL       VL53L0X_WrByte
001064  e1a04000          MOV      r4,r0                 ;892
001068  e3a02008          MOV      r2,#8                 ;895
00106c  e3a01056          MOV      r1,#0x56              ;895
001070  e1a00007          MOV      r0,r7                 ;895
001074  ebfffffe          BL       VL53L0X_WrByte
001078  e1a04000          MOV      r4,r0                 ;895
00107c  ea0000a5          B        |L1.4888|
                  |L1.4224|
001080  e3550012          CMP      r5,#0x12              ;898
001084  1a0000a3          BNE      |L1.4888|
001088  e3a02050          MOV      r2,#0x50              ;900
00108c  e3a01057          MOV      r1,#0x57              ;900
001090  e1a00007          MOV      r0,r7                 ;900
001094  ebfffffe          BL       VL53L0X_WrByte
001098  e1a04000          MOV      r4,r0                 ;900
00109c  e3a02008          MOV      r2,#8                 ;903
0010a0  e3a01056          MOV      r1,#0x56              ;903
0010a4  e1a00007          MOV      r0,r7                 ;903
0010a8  ebfffffe          BL       VL53L0X_WrByte
0010ac  e1a04000          MOV      r4,r0                 ;903
0010b0  ea000098          B        |L1.4888|
                  |L1.4276|
0010b4  e3560001          CMP      r6,#1                 ;907
0010b8  1a000096          BNE      |L1.4888|
0010bc  e3550008          CMP      r5,#8                 ;909
0010c0  1a000023          BNE      |L1.4436|
0010c4  e3a02010          MOV      r2,#0x10              ;911
0010c8  e3a01048          MOV      r1,#0x48              ;911
0010cc  e1a00007          MOV      r0,r7                 ;911
0010d0  ebfffffe          BL       VL53L0X_WrByte
0010d4  e1a04000          MOV      r4,r0                 ;911
0010d8  e3a02008          MOV      r2,#8                 ;914
0010dc  e3a01047          MOV      r1,#0x47              ;914
0010e0  e1a00007          MOV      r0,r7                 ;914
0010e4  ebfffffe          BL       VL53L0X_WrByte
0010e8  e1a04000          MOV      r4,r0                 ;914
0010ec  e3a02002          MOV      r2,#2                 ;918
0010f0  e3a01032          MOV      r1,#0x32              ;918
0010f4  e1a00007          MOV      r0,r7                 ;918
0010f8  ebfffffe          BL       VL53L0X_WrByte
0010fc  e1844000          ORR      r4,r4,r0              ;918
001100  e3a0200c          MOV      r2,#0xc               ;920
001104  e3a01030          MOV      r1,#0x30              ;920
001108  e1a00007          MOV      r0,r7                 ;920
00110c  ebfffffe          BL       VL53L0X_WrByte
001110  e1844000          ORR      r4,r4,r0              ;920
001114  e3a02001          MOV      r2,#1                 ;923
001118  e3a010ff          MOV      r1,#0xff              ;923
00111c  e1a00007          MOV      r0,r7                 ;923
001120  ebfffffe          BL       VL53L0X_WrByte
001124  e1844000          ORR      r4,r4,r0              ;923
001128  e3a02030          MOV      r2,#0x30              ;924
00112c  e1a01002          MOV      r1,r2                 ;924
001130  e1a00007          MOV      r0,r7                 ;924
001134  ebfffffe          BL       VL53L0X_WrByte
001138  e1844000          ORR      r4,r4,r0              ;924
00113c  e3a02000          MOV      r2,#0                 ;927
001140  e3a010ff          MOV      r1,#0xff              ;927
001144  e1a00007          MOV      r0,r7                 ;927
001148  ebfffffe          BL       VL53L0X_WrByte
00114c  e1844000          ORR      r4,r4,r0              ;927
001150  ea000070          B        |L1.4888|
                  |L1.4436|
001154  e355000a          CMP      r5,#0xa               ;928
001158  1a000023          BNE      |L1.4588|
00115c  e3a02028          MOV      r2,#0x28              ;930
001160  e3a01048          MOV      r1,#0x48              ;930
001164  e1a00007          MOV      r0,r7                 ;930
001168  ebfffffe          BL       VL53L0X_WrByte
00116c  e1a04000          MOV      r4,r0                 ;930
001170  e3a02008          MOV      r2,#8                 ;933
001174  e3a01047          MOV      r1,#0x47              ;933
001178  e1a00007          MOV      r0,r7                 ;933
00117c  ebfffffe          BL       VL53L0X_WrByte
001180  e1a04000          MOV      r4,r0                 ;933
001184  e3a02003          MOV      r2,#3                 ;937
001188  e3a01032          MOV      r1,#0x32              ;937
00118c  e1a00007          MOV      r0,r7                 ;937
001190  ebfffffe          BL       VL53L0X_WrByte
001194  e1844000          ORR      r4,r4,r0              ;937
001198  e3a02009          MOV      r2,#9                 ;939
00119c  e3a01030          MOV      r1,#0x30              ;939
0011a0  e1a00007          MOV      r0,r7                 ;939
0011a4  ebfffffe          BL       VL53L0X_WrByte
0011a8  e1844000          ORR      r4,r4,r0              ;939
0011ac  e3a02001          MOV      r2,#1                 ;942
0011b0  e3a010ff          MOV      r1,#0xff              ;942
0011b4  e1a00007          MOV      r0,r7                 ;942
0011b8  ebfffffe          BL       VL53L0X_WrByte
0011bc  e1844000          ORR      r4,r4,r0              ;942
0011c0  e3a02020          MOV      r2,#0x20              ;943
0011c4  e3a01030          MOV      r1,#0x30              ;943
0011c8  e1a00007          MOV      r0,r7                 ;943
0011cc  ebfffffe          BL       VL53L0X_WrByte
0011d0  e1844000          ORR      r4,r4,r0              ;943
0011d4  e3a02000          MOV      r2,#0                 ;946
0011d8  e3a010ff          MOV      r1,#0xff              ;946
0011dc  e1a00007          MOV      r0,r7                 ;946
0011e0  ebfffffe          BL       VL53L0X_WrByte
0011e4  e1844000          ORR      r4,r4,r0              ;946
0011e8  ea00004a          B        |L1.4888|
                  |L1.4588|
0011ec  e355000c          CMP      r5,#0xc               ;947
0011f0  1a000023          BNE      |L1.4740|
0011f4  e3a02038          MOV      r2,#0x38              ;949
0011f8  e3a01048          MOV      r1,#0x48              ;949
0011fc  e1a00007          MOV      r0,r7                 ;949
001200  ebfffffe          BL       VL53L0X_WrByte
001204  e1a04000          MOV      r4,r0                 ;949
001208  e3a02008          MOV      r2,#8                 ;952
00120c  e3a01047          MOV      r1,#0x47              ;952
001210  e1a00007          MOV      r0,r7                 ;952
001214  ebfffffe          BL       VL53L0X_WrByte
001218  e1a04000          MOV      r4,r0                 ;952
00121c  e3a02003          MOV      r2,#3                 ;956
001220  e3a01032          MOV      r1,#0x32              ;956
001224  e1a00007          MOV      r0,r7                 ;956
001228  ebfffffe          BL       VL53L0X_WrByte
00122c  e1844000          ORR      r4,r4,r0              ;956
001230  e3a02008          MOV      r2,#8                 ;958
001234  e3a01030          MOV      r1,#0x30              ;958
001238  e1a00007          MOV      r0,r7                 ;958
00123c  ebfffffe          BL       VL53L0X_WrByte
001240  e1844000          ORR      r4,r4,r0              ;958
001244  e3a02001          MOV      r2,#1                 ;961
001248  e3a010ff          MOV      r1,#0xff              ;961
00124c  e1a00007          MOV      r0,r7                 ;961
001250  ebfffffe          BL       VL53L0X_WrByte
001254  e1844000          ORR      r4,r4,r0              ;961
001258  e3a02020          MOV      r2,#0x20              ;962
00125c  e3a01030          MOV      r1,#0x30              ;962
001260  e1a00007          MOV      r0,r7                 ;962
001264  ebfffffe          BL       VL53L0X_WrByte
001268  e1844000          ORR      r4,r4,r0              ;962
00126c  e3a02000          MOV      r2,#0                 ;965
001270  e3a010ff          MOV      r1,#0xff              ;965
001274  e1a00007          MOV      r0,r7                 ;965
001278  ebfffffe          BL       VL53L0X_WrByte
00127c  e1844000          ORR      r4,r4,r0              ;965
001280  ea000024          B        |L1.4888|
                  |L1.4740|
001284  e355000e          CMP      r5,#0xe               ;966
001288  1a000022          BNE      |L1.4888|
00128c  e3a02048          MOV      r2,#0x48              ;968
001290  e1a01002          MOV      r1,r2                 ;968
001294  e1a00007          MOV      r0,r7                 ;968
001298  ebfffffe          BL       VL53L0X_WrByte
00129c  e1a04000          MOV      r4,r0                 ;968
0012a0  e3a02008          MOV      r2,#8                 ;971
0012a4  e3a01047          MOV      r1,#0x47              ;971
0012a8  e1a00007          MOV      r0,r7                 ;971
0012ac  ebfffffe          BL       VL53L0X_WrByte
0012b0  e1a04000          MOV      r4,r0                 ;971
0012b4  e3a02003          MOV      r2,#3                 ;975
0012b8  e3a01032          MOV      r1,#0x32              ;975
0012bc  e1a00007          MOV      r0,r7                 ;975
0012c0  ebfffffe          BL       VL53L0X_WrByte
0012c4  e1844000          ORR      r4,r4,r0              ;975
0012c8  e3a02007          MOV      r2,#7                 ;977
0012cc  e3a01030          MOV      r1,#0x30              ;977
0012d0  e1a00007          MOV      r0,r7                 ;977
0012d4  ebfffffe          BL       VL53L0X_WrByte
0012d8  e1844000          ORR      r4,r4,r0              ;977
0012dc  e3a02001          MOV      r2,#1                 ;980
0012e0  e3a010ff          MOV      r1,#0xff              ;980
0012e4  e1a00007          MOV      r0,r7                 ;980
0012e8  ebfffffe          BL       VL53L0X_WrByte
0012ec  e1844000          ORR      r4,r4,r0              ;980
0012f0  e3a02020          MOV      r2,#0x20              ;981
0012f4  e3a01030          MOV      r1,#0x30              ;981
0012f8  e1a00007          MOV      r0,r7                 ;981
0012fc  ebfffffe          BL       VL53L0X_WrByte
001300  e1844000          ORR      r4,r4,r0              ;981
001304  e3a02000          MOV      r2,#0                 ;984
001308  e3a010ff          MOV      r1,#0xff              ;984
00130c  e1a00007          MOV      r0,r7                 ;984
001310  ebfffffe          BL       VL53L0X_WrByte
001314  e1844000          ORR      r4,r4,r0              ;984
                  |L1.4888|
001318  e3540000          CMP      r4,#0                 ;991
00131c  1a000045          BNE      |L1.5176|
001320  e1a00005          MOV      r0,r5                 ;992
001324  ebfffffe          BL       VL53L0X_encode_vcsel_period
001328  e58d0018          STR      r0,[sp,#0x18]         ;992
00132c  e3560000          CMP      r6,#0                 ;1004
001330  0a000002          BEQ      |L1.4928|
001334  e3560001          CMP      r6,#1                 ;1004
001338  1a00003a          BNE      |L1.5160|
00133c  ea000023          B        |L1.5072|
                  |L1.4928|
001340  e1a00000          MOV      r0,r0                 ;1005
001344  e28d200c          ADD      r2,sp,#0xc            ;1006
001348  e3a01003          MOV      r1,#3                 ;1006
00134c  e1a00007          MOV      r0,r7                 ;1006
001350  ebfffffe          BL       get_sequence_step_timeout
001354  e1a04000          MOV      r4,r0                 ;1006
001358  e3540000          CMP      r4,#0                 ;1010
00135c  1a000004          BNE      |L1.4980|
001360  e28d2008          ADD      r2,sp,#8              ;1011
001364  e3a01002          MOV      r1,#2                 ;1011
001368  e1a00007          MOV      r0,r7                 ;1011
00136c  ebfffffe          BL       get_sequence_step_timeout
001370  e1a04000          MOV      r4,r0                 ;1011
                  |L1.4980|
001374  e3540000          CMP      r4,#0                 ;1015
001378  1a000004          BNE      |L1.5008|
00137c  e3a01050          MOV      r1,#0x50              ;1016
001380  e1a00007          MOV      r0,r7                 ;1016
001384  e59d2018          LDR      r2,[sp,#0x18]         ;1016
001388  ebfffffe          BL       VL53L0X_WrByte
00138c  e1a04000          MOV      r4,r0                 ;1016
                  |L1.5008|
001390  e3540000          CMP      r4,#0                 ;1021
001394  1a000004          BNE      |L1.5036|
001398  e3a01003          MOV      r1,#3                 ;1022
00139c  e1a00007          MOV      r0,r7                 ;1022
0013a0  e59d200c          LDR      r2,[sp,#0xc]          ;1022
0013a4  ebfffffe          BL       set_sequence_step_timeout
0013a8  e1a04000          MOV      r4,r0                 ;1022
                  |L1.5036|
0013ac  e3540000          CMP      r4,#0                 ;1027
0013b0  1a000004          BNE      |L1.5064|
0013b4  e3a01002          MOV      r1,#2                 ;1028
0013b8  e1a00007          MOV      r0,r7                 ;1028
0013bc  e59d2008          LDR      r2,[sp,#8]            ;1028
0013c0  ebfffffe          BL       set_sequence_step_timeout
0013c4  e1a04000          MOV      r4,r0                 ;1028
                  |L1.5064|
0013c8  e5c750e8          STRB     r5,[r7,#0xe8]         ;1032
0013cc  ea000018          B        |L1.5172|
                  |L1.5072|
0013d0  e1a00000          MOV      r0,r0                 ;1037
0013d4  e28d2010          ADD      r2,sp,#0x10           ;1038
0013d8  e3a01004          MOV      r1,#4                 ;1038
0013dc  e1a00007          MOV      r0,r7                 ;1038
0013e0  ebfffffe          BL       get_sequence_step_timeout
0013e4  e1a04000          MOV      r4,r0                 ;1038
0013e8  e3540000          CMP      r4,#0                 ;1042
0013ec  1a000004          BNE      |L1.5124|
0013f0  e3a01070          MOV      r1,#0x70              ;1043
0013f4  e1a00007          MOV      r0,r7                 ;1043
0013f8  e59d2018          LDR      r2,[sp,#0x18]         ;1043
0013fc  ebfffffe          BL       VL53L0X_WrByte
001400  e1a04000          MOV      r4,r0                 ;1043
                  |L1.5124|
001404  e3540000          CMP      r4,#0                 ;1048
001408  1a000004          BNE      |L1.5152|
00140c  e3a01004          MOV      r1,#4                 ;1049
001410  e1a00007          MOV      r0,r7                 ;1049
001414  e59d2010          LDR      r2,[sp,#0x10]         ;1049
001418  ebfffffe          BL       set_sequence_step_timeout
00141c  e1a04000          MOV      r4,r0                 ;1049
                  |L1.5152|
001420  e5c750e0          STRB     r5,[r7,#0xe0]         ;1053
001424  ea000002          B        |L1.5172|
                  |L1.5160|
001428  e1a00000          MOV      r0,r0                 ;1058
00142c  e3e04003          MVN      r4,#3                 ;1059
001430  e1a00000          MOV      r0,r0                 ;1004
                  |L1.5172|
001434  e1a00000          MOV      r0,r0                 ;1036
                  |L1.5176|
001438  e3540000          CMP      r4,#0                 ;1064
00143c  1a000004          BNE      |L1.5204|
001440  e5978014          LDR      r8,[r7,#0x14]         ;1065
001444  e1a01008          MOV      r1,r8                 ;1069
001448  e1a00007          MOV      r0,r7                 ;1069
00144c  ebfffffe          BL       VL53L0X_SetMeasurementTimingBudgetMicroSeconds
001450  e1a04000          MOV      r4,r0                 ;1069
                  |L1.5204|
001454  e3540000          CMP      r4,#0                 ;1076
001458  1a000005          BNE      |L1.5236|
00145c  e3a03001          MOV      r3,#1                 ;1077
001460  e3a02000          MOV      r2,#0                 ;1077
001464  e28d1004          ADD      r1,sp,#4              ;1077
001468  e1a00007          MOV      r0,r7                 ;1077
00146c  ebfffffe          BL       VL53L0X_perform_phase_calibration
001470  e1a04000          MOV      r4,r0                 ;1077
                  |L1.5236|
001474  e1a00004          MOV      r0,r4                 ;1080
001478  eafffed3          B        |L1.4044|
;;;1082   
                          ENDP

                  VL53L0X_get_vcsel_pulse_period PROC
;;;1083   VL53L0X_Error VL53L0X_get_vcsel_pulse_period(VL53L0X_DEV Dev,
00147c  e92d40f8          PUSH     {r3-r7,lr}
;;;1084   	VL53L0X_VcselPeriod VcselPeriodType, uint8_t *pVCSELPulsePeriodPCLK)
;;;1085   {
001480  e1a07000          MOV      r7,r0
001484  e1a04001          MOV      r4,r1
001488  e1a05002          MOV      r5,r2
;;;1086   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00148c  e3a06000          MOV      r6,#0
;;;1087   	uint8_t vcsel_period_reg;
;;;1088   
;;;1089   	switch (VcselPeriodType) {
001490  e3540000          CMP      r4,#0
001494  0a000002          BEQ      |L1.5284|
001498  e3540001          CMP      r4,#1
00149c  1a00000e          BNE      |L1.5340|
0014a0  ea000006          B        |L1.5312|
                  |L1.5284|
;;;1090   	case VL53L0X_VCSEL_PERIOD_PRE_RANGE:
0014a4  e1a00000          MOV      r0,r0
;;;1091   		Status = VL53L0X_RdByte(Dev,
0014a8  e1a0200d          MOV      r2,sp
0014ac  e3a01050          MOV      r1,#0x50
0014b0  e1a00007          MOV      r0,r7
0014b4  ebfffffe          BL       VL53L0X_RdByte
0014b8  e1a06000          MOV      r6,r0
;;;1092   			VL53L0X_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD,
;;;1093   			&vcsel_period_reg);
;;;1094   	break;
0014bc  ea000009          B        |L1.5352|
                  |L1.5312|
;;;1095   	case VL53L0X_VCSEL_PERIOD_FINAL_RANGE:
0014c0  e1a00000          MOV      r0,r0
;;;1096   		Status = VL53L0X_RdByte(Dev,
0014c4  e1a0200d          MOV      r2,sp
0014c8  e3a01070          MOV      r1,#0x70
0014cc  e1a00007          MOV      r0,r7
0014d0  ebfffffe          BL       VL53L0X_RdByte
0014d4  e1a06000          MOV      r6,r0
;;;1097   			VL53L0X_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD,
;;;1098   			&vcsel_period_reg);
;;;1099   	break;
0014d8  ea000002          B        |L1.5352|
                  |L1.5340|
;;;1100   	default:
0014dc  e1a00000          MOV      r0,r0
;;;1101   		Status = VL53L0X_ERROR_INVALID_PARAMS;
0014e0  e3e06003          MVN      r6,#3
0014e4  e1a00000          MOV      r0,r0                 ;1089
                  |L1.5352|
0014e8  e1a00000          MOV      r0,r0                 ;1094
;;;1102   	}
;;;1103   
;;;1104   	if (Status == VL53L0X_ERROR_NONE)
0014ec  e3560000          CMP      r6,#0
0014f0  1a000002          BNE      |L1.5376|
;;;1105   		*pVCSELPulsePeriodPCLK =
0014f4  e5dd0000          LDRB     r0,[sp,#0]
0014f8  ebfffffe          BL       VL53L0X_decode_vcsel_period
0014fc  e5c50000          STRB     r0,[r5,#0]
                  |L1.5376|
;;;1106   			VL53L0X_decode_vcsel_period(vcsel_period_reg);
;;;1107   
;;;1108   	return Status;
001500  e1a00006          MOV      r0,r6
;;;1109   }
001504  e8bd80f8          POP      {r3-r7,pc}
;;;1110   
                          ENDP

                  VL53L0X_set_measurement_timing_budget_micro_seconds PROC
;;;1112   
;;;1113   VL53L0X_Error VL53L0X_set_measurement_timing_budget_micro_seconds(VL53L0X_DEV Dev,
001508  e92d4ff0          PUSH     {r4-r11,lr}
;;;1114   		uint32_t MeasurementTimingBudgetMicroSeconds)
;;;1115   {
00150c  e24dd024          SUB      sp,sp,#0x24
001510  e1a08000          MOV      r8,r0
001514  e1a07001          MOV      r7,r1
;;;1116   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001518  e3a06000          MOV      r6,#0
;;;1117   	uint32_t FinalRangeTimingBudgetMicroSeconds;
;;;1118   	VL53L0X_SchedulerSequenceSteps_t SchedulerSequenceSteps;
;;;1119   	uint32_t MsrcDccTccTimeoutMicroSeconds	= 2000;
00151c  e3a00e7d          MOV      r0,#0x7d0
001520  e58d0018          STR      r0,[sp,#0x18]
;;;1120   	uint32_t StartOverheadMicroSeconds		= 1320;
001524  e2409faa          SUB      r9,r0,#0x2a8
;;;1121   	uint32_t EndOverheadMicroSeconds		= 960;
001528  e3a0ad0f          MOV      r10,#0x3c0
;;;1122   	uint32_t MsrcOverheadMicroSeconds		= 660;
00152c  e3a0bfa5          MOV      r11,#0x294
;;;1123   	uint32_t TccOverheadMicroSeconds		= 590;
001530  e24b0046          SUB      r0,r11,#0x46
001534  e58d0014          STR      r0,[sp,#0x14]
;;;1124   	uint32_t DssOverheadMicroSeconds		= 690;
001538  e2800064          ADD      r0,r0,#0x64
00153c  e58d0010          STR      r0,[sp,#0x10]
;;;1125   	uint32_t PreRangeOverheadMicroSeconds	= 660;
001540  e3a00fa5          MOV      r0,#0x294
001544  e58d000c          STR      r0,[sp,#0xc]
;;;1126   	uint32_t FinalRangeOverheadMicroSeconds = 550;
001548  e240006e          SUB      r0,r0,#0x6e
00154c  e58d0008          STR      r0,[sp,#8]
;;;1127   	uint32_t PreRangeTimeoutMicroSeconds	= 0;
001550  e3a00000          MOV      r0,#0
001554  e58d0004          STR      r0,[sp,#4]
;;;1128   	uint32_t cMinTimingBudgetMicroSeconds	= 20000;
001558  e59f0eec          LDR      r0,|L1.9292|
00155c  e58d0000          STR      r0,[sp,#0]
;;;1129   	uint32_t SubTimeout = 0;
001560  e3a05000          MOV      r5,#0
;;;1130   
;;;1131   	LOG_FUNCTION_START("");
;;;1132   
;;;1133   	if (MeasurementTimingBudgetMicroSeconds
001564  e59d0000          LDR      r0,[sp,#0]
001568  e1570000          CMP      r7,r0
00156c  2a000003          BCS      |L1.5504|
;;;1134   			< cMinTimingBudgetMicroSeconds) {
;;;1135   		Status = VL53L0X_ERROR_INVALID_PARAMS;
001570  e3e06003          MVN      r6,#3
;;;1136   		return Status;
001574  e1a00006          MOV      r0,r6
                  |L1.5496|
001578  e28dd024          ADD      sp,sp,#0x24
;;;1137   	}
;;;1138   
;;;1139   	FinalRangeTimingBudgetMicroSeconds =
;;;1140   		MeasurementTimingBudgetMicroSeconds -
;;;1141   		(StartOverheadMicroSeconds + EndOverheadMicroSeconds);
;;;1142   
;;;1143   	Status = VL53L0X_GetSequenceStepEnables(Dev, &SchedulerSequenceSteps);
;;;1144   
;;;1145   	if (Status == VL53L0X_ERROR_NONE &&
;;;1146   		(SchedulerSequenceSteps.TccOn  ||
;;;1147   		SchedulerSequenceSteps.MsrcOn ||
;;;1148   		SchedulerSequenceSteps.DssOn)) {
;;;1149   
;;;1150   		/* TCC, MSRC and DSS all share the same timeout */
;;;1151   		Status = get_sequence_step_timeout(Dev,
;;;1152   					VL53L0X_SEQUENCESTEP_MSRC,
;;;1153   					&MsrcDccTccTimeoutMicroSeconds);
;;;1154   
;;;1155   		/* Subtract the TCC, MSRC and DSS timeouts if they are
;;;1156   		 * enabled. */
;;;1157   
;;;1158   		if (Status != VL53L0X_ERROR_NONE)
;;;1159   			return Status;
;;;1160   
;;;1161   		/* TCC */
;;;1162   		if (SchedulerSequenceSteps.TccOn) {
;;;1163   
;;;1164   			SubTimeout = MsrcDccTccTimeoutMicroSeconds
;;;1165   				+ TccOverheadMicroSeconds;
;;;1166   
;;;1167   			if (SubTimeout <
;;;1168   				FinalRangeTimingBudgetMicroSeconds) {
;;;1169   				FinalRangeTimingBudgetMicroSeconds -=
;;;1170   							SubTimeout;
;;;1171   			} else {
;;;1172   				/* Requested timeout too big. */
;;;1173   				Status = VL53L0X_ERROR_INVALID_PARAMS;
;;;1174   			}
;;;1175   		}
;;;1176   
;;;1177   		if (Status != VL53L0X_ERROR_NONE) {
;;;1178   			LOG_FUNCTION_END(Status);
;;;1179   			return Status;
;;;1180   		}
;;;1181   
;;;1182   		/* DSS */
;;;1183   		if (SchedulerSequenceSteps.DssOn) {
;;;1184   
;;;1185   			SubTimeout = 2 * (MsrcDccTccTimeoutMicroSeconds +
;;;1186   				DssOverheadMicroSeconds);
;;;1187   
;;;1188   			if (SubTimeout < FinalRangeTimingBudgetMicroSeconds) {
;;;1189   				FinalRangeTimingBudgetMicroSeconds
;;;1190   							-= SubTimeout;
;;;1191   			} else {
;;;1192   				/* Requested timeout too big. */
;;;1193   				Status = VL53L0X_ERROR_INVALID_PARAMS;
;;;1194   			}
;;;1195   		} else if (SchedulerSequenceSteps.MsrcOn) {
;;;1196   			/* MSRC */
;;;1197   			SubTimeout = MsrcDccTccTimeoutMicroSeconds +
;;;1198   						MsrcOverheadMicroSeconds;
;;;1199   
;;;1200   			if (SubTimeout < FinalRangeTimingBudgetMicroSeconds) {
;;;1201   				FinalRangeTimingBudgetMicroSeconds
;;;1202   							-= SubTimeout;
;;;1203   			} else {
;;;1204   				/* Requested timeout too big. */
;;;1205   				Status = VL53L0X_ERROR_INVALID_PARAMS;
;;;1206   			}
;;;1207   		}
;;;1208   
;;;1209   	}
;;;1210   
;;;1211   	if (Status != VL53L0X_ERROR_NONE) {
;;;1212   		LOG_FUNCTION_END(Status);
;;;1213   		return Status;
;;;1214   	}
;;;1215   
;;;1216   	if (SchedulerSequenceSteps.PreRangeOn) {
;;;1217   
;;;1218   		/* Subtract the Pre-range timeout if enabled. */
;;;1219   
;;;1220   		Status = get_sequence_step_timeout(Dev,
;;;1221   				VL53L0X_SEQUENCESTEP_PRE_RANGE,
;;;1222   				&PreRangeTimeoutMicroSeconds);
;;;1223   
;;;1224   		SubTimeout = PreRangeTimeoutMicroSeconds +
;;;1225   				PreRangeOverheadMicroSeconds;
;;;1226   
;;;1227   		if (SubTimeout < FinalRangeTimingBudgetMicroSeconds) {
;;;1228   			FinalRangeTimingBudgetMicroSeconds -= SubTimeout;
;;;1229   		} else {
;;;1230   			/* Requested timeout too big. */
;;;1231   			Status = VL53L0X_ERROR_INVALID_PARAMS;
;;;1232   		}
;;;1233   	}
;;;1234   
;;;1235   
;;;1236   	if (Status == VL53L0X_ERROR_NONE &&
;;;1237   		SchedulerSequenceSteps.FinalRangeOn) {
;;;1238   
;;;1239   		FinalRangeTimingBudgetMicroSeconds -=
;;;1240   				FinalRangeOverheadMicroSeconds;
;;;1241   
;;;1242   		/* Final Range Timeout
;;;1243   		* Note that the final range timeout is determined by the timing
;;;1244   		* budget and the sum of all other timeouts within the sequence.
;;;1245   		* If there is no room for the final range timeout, then an error
;;;1246   		* will be set. Otherwise the remaining time will be applied to
;;;1247   		* the final range.
;;;1248   		*/
;;;1249   		Status = set_sequence_step_timeout(Dev,
;;;1250   			   VL53L0X_SEQUENCESTEP_FINAL_RANGE,
;;;1251   			   FinalRangeTimingBudgetMicroSeconds);
;;;1252   
;;;1253   		VL53L0X_SETPARAMETERFIELD(Dev,
;;;1254   			   MeasurementTimingBudgetMicroSeconds,
;;;1255   			   MeasurementTimingBudgetMicroSeconds);
;;;1256   	}
;;;1257   
;;;1258   	LOG_FUNCTION_END(Status);
;;;1259   
;;;1260   	return Status;
;;;1261   }
00157c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.5504|
001580  e089000a          ADD      r0,r9,r10             ;1139
001584  e0474000          SUB      r4,r7,r0              ;1139
001588  e28d101c          ADD      r1,sp,#0x1c           ;1143
00158c  e1a00008          MOV      r0,r8                 ;1143
001590  ebfffffe          BL       VL53L0X_GetSequenceStepEnables
001594  e1a06000          MOV      r6,r0                 ;1143
001598  e3560000          CMP      r6,#0                 ;1145
00159c  1a000037          BNE      |L1.5760|
0015a0  e5dd001c          LDRB     r0,[sp,#0x1c]         ;1146
0015a4  e3500000          CMP      r0,#0                 ;1146
0015a8  1a000005          BNE      |L1.5572|
0015ac  e5dd001d          LDRB     r0,[sp,#0x1d]         ;1147
0015b0  e3500000          CMP      r0,#0                 ;1147
0015b4  1a000002          BNE      |L1.5572|
0015b8  e5dd001e          LDRB     r0,[sp,#0x1e]         ;1148
0015bc  e3500000          CMP      r0,#0                 ;1148
0015c0  0a00002e          BEQ      |L1.5760|
                  |L1.5572|
0015c4  e28d2018          ADD      r2,sp,#0x18           ;1151
0015c8  e3a01002          MOV      r1,#2                 ;1151
0015cc  e1a00008          MOV      r0,r8                 ;1151
0015d0  ebfffffe          BL       get_sequence_step_timeout
0015d4  e1a06000          MOV      r6,r0                 ;1151
0015d8  e3560000          CMP      r6,#0                 ;1158
0015dc  0a000001          BEQ      |L1.5608|
0015e0  e1a00006          MOV      r0,r6                 ;1159
0015e4  eaffffe3          B        |L1.5496|
                  |L1.5608|
0015e8  e5dd001c          LDRB     r0,[sp,#0x1c]         ;1162
0015ec  e3500000          CMP      r0,#0                 ;1162
0015f0  0a000007          BEQ      |L1.5652|
0015f4  e59d0014          LDR      r0,[sp,#0x14]         ;1164
0015f8  e59d1018          LDR      r1,[sp,#0x18]         ;1164
0015fc  e0815000          ADD      r5,r1,r0              ;1164
001600  e1550004          CMP      r5,r4                 ;1167
001604  2a000001          BCS      |L1.5648|
001608  e0444005          SUB      r4,r4,r5              ;1169
00160c  ea000000          B        |L1.5652|
                  |L1.5648|
001610  e3e06003          MVN      r6,#3                 ;1173
                  |L1.5652|
001614  e3560000          CMP      r6,#0                 ;1177
001618  0a000001          BEQ      |L1.5668|
00161c  e1a00006          MOV      r0,r6                 ;1179
001620  eaffffd4          B        |L1.5496|
                  |L1.5668|
001624  e5dd001e          LDRB     r0,[sp,#0x1e]         ;1183
001628  e3500000          CMP      r0,#0                 ;1183
00162c  0a000009          BEQ      |L1.5720|
001630  e59d0010          LDR      r0,[sp,#0x10]         ;1185
001634  e59d1018          LDR      r1,[sp,#0x18]         ;1185
001638  e0800001          ADD      r0,r0,r1              ;1185
00163c  e1a05080          LSL      r5,r0,#1              ;1185
001640  e1550004          CMP      r5,r4                 ;1188
001644  2a000001          BCS      |L1.5712|
001648  e0444005          SUB      r4,r4,r5              ;1189
00164c  ea00000b          B        |L1.5760|
                  |L1.5712|
001650  e3e06003          MVN      r6,#3                 ;1193
001654  ea000009          B        |L1.5760|
                  |L1.5720|
001658  e5dd001d          LDRB     r0,[sp,#0x1d]         ;1195
00165c  e3500000          CMP      r0,#0                 ;1195
001660  0a000006          BEQ      |L1.5760|
001664  e59d0018          LDR      r0,[sp,#0x18]         ;1197
001668  e080500b          ADD      r5,r0,r11             ;1197
00166c  e1550004          CMP      r5,r4                 ;1200
001670  2a000001          BCS      |L1.5756|
001674  e0444005          SUB      r4,r4,r5              ;1201
001678  ea000000          B        |L1.5760|
                  |L1.5756|
00167c  e3e06003          MVN      r6,#3                 ;1205
                  |L1.5760|
001680  e3560000          CMP      r6,#0                 ;1211
001684  0a000001          BEQ      |L1.5776|
001688  e1a00006          MOV      r0,r6                 ;1213
00168c  eaffffb9          B        |L1.5496|
                  |L1.5776|
001690  e5dd001f          LDRB     r0,[sp,#0x1f]         ;1216
001694  e3500000          CMP      r0,#0                 ;1216
001698  0a00000c          BEQ      |L1.5840|
00169c  e28d2004          ADD      r2,sp,#4              ;1220
0016a0  e3a01003          MOV      r1,#3                 ;1220
0016a4  e1a00008          MOV      r0,r8                 ;1220
0016a8  ebfffffe          BL       get_sequence_step_timeout
0016ac  e1a06000          MOV      r6,r0                 ;1220
0016b0  e59d000c          LDR      r0,[sp,#0xc]          ;1224
0016b4  e59d1004          LDR      r1,[sp,#4]            ;1224
0016b8  e0815000          ADD      r5,r1,r0              ;1224
0016bc  e1550004          CMP      r5,r4                 ;1227
0016c0  2a000001          BCS      |L1.5836|
0016c4  e0444005          SUB      r4,r4,r5              ;1228
0016c8  ea000000          B        |L1.5840|
                  |L1.5836|
0016cc  e3e06003          MVN      r6,#3                 ;1231
                  |L1.5840|
0016d0  e3560000          CMP      r6,#0                 ;1236
0016d4  1a00000a          BNE      |L1.5892|
0016d8  e5dd0020          LDRB     r0,[sp,#0x20]         ;1237
0016dc  e3500000          CMP      r0,#0                 ;1237
0016e0  0a000007          BEQ      |L1.5892|
0016e4  e59d0008          LDR      r0,[sp,#8]            ;1239
0016e8  e0444000          SUB      r4,r4,r0              ;1239
0016ec  e1a02004          MOV      r2,r4                 ;1249
0016f0  e3a01004          MOV      r1,#4                 ;1249
0016f4  e1a00008          MOV      r0,r8                 ;1249
0016f8  ebfffffe          BL       set_sequence_step_timeout
0016fc  e1a06000          MOV      r6,r0                 ;1249
001700  e5887014          STR      r7,[r8,#0x14]         ;1253
                  |L1.5892|
001704  e1a00006          MOV      r0,r6                 ;1260
001708  eaffff9a          B        |L1.5496|
;;;1262   
                          ENDP

                  VL53L0X_get_measurement_timing_budget_micro_seconds PROC
;;;1263   VL53L0X_Error VL53L0X_get_measurement_timing_budget_micro_seconds(VL53L0X_DEV Dev,
00170c  e92d4ff0          PUSH     {r4-r11,lr}
;;;1264   		uint32_t *pMeasurementTimingBudgetMicroSeconds)
;;;1265   {
001710  e24dd01c          SUB      sp,sp,#0x1c
001714  e1a06000          MOV      r6,r0
001718  e1a04001          MOV      r4,r1
;;;1266   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
00171c  e3a05000          MOV      r5,#0
;;;1267   	VL53L0X_SchedulerSequenceSteps_t SchedulerSequenceSteps;
;;;1268   	uint32_t FinalRangeTimeoutMicroSeconds;
;;;1269   	uint32_t MsrcDccTccTimeoutMicroSeconds	= 2000;
001720  e3a00e7d          MOV      r0,#0x7d0
001724  e58d000c          STR      r0,[sp,#0xc]
;;;1270   	uint32_t StartOverheadMicroSeconds		= 1910;
001728  e240705a          SUB      r7,r0,#0x5a
;;;1271   	uint32_t EndOverheadMicroSeconds		= 960;
00172c  e3a08d0f          MOV      r8,#0x3c0
;;;1272   	uint32_t MsrcOverheadMicroSeconds		= 660;
001730  e3a09fa5          MOV      r9,#0x294
;;;1273   	uint32_t TccOverheadMicroSeconds		= 590;
001734  e249a046          SUB      r10,r9,#0x46
;;;1274   	uint32_t DssOverheadMicroSeconds		= 690;
001738  e089b2c8          ADD      r11,r9,r8,ASR #5
;;;1275   	uint32_t PreRangeOverheadMicroSeconds	= 660;
00173c  e3a00fa5          MOV      r0,#0x294
001740  e58d0008          STR      r0,[sp,#8]
;;;1276   	uint32_t FinalRangeOverheadMicroSeconds = 550;
001744  e240006e          SUB      r0,r0,#0x6e
001748  e58d0004          STR      r0,[sp,#4]
;;;1277   	uint32_t PreRangeTimeoutMicroSeconds	= 0;
00174c  e3a00000          MOV      r0,#0
001750  e58d0000          STR      r0,[sp,#0]
;;;1278   
;;;1279   	LOG_FUNCTION_START("");
;;;1280   
;;;1281   	/* Start and end overhead times always present */
;;;1282   	*pMeasurementTimingBudgetMicroSeconds
001754  e0870008          ADD      r0,r7,r8
001758  e5840000          STR      r0,[r4,#0]
;;;1283   		= StartOverheadMicroSeconds + EndOverheadMicroSeconds;
;;;1284   
;;;1285   	Status = VL53L0X_GetSequenceStepEnables(Dev, &SchedulerSequenceSteps);
00175c  e28d1014          ADD      r1,sp,#0x14
001760  e1a00006          MOV      r0,r6
001764  ebfffffe          BL       VL53L0X_GetSequenceStepEnables
001768  e1a05000          MOV      r5,r0
;;;1286   
;;;1287   	if (Status != VL53L0X_ERROR_NONE) {
00176c  e3550000          CMP      r5,#0
001770  0a000002          BEQ      |L1.6016|
;;;1288   		LOG_FUNCTION_END(Status);
;;;1289   		return Status;
001774  e1a00005          MOV      r0,r5
                  |L1.6008|
001778  e28dd01c          ADD      sp,sp,#0x1c
;;;1290   	}
;;;1291   
;;;1292   
;;;1293   	if (SchedulerSequenceSteps.TccOn  ||
;;;1294   		SchedulerSequenceSteps.MsrcOn ||
;;;1295   		SchedulerSequenceSteps.DssOn) {
;;;1296   
;;;1297   		Status = get_sequence_step_timeout(Dev,
;;;1298   				VL53L0X_SEQUENCESTEP_MSRC,
;;;1299   				&MsrcDccTccTimeoutMicroSeconds);
;;;1300   
;;;1301   		if (Status == VL53L0X_ERROR_NONE) {
;;;1302   			if (SchedulerSequenceSteps.TccOn) {
;;;1303   				*pMeasurementTimingBudgetMicroSeconds +=
;;;1304   					MsrcDccTccTimeoutMicroSeconds +
;;;1305   					TccOverheadMicroSeconds;
;;;1306   			}
;;;1307   
;;;1308   			if (SchedulerSequenceSteps.DssOn) {
;;;1309   				*pMeasurementTimingBudgetMicroSeconds +=
;;;1310   				2 * (MsrcDccTccTimeoutMicroSeconds +
;;;1311   					DssOverheadMicroSeconds);
;;;1312   			} else if (SchedulerSequenceSteps.MsrcOn) {
;;;1313   				*pMeasurementTimingBudgetMicroSeconds +=
;;;1314   					MsrcDccTccTimeoutMicroSeconds +
;;;1315   					MsrcOverheadMicroSeconds;
;;;1316   			}
;;;1317   		}
;;;1318   	}
;;;1319   
;;;1320   	if (Status == VL53L0X_ERROR_NONE) {
;;;1321   		if (SchedulerSequenceSteps.PreRangeOn) {
;;;1322   			Status = get_sequence_step_timeout(Dev,
;;;1323   				VL53L0X_SEQUENCESTEP_PRE_RANGE,
;;;1324   				&PreRangeTimeoutMicroSeconds);
;;;1325   			*pMeasurementTimingBudgetMicroSeconds +=
;;;1326   				PreRangeTimeoutMicroSeconds +
;;;1327   				PreRangeOverheadMicroSeconds;
;;;1328   		}
;;;1329   	}
;;;1330   
;;;1331   	if (Status == VL53L0X_ERROR_NONE) {
;;;1332   		if (SchedulerSequenceSteps.FinalRangeOn) {
;;;1333   			Status = get_sequence_step_timeout(Dev,
;;;1334   					VL53L0X_SEQUENCESTEP_FINAL_RANGE,
;;;1335   					&FinalRangeTimeoutMicroSeconds);
;;;1336   			*pMeasurementTimingBudgetMicroSeconds +=
;;;1337   				(FinalRangeTimeoutMicroSeconds +
;;;1338   				FinalRangeOverheadMicroSeconds);
;;;1339   		}
;;;1340   	}
;;;1341   
;;;1342   	if (Status == VL53L0X_ERROR_NONE) {
;;;1343   		VL53L0X_SETPARAMETERFIELD(Dev,
;;;1344   			MeasurementTimingBudgetMicroSeconds,
;;;1345   			*pMeasurementTimingBudgetMicroSeconds);
;;;1346   	}
;;;1347   
;;;1348   	LOG_FUNCTION_END(Status);
;;;1349   	return Status;
;;;1350   }
00177c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.6016|
001780  e5dd0014          LDRB     r0,[sp,#0x14]         ;1293
001784  e3500000          CMP      r0,#0                 ;1293
001788  1a000005          BNE      |L1.6052|
00178c  e5dd0015          LDRB     r0,[sp,#0x15]         ;1294
001790  e3500000          CMP      r0,#0                 ;1294
001794  1a000002          BNE      |L1.6052|
001798  e5dd0016          LDRB     r0,[sp,#0x16]         ;1295
00179c  e3500000          CMP      r0,#0                 ;1295
0017a0  0a000020          BEQ      |L1.6184|
                  |L1.6052|
0017a4  e28d200c          ADD      r2,sp,#0xc            ;1297
0017a8  e3a01002          MOV      r1,#2                 ;1297
0017ac  e1a00006          MOV      r0,r6                 ;1297
0017b0  ebfffffe          BL       get_sequence_step_timeout
0017b4  e1a05000          MOV      r5,r0                 ;1297
0017b8  e3550000          CMP      r5,#0                 ;1301
0017bc  1a000019          BNE      |L1.6184|
0017c0  e5dd0014          LDRB     r0,[sp,#0x14]         ;1302
0017c4  e3500000          CMP      r0,#0                 ;1302
0017c8  0a000004          BEQ      |L1.6112|
0017cc  e5940000          LDR      r0,[r4,#0]            ;1303
0017d0  e59d100c          LDR      r1,[sp,#0xc]          ;1303
0017d4  e081100a          ADD      r1,r1,r10             ;1303
0017d8  e0800001          ADD      r0,r0,r1              ;1303
0017dc  e5840000          STR      r0,[r4,#0]            ;1303
                  |L1.6112|
0017e0  e5dd0016          LDRB     r0,[sp,#0x16]         ;1308
0017e4  e3500000          CMP      r0,#0                 ;1308
0017e8  0a000006          BEQ      |L1.6152|
0017ec  e5940000          LDR      r0,[r4,#0]            ;1309
0017f0  e59d100c          LDR      r1,[sp,#0xc]          ;1309
0017f4  e081100b          ADD      r1,r1,r11             ;1309
0017f8  e3a02002          MOV      r2,#2                 ;1309
0017fc  e0200192          MLA      r0,r2,r1,r0           ;1309
001800  e5840000          STR      r0,[r4,#0]            ;1309
001804  ea000007          B        |L1.6184|
                  |L1.6152|
001808  e5dd0015          LDRB     r0,[sp,#0x15]         ;1312
00180c  e3500000          CMP      r0,#0                 ;1312
001810  0a000004          BEQ      |L1.6184|
001814  e5940000          LDR      r0,[r4,#0]            ;1313
001818  e59d100c          LDR      r1,[sp,#0xc]          ;1313
00181c  e0811009          ADD      r1,r1,r9              ;1313
001820  e0800001          ADD      r0,r0,r1              ;1313
001824  e5840000          STR      r0,[r4,#0]            ;1313
                  |L1.6184|
001828  e3550000          CMP      r5,#0                 ;1320
00182c  1a00000d          BNE      |L1.6248|
001830  e5dd0017          LDRB     r0,[sp,#0x17]         ;1321
001834  e3500000          CMP      r0,#0                 ;1321
001838  0a00000a          BEQ      |L1.6248|
00183c  e1a0200d          MOV      r2,sp                 ;1322
001840  e3a01003          MOV      r1,#3                 ;1322
001844  e1a00006          MOV      r0,r6                 ;1322
001848  ebfffffe          BL       get_sequence_step_timeout
00184c  e1a05000          MOV      r5,r0                 ;1322
001850  e5941000          LDR      r1,[r4,#0]            ;1325
001854  e59d0008          LDR      r0,[sp,#8]            ;1325
001858  e59d2000          LDR      r2,[sp,#0]            ;1325
00185c  e0800002          ADD      r0,r0,r2              ;1325
001860  e0800001          ADD      r0,r0,r1              ;1325
001864  e5840000          STR      r0,[r4,#0]            ;1325
                  |L1.6248|
001868  e3550000          CMP      r5,#0                 ;1331
00186c  1a00000d          BNE      |L1.6312|
001870  e5dd0018          LDRB     r0,[sp,#0x18]         ;1332
001874  e3500000          CMP      r0,#0                 ;1332
001878  0a00000a          BEQ      |L1.6312|
00187c  e28d2010          ADD      r2,sp,#0x10           ;1333
001880  e3a01004          MOV      r1,#4                 ;1333
001884  e1a00006          MOV      r0,r6                 ;1333
001888  ebfffffe          BL       get_sequence_step_timeout
00188c  e1a05000          MOV      r5,r0                 ;1333
001890  e5941000          LDR      r1,[r4,#0]            ;1336
001894  e59d0004          LDR      r0,[sp,#4]            ;1336
001898  e59d2010          LDR      r2,[sp,#0x10]         ;1336
00189c  e0800002          ADD      r0,r0,r2              ;1336
0018a0  e0800001          ADD      r0,r0,r1              ;1336
0018a4  e5840000          STR      r0,[r4,#0]            ;1336
                  |L1.6312|
0018a8  e3550000          CMP      r5,#0                 ;1342
0018ac  1a000001          BNE      |L1.6328|
0018b0  e5940000          LDR      r0,[r4,#0]            ;1343
0018b4  e5860014          STR      r0,[r6,#0x14]         ;1343
                  |L1.6328|
0018b8  e1a00005          MOV      r0,r5                 ;1349
0018bc  eaffffad          B        |L1.6008|
;;;1351   
                          ENDP

                  VL53L0X_load_tuning_settings PROC
;;;1353   
;;;1354   VL53L0X_Error VL53L0X_load_tuning_settings(VL53L0X_DEV Dev,
0018c0  e92d5fff          PUSH     {r0-r12,lr}
;;;1355   		uint8_t *pTuningSettingBuffer)
;;;1356   {
0018c4  e1a06000          MOV      r6,r0
0018c8  e1a05001          MOV      r5,r1
;;;1357   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
0018cc  e3a00000          MOV      r0,#0
0018d0  e58d000c          STR      r0,[sp,#0xc]
;;;1358   	int i;
;;;1359   	int Index;
;;;1360   	uint8_t msb;
;;;1361   	uint8_t lsb;
;;;1362   	uint8_t SelectParam;
;;;1363   	uint8_t NumberOfWrites;
;;;1364   	uint8_t Address;
;;;1365   	uint8_t localBuffer[4]; /* max */
;;;1366   	uint16_t Temp16;
;;;1367   
;;;1368   	LOG_FUNCTION_START("");
;;;1369   
;;;1370   	Index = 0;
0018d4  e3a04000          MOV      r4,#0
;;;1371   
;;;1372   	while ((*(pTuningSettingBuffer + Index) != 0) &&
0018d8  ea000053          B        |L1.6700|
                  |L1.6364|
;;;1373   			(Status == VL53L0X_ERROR_NONE)) {
;;;1374   		NumberOfWrites = *(pTuningSettingBuffer + Index);
0018dc  e7d57004          LDRB     r7,[r5,r4]
;;;1375   		Index++;
0018e0  e2844001          ADD      r4,r4,#1
;;;1376   		if (NumberOfWrites == 0xFF) {
0018e4  e35700ff          CMP      r7,#0xff
0018e8  1a000039          BNE      |L1.6612|
;;;1377   			/* internal parameters */
;;;1378   			SelectParam = *(pTuningSettingBuffer + Index);
0018ec  e7d50004          LDRB     r0,[r5,r4]
0018f0  e58d0008          STR      r0,[sp,#8]
;;;1379   			Index++;
0018f4  e2844001          ADD      r4,r4,#1
;;;1380   			switch (SelectParam) {
0018f8  e59d0008          LDR      r0,[sp,#8]
0018fc  e3500000          CMP      r0,#0
001900  0a000006          BEQ      |L1.6432|
001904  e3500001          CMP      r0,#1
001908  0a00000e          BEQ      |L1.6472|
00190c  e3500002          CMP      r0,#2
001910  0a000016          BEQ      |L1.6512|
001914  e3500003          CMP      r0,#3
001918  1a000028          BNE      |L1.6592|
00191c  ea00001d          B        |L1.6552|
                  |L1.6432|
;;;1381   			case 0: /* uint16_t SigmaEstRefArray -> 2 bytes */
001920  e1a00000          MOV      r0,r0
;;;1382   				msb = *(pTuningSettingBuffer + Index);
001924  e7d58004          LDRB     r8,[r5,r4]
;;;1383   				Index++;
001928  e2844001          ADD      r4,r4,#1
;;;1384   				lsb = *(pTuningSettingBuffer + Index);
00192c  e7d59004          LDRB     r9,[r5,r4]
;;;1385   				Index++;
001930  e2844001          ADD      r4,r4,#1
;;;1386   				Temp16 = VL53L0X_MAKEUINT16(lsb, msb);
001934  e0890408          ADD      r0,r9,r8,LSL #8
001938  e3c0a801          BIC      r10,r0,#0x10000
;;;1387   				PALDevDataSet(Dev, SigmaEstRefArray, Temp16);
00193c  e3a00f4d          MOV      r0,#0x134
001940  e180a0b6          STRH     r10,[r0,r6]
;;;1388   				break;
001944  ea000021          B        |L1.6608|
                  |L1.6472|
;;;1389   			case 1: /* uint16_t SigmaEstEffPulseWidth -> 2 bytes */
001948  e1a00000          MOV      r0,r0
;;;1390   				msb = *(pTuningSettingBuffer + Index);
00194c  e7d58004          LDRB     r8,[r5,r4]
;;;1391   				Index++;
001950  e2844001          ADD      r4,r4,#1
;;;1392   				lsb = *(pTuningSettingBuffer + Index);
001954  e7d59004          LDRB     r9,[r5,r4]
;;;1393   				Index++;
001958  e2844001          ADD      r4,r4,#1
;;;1394   				Temp16 = VL53L0X_MAKEUINT16(lsb, msb);
00195c  e0890408          ADD      r0,r9,r8,LSL #8
001960  e3c0a801          BIC      r10,r0,#0x10000
;;;1395   				PALDevDataSet(Dev, SigmaEstEffPulseWidth,
001964  e59f0ae4          LDR      r0,|L1.9296|
001968  e180a0b6          STRH     r10,[r0,r6]
;;;1396   					Temp16);
;;;1397   				break;
00196c  ea000017          B        |L1.6608|
                  |L1.6512|
;;;1398   			case 2: /* uint16_t SigmaEstEffAmbWidth -> 2 bytes */
001970  e1a00000          MOV      r0,r0
;;;1399   				msb = *(pTuningSettingBuffer + Index);
001974  e7d58004          LDRB     r8,[r5,r4]
;;;1400   				Index++;
001978  e2844001          ADD      r4,r4,#1
;;;1401   				lsb = *(pTuningSettingBuffer + Index);
00197c  e7d59004          LDRB     r9,[r5,r4]
;;;1402   				Index++;
001980  e2844001          ADD      r4,r4,#1
;;;1403   				Temp16 = VL53L0X_MAKEUINT16(lsb, msb);
001984  e0890408          ADD      r0,r9,r8,LSL #8
001988  e3c0a801          BIC      r10,r0,#0x10000
;;;1404   				PALDevDataSet(Dev, SigmaEstEffAmbWidth, Temp16);
00198c  e3a00f4e          MOV      r0,#0x138
001990  e180a0b6          STRH     r10,[r0,r6]
;;;1405   				break;
001994  ea00000d          B        |L1.6608|
                  |L1.6552|
;;;1406   			case 3: /* uint16_t targetRefRate -> 2 bytes */
001998  e1a00000          MOV      r0,r0
;;;1407   				msb = *(pTuningSettingBuffer + Index);
00199c  e7d58004          LDRB     r8,[r5,r4]
;;;1408   				Index++;
0019a0  e2844001          ADD      r4,r4,#1
;;;1409   				lsb = *(pTuningSettingBuffer + Index);
0019a4  e7d59004          LDRB     r9,[r5,r4]
;;;1410   				Index++;
0019a8  e2844001          ADD      r4,r4,#1
;;;1411   				Temp16 = VL53L0X_MAKEUINT16(lsb, msb);
0019ac  e0890408          ADD      r0,r9,r8,LSL #8
0019b0  e3c0a801          BIC      r10,r0,#0x10000
;;;1412   				PALDevDataSet(Dev, targetRefRate, Temp16);
0019b4  e3a00f4f          MOV      r0,#0x13c
0019b8  e180a0b6          STRH     r10,[r0,r6]
;;;1413   				break;
0019bc  ea000003          B        |L1.6608|
                  |L1.6592|
;;;1414   			default: /* invalid parameter */
0019c0  e1a00000          MOV      r0,r0
;;;1415   				Status = VL53L0X_ERROR_INVALID_PARAMS;
0019c4  e3e00003          MVN      r0,#3
0019c8  e58d000c          STR      r0,[sp,#0xc]
0019cc  e1a00000          MOV      r0,r0                 ;1380
                  |L1.6608|
0019d0  ea000015          B        |L1.6700|
                  |L1.6612|
;;;1416   			}
;;;1417   
;;;1418   		} else if (NumberOfWrites <= 4) {
0019d4  e3570004          CMP      r7,#4
0019d8  ca000011          BGT      |L1.6692|
;;;1419   			Address = *(pTuningSettingBuffer + Index);
0019dc  e7d50004          LDRB     r0,[r5,r4]
0019e0  e58d0004          STR      r0,[sp,#4]
;;;1420   			Index++;
0019e4  e2844001          ADD      r4,r4,#1
;;;1421   
;;;1422   			for (i = 0; i < NumberOfWrites; i++) {
0019e8  e3a0b000          MOV      r11,#0
0019ec  ea000003          B        |L1.6656|
                  |L1.6640|
;;;1423   				localBuffer[i] = *(pTuningSettingBuffer +
0019f0  e7d50004          LDRB     r0,[r5,r4]
0019f4  e7cd000b          STRB     r0,[sp,r11]
;;;1424   							Index);
;;;1425   				Index++;
0019f8  e2844001          ADD      r4,r4,#1
0019fc  e28bb001          ADD      r11,r11,#1            ;1422
                  |L1.6656|
001a00  e15b0007          CMP      r11,r7                ;1422
001a04  bafffff9          BLT      |L1.6640|
;;;1426   			}
;;;1427   
;;;1428   			Status = VL53L0X_WriteMulti(Dev, Address, localBuffer,
001a08  e1a03007          MOV      r3,r7
001a0c  e1a0200d          MOV      r2,sp
001a10  e1a00006          MOV      r0,r6
001a14  e59d1004          LDR      r1,[sp,#4]
001a18  ebfffffe          BL       VL53L0X_WriteMulti
001a1c  e58d000c          STR      r0,[sp,#0xc]
001a20  ea000001          B        |L1.6700|
                  |L1.6692|
;;;1429   					NumberOfWrites);
;;;1430   
;;;1431   		} else {
;;;1432   			Status = VL53L0X_ERROR_INVALID_PARAMS;
001a24  e3e00003          MVN      r0,#3
001a28  e58d000c          STR      r0,[sp,#0xc]
                  |L1.6700|
001a2c  e7d50004          LDRB     r0,[r5,r4]            ;1372
001a30  e3500000          CMP      r0,#0                 ;1372
001a34  0a000002          BEQ      |L1.6724|
001a38  e59d000c          LDR      r0,[sp,#0xc]          ;1373
001a3c  e3500000          CMP      r0,#0                 ;1373
001a40  0affffa5          BEQ      |L1.6364|
                  |L1.6724|
;;;1433   		}
;;;1434   	}
;;;1435   
;;;1436   	LOG_FUNCTION_END(Status);
;;;1437   	return Status;
001a44  e59d000c          LDR      r0,[sp,#0xc]
001a48  e28dd010          ADD      sp,sp,#0x10
;;;1438   }
001a4c  e8bd9ff0          POP      {r4-r12,pc}
;;;1439   
                          ENDP

                  VL53L0X_get_total_xtalk_rate PROC
;;;1440   VL53L0X_Error VL53L0X_get_total_xtalk_rate(VL53L0X_DEV Dev,
001a50  e92d43f8          PUSH     {r3-r9,lr}
;;;1441   	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData,
;;;1442   	FixPoint1616_t *ptotal_xtalk_rate_mcps)
;;;1443   {
001a54  e1a05000          MOV      r5,r0
001a58  e1a06001          MOV      r6,r1
001a5c  e1a04002          MOV      r4,r2
;;;1444   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001a60  e3a07000          MOV      r7,#0
;;;1445   
;;;1446   	uint8_t xtalkCompEnable;
;;;1447   	FixPoint1616_t totalXtalkMegaCps;
;;;1448   	FixPoint1616_t xtalkPerSpadMegaCps;
;;;1449   
;;;1450   	*ptotal_xtalk_rate_mcps = 0;
001a64  e3a00000          MOV      r0,#0
001a68  e5840000          STR      r0,[r4,#0]
;;;1451   
;;;1452   	Status = VL53L0X_GetXTalkCompensationEnable(Dev, &xtalkCompEnable);
001a6c  e1a0100d          MOV      r1,sp
001a70  e1a00005          MOV      r0,r5
001a74  ebfffffe          BL       VL53L0X_GetXTalkCompensationEnable
001a78  e1a07000          MOV      r7,r0
;;;1453   	if (Status == VL53L0X_ERROR_NONE) {
001a7c  e3570000          CMP      r7,#0
001a80  1a000008          BNE      |L1.6824|
;;;1454   
;;;1455   		if (xtalkCompEnable) {
001a84  e5dd0000          LDRB     r0,[sp,#0]
001a88  e3500000          CMP      r0,#0
001a8c  0a000005          BEQ      |L1.6824|
;;;1456   
;;;1457   			VL53L0X_GETPARAMETERFIELD(
001a90  e5959020          LDR      r9,[r5,#0x20]
;;;1458   				Dev,
;;;1459   				XTalkCompensationRateMegaCps,
;;;1460   				xtalkPerSpadMegaCps);
;;;1461   
;;;1462   			/* FixPoint1616 * FixPoint 8:8 = FixPoint0824 */
;;;1463   			totalXtalkMegaCps =
001a94  e1d601b4          LDRH     r0,[r6,#0x14]
001a98  e0080990          MUL      r8,r0,r9
;;;1464   				pRangingMeasurementData->EffectiveSpadRtnCount *
;;;1465   				xtalkPerSpadMegaCps;
;;;1466   
;;;1467   			/* FixPoint0824 >> 8 = FixPoint1616 */
;;;1468   			*ptotal_xtalk_rate_mcps =
001a9c  e2880080          ADD      r0,r8,#0x80
001aa0  e1a00420          LSR      r0,r0,#8
001aa4  e5840000          STR      r0,[r4,#0]
                  |L1.6824|
;;;1469   				(totalXtalkMegaCps + 0x80) >> 8;
;;;1470   		}
;;;1471   	}
;;;1472   
;;;1473   	return Status;
001aa8  e1a00007          MOV      r0,r7
;;;1474   }
001aac  e8bd83f8          POP      {r3-r9,pc}
;;;1475   
                          ENDP

                  VL53L0X_get_total_signal_rate PROC
;;;1476   VL53L0X_Error VL53L0X_get_total_signal_rate(VL53L0X_DEV Dev,
001ab0  e92d40f8          PUSH     {r3-r7,lr}
;;;1477   	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData,
;;;1478   	FixPoint1616_t *ptotal_signal_rate_mcps)
;;;1479   {
001ab4  e1a07000          MOV      r7,r0
001ab8  e1a05001          MOV      r5,r1
001abc  e1a04002          MOV      r4,r2
;;;1480   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001ac0  e3a06000          MOV      r6,#0
;;;1481   	FixPoint1616_t totalXtalkMegaCps;
;;;1482   
;;;1483   	LOG_FUNCTION_START("");
;;;1484   
;;;1485   	*ptotal_signal_rate_mcps =
001ac4  e595000c          LDR      r0,[r5,#0xc]
001ac8  e5840000          STR      r0,[r4,#0]
;;;1486   		pRangingMeasurementData->SignalRateRtnMegaCps;
;;;1487   
;;;1488   	Status = VL53L0X_get_total_xtalk_rate(
001acc  e1a0200d          MOV      r2,sp
001ad0  e1a01005          MOV      r1,r5
001ad4  e1a00007          MOV      r0,r7
001ad8  ebfffffe          BL       VL53L0X_get_total_xtalk_rate
001adc  e1a06000          MOV      r6,r0
;;;1489   		Dev, pRangingMeasurementData, &totalXtalkMegaCps);
;;;1490   
;;;1491   	if (Status == VL53L0X_ERROR_NONE)
001ae0  e3560000          CMP      r6,#0
001ae4  1a000003          BNE      |L1.6904|
;;;1492   		*ptotal_signal_rate_mcps += totalXtalkMegaCps;
001ae8  e5940000          LDR      r0,[r4,#0]
001aec  e59d1000          LDR      r1,[sp,#0]
001af0  e0800001          ADD      r0,r0,r1
001af4  e5840000          STR      r0,[r4,#0]
                  |L1.6904|
;;;1493   
;;;1494   	return Status;
001af8  e1a00006          MOV      r0,r6
;;;1495   }
001afc  e8bd80f8          POP      {r3-r7,pc}
;;;1496   
                          ENDP

                  VL53L0X_calc_dmax PROC
;;;1497   VL53L0X_Error VL53L0X_calc_dmax(
001b00  e92d4fff          PUSH     {r0-r11,lr}
;;;1498   	VL53L0X_DEV Dev,
;;;1499   	FixPoint1616_t totalSignalRate_mcps,
;;;1500   	FixPoint1616_t totalCorrSignalRate_mcps,
;;;1501   	FixPoint1616_t pwMult,
;;;1502   	uint32_t sigmaEstimateP1,
;;;1503   	FixPoint1616_t sigmaEstimateP2,
;;;1504   	uint32_t peakVcselDuration_us,
;;;1505   	uint32_t *pdmax_mm)
;;;1506   {
001b04  e24dd044          SUB      sp,sp,#0x44
001b08  e1a07002          MOV      r7,r2
001b0c  e59d807c          LDR      r8,[sp,#0x7c]
;;;1507   	const uint32_t cSigmaLimit		= 18;
001b10  e3a00012          MOV      r0,#0x12
001b14  e58d0040          STR      r0,[sp,#0x40]
;;;1508   	const FixPoint1616_t cSignalLimit	= 0x4000; /* 0.25 */
001b18  e3a00901          MOV      r0,#0x4000
001b1c  e58d003c          STR      r0,[sp,#0x3c]
;;;1509   	const FixPoint1616_t cSigmaEstRef	= 0x00000042; /* 0.001 */
001b20  e3a00042          MOV      r0,#0x42
001b24  e58d0038          STR      r0,[sp,#0x38]
;;;1510   	const uint32_t cAmbEffWidthSigmaEst_ns = 6;
001b28  e3a00006          MOV      r0,#6
001b2c  e58d0034          STR      r0,[sp,#0x34]
;;;1511   	const uint32_t cAmbEffWidthDMax_ns	   = 7;
001b30  e3a00007          MOV      r0,#7
001b34  e58d0030          STR      r0,[sp,#0x30]
;;;1512   	uint32_t dmaxCalRange_mm;
;;;1513   	FixPoint1616_t dmaxCalSignalRateRtn_mcps;
;;;1514   	FixPoint1616_t minSignalNeeded;
;;;1515   	FixPoint1616_t minSignalNeeded_p1;
;;;1516   	FixPoint1616_t minSignalNeeded_p2;
;;;1517   	FixPoint1616_t minSignalNeeded_p3;
;;;1518   	FixPoint1616_t minSignalNeeded_p4;
;;;1519   	FixPoint1616_t sigmaLimitTmp;
;;;1520   	FixPoint1616_t sigmaEstSqTmp;
;;;1521   	FixPoint1616_t signalLimitTmp;
;;;1522   	FixPoint1616_t SignalAt0mm;
;;;1523   	FixPoint1616_t dmaxDark;
;;;1524   	FixPoint1616_t dmaxAmbient;
;;;1525   	FixPoint1616_t dmaxDarkTmp;
;;;1526   	FixPoint1616_t sigmaEstP2Tmp;
;;;1527   	uint32_t signalRateTemp_mcps;
;;;1528   
;;;1529   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001b38  e3a00000          MOV      r0,#0
001b3c  e58d0004          STR      r0,[sp,#4]
;;;1530   
;;;1531   	LOG_FUNCTION_START("");
;;;1532   
;;;1533   	dmaxCalRange_mm =
001b40  e59d0044          LDR      r0,[sp,#0x44]
001b44  e2800c01          ADD      r0,r0,#0x100
001b48  e1d005b4          LDRH     r0,[r0,#0x54]
001b4c  e58d002c          STR      r0,[sp,#0x2c]
;;;1534   		PALDevDataGet(Dev, DmaxCalRangeMilliMeter);
;;;1535   
;;;1536   	dmaxCalSignalRateRtn_mcps =
001b50  e59d0044          LDR      r0,[sp,#0x44]
001b54  e5900158          LDR      r0,[r0,#0x158]
001b58  e58d0028          STR      r0,[sp,#0x28]
;;;1537   		PALDevDataGet(Dev, DmaxCalSignalRateRtnMegaCps);
;;;1538   
;;;1539   	/* uint32 * FixPoint1616 = FixPoint1616 */
;;;1540   	SignalAt0mm = dmaxCalRange_mm * dmaxCalSignalRateRtn_mcps;
001b5c  e59d002c          LDR      r0,[sp,#0x2c]
001b60  e59d1028          LDR      r1,[sp,#0x28]
001b64  e00a0190          MUL      r10,r0,r1
;;;1541   
;;;1542   	/* FixPoint1616 >> 8 = FixPoint2408 */
;;;1543   	SignalAt0mm = (SignalAt0mm + 0x80) >> 8;
001b68  e28a0080          ADD      r0,r10,#0x80
001b6c  e1a0a420          LSR      r10,r0,#8
;;;1544   	SignalAt0mm *= dmaxCalRange_mm;
001b70  e59d002c          LDR      r0,[sp,#0x2c]
001b74  e00a0a90          MUL      r10,r0,r10
;;;1545   
;;;1546   	minSignalNeeded_p1 = 0;
001b78  e3a05000          MOV      r5,#0
;;;1547   	if (totalCorrSignalRate_mcps > 0) {
001b7c  e3570000          CMP      r7,#0
001b80  0a00000d          BEQ      |L1.7100|
;;;1548   
;;;1549   		/* Shift by 10 bits to increase resolution prior to the
;;;1550   		 * division */
;;;1551   		signalRateTemp_mcps = totalSignalRate_mcps << 10;
001b84  e59d0048          LDR      r0,[sp,#0x48]
001b88  e1a00500          LSL      r0,r0,#10
001b8c  e58d0008          STR      r0,[sp,#8]
;;;1552   
;;;1553   		/* Add rounding value prior to division */
;;;1554   		minSignalNeeded_p1 = signalRateTemp_mcps +
001b90  e59d0008          LDR      r0,[sp,#8]
001b94  e08050a7          ADD      r5,r0,r7,LSR #1
;;;1555   			(totalCorrSignalRate_mcps/2);
;;;1556   
;;;1557   		/* FixPoint0626/FixPoint1616 = FixPoint2210 */
;;;1558   		minSignalNeeded_p1 /= totalCorrSignalRate_mcps;
001b98  e1a01007          MOV      r1,r7
001b9c  e1a00005          MOV      r0,r5
001ba0  ebfffffe          BL       __aeabi_uidivmod
001ba4  e1a05000          MOV      r5,r0
;;;1559   
;;;1560   		/* Apply a factored version of the speed of light.
;;;1561   		 Correction to be applied at the end */
;;;1562   		minSignalNeeded_p1 *= 3;
001ba8  e0855085          ADD      r5,r5,r5,LSL #1
;;;1563   
;;;1564   		/* FixPoint2210 * FixPoint2210 = FixPoint1220 */
;;;1565   		minSignalNeeded_p1 *= minSignalNeeded_p1;
001bac  e0000595          MUL      r0,r5,r5
001bb0  e1a05000          MOV      r5,r0
;;;1566   
;;;1567   		/* FixPoint1220 >> 16 = FixPoint2804 */
;;;1568   		minSignalNeeded_p1 = (minSignalNeeded_p1 + 0x8000) >> 16;
001bb4  e2850902          ADD      r0,r5,#0x8000
001bb8  e1a05820          LSR      r5,r0,#16
                  |L1.7100|
;;;1569   	}
;;;1570   
;;;1571   	minSignalNeeded_p2 = pwMult * sigmaEstimateP1;
001bbc  e59d0050          LDR      r0,[sp,#0x50]
001bc0  e59d1078          LDR      r1,[sp,#0x78]
001bc4  e0000091          MUL      r0,r1,r0
001bc8  e58d0024          STR      r0,[sp,#0x24]
;;;1572   
;;;1573   	/* FixPoint1616 >> 16 =	 uint32 */
;;;1574   	minSignalNeeded_p2 = (minSignalNeeded_p2 + 0x8000) >> 16;
001bcc  e59d0024          LDR      r0,[sp,#0x24]
001bd0  e2800902          ADD      r0,r0,#0x8000
001bd4  e1a00820          LSR      r0,r0,#16
001bd8  e58d0024          STR      r0,[sp,#0x24]
;;;1575   
;;;1576   	/* uint32 * uint32	=  uint32 */
;;;1577   	minSignalNeeded_p2 *= minSignalNeeded_p2;
001bdc  e59d0024          LDR      r0,[sp,#0x24]
001be0  e0010090          MUL      r1,r0,r0
001be4  e58d1024          STR      r1,[sp,#0x24]
;;;1578   
;;;1579   	/* Check sigmaEstimateP2
;;;1580   	 * If this value is too high there is not enough signal rate
;;;1581   	 * to calculate dmax value so set a suitable value to ensure
;;;1582   	 * a very small dmax.
;;;1583   	 */
;;;1584   	sigmaEstP2Tmp = (sigmaEstimateP2 + 0x8000) >> 16;
001be8  e2880902          ADD      r0,r8,#0x8000
001bec  e1a00820          LSR      r0,r0,#16
001bf0  e58d000c          STR      r0,[sp,#0xc]
;;;1585   	sigmaEstP2Tmp = (sigmaEstP2Tmp + cAmbEffWidthSigmaEst_ns/2)/
001bf4  e3a01006          MOV      r1,#6
001bf8  e59d000c          LDR      r0,[sp,#0xc]
001bfc  e2800003          ADD      r0,r0,#3
001c00  ebfffffe          BL       __aeabi_uidivmod
001c04  e58d000c          STR      r0,[sp,#0xc]
;;;1586   		cAmbEffWidthSigmaEst_ns;
;;;1587   	sigmaEstP2Tmp *= cAmbEffWidthDMax_ns;
001c08  e59d000c          LDR      r0,[sp,#0xc]
001c0c  e0600180          RSB      r0,r0,r0,LSL #3
001c10  e58d000c          STR      r0,[sp,#0xc]
;;;1588   
;;;1589   	if (sigmaEstP2Tmp > 0xffff) {
001c14  e59d000c          LDR      r0,[sp,#0xc]
001c18  e3500801          CMP      r0,#0x10000
001c1c  3a000002          BCC      |L1.7212|
;;;1590   		minSignalNeeded_p3 = 0xfff00000;
001c20  e59f082c          LDR      r0,|L1.9300|
001c24  e58d0020          STR      r0,[sp,#0x20]
001c28  ea00000a          B        |L1.7256|
                  |L1.7212|
;;;1591   	} else {
;;;1592   
;;;1593   		/* DMAX uses a different ambient width from sigma, so apply
;;;1594   		 * correction.
;;;1595   		 * Perform division before multiplication to prevent overflow.
;;;1596   		 */
;;;1597   		sigmaEstimateP2 = (sigmaEstimateP2 + cAmbEffWidthSigmaEst_ns/2)/
001c2c  e3a01006          MOV      r1,#6
001c30  e2880003          ADD      r0,r8,#3
001c34  ebfffffe          BL       __aeabi_uidivmod
001c38  e1a08000          MOV      r8,r0
;;;1598   			cAmbEffWidthSigmaEst_ns;
;;;1599   		sigmaEstimateP2 *= cAmbEffWidthDMax_ns;
001c3c  e0688188          RSB      r8,r8,r8,LSL #3
;;;1600   
;;;1601   		/* FixPoint1616 >> 16 = uint32 */
;;;1602   		minSignalNeeded_p3 = (sigmaEstimateP2 + 0x8000) >> 16;
001c40  e2880902          ADD      r0,r8,#0x8000
001c44  e1a00820          LSR      r0,r0,#16
001c48  e58d0020          STR      r0,[sp,#0x20]
;;;1603   
;;;1604   		minSignalNeeded_p3 *= minSignalNeeded_p3;
001c4c  e59d0020          LDR      r0,[sp,#0x20]
001c50  e0010090          MUL      r1,r0,r0
001c54  e58d1020          STR      r1,[sp,#0x20]
                  |L1.7256|
;;;1605   
;;;1606   	}
;;;1607   
;;;1608   	/* FixPoint1814 / uint32 = FixPoint1814 */
;;;1609   	sigmaLimitTmp = ((cSigmaLimit << 14) + 500) / 1000;
001c58  e59f07f8          LDR      r0,|L1.9304|
001c5c  e58d0018          STR      r0,[sp,#0x18]
;;;1610   
;;;1611   	/* FixPoint1814 * FixPoint1814 = FixPoint3628 := FixPoint0428 */
;;;1612   	sigmaLimitTmp *= sigmaLimitTmp;
001c60  e59d0018          LDR      r0,[sp,#0x18]
001c64  e1600080          SMULBB   r0,r0,r0
001c68  e58d0018          STR      r0,[sp,#0x18]
;;;1613   
;;;1614   	/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
;;;1615   	sigmaEstSqTmp = cSigmaEstRef * cSigmaEstRef;
001c6c  e59f07e8          LDR      r0,|L1.9308|
001c70  e58d0014          STR      r0,[sp,#0x14]
;;;1616   
;;;1617   	/* FixPoint3232 >> 4 = FixPoint0428 */
;;;1618   	sigmaEstSqTmp = (sigmaEstSqTmp + 0x08) >> 4;
001c74  e59d0014          LDR      r0,[sp,#0x14]
001c78  e2800008          ADD      r0,r0,#8
001c7c  e1a00220          LSR      r0,r0,#4
001c80  e58d0014          STR      r0,[sp,#0x14]
;;;1619   
;;;1620   	/* FixPoint0428 - FixPoint0428	= FixPoint0428 */
;;;1621   	sigmaLimitTmp -=  sigmaEstSqTmp;
001c84  e59d0018          LDR      r0,[sp,#0x18]
001c88  e59d1014          LDR      r1,[sp,#0x14]
001c8c  e0400001          SUB      r0,r0,r1
001c90  e58d0018          STR      r0,[sp,#0x18]
;;;1622   
;;;1623   	/* uint32_t * FixPoint0428 = FixPoint0428 */
;;;1624   	minSignalNeeded_p4 = 4 * 12 * sigmaLimitTmp;
001c94  e59d0018          LDR      r0,[sp,#0x18]
001c98  e0800080          ADD      r0,r0,r0,LSL #1
001c9c  e1a00200          LSL      r0,r0,#4
001ca0  e58d001c          STR      r0,[sp,#0x1c]
;;;1625   
;;;1626   	/* FixPoint0428 >> 14 = FixPoint1814 */
;;;1627   	minSignalNeeded_p4 = (minSignalNeeded_p4 + 0x2000) >> 14;
001ca4  e59d001c          LDR      r0,[sp,#0x1c]
001ca8  e2800a02          ADD      r0,r0,#0x2000
001cac  e1a00720          LSR      r0,r0,#14
001cb0  e58d001c          STR      r0,[sp,#0x1c]
;;;1628   
;;;1629   	/* uint32 + uint32 = uint32 */
;;;1630   	minSignalNeeded = (minSignalNeeded_p2 + minSignalNeeded_p3);
001cb4  e59d0024          LDR      r0,[sp,#0x24]
001cb8  e59d1020          LDR      r1,[sp,#0x20]
001cbc  e0804001          ADD      r4,r0,r1
;;;1631   
;;;1632   	/* uint32 / uint32 = uint32 */
;;;1633   	minSignalNeeded += (peakVcselDuration_us/2);
001cc0  e59d0080          LDR      r0,[sp,#0x80]
001cc4  e08440a0          ADD      r4,r4,r0,LSR #1
;;;1634   	minSignalNeeded /= peakVcselDuration_us;
001cc8  e1a00004          MOV      r0,r4
001ccc  e59d1080          LDR      r1,[sp,#0x80]
001cd0  ebfffffe          BL       __aeabi_uidivmod
001cd4  e1a04000          MOV      r4,r0
;;;1635   
;;;1636   	/* uint32 << 14 = FixPoint1814 */
;;;1637   	minSignalNeeded <<= 14;
001cd8  e1a04704          LSL      r4,r4,#14
;;;1638   
;;;1639   	/* FixPoint1814 / FixPoint1814 = uint32 */
;;;1640   	minSignalNeeded += (minSignalNeeded_p4/2);
001cdc  e59d001c          LDR      r0,[sp,#0x1c]
001ce0  e08440a0          ADD      r4,r4,r0,LSR #1
;;;1641   	minSignalNeeded /= minSignalNeeded_p4;
001ce4  e1a00004          MOV      r0,r4
001ce8  e59d101c          LDR      r1,[sp,#0x1c]
001cec  ebfffffe          BL       __aeabi_uidivmod
001cf0  e1a04000          MOV      r4,r0
;;;1642   
;;;1643   	/* FixPoint3200 * FixPoint2804 := FixPoint2804*/
;;;1644   	minSignalNeeded *= minSignalNeeded_p1;
001cf4  e0040495          MUL      r4,r5,r4
;;;1645   
;;;1646   	/* Apply correction by dividing by 1000000.
;;;1647   	 * This assumes 10E16 on the numerator of the equation
;;;1648   	 * and 10E-22 on the denominator.
;;;1649   	 * We do this because 32bit fix point calculation can't
;;;1650   	 * handle the larger and smaller elements of this equation,
;;;1651   	 * i.e. speed of light and pulse widths.
;;;1652   	 */
;;;1653   	minSignalNeeded = (minSignalNeeded + 500) / 1000;
001cf8  e3a01ffa          MOV      r1,#0x3e8
001cfc  e2840f7d          ADD      r0,r4,#0x1f4
001d00  ebfffffe          BL       __aeabi_uidivmod
001d04  e1a04000          MOV      r4,r0
;;;1654   	minSignalNeeded <<= 4;
001d08  e1a04204          LSL      r4,r4,#4
;;;1655   
;;;1656   	minSignalNeeded = (minSignalNeeded + 500) / 1000;
001d0c  e3a01ffa          MOV      r1,#0x3e8
001d10  e2840f7d          ADD      r0,r4,#0x1f4
001d14  ebfffffe          BL       __aeabi_uidivmod
001d18  e1a04000          MOV      r4,r0
;;;1657   
;;;1658   	/* FixPoint1616 >> 8 = FixPoint2408 */
;;;1659   	signalLimitTmp = (cSignalLimit + 0x80) >> 8;
001d1c  e3a09040          MOV      r9,#0x40
;;;1660   
;;;1661   	/* FixPoint2408/FixPoint2408 = uint32 */
;;;1662   	if (signalLimitTmp != 0)
001d20  e3590000          CMP      r9,#0
001d24  0a000004          BEQ      |L1.7484|
;;;1663   		dmaxDarkTmp = (SignalAt0mm + (signalLimitTmp / 2))
001d28  e08a00a9          ADD      r0,r10,r9,LSR #1
001d2c  e1a01009          MOV      r1,r9
001d30  ebfffffe          BL       __aeabi_uidivmod
001d34  e58d0010          STR      r0,[sp,#0x10]
001d38  ea000001          B        |L1.7492|
                  |L1.7484|
;;;1664   			/ signalLimitTmp;
;;;1665   	else
;;;1666   		dmaxDarkTmp = 0;
001d3c  e3a00000          MOV      r0,#0
001d40  e58d0010          STR      r0,[sp,#0x10]
                  |L1.7492|
;;;1667   
;;;1668   	dmaxDark = VL53L0X_isqrt(dmaxDarkTmp);
001d44  e59d0010          LDR      r0,[sp,#0x10]
001d48  ebfffffe          BL       VL53L0X_isqrt
001d4c  e1a0b000          MOV      r11,r0
;;;1669   
;;;1670   	/* FixPoint2408/FixPoint2408 = uint32 */
;;;1671   	if (minSignalNeeded != 0)
001d50  e3540000          CMP      r4,#0
001d54  0a000004          BEQ      |L1.7532|
;;;1672   		dmaxAmbient = (SignalAt0mm + minSignalNeeded/2)
001d58  e08a00a4          ADD      r0,r10,r4,LSR #1
001d5c  e1a01004          MOV      r1,r4
001d60  ebfffffe          BL       __aeabi_uidivmod
001d64  e1a06000          MOV      r6,r0
001d68  ea000000          B        |L1.7536|
                  |L1.7532|
;;;1673   			/ minSignalNeeded;
;;;1674   	else
;;;1675   		dmaxAmbient = 0;
001d6c  e3a06000          MOV      r6,#0
                  |L1.7536|
;;;1676   
;;;1677   	dmaxAmbient = VL53L0X_isqrt(dmaxAmbient);
001d70  e1a00006          MOV      r0,r6
001d74  ebfffffe          BL       VL53L0X_isqrt
001d78  e1a06000          MOV      r6,r0
;;;1678   
;;;1679   	*pdmax_mm = dmaxDark;
001d7c  e59d0084          LDR      r0,[sp,#0x84]
001d80  e580b000          STR      r11,[r0,#0]
;;;1680   	if (dmaxDark > dmaxAmbient)
001d84  e15b0006          CMP      r11,r6
001d88  9a000001          BLS      |L1.7572|
;;;1681   		*pdmax_mm = dmaxAmbient;
001d8c  e59d0084          LDR      r0,[sp,#0x84]
001d90  e5806000          STR      r6,[r0,#0]
                  |L1.7572|
;;;1682   
;;;1683   	LOG_FUNCTION_END(Status);
;;;1684   
;;;1685   	return Status;
001d94  e59d0004          LDR      r0,[sp,#4]
001d98  e28dd054          ADD      sp,sp,#0x54
;;;1686   }
001d9c  e8bd8ff0          POP      {r4-r11,pc}
;;;1687   
                          ENDP

                  VL53L0X_calc_sigma_estimate PROC
;;;1688   
;;;1689   VL53L0X_Error VL53L0X_calc_sigma_estimate(VL53L0X_DEV Dev,
001da0  e92d4fff          PUSH     {r0-r11,lr}
;;;1690   	VL53L0X_RangingMeasurementData_t *pRangingMeasurementData,
;;;1691   	FixPoint1616_t *pSigmaEstimate,
;;;1692   	uint32_t *pDmax_mm)
;;;1693   {
001da4  e24dd09c          SUB      sp,sp,#0x9c
001da8  e1a04000          MOV      r4,r0
;;;1694   	/* Expressed in 100ths of a ns, i.e. centi-ns */
;;;1695   	const uint32_t cPulseEffectiveWidth_centi_ns   = 800;
001dac  e3a00e32          MOV      r0,#0x320
001db0  e58d0098          STR      r0,[sp,#0x98]
;;;1696   	/* Expressed in 100ths of a ns, i.e. centi-ns */
;;;1697   	const uint32_t cAmbientEffectiveWidth_centi_ns = 600;
001db4  e3a00f96          MOV      r0,#0x258
001db8  e58d0094          STR      r0,[sp,#0x94]
;;;1698   	const FixPoint1616_t cSigmaEstRef	= 0x00000042; /* 0.001 */
001dbc  e3a00042          MOV      r0,#0x42
001dc0  e58d0090          STR      r0,[sp,#0x90]
;;;1699   	const uint32_t cVcselPulseWidth_ps	= 4700; /* pico secs */
001dc4  e59f0694          LDR      r0,|L1.9312|
001dc8  e58d008c          STR      r0,[sp,#0x8c]
;;;1700   	const FixPoint1616_t cSigmaEstMax	= 0x028F87AE;
001dcc  e59f0690          LDR      r0,|L1.9316|
001dd0  e58d0088          STR      r0,[sp,#0x88]
;;;1701   	const FixPoint1616_t cSigmaEstRtnMax	= 0xF000;
001dd4  e3a00a0f          MOV      r0,#0xf000
001dd8  e58d0084          STR      r0,[sp,#0x84]
;;;1702   	const FixPoint1616_t cAmbToSignalRatioMax = 0xF0000000/
001ddc  e59f0684          LDR      r0,|L1.9320|
001de0  e58d0080          STR      r0,[sp,#0x80]
;;;1703   		cAmbientEffectiveWidth_centi_ns;
;;;1704   	/* Time Of Flight per mm (6.6 pico secs) */
;;;1705   	const FixPoint1616_t cTOF_per_mm_ps		= 0x0006999A;
001de4  e59f0680          LDR      r0,|L1.9324|
001de8  e58d007c          STR      r0,[sp,#0x7c]
;;;1706   	const uint32_t c16BitRoundingParam		= 0x00008000;
001dec  e3a00902          MOV      r0,#0x8000
001df0  e58d0078          STR      r0,[sp,#0x78]
;;;1707   	const FixPoint1616_t cMaxXTalk_kcps		= 0x00320000;
001df4  e3a00832          MOV      r0,#0x320000
001df8  e58d0074          STR      r0,[sp,#0x74]
;;;1708   	const uint32_t cPllPeriod_ps			= 1655;
001dfc  e51f0dbc          LDR      r0,|L1.4168|
001e00  e58d0070          STR      r0,[sp,#0x70]
;;;1709   
;;;1710   	uint32_t vcselTotalEventsRtn;
;;;1711   	uint32_t finalRangeTimeoutMicroSecs;
;;;1712   	uint32_t preRangeTimeoutMicroSecs;
;;;1713   	FixPoint1616_t sigmaEstimateP1;
;;;1714   	FixPoint1616_t sigmaEstimateP2;
;;;1715   	FixPoint1616_t sigmaEstimateP3;
;;;1716   	FixPoint1616_t deltaT_ps;
;;;1717   	FixPoint1616_t pwMult;
;;;1718   	FixPoint1616_t sigmaEstRtn;
;;;1719   	FixPoint1616_t sigmaEstimate;
;;;1720   	FixPoint1616_t xTalkCorrection;
;;;1721   	FixPoint1616_t ambientRate_kcps;
;;;1722   	FixPoint1616_t peakSignalRate_kcps;
;;;1723   	FixPoint1616_t xTalkCompRate_mcps;
;;;1724   	uint32_t xTalkCompRate_kcps;
;;;1725   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
001e04  e1a00000          MOV      r0,r0
;;;1726   	FixPoint1616_t diff1_mcps;
;;;1727   	FixPoint1616_t diff2_mcps;
;;;1728   	FixPoint1616_t sqr1;
;;;1729   	FixPoint1616_t sqr2;
;;;1730   	FixPoint1616_t sqrSum;
;;;1731   	FixPoint1616_t sqrtResult_centi_ns;
;;;1732   	FixPoint1616_t sqrtResult;
;;;1733   	FixPoint1616_t totalSignalRate_mcps;
;;;1734   	FixPoint1616_t correctedSignalRate_mcps;
;;;1735   	uint32_t vcselWidth;
;;;1736   	uint32_t finalRangeMacroPCLKS;
;;;1737   	uint32_t preRangeMacroPCLKS;
;;;1738   	uint32_t peakVcselDuration_us;
;;;1739   	uint8_t finalRangeVcselPCLKS;
;;;1740   	uint8_t preRangeVcselPCLKS;
;;;1741   	/*! \addtogroup calc_sigma_estimate
;;;1742   	 * @{
;;;1743   	 *
;;;1744   	 * Estimates the range sigma based on the
;;;1745   	 *
;;;1746   	 *	- vcsel_rate_kcps
;;;1747   	 *	- ambient_rate_kcps
;;;1748   	 *	- signal_total_events
;;;1749   	 *	- xtalk_rate
;;;1750   	 *
;;;1751   	 * and the following parameters
;;;1752   	 *
;;;1753   	 *	- SigmaEstRefArray
;;;1754   	 *	- SigmaEstEffPulseWidth
;;;1755   	 *	- SigmaEstEffAmbWidth
;;;1756   	 */
;;;1757   
;;;1758   	LOG_FUNCTION_START("");
;;;1759   
;;;1760   	VL53L0X_GETPARAMETERFIELD(Dev, XTalkCompensationRateMegaCps,
001e08  e5940020          LDR      r0,[r4,#0x20]
001e0c  e58d0048          STR      r0,[sp,#0x48]
;;;1761   			xTalkCompRate_mcps);
;;;1762   
;;;1763   	/*
;;;1764   	 * We work in kcps rather than mcps as this helps keep within the
;;;1765   	 * confines of the 32 Fix1616 type.
;;;1766   	 */
;;;1767   
;;;1768   	ambientRate_kcps =
001e10  e59d00a0          LDR      r0,[sp,#0xa0]
001e14  e5900010          LDR      r0,[r0,#0x10]
001e18  e3a01ffa          MOV      r1,#0x3e8
001e1c  e0000091          MUL      r0,r1,r0
001e20  e1a00820          LSR      r0,r0,#16
001e24  e58d004c          STR      r0,[sp,#0x4c]
;;;1769   		(pRangingMeasurementData->AmbientRateRtnMegaCps * 1000) >> 16;
;;;1770   
;;;1771   	correctedSignalRate_mcps =
001e28  e59d00a0          LDR      r0,[sp,#0xa0]
001e2c  e590000c          LDR      r0,[r0,#0xc]
001e30  e58d0024          STR      r0,[sp,#0x24]
;;;1772   		pRangingMeasurementData->SignalRateRtnMegaCps;
;;;1773   
;;;1774   
;;;1775   	Status = VL53L0X_get_total_signal_rate(
001e34  e28d2028          ADD      r2,sp,#0x28
001e38  e1a00004          MOV      r0,r4
001e3c  e59d10a0          LDR      r1,[sp,#0xa0]
001e40  ebfffffe          BL       VL53L0X_get_total_signal_rate
;;;1776   		Dev, pRangingMeasurementData, &totalSignalRate_mcps);
;;;1777   	Status = VL53L0X_get_total_xtalk_rate(
001e44  e28d2048          ADD      r2,sp,#0x48
001e48  e1a00004          MOV      r0,r4
001e4c  e59d10a0          LDR      r1,[sp,#0xa0]
001e50  ebfffffe          BL       VL53L0X_get_total_xtalk_rate
001e54  e58d0040          STR      r0,[sp,#0x40]
;;;1778   		Dev, pRangingMeasurementData, &xTalkCompRate_mcps);
;;;1779   
;;;1780   
;;;1781   	/* Signal rate measurement provided by device is the
;;;1782   	 * peak signal rate, not average.
;;;1783   	 */
;;;1784   	peakSignalRate_kcps = (totalSignalRate_mcps * 1000);
001e58  e3a01ffa          MOV      r1,#0x3e8
001e5c  e59d0028          LDR      r0,[sp,#0x28]
001e60  e0070190          MUL      r7,r0,r1
;;;1785   	peakSignalRate_kcps = (peakSignalRate_kcps + 0x8000) >> 16;
001e64  e2870902          ADD      r0,r7,#0x8000
001e68  e1a07820          LSR      r7,r0,#16
;;;1786   
;;;1787   	xTalkCompRate_kcps = xTalkCompRate_mcps * 1000;
001e6c  e59d0048          LDR      r0,[sp,#0x48]
001e70  e0000091          MUL      r0,r1,r0
001e74  e58d0044          STR      r0,[sp,#0x44]
;;;1788   
;;;1789   	if (xTalkCompRate_kcps > cMaxXTalk_kcps)
001e78  e59d0044          LDR      r0,[sp,#0x44]
001e7c  e3500832          CMP      r0,#0x320000
001e80  9a000001          BLS      |L1.7820|
;;;1790   		xTalkCompRate_kcps = cMaxXTalk_kcps;
001e84  e3a00832          MOV      r0,#0x320000
001e88  e58d0044          STR      r0,[sp,#0x44]
                  |L1.7820|
;;;1791   
;;;1792   	if (Status == VL53L0X_ERROR_NONE) {
001e8c  e59d0040          LDR      r0,[sp,#0x40]
001e90  e3500000          CMP      r0,#0
001e94  1a000035          BNE      |L1.8048|
;;;1793   
;;;1794   		/* Calculate final range macro periods */
;;;1795   		finalRangeTimeoutMicroSecs = VL53L0X_GETDEVICESPECIFICPARAMETER(
001e98  e59400dc          LDR      r0,[r4,#0xdc]
001e9c  e58d0068          STR      r0,[sp,#0x68]
;;;1796   			Dev, FinalRangeTimeoutMicroSecs);
;;;1797   
;;;1798   		finalRangeVcselPCLKS = VL53L0X_GETDEVICESPECIFICPARAMETER(
001ea0  e5d400e0          LDRB     r0,[r4,#0xe0]
001ea4  e58d0014          STR      r0,[sp,#0x14]
;;;1799   			Dev, FinalRangeVcselPulsePeriod);
;;;1800   
;;;1801   		finalRangeMacroPCLKS = VL53L0X_calc_timeout_mclks(
001ea8  e1a00004          MOV      r0,r4
001eac  e59d1068          LDR      r1,[sp,#0x68]
001eb0  e59d2014          LDR      r2,[sp,#0x14]
001eb4  ebfffffe          BL       VL53L0X_calc_timeout_mclks
001eb8  e58d001c          STR      r0,[sp,#0x1c]
;;;1802   			Dev, finalRangeTimeoutMicroSecs, finalRangeVcselPCLKS);
;;;1803   
;;;1804   		/* Calculate pre-range macro periods */
;;;1805   		preRangeTimeoutMicroSecs = VL53L0X_GETDEVICESPECIFICPARAMETER(
001ebc  e59400e4          LDR      r0,[r4,#0xe4]
001ec0  e58d0064          STR      r0,[sp,#0x64]
;;;1806   			Dev, PreRangeTimeoutMicroSecs);
;;;1807   
;;;1808   		preRangeVcselPCLKS = VL53L0X_GETDEVICESPECIFICPARAMETER(
001ec4  e5d400e8          LDRB     r0,[r4,#0xe8]
001ec8  e58d0010          STR      r0,[sp,#0x10]
;;;1809   			Dev, PreRangeVcselPulsePeriod);
;;;1810   
;;;1811   		preRangeMacroPCLKS = VL53L0X_calc_timeout_mclks(
001ecc  e1a00004          MOV      r0,r4
001ed0  e59d1064          LDR      r1,[sp,#0x64]
001ed4  e59d2010          LDR      r2,[sp,#0x10]
001ed8  ebfffffe          BL       VL53L0X_calc_timeout_mclks
001edc  e58d0018          STR      r0,[sp,#0x18]
;;;1812   			Dev, preRangeTimeoutMicroSecs, preRangeVcselPCLKS);
;;;1813   
;;;1814   		vcselWidth = 3;
001ee0  e3a00003          MOV      r0,#3
001ee4  e58d0020          STR      r0,[sp,#0x20]
;;;1815   		if (finalRangeVcselPCLKS == 8)
001ee8  e59d0014          LDR      r0,[sp,#0x14]
001eec  e3500008          CMP      r0,#8
001ef0  1a000001          BNE      |L1.7932|
;;;1816   			vcselWidth = 2;
001ef4  e3a00002          MOV      r0,#2
001ef8  e58d0020          STR      r0,[sp,#0x20]
                  |L1.7932|
;;;1817   
;;;1818   
;;;1819   		peakVcselDuration_us = vcselWidth * 2048 *
001efc  e59d0020          LDR      r0,[sp,#0x20]
001f00  e1a02580          LSL      r2,r0,#11
001f04  e1cd01d8          LDRD     r0,r1,[sp,#0x18]
001f08  e0800001          ADD      r0,r0,r1
001f0c  e00b0092          MUL      r11,r2,r0
;;;1820   			(preRangeMacroPCLKS + finalRangeMacroPCLKS);
;;;1821   		peakVcselDuration_us = (peakVcselDuration_us + 500)/1000;
001f10  e3a01ffa          MOV      r1,#0x3e8
001f14  e28b0f7d          ADD      r0,r11,#0x1f4
001f18  ebfffffe          BL       __aeabi_uidivmod
001f1c  e1a0b000          MOV      r11,r0
;;;1822   		peakVcselDuration_us *= cPllPeriod_ps;
001f20  e51f0ee0          LDR      r0,|L1.4168|
001f24  e00b0b90          MUL      r11,r0,r11
;;;1823   		peakVcselDuration_us = (peakVcselDuration_us + 500)/1000;
001f28  e3a01ffa          MOV      r1,#0x3e8
001f2c  e28b0f7d          ADD      r0,r11,#0x1f4
001f30  ebfffffe          BL       __aeabi_uidivmod
001f34  e1a0b000          MOV      r11,r0
;;;1824   
;;;1825   		/* Fix1616 >> 8 = Fix2408 */
;;;1826   		totalSignalRate_mcps = (totalSignalRate_mcps + 0x80) >> 8;
001f38  e59d0028          LDR      r0,[sp,#0x28]
001f3c  e2800080          ADD      r0,r0,#0x80
001f40  e1a00420          LSR      r0,r0,#8
001f44  e58d0028          STR      r0,[sp,#0x28]
;;;1827   
;;;1828   		/* Fix2408 * uint32 = Fix2408 */
;;;1829   		vcselTotalEventsRtn = totalSignalRate_mcps *
001f48  e59d0028          LDR      r0,[sp,#0x28]
001f4c  e000009b          MUL      r0,r11,r0
001f50  e58d006c          STR      r0,[sp,#0x6c]
;;;1830   			peakVcselDuration_us;
;;;1831   
;;;1832   		/* Fix2408 >> 8 = uint32 */
;;;1833   		vcselTotalEventsRtn = (vcselTotalEventsRtn + 0x80) >> 8;
001f54  e59d006c          LDR      r0,[sp,#0x6c]
001f58  e2800080          ADD      r0,r0,#0x80
001f5c  e1a00420          LSR      r0,r0,#8
001f60  e58d006c          STR      r0,[sp,#0x6c]
;;;1834   
;;;1835   		/* Fix2408 << 8 = Fix1616 = */
;;;1836   		totalSignalRate_mcps <<= 8;
001f64  e59d0028          LDR      r0,[sp,#0x28]
001f68  e1a00400          LSL      r0,r0,#8
001f6c  e58d0028          STR      r0,[sp,#0x28]
                  |L1.8048|
;;;1837   	}
;;;1838   
;;;1839   	if (Status != VL53L0X_ERROR_NONE) {
001f70  e59d0040          LDR      r0,[sp,#0x40]
001f74  e3500000          CMP      r0,#0
001f78  0a000002          BEQ      |L1.8072|
;;;1840   		LOG_FUNCTION_END(Status);
;;;1841   		return Status;
001f7c  e59d0040          LDR      r0,[sp,#0x40]
                  |L1.8064|
001f80  e28dd0ac          ADD      sp,sp,#0xac
;;;1842   	}
;;;1843   
;;;1844   	if (peakSignalRate_kcps == 0) {
;;;1845   		*pSigmaEstimate = cSigmaEstMax;
;;;1846   		PALDevDataSet(Dev, SigmaEstimate, cSigmaEstMax);
;;;1847   		*pDmax_mm = 0;
;;;1848   	} else {
;;;1849   		if (vcselTotalEventsRtn < 1)
;;;1850   			vcselTotalEventsRtn = 1;
;;;1851   
;;;1852   		/*
;;;1853   		 * Calculate individual components of the main equation -
;;;1854   		 * replicating the equation implemented in the script
;;;1855   		 * OpenAll_Ewok_ranging_data.jsl.
;;;1856   		 *
;;;1857   		 * sigmaEstimateP1 represents the effective pulse width, which
;;;1858   		 * is a tuning parameter, rather than a real value.
;;;1859   		 *
;;;1860   		 * sigmaEstimateP2 represents the ambient/signal rate ratio
;;;1861   		 * expressed as a multiple of the effective ambient width
;;;1862   		 * (tuning parameter).
;;;1863   		 *
;;;1864   		 * sigmaEstimateP3 provides the signal event component, with the
;;;1865   		 * knowledge that
;;;1866   		 *	- Noise of a square pulse is 1/sqrt(12) of the pulse
;;;1867   		 *	 width.
;;;1868   		 *	- at 0Lux, sigma is proportional to
;;;1869   		 *	  effectiveVcselPulseWidth/sqrt(12 * signalTotalEvents)
;;;1870   		 *
;;;1871   		 * deltaT_ps represents the time of flight in pico secs for the
;;;1872   		 * current range measurement, using the "TOF per mm" constant
;;;1873   		 * (in ps).
;;;1874   		 */
;;;1875   
;;;1876   		sigmaEstimateP1 = cPulseEffectiveWidth_centi_ns;
;;;1877   
;;;1878   		/* ((FixPoint1616 << 16)* uint32)/uint32 = FixPoint1616 */
;;;1879   		sigmaEstimateP2 = (ambientRate_kcps << 16)/peakSignalRate_kcps;
;;;1880   		if (sigmaEstimateP2 > cAmbToSignalRatioMax) {
;;;1881   			/* Clip to prevent overflow. Will ensure safe
;;;1882   			 * max result. */
;;;1883   			sigmaEstimateP2 = cAmbToSignalRatioMax;
;;;1884   		}
;;;1885   		sigmaEstimateP2 *= cAmbientEffectiveWidth_centi_ns;
;;;1886   
;;;1887   		sigmaEstimateP3 = 2 * VL53L0X_isqrt(vcselTotalEventsRtn * 12);
;;;1888   
;;;1889   		/* uint32 * FixPoint1616 = FixPoint1616 */
;;;1890   		deltaT_ps = pRangingMeasurementData->RangeMilliMeter *
;;;1891   					cTOF_per_mm_ps;
;;;1892   
;;;1893   		/*
;;;1894   		 * vcselRate - xtalkCompRate
;;;1895   		 * (uint32 << 16) - FixPoint1616 = FixPoint1616.
;;;1896   		 * Divide result by 1000 to convert to mcps.
;;;1897   		 * 500 is added to ensure rounding when integer division
;;;1898   		 * truncates.
;;;1899   		 */
;;;1900   		diff1_mcps = (((peakSignalRate_kcps << 16) -
;;;1901   			xTalkCompRate_kcps) + 500)/1000;
;;;1902   
;;;1903   		/* vcselRate + xtalkCompRate */
;;;1904   		diff2_mcps = (((peakSignalRate_kcps << 16) +
;;;1905   			xTalkCompRate_kcps) + 500)/1000;
;;;1906   
;;;1907   		/* Shift by 8 bits to increase resolution prior to the
;;;1908   		 * division */
;;;1909   		diff1_mcps <<= 8;
;;;1910   
;;;1911   		/* FixPoint0824/FixPoint1616 = FixPoint2408 */
;;;1912   		xTalkCorrection	 = abs(diff1_mcps/diff2_mcps);
;;;1913   
;;;1914   		/* FixPoint2408 << 8 = FixPoint1616 */
;;;1915   		xTalkCorrection <<= 8;
;;;1916   
;;;1917   		/* FixPoint1616/uint32 = FixPoint1616 */
;;;1918   		pwMult = deltaT_ps/cVcselPulseWidth_ps; /* smaller than 1.0f */
;;;1919   
;;;1920   		/*
;;;1921   		 * FixPoint1616 * FixPoint1616 = FixPoint3232, however both
;;;1922   		 * values are small enough such that32 bits will not be
;;;1923   		 * exceeded.
;;;1924   		 */
;;;1925   		pwMult *= ((1 << 16) - xTalkCorrection);
;;;1926   
;;;1927   		/* (FixPoint3232 >> 16) = FixPoint1616 */
;;;1928   		pwMult =  (pwMult + c16BitRoundingParam) >> 16;
;;;1929   
;;;1930   		/* FixPoint1616 + FixPoint1616 = FixPoint1616 */
;;;1931   		pwMult += (1 << 16);
;;;1932   
;;;1933   		/*
;;;1934   		 * At this point the value will be 1.xx, therefore if we square
;;;1935   		 * the value this will exceed 32 bits. To address this perform
;;;1936   		 * a single shift to the right before the multiplication.
;;;1937   		 */
;;;1938   		pwMult >>= 1;
;;;1939   		/* FixPoint1715 * FixPoint1715 = FixPoint3430 */
;;;1940   		pwMult = pwMult * pwMult;
;;;1941   
;;;1942   		/* (FixPoint3430 >> 14) = Fix1616 */
;;;1943   		pwMult >>= 14;
;;;1944   
;;;1945   		/* FixPoint1616 * uint32 = FixPoint1616 */
;;;1946   		sqr1 = pwMult * sigmaEstimateP1;
;;;1947   
;;;1948   		/* (FixPoint1616 >> 16) = FixPoint3200 */
;;;1949   		sqr1 = (sqr1 + 0x8000) >> 16;
;;;1950   
;;;1951   		/* FixPoint3200 * FixPoint3200 = FixPoint6400 */
;;;1952   		sqr1 *= sqr1;
;;;1953   
;;;1954   		sqr2 = sigmaEstimateP2;
;;;1955   
;;;1956   		/* (FixPoint1616 >> 16) = FixPoint3200 */
;;;1957   		sqr2 = (sqr2 + 0x8000) >> 16;
;;;1958   
;;;1959   		/* FixPoint3200 * FixPoint3200 = FixPoint6400 */
;;;1960   		sqr2 *= sqr2;
;;;1961   
;;;1962   		/* FixPoint64000 + FixPoint6400 = FixPoint6400 */
;;;1963   		sqrSum = sqr1 + sqr2;
;;;1964   
;;;1965   		/* SQRT(FixPoin6400) = FixPoint3200 */
;;;1966   		sqrtResult_centi_ns = VL53L0X_isqrt(sqrSum);
;;;1967   
;;;1968   		/* (FixPoint3200 << 16) = FixPoint1616 */
;;;1969   		sqrtResult_centi_ns <<= 16;
;;;1970   
;;;1971   		/*
;;;1972   		 * Note that the Speed Of Light is expressed in um per 1E-10
;;;1973   		 * seconds (2997) Therefore to get mm/ns we have to divide by
;;;1974   		 * 10000
;;;1975   		 */
;;;1976   		sigmaEstRtn = (((sqrtResult_centi_ns+50)/100) /
;;;1977   				sigmaEstimateP3);
;;;1978   		sigmaEstRtn		 *= VL53L0X_SPEED_OF_LIGHT_IN_AIR;
;;;1979   
;;;1980   		/* Add 5000 before dividing by 10000 to ensure rounding. */
;;;1981   		sigmaEstRtn		 += 5000;
;;;1982   		sigmaEstRtn		 /= 10000;
;;;1983   
;;;1984   		if (sigmaEstRtn > cSigmaEstRtnMax) {
;;;1985   			/* Clip to prevent overflow. Will ensure safe
;;;1986   			 * max result. */
;;;1987   			sigmaEstRtn = cSigmaEstRtnMax;
;;;1988   		}
;;;1989   
;;;1990   		/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
;;;1991   		sqr1 = sigmaEstRtn * sigmaEstRtn;
;;;1992   		/* FixPoint1616 * FixPoint1616 = FixPoint3232 */
;;;1993   		sqr2 = cSigmaEstRef * cSigmaEstRef;
;;;1994   
;;;1995   		/* sqrt(FixPoint3232) = FixPoint1616 */
;;;1996   		sqrtResult = VL53L0X_isqrt((sqr1 + sqr2));
;;;1997   		/*
;;;1998   		 * Note that the Shift by 4 bits increases resolution prior to
;;;1999   		 * the sqrt, therefore the result must be shifted by 2 bits to
;;;2000   		 * the right to revert back to the FixPoint1616 format.
;;;2001   		 */
;;;2002   
;;;2003   		sigmaEstimate	 = 1000 * sqrtResult;
;;;2004   
;;;2005   		if ((peakSignalRate_kcps < 1) || (vcselTotalEventsRtn < 1) ||
;;;2006   				(sigmaEstimate > cSigmaEstMax)) {
;;;2007   				sigmaEstimate = cSigmaEstMax;
;;;2008   		}
;;;2009   
;;;2010   		*pSigmaEstimate = (uint32_t)(sigmaEstimate);
;;;2011   		PALDevDataSet(Dev, SigmaEstimate, *pSigmaEstimate);
;;;2012   		Status = VL53L0X_calc_dmax(
;;;2013   			Dev,
;;;2014   			totalSignalRate_mcps,
;;;2015   			correctedSignalRate_mcps,
;;;2016   			pwMult,
;;;2017   			sigmaEstimateP1,
;;;2018   			sigmaEstimateP2,
;;;2019   			peakVcselDuration_us,
;;;2020   			pDmax_mm);
;;;2021   	}
;;;2022   
;;;2023   	LOG_FUNCTION_END(Status);
;;;2024   	return Status;
;;;2025   }
001f84  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.8072|
001f88  e3570000          CMP      r7,#0                 ;1844
001f8c  1a000008          BNE      |L1.8116|
001f90  e59f14cc          LDR      r1,|L1.9316|
001f94  e59d00a4          LDR      r0,[sp,#0xa4]         ;1845
001f98  e5801000          STR      r1,[r0,#0]            ;1845
001f9c  e1a00001          MOV      r0,r1                 ;1846
001fa0  e5840140          STR      r0,[r4,#0x140]        ;1846
001fa4  e3a01000          MOV      r1,#0                 ;1847
001fa8  e59d00a8          LDR      r0,[sp,#0xa8]         ;1847
001fac  e5801000          STR      r1,[r0,#0]            ;1847
001fb0  ea000091          B        |L1.8700|
                  |L1.8116|
001fb4  e59d006c          LDR      r0,[sp,#0x6c]         ;1849
001fb8  e3500000          CMP      r0,#0                 ;1849
001fbc  1a000001          BNE      |L1.8136|
001fc0  e3a00001          MOV      r0,#1                 ;1850
001fc4  e58d006c          STR      r0,[sp,#0x6c]         ;1850
                  |L1.8136|
001fc8  e3a00e32          MOV      r0,#0x320             ;1876
001fcc  e58d0060          STR      r0,[sp,#0x60]         ;1876
001fd0  e59d104c          LDR      r1,[sp,#0x4c]         ;1879
001fd4  e1a00801          LSL      r0,r1,#16             ;1879
001fd8  e1a01007          MOV      r1,r7                 ;1879
001fdc  ebfffffe          BL       __aeabi_uidivmod
001fe0  e1a06000          MOV      r6,r0                 ;1879
001fe4  e59f147c          LDR      r1,|L1.9320|
001fe8  e1560001          CMP      r6,r1                 ;1880
001fec  9a000000          BLS      |L1.8180|
001ff0  e1a06001          MOV      r6,r1                 ;1883
                  |L1.8180|
001ff4  e3a00f96          MOV      r0,#0x258             ;1885
001ff8  e0060690          MUL      r6,r0,r6              ;1885
001ffc  e59d106c          LDR      r1,[sp,#0x6c]         ;1887
002000  e0811081          ADD      r1,r1,r1,LSL #1       ;1887
002004  e1a00101          LSL      r0,r1,#2              ;1887
002008  ebfffffe          BL       VL53L0X_isqrt
00200c  e1a00080          LSL      r0,r0,#1              ;1887
002010  e58d005c          STR      r0,[sp,#0x5c]         ;1887
002014  e59d00a0          LDR      r0,[sp,#0xa0]         ;1890
002018  e1d000b8          LDRH     r0,[r0,#8]            ;1890
00201c  e59f1448          LDR      r1,|L1.9324|
002020  e0000091          MUL      r0,r1,r0              ;1890
002024  e58d0058          STR      r0,[sp,#0x58]         ;1890
002028  e59d1044          LDR      r1,[sp,#0x44]         ;1900
00202c  e0611807          RSB      r1,r1,r7,LSL #16      ;1900
002030  e2810f7d          ADD      r0,r1,#0x1f4          ;1900
002034  e3a01ffa          MOV      r1,#0x3e8             ;1900
002038  ebfffffe          BL       __aeabi_uidivmod
00203c  e58d003c          STR      r0,[sp,#0x3c]         ;1900
002040  e59d1044          LDR      r1,[sp,#0x44]         ;1904
002044  e0811807          ADD      r1,r1,r7,LSL #16      ;1904
002048  e2810f7d          ADD      r0,r1,#0x1f4          ;1904
00204c  e3a01ffa          MOV      r1,#0x3e8             ;1904
002050  ebfffffe          BL       __aeabi_uidivmod
002054  e58d0038          STR      r0,[sp,#0x38]         ;1904
002058  e59d003c          LDR      r0,[sp,#0x3c]         ;1909
00205c  e1a00400          LSL      r0,r0,#8              ;1909
002060  e58d003c          STR      r0,[sp,#0x3c]         ;1909
002064  e59d003c          LDR      r0,[sp,#0x3c]         ;1912
002068  e59d1038          LDR      r1,[sp,#0x38]         ;1912
00206c  ebfffffe          BL       __aeabi_uidivmod
002070  e58d000c          STR      r0,[sp,#0xc]          ;1912
002074  e3500000          CMP      r0,#0                 ;1912
002078  ba000001          BLT      |L1.8324|
00207c  e59d000c          LDR      r0,[sp,#0xc]          ;1912
002080  ea000001          B        |L1.8332|
                  |L1.8324|
002084  e59d000c          LDR      r0,[sp,#0xc]          ;1912
002088  e2600000          RSB      r0,r0,#0              ;1912
                  |L1.8332|
00208c  e58d0050          STR      r0,[sp,#0x50]         ;1912
002090  e59d0050          LDR      r0,[sp,#0x50]         ;1915
002094  e1a00400          LSL      r0,r0,#8              ;1915
002098  e58d0050          STR      r0,[sp,#0x50]         ;1915
00209c  e59f13bc          LDR      r1,|L1.9312|
0020a0  e59d0058          LDR      r0,[sp,#0x58]         ;1918
0020a4  ebfffffe          BL       __aeabi_uidivmod
0020a8  e1a05000          MOV      r5,r0                 ;1918
0020ac  e59d0050          LDR      r0,[sp,#0x50]         ;1925
0020b0  e2600801          RSB      r0,r0,#0x10000        ;1925
0020b4  e0050590          MUL      r5,r0,r5              ;1925
0020b8  e2850902          ADD      r0,r5,#0x8000         ;1928
0020bc  e1a05820          LSR      r5,r0,#16             ;1928
0020c0  e2855801          ADD      r5,r5,#0x10000        ;1931
0020c4  e1a050a5          LSR      r5,r5,#1              ;1938
0020c8  e0000595          MUL      r0,r5,r5              ;1940
0020cc  e1a05000          MOV      r5,r0                 ;1940
0020d0  e1a05725          LSR      r5,r5,#14             ;1943
0020d4  e59d0060          LDR      r0,[sp,#0x60]         ;1946
0020d8  e0090095          MUL      r9,r5,r0              ;1946
0020dc  e2890902          ADD      r0,r9,#0x8000         ;1949
0020e0  e1a09820          LSR      r9,r0,#16             ;1949
0020e4  e0000999          MUL      r0,r9,r9              ;1952
0020e8  e1a09000          MOV      r9,r0                 ;1952
0020ec  e1a0a006          MOV      r10,r6                ;1954
0020f0  e28a0902          ADD      r0,r10,#0x8000        ;1957
0020f4  e1a0a820          LSR      r10,r0,#16            ;1957
0020f8  e0000a9a          MUL      r0,r10,r10            ;1960
0020fc  e1a0a000          MOV      r10,r0                ;1960
002100  e089000a          ADD      r0,r9,r10             ;1963
002104  e58d0034          STR      r0,[sp,#0x34]         ;1963
002108  e59d0034          LDR      r0,[sp,#0x34]         ;1966
00210c  ebfffffe          BL       VL53L0X_isqrt
002110  e58d0030          STR      r0,[sp,#0x30]         ;1966
002114  e59d0030          LDR      r0,[sp,#0x30]         ;1969
002118  e1a00800          LSL      r0,r0,#16             ;1969
00211c  e58d0030          STR      r0,[sp,#0x30]         ;1969
002120  e3a01064          MOV      r1,#0x64              ;1976
002124  e59d0030          LDR      r0,[sp,#0x30]         ;1976
002128  e2800032          ADD      r0,r0,#0x32           ;1976
00212c  ebfffffe          BL       __aeabi_uidivmod
002130  e58d000c          STR      r0,[sp,#0xc]          ;1976
002134  e59d105c          LDR      r1,[sp,#0x5c]         ;1976
002138  ebfffffe          BL       __aeabi_uidivmod
00213c  e1a08000          MOV      r8,r0                 ;1976
002140  e59f0328          LDR      r0,|L1.9328|
002144  e0080890          MUL      r8,r0,r8              ;1978
002148  e2888a01          ADD      r8,r8,#0x1000         ;1981
00214c  e2888fe2          ADD      r8,r8,#0x388          ;1981
002150  e59f131c          LDR      r1,|L1.9332|
002154  e1a00008          MOV      r0,r8                 ;1982
002158  ebfffffe          BL       __aeabi_uidivmod
00215c  e1a08000          MOV      r8,r0                 ;1982
002160  e3580a0f          CMP      r8,#0xf000            ;1984
002164  9a000000          BLS      |L1.8556|
002168  e3a08a0f          MOV      r8,#0xf000            ;1987
                  |L1.8556|
00216c  e0090898          MUL      r9,r8,r8              ;1991
002170  e59fa2e4          LDR      r10,|L1.9308|
002174  e089000a          ADD      r0,r9,r10             ;1996
002178  ebfffffe          BL       VL53L0X_isqrt
00217c  e58d002c          STR      r0,[sp,#0x2c]         ;1996
002180  e3a01ffa          MOV      r1,#0x3e8             ;2003
002184  e59d002c          LDR      r0,[sp,#0x2c]         ;2003
002188  e0000091          MUL      r0,r1,r0              ;2003
00218c  e58d0054          STR      r0,[sp,#0x54]         ;2003
002190  e3570000          CMP      r7,#0                 ;2005
002194  0a000006          BEQ      |L1.8628|
002198  e59d006c          LDR      r0,[sp,#0x6c]         ;2005
00219c  e3500000          CMP      r0,#0                 ;2005
0021a0  0a000003          BEQ      |L1.8628|
0021a4  e59d0054          LDR      r0,[sp,#0x54]         ;2006
0021a8  e59f12b4          LDR      r1,|L1.9316|
0021ac  e1500001          CMP      r0,r1                 ;2006
0021b0  9a000001          BLS      |L1.8636|
                  |L1.8628|
0021b4  e59f02a8          LDR      r0,|L1.9316|
0021b8  e58d0054          STR      r0,[sp,#0x54]         ;2007
                  |L1.8636|
0021bc  e59d0054          LDR      r0,[sp,#0x54]         ;2010
0021c0  e59d10a4          LDR      r1,[sp,#0xa4]         ;2010
0021c4  e5810000          STR      r0,[r1,#0]            ;2010
0021c8  e59d00a4          LDR      r0,[sp,#0xa4]         ;2011
0021cc  e5900000          LDR      r0,[r0,#0]            ;2011
0021d0  e5840140          STR      r0,[r4,#0x140]        ;2011
0021d4  e59d00a8          LDR      r0,[sp,#0xa8]         ;2012
0021d8  e59d1060          LDR      r1,[sp,#0x60]         ;2012
0021dc  e1a03005          MOV      r3,r5                 ;2012
0021e0  e58d000c          STR      r0,[sp,#0xc]          ;2012
0021e4  e88d0842          STM      sp,{r1,r6,r11}        ;2012
0021e8  e1a00004          MOV      r0,r4                 ;2012
0021ec  e59d1028          LDR      r1,[sp,#0x28]         ;2012
0021f0  e59d2024          LDR      r2,[sp,#0x24]         ;2012
0021f4  ebfffffe          BL       VL53L0X_calc_dmax
0021f8  e58d0040          STR      r0,[sp,#0x40]         ;2012
                  |L1.8700|
0021fc  e59d0040          LDR      r0,[sp,#0x40]         ;2024
002200  eaffff5e          B        |L1.8064|
;;;2026   
                          ENDP

                  VL53L0X_get_pal_range_status PROC
;;;2027   VL53L0X_Error VL53L0X_get_pal_range_status(VL53L0X_DEV Dev,
002204  e92d4fff          PUSH     {r0-r11,lr}
;;;2028   		uint8_t DeviceRangeStatus,
;;;2029   		FixPoint1616_t SignalRate,
;;;2030   		uint16_t EffectiveSpadRtnCount,
;;;2031   		VL53L0X_RangingMeasurementData_t *pRangingMeasurementData,
;;;2032   		uint8_t *pPalRangeStatus)
;;;2033   {
002208  e24dd03c          SUB      sp,sp,#0x3c
00220c  e1a07000          MOV      r7,r0
002210  e1a0a003          MOV      r10,r3
002214  e59d6074          LDR      r6,[sp,#0x74]
;;;2034   	VL53L0X_Error Status = VL53L0X_ERROR_NONE;
002218  e3a05000          MOV      r5,#0
;;;2035   	uint8_t NoneFlag;
;;;2036   	uint8_t SigmaLimitflag = 0;
00221c  e3a00000          MOV      r0,#0
002220  e58d0038          STR      r0,[sp,#0x38]
;;;2037   	uint8_t SignalRefClipflag = 0;
002224  e58d0034          STR      r0,[sp,#0x34]
;;;2038   	uint8_t RangeIgnoreThresholdflag = 0;
002228  e58d0030          STR      r0,[sp,#0x30]
;;;2039   	uint8_t SigmaLimitCheckEnable = 0;
00222c  e58d002c          STR      r0,[sp,#0x2c]
;;;2040   	uint8_t SignalRateFinalRangeLimitCheckEnable = 0;
002230  e58d0028          STR      r0,[sp,#0x28]
;;;2041   	uint8_t SignalRefClipLimitCheckEnable = 0;
002234  e58d0024          STR      r0,[sp,#0x24]
;;;2042   	uint8_t RangeIgnoreThresholdLimitCheckEnable = 0;
002238  e58d0020          STR      r0,[sp,#0x20]
;;;2043   	FixPoint1616_t SigmaEstimate;
;;;2044   	FixPoint1616_t SigmaLimitValue;
;;;2045   	FixPoint1616_t SignalRefClipValue;
;;;2046   	FixPoint1616_t RangeIgnoreThresholdValue;
;;;2047   	FixPoint1616_t SignalRatePerSpad;
;;;2048   	uint8_t DeviceRangeStatusInternal = 0;
00223c  e3a04000          MOV      r4,#0
;;;2049   	uint16_t tmpWord = 0;
002240  e58d000c          STR      r0,[sp,#0xc]
;;;2050   	uint8_t Temp8;
;;;2051   	uint32_t Dmax_mm = 0;
002244  e58d0008          STR      r0,[sp,#8]
;;;2052   	FixPoint1616_t LastSignalRefMcps;
;;;2053   
;;;2054   	LOG_FUNCTION_START("");
;;;2055   
;;;2056   
;;;2057   	/*
;;;2058   	 * VL53L0X has a good ranging when the value of the
;;;2059   	 * DeviceRangeStatus = 11. This function will replace the value 0 with
;;;2060   	 * the value 11 in the DeviceRangeStatus.
;;;2061   	 * In addition, the SigmaEstimator is not included in the VL53L0X
;;;2062   	 * DeviceRangeStatus, this will be added in the PalRangeStatus.
;;;2063   	 */
;;;2064   
;;;2065   	DeviceRangeStatusInternal = ((DeviceRangeStatus & 0x78) >> 3);
002248  e59d0040          LDR      r0,[sp,#0x40]
00224c  e2000078          AND      r0,r0,#0x78
002250  e1a041c0          ASR      r4,r0,#3
;;;2066   
;;;2067   	if (DeviceRangeStatusInternal == 0 ||
002254  e3540000          CMP      r4,#0
002258  0a00000b          BEQ      |L1.8844|
;;;2068   		DeviceRangeStatusInternal == 5 ||
00225c  e3540005          CMP      r4,#5
002260  0a000009          BEQ      |L1.8844|
;;;2069   		DeviceRangeStatusInternal == 7 ||
002264  e3540007          CMP      r4,#7
002268  0a000007          BEQ      |L1.8844|
;;;2070   		DeviceRangeStatusInternal == 12 ||
00226c  e354000c          CMP      r4,#0xc
002270  0a000005          BEQ      |L1.8844|
;;;2071   		DeviceRangeStatusInternal == 13 ||
002274  e354000d          CMP      r4,#0xd
002278  0a000003          BEQ      |L1.8844|
;;;2072   		DeviceRangeStatusInternal == 14 ||
00227c  e354000e          CMP      r4,#0xe
002280  0a000001          BEQ      |L1.8844|
;;;2073   		DeviceRangeStatusInternal == 15
002284  e354000f          CMP      r4,#0xf
002288  1a000001          BNE      |L1.8852|
                  |L1.8844|
;;;2074   			) {
;;;2075   		NoneFlag = 1;
00228c  e3a0b001          MOV      r11,#1
002290  ea000000          B        |L1.8856|
                  |L1.8852|
;;;2076   	} else {
;;;2077   		NoneFlag = 0;
002294  e3a0b000          MOV      r11,#0
                  |L1.8856|
;;;2078   	}
;;;2079   
;;;2080   	/* LastSignalRefMcps */
;;;2081   	if (Status == VL53L0X_ERROR_NONE)
002298  e3550000          CMP      r5,#0
00229c  1a000004          BNE      |L1.8884|
;;;2082   		Status = VL53L0X_WrByte(Dev, 0xFF, 0x01);
0022a0  e3a02001          MOV      r2,#1
0022a4  e3a010ff          MOV      r1,#0xff
0022a8  e1a00007          MOV      r0,r7
0022ac  ebfffffe          BL       VL53L0X_WrByte
0022b0  e1a05000          MOV      r5,r0
                  |L1.8884|
;;;2083   
;;;2084   	if (Status == VL53L0X_ERROR_NONE)
0022b4  e3550000          CMP      r5,#0
0022b8  1a000004          BNE      |L1.8912|
;;;2085   		Status = VL53L0X_RdWord(Dev,
0022bc  e28d200c          ADD      r2,sp,#0xc
0022c0  e3a010b6          MOV      r1,#0xb6
0022c4  e1a00007          MOV      r0,r7
0022c8  ebfffffe          BL       VL53L0X_RdWord
0022cc  e1a05000          MOV      r5,r0
                  |L1.8912|
;;;2086   			VL53L0X_REG_RESULT_PEAK_SIGNAL_RATE_REF,
;;;2087   			&tmpWord);
;;;2088   
;;;2089   	LastSignalRefMcps = VL53L0X_FIXPOINT97TOFIXPOINT1616(tmpWord);
0022d0  e1dd00bc          LDRH     r0,[sp,#0xc]
0022d4  e1a00480          LSL      r0,r0,#9
0022d8  e58d0004          STR      r0,[sp,#4]
;;;2090   
;;;2091   	if (Status == VL53L0X_ERROR_NONE)
0022dc  e3550000          CMP      r5,#0
0022e0  1a000004          BNE      |L1.8952|
;;;2092   		Status = VL53L0X_WrByte(Dev, 0xFF, 0x00);
0022e4  e3a02000          MOV      r2,#0
0022e8  e3a010ff          MOV      r1,#0xff
0022ec  e1a00007          MOV      r0,r7
0022f0  ebfffffe          BL       VL53L0X_WrByte
0022f4  e1a05000          MOV      r5,r0
                  |L1.8952|
;;;2093   
;;;2094   	PALDevDataSet(Dev, LastSignalRefMcps, LastSignalRefMcps);
0022f8  e59d0004          LDR      r0,[sp,#4]
0022fc  e5870148          STR      r0,[r7,#0x148]
;;;2095   
;;;2096   	/*
;;;2097   	 * Check if Sigma limit is enabled, if yes then do comparison with limit
;;;2098   	 * value and put the result back into pPalRangeStatus.
;;;2099   	 */
;;;2100   	if (Status == VL53L0X_ERROR_NONE)
002300  e3550000          CMP      r5,#0
002304  1a000004          BNE      |L1.8988|
;;;2101   		Status =  VL53L0X_GetLimitCheckEnable(Dev,
002308  e28d202c          ADD      r2,sp,#0x2c
00230c  e3a01000          MOV      r1,#0
002310  e1a00007          MOV      r0,r7
002314  ebfffffe          BL       VL53L0X_GetLimitCheckEnable
002318  e1a05000          MOV      r5,r0
                  |L1.8988|
;;;2102   			VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE,
;;;2103   			&SigmaLimitCheckEnable);
;;;2104   
;;;2105   	if ((SigmaLimitCheckEnable != 0) && (Status == VL53L0X_ERROR_NONE)) {
00231c  e5dd002c          LDRB     r0,[sp,#0x2c]
002320  e3500000          CMP      r0,#0
002324  0a00001e          BEQ      |L1.9124|
002328  e3550000          CMP      r5,#0
00232c  1a00001c          BNE      |L1.9124|
;;;2106   		/*
;;;2107   		* compute the Sigma and check with limit
;;;2108   		*/
;;;2109   		Status = VL53L0X_calc_sigma_estimate(
002330  e28d3008          ADD      r3,sp,#8
002334  e28d201c          ADD      r2,sp,#0x1c
002338  e1a00007          MOV      r0,r7
00233c  e59d1070          LDR      r1,[sp,#0x70]
002340  ebfffffe          BL       VL53L0X_calc_sigma_estimate
002344  e1a05000          MOV      r5,r0
;;;2110   			Dev,
;;;2111   			pRangingMeasurementData,
;;;2112   			&SigmaEstimate,
;;;2113   			&Dmax_mm);
;;;2114   		if (Status == VL53L0X_ERROR_NONE)
002348  e3550000          CMP      r5,#0
00234c  1a000004          BNE      |L1.9060|
;;;2115   			pRangingMeasurementData->RangeDMaxMilliMeter = Dmax_mm;
002350  e59d0008          LDR      r0,[sp,#8]
002354  e1a01800          LSL      r1,r0,#16
002358  e1a01821          LSR      r1,r1,#16
00235c  e59d0070          LDR      r0,[sp,#0x70]
002360  e1c010ba          STRH     r1,[r0,#0xa]
                  |L1.9060|
;;;2116   
;;;2117   		if (Status == VL53L0X_ERROR_NONE) {
002364  e3550000          CMP      r5,#0
002368  1a00000d          BNE      |L1.9124|
;;;2118   			Status = VL53L0X_GetLimitCheckValue(Dev,
00236c  e28d2018          ADD      r2,sp,#0x18
002370  e3a01000          MOV      r1,#0
002374  e1a00007          MOV      r0,r7
002378  ebfffffe          BL       VL53L0X_GetLimitCheckValue
00237c  e1a05000          MOV      r5,r0
;;;2119   				VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE,
;;;2120   				&SigmaLimitValue);
;;;2121   
;;;2122   			if ((SigmaLimitValue > 0) &&
002380  e59d0018          LDR      r0,[sp,#0x18]
002384  e3500000          CMP      r0,#0
002388  0a000005          BEQ      |L1.9124|
;;;2123   				(SigmaEstimate > SigmaLimitValue))
00238c  e59d001c          LDR      r0,[sp,#0x1c]
002390  e59d1018          LDR      r1,[sp,#0x18]
002394  e1500001          CMP      r0,r1
002398  9a000001          BLS      |L1.9124|
;;;2124   					/* Limit Fail */
;;;2125   					SigmaLimitflag = 1;
00239c  e3a00001          MOV      r0,#1
0023a0  e58d0038          STR      r0,[sp,#0x38]
                  |L1.9124|
;;;2126   		}
;;;2127   	}
;;;2128   
;;;2129   	/*
;;;2130   	 * Check if Signal ref clip limit is enabled, if yes then do comparison
;;;2131   	 * with limit value and put the result back into pPalRangeStatus.
;;;2132   	 */
;;;2133   	if (Status == VL53L0X_ERROR_NONE)
0023a4  e3550000          CMP      r5,#0
0023a8  1a000004          BNE      |L1.9152|
;;;2134   		Status =  VL53L0X_GetLimitCheckEnable(Dev,
0023ac  e28d2024          ADD      r2,sp,#0x24
0023b0  e3a01002          MOV      r1,#2
0023b4  e1a00007          MOV      r0,r7
0023b8  ebfffffe          BL       VL53L0X_GetLimitCheckEnable
0023bc  e1a05000          MOV      r5,r0
                  |L1.9152|
;;;2135   				VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP,
;;;2136   				&SignalRefClipLimitCheckEnable);
;;;2137   
;;;2138   	if ((SignalRefClipLimitCheckEnable != 0) &&
0023c0  e5dd0024          LDRB     r0,[sp,#0x24]
0023c4  e3500000          CMP      r0,#0
0023c8  0a00000f          BEQ      |L1.9228|
;;;2139   			(Status == VL53L0X_ERROR_NONE)) {
0023cc  e3550000          CMP      r5,#0
0023d0  1a00000d          BNE      |L1.9228|
;;;2140   
;;;2141   		Status = VL53L0X_GetLimitCheckValue(Dev,
0023d4  e28d2014          ADD      r2,sp,#0x14
0023d8  e3a01002          MOV      r1,#2
0023dc  e1a00007          MOV      r0,r7
0023e0  ebfffffe          BL       VL53L0X_GetLimitCheckValue
0023e4  e1a05000          MOV      r5,r0
;;;2142   				VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP,
;;;2143   				&SignalRefClipValue);
;;;2144   
;;;2145   		if ((SignalRefClipValue > 0) &&
0023e8  e59d0014          LDR      r0,[sp,#0x14]
0023ec  e3500000          CMP      r0,#0
0023f0  0a000005          BEQ      |L1.9228|
;;;2146   				(LastSignalRefMcps > SignalRefClipValue)) {
0023f4  e59d0004          LDR      r0,[sp,#4]
0023f8  e59d1014          LDR      r1,[sp,#0x14]
0023fc  e1500001          CMP      r0,r1
002400  9a000001          BLS      |L1.9228|
;;;2147   			/* Limit Fail */
;;;2148   			SignalRefClipflag = 1;
002404  e3a00001          MOV      r0,#1
002408  e58d0034          STR      r0,[sp,#0x34]
                  |L1.9228|
;;;2149   		}
;;;2150   	}
;;;2151   
;;;2152   	/*
;;;2153   	 * Check if Signal ref clip limit is enabled, if yes then do comparison
;;;2154   	 * with limit value and put the result back into pPalRangeStatus.
;;;2155   	 * EffectiveSpadRtnCount has a format 8.8
;;;2156   	 * If (Return signal rate < (1.5 x Xtalk x number of Spads)) : FAIL
;;;2157   	 */
;;;2158   	if (Status == VL53L0X_ERROR_NONE)
00240c  e3550000          CMP      r5,#0
002410  1a000004          BNE      |L1.9256|
;;;2159   		Status =  VL53L0X_GetLimitCheckEnable(Dev,
002414  e28d2020          ADD      r2,sp,#0x20
002418  e3a01003          MOV      r1,#3
00241c  e1a00007          MOV      r0,r7
002420  ebfffffe          BL       VL53L0X_GetLimitCheckEnable
002424  e1a05000          MOV      r5,r0
                  |L1.9256|
;;;2160   				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;2161   				&RangeIgnoreThresholdLimitCheckEnable);
;;;2162   
;;;2163   	if ((RangeIgnoreThresholdLimitCheckEnable != 0) &&
002428  e5dd0020          LDRB     r0,[sp,#0x20]
00242c  e3500000          CMP      r0,#0
002430  0a000022          BEQ      |L1.9408|
;;;2164   			(Status == VL53L0X_ERROR_NONE)) {
002434  e3550000          CMP      r5,#0
002438  1a000020          BNE      |L1.9408|
;;;2165   
;;;2166   		/* Compute the signal rate per spad */
;;;2167   		if (EffectiveSpadRtnCount == 0) {
00243c  e35a0000          CMP      r10,#0
002440  1a00000c          BNE      |L1.9336|
;;;2168   			SignalRatePerSpad = 0;
002444  e3a09000          MOV      r9,#0
002448  ea00000f          B        |L1.9356|
                  |L1.9292|
                          DCD      0x00004e20
                  |L1.9296|
                          DCD      0x00000136
                  |L1.9300|
                          DCD      0xfff00000
                  |L1.9304|
                          DCD      0x00000127
                  |L1.9308|
                          DCD      0x00001104
                  |L1.9312|
                          DCD      0x0000125c
                  |L1.9316|
                          DCD      0x028f87ae
                  |L1.9320|
                          DCD      0x00666666
                  |L1.9324|
                          DCD      0x0006999a
                  |L1.9328|
                          DCD      0x00000bb5
                  |L1.9332|
                          DCD      0x00002710
                  |L1.9336|
;;;2169   		} else {
;;;2170   			SignalRatePerSpad = (FixPoint1616_t)((256 * SignalRate)
002478  e59d1044          LDR      r1,[sp,#0x44]
00247c  e1a00401          LSL      r0,r1,#8
002480  e1a0100a          MOV      r1,r10
002484  ebfffffe          BL       __aeabi_uidivmod
002488  e1a09000          MOV      r9,r0
                  |L1.9356|
;;;2171   				/ EffectiveSpadRtnCount);
;;;2172   		}
;;;2173   
;;;2174   		Status = VL53L0X_GetLimitCheckValue(Dev,
00248c  e28d2010          ADD      r2,sp,#0x10
002490  e3a01003          MOV      r1,#3
002494  e1a00007          MOV      r0,r7
002498  ebfffffe          BL       VL53L0X_GetLimitCheckValue
00249c  e1a05000          MOV      r5,r0
;;;2175   				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;2176   				&RangeIgnoreThresholdValue);
;;;2177   
;;;2178   		if ((RangeIgnoreThresholdValue > 0) &&
0024a0  e59d0010          LDR      r0,[sp,#0x10]
0024a4  e3500000          CMP      r0,#0
0024a8  0a000004          BEQ      |L1.9408|
;;;2179   			(SignalRatePerSpad < RangeIgnoreThresholdValue)) {
0024ac  e59d0010          LDR      r0,[sp,#0x10]
0024b0  e1590000          CMP      r9,r0
0024b4  2a000001          BCS      |L1.9408|
;;;2180   			/* Limit Fail add 2^6 to range status */
;;;2181   			RangeIgnoreThresholdflag = 1;
0024b8  e3a00001          MOV      r0,#1
0024bc  e58d0030          STR      r0,[sp,#0x30]
                  |L1.9408|
;;;2182   		}
;;;2183   	}
;;;2184   
;;;2185   	if (Status == VL53L0X_ERROR_NONE) {
0024c0  e3550000          CMP      r5,#0
0024c4  1a00002e          BNE      |L1.9604|
;;;2186   		if (NoneFlag == 1) {
0024c8  e35b0001          CMP      r11,#1
0024cc  1a000002          BNE      |L1.9436|
;;;2187   			*pPalRangeStatus = 255;	 /* NONE */
0024d0  e3a000ff          MOV      r0,#0xff
0024d4  e5c60000          STRB     r0,[r6,#0]
0024d8  ea000029          B        |L1.9604|
                  |L1.9436|
;;;2188   		} else if (DeviceRangeStatusInternal == 1 ||
0024dc  e3540001          CMP      r4,#1
0024e0  0a000003          BEQ      |L1.9460|
;;;2189   					DeviceRangeStatusInternal == 2 ||
0024e4  e3540002          CMP      r4,#2
0024e8  0a000001          BEQ      |L1.9460|
;;;2190   					DeviceRangeStatusInternal == 3) {
0024ec  e3540003          CMP      r4,#3
0024f0  1a000002          BNE      |L1.9472|
                  |L1.9460|
;;;2191   			*pPalRangeStatus = 5; /* HW fail */
0024f4  e3a00005          MOV      r0,#5
0024f8  e5c60000          STRB     r0,[r6,#0]
0024fc  ea000020          B        |L1.9604|
                  |L1.9472|
;;;2192   		} else if (DeviceRangeStatusInternal == 6 ||
002500  e3540006          CMP      r4,#6
002504  0a000001          BEQ      |L1.9488|
;;;2193   					DeviceRangeStatusInternal == 9) {
002508  e3540009          CMP      r4,#9
00250c  1a000002          BNE      |L1.9500|
                  |L1.9488|
;;;2194   			*pPalRangeStatus = 4;  /* Phase fail */
002510  e3a00004          MOV      r0,#4
002514  e5c60000          STRB     r0,[r6,#0]
002518  ea000019          B        |L1.9604|
                  |L1.9500|
;;;2195   		} else if (DeviceRangeStatusInternal == 8 ||
00251c  e3540008          CMP      r4,#8
002520  0a000004          BEQ      |L1.9528|
;;;2196   					DeviceRangeStatusInternal == 10 ||
002524  e354000a          CMP      r4,#0xa
002528  0a000002          BEQ      |L1.9528|
;;;2197   					SignalRefClipflag == 1) {
00252c  e59d0034          LDR      r0,[sp,#0x34]
002530  e3500001          CMP      r0,#1
002534  1a000002          BNE      |L1.9540|
                  |L1.9528|
;;;2198   			*pPalRangeStatus = 3;  /* Min range */
002538  e3a00003          MOV      r0,#3
00253c  e5c60000          STRB     r0,[r6,#0]
002540  ea00000f          B        |L1.9604|
                  |L1.9540|
;;;2199   		} else if (DeviceRangeStatusInternal == 4 ||
002544  e3540004          CMP      r4,#4
002548  0a000002          BEQ      |L1.9560|
;;;2200   					RangeIgnoreThresholdflag == 1) {
00254c  e59d0030          LDR      r0,[sp,#0x30]
002550  e3500001          CMP      r0,#1
002554  1a000002          BNE      |L1.9572|
                  |L1.9560|
;;;2201   			*pPalRangeStatus = 2;  /* Signal Fail */
002558  e3a00002          MOV      r0,#2
00255c  e5c60000          STRB     r0,[r6,#0]
002560  ea000007          B        |L1.9604|
                  |L1.9572|
;;;2202   		} else if (SigmaLimitflag == 1) {
002564  e59d0038          LDR      r0,[sp,#0x38]
002568  e3500001          CMP      r0,#1
00256c  1a000002          BNE      |L1.9596|
;;;2203   			*pPalRangeStatus = 1;  /* Sigma	 Fail */
002570  e3a00001          MOV      r0,#1
002574  e5c60000          STRB     r0,[r6,#0]
002578  ea000001          B        |L1.9604|
                  |L1.9596|
;;;2204   		} else {
;;;2205   			*pPalRangeStatus = 0; /* Range Valid */
00257c  e3a00000          MOV      r0,#0
002580  e5c60000          STRB     r0,[r6,#0]
                  |L1.9604|
;;;2206   		}
;;;2207   	}
;;;2208   
;;;2209   	/* DMAX only relevant during range error */
;;;2210   	if (*pPalRangeStatus == 0)
002584  e5d60000          LDRB     r0,[r6,#0]
002588  e3500000          CMP      r0,#0
00258c  1a000002          BNE      |L1.9628|
;;;2211   		pRangingMeasurementData->RangeDMaxMilliMeter = 0;
002590  e3a01000          MOV      r1,#0
002594  e59d0070          LDR      r0,[sp,#0x70]
002598  e1c010ba          STRH     r1,[r0,#0xa]
                  |L1.9628|
;;;2212   
;;;2213   	/* fill the Limit Check Status */
;;;2214   
;;;2215   	Status =  VL53L0X_GetLimitCheckEnable(Dev,
00259c  e28d2028          ADD      r2,sp,#0x28
0025a0  e3a01001          MOV      r1,#1
0025a4  e1a00007          MOV      r0,r7
0025a8  ebfffffe          BL       VL53L0X_GetLimitCheckEnable
0025ac  e1a05000          MOV      r5,r0
;;;2216   			VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
;;;2217   			&SignalRateFinalRangeLimitCheckEnable);
;;;2218   
;;;2219   	if (Status == VL53L0X_ERROR_NONE) {
0025b0  e3550000          CMP      r5,#0
0025b4  1a000026          BNE      |L1.9812|
;;;2220   		if ((SigmaLimitCheckEnable == 0) || (SigmaLimitflag == 1))
0025b8  e5dd002c          LDRB     r0,[sp,#0x2c]
0025bc  e3500000          CMP      r0,#0
0025c0  0a000002          BEQ      |L1.9680|
0025c4  e59d0038          LDR      r0,[sp,#0x38]
0025c8  e3500001          CMP      r0,#1
0025cc  1a000001          BNE      |L1.9688|
                  |L1.9680|
;;;2221   			Temp8 = 1;
0025d0  e3a08001          MOV      r8,#1
0025d4  ea000000          B        |L1.9692|
                  |L1.9688|
;;;2222   		else
;;;2223   			Temp8 = 0;
0025d8  e3a08000          MOV      r8,#0
                  |L1.9692|
;;;2224   		VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
0025dc  e5c7802e          STRB     r8,[r7,#0x2e]
;;;2225   				VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, Temp8);
;;;2226   
;;;2227   		if ((DeviceRangeStatusInternal == 4) ||
0025e0  e3540004          CMP      r4,#4
0025e4  0a000002          BEQ      |L1.9716|
;;;2228   				(SignalRateFinalRangeLimitCheckEnable == 0))
0025e8  e5dd0028          LDRB     r0,[sp,#0x28]
0025ec  e3500000          CMP      r0,#0
0025f0  1a000001          BNE      |L1.9724|
                  |L1.9716|
;;;2229   			Temp8 = 1;
0025f4  e3a08001          MOV      r8,#1
0025f8  ea000000          B        |L1.9728|
                  |L1.9724|
;;;2230   		else
;;;2231   			Temp8 = 0;
0025fc  e3a08000          MOV      r8,#0
                  |L1.9728|
;;;2232   		VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
002600  e5c7802f          STRB     r8,[r7,#0x2f]
;;;2233   				VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE,
;;;2234   				Temp8);
;;;2235   
;;;2236   		if ((SignalRefClipLimitCheckEnable == 0) ||
002604  e5dd0024          LDRB     r0,[sp,#0x24]
002608  e3500000          CMP      r0,#0
00260c  0a000002          BEQ      |L1.9756|
;;;2237   					(SignalRefClipflag == 1))
002610  e59d0034          LDR      r0,[sp,#0x34]
002614  e3500001          CMP      r0,#1
002618  1a000001          BNE      |L1.9764|
                  |L1.9756|
;;;2238   			Temp8 = 1;
00261c  e3a08001          MOV      r8,#1
002620  ea000000          B        |L1.9768|
                  |L1.9764|
;;;2239   		else
;;;2240   			Temp8 = 0;
002624  e3a08000          MOV      r8,#0
                  |L1.9768|
;;;2241   
;;;2242   		VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
002628  e5c78030          STRB     r8,[r7,#0x30]
;;;2243   				VL53L0X_CHECKENABLE_SIGNAL_REF_CLIP, Temp8);
;;;2244   
;;;2245   		if ((RangeIgnoreThresholdLimitCheckEnable == 0) ||
00262c  e5dd0020          LDRB     r0,[sp,#0x20]
002630  e3500000          CMP      r0,#0
002634  0a000002          BEQ      |L1.9796|
;;;2246   				(RangeIgnoreThresholdflag == 1))
002638  e59d0030          LDR      r0,[sp,#0x30]
00263c  e3500001          CMP      r0,#1
002640  1a000001          BNE      |L1.9804|
                  |L1.9796|
;;;2247   			Temp8 = 1;
002644  e3a08001          MOV      r8,#1
002648  ea000000          B        |L1.9808|
                  |L1.9804|
;;;2248   		else
;;;2249   			Temp8 = 0;
00264c  e3a08000          MOV      r8,#0
                  |L1.9808|
;;;2250   
;;;2251   		VL53L0X_SETARRAYPARAMETERFIELD(Dev, LimitChecksStatus,
002650  e5c78031          STRB     r8,[r7,#0x31]
                  |L1.9812|
;;;2252   				VL53L0X_CHECKENABLE_RANGE_IGNORE_THRESHOLD,
;;;2253   				Temp8);
;;;2254   	}
;;;2255   
;;;2256   	LOG_FUNCTION_END(Status);
;;;2257   	return Status;
002654  e1a00005          MOV      r0,r5
002658  e28dd04c          ADD      sp,sp,#0x4c
;;;2258   
;;;2259   }
00265c  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP

