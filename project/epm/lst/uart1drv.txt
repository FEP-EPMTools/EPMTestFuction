; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart1drv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart1drv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uart1drv.crf src\userdrv\uart1drv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART1SetRS232Power PROC
;;;157    
;;;158    BOOL UART1SetRS232Power(BOOL flag)
000000  e92d4010          PUSH     {r4,lr}
;;;159    {
000004  e1a04000          MOV      r4,r0
;;;160        if(flag)
000008  e3540000          CMP      r4,#0
00000c  0a000003          BEQ      |L1.32|
;;;161        {         
;;;162            GPIO_SetBit(RS232_POWER_PORT, RS232_POWER_PIN);    
000010  e3a01080          MOV      r1,#0x80
000014  e3a00c01          MOV      r0,#0x100
000018  ebfffffe          BL       GPIO_SetBit
00001c  ea000002          B        |L1.44|
                  |L1.32|
;;;163        }
;;;164        else
;;;165        {
;;;166            GPIO_ClrBit(RS232_POWER_PORT, RS232_POWER_PIN);         
000020  e3a01080          MOV      r1,#0x80
000024  e3a00c01          MOV      r0,#0x100
000028  ebfffffe          BL       GPIO_ClrBit
                  |L1.44|
;;;167        }
;;;168        return TRUE;
00002c  e3a00001          MOV      r0,#1
;;;169    }
000030  e8bd8010          POP      {r4,pc}
;;;170    
                          ENDP

                  UART1SetPower PROC
;;;152    
;;;153    BOOL UART1SetPower(BOOL flag)
000034  e1a01000          MOV      r1,r0
;;;154    {
;;;155        return FALSE;
000038  e3a00000          MOV      r0,#0
;;;156    }
00003c  e12fff1e          BX       lr
;;;157    
                          ENDP

                  hwInit PROC
;;;44     /*-----------------------------------------*/
;;;45     static BOOL hwInit(UINT32 baudRate)
000040  e92d4070          PUSH     {r4-r6,lr}
;;;46     {
000044  e1a05000          MOV      r5,r0
;;;47         int retval;
;;;48         outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000048  e3a0020b          MOV      r0,#0xb0000000
00004c  e5900218          LDR      r0,[r0,#0x218]
000050  e3800008          ORR      r0,r0,#8
000054  e3a0120b          MOV      r1,#0xb0000000
000058  e5810218          STR      r0,[r1,#0x218]
;;;49         
;;;50         // GPE 2, 3, 4, 5 //TX, RX, RTS, CTS
;;;51         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<8)) | (0x9<<8));
00005c  e3a0020b          MOV      r0,#0xb0000000
000060  e5900090          LDR      r0,[r0,#0x90]
000064  e3c00c0f          BIC      r0,r0,#0xf00
000068  e3800c09          ORR      r0,r0,#0x900
00006c  e5810090          STR      r0,[r1,#0x90]
;;;52         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<12)) | (0x9<<12));
000070  e3a0020b          MOV      r0,#0xb0000000
000074  e5900090          LDR      r0,[r0,#0x90]
000078  e3c00a0f          BIC      r0,r0,#0xf000
00007c  e3800a09          ORR      r0,r0,#0x9000
000080  e5810090          STR      r0,[r1,#0x90]
;;;53         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<16)) | (0x9<<16));
000084  e3a0020b          MOV      r0,#0xb0000000
000088  e5900090          LDR      r0,[r0,#0x90]
00008c  e3c0080f          BIC      r0,r0,#0xf0000
000090  e3800809          ORR      r0,r0,#0x90000
000094  e5810090          STR      r0,[r1,#0x90]
;;;54         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<20)) | (0x9<<20));     
000098  e3a0020b          MOV      r0,#0xb0000000
00009c  e5900090          LDR      r0,[r0,#0x90]
0000a0  e3c0060f          BIC      r0,r0,#0xf00000
0000a4  e3800609          ORR      r0,r0,#0x900000
0000a8  e5810090          STR      r0,[r1,#0x90]
;;;55         
;;;56         //Power pin GPE6
;;;57         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<24)) | (0x0<<24));
0000ac  e3a0020b          MOV      r0,#0xb0000000
0000b0  e5900090          LDR      r0,[r0,#0x90]
0000b4  e3c0040f          BIC      r0,r0,#0xf000000
0000b8  e5810090          STR      r0,[r1,#0x90]
;;;58         GPIO_OpenBit(POWER_PORT, POWER_PIN, DIR_OUTPUT, NO_PULL_UP); 
0000bc  e3a03000          MOV      r3,#0
0000c0  e3a02001          MOV      r2,#1
0000c4  e3a01040          MOV      r1,#0x40
0000c8  e3a00c01          MOV      r0,#0x100
0000cc  ebfffffe          BL       GPIO_OpenBit
;;;59         UART1SetPower(FALSE);
0000d0  e3a00000          MOV      r0,#0
0000d4  ebfffffe          BL       UART1SetPower
;;;60         
;;;61         //RS232 Power pin GPE7
;;;62         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xFu<<28)) | (0x0u<<28));
0000d8  e3a0020b          MOV      r0,#0xb0000000
0000dc  e5900090          LDR      r0,[r0,#0x90]
0000e0  e3c0020f          BIC      r0,r0,#0xf0000000
0000e4  e3a0120b          MOV      r1,#0xb0000000
0000e8  e5810090          STR      r0,[r1,#0x90]
;;;63         GPIO_OpenBit(RS232_POWER_PORT, RS232_POWER_PIN, DIR_OUTPUT, NO_PULL_UP); 
0000ec  e3a03000          MOV      r3,#0
0000f0  e3a02001          MOV      r2,#1
0000f4  e3a01080          MOV      r1,#0x80
0000f8  e3a00c01          MOV      r0,#0x100
0000fc  ebfffffe          BL       GPIO_OpenBit
;;;64         UART1SetRS232Power(FALSE);
000100  e3a00000          MOV      r0,#0
000104  ebfffffe          BL       UART1SetRS232Power
;;;65         
;;;66         /* configure UART */
;;;67         param.uFreq = 12000000;
000108  e59f022c          LDR      r0,|L1.828|
00010c  e59f122c          LDR      r1,|L1.832|
000110  e5810000          STR      r0,[r1,#0]  ; param
;;;68         param.uBaudRate = baudRate;
000114  e2810000          ADD      r0,r1,#0
000118  e5805004          STR      r5,[r0,#4]  ; param
;;;69         param.ucUartNo = UART1;
00011c  e3a00001          MOV      r0,#1
000120  e5c10008          STRB     r0,[r1,#8]  ; param
;;;70         param.ucDataBits = DATA_BITS_8;
000124  e3a00003          MOV      r0,#3
000128  e5c10009          STRB     r0,[r1,#9]  ; param
;;;71         param.ucStopBits = STOP_BITS_1;
00012c  e3a00000          MOV      r0,#0
000130  e5c1000a          STRB     r0,[r1,#0xa]  ; param
;;;72         param.ucParity = PARITY_NONE;
000134  e5c1000b          STRB     r0,[r1,#0xb]  ; param
;;;73         param.ucRxTriggerLevel = UART_FCR_RFITL_1BYTE;
000138  e5c1000c          STRB     r0,[r1,#0xc]  ; param
;;;74         retval = uartOpen(&param);
00013c  e2810000          ADD      r0,r1,#0
000140  ebfffffe          BL       uartOpen
000144  e1a04000          MOV      r4,r0
;;;75         if(retval != 0) 
000148  e3540000          CMP      r4,#0
00014c  0a000003          BEQ      |L1.352|
;;;76         {
;;;77             sysprintf("hwInit Open UART error!\n");
000150  e28f0f7b          ADR      r0,|L1.836|
000154  ebfffffe          BL       sysprintf
;;;78             return FALSE;
000158  e3a00000          MOV      r0,#0
                  |L1.348|
;;;79         }
;;;80     
;;;81         /* set TX interrupt mode */
;;;82         retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTPOLLMODE /*UARTINTMODE*/ , 0);
;;;83         //retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTINTMODE , 0);
;;;84         if (retval != 0) 
;;;85         {
;;;86             sysprintf("hwInit Set TX interrupt mode fail!\n");
;;;87             return FALSE;
;;;88         }
;;;89     
;;;90         /* set RX interrupt mode */
;;;91         retval = uartIoctl(param.ucUartNo, UART_IOC_SETRXMODE, UARTINTMODE, 0);
;;;92         if (retval != 0) 
;;;93         {
;;;94             sysprintf("hwInit Set RX interrupt mode fail!\n");
;;;95             return FALSE;
;;;96         }
;;;97     
;;;98         return TRUE;
;;;99     }
00015c  e8bd8070          POP      {r4-r6,pc}
                  |L1.352|
000160  e59f11d8          LDR      r1,|L1.832|
000164  e5d10008          LDRB     r0,[r1,#8]            ;82  ; param
000168  e3a03000          MOV      r3,#0                 ;82
00016c  e1a02003          MOV      r2,r3                 ;82
000170  e3a01001          MOV      r1,#1                 ;82
000174  ebfffffe          BL       uartIoctl
000178  e1a04000          MOV      r4,r0                 ;82
00017c  e3540000          CMP      r4,#0                 ;84
000180  0a000003          BEQ      |L1.404|
000184  e28f0f75          ADR      r0,|L1.864|
000188  ebfffffe          BL       sysprintf
00018c  e3a00000          MOV      r0,#0                 ;87
000190  eafffff1          B        |L1.348|
                  |L1.404|
000194  e59f11a4          LDR      r1,|L1.832|
000198  e5d10008          LDRB     r0,[r1,#8]            ;91  ; param
00019c  e3a03000          MOV      r3,#0                 ;91
0001a0  e3a02001          MOV      r2,#1                 ;91
0001a4  e3a01002          MOV      r1,#2                 ;91
0001a8  ebfffffe          BL       uartIoctl
0001ac  e1a04000          MOV      r4,r0                 ;91
0001b0  e3540000          CMP      r4,#0                 ;92
0001b4  0a000003          BEQ      |L1.456|
0001b8  e28f0f71          ADR      r0,|L1.900|
0001bc  ebfffffe          BL       sysprintf
0001c0  e3a00000          MOV      r0,#0                 ;95
0001c4  eaffffe4          B        |L1.348|
                  |L1.456|
0001c8  e3a00001          MOV      r0,#1                 ;98
0001cc  eaffffe2          B        |L1.348|
;;;100    
                          ENDP

                  UART1DrvInit PROC
;;;103    /*-----------------------------------------*/
;;;104    BOOL UART1DrvInit(UINT32 baudRate)
0001d0  e92d4070          PUSH     {r4-r6,lr}
;;;105    {
0001d4  e1a05000          MOV      r5,r0
;;;106        int retval;
;;;107        sysprintf("UART1DrvInit!!\n");
0001d8  e28f0f72          ADR      r0,|L1.936|
0001dc  ebfffffe          BL       sysprintf
;;;108        retval = hwInit(baudRate);
0001e0  e1a00005          MOV      r0,r5
0001e4  ebfffffe          BL       hwInit
0001e8  e1a04000          MOV      r4,r0
;;;109        return retval;
0001ec  e1a00004          MOV      r0,r4
;;;110    }
0001f0  e8bd8070          POP      {r4-r6,pc}
;;;111    INT32 UART1Write(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART1Write PROC
0001f4  e92d41f0          PUSH     {r4-r8,lr}
;;;112    {
0001f8  e1a04000          MOV      r4,r0
0001fc  e1a05001          MOV      r5,r1
;;;113        INT32  reVal;
;;;114        
;;;115        /* DEBUG LED *///terninalPrintf("DebugSend>=");
;;;116        /* DEBUG LED *///for(int i=0;i<uLen;i++)
;;;117        /* DEBUG LED */// terninalPrintf("%02x ",pucBuf[i]);
;;;118        /* DEBUG LED *///terninalPrintf("\n  ");
;;;119                       /*
;;;120                       for(int k=0;k<uLen;k++)
;;;121                       {
;;;122                            if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;123                                terninalPrintf("%c",pucBuf[k]);
;;;124                       } 
;;;125                       terninalPrintf("\n"); 
;;;126                       */    
;;;127        
;;;128        /* DEBUG LED */terninalPrintf("\r");
000200  e28f0e1b          ADR      r0,|L1.952|
000204  ebfffffe          BL       terninalPrintf
;;;129        /* DEBUG LED */for(int i=0;i<uLen;i++)
000208  e3a06000          MOV      r6,#0
00020c  ea000002          B        |L1.540|
                  |L1.528|
;;;130        /* DEBUG LED */ terninalPrintf("\r");
000210  e28f0e1a          ADR      r0,|L1.952|
000214  ebfffffe          BL       terninalPrintf
000218  e2866001          ADD      r6,r6,#1              ;129
                  |L1.540|
00021c  e1560005          CMP      r6,r5                 ;129
000220  3afffffa          BCC      |L1.528|
;;;131        /* DEBUG LED */terninalPrintf("\r");
000224  e28f0f63          ADR      r0,|L1.952|
000228  ebfffffe          BL       terninalPrintf
;;;132                      
;;;133                       for(int k=0;k<uLen;k++)
00022c  e3a06000          MOV      r6,#0
000230  ea000008          B        |L1.600|
                  |L1.564|
;;;134                       {
;;;135                            if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
000234  e7d40006          LDRB     r0,[r4,r6]
000238  e3500020          CMP      r0,#0x20
00023c  ba000004          BLT      |L1.596|
000240  e7d40006          LDRB     r0,[r4,r6]
000244  e350007e          CMP      r0,#0x7e
000248  ca000001          BGT      |L1.596|
;;;136                                terninalPrintf("\r");
00024c  e28f0f59          ADR      r0,|L1.952|
000250  ebfffffe          BL       terninalPrintf
                  |L1.596|
000254  e2866001          ADD      r6,r6,#1              ;133
                  |L1.600|
000258  e1560005          CMP      r6,r5                 ;133
00025c  3afffff4          BCC      |L1.564|
;;;137                       } 
;;;138                       terninalPrintf("\r"); 
000260  e28f0e15          ADR      r0,|L1.952|
000264  ebfffffe          BL       terninalPrintf
;;;139        
;;;140        
;;;141        reVal = uartWrite(param.ucUartNo, pucBuf, uLen);
000268  e59f10d0          LDR      r1,|L1.832|
00026c  e5d10008          LDRB     r0,[r1,#8]  ; param
000270  e1a02005          MOV      r2,r5
000274  e1a01004          MOV      r1,r4
000278  ebfffffe          BL       uartWrite
00027c  e1a07000          MOV      r7,r0
;;;142        return reVal;
000280  e1a00007          MOV      r0,r7
;;;143    }
000284  e8bd81f0          POP      {r4-r8,pc}
;;;144    INT32 UART1Read(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART1Read PROC
000288  e92d4070          PUSH     {r4-r6,lr}
;;;145    {
00028c  e1a04000          MOV      r4,r0
000290  e1a05001          MOV      r5,r1
;;;146        return uartRead(param.ucUartNo, pucBuf, uLen);
000294  e59f10a4          LDR      r1,|L1.832|
000298  e5d10008          LDRB     r0,[r1,#8]  ; param
00029c  e1a02005          MOV      r2,r5
0002a0  e1a01004          MOV      r1,r4
0002a4  ebfffffe          BL       uartRead
;;;147    }
0002a8  e8bd8070          POP      {r4-r6,pc}
;;;148    BaseType_t UART1ReadWait(TickType_t time)
                          ENDP

                  UART1ReadWait PROC
0002ac  e92d4010          PUSH     {r4,lr}
;;;149    {
0002b0  e1a04000          MOV      r4,r0
;;;150        return  uartWaitReadEvent(param.ucUartNo, time);
0002b4  e59f1084          LDR      r1,|L1.832|
0002b8  e5d10008          LDRB     r0,[r1,#8]  ; param
0002bc  e1a01004          MOV      r1,r4
0002c0  ebfffffe          BL       uartWaitReadEvent
;;;151    }
0002c4  e8bd8010          POP      {r4,pc}
;;;152    
                          ENDP

                  UART1Ioctl PROC
;;;170    
;;;171    INT UART1Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
0002c8  e92d4070          PUSH     {r4-r6,lr}
;;;172    {
0002cc  e1a04000          MOV      r4,r0
0002d0  e1a05001          MOV      r5,r1
0002d4  e1a06002          MOV      r6,r2
;;;173        return uartIoctl(param.ucUartNo, uCmd, uArg0, uArg1);
0002d8  e59f1060          LDR      r1,|L1.832|
0002dc  e5d10008          LDRB     r0,[r1,#8]  ; param
0002e0  e1a03006          MOV      r3,r6
0002e4  e1a02005          MOV      r2,r5
0002e8  e1a01004          MOV      r1,r4
0002ec  ebfffffe          BL       uartIoctl
;;;174    }
0002f0  e8bd8070          POP      {r4-r6,pc}
;;;175    
                          ENDP

                  UART1SetRTS PROC
;;;176    void UART1SetRTS(BOOL flag)
0002f4  e92d4010          PUSH     {r4,lr}
;;;177    {
0002f8  e1a04000          MOV      r4,r0
;;;178        if(flag)
0002fc  e3540000          CMP      r4,#0
000300  0a000006          BEQ      |L1.800|
;;;179            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
000304  e59f1034          LDR      r1,|L1.832|
000308  e5d10008          LDRB     r0,[r1,#8]  ; param
00030c  e3a03000          MOV      r3,#0
000310  e1a02003          MOV      r2,r3
000314  e3a01010          MOV      r1,#0x10
000318  ebfffffe          BL       uartIoctl
00031c  ea000005          B        |L1.824|
                  |L1.800|
;;;180        else
;;;181            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
000320  e59f1018          LDR      r1,|L1.832|
000324  e5d10008          LDRB     r0,[r1,#8]  ; param
000328  e3a03000          MOV      r3,#0
00032c  e3a02001          MOV      r2,#1
000330  e3a01010          MOV      r1,#0x10
000334  ebfffffe          BL       uartIoctl
                  |L1.824|
;;;182    }
000338  e8bd8010          POP      {r4,pc}
                  |L1.828|
                          DCD      0x00b71b00
                  |L1.832|
                          DCD      param
                  |L1.836|
000344  6877496e          DCB      "hwInit Open UART error!\n",0
000348  6974204f
00034c  70656e20
000350  55415254
000354  20657272
000358  6f72210a
00035c  00      
00035d  00                DCB      0
00035e  00                DCB      0
00035f  00                DCB      0
                  |L1.864|
000360  6877496e          DCB      "hwInit Set TX interrupt mode fail!\n",0
000364  69742053
000368  65742054
00036c  5820696e
000370  74657272
000374  75707420
000378  6d6f6465
00037c  20666169
000380  6c210a00
                  |L1.900|
000384  6877496e          DCB      "hwInit Set RX interrupt mode fail!\n",0
000388  69742053
00038c  65742052
000390  5820696e
000394  74657272
000398  75707420
00039c  6d6f6465
0003a0  20666169
0003a4  6c210a00
                  |L1.936|
0003a8  55415254          DCB      "UART1DrvInit!!\n",0
0003ac  31447276
0003b0  496e6974
0003b4  21210a00
                  |L1.952|
0003b8  0d00              DCB      "\r",0
0003ba  00                DCB      0
0003bb  00                DCB      0
                          ENDP

                  UART1FlushBuffer PROC
;;;183    
;;;184    void UART1FlushBuffer(void)
0003bc  e92d4010          PUSH     {r4,lr}
;;;185    {
;;;186        //sysprintf(" --> CardFlushBuffer\n");
;;;187        //if (pUartInterface->ioctlFunc(UART_IOC_FLUSH_TX_BUFFER, 0, 0) != 0) {
;;;188       //     sysprintf("Set TX Flush fail!\n");
;;;189        //    return;
;;;190        //}
;;;191        if (UART1Ioctl(UART_IOC_FLUSH_RX_BUFFER, 0, 0) != 0) {
0003c0  e3a02000          MOV      r2,#0
0003c4  e1a01002          MOV      r1,r2
0003c8  e3a00019          MOV      r0,#0x19
0003cc  ebfffffe          BL       UART1Ioctl
0003d0  e3500000          CMP      r0,#0
0003d4  0a000002          BEQ      |L1.996|
;;;192            sysprintf("Set RX Flush fail!\n");
0003d8  e28f000c          ADR      r0,|L1.1004|
0003dc  ebfffffe          BL       sysprintf
                  |L1.992|
;;;193            return;
;;;194        }
;;;195    }
0003e0  e8bd8010          POP      {r4,pc}
                  |L1.996|
0003e4  e1a00000          MOV      r0,r0
0003e8  eafffffc          B        |L1.992|
;;;196        
                          ENDP

                  |L1.1004|
0003ec  53657420          DCB      "Set RX Flush fail!\n",0
0003f0  52582046
0003f4  6c757368
0003f8  20666169
0003fc  6c210a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param
                          %        16
