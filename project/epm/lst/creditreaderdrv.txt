; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\creditreaderdrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\creditreaderdrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\creditreaderdrv.crf src\syshal\creditReaderDrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  flushBuffer PROC
;;;50     
;;;51     static void flushBuffer(void)
000000  e92d4010          PUSH     {r4,lr}
;;;52     {
;;;53         //sysprintf(" --> CardFlushBuffer\n");
;;;54         //if (pUartInterface->ioctlFunc(UART_IOC_FLUSH_TX_BUFFER, 0, 0) != 0) {
;;;55        //     sysprintf("Set TX Flush fail!\n");
;;;56         //    return;
;;;57         //}
;;;58         if (pUartInterface->ioctlFunc(UART_IOC_FLUSH_RX_BUFFER, 0, 0) != 0) {
000004  e59f0268          LDR      r0,|L1.628|
000008  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
00000c  e3a02000          MOV      r2,#0
000010  e1a01002          MOV      r1,r2
000014  e5903018          LDR      r3,[r0,#0x18]
000018  e3a00019          MOV      r0,#0x19
00001c  e12fff33          BLX      r3
000020  e3500000          CMP      r0,#0
000024  0a000002          BEQ      |L1.52|
;;;59             sysprintf("Set RX Flush fail!\n");
000028  e28f0f92          ADR      r0,|L1.632|
00002c  ebfffffe          BL       sysprintf
                  |L1.48|
;;;60             return;
;;;61         }
;;;62     }
000030  e8bd8010          POP      {r4,pc}
                  |L1.52|
000034  e1a00000          MOV      r0,r0
000038  eafffffc          B        |L1.48|
;;;63     
                          ENDP

                  CreditCardSetPower PROC
;;;206    
;;;207    void CreditCardSetPower(BOOL flag)
00003c  e92d4010          PUSH     {r4,lr}
;;;208    {
000040  e1a04000          MOV      r4,r0
;;;209        pUartInterface->setRS232PowerFunc(flag);
000044  e59f0228          LDR      r0,|L1.628|
000048  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
00004c  e5901014          LDR      r1,[r0,#0x14]
000050  e1a00004          MOV      r0,r4
000054  e12fff31          BLX      r1
;;;210        pUartInterface->setPowerFunc(flag);
000058  e59f0214          LDR      r0,|L1.628|
00005c  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
000060  e5901010          LDR      r1,[r0,#0x10]
000064  e1a00004          MOV      r0,r4
000068  e12fff31          BLX      r1
;;;211    }
00006c  e8bd8010          POP      {r4,pc}
;;;212    
                          ENDP

                  CreditCardRead PROC
;;;217    
;;;218    INT32 CreditCardRead(PUINT8 pucBuf, UINT32 uLen)
000070  e92d4070          PUSH     {r4-r6,lr}
;;;219    {
000074  e1a04000          MOV      r4,r0
000078  e1a05001          MOV      r5,r1
;;;220        return pUartInterface->readFunc(pucBuf, uLen);
00007c  e59f01f0          LDR      r0,|L1.628|
000080  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
000084  e1a01005          MOV      r1,r5
000088  e5902008          LDR      r2,[r0,#8]
00008c  e1a00004          MOV      r0,r4
000090  e12fff32          BLX      r2
;;;221    }
000094  e8bd8070          POP      {r4-r6,pc}
;;;222    
                          ENDP

                  CreditCardWrite PROC
;;;223    INT32 CreditCardWrite(PUINT8 pucBuf, UINT32 uLen)
000098  e92d4070          PUSH     {r4-r6,lr}
;;;224    {
00009c  e1a04000          MOV      r4,r0
0000a0  e1a05001          MOV      r5,r1
;;;225        return pUartInterface->writeFunc(pucBuf, uLen);
0000a4  e59f01c8          LDR      r0,|L1.628|
0000a8  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
0000ac  e1a01005          MOV      r1,r5
0000b0  e5902004          LDR      r2,[r0,#4]
0000b4  e1a00004          MOV      r0,r4
0000b8  e12fff32          BLX      r2
;;;226    }
0000bc  e8bd8070          POP      {r4-r6,pc}
;;;227    
                          ENDP

                  CreditCardFlushTxRx PROC
;;;212    
;;;213    void CreditCardFlushTxRx(void)
0000c0  e92d4010          PUSH     {r4,lr}
;;;214    {
;;;215        flushBuffer();
0000c4  ebfffffe          BL       flushBuffer
;;;216    }
0000c8  e8bd8010          POP      {r4,pc}
;;;217    
                          ENDP

                  vCreditReaderTestTask PROC
;;;64     #if (ENABLE_BURNIN_TESTER)
;;;65     static void vCreditReaderTestTask(void *pvParameters)
0000cc  e24ddc01          SUB      sp,sp,#0x100
;;;66     {
;;;67         time_t lastTime = GetCurrentUTCTime();
0000d0  ebfffffe          BL       GetCurrentUTCTime
0000d4  e1a06000          MOV      r6,r0
;;;68         time_t currentTime;
;;;69         BOOL testLoop = FALSE;
0000d8  e3a07000          MOV      r7,#0
;;;70         uint8_t sndBuffer[128];
;;;71         uint8_t rcvBuffer[128];
;;;72         uint32_t sndLength = 0;
0000dc  e3a04000          MOV      r4,#0
;;;73         uint32_t rcvLength = 0;
0000e0  e3a08000          MOV      r8,#0
;;;74         terninalPrintf("vCreditReaderTestTask Going...\r\n");
0000e4  e28f0e1a          ADR      r0,|L1.652|
0000e8  ebfffffe          BL       terninalPrintf
;;;75         
;;;76         while (TRUE)
0000ec  ea00005f          B        |L1.624|
                  |L1.240|
;;;77         {
;;;78             if (GetPrepareStopBurninFlag())
0000f0  ebfffffe          BL       GetPrepareStopBurninFlag
0000f4  e3500000          CMP      r0,#0
0000f8  0a000003          BEQ      |L1.268|
;;;79             {
;;;80                 terninalPrintf("vCreditReaderTestTask Terminated !!\r\n");
0000fc  e28f0f6b          ADR      r0,|L1.688|
000100  ebfffffe          BL       terninalPrintf
;;;81                 vTaskDelete(NULL);
000104  e3a00000          MOV      r0,#0
000108  ebfffffe          BL       vTaskDelete
                  |L1.268|
;;;82             }
;;;83             currentTime = GetCurrentUTCTime();
00010c  ebfffffe          BL       GetCurrentUTCTime
000110  e1a05000          MOV      r5,r0
;;;84             if ((currentTime - lastTime) > BURNIN_CREDIT_READER_INTERVAL)
000114  e0450006          SUB      r0,r5,r6
000118  e3500014          CMP      r0,#0x14
00011c  9a000000          BLS      |L1.292|
;;;85             {
;;;86                 //terninalPrintf("vCreditReaderTestTask heartbeat.\r\n");
;;;87                 //lastTime = currentTime;
;;;88                 testLoop = TRUE;
000120  e3a07001          MOV      r7,#1
                  |L1.292|
;;;89             }
;;;90             if (!testLoop)
000124  e3570000          CMP      r7,#0
000128  1a000002          BNE      |L1.312|
;;;91             {
;;;92                 vTaskDelay(100 / portTICK_RATE_MS);
00012c  e3a0000a          MOV      r0,#0xa
000130  ebfffffe          BL       vTaskDelay
;;;93                 continue;
000134  ea00004d          B        |L1.624|
                  |L1.312|
;;;94             }
;;;95             testLoop = FALSE; 
000138  e3a07000          MOV      r7,#0
;;;96             CreditCardSetPower(TRUE);
00013c  e3a00001          MOV      r0,#1
000140  ebfffffe          BL       CreditCardSetPower
;;;97             vTaskDelay(3000/portTICK_RATE_MS);
000144  e3a00f4b          MOV      r0,#0x12c
000148  ebfffffe          BL       vTaskDelay
;;;98             CreditCardFlushTxRx(); 
00014c  ebfffffe          BL       CreditCardFlushTxRx
;;;99             //Unknown Test
;;;100            sndLength = 0;
000150  e3a04000          MOV      r4,#0
;;;101            sndBuffer[sndLength++] = 0x02;
000154  e3a01002          MOV      r1,#2
000158  e1a00004          MOV      r0,r4
00015c  e2844001          ADD      r4,r4,#1
000160  e28d2080          ADD      r2,sp,#0x80
000164  e7c21000          STRB     r1,[r2,r0]
;;;102            sndBuffer[sndLength++] = 0x00;
000168  e3a01000          MOV      r1,#0
00016c  e1a00004          MOV      r0,r4
000170  e2844001          ADD      r4,r4,#1
000174  e28d2080          ADD      r2,sp,#0x80
000178  e7c21000          STRB     r1,[r2,r0]
;;;103            sndBuffer[sndLength++] = 0x10;
00017c  e3a01010          MOV      r1,#0x10
000180  e1a00004          MOV      r0,r4
000184  e2844001          ADD      r4,r4,#1
000188  e28d2080          ADD      r2,sp,#0x80
00018c  e7c21000          STRB     r1,[r2,r0]
;;;104            sndBuffer[sndLength++] = 0x01;
000190  e3a01001          MOV      r1,#1
000194  e1a00004          MOV      r0,r4
000198  e2844001          ADD      r4,r4,#1
00019c  e28d2080          ADD      r2,sp,#0x80
0001a0  e7c21000          STRB     r1,[r2,r0]
;;;105            sndBuffer[sndLength++] = 0x00;
0001a4  e3a01000          MOV      r1,#0
0001a8  e1a00004          MOV      r0,r4
0001ac  e2844001          ADD      r4,r4,#1
0001b0  e28d2080          ADD      r2,sp,#0x80
0001b4  e7c21000          STRB     r1,[r2,r0]
;;;106            sndBuffer[sndLength++] = 0xFF;
0001b8  e3a010ff          MOV      r1,#0xff
0001bc  e1a00004          MOV      r0,r4
0001c0  e2844001          ADD      r4,r4,#1
0001c4  e28d2080          ADD      r2,sp,#0x80
0001c8  e7c21000          STRB     r1,[r2,r0]
;;;107            sndBuffer[sndLength++] = 0x03;
0001cc  e3a01003          MOV      r1,#3
0001d0  e1a00004          MOV      r0,r4
0001d4  e2844001          ADD      r4,r4,#1
0001d8  e28d2080          ADD      r2,sp,#0x80
0001dc  e7c21000          STRB     r1,[r2,r0]
;;;108            sndBuffer[sndLength++] = 0xA0;
0001e0  e3a010a0          MOV      r1,#0xa0
0001e4  e1a00004          MOV      r0,r4
0001e8  e2844001          ADD      r4,r4,#1
0001ec  e28d2080          ADD      r2,sp,#0x80
0001f0  e7c21000          STRB     r1,[r2,r0]
;;;109            sndBuffer[sndLength++] = 0x65;
0001f4  e3a01065          MOV      r1,#0x65
0001f8  e1a00004          MOV      r0,r4
0001fc  e2844001          ADD      r4,r4,#1
000200  e28d2080          ADD      r2,sp,#0x80
000204  e7c21000          STRB     r1,[r2,r0]
;;;110            CreditCardWrite(sndBuffer, sndLength);
000208  e1a01004          MOV      r1,r4
00020c  e28d0080          ADD      r0,sp,#0x80
000210  ebfffffe          BL       CreditCardWrite
;;;111            
;;;112            vTaskDelay(500/portTICK_RATE_MS);
000214  e3a00032          MOV      r0,#0x32
000218  ebfffffe          BL       vTaskDelay
;;;113            rcvLength = CreditCardRead(rcvBuffer, sizeof(rcvBuffer));  
00021c  e3a01080          MOV      r1,#0x80
000220  e1a0000d          MOV      r0,sp
000224  ebfffffe          BL       CreditCardRead
000228  e1a08000          MOV      r8,r0
;;;114            //BaseType_t reval = pUartInterface->readWaitFunc(portMAX_DELAY);
;;;115            //while(1)
;;;116            //{
;;;117            //    rcvLength = CreditCardRead(rcvBuffer, sizeof(rcvBuffer));
;;;118            //    if (rcvLength > 0) {
;;;119            //        break;
;;;120            //    }
;;;121            //}
;;;122            //terninalPrintf("vCreditReaderTestTask ==> rcvLength=%d\r\n", rcvLength);
;;;123            if (rcvLength == 0) {
00022c  e3580000          CMP      r8,#0
000230  1a000004          BNE      |L1.584|
;;;124                creditReaderBurninErrorCounter++;
000234  e59f009c          LDR      r0,|L1.728|
000238  e5900000          LDR      r0,[r0,#0]  ; creditReaderBurninErrorCounter
00023c  e2800001          ADD      r0,r0,#1
000240  e59f1090          LDR      r1,|L1.728|
000244  e5810000          STR      r0,[r1,#0]  ; creditReaderBurninErrorCounter
                  |L1.584|
;;;125            }
;;;126            creditReaderBurninCounter++;
000248  e59f008c          LDR      r0,|L1.732|
00024c  e5900000          LDR      r0,[r0,#0]  ; creditReaderBurninCounter
000250  e2800001          ADD      r0,r0,#1
000254  e59f1080          LDR      r1,|L1.732|
000258  e5810000          STR      r0,[r1,#0]  ; creditReaderBurninCounter
;;;127            CreditCardSetPower(FALSE);
00025c  e3a00000          MOV      r0,#0
000260  ebfffffe          BL       CreditCardSetPower
;;;128            lastTime = GetCurrentUTCTime(); 
000264  ebfffffe          BL       GetCurrentUTCTime
000268  e1a06000          MOV      r6,r0
00026c  e1a00000          MOV      r0,r0                 ;93
                  |L1.624|
000270  eaffff9e          B        |L1.240|
                  |L1.628|
                          DCD      pUartInterface
                  |L1.632|
000278  53657420          DCB      "Set RX Flush fail!\n",0
00027c  52582046
000280  6c757368
000284  20666169
000288  6c210a00
                  |L1.652|
00028c  76437265          DCB      "vCreditReaderTestTask Going...\r\n",0
000290  64697452
000294  65616465
000298  72546573
00029c  74546173
0002a0  6b20476f
0002a4  696e672e
0002a8  2e2e0d0a
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L1.688|
0002b0  76437265          DCB      "vCreditReaderTestTask Terminated !!\r\n",0
0002b4  64697452
0002b8  65616465
0002bc  72546573
0002c0  74546173
0002c4  6b205465
0002c8  726d696e
0002cc  61746564
0002d0  2021210d
0002d4  0a00    
0002d6  00                DCB      0
0002d7  00                DCB      0
                  |L1.728|
                          DCD      creditReaderBurninErrorCounter
                  |L1.732|
                          DCD      creditReaderBurninCounter
                          ENDP

                  swInit PROC
;;;132    
;;;133    static BOOL swInit(void)
0002e0  e92d401c          PUSH     {r2-r4,lr}
;;;134    {
;;;135    #if (ENABLE_BURNIN_TESTER)
;;;136        if (EnabledBurninTestMode())
0002e4  ebfffffe          BL       EnabledBurninTestMode
0002e8  e3500000          CMP      r0,#0
0002ec  0a000008          BEQ      |L1.788|
;;;137        {
;;;138            xTaskCreate(vCreditReaderTestTask, "vCreditReaderTestTask", 1024*5, NULL, CARD_READER_TEST_THREAD_PROI, NULL);
0002f0  e3a00000          MOV      r0,#0
0002f4  e3a01003          MOV      r1,#3
0002f8  e58d0004          STR      r0,[sp,#4]
0002fc  e1a03000          MOV      r3,r0
000300  e3a02b05          MOV      r2,#0x1400
000304  e58d1000          STR      r1,[sp,#0]
000308  e28f1f73          ADR      r1,|L1.1244|
00030c  e59f01e0          LDR      r0,|L1.1268|
000310  ebfffffe          BL       xTaskCreate
                  |L1.788|
;;;139        }
;;;140    #endif
;;;141        return TRUE;
000314  e3a00001          MOV      r0,#1
;;;142    }
000318  e8bd801c          POP      {r2-r4,pc}
;;;143    
                          ENDP

                  bv1000_testing PROC
;;;144    void bv1000_testing(void)
00031c  e92d4070          PUSH     {r4-r6,lr}
;;;145    {
000320  e24ddc01          SUB      sp,sp,#0x100
;;;146        uint8_t sndBuffer[128];
;;;147        uint8_t rcvBuffer[128];
;;;148        uint32_t sndLength = 0;
000324  e3a04000          MOV      r4,#0
;;;149        uint32_t rcvLength = 0;
000328  e3a05000          MOV      r5,#0
;;;150        
;;;151        CreditCardSetPower(TRUE);
00032c  e3a00001          MOV      r0,#1
000330  ebfffffe          BL       CreditCardSetPower
;;;152        vTaskDelay(3000/portTICK_RATE_MS);
000334  e3a00f4b          MOV      r0,#0x12c
000338  ebfffffe          BL       vTaskDelay
;;;153        
;;;154        CreditCardFlushTxRx();
00033c  ebfffffe          BL       CreditCardFlushTxRx
;;;155        sndBuffer[sndLength++] = 0x02;
000340  e3a01002          MOV      r1,#2
000344  e1a00004          MOV      r0,r4
000348  e2844001          ADD      r4,r4,#1
00034c  e28d2080          ADD      r2,sp,#0x80
000350  e7c21000          STRB     r1,[r2,r0]
;;;156        sndBuffer[sndLength++] = 0x01;
000354  e3a01001          MOV      r1,#1
000358  e1a00004          MOV      r0,r4
00035c  e2844001          ADD      r4,r4,#1
000360  e28d2080          ADD      r2,sp,#0x80
000364  e7c21000          STRB     r1,[r2,r0]
;;;157        sndBuffer[sndLength++] = 0x01;
000368  e1a00004          MOV      r0,r4
00036c  e2844001          ADD      r4,r4,#1
000370  e28d2080          ADD      r2,sp,#0x80
000374  e7c21000          STRB     r1,[r2,r0]
;;;158        sndBuffer[sndLength++] = 0x00;
000378  e3a01000          MOV      r1,#0
00037c  e1a00004          MOV      r0,r4
000380  e2844001          ADD      r4,r4,#1
000384  e28d2080          ADD      r2,sp,#0x80
000388  e7c21000          STRB     r1,[r2,r0]
;;;159        sndBuffer[sndLength++] = 0x20;
00038c  e3a01020          MOV      r1,#0x20
000390  e1a00004          MOV      r0,r4
000394  e2844001          ADD      r4,r4,#1
000398  e28d2080          ADD      r2,sp,#0x80
00039c  e7c21000          STRB     r1,[r2,r0]
;;;160        sndBuffer[sndLength++] = 0x03;
0003a0  e3a01003          MOV      r1,#3
0003a4  e1a00004          MOV      r0,r4
0003a8  e2844001          ADD      r4,r4,#1
0003ac  e28d2080          ADD      r2,sp,#0x80
0003b0  e7c21000          STRB     r1,[r2,r0]
;;;161        sndBuffer[sndLength++] = 0x13;
0003b4  e3a01013          MOV      r1,#0x13
0003b8  e1a00004          MOV      r0,r4
0003bc  e2844001          ADD      r4,r4,#1
0003c0  e28d2080          ADD      r2,sp,#0x80
0003c4  e7c21000          STRB     r1,[r2,r0]
;;;162        sndBuffer[sndLength++] = 0x0D;
0003c8  e3a0100d          MOV      r1,#0xd
0003cc  e1a00004          MOV      r0,r4
0003d0  e2844001          ADD      r4,r4,#1
0003d4  e28d2080          ADD      r2,sp,#0x80
0003d8  e7c21000          STRB     r1,[r2,r0]
;;;163        CreditCardWrite(sndBuffer, sndLength);
0003dc  e1a01004          MOV      r1,r4
0003e0  e28d0080          ADD      r0,sp,#0x80
0003e4  ebfffffe          BL       CreditCardWrite
;;;164        vTaskDelay(500/portTICK_RATE_MS);
0003e8  e3a00032          MOV      r0,#0x32
0003ec  ebfffffe          BL       vTaskDelay
;;;165        rcvLength = CreditCardRead(rcvBuffer, sizeof(rcvBuffer));
0003f0  e3a01080          MOV      r1,#0x80
0003f4  e1a0000d          MOV      r0,sp
0003f8  ebfffffe          BL       CreditCardRead
0003fc  e1a05000          MOV      r5,r0
;;;166        terninalPrintf("bv1000_testing ==> rcvLength=%d", rcvLength);
000400  e1a01005          MOV      r1,r5
000404  e28f00ec          ADR      r0,|L1.1272|
000408  ebfffffe          BL       terninalPrintf
;;;167        if (rcvLength > 0)
00040c  e3550000          CMP      r5,#0
000410  0a000009          BEQ      |L1.1084|
;;;168        {
;;;169            terninalPrintf(", data = ");
000414  e28f00fc          ADR      r0,|L1.1304|
000418  ebfffffe          BL       terninalPrintf
;;;170            for (int i = 0 ; i < rcvLength ; i++)
00041c  e3a06000          MOV      r6,#0
000420  ea000003          B        |L1.1076|
                  |L1.1060|
;;;171            {
;;;172                terninalPrintf("%02x, ", rcvBuffer[i]);
000424  e7dd1006          LDRB     r1,[sp,r6]
000428  e28f00f4          ADR      r0,|L1.1316|
00042c  ebfffffe          BL       terninalPrintf
000430  e2866001          ADD      r6,r6,#1              ;170
                  |L1.1076|
000434  e1560005          CMP      r6,r5                 ;170
000438  3afffff9          BCC      |L1.1060|
                  |L1.1084|
;;;173            }
;;;174        }
;;;175        terninalPrintf("\r\n");
00043c  e28f00e8          ADR      r0,|L1.1324|
000440  ebfffffe          BL       terninalPrintf
;;;176        
;;;177        CreditCardSetPower(FALSE);
000444  e3a00000          MOV      r0,#0
000448  ebfffffe          BL       CreditCardSetPower
;;;178    }
00044c  e28ddc01          ADD      sp,sp,#0x100
000450  e8bd8070          POP      {r4-r6,pc}
;;;179    
                          ENDP

                  CreditReaderDrvInit PROC
;;;182    /*-----------------------------------------*/
;;;183    BOOL CreditReaderDrvInit(BOOL testModeFlag)
000454  e92d4010          PUSH     {r4,lr}
;;;184    {
000458  e1a04000          MOV      r4,r0
;;;185        sysprintf("CreditReaderDrvInit!!\n");
00045c  e28f00cc          ADR      r0,|L1.1328|
000460  ebfffffe          BL       sysprintf
;;;186        pUartInterface = UartGetInterface(CREDIT_READER_UART);
000464  e3a00006          MOV      r0,#6
000468  ebfffffe          BL       UartGetInterface
00046c  e51f1200          LDR      r1,|L1.628|
000470  e5810000          STR      r0,[r1,#0]  ; pUartInterface
;;;187        if (pUartInterface == NULL)
000474  e2810000          ADD      r0,r1,#0
000478  e5900000          LDR      r0,[r0,#0]  ; pUartInterface
00047c  e3500000          CMP      r0,#0
000480  1a000003          BNE      |L1.1172|
;;;188        {
;;;189            sysprintf("CreditReaderDrvInit ERROR (pUartInterface == NULL)!!\n");
000484  e28f00bc          ADR      r0,|L1.1352|
000488  ebfffffe          BL       sysprintf
;;;190            return FALSE;
00048c  e3a00000          MOV      r0,#0
                  |L1.1168|
;;;191        }
;;;192        if (pUartInterface->initFunc(115200) == FALSE)
;;;193        {
;;;194            sysprintf("CreditReaderDrvInit ERROR (initFunc false)!!\n");
;;;195            return FALSE;
;;;196        }
;;;197        if (swInit() == FALSE)
;;;198        {
;;;199            sysprintf("CreditReaderDrvInit ERROR (swInit false)!!\n");
;;;200            return FALSE;
;;;201        }
;;;202        sysprintf("CreditReaderDrvInit OK!!\n");
;;;203        CreditCardSetPower(FALSE);//bv1000_testing();
;;;204        return TRUE;
;;;205    }
000490  e8bd8010          POP      {r4,pc}
                  |L1.1172|
000494  e51f0228          LDR      r0,|L1.628|
000498  e5900000          LDR      r0,[r0,#0]            ;192  ; pUartInterface
00049c  e5901000          LDR      r1,[r0,#0]            ;192
0004a0  e59f00d8          LDR      r0,|L1.1408|
0004a4  e12fff31          BLX      r1                    ;192
0004a8  e3500000          CMP      r0,#0                 ;192
0004ac  1a000003          BNE      |L1.1216|
0004b0  e28f00cc          ADR      r0,|L1.1412|
0004b4  ebfffffe          BL       sysprintf
0004b8  e3a00000          MOV      r0,#0                 ;195
0004bc  eafffff3          B        |L1.1168|
                  |L1.1216|
0004c0  ebfffffe          BL       swInit
0004c4  e3500000          CMP      r0,#0                 ;197
0004c8  1a000044          BNE      |L1.1504|
0004cc  e28f00e0          ADR      r0,|L1.1460|
0004d0  ebfffffe          BL       sysprintf
0004d4  e3a00000          MOV      r0,#0                 ;200
0004d8  eaffffec          B        |L1.1168|
                  |L1.1244|
0004dc  76437265          DCB      "vCreditReaderTestTask",0
0004e0  64697452
0004e4  65616465
0004e8  72546573
0004ec  74546173
0004f0  6b00    
0004f2  00                DCB      0
0004f3  00                DCB      0
                  |L1.1268|
                          DCD      vCreditReaderTestTask
                  |L1.1272|
0004f8  62763130          DCB      "bv1000_testing ==> rcvLength=%d",0
0004fc  30305f74
000500  65737469
000504  6e67203d
000508  3d3e2072
00050c  63764c65
000510  6e677468
000514  3d256400
                  |L1.1304|
000518  2c206461          DCB      ", data = ",0
00051c  7461203d
000520  2000    
000522  00                DCB      0
000523  00                DCB      0
                  |L1.1316|
000524  25303278          DCB      "%02x, ",0
000528  2c2000  
00052b  00                DCB      0
                  |L1.1324|
00052c  0d0a00            DCB      "\r\n",0
00052f  00                DCB      0
                  |L1.1328|
000530  43726564          DCB      "CreditReaderDrvInit!!\n",0
000534  69745265
000538  61646572
00053c  44727649
000540  6e697421
000544  210a00  
000547  00                DCB      0
                  |L1.1352|
000548  43726564          DCB      "CreditReaderDrvInit ERROR (pUartInterface == NULL)!!\n",0
00054c  69745265
000550  61646572
000554  44727649
000558  6e697420
00055c  4552524f
000560  52202870
000564  55617274
000568  496e7465
00056c  72666163
000570  65203d3d
000574  204e554c
000578  4c292121
00057c  0a00    
00057e  00                DCB      0
00057f  00                DCB      0
                  |L1.1408|
                          DCD      0x0001c200
                  |L1.1412|
000584  43726564          DCB      "CreditReaderDrvInit ERROR (initFunc false)!!\n",0
000588  69745265
00058c  61646572
000590  44727649
000594  6e697420
000598  4552524f
00059c  52202869
0005a0  6e697446
0005a4  756e6320
0005a8  66616c73
0005ac  65292121
0005b0  0a00    
0005b2  00                DCB      0
0005b3  00                DCB      0
                  |L1.1460|
0005b4  43726564          DCB      "CreditReaderDrvInit ERROR (swInit false)!!\n",0
0005b8  69745265
0005bc  61646572
0005c0  44727649
0005c4  6e697420
0005c8  4552524f
0005cc  52202873
0005d0  77496e69
0005d4  74206661
0005d8  6c736529
0005dc  21210a00
                  |L1.1504|
0005e0  e28f0f96          ADR      r0,|L1.2112|
0005e4  ebfffffe          BL       sysprintf
0005e8  e3a00000          MOV      r0,#0                 ;203
0005ec  ebfffffe          BL       CreditCardSetPower
0005f0  e3a00001          MOV      r0,#1                 ;204
0005f4  eaffffa5          B        |L1.1168|
;;;206    
                          ENDP

                  GetCreditReaderBurninTestCounter PROC
;;;228    #if (ENABLE_BURNIN_TESTER)
;;;229    uint32_t GetCreditReaderBurninTestCounter(void)
0005f8  e51f0324          LDR      r0,|L1.732|
;;;230    {
;;;231        return creditReaderBurninCounter;
0005fc  e5900000          LDR      r0,[r0,#0]  ; creditReaderBurninCounter
;;;232    }
000600  e12fff1e          BX       lr
;;;233    
                          ENDP

                  GetCreditReaderBurninTestErrorCounter PROC
;;;234    uint32_t GetCreditReaderBurninTestErrorCounter(void)
000604  e51f0334          LDR      r0,|L1.728|
;;;235    {
;;;236        return creditReaderBurninErrorCounter;
000608  e5900000          LDR      r0,[r0,#0]  ; creditReaderBurninErrorCounter
;;;237    }
00060c  e12fff1e          BX       lr
;;;238    #endif
                          ENDP

                  crc16_ccitt PROC
;;;239    
;;;240    static uint16_t crc16_ccitt(uint8_t *data, UINT length)
000610  e92d4010          PUSH     {r4,lr}
;;;241    {
000614  e1a02000          MOV      r2,r0
000618  e1a03001          MOV      r3,r1
;;;242        uint8_t i;
;;;243        uint16_t crc = 0;        // Initial value
00061c  e3a00000          MOV      r0,#0
;;;244        while(length--)
000620  ea00000d          B        |L1.1628|
                  |L1.1572|
;;;245        {
;;;246            crc ^= *data++;        // crc ^= *data; data++;
000624  e4d2c001          LDRB     r12,[r2],#1
000628  e020000c          EOR      r0,r0,r12
;;;247            for (i = 0; i < 8; ++i)
00062c  e3a01000          MOV      r1,#0
000630  ea000007          B        |L1.1620|
                  |L1.1588|
;;;248            {
;;;249                if (crc & 1)
000634  e3100001          TST      r0,#1
000638  0a000002          BEQ      |L1.1608|
;;;250                    crc = (crc >> 1) ^ 0x8408;        // 0x8408 = reverse 0x1021
00063c  e59fc218          LDR      r12,|L1.2140|
000640  e02c00c0          EOR      r0,r12,r0,ASR #1
000644  ea000000          B        |L1.1612|
                  |L1.1608|
;;;251                else
;;;252                    crc = (crc >> 1);
000648  e1a000c0          ASR      r0,r0,#1
                  |L1.1612|
00064c  e281c001          ADD      r12,r1,#1             ;247
000650  e20c10ff          AND      r1,r12,#0xff          ;247
                  |L1.1620|
000654  e3510008          CMP      r1,#8                 ;247
000658  bafffff5          BLT      |L1.1588|
                  |L1.1628|
00065c  e1b0c003          MOVS     r12,r3                ;244
000660  e2433001          SUB      r3,r3,#1              ;244
000664  1affffee          BNE      |L1.1572|
;;;253            }
;;;254        }
;;;255        
;;;256        crc = ( (crc>>8) & 0x00FF ) | ( (crc<<8) & 0xFF00 );
000668  e1a0c800          LSL      r12,r0,#16
00066c  e3a04cff          MOV      r4,#0xff00
000670  e0044400          AND      r4,r4,r0,LSL #8
000674  e1840c2c          ORR      r0,r4,r12,LSR #24
;;;257        return crc;
;;;258    }
000678  e8bd8010          POP      {r4,pc}
;;;259    
                          ENDP

                  readCreditCard PROC
;;;260    static void readCreditCard(uint8_t* buff,int buffsize,int* feedbackBuffSize ,BOOL para1)
00067c  e92d5fff          PUSH     {r0-r12,lr}
;;;261    {
000680  e1a05000          MOV      r5,r0
000684  e1a07001          MOV      r7,r1
000688  e1a08002          MOV      r8,r2
00068c  e1a09003          MOV      r9,r3
;;;262        int index = 0;
000690  e3a04000          MOV      r4,#0
;;;263        int counter = 0;
000694  e3a0a000          MOV      r10,#0
;;;264        BOOL breakFlag = FALSE;
000698  e3a0b000          MOV      r11,#0
;;;265        BOOL noAPDUmsgFlag = FALSE;
00069c  e3a00000          MOV      r0,#0
0006a0  e58d000c          STR      r0,[sp,#0xc]
;;;266        BOOL quickleaveFlag = FALSE;
0006a4  e58d0008          STR      r0,[sp,#8]
;;;267        INT32 reVal;
;;;268        uint8_t IndexShift = 0;
0006a8  e58d0004          STR      r0,[sp,#4]
;;;269    
;;;270        CommunicationInterface* CreditCardInterface;
;;;271        CreditCardInterface = CommunicationGetInterface(0);
0006ac  ebfffffe          BL       CommunicationGetInterface
0006b0  e58d0000          STR      r0,[sp,#0]
;;;272        //CreditCardInterface->initFunc();
;;;273        //uartIoctl(10, 25, 0, 0);
;;;274        while(counter < 300)
0006b4  ea00005c          B        |L1.2092|
                  |L1.1720|
;;;275        {
;;;276            //short Command_ID;
;;;277            vTaskDelay(10/portTICK_RATE_MS);
0006b8  e3a00001          MOV      r0,#1
0006bc  ebfffffe          BL       vTaskDelay
;;;278            counter++;
0006c0  e28aa001          ADD      r10,r10,#1
;;;279            reVal = CreditCardInterface->readFunc(buff + index, buffsize-index);
0006c4  e0471004          SUB      r1,r7,r4
0006c8  e0850004          ADD      r0,r5,r4
0006cc  e59d3000          LDR      r3,[sp,#0]
0006d0  e5932008          LDR      r2,[r3,#8]
0006d4  e12fff32          BLX      r2
0006d8  e1a06000          MOV      r6,r0
;;;280            if(reVal > 0)
0006dc  e3560000          CMP      r6,#0
0006e0  da000051          BLE      |L1.2092|
;;;281            {
;;;282                index = index + reVal;
0006e4  e0844006          ADD      r4,r4,r6
;;;283                //terninalPrintf("<=");            
;;;284                switch(buff[0]) 
0006e8  e5d50000          LDRB     r0,[r5,#0]
0006ec  e3500001          CMP      r0,#1
0006f0  0a000006          BEQ      |L1.1808|
0006f4  e3500004          CMP      r0,#4
0006f8  0a00000b          BEQ      |L1.1836|
0006fc  e3500006          CMP      r0,#6
000700  0a000010          BEQ      |L1.1864|
000704  e3500015          CMP      r0,#0x15
000708  1a000023          BNE      |L1.1948|
00070c  ea00001b          B        |L1.1920|
                  |L1.1808|
;;;285                {
;;;286                    case 0x01: //SOH
000710  e1a00000          MOV      r0,r0
;;;287                        noAPDUmsgFlag = TRUE;
000714  e3a00001          MOV      r0,#1
000718  e58d000c          STR      r0,[sp,#0xc]
;;;288                        if(index == 4)
00071c  e3540004          CMP      r4,#4
000720  1a000000          BNE      |L1.1832|
;;;289                            quickleaveFlag = TRUE;
000724  e58d0008          STR      r0,[sp,#8]
                  |L1.1832|
;;;290                        break;
000728  ea00001d          B        |L1.1956|
                  |L1.1836|
;;;291                    //case 0x02: //STX
;;;292                    //    break;
;;;293                    case 0x04: //EOT
00072c  e1a00000          MOV      r0,r0
;;;294                        noAPDUmsgFlag = TRUE;
000730  e3a00001          MOV      r0,#1
000734  e58d000c          STR      r0,[sp,#0xc]
;;;295                        if(index == 2)
000738  e3540002          CMP      r4,#2
00073c  1a000000          BNE      |L1.1860|
;;;296                            quickleaveFlag = TRUE;
000740  e58d0008          STR      r0,[sp,#8]
                  |L1.1860|
;;;297                        break;
000744  ea000016          B        |L1.1956|
                  |L1.1864|
;;;298                    case 0x06: //ACK
000748  e1a00000          MOV      r0,r0
;;;299                        if(index > 2)
00074c  e3540002          CMP      r4,#2
000750  da000002          BLE      |L1.1888|
;;;300                        {
;;;301                            //if((buff[2] == 0x01) || (buff[2] == 0x02))
;;;302                            //if(buff[2] == 0x01)
;;;303                              //  noAPDUmsgFlag = TRUE;
;;;304                            IndexShift = 2;                        
000754  e3a00002          MOV      r0,#2
000758  e58d0004          STR      r0,[sp,#4]
00075c  ea000006          B        |L1.1916|
                  |L1.1888|
;;;305                        }
;;;306                        else if((index == 2) && (para1 == TRUE))    
000760  e3540002          CMP      r4,#2
000764  1a000004          BNE      |L1.1916|
000768  e3590001          CMP      r9,#1
00076c  1a000002          BNE      |L1.1916|
;;;307                        {                        
;;;308                            noAPDUmsgFlag = TRUE;
000770  e3a00001          MOV      r0,#1
000774  e58d000c          STR      r0,[sp,#0xc]
;;;309                            quickleaveFlag = TRUE;
000778  e58d0008          STR      r0,[sp,#8]
                  |L1.1916|
;;;310                        }
;;;311                        break;
00077c  ea000008          B        |L1.1956|
                  |L1.1920|
;;;312                    case 0x15: //NAK
000780  e1a00000          MOV      r0,r0
;;;313                        noAPDUmsgFlag = TRUE;
000784  e3a00001          MOV      r0,#1
000788  e58d000c          STR      r0,[sp,#0xc]
;;;314                        if(index == 2)
00078c  e3540002          CMP      r4,#2
000790  1a000000          BNE      |L1.1944|
;;;315                            quickleaveFlag = TRUE;
000794  e58d0008          STR      r0,[sp,#8]
                  |L1.1944|
;;;316                        break;
000798  ea000001          B        |L1.1956|
                  |L1.1948|
;;;317                    default:
00079c  e1a00000          MOV      r0,r0
;;;318                        break;
0007a0  e1a00000          MOV      r0,r0
                  |L1.1956|
0007a4  e1a00000          MOV      r0,r0                 ;290
;;;319                }
;;;320                
;;;321                
;;;322                for(int i=0;i<index;i++)
0007a8  e3a00000          MOV      r0,#0
0007ac  ea000018          B        |L1.2068|
                  |L1.1968|
;;;323                {
;;;324    
;;;325                    //terninalPrintf("%02x ",buff[i]);
;;;326                    if(noAPDUmsgFlag)
0007b0  e59d100c          LDR      r1,[sp,#0xc]
0007b4  e3510000          CMP      r1,#0
0007b8  0a000004          BEQ      |L1.2000|
;;;327                    {
;;;328    
;;;329                        if(quickleaveFlag)
0007bc  e59d1008          LDR      r1,[sp,#8]
0007c0  e3510000          CMP      r1,#0
0007c4  0a000011          BEQ      |L1.2064|
;;;330                            breakFlag = TRUE;
0007c8  e3a0b001          MOV      r11,#1
0007cc  ea00000f          B        |L1.2064|
                  |L1.2000|
;;;331                    }                    
;;;332                    else if((buff[i] == 0x03) && (buff[i-1] != 0x10) && ((i + IndexShift) > 1) && (i < (index-2) ))
0007d0  e7d51000          LDRB     r1,[r5,r0]
0007d4  e3510003          CMP      r1,#3
0007d8  1a00000c          BNE      |L1.2064|
0007dc  e2401001          SUB      r1,r0,#1
0007e0  e7d51001          LDRB     r1,[r5,r1]
0007e4  e3510010          CMP      r1,#0x10
0007e8  0a000008          BEQ      |L1.2064|
0007ec  e59d1004          LDR      r1,[sp,#4]
0007f0  e0811000          ADD      r1,r1,r0
0007f4  e3510001          CMP      r1,#1
0007f8  da000004          BLE      |L1.2064|
0007fc  e2441002          SUB      r1,r4,#2
000800  e1510000          CMP      r1,r0
000804  da000001          BLE      |L1.2064|
;;;333                    {
;;;334                        /*
;;;335                       for(int j=0;j<=i;j++)
;;;336                            terninalPrintf("%02x ",buff[j]);
;;;337                       terninalPrintf("%02x ",buff[i+1]);
;;;338                       terninalPrintf("%02x index = %d",buff[i+2],i+2);
;;;339                        
;;;340                       terninalPrintf("\n   ");
;;;341                       for(int k=0;k<i;k++)
;;;342                       {
;;;343                           if((buff[k] >= 0x20) && (buff[k] <= 0x7E))
;;;344                                terninalPrintf("%c",buff[k]);
;;;345                       } 
;;;346                        */
;;;347                       breakFlag = TRUE; 
000808  e3a0b001          MOV      r11,#1
;;;348                       break;
00080c  ea000002          B        |L1.2076|
                  |L1.2064|
000810  e2800001          ADD      r0,r0,#1              ;322
                  |L1.2068|
000814  e1500004          CMP      r0,r4                 ;322
000818  baffffe4          BLT      |L1.1968|
                  |L1.2076|
00081c  e1a00000          MOV      r0,r0
;;;349                    }                               
;;;350                   }
;;;351                   //terninalPrintf("\n");    
;;;352                  
;;;353                   if(breakFlag)
000820  e35b0000          CMP      r11,#0
000824  0a000000          BEQ      |L1.2092|
;;;354                      break;
000828  ea000001          B        |L1.2100|
                  |L1.2092|
00082c  e35a0f4b          CMP      r10,#0x12c            ;274
000830  baffffa0          BLT      |L1.1720|
                  |L1.2100|
000834  e1a00000          MOV      r0,r0
;;;355            }
;;;356        }
;;;357        
;;;358        *feedbackBuffSize = index;
000838  e5884000          STR      r4,[r8,#0]
;;;359    }
00083c  e8bd9fff          POP      {r0-r12,pc}
                  |L1.2112|
000840  43726564          DCB      "CreditReaderDrvInit OK!!\n",0
000844  69745265
000848  61646572
00084c  44727649
000850  6e697420
000854  4f4b2121
000858  0a00    
00085a  00                DCB      0
00085b  00                DCB      0
                  |L1.2140|
                          DCD      0x00008408
                          ENDP

                  Decoder_S0_Parse PROC
;;;360    
;;;361    static uint8_t Decoder_S0_Parse(uint8_t ControlChr)
000860  e1a01000          MOV      r1,r0
;;;362    {
;;;363        switch(ControlChr) 
000864  e3510004          CMP      r1,#4
000868  0a000010          BEQ      |L1.2224|
00086c  ca000004          BGT      |L1.2180|
000870  e3510001          CMP      r1,#1
000874  0a000007          BEQ      |L1.2200|
000878  e3510002          CMP      r1,#2
00087c  1a000014          BNE      |L1.2260|
000880  ea000007          B        |L1.2212|
                  |L1.2180|
000884  e3510006          CMP      r1,#6
000888  0a00000b          BEQ      |L1.2236|
00088c  e3510015          CMP      r1,#0x15
000890  1a00000f          BNE      |L1.2260|
000894  ea00000b          B        |L1.2248|
                  |L1.2200|
;;;364        {
;;;365            case 0x01: //SOH
000898  e1a00000          MOV      r0,r0
;;;366                return DECODER_S1_SOH;
00089c  e3a00001          MOV      r0,#1
                  |L1.2208|
;;;367                break;
;;;368            case 0x02: //STX
;;;369                return DECODER_S2_STX;
;;;370                break;
;;;371            case 0x04: //EOT
;;;372                return DECODER_S3_EOT;
;;;373                break;
;;;374            case 0x06: //ACK
;;;375                return DECODER_S21_ACKin;
;;;376                break;
;;;377            case 0x15: //NAK
;;;378                return DECODER_S24_NACKin;
;;;379                break;
;;;380            default:
;;;381                return DECODER_S15_NACKout;
;;;382                break;
;;;383        }
;;;384    }
0008a0  e12fff1e          BX       lr
                  |L1.2212|
0008a4  e1a00000          MOV      r0,r0                 ;368
0008a8  e3a00002          MOV      r0,#2                 ;369
0008ac  eafffffb          B        |L1.2208|
                  |L1.2224|
0008b0  e1a00000          MOV      r0,r0                 ;371
0008b4  e3a00003          MOV      r0,#3                 ;372
0008b8  eafffff8          B        |L1.2208|
                  |L1.2236|
0008bc  e1a00000          MOV      r0,r0                 ;374
0008c0  e3a00015          MOV      r0,#0x15              ;375
0008c4  eafffff5          B        |L1.2208|
                  |L1.2248|
0008c8  e1a00000          MOV      r0,r0                 ;377
0008cc  e3a00018          MOV      r0,#0x18              ;378
0008d0  eafffff2          B        |L1.2208|
                  |L1.2260|
0008d4  e1a00000          MOV      r0,r0                 ;380
0008d8  e3a0000f          MOV      r0,#0xf               ;381
0008dc  eaffffef          B        |L1.2208|
;;;385    static void DecodeStateMachine(uint8_t* buff,int feedbackBuffSize,
                          ENDP

                  DecodeStateMachine PROC
0008e0  e92d4fff          PUSH     {r0-r11,lr}
;;;386                            uint8_t currentState,uint8_t* nextState,
;;;387                            uint8_t* currentSequenceNum,
;;;388                            BOOL ACKmessageFlag
;;;389                            )
;;;390    {
0008e4  e24dd014          SUB      sp,sp,#0x14
0008e8  e1a04000          MOV      r4,r0
0008ec  e1a07002          MOV      r7,r2
0008f0  e59d5048          LDR      r5,[sp,#0x48]
0008f4  e59d904c          LDR      r9,[sp,#0x4c]
;;;391        BOOL pollingFlag = TRUE;
0008f8  e3a0a001          MOV      r10,#1
;;;392        BOOL errorFlag = FALSE;
0008fc  e3a0b000          MOV      r11,#0
;;;393        BOOL ACKmessageParseFlag = FALSE;
000900  e3a00000          MOV      r0,#0
000904  e58d0010          STR      r0,[sp,#0x10]
;;;394        BOOL STXACKmessage = FALSE;
000908  e58d000c          STR      r0,[sp,#0xc]
;;;395        uint8_t originalSequenceNum = *currentSequenceNum;
00090c  e5d50000          LDRB     r0,[r5,#0]
000910  e58d0008          STR      r0,[sp,#8]
;;;396        uint8_t respons[] = {0x06,0x00};
000914  e28f0e2d          ADR      r0,|L1.3052|
000918  e5900000          LDR      r0,[r0,#0]
00091c  e58d0004          STR      r0,[sp,#4]
;;;397        uint16_t FramesNum;
;;;398        uint8_t IndexShift = 0;
000920  e3a06000          MOV      r6,#0
;;;399        CommunicationInterface* CreditCardInterface;
;;;400        CreditCardInterface = CommunicationGetInterface(0);
000924  e3a00000          MOV      r0,#0
000928  ebfffffe          BL       CommunicationGetInterface
00092c  e58d0000          STR      r0,[sp,#0]
;;;401        while(pollingFlag)
000930  ea0000bf          B        |L1.3124|
                  |L1.2356|
;;;402        {
;;;403            switch(currentState) 
000934  e357001d          CMP      r7,#0x1d
000938  308ff107          ADDCC    pc,pc,r7,LSL #2
00093c  ea0000b8          B        |L1.3108|
000940  ea00001b          B        |L1.2484|
000944  ea000026          B        |L1.2532|
000948  ea00002f          B        |L1.2572|
00094c  ea000038          B        |L1.2612|
000950  ea000041          B        |L1.2652|
000954  ea000042          B        |L1.2660|
000958  ea000043          B        |L1.2668|
00095c  ea000045          B        |L1.2680|
000960  ea000046          B        |L1.2688|
000964  ea000046          B        |L1.2692|
000968  ea000047          B        |L1.2700|
00096c  ea000048          B        |L1.2708|
000970  ea000049          B        |L1.2716|
000974  ea000049          B        |L1.2720|
000978  ea000049          B        |L1.2724|
00097c  ea00004a          B        |L1.2732|
000980  ea00004d          B        |L1.2748|
000984  ea00004e          B        |L1.2756|
000988  ea000055          B        |L1.2788|
00098c  ea000056          B        |L1.2796|
000990  ea000057          B        |L1.2804|
000994  ea000058          B        |L1.2812|
000998  ea00005a          B        |L1.2824|
00099c  ea000060          B        |L1.2852|
0009a0  ea000072          B        |L1.2928|
0009a4  ea000073          B        |L1.2936|
0009a8  ea000074          B        |L1.2944|
0009ac  ea000075          B        |L1.2952|
0009b0  ea00007c          B        |L1.2984|
                  |L1.2484|
;;;404            {
;;;405                case DECODER_S0_Start:
0009b4  e1a00000          MOV      r0,r0
;;;406                    if(ACKmessageParseFlag)
0009b8  e59d0010          LDR      r0,[sp,#0x10]
0009bc  e3500000          CMP      r0,#0
0009c0  0a000003          BEQ      |L1.2516|
;;;407                        currentState = Decoder_S0_Parse(buff[2]);
0009c4  e5d40002          LDRB     r0,[r4,#2]
0009c8  ebfffffe          BL       Decoder_S0_Parse
0009cc  e1a07000          MOV      r7,r0
0009d0  ea000002          B        |L1.2528|
                  |L1.2516|
;;;408                    else
;;;409                        currentState = Decoder_S0_Parse(buff[0]);
0009d4  e5d40000          LDRB     r0,[r4,#0]
0009d8  ebfffffe          BL       Decoder_S0_Parse
0009dc  e1a07000          MOV      r7,r0
                  |L1.2528|
;;;410                    break;
0009e0  ea000092          B        |L1.3120|
                  |L1.2532|
;;;411                case DECODER_S1_SOH:     
0009e4  e1a00000          MOV      r0,r0
;;;412                    //terninalPrintf("DECODER_S1_SOH , *currentSequenceNum = %d\r\n",*currentSequenceNum);
;;;413                    if(buff[1+IndexShift] == *currentSequenceNum)
0009e8  e2860001          ADD      r0,r6,#1
0009ec  e7d40000          LDRB     r0,[r4,r0]
0009f0  e5d51000          LDRB     r1,[r5,#0]
0009f4  e1500001          CMP      r0,r1
0009f8  1a000001          BNE      |L1.2564|
;;;414                        currentState = DECODER_S4_SOHsequenceNumber;
0009fc  e3a07004          MOV      r7,#4
000a00  ea000000          B        |L1.2568|
                  |L1.2564|
;;;415                    else
;;;416                        currentState = DECODER_S15_NACKout;
000a04  e3a0700f          MOV      r7,#0xf
                  |L1.2568|
;;;417                    break;    
000a08  ea000088          B        |L1.3120|
                  |L1.2572|
;;;418                case DECODER_S2_STX:   
000a0c  e1a00000          MOV      r0,r0
;;;419                    //terninalPrintf("DECODER_S2_STX\r\n");
;;;420                    if(buff[1+IndexShift] == *currentSequenceNum)
000a10  e2860001          ADD      r0,r6,#1
000a14  e7d40000          LDRB     r0,[r4,r0]
000a18  e5d51000          LDRB     r1,[r5,#0]
000a1c  e1500001          CMP      r0,r1
000a20  1a000001          BNE      |L1.2604|
;;;421                        currentState = DECODER_S6_STXsequenceNumber;
000a24  e3a07006          MOV      r7,#6
000a28  ea000000          B        |L1.2608|
                  |L1.2604|
;;;422                    else
;;;423                        currentState = DECODER_S15_NACKout;
000a2c  e3a0700f          MOV      r7,#0xf
                  |L1.2608|
;;;424                    break;            
000a30  ea00007e          B        |L1.3120|
                  |L1.2612|
;;;425                case DECODER_S3_EOT:
000a34  e1a00000          MOV      r0,r0
;;;426                    if(buff[1+IndexShift] == *currentSequenceNum)
000a38  e2860001          ADD      r0,r6,#1
000a3c  e7d40000          LDRB     r0,[r4,r0]
000a40  e5d51000          LDRB     r1,[r5,#0]
000a44  e1500001          CMP      r0,r1
000a48  1a000001          BNE      |L1.2644|
;;;427                        currentState = DECODER_S16_EOTsequenceNumber;
000a4c  e3a07010          MOV      r7,#0x10
000a50  ea000000          B        |L1.2648|
                  |L1.2644|
;;;428                    else
;;;429                        currentState = DECODER_S15_NACKout;
000a54  e3a0700f          MOV      r7,#0xf
                  |L1.2648|
;;;430                    break;            
000a58  ea000074          B        |L1.3120|
                  |L1.2652|
;;;431                    break;            
;;;432                case DECODER_S4_SOHsequenceNumber:
000a5c  e1a00000          MOV      r0,r0
;;;433                    //break;            
;;;434                case DECODER_S5_NumberOfFrames1:
000a60  e1a00000          MOV      r0,r0
                  |L1.2660|
;;;435                    currentState = DECODER_S27_NumberOfFrames2;
000a64  e3a0701b          MOV      r7,#0x1b
;;;436                    break;            
000a68  ea000070          B        |L1.3120|
                  |L1.2668|
;;;437                case DECODER_S6_STXsequenceNumber:
000a6c  e1a00000          MOV      r0,r0
;;;438                    //terninalPrintf("DECODER_S6_STXsequenceNumber\r\n");
;;;439                    currentState = DECODER_S8_IsDLE;
000a70  e3a07008          MOV      r7,#8
;;;440                    break;            
000a74  ea00006d          B        |L1.3120|
                  |L1.2680|
;;;441                case DECODER_S7_APDU:
000a78  e1a00000          MOV      r0,r0
;;;442                    //break;            
;;;443                case DECODER_S8_IsDLE:
000a7c  e1a00000          MOV      r0,r0
                  |L1.2688|
;;;444                    //break;            
;;;445                case DECODER_S9_IsETX:
000a80  e1a00000          MOV      r0,r0
                  |L1.2692|
;;;446                    currentState = DECODER_S11_EndOfFrame;
000a84  e3a0700b          MOV      r7,#0xb
;;;447                    break;            
000a88  ea000068          B        |L1.3120|
                  |L1.2700|
;;;448                case DECODER_S10_AddToBuffer:
000a8c  e1a00000          MOV      r0,r0
;;;449                    break;            
000a90  ea000066          B        |L1.3120|
                  |L1.2708|
;;;450                case DECODER_S11_EndOfFrame:
000a94  e1a00000          MOV      r0,r0
;;;451                    //break;            
;;;452                case DECODER_S12_CRC1:
000a98  e1a00000          MOV      r0,r0
                  |L1.2716|
;;;453                    //break;            
;;;454                case DECODER_S13_CRC2:
000a9c  e1a00000          MOV      r0,r0
                  |L1.2720|
;;;455                    //break;            
;;;456                case DECODER_S14_IsCrcOK:
000aa0  e1a00000          MOV      r0,r0
                  |L1.2724|
;;;457                    currentState = DECODER_S17_ACKout;
000aa4  e3a07011          MOV      r7,#0x11
;;;458                    break;            
000aa8  ea000060          B        |L1.3120|
                  |L1.2732|
;;;459                case DECODER_S15_NACKout:
000aac  e1a00000          MOV      r0,r0
;;;460                   // terninalPrintf("DECODER_S15_NACKout\r\n");
;;;461                    currentState = DECODER_S28_Finished;
000ab0  e3a0701c          MOV      r7,#0x1c
;;;462                    errorFlag = TRUE;
000ab4  e3a0b001          MOV      r11,#1
;;;463                    break;            
000ab8  ea00005c          B        |L1.3120|
                  |L1.2748|
;;;464                case DECODER_S16_EOTsequenceNumber:
000abc  e1a00000          MOV      r0,r0
;;;465                    //break;            
;;;466                case DECODER_S17_ACKout:
000ac0  e1a00000          MOV      r0,r0
                  |L1.2756|
;;;467                    respons[1] = *currentSequenceNum;
000ac4  e5d50000          LDRB     r0,[r5,#0]
000ac8  e5cd0005          STRB     r0,[sp,#5]
;;;468                    //terninalPrintf("currentSequenceNum = %d\r\n", currentSequenceNum);
;;;469                    CreditCardInterface->writeFunc(respons,sizeof(respons));
000acc  e59d0000          LDR      r0,[sp,#0]
000ad0  e3a01002          MOV      r1,#2
000ad4  e5902004          LDR      r2,[r0,#4]
000ad8  e28d0004          ADD      r0,sp,#4
000adc  e12fff32          BLX      r2
;;;470                    //break;            
;;;471                case DECODER_S18_IsComplete:
000ae0  e1a00000          MOV      r0,r0
                  |L1.2788|
;;;472                    currentState = DECODER_S28_Finished;
000ae4  e3a0701c          MOV      r7,#0x1c
;;;473                    break;            
000ae8  ea000050          B        |L1.3120|
                  |L1.2796|
;;;474                case DECODER_S19_APDUmessage:
000aec  e1a00000          MOV      r0,r0
;;;475                    break;            
000af0  ea00004e          B        |L1.3120|
                  |L1.2804|
;;;476                case DECODER_S20_IsSTXorSOH:
000af4  e1a00000          MOV      r0,r0
;;;477                    break;            
000af8  ea00004c          B        |L1.3120|
                  |L1.2812|
;;;478                case DECODER_S21_ACKin:
000afc  e1a00000          MOV      r0,r0
;;;479                    currentState = DECODER_S22_ACKsequenceNumber;
000b00  e3a07016          MOV      r7,#0x16
;;;480                   // if(buff[1+IndexShift] == currentSequenceNum)
;;;481                   //     currentState = DECODER_S22_ACKsequenceNumber;
;;;482                   // else
;;;483                   //     currentState = DECODER_S15_NACKout;
;;;484                    break;            
000b04  ea000049          B        |L1.3120|
                  |L1.2824|
;;;485                case DECODER_S22_ACKsequenceNumber:
000b08  e1a00000          MOV      r0,r0
;;;486                    if(ACKmessageFlag == TRUE)
000b0c  e3590001          CMP      r9,#1
000b10  1a000001          BNE      |L1.2844|
;;;487                        currentState = DECODER_S23_ACKmessage;
000b14  e3a07017          MOV      r7,#0x17
000b18  ea000000          B        |L1.2848|
                  |L1.2844|
;;;488                    else
;;;489                        currentState = DECODER_S28_Finished;
000b1c  e3a0701c          MOV      r7,#0x1c
                  |L1.2848|
;;;490                    break;            
000b20  ea000042          B        |L1.3120|
                  |L1.2852|
;;;491                case DECODER_S23_ACKmessage:
000b24  e1a00000          MOV      r0,r0
;;;492                    if( (buff[2] == 0x01) || (buff[2] == 0x02) )
000b28  e5d40002          LDRB     r0,[r4,#2]
000b2c  e3500001          CMP      r0,#1
000b30  0a000002          BEQ      |L1.2880|
000b34  e5d40002          LDRB     r0,[r4,#2]
000b38  e3500002          CMP      r0,#2
000b3c  1a000009          BNE      |L1.2920|
                  |L1.2880|
;;;493                    {
;;;494                        if(buff[2] == 0x02)
000b40  e5d40002          LDRB     r0,[r4,#2]
000b44  e3500002          CMP      r0,#2
000b48  1a000001          BNE      |L1.2900|
;;;495                            STXACKmessage = TRUE;
000b4c  e3a00001          MOV      r0,#1
000b50  e58d000c          STR      r0,[sp,#0xc]
                  |L1.2900|
;;;496                        ACKmessageParseFlag = TRUE;
000b54  e3a00001          MOV      r0,#1
000b58  e58d0010          STR      r0,[sp,#0x10]
;;;497                        IndexShift = 2;
000b5c  e3a06002          MOV      r6,#2
;;;498                        currentState = DECODER_S0_Start;
000b60  e3a07000          MOV      r7,#0
000b64  ea000000          B        |L1.2924|
                  |L1.2920|
;;;499                    }
;;;500                    else
;;;501                        currentState = DECODER_S28_Finished;
000b68  e3a0701c          MOV      r7,#0x1c
                  |L1.2924|
;;;502                    //DecodeStateMachine(buff,feedbackBuffSize,DECODER_S0_Start,&nextState,0,FALSE);
;;;503                    break;            
000b6c  ea00002f          B        |L1.3120|
                  |L1.2928|
;;;504                case DECODER_S24_NACKin:
000b70  e1a00000          MOV      r0,r0
;;;505                    break;            
000b74  ea00002d          B        |L1.3120|
                  |L1.2936|
;;;506                case DECODER_S25_NACKsequenceNumber:
000b78  e1a00000          MOV      r0,r0
;;;507                    break;            
000b7c  ea00002b          B        |L1.3120|
                  |L1.2944|
;;;508                case DECODER_S26_NACKmessage:
000b80  e1a00000          MOV      r0,r0
;;;509                    break;            
000b84  ea000029          B        |L1.3120|
                  |L1.2952|
;;;510                case DECODER_S27_NumberOfFrames2:
000b88  e1a00000          MOV      r0,r0
;;;511                    FramesNum = ( buff[3+IndexShift]<<8 ) | (buff[2+IndexShift]) ;
000b8c  e2860002          ADD      r0,r6,#2
000b90  e7d40000          LDRB     r0,[r4,r0]
000b94  e2861003          ADD      r1,r6,#3
000b98  e7d41001          LDRB     r1,[r4,r1]
000b9c  e1808401          ORR      r8,r0,r1,LSL #8
;;;512                    currentState = DECODER_S17_ACKout;
000ba0  e3a07011          MOV      r7,#0x11
;;;513                    break;            
000ba4  ea000021          B        |L1.3120|
                  |L1.2984|
;;;514                case DECODER_S28_Finished: 
000ba8  e1a00000          MOV      r0,r0
;;;515                    //terninalPrintf("DECODER_S28_Finished , *currentSequenceNum = %d\r\n",*currentSequenceNum);
;;;516                    if(( *currentSequenceNum >= (FramesNum + originalSequenceNum + 1)) || 
000bac  e5d51000          LDRB     r1,[r5,#0]
000bb0  e59d0008          LDR      r0,[sp,#8]
000bb4  e0800008          ADD      r0,r0,r8
000bb8  e2800001          ADD      r0,r0,#1
000bbc  e1510000          CMP      r1,r0
000bc0  aa000004          BGE      |L1.3032|
;;;517                        (STXACKmessage == TRUE)||
000bc4  e59d000c          LDR      r0,[sp,#0xc]
000bc8  e3500001          CMP      r0,#1
000bcc  0a000001          BEQ      |L1.3032|
;;;518                        (errorFlag == TRUE) )
000bd0  e35b0001          CMP      r11,#1
000bd4  1a000005          BNE      |L1.3056|
                  |L1.3032|
;;;519                    {
;;;520                        (*currentSequenceNum)++;
000bd8  e5d50000          LDRB     r0,[r5,#0]
000bdc  e2800001          ADD      r0,r0,#1
000be0  e5c50000          STRB     r0,[r5,#0]
;;;521                        pollingFlag = FALSE;
000be4  e3a0a000          MOV      r10,#0
000be8  ea00000c          B        |L1.3104|
                  |L1.3052|
000bec  0600              DCB      6,0
000bee  00                DCB      0
000bef  00                DCB      0
                  |L1.3056|
;;;522                    }
;;;523                    else
;;;524                    {
;;;525    
;;;526                        //if( *currentSequenceNum >= ( FramesNum + originalSequenceNum ))
;;;527                         //   readCreditCard(buff,300,&feedbackBuffSize, TRUE);
;;;528                       // else
;;;529                            readCreditCard(buff,300,&feedbackBuffSize, FALSE);
000bf0  e3a03000          MOV      r3,#0
000bf4  e28d2018          ADD      r2,sp,#0x18
000bf8  e3a01f4b          MOV      r1,#0x12c
000bfc  e1a00004          MOV      r0,r4
000c00  ebfffffe          BL       readCreditCard
;;;530    
;;;531                        //*currentSequenceNum = *currentSequenceNum + 1;
;;;532                        (*currentSequenceNum)++;
000c04  e5d50000          LDRB     r0,[r5,#0]
000c08  e2800001          ADD      r0,r0,#1
000c0c  e5c50000          STRB     r0,[r5,#0]
;;;533                        currentState = DECODER_S0_Start;
000c10  e3a07000          MOV      r7,#0
;;;534                        ACKmessageParseFlag = FALSE;
000c14  e3a00000          MOV      r0,#0
000c18  e58d0010          STR      r0,[sp,#0x10]
;;;535                        IndexShift = 0;
000c1c  e3a06000          MOV      r6,#0
                  |L1.3104|
;;;536                    }
;;;537                    break;        
000c20  ea000002          B        |L1.3120|
                  |L1.3108|
;;;538                default:
000c24  e1a00000          MOV      r0,r0
;;;539                    pollingFlag = FALSE;
000c28  e3a0a000          MOV      r10,#0
;;;540                    break;
000c2c  e1a00000          MOV      r0,r0
                  |L1.3120|
000c30  e1a00000          MOV      r0,r0                 ;410
                  |L1.3124|
000c34  e35a0000          CMP      r10,#0                ;401
000c38  1affff3d          BNE      |L1.2356|
;;;541            }
;;;542        }
;;;543        
;;;544        
;;;545    }
000c3c  e28dd024          ADD      sp,sp,#0x24
000c40  e8bd8ff0          POP      {r4-r11,pc}
;;;546    
                          ENDP

                  CADReadCardinit PROC
;;;547    
;;;548    void CADReadCardinit(uint8_t* pucBuf)
000c44  e92d43f8          PUSH     {r3-r9,lr}
;;;549    {
000c48  e1a04000          MOV      r4,r0
;;;550        uint8_t APDUBuf[] = {0x20,0x07,0x00,0x1C};
000c4c  e28f0f75          ADR      r0,|L1.3624|
000c50  e5900000          LDR      r0,[r0,#0]
000c54  e58d0000          STR      r0,[sp,#0]
;;;551        
;;;552        memset(tempbuff,0x00,sizeof(tempbuff));
000c58  e3a01f4b          MOV      r1,#0x12c
000c5c  e59f01c8          LDR      r0,|L1.3628|
000c60  ebfffffe          BL       __aeabi_memclr
;;;553        //uint8_t pucBuf[300];
;;;554        uint8_t buff[300]; //buff[30];
;;;555    
;;;556        int feedbackBuffSize;
;;;557        uint8_t currentState = 0;
000c64  e3a07000          MOV      r7,#0
;;;558        uint8_t nextState;
;;;559        uint8_t currentSequenceNum = 0;
000c68  e3a08000          MOV      r8,#0
;;;560        uint16_t tempcrc;
;;;561        INT32 reVal;
;;;562        BOOL breakFlag = FALSE;
000c6c  e3a09000          MOV      r9,#0
;;;563    
;;;564    
;;;565        
;;;566        
;;;567    
;;;568        pUartInterface = UartGetInterface(CREDIT_READER_UART);
000c70  e3a00006          MOV      r0,#6
000c74  ebfffffe          BL       UartGetInterface
000c78  e51f1a0c          LDR      r1,|L1.628|
000c7c  e5810000          STR      r0,[r1,#0]  ; pUartInterface
;;;569        CommunicationInterface* CreditCardInterface;
;;;570        CreditCardInterface = CommunicationGetInterface(0);
000c80  e3a00000          MOV      r0,#0
000c84  ebfffffe          BL       CommunicationGetInterface
000c88  e1a06000          MOV      r6,r0
;;;571        CreditCardInterface->initFunc();
000c8c  e5960000          LDR      r0,[r6,#0]
000c90  e12fff30          BLX      r0
;;;572        //CreditCardSetPower(TRUE);
;;;573        
;;;574        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<16)) | (0x0<<16));
000c94  e3a0020b          MOV      r0,#0xb0000000
000c98  e5900078          LDR      r0,[r0,#0x78]
000c9c  e3c0080f          BIC      r0,r0,#0xf0000
000ca0  e3a0120b          MOV      r1,#0xb0000000
000ca4  e5810078          STR      r0,[r1,#0x78]
;;;575        GPIO_OpenBit(GPIOB, BIT4, DIR_OUTPUT, NO_PULL_UP);
000ca8  e3a03000          MOV      r3,#0
000cac  e3a02001          MOV      r2,#1
000cb0  e3a01010          MOV      r1,#0x10
000cb4  e3a00040          MOV      r0,#0x40
000cb8  ebfffffe          BL       GPIO_OpenBit
;;;576        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<12)) | (0x0<<12));
000cbc  e3a0020b          MOV      r0,#0xb0000000
000cc0  e5900078          LDR      r0,[r0,#0x78]
000cc4  e3c00a0f          BIC      r0,r0,#0xf000
000cc8  e3a0120b          MOV      r1,#0xb0000000
000ccc  e5810078          STR      r0,[r1,#0x78]
;;;577        GPIO_OpenBit(GPIOB, BIT3, DIR_OUTPUT, NO_PULL_UP);
000cd0  e3a03000          MOV      r3,#0
000cd4  e3a02001          MOV      r2,#1
000cd8  e3a01008          MOV      r1,#8
000cdc  e3a00040          MOV      r0,#0x40
000ce0  ebfffffe          BL       GPIO_OpenBit
;;;578        GPIO_OpenBit(GPIOA, BIT14, DIR_OUTPUT, NO_PULL_UP);
000ce4  e3a03000          MOV      r3,#0
000ce8  e3a02001          MOV      r2,#1
000cec  e3a01901          MOV      r1,#0x4000
000cf0  e1a00003          MOV      r0,r3
000cf4  ebfffffe          BL       GPIO_OpenBit
;;;579    
;;;580        //GPIO_ClrBit(GPIOG, BIT6);
;;;581        //GPIO_SetBit(GPIOG, BIT6);
;;;582        GPIO_ClrBit(GPIOB, BIT3);
000cf8  e3a01008          MOV      r1,#8
000cfc  e3a00040          MOV      r0,#0x40
000d00  ebfffffe          BL       GPIO_ClrBit
;;;583        GPIO_SetBit(GPIOB, BIT4);
000d04  e3a01010          MOV      r1,#0x10
000d08  e3a00040          MOV      r0,#0x40
000d0c  ebfffffe          BL       GPIO_SetBit
;;;584        GPIO_SetBit(GPIOA, BIT14);
000d10  e3a01901          MOV      r1,#0x4000
000d14  e3a00000          MOV      r0,#0
000d18  ebfffffe          BL       GPIO_SetBit
;;;585    
;;;586        //GPIO_ClrBit(GPIOB, BIT3);
;;;587        vTaskDelay(3000/portTICK_RATE_MS);
000d1c  e3a00f4b          MOV      r0,#0x12c
000d20  ebfffffe          BL       vTaskDelay
;;;588        //vTaskDelay(5000/portTICK_RATE_MS);
;;;589    
;;;590        uartIoctl(10, 25, 0, 0);  //UART10FlushBuffer , UARTA=10 , UART_IOC_FLUSH_RX_BUFFER=25 
000d24  e3a03000          MOV      r3,#0
000d28  e1a02003          MOV      r2,r3
000d2c  e3a01019          MOV      r1,#0x19
000d30  e3a0000a          MOV      r0,#0xa
000d34  ebfffffe          BL       uartIoctl
;;;591    
;;;592        
;;;593        pucBuf[0] = 0x02;
000d38  e3a00002          MOV      r0,#2
000d3c  e5c40000          STRB     r0,[r4,#0]
;;;594        pucBuf[1] = 0x00;
000d40  e3a00000          MOV      r0,#0
000d44  e5c40001          STRB     r0,[r4,#1]
;;;595        memcpy(pucBuf+2,APDUBuf,sizeof(APDUBuf));
000d48  e3a02004          MOV      r2,#4
000d4c  e1a0100d          MOV      r1,sp
000d50  e2840002          ADD      r0,r4,#2
000d54  ebfffffe          BL       __aeabi_memcpy
;;;596        pucBuf[sizeof(APDUBuf)+2] = 0x03;
000d58  e3a00003          MOV      r0,#3
000d5c  e5c40006          STRB     r0,[r4,#6]
;;;597        
;;;598        // crc compute from Sequence Number to ETX(0x03) 
;;;599        // see PknPaymentKitInterface_PhysicalAndDataLinkLayers.pdf p.9
;;;600        tempcrc = crc16_ccitt(pucBuf+1,sizeof(APDUBuf)+2);  
000d60  e3a01006          MOV      r1,#6
000d64  e2840001          ADD      r0,r4,#1
000d68  ebfffffe          BL       crc16_ccitt
000d6c  e1a05000          MOV      r5,r0
;;;601        
;;;602        pucBuf[sizeof(APDUBuf)+3] = tempcrc >>8;
000d70  e1a00445          ASR      r0,r5,#8
000d74  e5c40007          STRB     r0,[r4,#7]
;;;603        pucBuf[sizeof(APDUBuf)+4] = tempcrc & 0x00FF;
000d78  e5c45008          STRB     r5,[r4,#8]
;;;604        
;;;605    }
000d7c  e8bd83f8          POP      {r3-r9,pc}
;;;606    
                          ENDP

                  CADReadCard PROC
;;;607    BOOL CADReadCard(uint8_t* pucBuf,uint8_t* currentSequenceNum)
000d80  e92d41f0          PUSH     {r4-r8,lr}
;;;608    {
000d84  e24dd018          SUB      sp,sp,#0x18
000d88  e1a05000          MOV      r5,r0
000d8c  e1a04001          MOV      r4,r1
;;;609        /*
;;;610        uint8_t APDUBuf[] = {0x20,0x07,0x00,0x1C};
;;;611        
;;;612     
;;;613        uint8_t pucBuf[300];
;;;614        uint8_t buff[300]; //buff[30];
;;;615    
;;;616        int feedbackBuffSize;
;;;617        uint8_t currentState = 0;
;;;618        uint8_t nextState;
;;;619        uint8_t currentSequenceNum = 0;
;;;620        uint16_t tempcrc;
;;;621        INT32 reVal;
;;;622        BOOL breakFlag = FALSE;
;;;623    
;;;624    
;;;625        
;;;626        
;;;627    
;;;628        
;;;629        CommunicationInterface* CreditCardInterface;
;;;630        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<16)) | (0x0<<16));
;;;631        GPIO_OpenBit(GPIOB, BIT4, DIR_OUTPUT, NO_PULL_UP);
;;;632        outpw(REG_SYS_GPB_MFPL,(inpw(REG_SYS_GPB_MFPL) & ~(0xF<<12)) | (0x0<<12));
;;;633        GPIO_OpenBit(GPIOB, BIT3, DIR_OUTPUT, NO_PULL_UP);
;;;634        GPIO_OpenBit(GPIOA, BIT14, DIR_OUTPUT, NO_PULL_UP);
;;;635    
;;;636    
;;;637        GPIO_ClrBit(GPIOB, BIT3);
;;;638        GPIO_SetBit(GPIOB, BIT4);
;;;639        GPIO_SetBit(GPIOA, BIT14);
;;;640        //GPIO_ClrBit(GPIOB, BIT3);
;;;641        vTaskDelay(3000/portTICK_RATE_MS);
;;;642        //vTaskDelay(5000/portTICK_RATE_MS);
;;;643        CreditCardInterface = CommunicationGetInterface(0);
;;;644        CreditCardInterface->initFunc();
;;;645        uartIoctl(10, 25, 0, 0);  //UART10FlushBuffer , UARTA=10 , UART_IOC_FLUSH_RX_BUFFER=25 
;;;646    
;;;647        
;;;648        pucBuf[0] = 0x02;
;;;649        pucBuf[1] = 0x00;
;;;650        memcpy(pucBuf+2,APDUBuf,sizeof(APDUBuf));
;;;651        pucBuf[sizeof(APDUBuf)+2] = 0x03;
;;;652        
;;;653        // crc compute from Sequence Number to ETX(0x03) 
;;;654        // see PknPaymentKitInterface_PhysicalAndDataLinkLayers.pdf p.9
;;;655        tempcrc = crc16_ccitt(pucBuf+1,sizeof(APDUBuf)+2);  
;;;656        
;;;657        pucBuf[sizeof(APDUBuf)+3] = tempcrc >>8;
;;;658        pucBuf[sizeof(APDUBuf)+4] = tempcrc & 0x00FF;
;;;659            
;;;660        vTaskDelay(2000/portTICK_RATE_MS);
;;;661        */
;;;662        uint8_t APDUBuf[] = {0x20,0x07,0x00,0x1C};
000d90  e28f0090          ADR      r0,|L1.3624|
000d94  e5900000          LDR      r0,[r0,#0]
000d98  e58d0014          STR      r0,[sp,#0x14]
;;;663            //uint8_t pucBuf[300];
;;;664        //uint8_t buff[300]; //buff[30];
;;;665    
;;;666        No3Data = tempbuff[3];
000d9c  e59f0088          LDR      r0,|L1.3628|
000da0  e5d00003          LDRB     r0,[r0,#3]  ; tempbuff
000da4  e59f1084          LDR      r1,|L1.3632|
000da8  e5c10000          STRB     r0,[r1,#0]  ; No3Data
;;;667        /*
;;;668        terninalPrintf("before read = ");
;;;669        for(int i=0;i<30;i++)
;;;670            terninalPrintf("%02x ",tempbuff[i]);
;;;671        terninalPrintf("\r\n");
;;;672        */
;;;673        int feedbackBuffSize;
;;;674        uint8_t currentState = 0;
000dac  e3a07000          MOV      r7,#0
;;;675        uint8_t nextState;
;;;676        //uint8_t currentSequenceNum = 0;
;;;677        uint16_t tempcrc;
;;;678        INT32 reVal;
;;;679        BOOL breakFlag = FALSE;
000db0  e3a08000          MOV      r8,#0
;;;680        CommunicationInterface* CreditCardInterface;
;;;681        CreditCardInterface = CommunicationGetInterface(0);
000db4  e3a00000          MOV      r0,#0
000db8  ebfffffe          BL       CommunicationGetInterface
000dbc  e1a06000          MOV      r6,r0
;;;682        //while(1)
;;;683        //{
;;;684            CreditCardInterface->writeFunc(pucBuf,sizeof(APDUBuf)+5);
000dc0  e3a01009          MOV      r1,#9
000dc4  e1a00005          MOV      r0,r5
000dc8  e5962004          LDR      r2,[r6,#4]
000dcc  e12fff32          BLX      r2
;;;685            readCreditCard(tempbuff,sizeof(tempbuff),&feedbackBuffSize, FALSE);
000dd0  e3a03000          MOV      r3,#0
000dd4  e28d2010          ADD      r2,sp,#0x10
000dd8  e3a01f4b          MOV      r1,#0x12c
000ddc  e59f0048          LDR      r0,|L1.3628|
000de0  ebfffffe          BL       readCreditCard
;;;686            DecodeStateMachine(tempbuff,feedbackBuffSize,DECODER_S0_Start,&nextState,currentSequenceNum,TRUE);
000de4  e3a00001          MOV      r0,#1
000de8  e58d0004          STR      r0,[sp,#4]
000dec  e58d4000          STR      r4,[sp,#0]
000df0  e28d300c          ADD      r3,sp,#0xc
000df4  e3a02000          MOV      r2,#0
000df8  e59f002c          LDR      r0,|L1.3628|
000dfc  e59d1010          LDR      r1,[sp,#0x10]
000e00  ebfffffe          BL       DecodeStateMachine
;;;687            
;;;688            //if(userResponse()=='q')
;;;689            //    break;
;;;690            
;;;691           // if(buff[7] == 0x05)
;;;692           // {
;;;693            //    BuzzerPlay(200, 500, 1, TRUE);
;;;694            //    break;
;;;695            //}
;;;696        //}
;;;697        
;;;698       // GPIO_SetBit(GPIOB, BIT3);
;;;699       // GPIO_ClrBit(GPIOB, BIT4);
;;;700       // GPIO_ClrBit(GPIOA, BIT14);
;;;701        /*
;;;702        terninalPrintf("after read =  ");
;;;703        for(int i=0;i<30;i++)
;;;704            terninalPrintf("%02x ",tempbuff[i]);
;;;705        terninalPrintf("\r\n");
;;;706        */
;;;707    
;;;708        
;;;709        if(tempbuff[7] == 0x05)
000e04  e59f0020          LDR      r0,|L1.3628|
000e08  e5d00007          LDRB     r0,[r0,#7]  ; tempbuff
000e0c  e3500005          CMP      r0,#5
000e10  1a000002          BNE      |L1.3616|
;;;710            return TRUE;
000e14  e3a00001          MOV      r0,#1
                  |L1.3608|
000e18  e28dd018          ADD      sp,sp,#0x18
;;;711        else
;;;712            return FALSE;
;;;713    }
000e1c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3616|
000e20  e3a00000          MOV      r0,#0                 ;712
000e24  eafffffb          B        |L1.3608|
                  |L1.3624|
000e28  200700            DCB      " \a",0
000e2b  1c                DCB      28
                  |L1.3628|
                          DCD      tempbuff
                  |L1.3632|
                          DCD      No3Data
                          ENDP

                  DetectCADConnect PROC
;;;714    
;;;715    BOOL DetectCADConnect(void)
000e34  e51f0010          LDR      r0,|L1.3628|
;;;716    {
;;;717        if(No3Data == tempbuff[3])
000e38  e5d00003          LDRB     r0,[r0,#3]  ; tempbuff
000e3c  e51f1014          LDR      r1,|L1.3632|
000e40  e5d11000          LDRB     r1,[r1,#0]  ; No3Data
000e44  e1500001          CMP      r0,r1
000e48  1a000001          BNE      |L1.3668|
;;;718            return FALSE;
000e4c  e3a00000          MOV      r0,#0
                  |L1.3664|
;;;719        else
;;;720            return TRUE;    
;;;721    }
000e50  e12fff1e          BX       lr
                  |L1.3668|
000e54  e3a00001          MOV      r0,#1                 ;720
000e58  eafffffc          B        |L1.3664|
;;;722    
                          ENDP

                  CADReadCardpoweron PROC
;;;723    void CADReadCardpoweron(void)
000e5c  e92d4010          PUSH     {r4,lr}
;;;724    {
;;;725        GPIO_ClrBit(GPIOB, BIT3);
000e60  e3a01008          MOV      r1,#8
000e64  e3a00040          MOV      r0,#0x40
000e68  ebfffffe          BL       GPIO_ClrBit
;;;726        GPIO_SetBit(GPIOB, BIT4);
000e6c  e3a01010          MOV      r1,#0x10
000e70  e3a00040          MOV      r0,#0x40
000e74  ebfffffe          BL       GPIO_SetBit
;;;727        GPIO_SetBit(GPIOA, BIT14);   
000e78  e3a01901          MOV      r1,#0x4000
000e7c  e3a00000          MOV      r0,#0
000e80  ebfffffe          BL       GPIO_SetBit
;;;728    }
000e84  e8bd8010          POP      {r4,pc}
;;;729    
                          ENDP

                  CADReadCardpoweroff PROC
;;;730    
;;;731    void CADReadCardpoweroff(void)
000e88  e92d4010          PUSH     {r4,lr}
;;;732    {
;;;733       // GPIO_SetBit(GPIOG, BIT6);
;;;734        //GPIO_ClrBit(GPIOG, BIT6);
;;;735        GPIO_SetBit(GPIOB, BIT3);
000e8c  e3a01008          MOV      r1,#8
000e90  e3a00040          MOV      r0,#0x40
000e94  ebfffffe          BL       GPIO_SetBit
;;;736        GPIO_ClrBit(GPIOB, BIT4);
000e98  e3a01010          MOV      r1,#0x10
000e9c  e3a00040          MOV      r0,#0x40
000ea0  ebfffffe          BL       GPIO_ClrBit
;;;737        GPIO_ClrBit(GPIOA, BIT14);    
000ea4  e3a01901          MOV      r1,#0x4000
000ea8  e3a00000          MOV      r0,#0
000eac  ebfffffe          BL       GPIO_ClrBit
;;;738    }
000eb0  e8bd8010          POP      {r4,pc}
;;;739    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  tempbuff
                          %        300

                          AREA ||.data||, DATA, ALIGN=2

                  pUartInterface
                          DCD      0x00000000
                  creditReaderBurninCounter
                          DCD      0x00000000
                  creditReaderBurninErrorCounter
                          DCD      0x00000000
                  No3Data
00000c  00                DCB      0x00
