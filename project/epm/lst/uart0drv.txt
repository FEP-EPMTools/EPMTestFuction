; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart0drv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart0drv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uart0drv.crf src\userdrv\uart0drv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  hwInit PROC
;;;37     /*-----------------------------------------*/
;;;38     static BOOL hwInit(UINT32 baudRate)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;39     {
000004  e1a05000          MOV      r5,r0
;;;40         int retval;
;;;41         outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000008  e3a0020b          MOV      r0,#0xb0000000
00000c  e5900218          LDR      r0,[r0,#0x218]
000010  e3800008          ORR      r0,r0,#8
000014  e3a0120b          MOV      r1,#0xb0000000
000018  e5810218          STR      r0,[r1,#0x218]
;;;42         
;;;43         // GPE 0, 1 //TX, RX
;;;44         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<0)) | (0x9<<0));
00001c  e3a0020b          MOV      r0,#0xb0000000
000020  e5900090          LDR      r0,[r0,#0x90]
000024  e3c0000f          BIC      r0,r0,#0xf
000028  e3800009          ORR      r0,r0,#9
00002c  e5810090          STR      r0,[r1,#0x90]
;;;45         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<4)) | (0x9<<4));
000030  e3a0020b          MOV      r0,#0xb0000000
000034  e5900090          LDR      r0,[r0,#0x90]
000038  e3c000f0          BIC      r0,r0,#0xf0
00003c  e3800090          ORR      r0,r0,#0x90
000040  e5810090          STR      r0,[r1,#0x90]
;;;46         
;;;47         
;;;48         /* configure UART */
;;;49         param.uFreq = 12000000;
000044  e59f01fc          LDR      r0,|L1.584|
000048  e59f11fc          LDR      r1,|L1.588|
00004c  e5810000          STR      r0,[r1,#0]  ; param
;;;50         param.uBaudRate = baudRate;
000050  e2810000          ADD      r0,r1,#0
000054  e5805004          STR      r5,[r0,#4]  ; param
;;;51         param.ucUartNo = UART0;
000058  e3a00000          MOV      r0,#0
00005c  e5c10008          STRB     r0,[r1,#8]  ; param
;;;52         param.ucDataBits = DATA_BITS_8;
000060  e3a00003          MOV      r0,#3
000064  e5c10009          STRB     r0,[r1,#9]  ; param
;;;53         param.ucStopBits = STOP_BITS_1;
000068  e3a00000          MOV      r0,#0
00006c  e5c1000a          STRB     r0,[r1,#0xa]  ; param
;;;54         param.ucParity = PARITY_NONE;
000070  e5c1000b          STRB     r0,[r1,#0xb]  ; param
;;;55         param.ucRxTriggerLevel = UART_FCR_RFITL_1BYTE;
000074  e5c1000c          STRB     r0,[r1,#0xc]  ; param
;;;56         retval = uartOpen(&param);
000078  e2810000          ADD      r0,r1,#0
00007c  ebfffffe          BL       uartOpen
000080  e1a04000          MOV      r4,r0
;;;57         if(retval != 0) 
000084  e3540000          CMP      r4,#0
000088  0a000005          BEQ      |L1.164|
;;;58         {
;;;59             terninalPrintf("hwInit Open UART error!\r\n");
00008c  e28f0f6f          ADR      r0,|L1.592|
000090  ebfffffe          BL       terninalPrintf
;;;60             sysprintf("hwInit Open UART error!\n");
000094  e28f0e1d          ADR      r0,|L1.620|
000098  ebfffffe          BL       sysprintf
;;;61             return FALSE;
00009c  e3a00000          MOV      r0,#0
                  |L1.160|
;;;62         }
;;;63     
;;;64         /* set TX interrupt mode */
;;;65         retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTPOLLMODE /*UARTINTMODE*/ , 0);
;;;66         //retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTINTMODE , 0);
;;;67         if (retval != 0) 
;;;68         {
;;;69             terninalPrintf("hwInit Set TX interrupt mode fail!\r\n");
;;;70             sysprintf("hwInit Set TX interrupt mode fail!\n");
;;;71             return FALSE;
;;;72         }
;;;73     
;;;74         /* set RX interrupt mode */
;;;75         retval = uartIoctl(param.ucUartNo, UART_IOC_SETRXMODE, UARTINTMODE, 0);
;;;76         if (retval != 0) 
;;;77         {
;;;78             terninalPrintf("hwInit Set RX interrupt mode fail!\r\n");
;;;79             sysprintf("hwInit Set RX interrupt mode fail!\n");
;;;80             return FALSE;
;;;81         }
;;;82     
;;;83         return TRUE;
;;;84     }
0000a0  e8bd8070          POP      {r4-r6,pc}
                  |L1.164|
0000a4  e59f11a0          LDR      r1,|L1.588|
0000a8  e5d10008          LDRB     r0,[r1,#8]            ;65  ; param
0000ac  e3a03000          MOV      r3,#0                 ;65
0000b0  e1a02003          MOV      r2,r3                 ;65
0000b4  e3a01001          MOV      r1,#1                 ;65
0000b8  ebfffffe          BL       uartIoctl
0000bc  e1a04000          MOV      r4,r0                 ;65
0000c0  e3540000          CMP      r4,#0                 ;67
0000c4  0a000005          BEQ      |L1.224|
0000c8  e28f0f6e          ADR      r0,|L1.648|
0000cc  ebfffffe          BL       terninalPrintf
0000d0  e28f0f76          ADR      r0,|L1.688|
0000d4  ebfffffe          BL       sysprintf
0000d8  e3a00000          MOV      r0,#0                 ;71
0000dc  eaffffef          B        |L1.160|
                  |L1.224|
0000e0  e59f1164          LDR      r1,|L1.588|
0000e4  e5d10008          LDRB     r0,[r1,#8]            ;75  ; param
0000e8  e3a03000          MOV      r3,#0                 ;75
0000ec  e3a02001          MOV      r2,#1                 ;75
0000f0  e3a01002          MOV      r1,#2                 ;75
0000f4  ebfffffe          BL       uartIoctl
0000f8  e1a04000          MOV      r4,r0                 ;75
0000fc  e3540000          CMP      r4,#0                 ;76
000100  0a000005          BEQ      |L1.284|
000104  e28f0f72          ADR      r0,|L1.724|
000108  ebfffffe          BL       terninalPrintf
00010c  e28f0f7a          ADR      r0,|L1.764|
000110  ebfffffe          BL       sysprintf
000114  e3a00000          MOV      r0,#0                 ;80
000118  eaffffe0          B        |L1.160|
                  |L1.284|
00011c  e3a00001          MOV      r0,#1                 ;83
000120  eaffffde          B        |L1.160|
;;;85     
                          ENDP

                  UART0DrvInit PROC
;;;88     /*-----------------------------------------*/
;;;89     BOOL UART0DrvInit(UINT32 baudRate)
000124  e92d4070          PUSH     {r4-r6,lr}
;;;90     {
000128  e1a05000          MOV      r5,r0
;;;91         int retval;
;;;92         //terninalPrintf("UART0DrvInit!!\r\n");
;;;93         sysprintf("UART0DrvInit!!\n");
00012c  e28f0f7b          ADR      r0,|L1.800|
000130  ebfffffe          BL       sysprintf
;;;94         retval = hwInit(baudRate);
000134  e1a00005          MOV      r0,r5
000138  ebfffffe          BL       hwInit
00013c  e1a04000          MOV      r4,r0
;;;95         //terninalPrintf("UART0DrvInit!!\r\n");
;;;96         return retval;
000140  e1a00004          MOV      r0,r4
;;;97     }
000144  e8bd8070          POP      {r4-r6,pc}
;;;98     INT32 UART0Write(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART0Write PROC
000148  e92d4070          PUSH     {r4-r6,lr}
;;;99     {
00014c  e1a04000          MOV      r4,r0
000150  e1a05001          MOV      r5,r1
;;;100        INT32  reVal;
;;;101        reVal = uartWrite(param.ucUartNo, pucBuf, uLen);
000154  e59f10f0          LDR      r1,|L1.588|
000158  e5d10008          LDRB     r0,[r1,#8]  ; param
00015c  e1a02005          MOV      r2,r5
000160  e1a01004          MOV      r1,r4
000164  ebfffffe          BL       uartWrite
000168  e1a06000          MOV      r6,r0
;;;102        return reVal;
00016c  e1a00006          MOV      r0,r6
;;;103    }
000170  e8bd8070          POP      {r4-r6,pc}
;;;104    INT32 UART0Read(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART0Read PROC
000174  e92d4070          PUSH     {r4-r6,lr}
;;;105    {
000178  e1a04000          MOV      r4,r0
00017c  e1a05001          MOV      r5,r1
;;;106        return uartRead(param.ucUartNo, pucBuf, uLen);
000180  e59f10c4          LDR      r1,|L1.588|
000184  e5d10008          LDRB     r0,[r1,#8]  ; param
000188  e1a02005          MOV      r2,r5
00018c  e1a01004          MOV      r1,r4
000190  ebfffffe          BL       uartRead
;;;107    }
000194  e8bd8070          POP      {r4-r6,pc}
;;;108    BaseType_t UART0ReadWait(TickType_t time)
                          ENDP

                  UART0ReadWait PROC
000198  e92d4010          PUSH     {r4,lr}
;;;109    {
00019c  e1a04000          MOV      r4,r0
;;;110        return  uartWaitReadEvent(param.ucUartNo, time);
0001a0  e59f10a4          LDR      r1,|L1.588|
0001a4  e5d10008          LDRB     r0,[r1,#8]  ; param
0001a8  e1a01004          MOV      r1,r4
0001ac  ebfffffe          BL       uartWaitReadEvent
;;;111    }
0001b0  e8bd8010          POP      {r4,pc}
;;;112    
                          ENDP

                  UART0SetPower PROC
;;;113    BOOL UART0SetPower(BOOL flag)
0001b4  e1a01000          MOV      r1,r0
;;;114    {
;;;115        if(flag)
;;;116        {         
;;;117            
;;;118        }
;;;119        else
;;;120        {
;;;121           
;;;122                
;;;123        }
;;;124        
;;;125        return FALSE;
0001b8  e3a00000          MOV      r0,#0
;;;126    }
0001bc  e12fff1e          BX       lr
;;;127    BOOL UART0SetRS232Power(BOOL flag)
                          ENDP

                  UART0SetRS232Power PROC
0001c0  e1a01000          MOV      r1,r0
;;;128    {
;;;129        if(flag)
0001c4  e3510000          CMP      r1,#0
0001c8  0a00000f          BEQ      |L1.524|
;;;130        {         
;;;131            // GPE 0, 1 //TX, RX
;;;132            outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<0)) | (0x9<<0));
0001cc  e3a0020b          MOV      r0,#0xb0000000
0001d0  e5900090          LDR      r0,[r0,#0x90]
0001d4  e3c0000f          BIC      r0,r0,#0xf
0001d8  e3800009          ORR      r0,r0,#9
0001dc  e3a0220b          MOV      r2,#0xb0000000
0001e0  e5820090          STR      r0,[r2,#0x90]
;;;133            outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<4)) | (0x9<<4));
0001e4  e3a0020b          MOV      r0,#0xb0000000
0001e8  e5900090          LDR      r0,[r0,#0x90]
0001ec  e3c000f0          BIC      r0,r0,#0xf0
0001f0  e3800090          ORR      r0,r0,#0x90
0001f4  e5820090          STR      r0,[r2,#0x90]
;;;134            outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<16)) | (0x1<<16)); 
0001f8  e3a0020b          MOV      r0,#0xb0000000
0001fc  e5900218          LDR      r0,[r0,#0x218]
000200  e3800801          ORR      r0,r0,#0x10000
000204  e5820218          STR      r0,[r2,#0x218]
000208  ea00000c          B        |L1.576|
                  |L1.524|
;;;135        }
;;;136        else
;;;137        {
;;;138            outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<16)) | (0x0<<16));   
00020c  e3a0020b          MOV      r0,#0xb0000000
000210  e5900218          LDR      r0,[r0,#0x218]
000214  e3c00801          BIC      r0,r0,#0x10000
000218  e3a0220b          MOV      r2,#0xb0000000
00021c  e5820218          STR      r0,[r2,#0x218]
;;;139            // GPE 0, 1 //TX, RX
;;;140            outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<0)) | (0x0<<0));
000220  e3a0020b          MOV      r0,#0xb0000000
000224  e5900090          LDR      r0,[r0,#0x90]
000228  e3c0000f          BIC      r0,r0,#0xf
00022c  e5820090          STR      r0,[r2,#0x90]
;;;141            outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xF<<4)) | (0x0<<4)); 
000230  e3a0020b          MOV      r0,#0xb0000000
000234  e5900090          LDR      r0,[r0,#0x90]
000238  e3c000f0          BIC      r0,r0,#0xf0
00023c  e5820090          STR      r0,[r2,#0x90]
                  |L1.576|
;;;142        }
;;;143        return TRUE;
000240  e3a00001          MOV      r0,#1
;;;144    }
000244  e12fff1e          BX       lr
                  |L1.584|
                          DCD      0x00b71b00
                  |L1.588|
                          DCD      param
                  |L1.592|
000250  6877496e          DCB      "hwInit Open UART error!\r\n",0
000254  6974204f
000258  70656e20
00025c  55415254
000260  20657272
000264  6f72210d
000268  0a00    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L1.620|
00026c  6877496e          DCB      "hwInit Open UART error!\n",0
000270  6974204f
000274  70656e20
000278  55415254
00027c  20657272
000280  6f72210a
000284  00      
000285  00                DCB      0
000286  00                DCB      0
000287  00                DCB      0
                  |L1.648|
000288  6877496e          DCB      "hwInit Set TX interrupt mode fail!\r\n",0
00028c  69742053
000290  65742054
000294  5820696e
000298  74657272
00029c  75707420
0002a0  6d6f6465
0002a4  20666169
0002a8  6c210d0a
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L1.688|
0002b0  6877496e          DCB      "hwInit Set TX interrupt mode fail!\n",0
0002b4  69742053
0002b8  65742054
0002bc  5820696e
0002c0  74657272
0002c4  75707420
0002c8  6d6f6465
0002cc  20666169
0002d0  6c210a00
                  |L1.724|
0002d4  6877496e          DCB      "hwInit Set RX interrupt mode fail!\r\n",0
0002d8  69742053
0002dc  65742052
0002e0  5820696e
0002e4  74657272
0002e8  75707420
0002ec  6d6f6465
0002f0  20666169
0002f4  6c210d0a
0002f8  00      
0002f9  00                DCB      0
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L1.764|
0002fc  6877496e          DCB      "hwInit Set RX interrupt mode fail!\n",0
000300  69742053
000304  65742052
000308  5820696e
00030c  74657272
000310  75707420
000314  6d6f6465
000318  20666169
00031c  6c210a00
                  |L1.800|
000320  55415254          DCB      "UART0DrvInit!!\n",0
000324  30447276
000328  496e6974
00032c  21210a00
                          ENDP

                  UART0Ioctl PROC
;;;145    INT UART0Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
000330  e92d4070          PUSH     {r4-r6,lr}
;;;146    {
000334  e1a04000          MOV      r4,r0
000338  e1a05001          MOV      r5,r1
00033c  e1a06002          MOV      r6,r2
;;;147        return uartIoctl(param.ucUartNo, uCmd, uArg0, uArg1);
000340  e51f10fc          LDR      r1,|L1.588|
000344  e5d10008          LDRB     r0,[r1,#8]  ; param
000348  e1a03006          MOV      r3,r6
00034c  e1a02005          MOV      r2,r5
000350  e1a01004          MOV      r1,r4
000354  ebfffffe          BL       uartIoctl
;;;148    }
000358  e8bd8070          POP      {r4-r6,pc}
;;;149    
                          ENDP

                  UART0SetRTS PROC
;;;150    void UART0SetRTS(BOOL flag)
00035c  e92d4010          PUSH     {r4,lr}
;;;151    {
000360  e1a04000          MOV      r4,r0
;;;152        if(flag)
000364  e3540000          CMP      r4,#0
000368  0a000006          BEQ      |L1.904|
;;;153            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_LOW, 0);
00036c  e51f1128          LDR      r1,|L1.588|
000370  e5d10008          LDRB     r0,[r1,#8]  ; param
000374  e3a03000          MOV      r3,#0
000378  e1a02003          MOV      r2,r3
00037c  e3a01010          MOV      r1,#0x10
000380  ebfffffe          BL       uartIoctl
000384  ea000005          B        |L1.928|
                  |L1.904|
;;;154        else
;;;155            uartIoctl(param.ucUartNo, UART_IOC_SETRTSSIGNAL, UART_RTS_HIGH, 0);
000388  e51f1144          LDR      r1,|L1.588|
00038c  e5d10008          LDRB     r0,[r1,#8]  ; param
000390  e3a03000          MOV      r3,#0
000394  e3a02001          MOV      r2,#1
000398  e3a01010          MOV      r1,#0x10
00039c  ebfffffe          BL       uartIoctl
                  |L1.928|
;;;156    }
0003a0  e8bd8010          POP      {r4,pc}
;;;157    
                          ENDP

                  UART0FlushBuffer PROC
;;;158    void UART0FlushBuffer(void)
0003a4  e92d4010          PUSH     {r4,lr}
;;;159    {
;;;160        //sysprintf(" --> CardFlushBuffer\n");
;;;161        //if (pUartInterface->ioctlFunc(UART_IOC_FLUSH_TX_BUFFER, 0, 0) != 0) {
;;;162       //     sysprintf("Set TX Flush fail!\n");
;;;163        //    return;
;;;164        //}
;;;165        if (UART0Ioctl(UART_IOC_FLUSH_RX_BUFFER, 0, 0) != 0) {
0003a8  e3a02000          MOV      r2,#0
0003ac  e1a01002          MOV      r1,r2
0003b0  e3a00019          MOV      r0,#0x19
0003b4  ebfffffe          BL       UART0Ioctl
0003b8  e3500000          CMP      r0,#0
0003bc  0a000002          BEQ      |L1.972|
;;;166            sysprintf("Set RX Flush fail!\n");
0003c0  e28f000c          ADR      r0,|L1.980|
0003c4  ebfffffe          BL       sysprintf
                  |L1.968|
;;;167            return;
;;;168        }
;;;169    }
0003c8  e8bd8010          POP      {r4,pc}
                  |L1.972|
0003cc  e1a00000          MOV      r0,r0
0003d0  eafffffc          B        |L1.968|
;;;170        
                          ENDP

                  |L1.980|
0003d4  53657420          DCB      "Set RX Flush fail!\n",0
0003d8  52582046
0003dc  6c757368
0003e0  20666169
0003e4  6c210a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param
                          %        16
