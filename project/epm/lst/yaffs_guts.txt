; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\yaffs_guts.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\yaffs_guts.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\yaffs_guts.crf ..\..\common\src\BSP\ThirdParty\yaffs2\yaffs_guts.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  list_add PROC
;;;52     /* Add an element to a list */
;;;53     static __inline void list_add(struct list_head *new_entry,
000000  e5912000          LDR      r2,[r1,#0]
;;;54     				struct list_head *list)
;;;55     {
;;;56     	struct list_head *list_next = list->next;
;;;57     
;;;58     	list->next = new_entry;
000004  e5810000          STR      r0,[r1,#0]
;;;59     	new_entry->prev = list;
000008  e5801004          STR      r1,[r0,#4]
;;;60     	new_entry->next = list_next;
00000c  e5802000          STR      r2,[r0,#0]
;;;61     	list_next->prev = new_entry;
000010  e5820004          STR      r0,[r2,#4]
;;;62     
;;;63     }
000014  e12fff1e          BX       lr
;;;64     
                          ENDP

                  list_del_init PROC
;;;89     
;;;90     static __inline void list_del_init(struct list_head *entry)
000018  e1a00000          MOV      r0,r0
;;;91     {
;;;92     	list_del(entry);
00001c  e5901000          LDR      r1,[r0,#0]
000020  e5902004          LDR      r2,[r0,#4]
000024  e5812004          STR      r2,[r1,#4]
000028  e5821000          STR      r1,[r2,#0]
00002c  e1a00000          MOV      r0,r0
;;;93     	entry->next = entry->prev = entry;
000030  e5800004          STR      r0,[r0,#4]
000034  e5800000          STR      r0,[r0,#0]
;;;94     }
000038  e12fff1e          BX       lr
;;;95     
                          ENDP

                  yaffs_get_block_info PROC
;;;23     /* Function to manipulate block info */
;;;24     static __inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
00003c  e92d4070          PUSH     {r4-r6,lr}
;;;25     							      *dev, int blk)
;;;26     {
000040  e1a04000          MOV      r4,r0
000044  e1a05001          MOV      r5,r1
;;;27     	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
000048  e59400d0          LDR      r0,[r4,#0xd0]
00004c  e1500005          CMP      r0,r5
000050  ca000002          BGT      |L1.96|
000054  e59400d4          LDR      r0,[r4,#0xd4]
000058  e1500005          CMP      r0,r5
00005c  aa00000c          BGE      |L1.148|
                  |L1.96|
;;;28     		yaffs_trace(YAFFS_TRACE_ERROR,
000060  e59f01d0          LDR      r0,|L1.568|
000064  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000068  e3100101          TST      r0,#0x40000000
00006c  0a000002          BEQ      |L1.124|
000070  e1a01005          MOV      r1,r5
000074  e28f0d07          ADR      r0,|L1.572|
000078  ebfffffe          BL       sysprintf
                  |L1.124|
;;;29     			"**>> yaffs: get_block_info block %d is not valid",
;;;30     			blk);
;;;31     		BUG();
00007c  e1a00000          MOV      r0,r0
000080  e3a0201f          MOV      r2,#0x1f
000084  e28f1f7b          ADR      r1,|L1.632|
000088  e28f0f89          ADR      r0,|L1.692|
00008c  ebfffffe          BL       sysprintf
000090  e1a00000          MOV      r0,r0
                  |L1.148|
;;;32     	}
;;;33     	return &dev->block_info[blk - dev->internal_start_block];
000094  e59410d0          LDR      r1,[r4,#0xd0]
000098  e0451001          SUB      r1,r5,r1
00009c  e5940118          LDR      r0,[r4,#0x118]
0000a0  e0800181          ADD      r0,r0,r1,LSL #3
;;;34     }
0000a4  e8bd8070          POP      {r4-r6,pc}
;;;35     
                          ENDP

                  yaffs_addr_to_chunk PROC
;;;48     
;;;49     void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
0000a8  e92d5ffc          PUSH     {r2-r12,lr}
;;;50     				int *chunk_out, u32 *offset_out)
;;;51     {
0000ac  e1a06000          MOV      r6,r0
0000b0  e1a04002          MOV      r4,r2
0000b4  e1a05003          MOV      r5,r3
0000b8  e59db030          LDR      r11,[sp,#0x30]
;;;52     	int chunk;
;;;53     	u32 offset;
;;;54     
;;;55     	chunk = (u32) (addr >> dev->chunk_shift);
0000bc  e1a09004          MOV      r9,r4
0000c0  e1a0a005          MOV      r10,r5
0000c4  e1a00009          MOV      r0,r9
0000c8  e1a0100a          MOV      r1,r10
0000cc  e59620b8          LDR      r2,[r6,#0xb8]
0000d0  ebfffffe          BL       __aeabi_lasr
0000d4  e1a08000          MOV      r8,r0
;;;56     
;;;57     	if (dev->chunk_div == 1) {
0000d8  e59600bc          LDR      r0,[r6,#0xbc]
0000dc  e3500001          CMP      r0,#1
0000e0  1a000002          BNE      |L1.240|
;;;58     		/* easy power of 2 case */
;;;59     		offset = (u32) (addr & dev->chunk_mask);
0000e4  e59600c0          LDR      r0,[r6,#0xc0]
0000e8  e0007004          AND      r7,r0,r4
0000ec  ea000009          B        |L1.280|
                  |L1.240|
;;;60     	} else {
;;;61     		/* Non power-of-2 case */
;;;62     
;;;63     		loff_t chunk_base;
;;;64     
;;;65     		chunk /= dev->chunk_div;
0000f0  e1a00008          MOV      r0,r8
0000f4  e59610bc          LDR      r1,[r6,#0xbc]
0000f8  ebfffffe          BL       __aeabi_uidivmod
0000fc  e1a08000          MOV      r8,r0
;;;66     
;;;67     		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
000100  e59600a4          LDR      r0,[r6,#0xa4]
000104  e0c10098          SMULL    r0,r1,r8,r0
000108  e58d0000          STR      r0,[sp,#0]
;;;68     		offset = (u32) (addr - chunk_base);
00010c  e59d0000          LDR      r0,[sp,#0]
000110  e0547000          SUBS     r7,r4,r0
;;;69     	}
000114  e1a00000          MOV      r0,r0
                  |L1.280|
;;;70     
;;;71     	*chunk_out = chunk;
000118  e58b8000          STR      r8,[r11,#0]
;;;72     	*offset_out = offset;
00011c  e59d0034          LDR      r0,[sp,#0x34]
000120  e5807000          STR      r7,[r0,#0]
;;;73     }
000124  e8bd9ffc          POP      {r2-r12,pc}
;;;74     
                          ENDP

                  yaffs_init_tmp_buffers PROC
;;;124    
;;;125    static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
000128  e92d4070          PUSH     {r4-r6,lr}
;;;126    {
00012c  e1a04000          MOV      r4,r0
;;;127    	int i;
;;;128    	u8 *buf = (u8 *) 1;
000130  e3a06001          MOV      r6,#1
;;;129    
;;;130    	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
000134  e3a01030          MOV      r1,#0x30
000138  e2840edb          ADD      r0,r4,#0xdb0
00013c  ebfffffe          BL       __aeabi_memclr4
;;;131    
;;;132    	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
000140  e3a05000          MOV      r5,#0
000144  ea000009          B        |L1.368|
                  |L1.328|
;;;133    		dev->temp_buffer[i].in_use = 0;
000148  e3a00000          MOV      r0,#0
00014c  e2841edb          ADD      r1,r4,#0xdb0
000150  e0811185          ADD      r1,r1,r5,LSL #3
000154  e5810004          STR      r0,[r1,#4]
;;;134    // 		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
;;;135    		buf = yaffs_malloc(dev->param.total_bytes_per_chunk);
000158  e5940008          LDR      r0,[r4,#8]
00015c  ebfffffe          BL       yaffs_malloc
000160  e1a06000          MOV      r6,r0
;;;136    		dev->temp_buffer[i].buffer = buf;
000164  e2840edb          ADD      r0,r4,#0xdb0
000168  e7806185          STR      r6,[r0,r5,LSL #3]
00016c  e2855001          ADD      r5,r5,#1              ;132
                  |L1.368|
000170  e3560000          CMP      r6,#0                 ;132
000174  0a000001          BEQ      |L1.384|
000178  e3550006          CMP      r5,#6                 ;132
00017c  bafffff1          BLT      |L1.328|
                  |L1.384|
;;;137    	}
;;;138    
;;;139    	return buf ? YAFFS_OK : YAFFS_FAIL;
000180  e3560000          CMP      r6,#0
000184  0a000001          BEQ      |L1.400|
000188  e3a00001          MOV      r0,#1
                  |L1.396|
;;;140    }
00018c  e8bd8070          POP      {r4-r6,pc}
                  |L1.400|
000190  e3a00000          MOV      r0,#0                 ;139
000194  eafffffc          B        |L1.396|
;;;141    
                          ENDP

                  yaffs_get_temp_buffer PROC
;;;142    u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
000198  e92d4070          PUSH     {r4-r6,lr}
;;;143    {
00019c  e1a04000          MOV      r4,r0
;;;144    	int i;
;;;145    
;;;146    	dev->temp_in_use++;
0001a0  e5940de4          LDR      r0,[r4,#0xde4]
0001a4  e2800001          ADD      r0,r0,#1
0001a8  e5840de4          STR      r0,[r4,#0xde4]
;;;147    	if (dev->temp_in_use > dev->max_temp)
0001ac  e5940de4          LDR      r0,[r4,#0xde4]
0001b0  e5941de0          LDR      r1,[r4,#0xde0]
0001b4  e1500001          CMP      r0,r1
0001b8  da000001          BLE      |L1.452|
;;;148    		dev->max_temp = dev->temp_in_use;
0001bc  e5940de4          LDR      r0,[r4,#0xde4]
0001c0  e5840de0          STR      r0,[r4,#0xde0]
                  |L1.452|
;;;149    
;;;150    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
0001c4  e3a05000          MOV      r5,#0
0001c8  ea00000c          B        |L1.512|
                  |L1.460|
;;;151    		if (dev->temp_buffer[i].in_use == 0) {
0001cc  e2840edb          ADD      r0,r4,#0xdb0
0001d0  e0800185          ADD      r0,r0,r5,LSL #3
0001d4  e5900004          LDR      r0,[r0,#4]
0001d8  e3500000          CMP      r0,#0
0001dc  1a000006          BNE      |L1.508|
;;;152    			dev->temp_buffer[i].in_use = 1;
0001e0  e3a00001          MOV      r0,#1
0001e4  e2841edb          ADD      r1,r4,#0xdb0
0001e8  e0811185          ADD      r1,r1,r5,LSL #3
0001ec  e5810004          STR      r0,[r1,#4]
;;;153    			return dev->temp_buffer[i].buffer;
0001f0  e2840edb          ADD      r0,r4,#0xdb0
0001f4  e7900185          LDR      r0,[r0,r5,LSL #3]
                  |L1.504|
;;;154    		}
;;;155    	}
;;;156    
;;;157    	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
;;;158    	/*
;;;159    	 * If we got here then we have to allocate an unmanaged one
;;;160    	 * This is not good.
;;;161    	 */
;;;162    
;;;163    	dev->unmanaged_buffer_allocs++;
;;;164    // 	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
;;;165    	return (u8 *)yaffs_malloc(dev->data_bytes_per_chunk);
;;;166    
;;;167    }
0001f8  e8bd8070          POP      {r4-r6,pc}
                  |L1.508|
0001fc  e2855001          ADD      r5,r5,#1              ;150
                  |L1.512|
000200  e3550006          CMP      r5,#6                 ;150
000204  bafffff0          BLT      |L1.460|
000208  e59f0028          LDR      r0,|L1.568|
00020c  e1d000b0          LDRH     r0,[r0,#0]            ;157  ; yaffs_trace_mask
000210  e3100b01          TST      r0,#0x400             ;157
000214  0a000001          BEQ      |L1.544|
000218  e28f00ac          ADR      r0,|L1.716|
00021c  ebfffffe          BL       sysprintf
                  |L1.544|
000220  e5940de8          LDR      r0,[r4,#0xde8]        ;163
000224  e2800001          ADD      r0,r0,#1              ;163
000228  e5840de8          STR      r0,[r4,#0xde8]        ;163
00022c  e59400a4          LDR      r0,[r4,#0xa4]         ;165
000230  ebfffffe          BL       yaffs_malloc
000234  eaffffef          B        |L1.504|
                  |L1.568|
                          DCD      yaffs_trace_mask
                  |L1.572|
00023c  79616666          DCB      "yaffs: **>> yaffs: get_block_info block %d is not valid"
000240  733a202a
000244  2a3e3e20
000248  79616666
00024c  733a2067
000250  65745f62
000254  6c6f636b
000258  5f696e66
00025c  6f20626c
000260  6f636b20
000264  25642069
000268  73206e6f
00026c  74207661
000270  6c6964  
000273  0a00              DCB      "\n",0
000275  00                DCB      0
000276  00                DCB      0
000277  00                DCB      0
                  |L1.632|
000278  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\yaffs_get"
00027c  2e5c636f
000280  6d6d6f6e
000284  5c737263
000288  5c425350
00028c  5c546869
000290  72645061
000294  7274795c
000298  79616666
00029c  73325c79
0002a0  61666673
0002a4  5f676574
0002a8  626c6f63          DCB      "blockinfo.h",0
0002ac  6b696e66
0002b0  6f2e6800
                  |L1.692|
0002b4  552d426f          DCB      "U-Boot BUG at %s:%d!\n",0
0002b8  6f742042
0002bc  55472061
0002c0  74202573
0002c4  3a256421
0002c8  0a00    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L1.716|
0002cc  79616666          DCB      "yaffs: Out of temp buffers\n",0
0002d0  733a204f
0002d4  7574206f
0002d8  66207465
0002dc  6d702062
0002e0  75666665
0002e4  72730a00
                          ENDP

                  yaffs_release_temp_buffer PROC
;;;168    
;;;169    void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
0002e8  e92d4070          PUSH     {r4-r6,lr}
;;;170    {
0002ec  e1a04000          MOV      r4,r0
0002f0  e1a05001          MOV      r5,r1
;;;171    	int i;
;;;172    
;;;173    	dev->temp_in_use--;
0002f4  e5940de4          LDR      r0,[r4,#0xde4]
0002f8  e2400001          SUB      r0,r0,#1
0002fc  e5840de4          STR      r0,[r4,#0xde4]
;;;174    
;;;175    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
000300  e3a06000          MOV      r6,#0
000304  ea000009          B        |L1.816|
                  |L1.776|
;;;176    		if (dev->temp_buffer[i].buffer == buffer) {
000308  e2840edb          ADD      r0,r4,#0xdb0
00030c  e7900186          LDR      r0,[r0,r6,LSL #3]
000310  e1500005          CMP      r0,r5
000314  1a000004          BNE      |L1.812|
;;;177    			dev->temp_buffer[i].in_use = 0;
000318  e3a00000          MOV      r0,#0
00031c  e2841edb          ADD      r1,r4,#0xdb0
000320  e0811186          ADD      r1,r1,r6,LSL #3
000324  e5810004          STR      r0,[r1,#4]
                  |L1.808|
;;;178    			return;
;;;179    		}
;;;180    	}
;;;181    
;;;182    	if (buffer) {
;;;183    		/* assume it is an unmanaged one. */
;;;184    		yaffs_trace(YAFFS_TRACE_BUFFERS,
;;;185    			"Releasing unmanaged temp buffer");
;;;186    		yaffs_free(buffer);
;;;187    		dev->unmanaged_buffer_deallocs++;
;;;188    	}
;;;189    
;;;190    }
000328  e8bd8070          POP      {r4-r6,pc}
                  |L1.812|
00032c  e2866001          ADD      r6,r6,#1              ;175
                  |L1.816|
000330  e3560006          CMP      r6,#6                 ;175
000334  bafffff3          BLT      |L1.776|
000338  e3550000          CMP      r5,#0                 ;182
00033c  0a00000a          BEQ      |L1.876|
000340  e51f0110          LDR      r0,|L1.568|
000344  e1d000b0          LDRH     r0,[r0,#0]            ;184  ; yaffs_trace_mask
000348  e3100b01          TST      r0,#0x400             ;184
00034c  0a000001          BEQ      |L1.856|
000350  e28f0fc2          ADR      r0,|L1.1632|
000354  ebfffffe          BL       sysprintf
                  |L1.856|
000358  e1a00005          MOV      r0,r5                 ;186
00035c  ebfffffe          BL       yaffs_free
000360  e5940dec          LDR      r0,[r4,#0xdec]        ;187
000364  e2800001          ADD      r0,r0,#1              ;187
000368  e5840dec          STR      r0,[r4,#0xdec]        ;187
                  |L1.876|
00036c  e1a00000          MOV      r0,r0
000370  eaffffec          B        |L1.808|
;;;191    
                          ENDP

                  yaffs_is_managed_tmp_buffer PROC
;;;194     */
;;;195    int yaffs_is_managed_tmp_buffer(struct yaffs_dev *dev, const u8 *buffer)
000374  e92d4070          PUSH     {r4-r6,lr}
;;;196    {
000378  e1a05000          MOV      r5,r0
00037c  e1a06001          MOV      r6,r1
;;;197    	int i;
;;;198    
;;;199    	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
000380  e3a04000          MOV      r4,#0
000384  ea000006          B        |L1.932|
                  |L1.904|
;;;200    		if (dev->temp_buffer[i].buffer == buffer)
000388  e2850edb          ADD      r0,r5,#0xdb0
00038c  e7900184          LDR      r0,[r0,r4,LSL #3]
000390  e1500006          CMP      r0,r6
000394  1a000001          BNE      |L1.928|
;;;201    			return 1;
000398  e3a00001          MOV      r0,#1
                  |L1.924|
;;;202    	}
;;;203    
;;;204    	for (i = 0; i < dev->param.n_caches; i++) {
;;;205    		if (dev->cache[i].data == buffer)
;;;206    			return 1;
;;;207    	}
;;;208    
;;;209    	if (buffer == dev->checkpt_buffer)
;;;210    		return 1;
;;;211    
;;;212    	yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;213    	  "yaffs: unmaged buffer detected.");
;;;214    	return 0;
;;;215    }
00039c  e8bd8070          POP      {r4-r6,pc}
                  |L1.928|
0003a0  e2844001          ADD      r4,r4,#1              ;199
                  |L1.932|
0003a4  e3540006          CMP      r4,#6                 ;199
0003a8  bafffff6          BLT      |L1.904|
0003ac  e3a04000          MOV      r4,#0                 ;204
0003b0  ea000008          B        |L1.984|
                  |L1.948|
0003b4  e0641184          RSB      r1,r4,r4,LSL #3       ;205
0003b8  e5950d90          LDR      r0,[r5,#0xd90]        ;205
0003bc  e0800101          ADD      r0,r0,r1,LSL #2       ;205
0003c0  e5900018          LDR      r0,[r0,#0x18]         ;205
0003c4  e1500006          CMP      r0,r6                 ;205
0003c8  1a000001          BNE      |L1.980|
0003cc  e3a00001          MOV      r0,#1                 ;206
0003d0  eafffff1          B        |L1.924|
                  |L1.980|
0003d4  e2844001          ADD      r4,r4,#1              ;204
                  |L1.984|
0003d8  e5950020          LDR      r0,[r5,#0x20]         ;204
0003dc  e1500004          CMP      r0,r4                 ;204
0003e0  cafffff3          BGT      |L1.948|
0003e4  e59500ec          LDR      r0,[r5,#0xec]         ;209
0003e8  e1500006          CMP      r0,r6                 ;209
0003ec  1a000001          BNE      |L1.1016|
0003f0  e3a00001          MOV      r0,#1                 ;210
0003f4  eaffffe8          B        |L1.924|
                  |L1.1016|
0003f8  e51f01c8          LDR      r0,|L1.568|
0003fc  e5900000          LDR      r0,[r0,#0]            ;212  ; yaffs_trace_mask
000400  e310020f          TST      r0,#0xf0000000        ;212
000404  0a000001          BEQ      |L1.1040|
000408  e28f0f9e          ADR      r0,|L1.1672|
00040c  ebfffffe          BL       sysprintf
                  |L1.1040|
000410  e3a00000          MOV      r0,#0                 ;214
000414  eaffffe0          B        |L1.924|
;;;216    
                          ENDP

                  yaffs_handle_chunk_wr_ok PROC
;;;221    
;;;222    static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
000418  e1a00000          MOV      r0,r0
;;;223    				     const u8 *data,
;;;224    				     const struct yaffs_ext_tags *tags)
;;;225    {
;;;226    	dev = dev;
;;;227    	nand_chunk = nand_chunk;
00041c  e1a00000          MOV      r0,r0
;;;228    	data = data;
000420  e1a00000          MOV      r0,r0
;;;229    	tags = tags;
000424  e1a00000          MOV      r0,r0
;;;230    }
000428  e12fff1e          BX       lr
;;;231    
                          ENDP

                  yaffs_handle_chunk_update PROC
;;;232    static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
00042c  e1a00000          MOV      r0,r0
;;;233    				      const struct yaffs_ext_tags *tags)
;;;234    {
;;;235    	dev = dev;
;;;236    	nand_chunk = nand_chunk;
000430  e1a00000          MOV      r0,r0
;;;237    	tags = tags;
000434  e1a00000          MOV      r0,r0
;;;238    }
000438  e12fff1e          BX       lr
;;;239    
                          ENDP

                  yaffs_handle_chunk_error PROC
;;;240    void yaffs_handle_chunk_error(struct yaffs_dev *dev,
00043c  e92d4070          PUSH     {r4-r6,lr}
;;;241    			      struct yaffs_block_info *bi)
;;;242    {
000440  e1a05000          MOV      r5,r0
000444  e1a04001          MOV      r4,r1
;;;243    	if (!bi->gc_prioritise) {
000448  e5940000          LDR      r0,[r4,#0]
00044c  e1a00280          LSL      r0,r0,#5
000450  e1b00fa0          LSRS     r0,r0,#31
000454  1a00001c          BNE      |L1.1228|
;;;244    		bi->gc_prioritise = 1;
000458  e5940000          LDR      r0,[r4,#0]
00045c  e3800301          ORR      r0,r0,#0x4000000
000460  e5840000          STR      r0,[r4,#0]
;;;245    		dev->has_pending_prioritised_gc = 1;
000464  e3a00001          MOV      r0,#1
000468  e5850d58          STR      r0,[r5,#0xd58]
;;;246    		bi->chunk_error_strikes++;
00046c  e5940000          LDR      r0,[r4,#0]
000470  e3c0030e          BIC      r0,r0,#0x38000000
000474  e5941000          LDR      r1,[r4,#0]
000478  e1a01101          LSL      r1,r1,#2
00047c  e3a02001          MOV      r2,#1
000480  e0821ea1          ADD      r1,r2,r1,LSR #29
000484  e3a0230e          MOV      r2,#0x38000000
000488  e0021d81          AND      r1,r2,r1,LSL #27
00048c  e1800001          ORR      r0,r0,r1
000490  e5840000          STR      r0,[r4,#0]
;;;247    
;;;248    		if (bi->chunk_error_strikes > 3) {
000494  e5940000          LDR      r0,[r4,#0]
000498  e1a00100          LSL      r0,r0,#2
00049c  e3a01003          MOV      r1,#3
0004a0  e1510ea0          CMP      r1,r0,LSR #29
0004a4  aa000008          BGE      |L1.1228|
;;;249    			bi->needs_retiring = 1;	/* Too many stikes, so retire */
0004a8  e5940000          LDR      r0,[r4,#0]
0004ac  e3800401          ORR      r0,r0,#0x1000000
0004b0  e5840000          STR      r0,[r4,#0]
;;;250    			yaffs_trace(YAFFS_TRACE_ALWAYS,
0004b4  e51f0284          LDR      r0,|L1.568|
0004b8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0004bc  e310020f          TST      r0,#0xf0000000
0004c0  0a000001          BEQ      |L1.1228|
0004c4  e28f0f79          ADR      r0,|L1.1712|
0004c8  ebfffffe          BL       sysprintf
                  |L1.1228|
;;;251    				"yaffs: Block struck out");
;;;252    
;;;253    		}
;;;254    	}
;;;255    }
0004cc  e8bd8070          POP      {r4-r6,pc}
;;;256    
                          ENDP

                  yaffs_skip_rest_of_block PROC
;;;497     */
;;;498    void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
0004d0  e92d4070          PUSH     {r4-r6,lr}
;;;499    {
0004d4  e1a05000          MOV      r5,r0
;;;500    	struct yaffs_block_info *bi;
;;;501    
;;;502    	if (dev->alloc_block > 0) {
0004d8  e595012c          LDR      r0,[r5,#0x12c]
0004dc  e3500000          CMP      r0,#0
0004e0  da00000d          BLE      |L1.1308|
;;;503    		bi = yaffs_get_block_info(dev, dev->alloc_block);
0004e4  e595112c          LDR      r1,[r5,#0x12c]
0004e8  e1a00005          MOV      r0,r5
0004ec  ebfffffe          BL       yaffs_get_block_info
0004f0  e1a04000          MOV      r4,r0
;;;504    		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
0004f4  e5940000          LDR      r0,[r4,#0]
0004f8  e200060f          AND      r0,r0,#0xf00000
0004fc  e3500501          CMP      r0,#0x400000
000500  1a000005          BNE      |L1.1308|
;;;505    			bi->block_state = YAFFS_BLOCK_STATE_FULL;
000504  e5940000          LDR      r0,[r4,#0]
000508  e3c0060f          BIC      r0,r0,#0xf00000
00050c  e3800605          ORR      r0,r0,#0x500000
000510  e5840000          STR      r0,[r4,#0]
;;;506    			dev->alloc_block = -1;
000514  e3e00000          MVN      r0,#0
000518  e585012c          STR      r0,[r5,#0x12c]
                  |L1.1308|
;;;507    		}
;;;508    	}
;;;509    }
00051c  e8bd8070          POP      {r4-r6,pc}
;;;510    
                          ENDP

                  yaffs_retire_block PROC
;;;614    
;;;615    static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
000520  e92d41f0          PUSH     {r4-r8,lr}
;;;616    {
000524  e24dd048          SUB      sp,sp,#0x48
000528  e1a04000          MOV      r4,r0
00052c  e1a06001          MOV      r6,r1
;;;617    	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
000530  e1a01006          MOV      r1,r6
000534  e1a00004          MOV      r0,r4
000538  ebfffffe          BL       yaffs_get_block_info
00053c  e1a05000          MOV      r5,r0
;;;618    
;;;619    	yaffs2_checkpt_invalidate(dev);
000540  e1a00004          MOV      r0,r4
000544  ebfffffe          BL       yaffs2_checkpt_invalidate
;;;620    
;;;621    	yaffs2_clear_oldest_dirty_seq(dev, bi);
000548  e1a01005          MOV      r1,r5
00054c  e1a00004          MOV      r0,r4
000550  ebfffffe          BL       yaffs2_clear_oldest_dirty_seq
;;;622    
;;;623    	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
000554  e1a01006          MOV      r1,r6
000558  e1a00004          MOV      r0,r4
00055c  ebfffffe          BL       yaffs_mark_bad
000560  e3500001          CMP      r0,#1
000564  0a00002e          BEQ      |L1.1572|
;;;624    		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
000568  e1a01006          MOV      r1,r6
00056c  e1a00004          MOV      r0,r4
000570  ebfffffe          BL       yaffs_erase_block
000574  e3500001          CMP      r0,#1
000578  0a000007          BEQ      |L1.1436|
;;;625    			yaffs_trace(YAFFS_TRACE_ALWAYS,
00057c  e51f034c          LDR      r0,|L1.568|
000580  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000584  e310020f          TST      r0,#0xf0000000
000588  0a000025          BEQ      |L1.1572|
00058c  e1a01006          MOV      r1,r6
000590  e28f0f4e          ADR      r0,|L1.1744|
000594  ebfffffe          BL       sysprintf
000598  ea000021          B        |L1.1572|
                  |L1.1436|
;;;626    				"yaffs: Failed to mark bad and erase block %d",
;;;627    				flash_block);
;;;628    		} else {
;;;629    			struct yaffs_ext_tags tags;
;;;630    			int chunk_id =
00059c  e594000c          LDR      r0,[r4,#0xc]
0005a0  e0070690          MUL      r7,r0,r6
;;;631    			    flash_block * dev->param.chunks_per_block;
;;;632    
;;;633    			u8 *buffer = yaffs_get_temp_buffer(dev);
0005a4  e1a00004          MOV      r0,r4
0005a8  ebfffffe          BL       yaffs_get_temp_buffer
0005ac  e1a08000          MOV      r8,r0
;;;634    
;;;635    			memset(buffer, 0xff, dev->data_bytes_per_chunk);
0005b0  e3a020ff          MOV      r2,#0xff
0005b4  e1a00008          MOV      r0,r8
0005b8  e59410a4          LDR      r1,[r4,#0xa4]
0005bc  ebfffffe          BL       __aeabi_memset
;;;636    			memset(&tags, 0, sizeof(tags));
0005c0  e3a01048          MOV      r1,#0x48
0005c4  e1a0000d          MOV      r0,sp
0005c8  ebfffffe          BL       __aeabi_memclr4
;;;637    			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
0005cc  e59f0134          LDR      r0,|L1.1800|
0005d0  e58d0020          STR      r0,[sp,#0x20]
;;;638    			if (dev->param.write_chunk_tags_fn(dev, chunk_id -
0005d4  e59400dc          LDR      r0,[r4,#0xdc]
0005d8  e0471000          SUB      r1,r7,r0
0005dc  e1a0300d          MOV      r3,sp
0005e0  e1a02008          MOV      r2,r8
0005e4  e594c058          LDR      r12,[r4,#0x58]
0005e8  e1a00004          MOV      r0,r4
0005ec  e12fff3c          BLX      r12
0005f0  e3500001          CMP      r0,#1
0005f4  0a000006          BEQ      |L1.1556|
;;;639    							   dev->chunk_offset,
;;;640    							   buffer,
;;;641    							   &tags) != YAFFS_OK)
;;;642    				yaffs_trace(YAFFS_TRACE_ALWAYS,
0005f8  e51f03c8          LDR      r0,|L1.568|
0005fc  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000600  e310020f          TST      r0,#0xf0000000
000604  0a000002          BEQ      |L1.1556|
000608  e1a01006          MOV      r1,r6
00060c  e28f00f8          ADR      r0,|L1.1804|
000610  ebfffffe          BL       sysprintf
                  |L1.1556|
;;;643    					"yaffs: Failed to write bad block marker to block %d",
;;;644    					flash_block);
;;;645    
;;;646    			yaffs_release_temp_buffer(dev, buffer);
000614  e1a01008          MOV      r1,r8
000618  e1a00004          MOV      r0,r4
00061c  ebfffffe          BL       yaffs_release_temp_buffer
;;;647    		}
000620  e1a00000          MOV      r0,r0
                  |L1.1572|
;;;648    	}
;;;649    
;;;650    	bi->block_state = YAFFS_BLOCK_STATE_DEAD;
000624  e5950000          LDR      r0,[r5,#0]
000628  e3c0060f          BIC      r0,r0,#0xf00000
00062c  e3800609          ORR      r0,r0,#0x900000
000630  e5850000          STR      r0,[r5,#0]
;;;651    	bi->gc_prioritise = 0;
000634  e5950000          LDR      r0,[r5,#0]
000638  e3c00301          BIC      r0,r0,#0x4000000
00063c  e5850000          STR      r0,[r5,#0]
;;;652    	bi->needs_retiring = 0;
000640  e5950000          LDR      r0,[r5,#0]
000644  e3c00401          BIC      r0,r0,#0x1000000
000648  e5850000          STR      r0,[r5,#0]
;;;653    
;;;654    	dev->n_retired_blocks++;
00064c  e5940e3c          LDR      r0,[r4,#0xe3c]
000650  e2800001          ADD      r0,r0,#1
000654  e5840e3c          STR      r0,[r4,#0xe3c]
;;;655    }
000658  e28dd048          ADD      sp,sp,#0x48
00065c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1632|
000660  79616666          DCB      "yaffs: Releasing unmanaged temp buffer\n",0
000664  733a2052
000668  656c6561
00066c  73696e67
000670  20756e6d
000674  616e6167
000678  65642074
00067c  656d7020
000680  62756666
000684  65720a00
                  |L1.1672|
000688  79616666          DCB      "yaffs: yaffs: unmaged buffer detected.\n",0
00068c  733a2079
000690  61666673
000694  3a20756e
000698  6d616765
00069c  64206275
0006a0  66666572
0006a4  20646574
0006a8  65637465
0006ac  642e0a00
                  |L1.1712|
0006b0  79616666          DCB      "yaffs: yaffs: Block struck out\n",0
0006b4  733a2079
0006b8  61666673
0006bc  3a20426c
0006c0  6f636b20
0006c4  73747275
0006c8  636b206f
0006cc  75740a00
                  |L1.1744|
0006d0  79616666          DCB      "yaffs: yaffs: Failed to mark bad and erase block %d\n"
0006d4  733a2079
0006d8  61666673
0006dc  3a204661
0006e0  696c6564
0006e4  20746f20
0006e8  6d61726b
0006ec  20626164
0006f0  20616e64
0006f4  20657261
0006f8  73652062
0006fc  6c6f636b
000700  2025640a
                  |L1.1796|
000704  00                DCB      0
000705  00                DCB      0
000706  00                DCB      0
000707  00                DCB      0
                  |L1.1800|
                          DCD      0xffff0000
                  |L1.1804|
00070c  79616666          DCB      "yaffs: yaffs: Failed to write bad block marker to block"
000710  733a2079
000714  61666673
000718  3a204661
00071c  696c6564
000720  20746f20
000724  77726974
000728  65206261
00072c  6420626c
000730  6f636b20
000734  6d61726b
000738  65722074
00073c  6f20626c
000740  6f636b  
000743  2025640a          DCB      " %d\n",0
000747  00      
                          ENDP

                  yaffs_check_ff PROC
;;;311    
;;;312    int yaffs_check_ff(u8 *buffer, int n_bytes)
000748  e1a02000          MOV      r2,r0
;;;313    {
;;;314    	/* Horrible, slow implementation */
;;;315    	while (n_bytes--) {
00074c  ea000005          B        |L1.1896|
                  |L1.1872|
;;;316    		if (*buffer != 0xff)
000750  e5d20000          LDRB     r0,[r2,#0]
000754  e35000ff          CMP      r0,#0xff
000758  0a000001          BEQ      |L1.1892|
;;;317    			return 0;
00075c  e3a00000          MOV      r0,#0
                  |L1.1888|
;;;318    		buffer++;
;;;319    	}
;;;320    	return 1;
;;;321    }
000760  e12fff1e          BX       lr
                  |L1.1892|
000764  e2822001          ADD      r2,r2,#1              ;318
                  |L1.1896|
000768  e1b00001          MOVS     r0,r1                 ;315
00076c  e2411001          SUB      r1,r1,#1              ;315
000770  1afffff6          BNE      |L1.1872|
000774  e3a00001          MOV      r0,#1                 ;320
000778  eafffff8          B        |L1.1888|
;;;322    
                          ENDP

                  yaffs_check_chunk_erased PROC
;;;323    static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
00077c  e92d40f0          PUSH     {r4-r7,lr}
;;;324    {
000780  e24dd04c          SUB      sp,sp,#0x4c
000784  e1a04000          MOV      r4,r0
000788  e1a05001          MOV      r5,r1
;;;325    	int retval = YAFFS_OK;
00078c  e3a06001          MOV      r6,#1
;;;326    	u8 *data = yaffs_get_temp_buffer(dev);
000790  e1a00004          MOV      r0,r4
000794  ebfffffe          BL       yaffs_get_temp_buffer
000798  e1a07000          MOV      r7,r0
;;;327    	struct yaffs_ext_tags tags;
;;;328    
;;;329    	yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
00079c  e1a0300d          MOV      r3,sp
0007a0  e1a02007          MOV      r2,r7
0007a4  e1a01005          MOV      r1,r5
0007a8  e1a00004          MOV      r0,r4
0007ac  ebfffffe          BL       yaffs_rd_chunk_tags_nand
;;;330    
;;;331    	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
0007b0  e5dd0010          LDRB     r0,[sp,#0x10]
0007b4  e3500001          CMP      r0,#1
0007b8  da000000          BLE      |L1.1984|
;;;332    		retval = YAFFS_FAIL;
0007bc  e3a06000          MOV      r6,#0
                  |L1.1984|
;;;333    
;;;334    	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
0007c0  e1a00007          MOV      r0,r7
0007c4  e59410a4          LDR      r1,[r4,#0xa4]
0007c8  ebfffffe          BL       yaffs_check_ff
0007cc  e3500000          CMP      r0,#0
0007d0  0a000002          BEQ      |L1.2016|
;;;335    		tags.chunk_used) {
0007d4  e59d0000          LDR      r0,[sp,#0]
0007d8  e3500000          CMP      r0,#0
0007dc  0a000007          BEQ      |L1.2048|
                  |L1.2016|
;;;336    		yaffs_trace(YAFFS_TRACE_NANDACCESS,
0007e0  e51f05b0          LDR      r0,|L1.568|
0007e4  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
0007e8  e3100b02          TST      r0,#0x800
0007ec  0a000002          BEQ      |L1.2044|
0007f0  e1a01005          MOV      r1,r5
0007f4  e28f0fa1          ADR      r0,|L1.2688|
0007f8  ebfffffe          BL       sysprintf
                  |L1.2044|
;;;337    			"Chunk %d not erased", nand_chunk);
;;;338    		retval = YAFFS_FAIL;
0007fc  e3a06000          MOV      r6,#0
                  |L1.2048|
;;;339    	}
;;;340    
;;;341    	yaffs_release_temp_buffer(dev, data);
000800  e1a01007          MOV      r1,r7
000804  e1a00004          MOV      r0,r4
000808  ebfffffe          BL       yaffs_release_temp_buffer
;;;342    
;;;343    	return retval;
00080c  e1a00006          MOV      r0,r6
000810  e28dd04c          ADD      sp,sp,#0x4c
;;;344    
;;;345    }
000814  e8bd80f0          POP      {r4-r7,pc}
;;;346    
                          ENDP

                  yaffs_block_became_dirty PROC
;;;2318   
;;;2319   void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
000818  e92d41f0          PUSH     {r4-r8,lr}
;;;2320   {
00081c  e1a05000          MOV      r5,r0
000820  e1a07001          MOV      r7,r1
;;;2321   	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
000824  e1a01007          MOV      r1,r7
000828  e1a00005          MOV      r0,r5
00082c  ebfffffe          BL       yaffs_get_block_info
000830  e1a04000          MOV      r4,r0
;;;2322   	int erased_ok = 0;
000834  e3a08000          MOV      r8,#0
;;;2323   	int i;
;;;2324   
;;;2325   	/* If the block is still healthy erase it and mark as clean.
;;;2326   	 * If the block has had a data failure, then retire it.
;;;2327   	 */
;;;2328   
;;;2329   	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
000838  e51f0608          LDR      r0,|L1.568|
00083c  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
000840  e3100060          TST      r0,#0x60
000844  0a00000d          BEQ      |L1.2176|
000848  e5940000          LDR      r0,[r4,#0]
00084c  e1a00380          LSL      r0,r0,#7
000850  e1b00fa0          LSRS     r0,r0,#31
000854  0a000001          BEQ      |L1.2144|
000858  e28f0f8f          ADR      r0,|L1.2716|
00085c  ea000000          B        |L1.2148|
                  |L1.2144|
000860  e24f0f59          ADR      r0,|L1.1796|
                  |L1.2148|
000864  e1a03000          MOV      r3,r0
000868  e5940000          LDR      r0,[r4,#0]
00086c  e1a00400          LSL      r0,r0,#8
000870  e1a02e20          LSR      r2,r0,#28
000874  e1a01007          MOV      r1,r7
000878  e28f0f8b          ADR      r0,|L1.2732|
00087c  ebfffffe          BL       sysprintf
                  |L1.2176|
;;;2330   		"yaffs_block_became_dirty block %d state %d %s",
;;;2331   		block_no, bi->block_state,
;;;2332   		(bi->needs_retiring) ? "needs retiring" : "");
;;;2333   
;;;2334   	yaffs2_clear_oldest_dirty_seq(dev, bi);
000880  e1a01004          MOV      r1,r4
000884  e1a00005          MOV      r0,r5
000888  ebfffffe          BL       yaffs2_clear_oldest_dirty_seq
;;;2335   
;;;2336   	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
00088c  e5940000          LDR      r0,[r4,#0]
000890  e3c0060f          BIC      r0,r0,#0xf00000
000894  e3800606          ORR      r0,r0,#0x600000
000898  e5840000          STR      r0,[r4,#0]
;;;2337   
;;;2338   	/* If this is the block being garbage collected then stop gc'ing */
;;;2339   	if (block_no == dev->gc_block)
00089c  e5950d70          LDR      r0,[r5,#0xd70]
0008a0  e1500007          CMP      r0,r7
0008a4  1a000001          BNE      |L1.2224|
;;;2340   		dev->gc_block = 0;
0008a8  e3a00000          MOV      r0,#0
0008ac  e5850d70          STR      r0,[r5,#0xd70]
                  |L1.2224|
;;;2341   
;;;2342   	/* If this block is currently the best candidate for gc
;;;2343   	 * then drop as a candidate */
;;;2344   	if (block_no == dev->gc_dirtiest) {
0008b0  e5950d64          LDR      r0,[r5,#0xd64]
0008b4  e1500007          CMP      r0,r7
0008b8  1a000002          BNE      |L1.2248|
;;;2345   		dev->gc_dirtiest = 0;
0008bc  e3a00000          MOV      r0,#0
0008c0  e5850d64          STR      r0,[r5,#0xd64]
;;;2346   		dev->gc_pages_in_use = 0;
0008c4  e5850d68          STR      r0,[r5,#0xd68]
                  |L1.2248|
;;;2347   	}
;;;2348   
;;;2349   	if (!bi->needs_retiring) {
0008c8  e5940000          LDR      r0,[r4,#0]
0008cc  e1a00380          LSL      r0,r0,#7
0008d0  e1b00fa0          LSRS     r0,r0,#31
0008d4  1a000011          BNE      |L1.2336|
;;;2350   		yaffs2_checkpt_invalidate(dev);
0008d8  e1a00005          MOV      r0,r5
0008dc  ebfffffe          BL       yaffs2_checkpt_invalidate
;;;2351   		erased_ok = yaffs_erase_block(dev, block_no);
0008e0  e1a01007          MOV      r1,r7
0008e4  e1a00005          MOV      r0,r5
0008e8  ebfffffe          BL       yaffs_erase_block
0008ec  e1a08000          MOV      r8,r0
;;;2352   		if (!erased_ok) {
0008f0  e3580000          CMP      r8,#0
0008f4  1a000009          BNE      |L1.2336|
;;;2353   			dev->n_erase_failures++;
0008f8  e5950e1c          LDR      r0,[r5,#0xe1c]
0008fc  e2800001          ADD      r0,r0,#1
000900  e5850e1c          STR      r0,[r5,#0xe1c]
;;;2354   			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
000904  e51f06d4          LDR      r0,|L1.568|
000908  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00090c  e3100141          TST      r0,#0x40000010
000910  0a000002          BEQ      |L1.2336|
000914  e1a01007          MOV      r1,r7
000918  e28f0f71          ADR      r0,|L1.2788|
00091c  ebfffffe          BL       sysprintf
                  |L1.2336|
;;;2355   			  "**>> Erasure failed %d", block_no);
;;;2356   		}
;;;2357   	}
;;;2358   
;;;2359   	/* Verify erasure if needed */
;;;2360   	if (erased_ok &&
000920  e3580000          CMP      r8,#0
000924  0a00001b          BEQ      |L1.2456|
;;;2361   	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
000928  e51f06f8          LDR      r0,|L1.568|
00092c  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
000930  e3100020          TST      r0,#0x20
000934  1a000003          BNE      |L1.2376|
;;;2362   	     !yaffs_skip_verification(dev))) {
000938  e1a00005          MOV      r0,r5
00093c  ebfffffe          BL       yaffs_skip_verification
000940  e3500000          CMP      r0,#0
000944  1a000013          BNE      |L1.2456|
                  |L1.2376|
;;;2363   		for (i = 0; i < dev->param.chunks_per_block; i++) {
000948  e3a06000          MOV      r6,#0
00094c  ea00000e          B        |L1.2444|
                  |L1.2384|
;;;2364   			if (!yaffs_check_chunk_erased(dev,
000950  e595000c          LDR      r0,[r5,#0xc]
000954  e0216097          MLA      r1,r7,r0,r6
000958  e1a00005          MOV      r0,r5
00095c  ebfffffe          BL       yaffs_check_chunk_erased
000960  e3500000          CMP      r0,#0
000964  1a000007          BNE      |L1.2440|
;;;2365   				block_no * dev->param.chunks_per_block + i)) {
;;;2366   				yaffs_trace(YAFFS_TRACE_ERROR,
000968  e51f0738          LDR      r0,|L1.568|
00096c  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000970  e3100101          TST      r0,#0x40000000
000974  0a000003          BEQ      |L1.2440|
000978  e1a02006          MOV      r2,r6
00097c  e1a01007          MOV      r1,r7
000980  e59f017c          LDR      r0,|L1.2820|
000984  ebfffffe          BL       sysprintf
                  |L1.2440|
000988  e2866001          ADD      r6,r6,#1              ;2363
                  |L1.2444|
00098c  e595000c          LDR      r0,[r5,#0xc]          ;2363
000990  e1500006          CMP      r0,r6                 ;2363
000994  caffffed          BGT      |L1.2384|
                  |L1.2456|
;;;2367   					">>Block %d erasure supposedly OK, but chunk %d not erased",
;;;2368   					block_no, i);
;;;2369   			}
;;;2370   		}
;;;2371   	}
;;;2372   
;;;2373   	if (!erased_ok) {
000998  e3580000          CMP      r8,#0
00099c  1a00000e          BNE      |L1.2524|
;;;2374   		/* We lost a block of free space */
;;;2375   		dev->n_free_chunks -= dev->param.chunks_per_block;
0009a0  e5950d4c          LDR      r0,[r5,#0xd4c]
0009a4  e595100c          LDR      r1,[r5,#0xc]
0009a8  e0400001          SUB      r0,r0,r1
0009ac  e5850d4c          STR      r0,[r5,#0xd4c]
;;;2376   		yaffs_retire_block(dev, block_no);
0009b0  e1a01007          MOV      r1,r7
0009b4  e1a00005          MOV      r0,r5
0009b8  ebfffffe          BL       yaffs_retire_block
;;;2377   		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
0009bc  e51f078c          LDR      r0,|L1.568|
0009c0  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0009c4  e3100141          TST      r0,#0x40000010
0009c8  0a000002          BEQ      |L1.2520|
0009cc  e1a01007          MOV      r1,r7
0009d0  e28f0e13          ADR      r0,|L1.2824|
0009d4  ebfffffe          BL       sysprintf
                  |L1.2520|
;;;2378   			"**>> Block %d retired", block_no);
;;;2379   		return;
;;;2380   	}
;;;2381   
;;;2382   	/* Clean it up... */
;;;2383   	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
;;;2384   	bi->seq_number = 0;
;;;2385   	dev->n_erased_blocks++;
;;;2386   	bi->pages_in_use = 0;
;;;2387   	bi->soft_del_pages = 0;
;;;2388   	bi->has_shrink_hdr = 0;
;;;2389   	bi->skip_erased_check = 1;	/* Clean, so no need to check */
;;;2390   	bi->gc_prioritise = 0;
;;;2391   	bi->has_summary = 0;
;;;2392   
;;;2393   	yaffs_clear_chunk_bits(dev, block_no);
;;;2394   
;;;2395   	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
;;;2396   }
0009d8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2524|
0009dc  e5940000          LDR      r0,[r4,#0]            ;2383
0009e0  e3c0060f          BIC      r0,r0,#0xf00000       ;2383
0009e4  e3800603          ORR      r0,r0,#0x300000       ;2383
0009e8  e5840000          STR      r0,[r4,#0]            ;2383
0009ec  e3a00000          MOV      r0,#0                 ;2384
0009f0  e5840004          STR      r0,[r4,#4]            ;2384
0009f4  e5950128          LDR      r0,[r5,#0x128]        ;2385
0009f8  e2800001          ADD      r0,r0,#1              ;2385
0009fc  e5850128          STR      r0,[r5,#0x128]        ;2385
000a00  e5940000          LDR      r0,[r4,#0]            ;2386
000a04  e3c00703          BIC      r0,r0,#0xc0000        ;2386
000a08  e3c00bff          BIC      r0,r0,#0x3fc00        ;2386
000a0c  e5840000          STR      r0,[r4,#0]            ;2386
000a10  e5940000          LDR      r0,[r4,#0]            ;2387
000a14  e1a00520          LSR      r0,r0,#10             ;2387
000a18  e1a00500          LSL      r0,r0,#10             ;2387
000a1c  e5840000          STR      r0,[r4,#0]            ;2387
000a20  e5940000          LDR      r0,[r4,#0]            ;2388
000a24  e3c00102          BIC      r0,r0,#0x80000000     ;2388
000a28  e5840000          STR      r0,[r4,#0]            ;2388
000a2c  e5940000          LDR      r0,[r4,#0]            ;2389
000a30  e3800402          ORR      r0,r0,#0x2000000      ;2389
000a34  e5840000          STR      r0,[r4,#0]            ;2389
000a38  e5940000          LDR      r0,[r4,#0]            ;2390
000a3c  e3c00301          BIC      r0,r0,#0x4000000      ;2390
000a40  e5840000          STR      r0,[r4,#0]            ;2390
000a44  e5940000          LDR      r0,[r4,#0]            ;2391
000a48  e3c00101          BIC      r0,r0,#0x40000000     ;2391
000a4c  e5840000          STR      r0,[r4,#0]            ;2391
000a50  e1a01007          MOV      r1,r7                 ;2393
000a54  e1a00005          MOV      r0,r5                 ;2393
000a58  ebfffffe          BL       yaffs_clear_chunk_bits
000a5c  e51f082c          LDR      r0,|L1.568|
000a60  e5d00000          LDRB     r0,[r0,#0]            ;2395  ; yaffs_trace_mask
000a64  e3100020          TST      r0,#0x20              ;2395
000a68  0a000002          BEQ      |L1.2680|
000a6c  e1a01007          MOV      r1,r7                 ;2395
000a70  e28f00b0          ADR      r0,|L1.2856|
000a74  ebfffffe          BL       sysprintf
                  |L1.2680|
000a78  e1a00000          MOV      r0,r0
000a7c  eaffffd5          B        |L1.2520|
                  |L1.2688|
000a80  79616666          DCB      "yaffs: Chunk %d not erased\n",0
000a84  733a2043
000a88  68756e6b
000a8c  20256420
000a90  6e6f7420
000a94  65726173
000a98  65640a00
                  |L1.2716|
000a9c  6e656564          DCB      "needs retiring",0
000aa0  73207265
000aa4  74697269
000aa8  6e6700  
000aab  00                DCB      0
                  |L1.2732|
000aac  79616666          DCB      "yaffs: yaffs_block_became_dirty block %d state %d %s\n",0
000ab0  733a2079
000ab4  61666673
000ab8  5f626c6f
000abc  636b5f62
000ac0  6563616d
000ac4  655f6469
000ac8  72747920
000acc  626c6f63
000ad0  6b202564
000ad4  20737461
000ad8  74652025
000adc  64202573
000ae0  0a00    
000ae2  00                DCB      0
000ae3  00                DCB      0
                  |L1.2788|
000ae4  79616666          DCB      "yaffs: **>> Erasure failed %d\n",0
000ae8  733a202a
000aec  2a3e3e20
000af0  45726173
000af4  75726520
000af8  6661696c
000afc  65642025
000b00  640a00  
000b03  00                DCB      0
                  |L1.2820|
                          DCD      ||.constdata||
                  |L1.2824|
000b08  79616666          DCB      "yaffs: **>> Block %d retired\n",0
000b0c  733a202a
000b10  2a3e3e20
000b14  426c6f63
000b18  6b202564
000b1c  20726574
000b20  69726564
000b24  0a00    
000b26  00                DCB      0
000b27  00                DCB      0
                  |L1.2856|
000b28  79616666          DCB      "yaffs: Erased block %d\n",0
000b2c  733a2045
000b30  72617365
000b34  6420626c
000b38  6f636b20
000b3c  25640a00
                          ENDP

                  yaffs_chunk_del PROC
;;;2937   
;;;2938   void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
000b40  e92d47f0          PUSH     {r4-r10,lr}
;;;2939   		     int lyn)
;;;2940   {
000b44  e24dd048          SUB      sp,sp,#0x48
000b48  e1a05000          MOV      r5,r0
000b4c  e1a06001          MOV      r6,r1
000b50  e1a07002          MOV      r7,r2
000b54  e1a08003          MOV      r8,r3
;;;2941   	int block;
;;;2942   	int page;
;;;2943   	struct yaffs_ext_tags tags;
;;;2944   	struct yaffs_block_info *bi;
;;;2945   
;;;2946   	if (chunk_id <= 0)
000b58  e3560000          CMP      r6,#0
000b5c  ca000001          BGT      |L1.2920|
                  |L1.2912|
;;;2947   		return;
;;;2948   
;;;2949   	dev->n_deletions++;
;;;2950   	block = chunk_id / dev->param.chunks_per_block;
;;;2951   	page = chunk_id % dev->param.chunks_per_block;
;;;2952   
;;;2953   	if (!yaffs_check_chunk_bit(dev, block, page))
;;;2954   		yaffs_trace(YAFFS_TRACE_VERIFY,
;;;2955   			"Deleting invalid chunk %d", chunk_id);
;;;2956   
;;;2957   	bi = yaffs_get_block_info(dev, block);
;;;2958   
;;;2959   	yaffs2_update_oldest_dirty_seq(dev, block, bi);
;;;2960   
;;;2961   	yaffs_trace(YAFFS_TRACE_DELETION,
;;;2962   		"line %d delete of chunk %d",
;;;2963   		lyn, chunk_id);
;;;2964   
;;;2965   	if (!dev->param.is_yaffs2 && mark_flash &&
;;;2966   	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
;;;2967   
;;;2968   		memset(&tags, 0, sizeof(tags));
;;;2969   		tags.is_deleted = 1;
;;;2970   		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
;;;2971   		yaffs_handle_chunk_update(dev, chunk_id, &tags);
;;;2972   	} else {
;;;2973   		dev->n_unmarked_deletions++;
;;;2974   	}
;;;2975   
;;;2976   	/* Pull out of the management area.
;;;2977   	 * If the whole block became dirty, this will kick off an erasure.
;;;2978   	 */
;;;2979   	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
;;;2980   	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
;;;2981   	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
;;;2982   	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
;;;2983   		dev->n_free_chunks++;
;;;2984   		yaffs_clear_chunk_bit(dev, block, page);
;;;2985   		bi->pages_in_use--;
;;;2986   
;;;2987   		if (bi->pages_in_use == 0 &&
;;;2988   		    !bi->has_shrink_hdr &&
;;;2989   		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
;;;2990   		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
;;;2991   			yaffs_block_became_dirty(dev, block);
;;;2992   		}
;;;2993   	}
;;;2994   }
000b60  e28dd048          ADD      sp,sp,#0x48
000b64  e8bd87f0          POP      {r4-r10,pc}
                  |L1.2920|
000b68  e5950e50          LDR      r0,[r5,#0xe50]        ;2949
000b6c  e2800001          ADD      r0,r0,#1              ;2949
000b70  e5850e50          STR      r0,[r5,#0xe50]        ;2949
000b74  e1a00006          MOV      r0,r6                 ;2950
000b78  e595100c          LDR      r1,[r5,#0xc]          ;2950
000b7c  ebfffffe          BL       __aeabi_idivmod
000b80  e1a09000          MOV      r9,r0                 ;2950
000b84  e1a00006          MOV      r0,r6                 ;2951
000b88  e595100c          LDR      r1,[r5,#0xc]          ;2951
000b8c  ebfffffe          BL       __aeabi_idivmod
000b90  e1a0a001          MOV      r10,r1                ;2951
000b94  e1a0200a          MOV      r2,r10                ;2953
000b98  e1a01009          MOV      r1,r9                 ;2953
000b9c  e1a00005          MOV      r0,r5                 ;2953
000ba0  ebfffffe          BL       yaffs_check_chunk_bit
000ba4  e3500000          CMP      r0,#0                 ;2953
000ba8  1a000006          BNE      |L1.3016|
000bac  e51f097c          LDR      r0,|L1.568|
000bb0  e5900000          LDR      r0,[r0,#0]            ;2954  ; yaffs_trace_mask
000bb4  e3100801          TST      r0,#0x10000           ;2954
000bb8  0a000002          BEQ      |L1.3016|
000bbc  e1a01006          MOV      r1,r6                 ;2954
000bc0  e28f0e21          ADR      r0,|L1.3544|
000bc4  ebfffffe          BL       sysprintf
                  |L1.3016|
000bc8  e1a01009          MOV      r1,r9                 ;2957
000bcc  e1a00005          MOV      r0,r5                 ;2957
000bd0  ebfffffe          BL       yaffs_get_block_info
000bd4  e1a04000          MOV      r4,r0                 ;2957
000bd8  e1a02004          MOV      r2,r4                 ;2959
000bdc  e1a01009          MOV      r1,r9                 ;2959
000be0  e1a00005          MOV      r0,r5                 ;2959
000be4  ebfffffe          BL       yaffs2_update_oldest_dirty_seq
000be8  e51f09b8          LDR      r0,|L1.568|
000bec  e1d000b0          LDRH     r0,[r0,#0]            ;2961  ; yaffs_trace_mask
000bf0  e3100c02          TST      r0,#0x200             ;2961
000bf4  0a000003          BEQ      |L1.3080|
000bf8  e1a02006          MOV      r2,r6                 ;2961
000bfc  e1a01008          MOV      r1,r8                 ;2961
000c00  e28f0f7d          ADR      r0,|L1.3580|
000c04  ebfffffe          BL       sysprintf
                  |L1.3080|
000c08  e5950030          LDR      r0,[r5,#0x30]         ;2965
000c0c  e3500000          CMP      r0,#0                 ;2965
000c10  1a000014          BNE      |L1.3176|
000c14  e3570000          CMP      r7,#0                 ;2965
000c18  0a000012          BEQ      |L1.3176|
000c1c  e5940000          LDR      r0,[r4,#0]            ;2966
000c20  e200060f          AND      r0,r0,#0xf00000       ;2966
000c24  e3500502          CMP      r0,#0x800000          ;2966
000c28  0a00000e          BEQ      |L1.3176|
000c2c  e3a01048          MOV      r1,#0x48              ;2968
000c30  e1a0000d          MOV      r0,sp                 ;2968
000c34  ebfffffe          BL       __aeabi_memclr4
000c38  e3a00001          MOV      r0,#1                 ;2969
000c3c  e58d0018          STR      r0,[sp,#0x18]         ;2969
000c40  e1a0300d          MOV      r3,sp                 ;2970
000c44  e3a02000          MOV      r2,#0                 ;2970
000c48  e1a01006          MOV      r1,r6                 ;2970
000c4c  e1a00005          MOV      r0,r5                 ;2970
000c50  ebfffffe          BL       yaffs_wr_chunk_tags_nand
000c54  e1a0200d          MOV      r2,sp                 ;2971
000c58  e1a01006          MOV      r1,r6                 ;2971
000c5c  e1a00005          MOV      r0,r5                 ;2971
000c60  ebfffffe          BL       yaffs_handle_chunk_update
000c64  ea000002          B        |L1.3188|
                  |L1.3176|
000c68  e5950e54          LDR      r0,[r5,#0xe54]        ;2973
000c6c  e2800001          ADD      r0,r0,#1              ;2973
000c70  e5850e54          STR      r0,[r5,#0xe54]        ;2973
                  |L1.3188|
000c74  e5940000          LDR      r0,[r4,#0]            ;2979
000c78  e200060f          AND      r0,r0,#0xf00000       ;2979
000c7c  e3500501          CMP      r0,#0x400000          ;2979
000c80  0a00000b          BEQ      |L1.3252|
000c84  e5940000          LDR      r0,[r4,#0]            ;2980
000c88  e200060f          AND      r0,r0,#0xf00000       ;2980
000c8c  e3500605          CMP      r0,#0x500000          ;2980
000c90  0a000007          BEQ      |L1.3252|
000c94  e5940000          LDR      r0,[r4,#0]            ;2981
000c98  e200060f          AND      r0,r0,#0xf00000       ;2981
000c9c  e3500602          CMP      r0,#0x200000          ;2981
000ca0  0a000003          BEQ      |L1.3252|
000ca4  e5940000          LDR      r0,[r4,#0]            ;2982
000ca8  e200060f          AND      r0,r0,#0xf00000       ;2982
000cac  e3500502          CMP      r0,#0x800000          ;2982
000cb0  1a000023          BNE      |L1.3396|
                  |L1.3252|
000cb4  e5950d4c          LDR      r0,[r5,#0xd4c]        ;2983
000cb8  e2800001          ADD      r0,r0,#1              ;2983
000cbc  e5850d4c          STR      r0,[r5,#0xd4c]        ;2983
000cc0  e1a0200a          MOV      r2,r10                ;2984
000cc4  e1a01009          MOV      r1,r9                 ;2984
000cc8  e1a00005          MOV      r0,r5                 ;2984
000ccc  ebfffffe          BL       yaffs_clear_chunk_bit
000cd0  e5940000          LDR      r0,[r4,#0]            ;2985
000cd4  e3c00703          BIC      r0,r0,#0xc0000        ;2985
000cd8  e3c00bff          BIC      r0,r0,#0x3fc00        ;2985
000cdc  e5941000          LDR      r1,[r4,#0]            ;2985
000ce0  e1a01601          LSL      r1,r1,#12             ;2985
000ce4  e3a02001          MOV      r2,#1                 ;2985
000ce8  e0621b21          RSB      r1,r2,r1,LSR #22      ;2985
000cec  e59f212c          LDR      r2,|L1.3616|
000cf0  e0021501          AND      r1,r2,r1,LSL #10      ;2985
000cf4  e1800001          ORR      r0,r0,r1              ;2985
000cf8  e5840000          STR      r0,[r4,#0]            ;2985
000cfc  e5940000          LDR      r0,[r4,#0]            ;2987
000d00  e1a00600          LSL      r0,r0,#12             ;2987
000d04  e1b00b20          LSRS     r0,r0,#22             ;2987
000d08  1a00000d          BNE      |L1.3396|
000d0c  e5940000          LDR      r0,[r4,#0]            ;2988
000d10  e1b00fa0          LSRS     r0,r0,#31             ;2988
000d14  1a00000a          BNE      |L1.3396|
000d18  e5940000          LDR      r0,[r4,#0]            ;2989
000d1c  e200060f          AND      r0,r0,#0xf00000       ;2989
000d20  e3500501          CMP      r0,#0x400000          ;2989
000d24  0a000006          BEQ      |L1.3396|
000d28  e5940000          LDR      r0,[r4,#0]            ;2990
000d2c  e200060f          AND      r0,r0,#0xf00000       ;2990
000d30  e3500602          CMP      r0,#0x200000          ;2990
000d34  0a000002          BEQ      |L1.3396|
000d38  e1a01009          MOV      r1,r9                 ;2991
000d3c  e1a00005          MOV      r0,r5                 ;2991
000d40  ebfffffe          BL       yaffs_block_became_dirty
                  |L1.3396|
000d44  e1a00000          MOV      r0,r0
000d48  eaffff84          B        |L1.2912|
;;;2995   
                          ENDP

                  yaffs_handle_chunk_wr_error PROC
;;;256    
;;;257    static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
000d4c  e92d41f0          PUSH     {r4-r8,lr}
;;;258    					int erased_ok)
;;;259    {
000d50  e1a05000          MOV      r5,r0
000d54  e1a06001          MOV      r6,r1
000d58  e1a07002          MOV      r7,r2
;;;260    	int flash_block = nand_chunk / dev->param.chunks_per_block;
000d5c  e1a00006          MOV      r0,r6
000d60  e595100c          LDR      r1,[r5,#0xc]
000d64  ebfffffe          BL       __aeabi_idivmod
000d68  e1a08000          MOV      r8,r0
;;;261    	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
000d6c  e1a01008          MOV      r1,r8
000d70  e1a00005          MOV      r0,r5
000d74  ebfffffe          BL       yaffs_get_block_info
000d78  e1a04000          MOV      r4,r0
;;;262    
;;;263    	yaffs_handle_chunk_error(dev, bi);
000d7c  e1a01004          MOV      r1,r4
000d80  e1a00005          MOV      r0,r5
000d84  ebfffffe          BL       yaffs_handle_chunk_error
;;;264    
;;;265    	if (erased_ok) {
000d88  e3570000          CMP      r7,#0
000d8c  0a000009          BEQ      |L1.3512|
;;;266    		/* Was an actual write failure,
;;;267    		 * so mark the block for retirement.*/
;;;268    		bi->needs_retiring = 1;
000d90  e5940000          LDR      r0,[r4,#0]
000d94  e3800401          ORR      r0,r0,#0x1000000
000d98  e5840000          STR      r0,[r4,#0]
;;;269    		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
000d9c  e51f0b6c          LDR      r0,|L1.568|
000da0  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000da4  e3100141          TST      r0,#0x40000010
000da8  0a000002          BEQ      |L1.3512|
000dac  e1a01008          MOV      r1,r8
000db0  e28f006c          ADR      r0,|L1.3620|
000db4  ebfffffe          BL       sysprintf
                  |L1.3512|
;;;270    		  "**>> Block %d needs retiring", flash_block);
;;;271    	}
;;;272    
;;;273    	/* Delete the chunk */
;;;274    	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
000db8  e59f308c          LDR      r3,|L1.3660|
000dbc  e3a02001          MOV      r2,#1
000dc0  e1a01006          MOV      r1,r6
000dc4  e1a00005          MOV      r0,r5
000dc8  ebfffffe          BL       yaffs_chunk_del
;;;275    	yaffs_skip_rest_of_block(dev);
000dcc  e1a00005          MOV      r0,r5
000dd0  ebfffffe          BL       yaffs_skip_rest_of_block
;;;276    }
000dd4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3544|
000dd8  79616666          DCB      "yaffs: Deleting invalid chunk %d\n",0
000ddc  733a2044
000de0  656c6574
000de4  696e6720
000de8  696e7661
000dec  6c696420
000df0  6368756e
000df4  6b202564
000df8  0a00    
000dfa  00                DCB      0
000dfb  00                DCB      0
                  |L1.3580|
000dfc  79616666          DCB      "yaffs: line %d delete of chunk %d\n",0
000e00  733a206c
000e04  696e6520
000e08  25642064
000e0c  656c6574
000e10  65206f66
000e14  20636875
000e18  6e6b2025
000e1c  640a00  
000e1f  00                DCB      0
                  |L1.3616|
                          DCD      0x000ffc00
                  |L1.3620|
000e24  79616666          DCB      "yaffs: **>> Block %d needs retiring\n",0
000e28  733a202a
000e2c  2a3e3e20
000e30  426c6f63
000e34  6b202564
000e38  206e6565
000e3c  64732072
000e40  65746972
000e44  696e670a
000e48  00      
000e49  00                DCB      0
000e4a  00                DCB      0
000e4b  00                DCB      0
                  |L1.3660|
                          DCD      0x00000112
                          ENDP

                  yaffs_hash_fn PROC
;;;285    
;;;286    static __inline int yaffs_hash_fn(int n)
000e50  e1a01000          MOV      r1,r0
;;;287    {
;;;288    	if (n < 0)
000e54  e3510000          CMP      r1,#0
000e58  aa000000          BGE      |L1.3680|
;;;289    		n = -n;
000e5c  e2611000          RSB      r1,r1,#0
                  |L1.3680|
;;;290    	return n % YAFFS_NOBJECT_BUCKETS;
000e60  e1a02001          MOV      r2,r1
000e64  e1a00fc1          ASR      r0,r1,#31
000e68  e0810c20          ADD      r0,r1,r0,LSR #24
000e6c  e1a00440          ASR      r0,r0,#8
000e70  e0410400          SUB      r0,r1,r0,LSL #8
;;;291    }
000e74  e12fff1e          BX       lr
;;;292    
                          ENDP

                  yaffs_root PROC
;;;297    
;;;298    struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
000e78  e1a01000          MOV      r1,r0
;;;299    {
;;;300    	return dev->root_dir;
000e7c  e5910d80          LDR      r0,[r1,#0xd80]
;;;301    }
000e80  e12fff1e          BX       lr
;;;302    
                          ENDP

                  yaffs_lost_n_found PROC
;;;303    struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
000e84  e1a01000          MOV      r1,r0
;;;304    {
;;;305    	return dev->lost_n_found;
000e88  e5910d84          LDR      r0,[r1,#0xd84]
;;;306    }
000e8c  e12fff1e          BX       lr
;;;307    
                          ENDP

                  yaffs_verify_chunk_written PROC
;;;346    
;;;347    static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
000e90  e92d43f0          PUSH     {r4-r9,lr}
;;;348    				      int nand_chunk,
;;;349    				      const u8 *data,
;;;350    				      struct yaffs_ext_tags *tags)
;;;351    {
000e94  e24dd04c          SUB      sp,sp,#0x4c
000e98  e1a05000          MOV      r5,r0
000e9c  e1a07001          MOV      r7,r1
000ea0  e1a06002          MOV      r6,r2
000ea4  e1a04003          MOV      r4,r3
;;;352    	int retval = YAFFS_OK;
000ea8  e3a08001          MOV      r8,#1
;;;353    	struct yaffs_ext_tags temp_tags;
;;;354    	u8 *buffer = yaffs_get_temp_buffer(dev);
000eac  e1a00005          MOV      r0,r5
000eb0  ebfffffe          BL       yaffs_get_temp_buffer
000eb4  e1a09000          MOV      r9,r0
;;;355    
;;;356    	yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
000eb8  e1a0300d          MOV      r3,sp
000ebc  e1a02009          MOV      r2,r9
000ec0  e1a01007          MOV      r1,r7
000ec4  e1a00005          MOV      r0,r5
000ec8  ebfffffe          BL       yaffs_rd_chunk_tags_nand
;;;357    	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
000ecc  e1a01006          MOV      r1,r6
000ed0  e1a00009          MOV      r0,r9
000ed4  e59520a4          LDR      r2,[r5,#0xa4]
000ed8  ebfffffe          BL       memcmp
000edc  e3500000          CMP      r0,#0
000ee0  1a00000b          BNE      |L1.3860|
;;;358    	    temp_tags.obj_id != tags->obj_id ||
000ee4  e59d0004          LDR      r0,[sp,#4]
000ee8  e5941004          LDR      r1,[r4,#4]
000eec  e1500001          CMP      r0,r1
000ef0  1a000007          BNE      |L1.3860|
;;;359    	    temp_tags.chunk_id != tags->chunk_id ||
000ef4  e59d0008          LDR      r0,[sp,#8]
000ef8  e5941008          LDR      r1,[r4,#8]
000efc  e1500001          CMP      r0,r1
000f00  1a000003          BNE      |L1.3860|
;;;360    	    temp_tags.n_bytes != tags->n_bytes)
000f04  e59d000c          LDR      r0,[sp,#0xc]
000f08  e594100c          LDR      r1,[r4,#0xc]
000f0c  e1500001          CMP      r0,r1
000f10  0a000000          BEQ      |L1.3864|
                  |L1.3860|
;;;361    		retval = YAFFS_FAIL;
000f14  e3a08000          MOV      r8,#0
                  |L1.3864|
;;;362    
;;;363    	yaffs_release_temp_buffer(dev, buffer);
000f18  e1a01009          MOV      r1,r9
000f1c  e1a00005          MOV      r0,r5
000f20  ebfffffe          BL       yaffs_release_temp_buffer
;;;364    
;;;365    	return retval;
000f24  e1a00008          MOV      r0,r8
000f28  e28dd04c          ADD      sp,sp,#0x4c
;;;366    }
000f2c  e8bd83f0          POP      {r4-r9,pc}
;;;367    
                          ENDP

                  yaffs_check_alloc_available PROC
;;;368    
;;;369    int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
000f30  e92d41f0          PUSH     {r4-r8,lr}
;;;370    {
000f34  e1a04000          MOV      r4,r0
000f38  e1a05001          MOV      r5,r1
;;;371    	int reserved_chunks;
;;;372    	int reserved_blocks = dev->param.n_reserved_blocks;
000f3c  e594701c          LDR      r7,[r4,#0x1c]
;;;373    	int checkpt_blocks;
;;;374    
;;;375    	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
000f40  e1a00004          MOV      r0,r4
000f44  ebfffffe          BL       yaffs_calc_checkpt_blocks_required
000f48  e1a08000          MOV      r8,r0
;;;376    
;;;377    	reserved_chunks =
000f4c  e0870008          ADD      r0,r7,r8
000f50  e594100c          LDR      r1,[r4,#0xc]
000f54  e0060190          MUL      r6,r0,r1
;;;378    	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
;;;379    
;;;380    	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
000f58  e0861005          ADD      r1,r6,r5
000f5c  e5940d4c          LDR      r0,[r4,#0xd4c]
000f60  e1500001          CMP      r0,r1
000f64  da000001          BLE      |L1.3952|
000f68  e3a00001          MOV      r0,#1
                  |L1.3948|
;;;381    }
000f6c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3952|
000f70  e3a00000          MOV      r0,#0                 ;380
000f74  eafffffc          B        |L1.3948|
;;;382    
                          ENDP

                  yaffs_find_alloc_block PROC
;;;383    static int yaffs_find_alloc_block(struct yaffs_dev *dev)
000f78  e92d4070          PUSH     {r4-r6,lr}
;;;384    {
000f7c  e1a04000          MOV      r4,r0
;;;385    	int i;
;;;386    	struct yaffs_block_info *bi;
;;;387    
;;;388    	if (dev->n_erased_blocks < 1) {
000f80  e5940128          LDR      r0,[r4,#0x128]
000f84  e3500001          CMP      r0,#1
000f88  aa000007          BGE      |L1.4012|
;;;389    		/* Hoosterman we've got a problem.
;;;390    		 * Can't get space to gc
;;;391    		 */
;;;392    		yaffs_trace(YAFFS_TRACE_ERROR,
000f8c  e51f0d5c          LDR      r0,|L1.568|
000f90  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
000f94  e3100101          TST      r0,#0x40000000
000f98  0a000001          BEQ      |L1.4004|
000f9c  e28f0f96          ADR      r0,|L1.4604|
000fa0  ebfffffe          BL       sysprintf
                  |L1.4004|
;;;393    		  "yaffs tragedy: no more erased blocks");
;;;394    
;;;395    		return -1;
000fa4  e3e00000          MVN      r0,#0
                  |L1.4008|
;;;396    	}
;;;397    
;;;398    	/* Find an empty block. */
;;;399    
;;;400    	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
;;;401    		dev->alloc_block_finder++;
;;;402    		if (dev->alloc_block_finder < dev->internal_start_block
;;;403    		    || dev->alloc_block_finder > dev->internal_end_block) {
;;;404    			dev->alloc_block_finder = dev->internal_start_block;
;;;405    		}
;;;406    
;;;407    		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
;;;408    
;;;409    		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
;;;410    			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
;;;411    			dev->seq_number++;
;;;412    			bi->seq_number = dev->seq_number;
;;;413    			dev->n_erased_blocks--;
;;;414    			yaffs_trace(YAFFS_TRACE_ALLOCATE,
;;;415    			  "Allocated block %d, seq  %d, %d left" ,
;;;416    			   dev->alloc_block_finder, dev->seq_number,
;;;417    			   dev->n_erased_blocks);
;;;418    			return dev->alloc_block_finder;
;;;419    		}
;;;420    	}
;;;421    
;;;422    	yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;423    		"yaffs tragedy: no more erased blocks, but there should have been %d",
;;;424    		dev->n_erased_blocks);
;;;425    
;;;426    	return -1;
;;;427    }
000fa8  e8bd8070          POP      {r4-r6,pc}
                  |L1.4012|
000fac  e59460d0          LDR      r6,[r4,#0xd0]         ;400
000fb0  ea00002c          B        |L1.4200|
                  |L1.4020|
000fb4  e5940134          LDR      r0,[r4,#0x134]        ;401
000fb8  e2800001          ADD      r0,r0,#1              ;401
000fbc  e5840134          STR      r0,[r4,#0x134]        ;401
000fc0  e5940134          LDR      r0,[r4,#0x134]        ;402
000fc4  e59410d0          LDR      r1,[r4,#0xd0]         ;402
000fc8  e1500001          CMP      r0,r1                 ;402
000fcc  ba000003          BLT      |L1.4064|
000fd0  e5940134          LDR      r0,[r4,#0x134]        ;403
000fd4  e59410d4          LDR      r1,[r4,#0xd4]         ;403
000fd8  e1500001          CMP      r0,r1                 ;403
000fdc  da000001          BLE      |L1.4072|
                  |L1.4064|
000fe0  e59400d0          LDR      r0,[r4,#0xd0]         ;404
000fe4  e5840134          STR      r0,[r4,#0x134]        ;404
                  |L1.4072|
000fe8  e5941134          LDR      r1,[r4,#0x134]        ;407
000fec  e1a00004          MOV      r0,r4                 ;407
000ff0  ebfffffe          BL       yaffs_get_block_info
000ff4  e1a05000          MOV      r5,r0                 ;407
000ff8  e5950000          LDR      r0,[r5,#0]            ;409
000ffc  e200060f          AND      r0,r0,#0xf00000       ;409
001000  e3500603          CMP      r0,#0x300000          ;409
001004  1a000016          BNE      |L1.4196|
001008  e5950000          LDR      r0,[r5,#0]            ;410
00100c  e3c0060f          BIC      r0,r0,#0xf00000       ;410
001010  e3800501          ORR      r0,r0,#0x400000       ;410
001014  e5850000          STR      r0,[r5,#0]            ;410
001018  e5940df0          LDR      r0,[r4,#0xdf0]        ;411
00101c  e2800001          ADD      r0,r0,#1              ;411
001020  e5840df0          STR      r0,[r4,#0xdf0]        ;411
001024  e5940df0          LDR      r0,[r4,#0xdf0]        ;412
001028  e5850004          STR      r0,[r5,#4]            ;412
00102c  e5940128          LDR      r0,[r4,#0x128]        ;413
001030  e2400001          SUB      r0,r0,#1              ;413
001034  e5840128          STR      r0,[r4,#0x128]        ;413
001038  e51f0e08          LDR      r0,|L1.568|
00103c  e5d00000          LDRB     r0,[r0,#0]            ;414  ; yaffs_trace_mask
001040  e3100004          TST      r0,#4                 ;414
001044  0a000004          BEQ      |L1.4188|
001048  e28f0f77          ADR      r0,|L1.4652|
00104c  e5941134          LDR      r1,[r4,#0x134]        ;414
001050  e5942df0          LDR      r2,[r4,#0xdf0]        ;414
001054  e5943128          LDR      r3,[r4,#0x128]        ;414
001058  ebfffffe          BL       sysprintf
                  |L1.4188|
00105c  e5940134          LDR      r0,[r4,#0x134]        ;418
001060  eaffffd0          B        |L1.4008|
                  |L1.4196|
001064  e2866001          ADD      r6,r6,#1              ;400
                  |L1.4200|
001068  e59400d4          LDR      r0,[r4,#0xd4]         ;400
00106c  e1500006          CMP      r0,r6                 ;400
001070  aaffffcf          BGE      |L1.4020|
001074  e51f0e44          LDR      r0,|L1.568|
001078  e5900000          LDR      r0,[r0,#0]            ;422  ; yaffs_trace_mask
00107c  e310020f          TST      r0,#0xf0000000        ;422
001080  0a000002          BEQ      |L1.4240|
001084  e59f01d0          LDR      r0,|L1.4700|
001088  e5941128          LDR      r1,[r4,#0x128]        ;422
00108c  ebfffffe          BL       sysprintf
                  |L1.4240|
001090  e3e00000          MVN      r0,#0                 ;426
001094  eaffffc3          B        |L1.4008|
;;;428    
                          ENDP

                  yaffs_alloc_chunk PROC
;;;429    static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
001098  e92d41f0          PUSH     {r4-r8,lr}
;;;430    			     struct yaffs_block_info **block_ptr)
;;;431    {
00109c  e1a04000          MOV      r4,r0
0010a0  e1a07001          MOV      r7,r1
0010a4  e1a06002          MOV      r6,r2
;;;432    	int ret_val;
;;;433    	struct yaffs_block_info *bi;
;;;434    
;;;435    	if (dev->alloc_block < 0) {
0010a8  e594012c          LDR      r0,[r4,#0x12c]
0010ac  e3500000          CMP      r0,#0
0010b0  aa000004          BGE      |L1.4296|
;;;436    		/* Get next block to allocate off */
;;;437    		dev->alloc_block = yaffs_find_alloc_block(dev);
0010b4  e1a00004          MOV      r0,r4
0010b8  ebfffffe          BL       yaffs_find_alloc_block
0010bc  e584012c          STR      r0,[r4,#0x12c]
;;;438    		dev->alloc_page = 0;
0010c0  e3a00000          MOV      r0,#0
0010c4  e5840130          STR      r0,[r4,#0x130]
                  |L1.4296|
;;;439    	}
;;;440    
;;;441    	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
0010c8  e3570000          CMP      r7,#0
0010cc  1a000006          BNE      |L1.4332|
0010d0  e3a01001          MOV      r1,#1
0010d4  e1a00004          MOV      r0,r4
0010d8  ebfffffe          BL       yaffs_check_alloc_available
0010dc  e3500000          CMP      r0,#0
0010e0  1a000001          BNE      |L1.4332|
;;;442    		/* No space unless we're allowed to use the reserve. */
;;;443    		return -1;
0010e4  e3e00000          MVN      r0,#0
                  |L1.4328|
;;;444    	}
;;;445    
;;;446    	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
;;;447    	    && dev->alloc_page == 0)
;;;448    		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
;;;449    
;;;450    	/* Next page please.... */
;;;451    	if (dev->alloc_block >= 0) {
;;;452    		bi = yaffs_get_block_info(dev, dev->alloc_block);
;;;453    
;;;454    		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
;;;455    		    dev->alloc_page;
;;;456    		bi->pages_in_use++;
;;;457    		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
;;;458    
;;;459    		dev->alloc_page++;
;;;460    
;;;461    		dev->n_free_chunks--;
;;;462    
;;;463    		/* If the block is full set the state to full */
;;;464    		if (dev->alloc_page >= dev->param.chunks_per_block) {
;;;465    			bi->block_state = YAFFS_BLOCK_STATE_FULL;
;;;466    			dev->alloc_block = -1;
;;;467    		}
;;;468    
;;;469    		if (block_ptr)
;;;470    			*block_ptr = bi;
;;;471    
;;;472    		return ret_val;
;;;473    	}
;;;474    
;;;475    	yaffs_trace(YAFFS_TRACE_ERROR,
;;;476    		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
;;;477    
;;;478    	return -1;
;;;479    }
0010e8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4332|
0010ec  e5940128          LDR      r0,[r4,#0x128]        ;446
0010f0  e594101c          LDR      r1,[r4,#0x1c]         ;446
0010f4  e1500001          CMP      r0,r1                 ;446
0010f8  aa000008          BGE      |L1.4384|
0010fc  e5940130          LDR      r0,[r4,#0x130]        ;447
001100  e3500000          CMP      r0,#0                 ;447
001104  1a000005          BNE      |L1.4384|
001108  e51f0ed8          LDR      r0,|L1.568|
00110c  e5d00000          LDRB     r0,[r0,#0]            ;448  ; yaffs_trace_mask
001110  e3100004          TST      r0,#4                 ;448
001114  0a000001          BEQ      |L1.4384|
001118  e28f0d05          ADR      r0,|L1.4704|
00111c  ebfffffe          BL       sysprintf
                  |L1.4384|
001120  e594012c          LDR      r0,[r4,#0x12c]        ;451
001124  e3500000          CMP      r0,#0                 ;451
001128  ba00002b          BLT      |L1.4572|
00112c  e594112c          LDR      r1,[r4,#0x12c]        ;452
001130  e1a00004          MOV      r0,r4                 ;452
001134  ebfffffe          BL       yaffs_get_block_info
001138  e1a05000          MOV      r5,r0                 ;452
00113c  e5940130          LDR      r0,[r4,#0x130]        ;454
001140  e594112c          LDR      r1,[r4,#0x12c]        ;454
001144  e594200c          LDR      r2,[r4,#0xc]          ;454
001148  e0280291          MLA      r8,r1,r2,r0           ;454
00114c  e5950000          LDR      r0,[r5,#0]            ;456
001150  e3c00703          BIC      r0,r0,#0xc0000        ;456
001154  e3c00bff          BIC      r0,r0,#0x3fc00        ;456
001158  e5951000          LDR      r1,[r5,#0]            ;456
00115c  e1a01601          LSL      r1,r1,#12             ;456
001160  e3a02001          MOV      r2,#1                 ;456
001164  e0821b21          ADD      r1,r2,r1,LSR #22      ;456
001168  e51f2350          LDR      r2,|L1.3616|
00116c  e0021501          AND      r1,r2,r1,LSL #10      ;456
001170  e1800001          ORR      r0,r0,r1              ;456
001174  e5850000          STR      r0,[r5,#0]            ;456
001178  e594112c          LDR      r1,[r4,#0x12c]        ;457
00117c  e5942130          LDR      r2,[r4,#0x130]        ;457
001180  e1a00004          MOV      r0,r4                 ;457
001184  ebfffffe          BL       yaffs_set_chunk_bit
001188  e5940130          LDR      r0,[r4,#0x130]        ;459
00118c  e2800001          ADD      r0,r0,#1              ;459
001190  e5840130          STR      r0,[r4,#0x130]        ;459
001194  e5940d4c          LDR      r0,[r4,#0xd4c]        ;461
001198  e2400001          SUB      r0,r0,#1              ;461
00119c  e5840d4c          STR      r0,[r4,#0xd4c]        ;461
0011a0  e5940130          LDR      r0,[r4,#0x130]        ;464
0011a4  e594100c          LDR      r1,[r4,#0xc]          ;464
0011a8  e1500001          CMP      r0,r1                 ;464
0011ac  3a000005          BCC      |L1.4552|
0011b0  e5950000          LDR      r0,[r5,#0]            ;465
0011b4  e3c0060f          BIC      r0,r0,#0xf00000       ;465
0011b8  e3800605          ORR      r0,r0,#0x500000       ;465
0011bc  e5850000          STR      r0,[r5,#0]            ;465
0011c0  e3e00000          MVN      r0,#0                 ;466
0011c4  e584012c          STR      r0,[r4,#0x12c]        ;466
                  |L1.4552|
0011c8  e3560000          CMP      r6,#0                 ;469
0011cc  0a000000          BEQ      |L1.4564|
0011d0  e5865000          STR      r5,[r6,#0]            ;470
                  |L1.4564|
0011d4  e1a00008          MOV      r0,r8                 ;472
0011d8  eaffffc2          B        |L1.4328|
                  |L1.4572|
0011dc  e51f0fac          LDR      r0,|L1.568|
0011e0  e5900000          LDR      r0,[r0,#0]            ;475  ; yaffs_trace_mask
0011e4  e3100101          TST      r0,#0x40000000        ;475
0011e8  0a000001          BEQ      |L1.4596|
0011ec  e28f0088          ADR      r0,|L1.4732|
0011f0  ebfffffe          BL       sysprintf
                  |L1.4596|
0011f4  e3e00000          MVN      r0,#0                 ;478
0011f8  eaffffba          B        |L1.4328|
                  |L1.4604|
0011fc  79616666          DCB      "yaffs: yaffs tragedy: no more erased blocks\n",0
001200  733a2079
001204  61666673
001208  20747261
00120c  67656479
001210  3a206e6f
001214  206d6f72
001218  65206572
00121c  61736564
001220  20626c6f
001224  636b730a
001228  00      
001229  00                DCB      0
00122a  00                DCB      0
00122b  00                DCB      0
                  |L1.4652|
00122c  79616666          DCB      "yaffs: Allocated block %d, seq  %d, %d left\n",0
001230  733a2041
001234  6c6c6f63
001238  61746564
00123c  20626c6f
001240  636b2025
001244  642c2073
001248  65712020
00124c  25642c20
001250  2564206c
001254  6566740a
001258  00      
001259  00                DCB      0
00125a  00                DCB      0
00125b  00                DCB      0
                  |L1.4700|
                          DCD      ||.constdata||+0x44
                  |L1.4704|
001260  79616666          DCB      "yaffs: Allocating reserve\n",0
001264  733a2041
001268  6c6c6f63
00126c  6174696e
001270  67207265
001274  73657276
001278  650a00  
00127b  00                DCB      0
                  |L1.4732|
00127c  79616666          DCB      "yaffs: !!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!\n",0
001280  733a2021
001284  21212121
001288  21212121
00128c  20416c6c
001290  6f636174
001294  6f72206f
001298  75742021
00129c  21212121
0012a0  21212121
0012a4  21212121
0012a8  21212121
0012ac  0a00    
0012ae  00                DCB      0
0012af  00                DCB      0
                          ENDP

                  yaffs_get_erased_chunks PROC
;;;480    
;;;481    static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
0012b0  e1a01000          MOV      r1,r0
;;;482    {
;;;483    	int n;
;;;484    
;;;485    	n = dev->n_erased_blocks * dev->param.chunks_per_block;
0012b4  e5912128          LDR      r2,[r1,#0x128]
0012b8  e591300c          LDR      r3,[r1,#0xc]
0012bc  e0000392          MUL      r0,r2,r3
;;;486    
;;;487    	if (dev->alloc_block > 0)
0012c0  e591212c          LDR      r2,[r1,#0x12c]
0012c4  e3520000          CMP      r2,#0
0012c8  da000003          BLE      |L1.4828|
;;;488    		n += (dev->param.chunks_per_block - dev->alloc_page);
0012cc  e591200c          LDR      r2,[r1,#0xc]
0012d0  e5913130          LDR      r3,[r1,#0x130]
0012d4  e0422003          SUB      r2,r2,r3
0012d8  e0800002          ADD      r0,r0,r2
                  |L1.4828|
;;;489    
;;;490    	return n;
;;;491    
;;;492    }
0012dc  e12fff1e          BX       lr
;;;493    
                          ENDP

                  yaffs_write_new_chunk PROC
;;;510    
;;;511    static int yaffs_write_new_chunk(struct yaffs_dev *dev,
0012e0  e92d4ff8          PUSH     {r3-r11,lr}
;;;512    				 const u8 *data,
;;;513    				 struct yaffs_ext_tags *tags, int use_reserver)
;;;514    {
0012e4  e1a05000          MOV      r5,r0
0012e8  e1a08001          MOV      r8,r1
0012ec  e1a09002          MOV      r9,r2
0012f0  e1a0a003          MOV      r10,r3
;;;515    	int attempts = 0;
0012f4  e3a04000          MOV      r4,#0
;;;516    	int write_ok = 0;
0012f8  e3a07000          MOV      r7,#0
;;;517    	int chunk;
;;;518    
;;;519    	yaffs2_checkpt_invalidate(dev);
0012fc  e1a00005          MOV      r0,r5
001300  ebfffffe          BL       yaffs2_checkpt_invalidate
;;;520    
;;;521    	do {
001304  e1a00000          MOV      r0,r0
                  |L1.4872|
;;;522    		struct yaffs_block_info *bi = 0;
001308  e3a00000          MOV      r0,#0
00130c  e58d0000          STR      r0,[sp,#0]
;;;523    		int erased_ok = 0;
001310  e3a0b000          MOV      r11,#0
;;;524    
;;;525    		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
001314  e1a0200d          MOV      r2,sp
001318  e1a0100a          MOV      r1,r10
00131c  e1a00005          MOV      r0,r5
001320  ebfffffe          BL       yaffs_alloc_chunk
001324  e1a06000          MOV      r6,r0
;;;526    		if (chunk < 0) {
001328  e3560000          CMP      r6,#0
00132c  aa000000          BGE      |L1.4916|
;;;527    			/* no space */
;;;528    			break;
001330  ea00004f          B        |L1.5236|
                  |L1.4916|
;;;529    		}
;;;530    
;;;531    		/* First check this chunk is erased, if it needs
;;;532    		 * checking.  The checking policy (unless forced
;;;533    		 * always on) is as follows:
;;;534    		 *
;;;535    		 * Check the first page we try to write in a block.
;;;536    		 * If the check passes then we don't need to check any
;;;537    		 * more.        If the check fails, we check again...
;;;538    		 * If the block has been erased, we don't need to check.
;;;539    		 *
;;;540    		 * However, if the block has been prioritised for gc,
;;;541    		 * then we think there might be something odd about
;;;542    		 * this block and stop using it.
;;;543    		 *
;;;544    		 * Rationale: We should only ever see chunks that have
;;;545    		 * not been erased if there was a partially written
;;;546    		 * chunk due to power loss.  This checking policy should
;;;547    		 * catch that case with very few checks and thus save a
;;;548    		 * lot of checks that are most likely not needed.
;;;549    		 *
;;;550    		 * Mods to the above
;;;551    		 * If an erase check fails or the write fails we skip the
;;;552    		 * rest of the block.
;;;553    		 */
;;;554    
;;;555    		/* let's give it a try */
;;;556    		attempts++;
001334  e2844001          ADD      r4,r4,#1
;;;557    
;;;558    		if (dev->param.always_check_erased)
001338  e5950088          LDR      r0,[r5,#0x88]
00133c  e3500000          CMP      r0,#0
001340  0a000004          BEQ      |L1.4952|
;;;559    			bi->skip_erased_check = 0;
001344  e59d0000          LDR      r0,[sp,#0]
001348  e5900000          LDR      r0,[r0,#0]
00134c  e3c00402          BIC      r0,r0,#0x2000000
001350  e59d1000          LDR      r1,[sp,#0]
001354  e5810000          STR      r0,[r1,#0]
                  |L1.4952|
;;;560    
;;;561    		if (!bi->skip_erased_check) {
001358  e59d0000          LDR      r0,[sp,#0]
00135c  e5900000          LDR      r0,[r0,#0]
001360  e1a00300          LSL      r0,r0,#6
001364  e1b00fa0          LSRS     r0,r0,#31
001368  1a000014          BNE      |L1.5056|
;;;562    			erased_ok = yaffs_check_chunk_erased(dev, chunk);
00136c  e1a01006          MOV      r1,r6
001370  e1a00005          MOV      r0,r5
001374  ebfffffe          BL       yaffs_check_chunk_erased
001378  e1a0b000          MOV      r11,r0
;;;563    			if (erased_ok != YAFFS_OK) {
00137c  e35b0001          CMP      r11,#1
001380  0a00000e          BEQ      |L1.5056|
;;;564    				yaffs_trace(YAFFS_TRACE_ERROR,
001384  e59f020c          LDR      r0,|L1.5528|
001388  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00138c  e3100101          TST      r0,#0x40000000
001390  0a000002          BEQ      |L1.5024|
001394  e1a01006          MOV      r1,r6
001398  e28f0f7f          ADR      r0,|L1.5532|
00139c  ebfffffe          BL       sysprintf
                  |L1.5024|
;;;565    				  "**>> yaffs chunk %d was not erased",
;;;566    				  chunk);
;;;567    
;;;568    				/* If not erased, delete this one,
;;;569    				 * skip rest of block and
;;;570    				 * try another chunk */
;;;571    				yaffs_chunk_del(dev, chunk, 1, __LINE__);
0013a0  e59f3220          LDR      r3,|L1.5576|
0013a4  e3a02001          MOV      r2,#1
0013a8  e1a01006          MOV      r1,r6
0013ac  e1a00005          MOV      r0,r5
0013b0  ebfffffe          BL       yaffs_chunk_del
;;;572    				yaffs_skip_rest_of_block(dev);
0013b4  e1a00005          MOV      r0,r5
0013b8  ebfffffe          BL       yaffs_skip_rest_of_block
;;;573    				continue;
0013bc  ea000022          B        |L1.5196|
                  |L1.5056|
;;;574    			}
;;;575    		}
;;;576    
;;;577    		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
0013c0  e1a03009          MOV      r3,r9
0013c4  e1a02008          MOV      r2,r8
0013c8  e1a01006          MOV      r1,r6
0013cc  e1a00005          MOV      r0,r5
0013d0  ebfffffe          BL       yaffs_wr_chunk_tags_nand
0013d4  e1a07000          MOV      r7,r0
;;;578    
;;;579    		if (!bi->skip_erased_check)
0013d8  e59d0000          LDR      r0,[sp,#0]
0013dc  e5900000          LDR      r0,[r0,#0]
0013e0  e1a00300          LSL      r0,r0,#6
0013e4  e1b00fa0          LSRS     r0,r0,#31
0013e8  1a000005          BNE      |L1.5124|
;;;580    			write_ok =
0013ec  e1a03009          MOV      r3,r9
0013f0  e1a02008          MOV      r2,r8
0013f4  e1a01006          MOV      r1,r6
0013f8  e1a00005          MOV      r0,r5
0013fc  ebfffffe          BL       yaffs_verify_chunk_written
001400  e1a07000          MOV      r7,r0
                  |L1.5124|
;;;581    			    yaffs_verify_chunk_written(dev, chunk, data, tags);
;;;582    
;;;583    		if (write_ok != YAFFS_OK) {
001404  e3570001          CMP      r7,#1
001408  0a000004          BEQ      |L1.5152|
;;;584    			/* Clean up aborted write, skip to next block and
;;;585    			 * try another chunk */
;;;586    			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
00140c  e1a0200b          MOV      r2,r11
001410  e1a01006          MOV      r1,r6
001414  e1a00005          MOV      r0,r5
001418  ebfffffe          BL       yaffs_handle_chunk_wr_error
;;;587    			continue;
00141c  ea00000a          B        |L1.5196|
                  |L1.5152|
;;;588    		}
;;;589    
;;;590    		bi->skip_erased_check = 1;
001420  e59d0000          LDR      r0,[sp,#0]
001424  e5900000          LDR      r0,[r0,#0]
001428  e3800402          ORR      r0,r0,#0x2000000
00142c  e59d1000          LDR      r1,[sp,#0]
001430  e5810000          STR      r0,[r1,#0]
;;;591    
;;;592    		/* Copy the data into the robustification buffer */
;;;593    		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
001434  e1a03009          MOV      r3,r9
001438  e1a02008          MOV      r2,r8
00143c  e1a01006          MOV      r1,r6
001440  e1a00005          MOV      r0,r5
001444  ebfffffe          BL       yaffs_handle_chunk_wr_ok
001448  e1a00000          MOV      r0,r0                 ;573
                  |L1.5196|
;;;594    
;;;595    	} while (write_ok != YAFFS_OK &&
00144c  e3570001          CMP      r7,#1
001450  0a000007          BEQ      |L1.5236|
;;;596    		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
001454  e59f0170          LDR      r0,|L1.5580|
001458  e5900000          LDR      r0,[r0,#0]  ; yaffs_wr_attempts
00145c  e3500000          CMP      r0,#0
001460  0affffa8          BEQ      |L1.4872|
001464  e59f0160          LDR      r0,|L1.5580|
001468  e5900000          LDR      r0,[r0,#0]  ; yaffs_wr_attempts
00146c  e1540000          CMP      r4,r0
001470  9affffa4          BLS      |L1.4872|
                  |L1.5236|
001474  e1a00000          MOV      r0,r0                 ;528
;;;597    
;;;598    	if (!write_ok)
001478  e3570000          CMP      r7,#0
00147c  1a000000          BNE      |L1.5252|
;;;599    		chunk = -1;
001480  e3e06000          MVN      r6,#0
                  |L1.5252|
;;;600    
;;;601    	if (attempts > 1) {
001484  e3540001          CMP      r4,#1
001488  da00000a          BLE      |L1.5304|
;;;602    		yaffs_trace(YAFFS_TRACE_ERROR,
00148c  e59f0104          LDR      r0,|L1.5528|
001490  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
001494  e3100101          TST      r0,#0x40000000
001498  0a000002          BEQ      |L1.5288|
00149c  e1a01004          MOV      r1,r4
0014a0  e28f0f4a          ADR      r0,|L1.5584|
0014a4  ebfffffe          BL       sysprintf
                  |L1.5288|
;;;603    			"**>> yaffs write required %d attempts",
;;;604    			attempts);
;;;605    		dev->n_retried_writes += (attempts - 1);
0014a8  e2441001          SUB      r1,r4,#1
0014ac  e5950e38          LDR      r0,[r5,#0xe38]
0014b0  e0800001          ADD      r0,r0,r1
0014b4  e5850e38          STR      r0,[r5,#0xe38]
                  |L1.5304|
;;;606    	}
;;;607    
;;;608    	return chunk;
0014b8  e1a00006          MOV      r0,r6
;;;609    }
0014bc  e8bd8ff8          POP      {r3-r11,pc}
;;;610    
                          ENDP

                  yaffs_calc_name_sum PROC
;;;658    
;;;659    static u16 yaffs_calc_name_sum(const YCHAR *name)
0014c0  e1a01000          MOV      r1,r0
;;;660    {
;;;661    	u16 sum = 0;
0014c4  e3a03000          MOV      r3,#0
;;;662    	u16 i = 1;
0014c8  e3a02001          MOV      r2,#1
;;;663    
;;;664    	if (!name)
0014cc  e3510000          CMP      r1,#0
0014d0  1a000001          BNE      |L1.5340|
;;;665    		return 0;
0014d4  e3a00000          MOV      r0,#0
                  |L1.5336|
;;;666    
;;;667    	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
;;;668    
;;;669    		/* 0x1f mask is case insensitive */
;;;670    		sum += ((*name) & 0x1f) * i;
;;;671    		i++;
;;;672    		name++;
;;;673    	}
;;;674    	return sum;
;;;675    }
0014d8  e12fff1e          BX       lr
                  |L1.5340|
0014dc  ea000008          B        |L1.5380|
                  |L1.5344|
0014e0  e5d10000          LDRB     r0,[r1,#0]            ;670
0014e4  e200001f          AND      r0,r0,#0x1f           ;670
0014e8  e0203092          MLA      r0,r2,r0,r3           ;670
0014ec  e1a03800          LSL      r3,r0,#16             ;670
0014f0  e1a03823          LSR      r3,r3,#16             ;670
0014f4  e2820001          ADD      r0,r2,#1              ;671
0014f8  e1a02800          LSL      r2,r0,#16             ;671
0014fc  e1a02822          LSR      r2,r2,#16             ;671
001500  e2811001          ADD      r1,r1,#1              ;672
                  |L1.5380|
001504  e5d10000          LDRB     r0,[r1,#0]            ;667
001508  e3500000          CMP      r0,#0                 ;667
00150c  0a000001          BEQ      |L1.5400|
001510  e352007f          CMP      r2,#0x7f              ;667
001514  bafffff1          BLT      |L1.5344|
                  |L1.5400|
001518  e1a00003          MOV      r0,r3                 ;674
00151c  eaffffed          B        |L1.5336|
;;;676    
                          ENDP

                  yaffs_set_obj_name PROC
;;;677    void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
001520  e92d4070          PUSH     {r4-r6,lr}
;;;678    {
001524  e1a04000          MOV      r4,r0
001528  e1a05001          MOV      r5,r1
;;;679    	memset(obj->short_name, 0, sizeof(obj->short_name));
00152c  e3a00000          MOV      r0,#0
001530  e5840038          STR      r0,[r4,#0x38]
001534  e584003c          STR      r0,[r4,#0x3c]
001538  e5840040          STR      r0,[r4,#0x40]
00153c  e5840044          STR      r0,[r4,#0x44]
;;;680    	if (name &&
001540  e3550000          CMP      r5,#0
001544  0a00000d          BEQ      |L1.5504|
;;;681    		yaffs_strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
001548  e1a00005          MOV      r0,r5
00154c  ebfffffe          BL       strlen
001550  e3500010          CMP      r0,#0x10
001554  9a000001          BLS      |L1.5472|
001558  e3a00010          MOV      r0,#0x10
00155c  ea000001          B        |L1.5480|
                  |L1.5472|
001560  e1a00005          MOV      r0,r5
001564  ebfffffe          BL       strlen
                  |L1.5480|
001568  e350000f          CMP      r0,#0xf
00156c  8a000003          BHI      |L1.5504|
;;;682    		YAFFS_SHORT_NAME_LENGTH)
;;;683    		yaffs_strcpy(obj->short_name, name);
001570  e1a01005          MOV      r1,r5
001574  e2840038          ADD      r0,r4,#0x38
001578  ebfffffe          BL       strcpy
00157c  ea000001          B        |L1.5512|
                  |L1.5504|
;;;684    	else
;;;685    		obj->short_name[0] = _Y('\0');
001580  e3a00000          MOV      r0,#0
001584  e5c40038          STRB     r0,[r4,#0x38]
                  |L1.5512|
;;;686    	obj->sum = yaffs_calc_name_sum(name);
001588  e1a00005          MOV      r0,r5
00158c  ebfffffe          BL       yaffs_calc_name_sum
001590  e1c400b4          STRH     r0,[r4,#4]
;;;687    }
001594  e8bd8070          POP      {r4-r6,pc}
                  |L1.5528|
                          DCD      yaffs_trace_mask
                  |L1.5532|
00159c  79616666          DCB      "yaffs: **>> yaffs chunk %d was not erased\n",0
0015a0  733a202a
0015a4  2a3e3e20
0015a8  79616666
0015ac  73206368
0015b0  756e6b20
0015b4  25642077
0015b8  6173206e
0015bc  6f742065
0015c0  72617365
0015c4  640a00  
0015c7  00                DCB      0
                  |L1.5576|
                          DCD      0x0000023b
                  |L1.5580|
                          DCD      yaffs_wr_attempts
                  |L1.5584|
0015d0  79616666          DCB      "yaffs: **>> yaffs write required %d attempts\n",0
0015d4  733a202a
0015d8  2a3e3e20
0015dc  79616666
0015e0  73207772
0015e4  69746520
0015e8  72657175
0015ec  69726564
0015f0  20256420
0015f4  61747465
0015f8  6d707473
0015fc  0a00    
0015fe  00                DCB      0
0015ff  00                DCB      0
                          ENDP

                  yaffs_set_obj_name_from_oh PROC
;;;688    
;;;689    void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
001600  e92d4070          PUSH     {r4-r6,lr}
;;;690    				const struct yaffs_obj_hdr *oh)
;;;691    {
001604  e1a05000          MOV      r5,r0
001608  e1a04001          MOV      r4,r1
;;;692    #ifdef CONFIG_YAFFS_AUTO_UNICODE
;;;693    	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
;;;694    	memset(tmp_name, 0, sizeof(tmp_name));
;;;695    	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
;;;696    				YAFFS_MAX_NAME_LENGTH + 1);
;;;697    	yaffs_set_obj_name(obj, tmp_name);
;;;698    #else
;;;699    	yaffs_set_obj_name(obj, oh->name);
00160c  e284100a          ADD      r1,r4,#0xa
001610  e1a00005          MOV      r0,r5
001614  ebfffffe          BL       yaffs_set_obj_name
;;;700    #endif
;;;701    }
001618  e8bd8070          POP      {r4-r6,pc}
;;;702    
                          ENDP

                  yaffs_max_file_size PROC
;;;703    loff_t yaffs_max_file_size(struct yaffs_dev *dev)
00161c  e1a02000          MOV      r2,r0
;;;704    {
;;;705    	return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
001620  e3e0320f          MVN      r3,#0xf0000000
001624  e59200a4          LDR      r0,[r2,#0xa4]
001628  e0c10093          SMULL    r0,r1,r3,r0
;;;706    }
00162c  e12fff1e          BX       lr
;;;707    
                          ENDP

                  yaffs_get_tnode PROC
;;;714    
;;;715    struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
001630  e92d4070          PUSH     {r4-r6,lr}
;;;716    {
001634  e1a04000          MOV      r4,r0
;;;717    	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
001638  e1a00004          MOV      r0,r4
00163c  ebfffffe          BL       yaffs_alloc_raw_tnode
001640  e1a05000          MOV      r5,r0
;;;718    
;;;719    	if (tn) {
001644  e3550000          CMP      r5,#0
001648  0a000005          BEQ      |L1.5732|
;;;720    		memset(tn, 0, dev->tnode_size);
00164c  e1a00005          MOV      r0,r5
001650  e59410b4          LDR      r1,[r4,#0xb4]
001654  ebfffffe          BL       __aeabi_memclr4
;;;721    		dev->n_tnodes++;
001658  e5940140          LDR      r0,[r4,#0x140]
00165c  e2800001          ADD      r0,r0,#1
001660  e5840140          STR      r0,[r4,#0x140]
                  |L1.5732|
;;;722    	}
;;;723    
;;;724    	dev->checkpoint_blocks_required = 0;	/* force recalculation */
001664  e3a00000          MOV      r0,#0
001668  e5840114          STR      r0,[r4,#0x114]
;;;725    
;;;726    	return tn;
00166c  e1a00005          MOV      r0,r5
;;;727    }
001670  e8bd8070          POP      {r4-r6,pc}
;;;728    
                          ENDP

                  yaffs_free_tnode PROC
;;;729    /* FreeTnode frees up a tnode and puts it back on the free list */
;;;730    static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
001674  e92d4070          PUSH     {r4-r6,lr}
;;;731    {
001678  e1a04000          MOV      r4,r0
00167c  e1a05001          MOV      r5,r1
;;;732    	yaffs_free_raw_tnode(dev, tn);
001680  e1a01005          MOV      r1,r5
001684  e1a00004          MOV      r0,r4
001688  ebfffffe          BL       yaffs_free_raw_tnode
;;;733    	dev->n_tnodes--;
00168c  e5940140          LDR      r0,[r4,#0x140]
001690  e2400001          SUB      r0,r0,#1
001694  e5840140          STR      r0,[r4,#0x140]
;;;734    	dev->checkpoint_blocks_required = 0;	/* force recalculation */
001698  e3a00000          MOV      r0,#0
00169c  e5840114          STR      r0,[r4,#0x114]
;;;735    }
0016a0  e8bd8070          POP      {r4-r6,pc}
;;;736    
                          ENDP

                  yaffs_deinit_tnodes_and_objs PROC
;;;737    static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
0016a4  e92d4010          PUSH     {r4,lr}
;;;738    {
0016a8  e1a04000          MOV      r4,r0
;;;739    	yaffs_deinit_raw_tnodes_and_objs(dev);
0016ac  e1a00004          MOV      r0,r4
0016b0  ebfffffe          BL       yaffs_deinit_raw_tnodes_and_objs
;;;740    	dev->n_obj = 0;
0016b4  e3a00000          MOV      r0,#0
0016b8  e584013c          STR      r0,[r4,#0x13c]
;;;741    	dev->n_tnodes = 0;
0016bc  e5840140          STR      r0,[r4,#0x140]
;;;742    }
0016c0  e8bd8010          POP      {r4,pc}
;;;743    
                          ENDP

                  yaffs_load_tnode_0 PROC
;;;744    void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
0016c4  e92d43f0          PUSH     {r4-r9,lr}
;;;745    			unsigned pos, unsigned val)
;;;746    {
0016c8  e1a0c000          MOV      r12,r0
0016cc  e1a04001          MOV      r4,r1
0016d0  e1a06002          MOV      r6,r2
;;;747    	u32 *map = (u32 *) tn;
0016d4  e1a01004          MOV      r1,r4
;;;748    	u32 bit_in_map;
;;;749    	u32 bit_in_word;
;;;750    	u32 word_in_map;
;;;751    	u32 mask;
;;;752    
;;;753    	pos &= YAFFS_TNODES_LEVEL0_MASK;
0016d8  e206600f          AND      r6,r6,#0xf
;;;754    	val >>= dev->chunk_grp_bits;
0016dc  e5dc80a8          LDRB     r8,[r12,#0xa8]
0016e0  e1a03833          LSR      r3,r3,r8
;;;755    
;;;756    	bit_in_map = pos * dev->tnode_width;
0016e4  e59c80ac          LDR      r8,[r12,#0xac]
0016e8  e0070698          MUL      r7,r8,r6
;;;757    	word_in_map = bit_in_map / 32;
0016ec  e1a002a7          LSR      r0,r7,#5
;;;758    	bit_in_word = bit_in_map & (32 - 1);
0016f0  e207201f          AND      r2,r7,#0x1f
;;;759    
;;;760    	mask = dev->tnode_mask << bit_in_word;
0016f4  e59c80b0          LDR      r8,[r12,#0xb0]
0016f8  e1a05218          LSL      r5,r8,r2
;;;761    
;;;762    	map[word_in_map] &= ~mask;
0016fc  e7918100          LDR      r8,[r1,r0,LSL #2]
001700  e1c88005          BIC      r8,r8,r5
001704  e7818100          STR      r8,[r1,r0,LSL #2]
;;;763    	map[word_in_map] |= (mask & (val << bit_in_word));
001708  e7918100          LDR      r8,[r1,r0,LSL #2]
00170c  e0059213          AND      r9,r5,r3,LSL r2
001710  e1888009          ORR      r8,r8,r9
001714  e7818100          STR      r8,[r1,r0,LSL #2]
;;;764    
;;;765    	if (dev->tnode_width > (32 - bit_in_word)) {
001718  e2629020          RSB      r9,r2,#0x20
00171c  e59c80ac          LDR      r8,[r12,#0xac]
001720  e1580009          CMP      r8,r9
001724  9a00000b          BLS      |L1.5976|
;;;766    		bit_in_word = (32 - bit_in_word);
001728  e2622020          RSB      r2,r2,#0x20
;;;767    		word_in_map++;
00172c  e2800001          ADD      r0,r0,#1
;;;768    		mask =
001730  e59c80b0          LDR      r8,[r12,#0xb0]
001734  e1a05238          LSR      r5,r8,r2
;;;769    		    dev->tnode_mask >> bit_in_word;
;;;770    		map[word_in_map] &= ~mask;
001738  e7918100          LDR      r8,[r1,r0,LSL #2]
00173c  e1c88005          BIC      r8,r8,r5
001740  e7818100          STR      r8,[r1,r0,LSL #2]
;;;771    		map[word_in_map] |= (mask & (val >> bit_in_word));
001744  e7918100          LDR      r8,[r1,r0,LSL #2]
001748  e1a09233          LSR      r9,r3,r2
00174c  e0099005          AND      r9,r9,r5
001750  e1888009          ORR      r8,r8,r9
001754  e7818100          STR      r8,[r1,r0,LSL #2]
                  |L1.5976|
;;;772    	}
;;;773    }
001758  e8bd83f0          POP      {r4-r9,pc}
;;;774    
                          ENDP

                  yaffs_get_group_base PROC
;;;775    u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
00175c  e92d41f0          PUSH     {r4-r8,lr}
;;;776    			 unsigned pos)
;;;777    {
001760  e1a03000          MOV      r3,r0
001764  e1a0c001          MOV      r12,r1
;;;778    	u32 *map = (u32 *) tn;
001768  e1a0600c          MOV      r6,r12
;;;779    	u32 bit_in_map;
;;;780    	u32 bit_in_word;
;;;781    	u32 word_in_map;
;;;782    	u32 val;
;;;783    
;;;784    	pos &= YAFFS_TNODES_LEVEL0_MASK;
00176c  e202200f          AND      r2,r2,#0xf
;;;785    
;;;786    	bit_in_map = pos * dev->tnode_width;
001770  e59370ac          LDR      r7,[r3,#0xac]
001774  e0050297          MUL      r5,r7,r2
;;;787    	word_in_map = bit_in_map / 32;
001778  e1a042a5          LSR      r4,r5,#5
;;;788    	bit_in_word = bit_in_map & (32 - 1);
00177c  e205101f          AND      r1,r5,#0x1f
;;;789    
;;;790    	val = map[word_in_map] >> bit_in_word;
001780  e7967104          LDR      r7,[r6,r4,LSL #2]
001784  e1a00137          LSR      r0,r7,r1
;;;791    
;;;792    	if (dev->tnode_width > (32 - bit_in_word)) {
001788  e2618020          RSB      r8,r1,#0x20
00178c  e59370ac          LDR      r7,[r3,#0xac]
001790  e1570008          CMP      r7,r8
001794  9a000003          BLS      |L1.6056|
;;;793    		bit_in_word = (32 - bit_in_word);
001798  e2611020          RSB      r1,r1,#0x20
;;;794    		word_in_map++;
00179c  e2844001          ADD      r4,r4,#1
;;;795    		val |= (map[word_in_map] << bit_in_word);
0017a0  e7967104          LDR      r7,[r6,r4,LSL #2]
0017a4  e1800117          ORR      r0,r0,r7,LSL r1
                  |L1.6056|
;;;796    	}
;;;797    
;;;798    	val &= dev->tnode_mask;
0017a8  e59370b0          LDR      r7,[r3,#0xb0]
0017ac  e0000007          AND      r0,r0,r7
;;;799    	val <<= dev->chunk_grp_bits;
0017b0  e5d370a8          LDRB     r7,[r3,#0xa8]
0017b4  e1a00710          LSL      r0,r0,r7
;;;800    
;;;801    	return val;
;;;802    }
0017b8  e8bd81f0          POP      {r4-r8,pc}
;;;803    
                          ENDP

                  yaffs_find_tnode_0 PROC
;;;811    /* FindLevel0Tnode finds the level 0 tnode, if one exists. */
;;;812    struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
0017bc  e92d4070          PUSH     {r4-r6,lr}
;;;813    				       struct yaffs_file_var *file_struct,
;;;814    				       u32 chunk_id)
;;;815    {
0017c0  e1a06000          MOV      r6,r0
0017c4  e1a03001          MOV      r3,r1
;;;816    	struct yaffs_tnode *tn = file_struct->top;
0017c8  e593c01c          LDR      r12,[r3,#0x1c]
;;;817    	u32 i;
;;;818    	int required_depth;
;;;819    	int level = file_struct->top_level;
0017cc  e5931018          LDR      r1,[r3,#0x18]
;;;820    
;;;821    	dev = dev;
0017d0  e1a00000          MOV      r0,r0
;;;822    
;;;823    	/* Check sane level and chunk Id */
;;;824    	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
0017d4  e3510000          CMP      r1,#0
0017d8  ba000001          BLT      |L1.6116|
0017dc  e3510008          CMP      r1,#8
0017e0  da000001          BLE      |L1.6124|
                  |L1.6116|
;;;825    		return NULL;
0017e4  e3a00000          MOV      r0,#0
                  |L1.6120|
;;;826    
;;;827    	if (chunk_id > YAFFS_MAX_CHUNK_ID)
;;;828    		return NULL;
;;;829    
;;;830    	/* First check we're tall enough (ie enough top_level) */
;;;831    
;;;832    	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
;;;833    	required_depth = 0;
;;;834    	while (i) {
;;;835    		i >>= YAFFS_TNODES_INTERNAL_BITS;
;;;836    		required_depth++;
;;;837    	}
;;;838    
;;;839    	if (required_depth > file_struct->top_level)
;;;840    		return NULL;	/* Not tall enough, so we can't find it */
;;;841    
;;;842    	/* Traverse down to level 0 */
;;;843    	while (level > 0 && tn) {
;;;844    		tn = tn->internal[(chunk_id >>
;;;845    				   (YAFFS_TNODES_LEVEL0_BITS +
;;;846    				    (level - 1) *
;;;847    				    YAFFS_TNODES_INTERNAL_BITS)) &
;;;848    				  YAFFS_TNODES_INTERNAL_MASK];
;;;849    		level--;
;;;850    	}
;;;851    
;;;852    	return tn;
;;;853    }
0017e8  e8bd8070          POP      {r4-r6,pc}
                  |L1.6124|
0017ec  e372021f          CMN      r2,#0xf0000001        ;827
0017f0  9a000001          BLS      |L1.6140|
0017f4  e3a00000          MOV      r0,#0                 ;828
0017f8  eafffffa          B        |L1.6120|
                  |L1.6140|
0017fc  e1a04222          LSR      r4,r2,#4              ;832
001800  e3a05000          MOV      r5,#0                 ;833
001804  ea000001          B        |L1.6160|
                  |L1.6152|
001808  e1a041a4          LSR      r4,r4,#3              ;835
00180c  e2855001          ADD      r5,r5,#1              ;836
                  |L1.6160|
001810  e3540000          CMP      r4,#0                 ;834
001814  1afffffb          BNE      |L1.6152|
001818  e5930018          LDR      r0,[r3,#0x18]         ;839
00181c  e1500005          CMP      r0,r5                 ;839
001820  aa000001          BGE      |L1.6188|
001824  e3a00000          MOV      r0,#0                 ;840
001828  eaffffee          B        |L1.6120|
                  |L1.6188|
00182c  ea000006          B        |L1.6220|
                  |L1.6192|
001830  e2410001          SUB      r0,r1,#1              ;844
001834  e0800080          ADD      r0,r0,r0,LSL #1       ;844
001838  e2800004          ADD      r0,r0,#4              ;844
00183c  e1a00032          LSR      r0,r2,r0              ;844
001840  e2000007          AND      r0,r0,#7              ;844
001844  e79cc100          LDR      r12,[r12,r0,LSL #2]   ;844
001848  e2411001          SUB      r1,r1,#1              ;849
                  |L1.6220|
00184c  e3510000          CMP      r1,#0                 ;843
001850  da000001          BLE      |L1.6236|
001854  e35c0000          CMP      r12,#0                ;843
001858  1afffff4          BNE      |L1.6192|
                  |L1.6236|
00185c  e1a0000c          MOV      r0,r12                ;852
001860  eaffffe0          B        |L1.6120|
;;;854    
                          ENDP

                  yaffs_add_find_tnode_0 PROC
;;;866    
;;;867    struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
001864  e92d5fff          PUSH     {r0-r12,lr}
;;;868    					   struct yaffs_file_var *file_struct,
;;;869    					   u32 chunk_id,
;;;870    					   struct yaffs_tnode *passed_tn)
;;;871    {
001868  e1a06001          MOV      r6,r1
00186c  e1a09002          MOV      r9,r2
001870  e1a08003          MOV      r8,r3
;;;872    	int required_depth;
;;;873    	int i;
;;;874    	int l;
;;;875    	struct yaffs_tnode *tn;
;;;876    	u32 x;
;;;877    
;;;878    	/* Check sane level and page Id */
;;;879    	if (file_struct->top_level < 0 ||
001874  e5960018          LDR      r0,[r6,#0x18]
001878  e3500000          CMP      r0,#0
00187c  ba000002          BLT      |L1.6284|
;;;880    	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
001880  e5960018          LDR      r0,[r6,#0x18]
001884  e3500008          CMP      r0,#8
001888  da000002          BLE      |L1.6296|
                  |L1.6284|
;;;881    		return NULL;
00188c  e3a00000          MOV      r0,#0
                  |L1.6288|
001890  e28dd010          ADD      sp,sp,#0x10
;;;882    
;;;883    	if (chunk_id > YAFFS_MAX_CHUNK_ID)
;;;884    		return NULL;
;;;885    
;;;886    	/* First check we're tall enough (ie enough top_level) */
;;;887    
;;;888    	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
;;;889    	required_depth = 0;
;;;890    	while (x) {
;;;891    		x >>= YAFFS_TNODES_INTERNAL_BITS;
;;;892    		required_depth++;
;;;893    	}
;;;894    
;;;895    	if (required_depth > file_struct->top_level) {
;;;896    		/* Not tall enough, gotta make the tree taller */
;;;897    		for (i = file_struct->top_level; i < required_depth; i++) {
;;;898    
;;;899    			tn = yaffs_get_tnode(dev);
;;;900    
;;;901    			if (tn) {
;;;902    				tn->internal[0] = file_struct->top;
;;;903    				file_struct->top = tn;
;;;904    				file_struct->top_level++;
;;;905    			} else {
;;;906    				yaffs_trace(YAFFS_TRACE_ERROR,
;;;907    					"yaffs: no more tnodes");
;;;908    				return NULL;
;;;909    			}
;;;910    		}
;;;911    	}
;;;912    
;;;913    	/* Traverse down to level 0, adding anything we need */
;;;914    
;;;915    	l = file_struct->top_level;
;;;916    	tn = file_struct->top;
;;;917    
;;;918    	if (l > 0) {
;;;919    		while (l > 0 && tn) {
;;;920    			x = (chunk_id >>
;;;921    			     (YAFFS_TNODES_LEVEL0_BITS +
;;;922    			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
;;;923    			    YAFFS_TNODES_INTERNAL_MASK;
;;;924    
;;;925    			if ((l > 1) && !tn->internal[x]) {
;;;926    				/* Add missing non-level-zero tnode */
;;;927    				tn->internal[x] = yaffs_get_tnode(dev);
;;;928    				if (!tn->internal[x])
;;;929    					return NULL;
;;;930    			} else if (l == 1) {
;;;931    				/* Looking from level 1 at level 0 */
;;;932    				if (passed_tn) {
;;;933    					/* If we already have one, release it */
;;;934    					if (tn->internal[x])
;;;935    						yaffs_free_tnode(dev,
;;;936    							tn->internal[x]);
;;;937    					tn->internal[x] = passed_tn;
;;;938    
;;;939    				} else if (!tn->internal[x]) {
;;;940    					/* Don't have one, none passed in */
;;;941    					tn->internal[x] = yaffs_get_tnode(dev);
;;;942    					if (!tn->internal[x])
;;;943    						return NULL;
;;;944    				}
;;;945    			}
;;;946    
;;;947    			tn = tn->internal[x];
;;;948    			l--;
;;;949    		}
;;;950    	} else {
;;;951    		/* top is level 0 */
;;;952    		if (passed_tn) {
;;;953    			memcpy(tn, passed_tn,
;;;954    			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
;;;955    			yaffs_free_tnode(dev, passed_tn);
;;;956    		}
;;;957    	}
;;;958    
;;;959    	return tn;
;;;960    }
001894  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.6296|
001898  e379021f          CMN      r9,#0xf0000001        ;883
00189c  9a000001          BLS      |L1.6312|
0018a0  e3a00000          MOV      r0,#0                 ;884
0018a4  eafffff9          B        |L1.6288|
                  |L1.6312|
0018a8  e1a05229          LSR      r5,r9,#4              ;888
0018ac  e3a0a000          MOV      r10,#0                ;889
0018b0  ea000001          B        |L1.6332|
                  |L1.6324|
0018b4  e1a051a5          LSR      r5,r5,#3              ;891
0018b8  e28aa001          ADD      r10,r10,#1            ;892
                  |L1.6332|
0018bc  e3550000          CMP      r5,#0                 ;890
0018c0  1afffffb          BNE      |L1.6324|
0018c4  e5960018          LDR      r0,[r6,#0x18]         ;895
0018c8  e150000a          CMP      r0,r10                ;895
0018cc  aa000018          BGE      |L1.6452|
0018d0  e596b018          LDR      r11,[r6,#0x18]        ;897
0018d4  ea000014          B        |L1.6444|
                  |L1.6360|
0018d8  e59d0000          LDR      r0,[sp,#0]            ;899
0018dc  ebfffffe          BL       yaffs_get_tnode
0018e0  e1a04000          MOV      r4,r0                 ;899
0018e4  e3540000          CMP      r4,#0                 ;901
0018e8  0a000006          BEQ      |L1.6408|
0018ec  e596001c          LDR      r0,[r6,#0x1c]         ;902
0018f0  e5840000          STR      r0,[r4,#0]            ;902
0018f4  e586401c          STR      r4,[r6,#0x1c]         ;903
0018f8  e5960018          LDR      r0,[r6,#0x18]         ;904
0018fc  e2800001          ADD      r0,r0,#1              ;904
001900  e5860018          STR      r0,[r6,#0x18]         ;904
001904  ea000007          B        |L1.6440|
                  |L1.6408|
001908  e51f0378          LDR      r0,|L1.5528|
00190c  e5900000          LDR      r0,[r0,#0]            ;906  ; yaffs_trace_mask
001910  e3100101          TST      r0,#0x40000000        ;906
001914  0a000001          BEQ      |L1.6432|
001918  e28f0f87          ADR      r0,|L1.6972|
00191c  ebfffffe          BL       sysprintf
                  |L1.6432|
001920  e3a00000          MOV      r0,#0                 ;908
001924  eaffffd9          B        |L1.6288|
                  |L1.6440|
001928  e28bb001          ADD      r11,r11,#1            ;897
                  |L1.6444|
00192c  e15b000a          CMP      r11,r10               ;897
001930  baffffe8          BLT      |L1.6360|
                  |L1.6452|
001934  e5967018          LDR      r7,[r6,#0x18]         ;915
001938  e596401c          LDR      r4,[r6,#0x1c]         ;916
00193c  e3570000          CMP      r7,#0                 ;918
001940  da000030          BLE      |L1.6664|
001944  ea00002a          B        |L1.6644|
                  |L1.6472|
001948  e2470001          SUB      r0,r7,#1              ;920
00194c  e0800080          ADD      r0,r0,r0,LSL #1       ;920
001950  e2800004          ADD      r0,r0,#4              ;920
001954  e1a00039          LSR      r0,r9,r0              ;920
001958  e2005007          AND      r5,r0,#7              ;920
00195c  e3570001          CMP      r7,#1                 ;925
001960  da00000a          BLE      |L1.6544|
001964  e7940105          LDR      r0,[r4,r5,LSL #2]     ;925
001968  e3500000          CMP      r0,#0                 ;925
00196c  1a000007          BNE      |L1.6544|
001970  e59d0000          LDR      r0,[sp,#0]            ;927
001974  ebfffffe          BL       yaffs_get_tnode
001978  e7840105          STR      r0,[r4,r5,LSL #2]     ;927
00197c  e7940105          LDR      r0,[r4,r5,LSL #2]     ;928
001980  e3500000          CMP      r0,#0                 ;928
001984  1a000018          BNE      |L1.6636|
001988  e3a00000          MOV      r0,#0                 ;929
00198c  eaffffbf          B        |L1.6288|
                  |L1.6544|
001990  e3570001          CMP      r7,#1                 ;930
001994  1a000014          BNE      |L1.6636|
001998  e3580000          CMP      r8,#0                 ;932
00199c  0a000007          BEQ      |L1.6592|
0019a0  e7940105          LDR      r0,[r4,r5,LSL #2]     ;934
0019a4  e3500000          CMP      r0,#0                 ;934
0019a8  0a000002          BEQ      |L1.6584|
0019ac  e7941105          LDR      r1,[r4,r5,LSL #2]     ;935
0019b0  e59d0000          LDR      r0,[sp,#0]            ;935
0019b4  ebfffffe          BL       yaffs_free_tnode
                  |L1.6584|
0019b8  e7848105          STR      r8,[r4,r5,LSL #2]     ;937
0019bc  ea00000a          B        |L1.6636|
                  |L1.6592|
0019c0  e7940105          LDR      r0,[r4,r5,LSL #2]     ;939
0019c4  e3500000          CMP      r0,#0                 ;939
0019c8  1a000007          BNE      |L1.6636|
0019cc  e59d0000          LDR      r0,[sp,#0]            ;941
0019d0  ebfffffe          BL       yaffs_get_tnode
0019d4  e7840105          STR      r0,[r4,r5,LSL #2]     ;941
0019d8  e7940105          LDR      r0,[r4,r5,LSL #2]     ;942
0019dc  e3500000          CMP      r0,#0                 ;942
0019e0  1a000001          BNE      |L1.6636|
0019e4  e3a00000          MOV      r0,#0                 ;943
0019e8  eaffffa8          B        |L1.6288|
                  |L1.6636|
0019ec  e7944105          LDR      r4,[r4,r5,LSL #2]     ;947
0019f0  e2477001          SUB      r7,r7,#1              ;948
                  |L1.6644|
0019f4  e3570000          CMP      r7,#0                 ;919
0019f8  da00000e          BLE      |L1.6712|
0019fc  e3540000          CMP      r4,#0                 ;919
001a00  1affffd0          BNE      |L1.6472|
001a04  ea00000b          B        |L1.6712|
                  |L1.6664|
001a08  e3580000          CMP      r8,#0                 ;952
001a0c  0a000009          BEQ      |L1.6712|
001a10  e59d0000          LDR      r0,[sp,#0]            ;953
001a14  e59000ac          LDR      r0,[r0,#0xac]         ;953
001a18  e1a00200          LSL      r0,r0,#4              ;953
001a1c  e1a021a0          LSR      r2,r0,#3              ;953
001a20  e1a01008          MOV      r1,r8                 ;953
001a24  e1a00004          MOV      r0,r4                 ;953
001a28  ebfffffe          BL       __aeabi_memcpy4
001a2c  e1a01008          MOV      r1,r8                 ;955
001a30  e59d0000          LDR      r0,[sp,#0]            ;955
001a34  ebfffffe          BL       yaffs_free_tnode
                  |L1.6712|
001a38  e1a00004          MOV      r0,r4                 ;959
001a3c  eaffff93          B        |L1.6288|
;;;961    
                          ENDP

                  yaffs_tags_match PROC
;;;962    static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
001a40  e1a03000          MOV      r3,r0
;;;963    			    int chunk_obj)
;;;964    {
;;;965    	return (tags->chunk_id == chunk_obj &&
001a44  e5930008          LDR      r0,[r3,#8]
001a48  e1500002          CMP      r0,r2
001a4c  1a000007          BNE      |L1.6768|
;;;966    		tags->obj_id == obj_id &&
001a50  e5930004          LDR      r0,[r3,#4]
001a54  e1500001          CMP      r0,r1
001a58  1a000004          BNE      |L1.6768|
;;;967    		!tags->is_deleted) ? 1 : 0;
001a5c  e5930018          LDR      r0,[r3,#0x18]
001a60  e3500000          CMP      r0,#0
001a64  1a000001          BNE      |L1.6768|
001a68  e3a00001          MOV      r0,#1
                  |L1.6764|
;;;968    
;;;969    }
001a6c  e12fff1e          BX       lr
                  |L1.6768|
001a70  e3a00000          MOV      r0,#0                 ;967
001a74  eafffffc          B        |L1.6764|
;;;970    
                          ENDP

                  yaffs_find_chunk_in_group PROC
;;;971    static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
001a78  e92d5ff0          PUSH     {r4-r12,lr}
;;;972    					struct yaffs_ext_tags *tags, int obj_id,
;;;973    					int inode_chunk)
;;;974    {
001a7c  e1a04000          MOV      r4,r0
001a80  e1a05001          MOV      r5,r1
001a84  e1a06002          MOV      r6,r2
001a88  e1a07003          MOV      r7,r3
001a8c  e59d9028          LDR      r9,[sp,#0x28]
;;;975    	int j;
;;;976    
;;;977    	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
001a90  e3a08000          MOV      r8,#0
001a94  ea000021          B        |L1.6944|
                  |L1.6808|
;;;978    		if (yaffs_check_chunk_bit
001a98  e1a00005          MOV      r0,r5
001a9c  e594100c          LDR      r1,[r4,#0xc]
001aa0  ebfffffe          BL       __aeabi_idivmod
001aa4  e1a0a001          MOV      r10,r1
001aa8  e1a00005          MOV      r0,r5
001aac  e594100c          LDR      r1,[r4,#0xc]
001ab0  ebfffffe          BL       __aeabi_idivmod
001ab4  e1a0b000          MOV      r11,r0
001ab8  e1a0200a          MOV      r2,r10
001abc  e1a0100b          MOV      r1,r11
001ac0  e1a00004          MOV      r0,r4
001ac4  ebfffffe          BL       yaffs_check_chunk_bit
001ac8  e3500000          CMP      r0,#0
001acc  0a000011          BEQ      |L1.6936|
;;;979    		    (dev, the_chunk / dev->param.chunks_per_block,
;;;980    		     the_chunk % dev->param.chunks_per_block)) {
;;;981    
;;;982    			if (dev->chunk_grp_size == 1)
001ad0  e1d40aba          LDRH     r0,[r4,#0xaa]
001ad4  e3500001          CMP      r0,#1
001ad8  1a000001          BNE      |L1.6884|
;;;983    				return the_chunk;
001adc  e1a00005          MOV      r0,r5
                  |L1.6880|
;;;984    			else {
;;;985    				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
;;;986    							 tags);
;;;987    				if (yaffs_tags_match(tags,
;;;988    							obj_id, inode_chunk)) {
;;;989    					/* found it; */
;;;990    					return the_chunk;
;;;991    				}
;;;992    			}
;;;993    		}
;;;994    		the_chunk++;
;;;995    	}
;;;996    	return -1;
;;;997    }
001ae0  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.6884|
001ae4  e1a03006          MOV      r3,r6                 ;985
001ae8  e3a02000          MOV      r2,#0                 ;985
001aec  e1a01005          MOV      r1,r5                 ;985
001af0  e1a00004          MOV      r0,r4                 ;985
001af4  ebfffffe          BL       yaffs_rd_chunk_tags_nand
001af8  e1a02009          MOV      r2,r9                 ;987
001afc  e1a01007          MOV      r1,r7                 ;987
001b00  e1a00006          MOV      r0,r6                 ;987
001b04  ebfffffe          BL       yaffs_tags_match
001b08  e3500000          CMP      r0,#0                 ;987
001b0c  0a000001          BEQ      |L1.6936|
001b10  e1a00005          MOV      r0,r5                 ;990
001b14  eafffff1          B        |L1.6880|
                  |L1.6936|
001b18  e2855001          ADD      r5,r5,#1              ;994
001b1c  e2888001          ADD      r8,r8,#1              ;977
                  |L1.6944|
001b20  e3550000          CMP      r5,#0                 ;977
001b24  0a000002          BEQ      |L1.6964|
001b28  e1d40aba          LDRH     r0,[r4,#0xaa]         ;977
001b2c  e1500008          CMP      r0,r8                 ;977
001b30  caffffd8          BGT      |L1.6808|
                  |L1.6964|
001b34  e3e00000          MVN      r0,#0                 ;996
001b38  eaffffe8          B        |L1.6880|
                  |L1.6972|
001b3c  79616666          DCB      "yaffs: yaffs: no more tnodes\n",0
001b40  733a2079
001b44  61666673
001b48  3a206e6f
001b4c  206d6f72
001b50  6520746e
001b54  6f646573
001b58  0a00    
001b5a  00                DCB      0
001b5b  00                DCB      0
                          ENDP

                  yaffs_find_chunk_in_file PROC
;;;998    
;;;999    static int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
001b5c  e92d47f0          PUSH     {r4-r10,lr}
;;;1000   				    struct yaffs_ext_tags *tags)
;;;1001   {
001b60  e24dd050          SUB      sp,sp,#0x50
001b64  e1a04000          MOV      r4,r0
001b68  e1a06001          MOV      r6,r1
001b6c  e1a07002          MOV      r7,r2
;;;1002   	/*Get the Tnode, then get the level 0 offset chunk offset */
;;;1003   	struct yaffs_tnode *tn;
;;;1004   	int the_chunk = -1;
001b70  e3e08000          MVN      r8,#0
;;;1005   	struct yaffs_ext_tags local_tags;
;;;1006   	int ret_val = -1;
001b74  e3e09000          MVN      r9,#0
;;;1007   	struct yaffs_dev *dev = in->my_dev;
001b78  e594a008          LDR      r10,[r4,#8]
;;;1008   
;;;1009   	if (!tags) {
001b7c  e3570000          CMP      r7,#0
001b80  1a000000          BNE      |L1.7048|
;;;1010   		/* Passed a NULL, so use our own tags space */
;;;1011   		tags = &local_tags;
001b84  e28d7008          ADD      r7,sp,#8
                  |L1.7048|
;;;1012   	}
;;;1013   
;;;1014   	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
001b88  e1a02006          MOV      r2,r6
001b8c  e2841068          ADD      r1,r4,#0x68
001b90  e1a0000a          MOV      r0,r10
001b94  ebfffffe          BL       yaffs_find_tnode_0
001b98  e1a05000          MOV      r5,r0
;;;1015   
;;;1016   	if (!tn)
001b9c  e3550000          CMP      r5,#0
001ba0  1a000002          BNE      |L1.7088|
;;;1017   		return ret_val;
001ba4  e1a00009          MOV      r0,r9
                  |L1.7080|
001ba8  e28dd050          ADD      sp,sp,#0x50
;;;1018   
;;;1019   	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
;;;1020   
;;;1021   	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
;;;1022   					      inode_chunk);
;;;1023   	return ret_val;
;;;1024   }
001bac  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7088|
001bb0  e1a02006          MOV      r2,r6                 ;1019
001bb4  e1a01005          MOV      r1,r5                 ;1019
001bb8  e1a0000a          MOV      r0,r10                ;1019
001bbc  ebfffffe          BL       yaffs_get_group_base
001bc0  e1a08000          MOV      r8,r0                 ;1019
001bc4  e58d6000          STR      r6,[sp,#0]            ;1021
001bc8  e1a02007          MOV      r2,r7                 ;1021
001bcc  e1a01008          MOV      r1,r8                 ;1021
001bd0  e1a0000a          MOV      r0,r10                ;1021
001bd4  e5943030          LDR      r3,[r4,#0x30]         ;1021
001bd8  ebfffffe          BL       yaffs_find_chunk_in_group
001bdc  e1a09000          MOV      r9,r0                 ;1021
001be0  e1a00009          MOV      r0,r9                 ;1023
001be4  eaffffef          B        |L1.7080|
;;;1025   
                          ENDP

                  yaffs_find_del_file_chunk PROC
;;;1026   static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
001be8  e92d47f0          PUSH     {r4-r10,lr}
;;;1027   				     struct yaffs_ext_tags *tags)
;;;1028   {
001bec  e24dd050          SUB      sp,sp,#0x50
001bf0  e1a04000          MOV      r4,r0
001bf4  e1a06001          MOV      r6,r1
001bf8  e1a07002          MOV      r7,r2
;;;1029   	/* Get the Tnode, then get the level 0 offset chunk offset */
;;;1030   	struct yaffs_tnode *tn;
;;;1031   	int the_chunk = -1;
001bfc  e3e09000          MVN      r9,#0
;;;1032   	struct yaffs_ext_tags local_tags;
;;;1033   	struct yaffs_dev *dev = in->my_dev;
001c00  e594a008          LDR      r10,[r4,#8]
;;;1034   	int ret_val = -1;
001c04  e3e08000          MVN      r8,#0
;;;1035   
;;;1036   	if (!tags) {
001c08  e3570000          CMP      r7,#0
001c0c  1a000000          BNE      |L1.7188|
;;;1037   		/* Passed a NULL, so use our own tags space */
;;;1038   		tags = &local_tags;
001c10  e28d7008          ADD      r7,sp,#8
                  |L1.7188|
;;;1039   	}
;;;1040   
;;;1041   	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
001c14  e1a02006          MOV      r2,r6
001c18  e2841068          ADD      r1,r4,#0x68
001c1c  e1a0000a          MOV      r0,r10
001c20  ebfffffe          BL       yaffs_find_tnode_0
001c24  e1a05000          MOV      r5,r0
;;;1042   
;;;1043   	if (!tn)
001c28  e3550000          CMP      r5,#0
001c2c  1a000002          BNE      |L1.7228|
;;;1044   		return ret_val;
001c30  e1a00008          MOV      r0,r8
                  |L1.7220|
001c34  e28dd050          ADD      sp,sp,#0x50
;;;1045   
;;;1046   	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
;;;1047   
;;;1048   	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
;;;1049   					      inode_chunk);
;;;1050   
;;;1051   	/* Delete the entry in the filestructure (if found) */
;;;1052   	if (ret_val != -1)
;;;1053   		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
;;;1054   
;;;1055   	return ret_val;
;;;1056   }
001c38  e8bd87f0          POP      {r4-r10,pc}
                  |L1.7228|
001c3c  e1a02006          MOV      r2,r6                 ;1046
001c40  e1a01005          MOV      r1,r5                 ;1046
001c44  e1a0000a          MOV      r0,r10                ;1046
001c48  ebfffffe          BL       yaffs_get_group_base
001c4c  e1a09000          MOV      r9,r0                 ;1046
001c50  e58d6000          STR      r6,[sp,#0]            ;1048
001c54  e1a02007          MOV      r2,r7                 ;1048
001c58  e1a01009          MOV      r1,r9                 ;1048
001c5c  e1a0000a          MOV      r0,r10                ;1048
001c60  e5943030          LDR      r3,[r4,#0x30]         ;1048
001c64  ebfffffe          BL       yaffs_find_chunk_in_group
001c68  e1a08000          MOV      r8,r0                 ;1048
001c6c  e3780001          CMN      r8,#1                 ;1052
001c70  0a000004          BEQ      |L1.7304|
001c74  e3a03000          MOV      r3,#0                 ;1053
001c78  e1a02006          MOV      r2,r6                 ;1053
001c7c  e1a01005          MOV      r1,r5                 ;1053
001c80  e1a0000a          MOV      r0,r10                ;1053
001c84  ebfffffe          BL       yaffs_load_tnode_0
                  |L1.7304|
001c88  e1a00008          MOV      r0,r8                 ;1055
001c8c  eaffffe8          B        |L1.7220|
;;;1057   
                          ENDP

                  yaffs_put_chunk_in_file PROC
;;;1058   int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
001c90  e92d4ff0          PUSH     {r4-r11,lr}
;;;1059   			    int nand_chunk, int in_scan)
;;;1060   {
001c94  e24dd094          SUB      sp,sp,#0x94
001c98  e1a05000          MOV      r5,r0
001c9c  e1a09001          MOV      r9,r1
001ca0  e1a07002          MOV      r7,r2
001ca4  e1a06003          MOV      r6,r3
;;;1061   	/* NB in_scan is zero unless scanning.
;;;1062   	 * For forward scanning, in_scan is > 0;
;;;1063   	 * for backward scanning in_scan is < 0
;;;1064   	 *
;;;1065   	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
;;;1066   	 */
;;;1067   
;;;1068   	struct yaffs_tnode *tn;
;;;1069   	struct yaffs_dev *dev = in->my_dev;
001ca8  e5950008          LDR      r0,[r5,#8]
001cac  e58d0090          STR      r0,[sp,#0x90]
;;;1070   	int existing_cunk;
;;;1071   	struct yaffs_ext_tags existing_tags;
;;;1072   	struct yaffs_ext_tags new_tags;
;;;1073   	unsigned existing_serial, new_serial;
;;;1074   
;;;1075   	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
001cb0  e5d50064          LDRB     r0,[r5,#0x64]
001cb4  e3500001          CMP      r0,#1
001cb8  0a000015          BEQ      |L1.7444|
;;;1076   		/* Just ignore an attempt at putting a chunk into a non-file
;;;1077   		 * during scanning.
;;;1078   		 * If it is not during Scanning then something went wrong!
;;;1079   		 */
;;;1080   		if (!in_scan) {
001cbc  e3560000          CMP      r6,#0
001cc0  1a00000b          BNE      |L1.7412|
;;;1081   			yaffs_trace(YAFFS_TRACE_ERROR,
001cc4  e51f0734          LDR      r0,|L1.5528|
001cc8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
001ccc  e3100101          TST      r0,#0x40000000
001cd0  0a000001          BEQ      |L1.7388|
001cd4  e28f0f83          ADR      r0,|L1.7912|
001cd8  ebfffffe          BL       sysprintf
                  |L1.7388|
;;;1082   				"yaffs tragedy:attempt to put data chunk into a non-file"
;;;1083   				);
;;;1084   			BUG();
001cdc  e1a00000          MOV      r0,r0
001ce0  e59f2240          LDR      r2,|L1.7976|
001ce4  e28f1d09          ADR      r1,|L1.7980|
001ce8  e59f0270          LDR      r0,|L1.8032|
001cec  ebfffffe          BL       sysprintf
001cf0  e1a00000          MOV      r0,r0
                  |L1.7412|
;;;1085   		}
;;;1086   
;;;1087   		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
001cf4  e59f3268          LDR      r3,|L1.8036|
001cf8  e3a02001          MOV      r2,#1
001cfc  e1a01007          MOV      r1,r7
001d00  e59d0090          LDR      r0,[sp,#0x90]
001d04  ebfffffe          BL       yaffs_chunk_del
;;;1088   		return YAFFS_OK;
001d08  e3a00001          MOV      r0,#1
                  |L1.7436|
001d0c  e28dd094          ADD      sp,sp,#0x94
;;;1089   	}
;;;1090   
;;;1091   	tn = yaffs_add_find_tnode_0(dev,
;;;1092   				    &in->variant.file_variant,
;;;1093   				    inode_chunk, NULL);
;;;1094   	if (!tn)
;;;1095   		return YAFFS_FAIL;
;;;1096   
;;;1097   	if (!nand_chunk)
;;;1098   		/* Dummy insert, bail now */
;;;1099   		return YAFFS_OK;
;;;1100   
;;;1101   	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
;;;1102   
;;;1103   	if (in_scan != 0) {
;;;1104   		/* If we're scanning then we need to test for duplicates
;;;1105   		 * NB This does not need to be efficient since it should only
;;;1106   		 * happen when the power fails during a write, then only one
;;;1107   		 * chunk should ever be affected.
;;;1108   		 *
;;;1109   		 * Correction for YAFFS2: This could happen quite a lot and we
;;;1110   		 * need to think about efficiency! TODO
;;;1111   		 * Update: For backward scanning we don't need to re-read tags
;;;1112   		 * so this is quite cheap.
;;;1113   		 */
;;;1114   
;;;1115   		if (existing_cunk > 0) {
;;;1116   			/* NB Right now existing chunk will not be real
;;;1117   			 * chunk_id if the chunk group size > 1
;;;1118   			 * thus we have to do a FindChunkInFile to get the
;;;1119   			 * real chunk id.
;;;1120   			 *
;;;1121   			 * We have a duplicate now we need to decide which
;;;1122   			 * one to use:
;;;1123   			 *
;;;1124   			 * Backwards scanning YAFFS2: The old one is what
;;;1125   			 * we use, dump the new one.
;;;1126   			 * YAFFS1: Get both sets of tags and compare serial
;;;1127   			 * numbers.
;;;1128   			 */
;;;1129   
;;;1130   			if (in_scan > 0) {
;;;1131   				/* Only do this for forward scanning */
;;;1132   				yaffs_rd_chunk_tags_nand(dev,
;;;1133   							 nand_chunk,
;;;1134   							 NULL, &new_tags);
;;;1135   
;;;1136   				/* Do a proper find */
;;;1137   				existing_cunk =
;;;1138   				    yaffs_find_chunk_in_file(in, inode_chunk,
;;;1139   							     &existing_tags);
;;;1140   			}
;;;1141   
;;;1142   			if (existing_cunk <= 0) {
;;;1143   				/*Hoosterman - how did this happen? */
;;;1144   
;;;1145   				yaffs_trace(YAFFS_TRACE_ERROR,
;;;1146   					"yaffs tragedy: existing chunk < 0 in scan"
;;;1147   					);
;;;1148   
;;;1149   			}
;;;1150   
;;;1151   			/* NB The deleted flags should be false, otherwise
;;;1152   			 * the chunks will not be loaded during a scan
;;;1153   			 */
;;;1154   
;;;1155   			if (in_scan > 0) {
;;;1156   				new_serial = new_tags.serial_number;
;;;1157   				existing_serial = existing_tags.serial_number;
;;;1158   			}
;;;1159   
;;;1160   			if ((in_scan > 0) &&
;;;1161   			    (existing_cunk <= 0 ||
;;;1162   			     ((existing_serial + 1) & 3) == new_serial)) {
;;;1163   				/* Forward scanning.
;;;1164   				 * Use new
;;;1165   				 * Delete the old one and drop through to
;;;1166   				 * update the tnode
;;;1167   				 */
;;;1168   				yaffs_chunk_del(dev, existing_cunk, 1,
;;;1169   						__LINE__);
;;;1170   			} else {
;;;1171   				/* Backward scanning or we want to use the
;;;1172   				 * existing one
;;;1173   				 * Delete the new one and return early so that
;;;1174   				 * the tnode isn't changed
;;;1175   				 */
;;;1176   				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
;;;1177   				return YAFFS_OK;
;;;1178   			}
;;;1179   		}
;;;1180   
;;;1181   	}
;;;1182   
;;;1183   	if (existing_cunk == 0)
;;;1184   		in->n_data_chunks++;
;;;1185   
;;;1186   	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
;;;1187   
;;;1188   	return YAFFS_OK;
;;;1189   }
001d10  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.7444|
001d14  e3a03000          MOV      r3,#0                 ;1091
001d18  e1a02009          MOV      r2,r9                 ;1091
001d1c  e2851068          ADD      r1,r5,#0x68           ;1091
001d20  e59d0090          LDR      r0,[sp,#0x90]         ;1091
001d24  ebfffffe          BL       yaffs_add_find_tnode_0
001d28  e1a08000          MOV      r8,r0                 ;1091
001d2c  e3580000          CMP      r8,#0                 ;1094
001d30  1a000001          BNE      |L1.7484|
001d34  e3a00000          MOV      r0,#0                 ;1095
001d38  eafffff3          B        |L1.7436|
                  |L1.7484|
001d3c  e3570000          CMP      r7,#0                 ;1097
001d40  1a000001          BNE      |L1.7500|
001d44  e3a00001          MOV      r0,#1                 ;1099
001d48  eaffffef          B        |L1.7436|
                  |L1.7500|
001d4c  e1a02009          MOV      r2,r9                 ;1101
001d50  e1a01008          MOV      r1,r8                 ;1101
001d54  e59d0090          LDR      r0,[sp,#0x90]         ;1101
001d58  ebfffffe          BL       yaffs_get_group_base
001d5c  e1a04000          MOV      r4,r0                 ;1101
001d60  e3560000          CMP      r6,#0                 ;1103
001d64  0a00002e          BEQ      |L1.7716|
001d68  e3540000          CMP      r4,#0                 ;1115
001d6c  da00002c          BLE      |L1.7716|
001d70  e3560000          CMP      r6,#0                 ;1130
001d74  da000009          BLE      |L1.7584|
001d78  e1a0300d          MOV      r3,sp                 ;1132
001d7c  e3a02000          MOV      r2,#0                 ;1132
001d80  e1a01007          MOV      r1,r7                 ;1132
001d84  e59d0090          LDR      r0,[sp,#0x90]         ;1132
001d88  ebfffffe          BL       yaffs_rd_chunk_tags_nand
001d8c  e28d2048          ADD      r2,sp,#0x48           ;1137
001d90  e1a01009          MOV      r1,r9                 ;1137
001d94  e1a00005          MOV      r0,r5                 ;1137
001d98  ebfffffe          BL       yaffs_find_chunk_in_file
001d9c  e1a04000          MOV      r4,r0                 ;1137
                  |L1.7584|
001da0  e3540000          CMP      r4,#0                 ;1142
001da4  ca000005          BGT      |L1.7616|
001da8  e51f0818          LDR      r0,|L1.5528|
001dac  e5900000          LDR      r0,[r0,#0]            ;1145  ; yaffs_trace_mask
001db0  e3100101          TST      r0,#0x40000000        ;1145
001db4  0a000001          BEQ      |L1.7616|
001db8  e28f0f6a          ADR      r0,|L1.8040|
001dbc  ebfffffe          BL       sysprintf
                  |L1.7616|
001dc0  e3560000          CMP      r6,#0                 ;1155
001dc4  da000001          BLE      |L1.7632|
001dc8  e59db01c          LDR      r11,[sp,#0x1c]        ;1156
001dcc  e59da064          LDR      r10,[sp,#0x64]        ;1157
                  |L1.7632|
001dd0  e3560000          CMP      r6,#0                 ;1160
001dd4  da00000b          BLE      |L1.7688|
001dd8  e3540000          CMP      r4,#0                 ;1161
001ddc  da000003          BLE      |L1.7664|
001de0  e28a0001          ADD      r0,r10,#1             ;1162
001de4  e2000003          AND      r0,r0,#3              ;1162
001de8  e150000b          CMP      r0,r11                ;1162
001dec  1a000005          BNE      |L1.7688|
                  |L1.7664|
001df0  e59f31a4          LDR      r3,|L1.8092|
001df4  e3a02001          MOV      r2,#1                 ;1168
001df8  e1a01004          MOV      r1,r4                 ;1168
001dfc  e59d0090          LDR      r0,[sp,#0x90]         ;1168
001e00  ebfffffe          BL       yaffs_chunk_del
001e04  ea000006          B        |L1.7716|
                  |L1.7688|
001e08  e59f3190          LDR      r3,|L1.8096|
001e0c  e3a02001          MOV      r2,#1                 ;1176
001e10  e1a01007          MOV      r1,r7                 ;1176
001e14  e59d0090          LDR      r0,[sp,#0x90]         ;1176
001e18  ebfffffe          BL       yaffs_chunk_del
001e1c  e3a00001          MOV      r0,#1                 ;1177
001e20  eaffffb9          B        |L1.7436|
                  |L1.7716|
001e24  e3540000          CMP      r4,#0                 ;1183
001e28  1a000002          BNE      |L1.7736|
001e2c  e595002c          LDR      r0,[r5,#0x2c]         ;1184
001e30  e2800001          ADD      r0,r0,#1              ;1184
001e34  e585002c          STR      r0,[r5,#0x2c]         ;1184
                  |L1.7736|
001e38  e1a03007          MOV      r3,r7                 ;1186
001e3c  e1a02009          MOV      r2,r9                 ;1186
001e40  e1a01008          MOV      r1,r8                 ;1186
001e44  e59d0090          LDR      r0,[sp,#0x90]         ;1186
001e48  ebfffffe          BL       yaffs_load_tnode_0
001e4c  e3a00001          MOV      r0,#1                 ;1188
001e50  eaffffad          B        |L1.7436|
;;;1190   
                          ENDP

                  yaffs_soft_del_chunk PROC
;;;1191   static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
001e54  e92d41f0          PUSH     {r4-r8,lr}
;;;1192   {
001e58  e1a05000          MOV      r5,r0
001e5c  e1a06001          MOV      r6,r1
;;;1193   	struct yaffs_block_info *the_block;
;;;1194   	unsigned block_no;
;;;1195   
;;;1196   	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
001e60  e51f08d0          LDR      r0,|L1.5528|
001e64  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
001e68  e3100c02          TST      r0,#0x200
001e6c  0a000002          BEQ      |L1.7804|
001e70  e1a01006          MOV      r1,r6
001e74  e28f0f4a          ADR      r0,|L1.8100|
001e78  ebfffffe          BL       sysprintf
                  |L1.7804|
;;;1197   
;;;1198   	block_no = chunk / dev->param.chunks_per_block;
001e7c  e1a00006          MOV      r0,r6
001e80  e595100c          LDR      r1,[r5,#0xc]
001e84  ebfffffe          BL       __aeabi_idivmod
001e88  e1a07000          MOV      r7,r0
;;;1199   	the_block = yaffs_get_block_info(dev, block_no);
001e8c  e1a01007          MOV      r1,r7
001e90  e1a00005          MOV      r0,r5
001e94  ebfffffe          BL       yaffs_get_block_info
001e98  e1a04000          MOV      r4,r0
;;;1200   	if (the_block) {
001e9c  e3540000          CMP      r4,#0
001ea0  0a00000f          BEQ      |L1.7908|
;;;1201   		the_block->soft_del_pages++;
001ea4  e5940000          LDR      r0,[r4,#0]
001ea8  e1a00520          LSR      r0,r0,#10
001eac  e1a00500          LSL      r0,r0,#10
001eb0  e1d410b0          LDRH     r1,[r4,#0]
001eb4  e2811001          ADD      r1,r1,#1
001eb8  e1a01b01          LSL      r1,r1,#22
001ebc  e1a01b21          LSR      r1,r1,#22
001ec0  e1800001          ORR      r0,r0,r1
001ec4  e5840000          STR      r0,[r4,#0]
;;;1202   		dev->n_free_chunks++;
001ec8  e5950d4c          LDR      r0,[r5,#0xd4c]
001ecc  e2800001          ADD      r0,r0,#1
001ed0  e5850d4c          STR      r0,[r5,#0xd4c]
;;;1203   		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
001ed4  e1a02004          MOV      r2,r4
001ed8  e1a01007          MOV      r1,r7
001edc  e1a00005          MOV      r0,r5
001ee0  ebfffffe          BL       yaffs2_update_oldest_dirty_seq
                  |L1.7908|
;;;1204   	}
;;;1205   }
001ee4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7912|
001ee8  79616666          DCB      "yaffs: yaffs tragedy:attempt to put data chunk into a n"
001eec  733a2079
001ef0  61666673
001ef4  20747261
001ef8  67656479
001efc  3a617474
001f00  656d7074
001f04  20746f20
001f08  70757420
001f0c  64617461
001f10  20636875
001f14  6e6b2069
001f18  6e746f20
001f1c  61206e  
001f1f  6f6e2d66          DCB      "on-file\n",0
001f23  696c650a
001f27  00      
                  |L1.7976|
                          DCD      0x0000043c
                  |L1.7980|
001f2c  2e2e5c2e          DCB      "..\\..\\common\\src\\BSP\\ThirdParty\\yaffs2\\yaffs_gut"
001f30  2e5c636f
001f34  6d6d6f6e
001f38  5c737263
001f3c  5c425350
001f40  5c546869
001f44  72645061
001f48  7274795c
001f4c  79616666
001f50  73325c79
001f54  61666673
001f58  5f677574
001f5c  732e6300          DCB      "s.c",0
                  |L1.8032|
                          DCD      ||.text||+0x2b4
                  |L1.8036|
                          DCD      0x0000043f
                  |L1.8040|
001f68  79616666          DCB      "yaffs: yaffs tragedy: existing chunk < 0 in scan\n",0
001f6c  733a2079
001f70  61666673
001f74  20747261
001f78  67656479
001f7c  3a206578
001f80  69737469
001f84  6e672063
001f88  68756e6b
001f8c  203c2030
001f90  20696e20
001f94  7363616e
001f98  0a00    
001f9a  00                DCB      0
001f9b  00                DCB      0
                  |L1.8092|
                          DCD      0x00000491
                  |L1.8096|
                          DCD      0x00000498
                  |L1.8100|
001fa4  79616666          DCB      "yaffs: soft delete chunk %d\n",0
001fa8  733a2073
001fac  6f667420
001fb0  64656c65
001fb4  74652063
001fb8  68756e6b
001fbc  2025640a
001fc0  00      
001fc1  00                DCB      0
001fc2  00                DCB      0
001fc3  00                DCB      0
                          ENDP

                  yaffs_soft_del_worker PROC
;;;1214   
;;;1215   static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
001fc4  e92d5ff0          PUSH     {r4-r12,lr}
;;;1216   				 u32 level, int chunk_offset)
;;;1217   {
001fc8  e1a09000          MOV      r9,r0
001fcc  e1a05001          MOV      r5,r1
001fd0  e1a07002          MOV      r7,r2
001fd4  e1a0a003          MOV      r10,r3
;;;1218   	int i;
;;;1219   	int the_chunk;
;;;1220   	int all_done = 1;
001fd8  e3a08001          MOV      r8,#1
;;;1221   	struct yaffs_dev *dev = in->my_dev;
001fdc  e599b008          LDR      r11,[r9,#8]
;;;1222   
;;;1223   	if (!tn)
001fe0  e3550000          CMP      r5,#0
001fe4  1a000001          BNE      |L1.8176|
;;;1224   		return 1;
001fe8  e3a00001          MOV      r0,#1
                  |L1.8172|
;;;1225   
;;;1226   	if (level > 0) {
;;;1227   		for (i = YAFFS_NTNODES_INTERNAL - 1;
;;;1228   			all_done && i >= 0;
;;;1229   			i--) {
;;;1230   			if (tn->internal[i]) {
;;;1231   				all_done =
;;;1232   				    yaffs_soft_del_worker(in,
;;;1233   					tn->internal[i],
;;;1234   					level - 1,
;;;1235   					(chunk_offset <<
;;;1236   					YAFFS_TNODES_INTERNAL_BITS)
;;;1237   					+ i);
;;;1238   				if (all_done) {
;;;1239   					yaffs_free_tnode(dev,
;;;1240   						tn->internal[i]);
;;;1241   					tn->internal[i] = NULL;
;;;1242   				} else {
;;;1243   					/* Can this happen? */
;;;1244   				}
;;;1245   			}
;;;1246   		}
;;;1247   		return (all_done) ? 1 : 0;
;;;1248   	}
;;;1249   
;;;1250   	/* level 0 */
;;;1251   	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
;;;1252   		the_chunk = yaffs_get_group_base(dev, tn, i);
;;;1253   		if (the_chunk) {
;;;1254   			yaffs_soft_del_chunk(dev, the_chunk);
;;;1255   			yaffs_load_tnode_0(dev, tn, i, 0);
;;;1256   		}
;;;1257   	}
;;;1258   	return 1;
;;;1259   }
001fec  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.8176|
001ff0  e3570000          CMP      r7,#0                 ;1226
001ff4  0a00001c          BEQ      |L1.8300|
001ff8  e3a04007          MOV      r4,#7                 ;1227
001ffc  ea000010          B        |L1.8260|
                  |L1.8192|
002000  e7950104          LDR      r0,[r5,r4,LSL #2]     ;1230
002004  e3500000          CMP      r0,#0                 ;1230
002008  0a00000c          BEQ      |L1.8256|
00200c  e084318a          ADD      r3,r4,r10,LSL #3      ;1231
002010  e2472001          SUB      r2,r7,#1              ;1231
002014  e7951104          LDR      r1,[r5,r4,LSL #2]     ;1231
002018  e1a00009          MOV      r0,r9                 ;1231
00201c  ebfffffe          BL       yaffs_soft_del_worker
002020  e1a08000          MOV      r8,r0                 ;1231
002024  e3580000          CMP      r8,#0                 ;1238
002028  0a000004          BEQ      |L1.8256|
00202c  e7951104          LDR      r1,[r5,r4,LSL #2]     ;1239
002030  e1a0000b          MOV      r0,r11                ;1239
002034  ebfffffe          BL       yaffs_free_tnode
002038  e3a00000          MOV      r0,#0                 ;1241
00203c  e7850104          STR      r0,[r5,r4,LSL #2]     ;1241
                  |L1.8256|
002040  e2444001          SUB      r4,r4,#1              ;1229
                  |L1.8260|
002044  e3580000          CMP      r8,#0                 ;1228
002048  0a000001          BEQ      |L1.8276|
00204c  e3540000          CMP      r4,#0                 ;1228
002050  aaffffea          BGE      |L1.8192|
                  |L1.8276|
002054  e3580000          CMP      r8,#0                 ;1247
002058  0a000001          BEQ      |L1.8292|
00205c  e3a00001          MOV      r0,#1                 ;1247
002060  eaffffe1          B        |L1.8172|
                  |L1.8292|
002064  e3a00000          MOV      r0,#0                 ;1247
002068  eaffffdf          B        |L1.8172|
                  |L1.8300|
00206c  e3a0400f          MOV      r4,#0xf               ;1251
002070  ea00000f          B        |L1.8372|
                  |L1.8308|
002074  e1a02004          MOV      r2,r4                 ;1252
002078  e1a01005          MOV      r1,r5                 ;1252
00207c  e1a0000b          MOV      r0,r11                ;1252
002080  ebfffffe          BL       yaffs_get_group_base
002084  e1a06000          MOV      r6,r0                 ;1252
002088  e3560000          CMP      r6,#0                 ;1253
00208c  0a000007          BEQ      |L1.8368|
002090  e1a01006          MOV      r1,r6                 ;1254
002094  e1a0000b          MOV      r0,r11                ;1254
002098  ebfffffe          BL       yaffs_soft_del_chunk
00209c  e3a03000          MOV      r3,#0                 ;1255
0020a0  e1a02004          MOV      r2,r4                 ;1255
0020a4  e1a01005          MOV      r1,r5                 ;1255
0020a8  e1a0000b          MOV      r0,r11                ;1255
0020ac  ebfffffe          BL       yaffs_load_tnode_0
                  |L1.8368|
0020b0  e2444001          SUB      r4,r4,#1              ;1251
                  |L1.8372|
0020b4  e3540000          CMP      r4,#0                 ;1251
0020b8  aaffffed          BGE      |L1.8308|
0020bc  e3a00001          MOV      r0,#1                 ;1258
0020c0  eaffffc9          B        |L1.8172|
;;;1260   
                          ENDP

                  yaffs_remove_obj_from_dir PROC
;;;1261   static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
0020c4  e92d4070          PUSH     {r4-r6,lr}
;;;1262   {
0020c8  e1a04000          MOV      r4,r0
;;;1263   	struct yaffs_dev *dev = obj->my_dev;
0020cc  e5945008          LDR      r5,[r4,#8]
;;;1264   	struct yaffs_obj *parent;
;;;1265   
;;;1266   	yaffs_verify_obj_in_dir(obj);
0020d0  e1a00004          MOV      r0,r4
0020d4  ebfffffe          BL       yaffs_verify_obj_in_dir
;;;1267   	parent = obj->parent;
0020d8  e594601c          LDR      r6,[r4,#0x1c]
;;;1268   
;;;1269   	yaffs_verify_dir(parent);
0020dc  e1a00006          MOV      r0,r6
0020e0  ebfffffe          BL       yaffs_verify_dir
;;;1270   
;;;1271   	if (dev && dev->param.remove_obj_fn)
0020e4  e3550000          CMP      r5,#0
0020e8  0a000005          BEQ      |L1.8452|
0020ec  e5950068          LDR      r0,[r5,#0x68]
0020f0  e3500000          CMP      r0,#0
0020f4  0a000002          BEQ      |L1.8452|
;;;1272   		dev->param.remove_obj_fn(obj);
0020f8  e1a00004          MOV      r0,r4
0020fc  e5951068          LDR      r1,[r5,#0x68]
002100  e12fff31          BLX      r1
                  |L1.8452|
;;;1273   
;;;1274   	list_del_init(&obj->siblings);
002104  e2840020          ADD      r0,r4,#0x20
002108  ebfffffe          BL       list_del_init
;;;1275   	obj->parent = NULL;
00210c  e3a00000          MOV      r0,#0
002110  e584001c          STR      r0,[r4,#0x1c]
;;;1276   
;;;1277   	yaffs_verify_dir(parent);
002114  e1a00006          MOV      r0,r6
002118  ebfffffe          BL       yaffs_verify_dir
;;;1278   }
00211c  e8bd8070          POP      {r4-r6,pc}
;;;1279   
                          ENDP

                  yaffs_add_obj_to_dir PROC
;;;1280   void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
002120  e92d4070          PUSH     {r4-r6,lr}
;;;1281   {
002124  e1a05000          MOV      r5,r0
002128  e1a04001          MOV      r4,r1
;;;1282   	if (!directory) {
00212c  e3550000          CMP      r5,#0
002130  1a00000c          BNE      |L1.8552|
;;;1283   		yaffs_trace(YAFFS_TRACE_ALWAYS,
002134  e51f0ba4          LDR      r0,|L1.5528|
002138  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00213c  e310020f          TST      r0,#0xf0000000
002140  0a000001          BEQ      |L1.8524|
002144  e59f0214          LDR      r0,|L1.9056|
002148  ebfffffe          BL       sysprintf
                  |L1.8524|
;;;1284   			"tragedy: Trying to add an object to a null pointer directory"
;;;1285   			);
;;;1286   		BUG();
00214c  e1a00000          MOV      r0,r0
002150  e59f220c          LDR      r2,|L1.9060|
002154  e24f1e23          ADR      r1,|L1.7980|
002158  e51f0200          LDR      r0,|L1.8032|
00215c  ebfffffe          BL       sysprintf
002160  e1a00000          MOV      r0,r0
                  |L1.8548|
;;;1287   		return;
;;;1288   	}
;;;1289   	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;1290   		yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;1291   			"tragedy: Trying to add an object to a non-directory"
;;;1292   			);
;;;1293   		BUG();
;;;1294   	}
;;;1295   
;;;1296   	if (obj->siblings.prev == NULL) {
;;;1297   		/* Not initialised */
;;;1298   		BUG();
;;;1299   	}
;;;1300   
;;;1301   	yaffs_verify_dir(directory);
;;;1302   
;;;1303   	yaffs_remove_obj_from_dir(obj);
;;;1304   
;;;1305   	/* Now add it */
;;;1306   	list_add(&obj->siblings, &directory->variant.dir_variant.children);
;;;1307   	obj->parent = directory;
;;;1308   
;;;1309   	if (directory == obj->my_dev->unlinked_dir
;;;1310   	    || directory == obj->my_dev->del_dir) {
;;;1311   		obj->unlinked = 1;
;;;1312   		obj->my_dev->n_unlinked_files++;
;;;1313   		obj->rename_allowed = 0;
;;;1314   	}
;;;1315   
;;;1316   	yaffs_verify_dir(directory);
;;;1317   	yaffs_verify_obj_in_dir(obj);
;;;1318   }
002164  e8bd8070          POP      {r4-r6,pc}
                  |L1.8552|
002168  e5d50064          LDRB     r0,[r5,#0x64]         ;1289
00216c  e3500003          CMP      r0,#3                 ;1289
002170  0a00000b          BEQ      |L1.8612|
002174  e51f0be4          LDR      r0,|L1.5528|
002178  e5900000          LDR      r0,[r0,#0]            ;1290  ; yaffs_trace_mask
00217c  e310020f          TST      r0,#0xf0000000        ;1290
002180  0a000001          BEQ      |L1.8588|
002184  e28f0f77          ADR      r0,|L1.9064|
002188  ebfffffe          BL       sysprintf
                  |L1.8588|
00218c  e1a00000          MOV      r0,r0                 ;1293
002190  e59f220c          LDR      r2,|L1.9124|
002194  e24f1e27          ADR      r1,|L1.7980|
002198  e51f0240          LDR      r0,|L1.8032|
00219c  ebfffffe          BL       sysprintf
0021a0  e1a00000          MOV      r0,r0                 ;1293
                  |L1.8612|
0021a4  e5940024          LDR      r0,[r4,#0x24]         ;1296
0021a8  e3500000          CMP      r0,#0                 ;1296
0021ac  1a000005          BNE      |L1.8648|
0021b0  e1a00000          MOV      r0,r0                 ;1298
0021b4  e59f21ec          LDR      r2,|L1.9128|
0021b8  e24f1fa5          ADR      r1,|L1.7980|
0021bc  e51f0264          LDR      r0,|L1.8032|
0021c0  ebfffffe          BL       sysprintf
0021c4  e1a00000          MOV      r0,r0                 ;1298
                  |L1.8648|
0021c8  e1a00005          MOV      r0,r5                 ;1301
0021cc  ebfffffe          BL       yaffs_verify_dir
0021d0  e1a00004          MOV      r0,r4                 ;1303
0021d4  ebfffffe          BL       yaffs_remove_obj_from_dir
0021d8  e2851068          ADD      r1,r5,#0x68           ;1306
0021dc  e2840020          ADD      r0,r4,#0x20           ;1306
0021e0  ebfffffe          BL       list_add
0021e4  e584501c          STR      r5,[r4,#0x1c]         ;1307
0021e8  e5940008          LDR      r0,[r4,#8]            ;1309
0021ec  e5900d98          LDR      r0,[r0,#0xd98]        ;1309
0021f0  e1500005          CMP      r0,r5                 ;1309
0021f4  0a000003          BEQ      |L1.8712|
0021f8  e5940008          LDR      r0,[r4,#8]            ;1310
0021fc  e5900d9c          LDR      r0,[r0,#0xd9c]        ;1310
002200  e1500005          CMP      r0,r5                 ;1310
002204  1a00000a          BNE      |L1.8756|
                  |L1.8712|
002208  e5d40000          LDRB     r0,[r4,#0]            ;1311
00220c  e3800004          ORR      r0,r0,#4              ;1311
002210  e5c40000          STRB     r0,[r4,#0]            ;1311
002214  e5940008          LDR      r0,[r4,#8]            ;1312
002218  e5900da8          LDR      r0,[r0,#0xda8]        ;1312
00221c  e2800001          ADD      r0,r0,#1              ;1312
002220  e5941008          LDR      r1,[r4,#8]            ;1312
002224  e5810da8          STR      r0,[r1,#0xda8]        ;1312
002228  e5d40000          LDRB     r0,[r4,#0]            ;1313
00222c  e3c00010          BIC      r0,r0,#0x10           ;1313
002230  e5c40000          STRB     r0,[r4,#0]            ;1313
                  |L1.8756|
002234  e1a00005          MOV      r0,r5                 ;1316
002238  ebfffffe          BL       yaffs_verify_dir
00223c  e1a00004          MOV      r0,r4                 ;1317
002240  ebfffffe          BL       yaffs_verify_obj_in_dir
002244  e1a00000          MOV      r0,r0
002248  eaffffc5          B        |L1.8548|
;;;1319   
                          ENDP

                  yaffs_obj_cache_dirty PROC
;;;1379   
;;;1380   static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
00224c  e92d4030          PUSH     {r4,r5,lr}
;;;1381   {
002250  e1a01000          MOV      r1,r0
;;;1382   	struct yaffs_dev *dev = obj->my_dev;
002254  e591c008          LDR      r12,[r1,#8]
;;;1383   	int i;
;;;1384   	struct yaffs_cache *cache;
;;;1385   	int n_caches = obj->my_dev->param.n_caches;
002258  e5910008          LDR      r0,[r1,#8]
00225c  e5904020          LDR      r4,[r0,#0x20]
;;;1386   
;;;1387   	for (i = 0; i < n_caches; i++) {
002260  e3a02000          MOV      r2,#0
002264  ea00000b          B        |L1.8856|
                  |L1.8808|
;;;1388   		cache = &dev->cache[i];
002268  e0625182          RSB      r5,r2,r2,LSL #3
00226c  e59c0d90          LDR      r0,[r12,#0xd90]
002270  e0803105          ADD      r3,r0,r5,LSL #2
;;;1389   		if (cache->object == obj && cache->dirty)
002274  e5930000          LDR      r0,[r3,#0]
002278  e1500001          CMP      r0,r1
00227c  1a000004          BNE      |L1.8852|
002280  e593000c          LDR      r0,[r3,#0xc]
002284  e3500000          CMP      r0,#0
002288  0a000001          BEQ      |L1.8852|
;;;1390   			return 1;
00228c  e3a00001          MOV      r0,#1
                  |L1.8848|
;;;1391   	}
;;;1392   
;;;1393   	return 0;
;;;1394   }
002290  e8bd8030          POP      {r4,r5,pc}
                  |L1.8852|
002294  e2822001          ADD      r2,r2,#1              ;1387
                  |L1.8856|
002298  e1520004          CMP      r2,r4                 ;1387
00229c  bafffff1          BLT      |L1.8808|
0022a0  e3a00000          MOV      r0,#0                 ;1393
0022a4  eafffff9          B        |L1.8848|
;;;1395   
                          ENDP

                  yaffs_apply_xattrib_mod PROC
;;;3075   
;;;3076   static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
0022a8  e92d4ffe          PUSH     {r1-r11,lr}
;;;3077   				   struct yaffs_xattr_mod *xmod)
;;;3078   {
0022ac  e1a05000          MOV      r5,r0
0022b0  e1a06001          MOV      r6,r1
0022b4  e1a04002          MOV      r4,r2
;;;3079   	int retval = 0;
0022b8  e3a07000          MOV      r7,#0
;;;3080   	int x_offs = sizeof(struct yaffs_obj_hdr);
0022bc  e3a08c02          MOV      r8,#0x200
;;;3081   	struct yaffs_dev *dev = obj->my_dev;
0022c0  e5959008          LDR      r9,[r5,#8]
;;;3082   	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
0022c4  e59900a4          LDR      r0,[r9,#0xa4]
0022c8  e240ac02          SUB      r10,r0,#0x200
;;;3083   	char *x_buffer = buffer + x_offs;
0022cc  e0860008          ADD      r0,r6,r8
0022d0  e58d0008          STR      r0,[sp,#8]
;;;3084   
;;;3085   	if (xmod->set)
0022d4  e5940000          LDR      r0,[r4,#0]
0022d8  e3500000          CMP      r0,#0
0022dc  0a000008          BEQ      |L1.8964|
;;;3086   		retval =
0022e0  e594000c          LDR      r0,[r4,#0xc]
0022e4  e5941010          LDR      r1,[r4,#0x10]
0022e8  e1cd00f0          STRD     r0,r1,[sp,#0]
0022ec  e1a0100a          MOV      r1,r10
0022f0  e994000c          LDMIB    r4,{r2,r3}
0022f4  e59d0008          LDR      r0,[sp,#8]
0022f8  ebfffffe          BL       nval_set
0022fc  e1a07000          MOV      r7,r0
002300  ea000004          B        |L1.8984|
                  |L1.8964|
;;;3087   		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
;;;3088   			     xmod->size, xmod->flags);
;;;3089   	else
;;;3090   		retval = nval_del(x_buffer, x_size, xmod->name);
002304  e1a0100a          MOV      r1,r10
002308  e5942004          LDR      r2,[r4,#4]
00230c  e59d0008          LDR      r0,[sp,#8]
002310  ebfffffe          BL       nval_del
002314  e1a07000          MOV      r7,r0
                  |L1.8984|
;;;3091   
;;;3092   	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
002318  e1a0100a          MOV      r1,r10
00231c  e59d0008          LDR      r0,[sp,#8]
002320  ebfffffe          BL       nval_hasvalues
002324  e3a01020          MOV      r1,#0x20
002328  e001b280          AND      r11,r1,r0,LSL #5
00232c  e5d50001          LDRB     r0,[r5,#1]
002330  e3c00020          BIC      r0,r0,#0x20
002334  e180000b          ORR      r0,r0,r11
002338  e5c50001          STRB     r0,[r5,#1]
;;;3093   	obj->xattr_known = 1;
00233c  e5d50001          LDRB     r0,[r5,#1]
002340  e3800010          ORR      r0,r0,#0x10
002344  e5c50001          STRB     r0,[r5,#1]
;;;3094   	xmod->result = retval;
002348  e5847014          STR      r7,[r4,#0x14]
;;;3095   
;;;3096   	return retval;
00234c  e1a00007          MOV      r0,r7
;;;3097   }
002350  e8bd8ffe          POP      {r1-r11,pc}
;;;3098   
                          ENDP

                  yaffs_oh_size_load PROC
;;;5007    */
;;;5008   void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
002354  e5802124          STR      r2,[r0,#0x124]
;;;5009   {
;;;5010   	oh->file_size_low = (fsize & 0xFFFFFFFF);
;;;5011   	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
002358  e58031f0          STR      r3,[r0,#0x1f0]
;;;5012   }
00235c  e12fff1e          BX       lr
                  |L1.9056|
                          DCD      ||.constdata||+0x90
                  |L1.9060|
                          DCD      0x00000506
                  |L1.9064|
002368  79616666          DCB      "yaffs: tragedy: Trying to add an object to a non-direct"
00236c  733a2074
002370  72616765
002374  64793a20
002378  54727969
00237c  6e672074
002380  6f206164
002384  6420616e
002388  206f626a
00238c  65637420
002390  746f2061
002394  206e6f6e
002398  2d646972
00239c  656374  
00239f  6f72790a          DCB      "ory\n",0
0023a3  00      
                  |L1.9124|
                          DCD      0x0000050d
                  |L1.9128|
                          DCD      0x00000512
                          ENDP

                  yaffs_load_oh_from_name PROC
;;;3227   
;;;3228   static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
0023ac  e92d4070          PUSH     {r4-r6,lr}
;;;3229   				    const YCHAR *name)
;;;3230   {
0023b0  e1a06000          MOV      r6,r0
0023b4  e1a04001          MOV      r4,r1
0023b8  e1a05002          MOV      r5,r2
;;;3231   #ifdef CONFIG_YAFFS_AUTO_UNICODE
;;;3232   
;;;3233   	int is_ascii;
;;;3234   	YCHAR *w;
;;;3235   
;;;3236   	if (dev->param.auto_unicode) {
;;;3237   
;;;3238   		is_ascii = 1;
;;;3239   		w = name;
;;;3240   
;;;3241   		/* Figure out if the name will fit in ascii character set */
;;;3242   		while (is_ascii && *w) {
;;;3243   			if ((*w) & 0xff00)
;;;3244   				is_ascii = 0;
;;;3245   			w++;
;;;3246   		}
;;;3247   
;;;3248   		if (is_ascii) {
;;;3249   			/* It is an ASCII name, so convert unicode to ascii */
;;;3250   			char *ascii_oh_name = (char *)oh_name;
;;;3251   			int n = YAFFS_MAX_NAME_LENGTH - 1;
;;;3252   			while (n > 0 && *name) {
;;;3253   				*ascii_oh_name = *name;
;;;3254   				name++;
;;;3255   				ascii_oh_name++;
;;;3256   				n--;
;;;3257   			}
;;;3258   		} else {
;;;3259   			/* Unicode name, so save starting at the second YCHAR */
;;;3260   			*oh_name = 0;
;;;3261   			yaffs_strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
;;;3262   		}
;;;3263   	} else {
;;;3264   #else
;;;3265   	dev = dev;
0023bc  e1a00000          MOV      r0,r0
;;;3266   	{
;;;3267   #endif
;;;3268   		yaffs_strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
0023c0  e3a020fe          MOV      r2,#0xfe
0023c4  e1a01005          MOV      r1,r5
0023c8  e1a00004          MOV      r0,r4
0023cc  ebfffffe          BL       strncpy
;;;3269   	}
;;;3270   }
0023d0  e8bd8070          POP      {r4-r6,pc}
;;;3271   
                          ENDP

                  yaffs_clone_str PROC
;;;2035   
;;;2036   YCHAR *yaffs_clone_str(const YCHAR *str)
0023d4  e92d4070          PUSH     {r4-r6,lr}
;;;2037   {
0023d8  e1a04000          MOV      r4,r0
;;;2038   	YCHAR *new_str = NULL;
0023dc  e3a05000          MOV      r5,#0
;;;2039   	int len;
;;;2040   
;;;2041   	if (!str)
0023e0  e3540000          CMP      r4,#0
0023e4  1a000000          BNE      |L1.9196|
;;;2042   		str = _Y("");
0023e8  e28f4f92          ADR      r4,|L1.9784|
                  |L1.9196|
;;;2043   
;;;2044   	len = yaffs_strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
0023ec  e1a00004          MOV      r0,r4
0023f0  ebfffffe          BL       strlen
0023f4  e350009f          CMP      r0,#0x9f
0023f8  9a000001          BLS      |L1.9220|
0023fc  e3a0009f          MOV      r0,#0x9f
002400  ea000001          B        |L1.9228|
                  |L1.9220|
002404  e1a00004          MOV      r0,r4
002408  ebfffffe          BL       strlen
                  |L1.9228|
00240c  e1a06000          MOV      r6,r0
;;;2045   // 	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
;;;2046   	new_str = (YCHAR *)yaffs_malloc((len + 1) * sizeof(YCHAR));
002410  e2860001          ADD      r0,r6,#1
002414  ebfffffe          BL       yaffs_malloc
002418  e1a05000          MOV      r5,r0
;;;2047   	if (new_str) {
00241c  e3550000          CMP      r5,#0
002420  0a000005          BEQ      |L1.9276|
;;;2048   		yaffs_strncpy(new_str, str, len);
002424  e1a02006          MOV      r2,r6
002428  e1a01004          MOV      r1,r4
00242c  e1a00005          MOV      r0,r5
002430  ebfffffe          BL       strncpy
;;;2049   		new_str[len] = 0;
002434  e3a00000          MOV      r0,#0
002438  e7c50006          STRB     r0,[r5,r6]
                  |L1.9276|
;;;2050   	}
;;;2051   	return new_str;
00243c  e1a00005          MOV      r0,r5
;;;2052   
;;;2053   }
002440  e8bd8070          POP      {r4-r6,pc}
;;;2054   /*
                          ENDP

                  yaffs_check_obj_details_loaded PROC
;;;3171   
;;;3172   static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
002444  e92d40f0          PUSH     {r4-r7,lr}
;;;3173   {
002448  e24dd04c          SUB      sp,sp,#0x4c
00244c  e1a04000          MOV      r4,r0
;;;3174   	u8 *buf;
;;;3175   	struct yaffs_obj_hdr *oh;
;;;3176   	struct yaffs_dev *dev;
;;;3177   	struct yaffs_ext_tags tags;
;;;3178   
;;;3179   	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
002450  e3540000          CMP      r4,#0
002454  0a000005          BEQ      |L1.9328|
002458  e5d40001          LDRB     r0,[r4,#1]
00245c  e3100001          TST      r0,#1
002460  0a000002          BEQ      |L1.9328|
002464  e5940028          LDR      r0,[r4,#0x28]
002468  e3500001          CMP      r0,#1
00246c  aa000001          BGE      |L1.9336|
                  |L1.9328|
;;;3180   		return;
;;;3181   
;;;3182   	dev = in->my_dev;
;;;3183   	in->lazy_loaded = 0;
;;;3184   	buf = yaffs_get_temp_buffer(dev);
;;;3185   
;;;3186   	yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
;;;3187   	oh = (struct yaffs_obj_hdr *)buf;
;;;3188   
;;;3189   	in->yst_mode = oh->yst_mode;
;;;3190   	yaffs_load_attribs(in, oh);
;;;3191   	yaffs_set_obj_name_from_oh(in, oh);
;;;3192   
;;;3193   	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
;;;3194   		in->variant.symlink_variant.alias =
;;;3195   		    yaffs_clone_str(oh->alias);
;;;3196   	}
;;;3197   	yaffs_release_temp_buffer(dev, buf);
;;;3198   }
002470  e28dd04c          ADD      sp,sp,#0x4c
002474  e8bd80f0          POP      {r4-r7,pc}
                  |L1.9336|
002478  e5947008          LDR      r7,[r4,#8]            ;3182
00247c  e5d40001          LDRB     r0,[r4,#1]            ;3183
002480  e3c00001          BIC      r0,r0,#1              ;3183
002484  e5c40001          STRB     r0,[r4,#1]            ;3183
002488  e1a00007          MOV      r0,r7                 ;3184
00248c  ebfffffe          BL       yaffs_get_temp_buffer
002490  e1a05000          MOV      r5,r0                 ;3184
002494  e1a0300d          MOV      r3,sp                 ;3186
002498  e1a02005          MOV      r2,r5                 ;3186
00249c  e1a00007          MOV      r0,r7                 ;3186
0024a0  e5941028          LDR      r1,[r4,#0x28]         ;3186
0024a4  ebfffffe          BL       yaffs_rd_chunk_tags_nand
0024a8  e1a06005          MOV      r6,r5                 ;3187
0024ac  e596010c          LDR      r0,[r6,#0x10c]        ;3189
0024b0  e5840034          STR      r0,[r4,#0x34]         ;3189
0024b4  e1a01006          MOV      r1,r6                 ;3190
0024b8  e1a00004          MOV      r0,r4                 ;3190
0024bc  ebfffffe          BL       yaffs_load_attribs
0024c0  e1a01006          MOV      r1,r6                 ;3191
0024c4  e1a00004          MOV      r0,r4                 ;3191
0024c8  ebfffffe          BL       yaffs_set_obj_name_from_oh
0024cc  e5d40064          LDRB     r0,[r4,#0x64]         ;3193
0024d0  e3500002          CMP      r0,#2                 ;3193
0024d4  1a000002          BNE      |L1.9444|
0024d8  e2860f4b          ADD      r0,r6,#0x12c          ;3194
0024dc  ebfffffe          BL       yaffs_clone_str
0024e0  e5840068          STR      r0,[r4,#0x68]         ;3194
                  |L1.9444|
0024e4  e1a01005          MOV      r1,r5                 ;3197
0024e8  e1a00007          MOV      r0,r7                 ;3197
0024ec  ebfffffe          BL       yaffs_release_temp_buffer
0024f0  e1a00000          MOV      r0,r0
0024f4  eaffffdd          B        |L1.9328|
;;;3199   
                          ENDP

                  yaffs_unhash_obj PROC
;;;1608   
;;;1609   static void yaffs_unhash_obj(struct yaffs_obj *obj)
0024f8  e92d4070          PUSH     {r4-r6,lr}
;;;1610   {
0024fc  e1a04000          MOV      r4,r0
;;;1611   	int bucket;
;;;1612   	struct yaffs_dev *dev = obj->my_dev;
002500  e5946008          LDR      r6,[r4,#8]
;;;1613   
;;;1614   	/* If it is still linked into the bucket list, free from the list */
;;;1615   	if (!list_empty(&obj->hash_link)) {
002504  e284000c          ADD      r0,r4,#0xc
002508  ebfffffe          BL       list_empty
00250c  e3500000          CMP      r0,#0
002510  1a00000d          BNE      |L1.9548|
;;;1616   		list_del_init(&obj->hash_link);
002514  e284000c          ADD      r0,r4,#0xc
002518  ebfffffe          BL       list_del_init
;;;1617   		bucket = yaffs_hash_fn(obj->obj_id);
00251c  e5940030          LDR      r0,[r4,#0x30]
002520  ebfffffe          BL       yaffs_hash_fn
002524  e1a05000          MOV      r5,r0
;;;1618   		dev->obj_bucket[bucket].count--;
002528  e0850085          ADD      r0,r5,r5,LSL #1
00252c  e2861f52          ADD      r1,r6,#0x148
002530  e0810100          ADD      r0,r1,r0,LSL #2
002534  e5900008          LDR      r0,[r0,#8]
002538  e2400001          SUB      r0,r0,#1
00253c  e0851085          ADD      r1,r5,r5,LSL #1
002540  e2862f52          ADD      r2,r6,#0x148
002544  e0821101          ADD      r1,r2,r1,LSL #2
002548  e5810008          STR      r0,[r1,#8]
                  |L1.9548|
;;;1619   	}
;;;1620   }
00254c  e8bd8070          POP      {r4-r6,pc}
;;;1621   
                          ENDP

                  yaffs_free_obj PROC
;;;1622   /*  FreeObject frees up a Object and puts it back on the free list */
;;;1623   static void yaffs_free_obj(struct yaffs_obj *obj)
002550  e92d4070          PUSH     {r4-r6,lr}
;;;1624   {
002554  e1a04000          MOV      r4,r0
;;;1625   	struct yaffs_dev *dev;
;;;1626   
;;;1627   	if (!obj) {
002558  e3540000          CMP      r4,#0
00255c  1a000006          BNE      |L1.9596|
;;;1628   		BUG();
002560  e1a00000          MOV      r0,r0
002564  e59f20d0          LDR      r2,|L1.9788|
002568  e59f10d0          LDR      r1,|L1.9792|
00256c  e51f0614          LDR      r0,|L1.8032|
002570  ebfffffe          BL       sysprintf
002574  e1a00000          MOV      r0,r0
                  |L1.9592|
;;;1629   		return;
;;;1630   	}
;;;1631   	dev = obj->my_dev;
;;;1632   	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
;;;1633   		obj, obj->my_inode);
;;;1634   	if (obj->parent)
;;;1635   		BUG();
;;;1636   	if (!list_empty(&obj->siblings))
;;;1637   		BUG();
;;;1638   
;;;1639   	if (obj->my_inode) {
;;;1640   		/* We're still hooked up to a cached inode.
;;;1641   		 * Don't delete now, but mark for later deletion
;;;1642   		 */
;;;1643   		obj->defered_free = 1;
;;;1644   		return;
;;;1645   	}
;;;1646   
;;;1647   	yaffs_unhash_obj(obj);
;;;1648   
;;;1649   	yaffs_free_raw_obj(dev, obj);
;;;1650   	dev->n_obj--;
;;;1651   	dev->checkpoint_blocks_required = 0;	/* force recalculation */
;;;1652   }
002578  e8bd8070          POP      {r4-r6,pc}
                  |L1.9596|
00257c  e5945008          LDR      r5,[r4,#8]            ;1631
002580  e51f0ff0          LDR      r0,|L1.5528|
002584  e5d00000          LDRB     r0,[r0,#0]            ;1632  ; yaffs_trace_mask
002588  e3100002          TST      r0,#2                 ;1632
00258c  0a000003          BEQ      |L1.9632|
002590  e5942060          LDR      r2,[r4,#0x60]         ;1632
002594  e1a01004          MOV      r1,r4                 ;1632
002598  e28f00a4          ADR      r0,|L1.9796|
00259c  ebfffffe          BL       sysprintf
                  |L1.9632|
0025a0  e594001c          LDR      r0,[r4,#0x1c]         ;1634
0025a4  e3500000          CMP      r0,#0                 ;1634
0025a8  0a000005          BEQ      |L1.9668|
0025ac  e1a00000          MOV      r0,r0                 ;1635
0025b0  e59f20ac          LDR      r2,|L1.9828|
0025b4  e59f1084          LDR      r1,|L1.9792|
0025b8  e51f0660          LDR      r0,|L1.8032|
0025bc  ebfffffe          BL       sysprintf
0025c0  e1a00000          MOV      r0,r0                 ;1635
                  |L1.9668|
0025c4  e2840020          ADD      r0,r4,#0x20           ;1636
0025c8  ebfffffe          BL       list_empty
0025cc  e3500000          CMP      r0,#0                 ;1636
0025d0  1a000005          BNE      |L1.9708|
0025d4  e1a00000          MOV      r0,r0                 ;1637
0025d8  e59f2088          LDR      r2,|L1.9832|
0025dc  e59f105c          LDR      r1,|L1.9792|
0025e0  e51f0688          LDR      r0,|L1.8032|
0025e4  ebfffffe          BL       sysprintf
0025e8  e1a00000          MOV      r0,r0                 ;1637
                  |L1.9708|
0025ec  e5940060          LDR      r0,[r4,#0x60]         ;1639
0025f0  e3500000          CMP      r0,#0                 ;1639
0025f4  0a000003          BEQ      |L1.9736|
0025f8  e5d40001          LDRB     r0,[r4,#1]            ;1643
0025fc  e3800002          ORR      r0,r0,#2              ;1643
002600  e5c40001          STRB     r0,[r4,#1]            ;1643
002604  eaffffdb          B        |L1.9592|
                  |L1.9736|
002608  e1a00004          MOV      r0,r4                 ;1647
00260c  ebfffffe          BL       yaffs_unhash_obj
002610  e1a01004          MOV      r1,r4                 ;1649
002614  e1a00005          MOV      r0,r5                 ;1649
002618  ebfffffe          BL       yaffs_free_raw_obj
00261c  e595013c          LDR      r0,[r5,#0x13c]        ;1650
002620  e2400001          SUB      r0,r0,#1              ;1650
002624  e585013c          STR      r0,[r5,#0x13c]        ;1650
002628  e3a00000          MOV      r0,#0                 ;1651
00262c  e5850114          STR      r0,[r5,#0x114]        ;1651
002630  e1a00000          MOV      r0,r0
002634  eaffffcf          B        |L1.9592|
                  |L1.9784|
002638  00                DCB      0
002639  00                DCB      0
00263a  00                DCB      0
00263b  00                DCB      0
                  |L1.9788|
                          DCD      0x0000065c
                  |L1.9792|
                          DCD      ||.text||+0x1f2c
                  |L1.9796|
002644  79616666          DCB      "yaffs: FreeObject %p inode %p\n",0
002648  733a2046
00264c  7265654f
002650  626a6563
002654  74202570
002658  20696e6f
00265c  64652025
002660  700a00  
002663  00                DCB      0
                  |L1.9828|
                          DCD      0x00000663
                  |L1.9832|
                          DCD      0x00000665
                          ENDP

                  yaffs_invalidate_whole_cache PROC
;;;1594    */
;;;1595   static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
00266c  e92d4010          PUSH     {r4,lr}
;;;1596   {
002670  e1a02000          MOV      r2,r0
;;;1597   	int i;
;;;1598   	struct yaffs_dev *dev = in->my_dev;
002674  e5921008          LDR      r1,[r2,#8]
;;;1599   
;;;1600   	if (dev->param.n_caches > 0) {
002678  e5913020          LDR      r3,[r1,#0x20]
00267c  e3530000          CMP      r3,#0
002680  da00000e          BLE      |L1.9920|
;;;1601   		/* Invalidate it. */
;;;1602   		for (i = 0; i < dev->param.n_caches; i++) {
002684  e3a00000          MOV      r0,#0
002688  ea000009          B        |L1.9908|
                  |L1.9868|
;;;1603   			if (dev->cache[i].object == in)
00268c  e060c180          RSB      r12,r0,r0,LSL #3
002690  e5913d90          LDR      r3,[r1,#0xd90]
002694  e793310c          LDR      r3,[r3,r12,LSL #2]
002698  e1530002          CMP      r3,r2
00269c  1a000003          BNE      |L1.9904|
;;;1604   				dev->cache[i].object = NULL;
0026a0  e3a03000          MOV      r3,#0
0026a4  e0604180          RSB      r4,r0,r0,LSL #3
0026a8  e591cd90          LDR      r12,[r1,#0xd90]
0026ac  e78c3104          STR      r3,[r12,r4,LSL #2]
                  |L1.9904|
0026b0  e2800001          ADD      r0,r0,#1              ;1602
                  |L1.9908|
0026b4  e5913020          LDR      r3,[r1,#0x20]         ;1602
0026b8  e1530000          CMP      r3,r0                 ;1602
0026bc  cafffff2          BGT      |L1.9868|
                  |L1.9920|
;;;1605   		}
;;;1606   	}
;;;1607   }
0026c0  e8bd8010          POP      {r4,pc}
;;;1608   
                          ENDP

                  yaffs_generic_obj_del PROC
;;;1659   
;;;1660   static int yaffs_generic_obj_del(struct yaffs_obj *in)
0026c4  e92d4038          PUSH     {r3-r5,lr}
;;;1661   {
0026c8  e1a04000          MOV      r4,r0
;;;1662   	/* Iinvalidate the file's data in the cache, without flushing. */
;;;1663   	yaffs_invalidate_whole_cache(in);
0026cc  e1a00004          MOV      r0,r4
0026d0  ebfffffe          BL       yaffs_invalidate_whole_cache
;;;1664   
;;;1665   	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
0026d4  e5940008          LDR      r0,[r4,#8]
0026d8  e5900030          LDR      r0,[r0,#0x30]
0026dc  e3500000          CMP      r0,#0
0026e0  0a00000c          BEQ      |L1.10008|
0026e4  e594001c          LDR      r0,[r4,#0x1c]
0026e8  e5941008          LDR      r1,[r4,#8]
0026ec  e5911d9c          LDR      r1,[r1,#0xd9c]
0026f0  e1500001          CMP      r0,r1
0026f4  0a000007          BEQ      |L1.10008|
;;;1666   		/* Move to unlinked directory so we have a deletion record */
;;;1667   		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
0026f8  e3a00000          MOV      r0,#0
0026fc  e58d0000          STR      r0,[sp,#0]
002700  e5940008          LDR      r0,[r4,#8]
002704  e3a03000          MOV      r3,#0
002708  e28f2fce          ADR      r2,|L1.10824|
00270c  e5901d9c          LDR      r1,[r0,#0xd9c]
002710  e1a00004          MOV      r0,r4
002714  ebfffffe          BL       yaffs_change_obj_name
                  |L1.10008|
;;;1668   				      0);
;;;1669   	}
;;;1670   
;;;1671   	yaffs_remove_obj_from_dir(in);
002718  e1a00004          MOV      r0,r4
00271c  ebfffffe          BL       yaffs_remove_obj_from_dir
;;;1672   	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
002720  e5940008          LDR      r0,[r4,#8]
002724  e5941028          LDR      r1,[r4,#0x28]
002728  e59f3320          LDR      r3,|L1.10832|
00272c  e3a02001          MOV      r2,#1
002730  ebfffffe          BL       yaffs_chunk_del
;;;1673   	in->hdr_chunk = 0;
002734  e3a00000          MOV      r0,#0
002738  e5840028          STR      r0,[r4,#0x28]
;;;1674   
;;;1675   	yaffs_free_obj(in);
00273c  e1a00004          MOV      r0,r4
002740  ebfffffe          BL       yaffs_free_obj
;;;1676   	return YAFFS_OK;
002744  e3a00001          MOV      r0,#1
;;;1677   
;;;1678   }
002748  e8bd8038          POP      {r3-r5,pc}
;;;1679   
                          ENDP

                  yaffs_find_by_number PROC
;;;1907   
;;;1908   struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
00274c  e92d41f0          PUSH     {r4-r8,lr}
;;;1909   {
002750  e1a05000          MOV      r5,r0
002754  e1a06001          MOV      r6,r1
;;;1910   	int bucket = yaffs_hash_fn(number);
002758  e1a00006          MOV      r0,r6
00275c  ebfffffe          BL       yaffs_hash_fn
002760  e1a08000          MOV      r8,r0
;;;1911   	struct list_head *i;
;;;1912   	struct yaffs_obj *in;
;;;1913   
;;;1914   	list_for_each(i, &dev->obj_bucket[bucket].list) {
002764  e0880088          ADD      r0,r8,r8,LSL #1
002768  e2851f52          ADD      r1,r5,#0x148
00276c  e7917100          LDR      r7,[r1,r0,LSL #2]
002770  ea00000c          B        |L1.10152|
                  |L1.10100|
;;;1915   		/* Look if it is in the list */
;;;1916   		in = list_entry(i, struct yaffs_obj, hash_link);
002774  e247400c          SUB      r4,r7,#0xc
;;;1917   		if (in->obj_id == number) {
002778  e5940030          LDR      r0,[r4,#0x30]
00277c  e1500006          CMP      r0,r6
002780  1a000007          BNE      |L1.10148|
;;;1918   			/* Don't show if it is defered free */
;;;1919   			if (in->defered_free)
002784  e5d40001          LDRB     r0,[r4,#1]
002788  e1a00f00          LSL      r0,r0,#30
00278c  e1b00fa0          LSRS     r0,r0,#31
002790  0a000001          BEQ      |L1.10140|
;;;1920   				return NULL;
002794  e3a00000          MOV      r0,#0
                  |L1.10136|
;;;1921   			return in;
;;;1922   		}
;;;1923   	}
;;;1924   
;;;1925   	return NULL;
;;;1926   }
002798  e8bd81f0          POP      {r4-r8,pc}
                  |L1.10140|
00279c  e1a00004          MOV      r0,r4                 ;1921
0027a0  eafffffc          B        |L1.10136|
                  |L1.10148|
0027a4  e5977000          LDR      r7,[r7,#0]            ;1914
                  |L1.10152|
0027a8  e0880088          ADD      r0,r8,r8,LSL #1       ;1914
0027ac  e2851f52          ADD      r1,r5,#0x148          ;1914
0027b0  e0810100          ADD      r0,r1,r0,LSL #2       ;1914
0027b4  e1500007          CMP      r0,r7                 ;1914
0027b8  1affffed          BNE      |L1.10100|
0027bc  e3a00000          MOV      r0,#0                 ;1925
0027c0  eafffff4          B        |L1.10136|
;;;1927   
                          ENDP

                  yaffs_gc_process_chunk PROC
;;;2397   
;;;2398   static __inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
0027c4  e92d4ff0          PUSH     {r4-r11,lr}
;;;2399   					struct yaffs_block_info *bi,
;;;2400   					int old_chunk, u8 *buffer)
;;;2401   {
0027c8  e24dd05c          SUB      sp,sp,#0x5c
0027cc  e1a05000          MOV      r5,r0
0027d0  e1a0a001          MOV      r10,r1
0027d4  e1a0b002          MOV      r11,r2
0027d8  e1a06003          MOV      r6,r3
;;;2402   	int new_chunk;
;;;2403   	int mark_flash = 1;
0027dc  e3a00001          MOV      r0,#1
0027e0  e58d0058          STR      r0,[sp,#0x58]
;;;2404   	struct yaffs_ext_tags tags;
;;;2405   	struct yaffs_obj *object;
;;;2406   	int matching_chunk;
;;;2407   	int ret_val = YAFFS_OK;
0027e4  e58d000c          STR      r0,[sp,#0xc]
;;;2408   
;;;2409   	memset(&tags, 0, sizeof(tags));
0027e8  e3a01048          MOV      r1,#0x48
0027ec  e28d0010          ADD      r0,sp,#0x10
0027f0  ebfffffe          BL       __aeabi_memclr4
;;;2410   	yaffs_rd_chunk_tags_nand(dev, old_chunk,
0027f4  e28d3010          ADD      r3,sp,#0x10
0027f8  e1a02006          MOV      r2,r6
0027fc  e1a0100b          MOV      r1,r11
002800  e1a00005          MOV      r0,r5
002804  ebfffffe          BL       yaffs_rd_chunk_tags_nand
;;;2411   				 buffer, &tags);
;;;2412   	object = yaffs_find_by_number(dev, tags.obj_id);
002808  e1a00005          MOV      r0,r5
00280c  e59d1014          LDR      r1,[sp,#0x14]
002810  ebfffffe          BL       yaffs_find_by_number
002814  e1a04000          MOV      r4,r0
;;;2413   
;;;2414   	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
002818  e59f0234          LDR      r0,|L1.10836|
00281c  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
002820  e3100a01          TST      r0,#0x1000
002824  0a000006          BEQ      |L1.10308|
002828  e59d001c          LDR      r0,[sp,#0x1c]
00282c  e58d0000          STR      r0,[sp,#0]
002830  e59d2014          LDR      r2,[sp,#0x14]
002834  e59d3018          LDR      r3,[sp,#0x18]
002838  e28f0f86          ADR      r0,|L1.10840|
00283c  e5951d74          LDR      r1,[r5,#0xd74]
002840  ebfffffe          BL       sysprintf
                  |L1.10308|
;;;2415   		"Collecting chunk in block %d, %d %d %d ",
;;;2416   		dev->gc_chunk, tags.obj_id,
;;;2417   		tags.chunk_id, tags.n_bytes);
;;;2418   
;;;2419   	if (object && !yaffs_skip_verification(dev)) {
002844  e3540000          CMP      r4,#0
002848  0a000020          BEQ      |L1.10448|
00284c  e1a00005          MOV      r0,r5
002850  ebfffffe          BL       yaffs_skip_verification
002854  e3500000          CMP      r0,#0
002858  1a00001c          BNE      |L1.10448|
;;;2420   		if (tags.chunk_id == 0)
00285c  e59d0018          LDR      r0,[sp,#0x18]
002860  e3500000          CMP      r0,#0
002864  1a000001          BNE      |L1.10352|
;;;2421   			matching_chunk =
002868  e5948028          LDR      r8,[r4,#0x28]
00286c  ea00000a          B        |L1.10396|
                  |L1.10352|
;;;2422   			    object->hdr_chunk;
;;;2423   		else if (object->soft_del)
002870  e5d40000          LDRB     r0,[r4,#0]
002874  e1a00f00          LSL      r0,r0,#30
002878  e1b00fa0          LSRS     r0,r0,#31
00287c  0a000001          BEQ      |L1.10376|
;;;2424   			/* Defeat the test */
;;;2425   			matching_chunk = old_chunk;
002880  e1a0800b          MOV      r8,r11
002884  ea000004          B        |L1.10396|
                  |L1.10376|
;;;2426   		else
;;;2427   			matching_chunk =
002888  e3a02000          MOV      r2,#0
00288c  e1a00004          MOV      r0,r4
002890  e59d1018          LDR      r1,[sp,#0x18]
002894  ebfffffe          BL       yaffs_find_chunk_in_file
002898  e1a08000          MOV      r8,r0
                  |L1.10396|
;;;2428   			    yaffs_find_chunk_in_file
;;;2429   			    (object, tags.chunk_id,
;;;2430   			     NULL);
;;;2431   
;;;2432   		if (old_chunk != matching_chunk)
00289c  e15b0008          CMP      r11,r8
0028a0  0a00000a          BEQ      |L1.10448|
;;;2433   			yaffs_trace(YAFFS_TRACE_ERROR,
0028a4  e59f01a8          LDR      r0,|L1.10836|
0028a8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0028ac  e3100101          TST      r0,#0x40000000
0028b0  0a000006          BEQ      |L1.10448|
0028b4  e59d0018          LDR      r0,[sp,#0x18]
0028b8  e58d0000          STR      r0,[sp,#0]
0028bc  e1a02008          MOV      r2,r8
0028c0  e1a0100b          MOV      r1,r11
0028c4  e28f0f6f          ADR      r0,|L1.10888|
0028c8  e59d3014          LDR      r3,[sp,#0x14]
0028cc  ebfffffe          BL       sysprintf
                  |L1.10448|
;;;2434   				"gc: page in gc mismatch: %d %d %d %d",
;;;2435   				old_chunk,
;;;2436   				matching_chunk,
;;;2437   				tags.obj_id,
;;;2438   				tags.chunk_id);
;;;2439   	}
;;;2440   
;;;2441   	if (!object) {
0028d0  e3540000          CMP      r4,#0
0028d4  1a00000a          BNE      |L1.10500|
;;;2442   		yaffs_trace(YAFFS_TRACE_ERROR,
0028d8  e59f0174          LDR      r0,|L1.10836|
0028dc  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0028e0  e3100101          TST      r0,#0x40000000
0028e4  0a000006          BEQ      |L1.10500|
0028e8  e59d001c          LDR      r0,[sp,#0x1c]
0028ec  e58d0000          STR      r0,[sp,#0]
0028f0  e1a0100b          MOV      r1,r11
0028f4  e28f0f6f          ADR      r0,|L1.10936|
0028f8  e59d2014          LDR      r2,[sp,#0x14]
0028fc  e59d3018          LDR      r3,[sp,#0x18]
002900  ebfffffe          BL       sysprintf
                  |L1.10500|
;;;2443   			"page %d in gc has no object: %d %d %d ",
;;;2444   			old_chunk,
;;;2445   			tags.obj_id, tags.chunk_id,
;;;2446   			tags.n_bytes);
;;;2447   	}
;;;2448   
;;;2449   	if (object &&
002904  e3540000          CMP      r4,#0
002908  0a000025          BEQ      |L1.10660|
;;;2450   	    object->deleted &&
00290c  e5d40000          LDRB     r0,[r4,#0]
002910  e3100001          TST      r0,#1
002914  0a000022          BEQ      |L1.10660|
;;;2451   	    object->soft_del && tags.chunk_id != 0) {
002918  e5d40000          LDRB     r0,[r4,#0]
00291c  e1a00f00          LSL      r0,r0,#30
002920  e1b00fa0          LSRS     r0,r0,#31
002924  0a00001e          BEQ      |L1.10660|
002928  e59d0018          LDR      r0,[sp,#0x18]
00292c  e3500000          CMP      r0,#0
002930  0a00001b          BEQ      |L1.10660|
;;;2452   		/* Data chunk in a soft deleted file,
;;;2453   		 * throw it away.
;;;2454   		 * It's a soft deleted data chunk,
;;;2455   		 * No need to copy this, just forget
;;;2456   		 * about it and fix up the object.
;;;2457   		 */
;;;2458   
;;;2459   		/* Free chunks already includes
;;;2460   		 * softdeleted chunks, how ever this
;;;2461   		 * chunk is going to soon be really
;;;2462   		 * deleted which will increment free
;;;2463   		 * chunks. We have to decrement free
;;;2464   		 * chunks so this works out properly.
;;;2465   		 */
;;;2466   		dev->n_free_chunks--;
002934  e5950d4c          LDR      r0,[r5,#0xd4c]
002938  e2400001          SUB      r0,r0,#1
00293c  e5850d4c          STR      r0,[r5,#0xd4c]
;;;2467   		bi->soft_del_pages--;
002940  e59a0000          LDR      r0,[r10,#0]
002944  e1a00520          LSR      r0,r0,#10
002948  e1a00500          LSL      r0,r0,#10
00294c  e1da10b0          LDRH     r1,[r10,#0]
002950  e2411001          SUB      r1,r1,#1
002954  e1a01b01          LSL      r1,r1,#22
002958  e1a01b21          LSR      r1,r1,#22
00295c  e1800001          ORR      r0,r0,r1
002960  e58a0000          STR      r0,[r10,#0]
;;;2468   
;;;2469   		object->n_data_chunks--;
002964  e594002c          LDR      r0,[r4,#0x2c]
002968  e2400001          SUB      r0,r0,#1
00296c  e584002c          STR      r0,[r4,#0x2c]
;;;2470   		if (object->n_data_chunks <= 0) {
002970  e594002c          LDR      r0,[r4,#0x2c]
002974  e3500000          CMP      r0,#0
002978  ca000006          BGT      |L1.10648|
;;;2471   			/* remeber to clean up obj */
;;;2472   			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
00297c  e59d0014          LDR      r0,[sp,#0x14]
002980  e5951d50          LDR      r1,[r5,#0xd50]
002984  e5952d54          LDR      r2,[r5,#0xd54]
002988  e7810102          STR      r0,[r1,r2,LSL #2]
;;;2473   			dev->n_clean_ups++;
00298c  e5950d54          LDR      r0,[r5,#0xd54]
002990  e2800001          ADD      r0,r0,#1
002994  e5850d54          STR      r0,[r5,#0xd54]
                  |L1.10648|
;;;2474   		}
;;;2475   		mark_flash = 0;
002998  e3a00000          MOV      r0,#0
00299c  e58d0058          STR      r0,[sp,#0x58]
0029a0  ea000067          B        |L1.11076|
                  |L1.10660|
;;;2476   	} else if (object) {
0029a4  e3540000          CMP      r4,#0
0029a8  0a000065          BEQ      |L1.11076|
;;;2477   		/* It's either a data chunk in a live
;;;2478   		 * file or an ObjectHeader, so we're
;;;2479   		 * interested in it.
;;;2480   		 * NB Need to keep the ObjectHeaders of
;;;2481   		 * deleted files until the whole file
;;;2482   		 * has been deleted off
;;;2483   		 */
;;;2484   		tags.serial_number++;
0029ac  e59d002c          LDR      r0,[sp,#0x2c]
0029b0  e2800001          ADD      r0,r0,#1
0029b4  e58d002c          STR      r0,[sp,#0x2c]
;;;2485   		dev->n_gc_copies++;
0029b8  e5950e20          LDR      r0,[r5,#0xe20]
0029bc  e2800001          ADD      r0,r0,#1
0029c0  e5850e20          STR      r0,[r5,#0xe20]
;;;2486   
;;;2487   		if (tags.chunk_id == 0) {
0029c4  e59d0018          LDR      r0,[sp,#0x18]
0029c8  e3500000          CMP      r0,#0
0029cc  1a000045          BNE      |L1.10984|
;;;2488   			/* It is an object Id,
;;;2489   			 * We need to nuke the
;;;2490   			 * shrinkheader flags since its
;;;2491   			 * work is done.
;;;2492   			 * Also need to clean up
;;;2493   			 * shadowing.
;;;2494   			 */
;;;2495   			struct yaffs_obj_hdr *oh;
;;;2496   			oh = (struct yaffs_obj_hdr *) buffer;
0029d0  e1a09006          MOV      r9,r6
;;;2497   
;;;2498   			oh->is_shrink = 0;
0029d4  e3a00000          MOV      r0,#0
0029d8  e58901fc          STR      r0,[r9,#0x1fc]
;;;2499   			tags.extra_is_shrink = 0;
0029dc  e58d003c          STR      r0,[sp,#0x3c]
;;;2500   			oh->shadows_obj = 0;
0029e0  e58901f8          STR      r0,[r9,#0x1f8]
;;;2501   			oh->inband_shadowed_obj_id = 0;
0029e4  e58901e8          STR      r0,[r9,#0x1e8]
;;;2502   			tags.extra_shadows = 0;
0029e8  e58d0040          STR      r0,[sp,#0x40]
;;;2503   
;;;2504   			/* Update file size */
;;;2505   			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
0029ec  e5d40064          LDRB     r0,[r4,#0x64]
0029f0  e3500001          CMP      r0,#1
0029f4  1a000007          BNE      |L1.10776|
;;;2506   				yaffs_oh_size_load(oh,
0029f8  e1c406d8          LDRD     r0,r1,[r4,#0x68]
0029fc  e1cd00f0          STRD     r0,r1,[sp,#0]
002a00  e1a02000          MOV      r2,r0
002a04  e1a03001          MOV      r3,r1
002a08  e1a00009          MOV      r0,r9
002a0c  ebfffffe          BL       yaffs_oh_size_load
;;;2507   				    object->variant.file_variant.file_size);
;;;2508   				tags.extra_file_size =
002a10  e1c406d8          LDRD     r0,r1,[r4,#0x68]
002a14  e1cd04f8          STRD     r0,r1,[sp,#0x48]
                  |L1.10776|
;;;2509   				    object->variant.file_variant.file_size;
;;;2510   			}
;;;2511   
;;;2512   			yaffs_verify_oh(object, oh, &tags, 1);
002a18  e3a03001          MOV      r3,#1
002a1c  e28d2010          ADD      r2,sp,#0x10
002a20  e1a01009          MOV      r1,r9
002a24  e1a00004          MOV      r0,r4
002a28  ebfffffe          BL       yaffs_verify_oh
;;;2513   			new_chunk =
002a2c  e3a03001          MOV      r3,#1
002a30  e28d2010          ADD      r2,sp,#0x10
002a34  e1a01009          MOV      r1,r9
002a38  e1a00005          MOV      r0,r5
002a3c  ebfffffe          BL       yaffs_write_new_chunk
002a40  e1a07000          MOV      r7,r0
;;;2514   			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
;;;2515   		} else {
002a44  ea00002d          B        |L1.11008|
                  |L1.10824|
002a48  64656c65          DCB      "deleted",0
002a4c  74656400
                  |L1.10832|
                          DCD      0x00000688
                  |L1.10836|
                          DCD      yaffs_trace_mask
                  |L1.10840|
002a58  79616666          DCB      "yaffs: Collecting chunk in block %d, %d %d %d \n",0
002a5c  733a2043
002a60  6f6c6c65
002a64  6374696e
002a68  67206368
002a6c  756e6b20
002a70  696e2062
002a74  6c6f636b
002a78  2025642c
002a7c  20256420
002a80  25642025
002a84  64200a00
                  |L1.10888|
002a88  79616666          DCB      "yaffs: gc: page in gc mismatch: %d %d %d %d\n",0
002a8c  733a2067
002a90  633a2070
002a94  61676520
002a98  696e2067
002a9c  63206d69
002aa0  736d6174
002aa4  63683a20
002aa8  25642025
002aac  64202564
002ab0  2025640a
002ab4  00      
002ab5  00                DCB      0
002ab6  00                DCB      0
002ab7  00                DCB      0
                  |L1.10936|
002ab8  79616666          DCB      "yaffs: page %d in gc has no object: %d %d %d \n",0
002abc  733a2070
002ac0  61676520
002ac4  25642069
002ac8  6e206763
002acc  20686173
002ad0  206e6f20
002ad4  6f626a65
002ad8  63743a20
002adc  25642025
002ae0  64202564
002ae4  200a00  
002ae7  00                DCB      0
                  |L1.10984|
;;;2516   			new_chunk =
002ae8  e3a03001          MOV      r3,#1
002aec  e28d2010          ADD      r2,sp,#0x10
002af0  e1a01006          MOV      r1,r6
002af4  e1a00005          MOV      r0,r5
002af8  ebfffffe          BL       yaffs_write_new_chunk
002afc  e1a07000          MOV      r7,r0
                  |L1.11008|
;;;2517   			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
;;;2518   		}
;;;2519   
;;;2520   		if (new_chunk < 0) {
002b00  e3570000          CMP      r7,#0
002b04  aa000002          BGE      |L1.11028|
;;;2521   			ret_val = YAFFS_FAIL;
002b08  e3a00000          MOV      r0,#0
002b0c  e58d000c          STR      r0,[sp,#0xc]
002b10  ea00000b          B        |L1.11076|
                  |L1.11028|
;;;2522   		} else {
;;;2523   
;;;2524   			/* Now fix up the Tnodes etc. */
;;;2525   
;;;2526   			if (tags.chunk_id == 0) {
002b14  e59d0018          LDR      r0,[sp,#0x18]
002b18  e3500000          CMP      r0,#0
002b1c  1a000003          BNE      |L1.11056|
;;;2527   				/* It's a header */
;;;2528   				object->hdr_chunk = new_chunk;
002b20  e5847028          STR      r7,[r4,#0x28]
;;;2529   				object->serial = tags.serial_number;
002b24  e59d002c          LDR      r0,[sp,#0x2c]
002b28  e5c40002          STRB     r0,[r4,#2]
002b2c  ea000004          B        |L1.11076|
                  |L1.11056|
;;;2530   			} else {
;;;2531   				/* It's a data chunk */
;;;2532   				yaffs_put_chunk_in_file(object, tags.chunk_id,
002b30  e3a03000          MOV      r3,#0
002b34  e1a02007          MOV      r2,r7
002b38  e1a00004          MOV      r0,r4
002b3c  e59d1018          LDR      r1,[sp,#0x18]
002b40  ebfffffe          BL       yaffs_put_chunk_in_file
                  |L1.11076|
;;;2533   							new_chunk, 0);
;;;2534   			}
;;;2535   		}
;;;2536   	}
;;;2537   	if (ret_val == YAFFS_OK)
002b44  e59d000c          LDR      r0,[sp,#0xc]
002b48  e3500001          CMP      r0,#1
002b4c  1a000004          BNE      |L1.11108|
;;;2538   		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
002b50  e59f3314          LDR      r3,|L1.11884|
002b54  e1a0100b          MOV      r1,r11
002b58  e1a00005          MOV      r0,r5
002b5c  e59d2058          LDR      r2,[sp,#0x58]
002b60  ebfffffe          BL       yaffs_chunk_del
                  |L1.11108|
;;;2539   	return ret_val;
002b64  e59d000c          LDR      r0,[sp,#0xc]
002b68  e28dd05c          ADD      sp,sp,#0x5c
;;;2540   }
002b6c  e8bd8ff0          POP      {r4-r11,pc}
;;;2541   
                          ENDP

                  yaffs_gc_block PROC
;;;2542   static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
002b70  e92d4ff0          PUSH     {r4-r11,lr}
;;;2543   {
002b74  e24dd014          SUB      sp,sp,#0x14
002b78  e1a04000          MOV      r4,r0
002b7c  e1a09001          MOV      r9,r1
002b80  e1a0a002          MOV      r10,r2
;;;2544   	int old_chunk;
;;;2545   	int ret_val = YAFFS_OK;
002b84  e3a00001          MOV      r0,#1
002b88  e58d0010          STR      r0,[sp,#0x10]
;;;2546   	int i;
;;;2547   	int is_checkpt_block;
;;;2548   	int max_copies;
;;;2549   	int chunks_before = yaffs_get_erased_chunks(dev);
002b8c  e1a00004          MOV      r0,r4
002b90  ebfffffe          BL       yaffs_get_erased_chunks
002b94  e58d0004          STR      r0,[sp,#4]
;;;2550   	int chunks_after;
;;;2551   	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
002b98  e1a01009          MOV      r1,r9
002b9c  e1a00004          MOV      r0,r4
002ba0  ebfffffe          BL       yaffs_get_block_info
002ba4  e1a05000          MOV      r5,r0
;;;2552   
;;;2553   	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
002ba8  e5950000          LDR      r0,[r5,#0]
002bac  e200060f          AND      r0,r0,#0xf00000
002bb0  e3500607          CMP      r0,#0x700000
002bb4  1a000001          BNE      |L1.11200|
002bb8  e3a00001          MOV      r0,#1
002bbc  ea000000          B        |L1.11204|
                  |L1.11200|
002bc0  e3a00000          MOV      r0,#0
                  |L1.11204|
002bc4  e58d000c          STR      r0,[sp,#0xc]
;;;2554   
;;;2555   	yaffs_trace(YAFFS_TRACE_TRACING,
002bc8  e51f017c          LDR      r0,|L1.10836|
002bcc  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
002bd0  e3100c01          TST      r0,#0x100
002bd4  0a000007          BEQ      |L1.11256|
002bd8  e58da000          STR      r10,[sp,#0]
002bdc  e5950000          LDR      r0,[r5,#0]
002be0  e1a03fa0          LSR      r3,r0,#31
002be4  e1a00600          LSL      r0,r0,#12
002be8  e1a02b20          LSR      r2,r0,#22
002bec  e1a01009          MOV      r1,r9
002bf0  e59f0278          LDR      r0,|L1.11888|
002bf4  ebfffffe          BL       sysprintf
                  |L1.11256|
;;;2556   		"Collecting block %d, in use %d, shrink %d, whole_block %d",
;;;2557   		block, bi->pages_in_use, bi->has_shrink_hdr,
;;;2558   		whole_block);
;;;2559   
;;;2560   	/*yaffs_verify_free_chunks(dev); */
;;;2561   
;;;2562   	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
002bf8  e5950000          LDR      r0,[r5,#0]
002bfc  e200060f          AND      r0,r0,#0xf00000
002c00  e3500605          CMP      r0,#0x500000
002c04  1a000003          BNE      |L1.11288|
;;;2563   		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
002c08  e5950000          LDR      r0,[r5,#0]
002c0c  e3c0060f          BIC      r0,r0,#0xf00000
002c10  e3800502          ORR      r0,r0,#0x800000
002c14  e5850000          STR      r0,[r5,#0]
                  |L1.11288|
;;;2564   
;;;2565   	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
002c18  e5950000          LDR      r0,[r5,#0]
002c1c  e3c00102          BIC      r0,r0,#0x80000000
002c20  e5850000          STR      r0,[r5,#0]
;;;2566   
;;;2567   	dev->gc_disable = 1;
002c24  e3a00001          MOV      r0,#1
002c28  e5840d5c          STR      r0,[r4,#0xd5c]
;;;2568   
;;;2569   	yaffs_summary_gc(dev, block);
002c2c  e1a01009          MOV      r1,r9
002c30  e1a00004          MOV      r0,r4
002c34  ebfffffe          BL       yaffs_summary_gc
;;;2570   
;;;2571   	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
002c38  e59d000c          LDR      r0,[sp,#0xc]
002c3c  e3500000          CMP      r0,#0
002c40  1a000004          BNE      |L1.11352|
002c44  e1a01009          MOV      r1,r9
002c48  e1a00004          MOV      r0,r4
002c4c  ebfffffe          BL       yaffs_still_some_chunks
002c50  e3500000          CMP      r0,#0
002c54  1a00000a          BNE      |L1.11396|
                  |L1.11352|
;;;2572   		yaffs_trace(YAFFS_TRACE_TRACING,
002c58  e51f020c          LDR      r0,|L1.10836|
002c5c  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
002c60  e3100c01          TST      r0,#0x100
002c64  0a000002          BEQ      |L1.11380|
002c68  e1a01009          MOV      r1,r9
002c6c  e28f0c02          ADR      r0,|L1.11892|
002c70  ebfffffe          BL       sysprintf
                  |L1.11380|
;;;2573   			"Collecting block %d that has no chunks in use",
;;;2574   			block);
;;;2575   		yaffs_block_became_dirty(dev, block);
002c74  e1a01009          MOV      r1,r9
002c78  e1a00004          MOV      r0,r4
002c7c  ebfffffe          BL       yaffs_block_became_dirty
002c80  ea000035          B        |L1.11612|
                  |L1.11396|
;;;2576   	} else {
;;;2577   
;;;2578   		u8 *buffer = yaffs_get_temp_buffer(dev);
002c84  e1a00004          MOV      r0,r4
002c88  ebfffffe          BL       yaffs_get_temp_buffer
002c8c  e1a06000          MOV      r6,r0
;;;2579   
;;;2580   		yaffs_verify_blk(dev, bi, block);
002c90  e1a02009          MOV      r2,r9
002c94  e1a01005          MOV      r1,r5
002c98  e1a00004          MOV      r0,r4
002c9c  ebfffffe          BL       yaffs_verify_blk
;;;2581   
;;;2582   		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
002ca0  e35a0000          CMP      r10,#0
002ca4  0a000001          BEQ      |L1.11440|
002ca8  e594000c          LDR      r0,[r4,#0xc]
002cac  ea000000          B        |L1.11444|
                  |L1.11440|
002cb0  e3a00005          MOV      r0,#5
                  |L1.11444|
002cb4  e58d0008          STR      r0,[sp,#8]
;;;2583   		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
002cb8  e5940d74          LDR      r0,[r4,#0xd74]
002cbc  e594100c          LDR      r1,[r4,#0xc]
002cc0  e02b0199          MLA      r11,r9,r1,r0
;;;2584   
;;;2585   		for (/* init already done */ ;
002cc4  ea000012          B        |L1.11540|
                  |L1.11464|
;;;2586   		     ret_val == YAFFS_OK &&
;;;2587   		     dev->gc_chunk < dev->param.chunks_per_block &&
;;;2588   		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
;;;2589   		     max_copies > 0;
;;;2590   		     dev->gc_chunk++, old_chunk++) {
;;;2591   			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
002cc8  e1a01009          MOV      r1,r9
002ccc  e5942d74          LDR      r2,[r4,#0xd74]
002cd0  e1a00004          MOV      r0,r4
002cd4  ebfffffe          BL       yaffs_check_chunk_bit
002cd8  e3500000          CMP      r0,#0
002cdc  0a000008          BEQ      |L1.11524|
;;;2592   				/* Page is in use and might need to be copied */
;;;2593   				max_copies--;
002ce0  e59d0008          LDR      r0,[sp,#8]
002ce4  e2400001          SUB      r0,r0,#1
002ce8  e58d0008          STR      r0,[sp,#8]
;;;2594   				ret_val = yaffs_gc_process_chunk(dev, bi,
002cec  e1a03006          MOV      r3,r6
002cf0  e1a0200b          MOV      r2,r11
002cf4  e1a01005          MOV      r1,r5
002cf8  e1a00004          MOV      r0,r4
002cfc  ebfffffe          BL       yaffs_gc_process_chunk
002d00  e58d0010          STR      r0,[sp,#0x10]
                  |L1.11524|
002d04  e5940d74          LDR      r0,[r4,#0xd74]        ;2590
002d08  e2800001          ADD      r0,r0,#1              ;2590
002d0c  e5840d74          STR      r0,[r4,#0xd74]        ;2590
002d10  e28bb001          ADD      r11,r11,#1            ;2590
                  |L1.11540|
002d14  e59d0010          LDR      r0,[sp,#0x10]         ;2586
002d18  e3500001          CMP      r0,#1                 ;2586
002d1c  1a00000a          BNE      |L1.11596|
002d20  e5940d74          LDR      r0,[r4,#0xd74]        ;2587
002d24  e594100c          LDR      r1,[r4,#0xc]          ;2587
002d28  e1500001          CMP      r0,r1                 ;2587
002d2c  2a000006          BCS      |L1.11596|
002d30  e5950000          LDR      r0,[r5,#0]            ;2588
002d34  e200060f          AND      r0,r0,#0xf00000       ;2588
002d38  e3500502          CMP      r0,#0x800000          ;2588
002d3c  1a000002          BNE      |L1.11596|
002d40  e59d0008          LDR      r0,[sp,#8]            ;2589
002d44  e3500000          CMP      r0,#0                 ;2589
002d48  caffffde          BGT      |L1.11464|
                  |L1.11596|
;;;2595   							old_chunk, buffer);
;;;2596   			}
;;;2597   		}
;;;2598   		yaffs_release_temp_buffer(dev, buffer);
002d4c  e1a01006          MOV      r1,r6
002d50  e1a00004          MOV      r0,r4
002d54  ebfffffe          BL       yaffs_release_temp_buffer
;;;2599   	}
002d58  e1a00000          MOV      r0,r0
                  |L1.11612|
;;;2600   
;;;2601   	yaffs_verify_collected_blk(dev, bi, block);
002d5c  e1a02009          MOV      r2,r9
002d60  e1a01005          MOV      r1,r5
002d64  e1a00004          MOV      r0,r4
002d68  ebfffffe          BL       yaffs_verify_collected_blk
;;;2602   
;;;2603   	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
002d6c  e5950000          LDR      r0,[r5,#0]
002d70  e200060f          AND      r0,r0,#0xf00000
002d74  e3500502          CMP      r0,#0x800000
002d78  1a000004          BNE      |L1.11664|
;;;2604   		/*
;;;2605   		 * The gc did not complete. Set block state back to FULL
;;;2606   		 * because checkpointing does not restore gc.
;;;2607   		 */
;;;2608   		bi->block_state = YAFFS_BLOCK_STATE_FULL;
002d7c  e5950000          LDR      r0,[r5,#0]
002d80  e3c0060f          BIC      r0,r0,#0xf00000
002d84  e3800605          ORR      r0,r0,#0x500000
002d88  e5850000          STR      r0,[r5,#0]
002d8c  ea000031          B        |L1.11864|
                  |L1.11664|
;;;2609   	} else {
;;;2610   		/* The gc completed. */
;;;2611   		/* Do any required cleanups */
;;;2612   		for (i = 0; i < dev->n_clean_ups; i++) {
002d90  e3a07000          MOV      r7,#0
002d94  ea00001a          B        |L1.11780|
                  |L1.11672|
;;;2613   			/* Time to delete the file too */
;;;2614   			struct yaffs_obj *object =
002d98  e5940d50          LDR      r0,[r4,#0xd50]
002d9c  e7901107          LDR      r1,[r0,r7,LSL #2]
002da0  e1a00004          MOV      r0,r4
002da4  ebfffffe          BL       yaffs_find_by_number
002da8  e1a06000          MOV      r6,r0
;;;2615   			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
;;;2616   			if (object) {
002dac  e3560000          CMP      r6,#0
002db0  0a000012          BEQ      |L1.11776|
;;;2617   				yaffs_free_tnode(dev,
002db4  e1a00004          MOV      r0,r4
002db8  e5961084          LDR      r1,[r6,#0x84]
002dbc  ebfffffe          BL       yaffs_free_tnode
;;;2618   					  object->variant.file_variant.top);
;;;2619   				object->variant.file_variant.top = NULL;
002dc0  e3a00000          MOV      r0,#0
002dc4  e5860084          STR      r0,[r6,#0x84]
;;;2620   				yaffs_trace(YAFFS_TRACE_GC,
002dc8  e51f037c          LDR      r0,|L1.10836|
002dcc  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
002dd0  e3100040          TST      r0,#0x40
002dd4  0a000002          BEQ      |L1.11748|
002dd8  e28f00cc          ADR      r0,|L1.11948|
002ddc  e5961030          LDR      r1,[r6,#0x30]
002de0  ebfffffe          BL       sysprintf
                  |L1.11748|
;;;2621   					"yaffs: About to finally delete object %d",
;;;2622   					object->obj_id);
;;;2623   				yaffs_generic_obj_del(object);
002de4  e1a00006          MOV      r0,r6
002de8  ebfffffe          BL       yaffs_generic_obj_del
;;;2624   				object->my_dev->n_deleted_files--;
002dec  e5960008          LDR      r0,[r6,#8]
002df0  e5900da4          LDR      r0,[r0,#0xda4]
002df4  e2400001          SUB      r0,r0,#1
002df8  e5961008          LDR      r1,[r6,#8]
002dfc  e5810da4          STR      r0,[r1,#0xda4]
                  |L1.11776|
002e00  e2877001          ADD      r7,r7,#1              ;2612
                  |L1.11780|
002e04  e5940d54          LDR      r0,[r4,#0xd54]        ;2612
002e08  e1500007          CMP      r0,r7                 ;2612
002e0c  8affffe1          BHI      |L1.11672|
;;;2625   			}
;;;2626   
;;;2627   		}
;;;2628   		chunks_after = yaffs_get_erased_chunks(dev);
002e10  e1a00004          MOV      r0,r4
002e14  ebfffffe          BL       yaffs_get_erased_chunks
002e18  e1a08000          MOV      r8,r0
;;;2629   		if (chunks_before >= chunks_after)
002e1c  e59d1004          LDR      r1,[sp,#4]
002e20  e1510008          CMP      r1,r8
002e24  ba000007          BLT      |L1.11848|
;;;2630   			yaffs_trace(YAFFS_TRACE_GC,
002e28  e51f03dc          LDR      r0,|L1.10836|
002e2c  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
002e30  e3100040          TST      r0,#0x40
002e34  0a000003          BEQ      |L1.11848|
002e38  e1a02008          MOV      r2,r8
002e3c  e28f009c          ADR      r0,|L1.12000|
002e40  e59d1004          LDR      r1,[sp,#4]
002e44  ebfffffe          BL       sysprintf
                  |L1.11848|
;;;2631   				"gc did not increase free chunks before %d after %d",
;;;2632   				chunks_before, chunks_after);
;;;2633   		dev->gc_block = 0;
002e48  e3a00000          MOV      r0,#0
002e4c  e5840d70          STR      r0,[r4,#0xd70]
;;;2634   		dev->gc_chunk = 0;
002e50  e5840d74          STR      r0,[r4,#0xd74]
;;;2635   		dev->n_clean_ups = 0;
002e54  e5840d54          STR      r0,[r4,#0xd54]
                  |L1.11864|
;;;2636   	}
;;;2637   
;;;2638   	dev->gc_disable = 0;
002e58  e3a00000          MOV      r0,#0
002e5c  e5840d5c          STR      r0,[r4,#0xd5c]
;;;2639   
;;;2640   	return ret_val;
002e60  e59d0010          LDR      r0,[sp,#0x10]
002e64  e28dd014          ADD      sp,sp,#0x14
;;;2641   }
002e68  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.11884|
                          DCD      0x000009ea
                  |L1.11888|
                          DCD      ||.constdata||+0xd8
                  |L1.11892|
002e74  79616666          DCB      "yaffs: Collecting block %d that has no chunks in use\n",0
002e78  733a2043
002e7c  6f6c6c65
002e80  6374696e
002e84  6720626c
002e88  6f636b20
002e8c  25642074
002e90  68617420
002e94  68617320
002e98  6e6f2063
002e9c  68756e6b
002ea0  7320696e
002ea4  20757365
002ea8  0a00    
002eaa  00                DCB      0
002eab  00                DCB      0
                  |L1.11948|
002eac  79616666          DCB      "yaffs: yaffs: About to finally delete object %d\n",0
002eb0  733a2079
002eb4  61666673
002eb8  3a204162
002ebc  6f757420
002ec0  746f2066
002ec4  696e616c
002ec8  6c792064
002ecc  656c6574
002ed0  65206f62
002ed4  6a656374
002ed8  2025640a
002edc  00      
002edd  00                DCB      0
002ede  00                DCB      0
002edf  00                DCB      0
                  |L1.12000|
002ee0  79616666          DCB      "yaffs: gc did not increase free chunks before %d after "
002ee4  733a2067
002ee8  63206469
002eec  64206e6f
002ef0  7420696e
002ef4  63726561
002ef8  73652066
002efc  72656520
002f00  6368756e
002f04  6b732062
002f08  65666f72
002f0c  65202564
002f10  20616674
002f14  657220  
002f17  25640a00          DCB      "%d\n",0
002f1b  00                DCB      0
                          ENDP

                  yaffs_find_gc_block PROC
;;;2647   
;;;2648   static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
002f1c  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2649   				    int aggressive, int background)
;;;2650   {
002f20  e24dd018          SUB      sp,sp,#0x18
002f24  e1a04000          MOV      r4,r0
002f28  e1a07002          MOV      r7,r2
;;;2651   	int i;
;;;2652   	int iterations;
;;;2653   	unsigned selected = 0;
002f2c  e3a06000          MOV      r6,#0
;;;2654   	int prioritised = 0;
002f30  e3a00000          MOV      r0,#0
002f34  e58d0014          STR      r0,[sp,#0x14]
;;;2655   	int prioritised_exist = 0;
002f38  e58d0010          STR      r0,[sp,#0x10]
;;;2656   	struct yaffs_block_info *bi;
;;;2657   	int threshold;
;;;2658   
;;;2659   	/* First let's see if we need to grab a prioritised block */
;;;2660   	if (dev->has_pending_prioritised_gc && !aggressive) {
002f3c  e5940d58          LDR      r0,[r4,#0xd58]
002f40  e3500000          CMP      r0,#0
002f44  0a00002e          BEQ      |L1.12292|
002f48  e59d001c          LDR      r0,[sp,#0x1c]
002f4c  e3500000          CMP      r0,#0
002f50  1a00002b          BNE      |L1.12292|
;;;2661   		dev->gc_dirtiest = 0;
002f54  e3a00000          MOV      r0,#0
002f58  e5840d64          STR      r0,[r4,#0xd64]
;;;2662   		bi = dev->block_info;
002f5c  e5945118          LDR      r5,[r4,#0x118]
;;;2663   		for (i = dev->internal_start_block;
002f60  e59480d0          LDR      r8,[r4,#0xd0]
002f64  ea000013          B        |L1.12216|
                  |L1.12136|
;;;2664   		     i <= dev->internal_end_block && !selected; i++) {
;;;2665   
;;;2666   			if (bi->gc_prioritise) {
002f68  e5950000          LDR      r0,[r5,#0]
002f6c  e1a00280          LSL      r0,r0,#5
002f70  e1b00fa0          LSRS     r0,r0,#31
002f74  0a00000d          BEQ      |L1.12208|
;;;2667   				prioritised_exist = 1;
002f78  e3a00001          MOV      r0,#1
002f7c  e58d0010          STR      r0,[sp,#0x10]
;;;2668   				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
002f80  e5950000          LDR      r0,[r5,#0]
002f84  e200060f          AND      r0,r0,#0xf00000
002f88  e3500605          CMP      r0,#0x500000
002f8c  1a000007          BNE      |L1.12208|
;;;2669   				    yaffs_block_ok_for_gc(dev, bi)) {
002f90  e1a01005          MOV      r1,r5
002f94  e1a00004          MOV      r0,r4
002f98  ebfffffe          BL       yaffs_block_ok_for_gc
002f9c  e3500000          CMP      r0,#0
002fa0  0a000002          BEQ      |L1.12208|
;;;2670   					selected = i;
002fa4  e1a06008          MOV      r6,r8
;;;2671   					prioritised = 1;
002fa8  e3a00001          MOV      r0,#1
002fac  e58d0014          STR      r0,[sp,#0x14]
                  |L1.12208|
;;;2672   				}
;;;2673   			}
;;;2674   			bi++;
002fb0  e2855008          ADD      r5,r5,#8
002fb4  e2888001          ADD      r8,r8,#1              ;2664
                  |L1.12216|
002fb8  e59400d4          LDR      r0,[r4,#0xd4]         ;2664
002fbc  e1500008          CMP      r0,r8                 ;2664
002fc0  ba000001          BLT      |L1.12236|
002fc4  e3560000          CMP      r6,#0                 ;2664
002fc8  0affffe6          BEQ      |L1.12136|
                  |L1.12236|
;;;2675   		}
;;;2676   
;;;2677   		/*
;;;2678   		 * If there is a prioritised block and none was selected then
;;;2679   		 * this happened because there is at least one old dirty block
;;;2680   		 * gumming up the works. Let's gc the oldest dirty block.
;;;2681   		 */
;;;2682   
;;;2683   		if (prioritised_exist &&
002fcc  e59d0010          LDR      r0,[sp,#0x10]
002fd0  e3500000          CMP      r0,#0
002fd4  0a000005          BEQ      |L1.12272|
;;;2684   		    !selected && dev->oldest_dirty_block > 0)
002fd8  e3560000          CMP      r6,#0
002fdc  1a000003          BNE      |L1.12272|
002fe0  e5940df8          LDR      r0,[r4,#0xdf8]
002fe4  e3500000          CMP      r0,#0
002fe8  0a000000          BEQ      |L1.12272|
;;;2685   			selected = dev->oldest_dirty_block;
002fec  e5946df8          LDR      r6,[r4,#0xdf8]
                  |L1.12272|
;;;2686   
;;;2687   		if (!prioritised_exist)	/* None found, so we can clear this */
002ff0  e59d0010          LDR      r0,[sp,#0x10]
002ff4  e3500000          CMP      r0,#0
002ff8  1a000001          BNE      |L1.12292|
;;;2688   			dev->has_pending_prioritised_gc = 0;
002ffc  e3a00000          MOV      r0,#0
003000  e5840d58          STR      r0,[r4,#0xd58]
                  |L1.12292|
;;;2689   	}
;;;2690   
;;;2691   	/* If we're doing aggressive GC then we are happy to take a less-dirty
;;;2692   	 * block, and search harder.
;;;2693   	 * else (leasurely gc), then we only bother to do this if the
;;;2694   	 * block has only a few pages in use.
;;;2695   	 */
;;;2696   
;;;2697   	if (!selected) {
003004  e3560000          CMP      r6,#0
003008  1a00006d          BNE      |L1.12740|
;;;2698   		int pages_used;
;;;2699   		int n_blocks =
00300c  e59400d4          LDR      r0,[r4,#0xd4]
003010  e59410d0          LDR      r1,[r4,#0xd0]
003014  e0400001          SUB      r0,r0,r1
003018  e2800001          ADD      r0,r0,#1
00301c  e58d000c          STR      r0,[sp,#0xc]
;;;2700   		    dev->internal_end_block - dev->internal_start_block + 1;
;;;2701   		if (aggressive) {
003020  e59d001c          LDR      r0,[sp,#0x1c]
003024  e3500000          CMP      r0,#0
003028  0a000002          BEQ      |L1.12344|
;;;2702   			threshold = dev->param.chunks_per_block;
00302c  e594900c          LDR      r9,[r4,#0xc]
;;;2703   			iterations = n_blocks;
003030  e59da00c          LDR      r10,[sp,#0xc]
003034  ea000023          B        |L1.12488|
                  |L1.12344|
;;;2704   		} else {
;;;2705   			int max_threshold;
;;;2706   
;;;2707   			if (background)
003038  e3570000          CMP      r7,#0
00303c  0a000003          BEQ      |L1.12368|
;;;2708   				max_threshold = dev->param.chunks_per_block / 2;
003040  e594100c          LDR      r1,[r4,#0xc]
003044  e0812fa1          ADD      r2,r1,r1,LSR #31
003048  e1a000c2          ASR      r0,r2,#1
00304c  ea000003          B        |L1.12384|
                  |L1.12368|
;;;2709   			else
;;;2710   				max_threshold = dev->param.chunks_per_block / 8;
003050  e594100c          LDR      r1,[r4,#0xc]
003054  e1a02fc1          ASR      r2,r1,#31
003058  e0812ea2          ADD      r2,r1,r2,LSR #29
00305c  e1a001c2          ASR      r0,r2,#3
                  |L1.12384|
;;;2711   
;;;2712   			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
003060  e3500004          CMP      r0,#4
003064  aa000000          BGE      |L1.12396|
;;;2713   				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
003068  e3a00004          MOV      r0,#4
                  |L1.12396|
;;;2714   
;;;2715   			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
00306c  e3570000          CMP      r7,#0
003070  0a000003          BEQ      |L1.12420|
003074  e5941d6c          LDR      r1,[r4,#0xd6c]
003078  e2811002          ADD      r1,r1,#2
00307c  e1a01081          LSL      r1,r1,#1
003080  ea000000          B        |L1.12424|
                  |L1.12420|
003084  e3a01000          MOV      r1,#0
                  |L1.12424|
003088  e1a09001          MOV      r9,r1
;;;2716   			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
00308c  e3590004          CMP      r9,#4
003090  aa000000          BGE      |L1.12440|
;;;2717   				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
003094  e3a09004          MOV      r9,#4
                  |L1.12440|
;;;2718   			if (threshold > max_threshold)
003098  e1590000          CMP      r9,r0
00309c  da000000          BLE      |L1.12452|
;;;2719   				threshold = max_threshold;
0030a0  e1a09000          MOV      r9,r0
                  |L1.12452|
;;;2720   
;;;2721   			iterations = n_blocks / 16 + 1;
0030a4  e59d100c          LDR      r1,[sp,#0xc]
0030a8  e1a02fc1          ASR      r2,r1,#31
0030ac  e0812e22          ADD      r2,r1,r2,LSR #28
0030b0  e1a02242          ASR      r2,r2,#4
0030b4  e282a001          ADD      r10,r2,#1
;;;2722   			if (iterations > 100)
0030b8  e35a0064          CMP      r10,#0x64
0030bc  da000000          BLE      |L1.12484|
;;;2723   				iterations = 100;
0030c0  e3a0a064          MOV      r10,#0x64
                  |L1.12484|
;;;2724   		}
0030c4  e1a00000          MOV      r0,r0
                  |L1.12488|
;;;2725   
;;;2726   		for (i = 0;
0030c8  e3a08000          MOV      r8,#0
0030cc  ea00002c          B        |L1.12676|
                  |L1.12496|
;;;2727   		     i < iterations &&
;;;2728   		     (dev->gc_dirtiest < 1 ||
;;;2729   		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
;;;2730   		     i++) {
;;;2731   			dev->gc_block_finder++;
0030d0  e5940d60          LDR      r0,[r4,#0xd60]
0030d4  e2800001          ADD      r0,r0,#1
0030d8  e5840d60          STR      r0,[r4,#0xd60]
;;;2732   			if (dev->gc_block_finder < dev->internal_start_block ||
0030dc  e5940d60          LDR      r0,[r4,#0xd60]
0030e0  e59410d0          LDR      r1,[r4,#0xd0]
0030e4  e1500001          CMP      r0,r1
0030e8  3a000003          BCC      |L1.12540|
;;;2733   			    dev->gc_block_finder > dev->internal_end_block)
0030ec  e5940d60          LDR      r0,[r4,#0xd60]
0030f0  e59410d4          LDR      r1,[r4,#0xd4]
0030f4  e1500001          CMP      r0,r1
0030f8  9a000001          BLS      |L1.12548|
                  |L1.12540|
;;;2734   				dev->gc_block_finder =
0030fc  e59400d0          LDR      r0,[r4,#0xd0]
003100  e5840d60          STR      r0,[r4,#0xd60]
                  |L1.12548|
;;;2735   				    dev->internal_start_block;
;;;2736   
;;;2737   			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
003104  e5941d60          LDR      r1,[r4,#0xd60]
003108  e1a00004          MOV      r0,r4
00310c  ebfffffe          BL       yaffs_get_block_info
003110  e1a05000          MOV      r5,r0
;;;2738   
;;;2739   			pages_used = bi->pages_in_use - bi->soft_del_pages;
003114  e1d500b0          LDRH     r0,[r5,#0]
003118  e1a00b00          LSL      r0,r0,#22
00311c  e1a00b20          LSR      r0,r0,#22
003120  e5951000          LDR      r1,[r5,#0]
003124  e1a01601          LSL      r1,r1,#12
003128  e060bb21          RSB      r11,r0,r1,LSR #22
;;;2740   
;;;2741   			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
00312c  e5950000          LDR      r0,[r5,#0]
003130  e200060f          AND      r0,r0,#0xf00000
003134  e3500605          CMP      r0,#0x500000
003138  1a000010          BNE      |L1.12672|
;;;2742   			    pages_used < dev->param.chunks_per_block &&
00313c  e594000c          LDR      r0,[r4,#0xc]
003140  e150000b          CMP      r0,r11
003144  da00000d          BLE      |L1.12672|
;;;2743   			    (dev->gc_dirtiest < 1 ||
003148  e5940d64          LDR      r0,[r4,#0xd64]
00314c  e3500000          CMP      r0,#0
003150  0a000002          BEQ      |L1.12640|
;;;2744   			     pages_used < dev->gc_pages_in_use) &&
003154  e5940d68          LDR      r0,[r4,#0xd68]
003158  e150000b          CMP      r0,r11
00315c  9a000007          BLS      |L1.12672|
                  |L1.12640|
;;;2745   			    yaffs_block_ok_for_gc(dev, bi)) {
003160  e1a01005          MOV      r1,r5
003164  e1a00004          MOV      r0,r4
003168  ebfffffe          BL       yaffs_block_ok_for_gc
00316c  e3500000          CMP      r0,#0
003170  0a000002          BEQ      |L1.12672|
;;;2746   				dev->gc_dirtiest = dev->gc_block_finder;
003174  e5940d60          LDR      r0,[r4,#0xd60]
003178  e5840d64          STR      r0,[r4,#0xd64]
;;;2747   				dev->gc_pages_in_use = pages_used;
00317c  e584bd68          STR      r11,[r4,#0xd68]
                  |L1.12672|
003180  e2888001          ADD      r8,r8,#1              ;2730
                  |L1.12676|
003184  e158000a          CMP      r8,r10                ;2727
003188  aa000005          BGE      |L1.12708|
00318c  e5940d64          LDR      r0,[r4,#0xd64]        ;2728
003190  e3500000          CMP      r0,#0                 ;2728
003194  0affffcd          BEQ      |L1.12496|
003198  e5940d68          LDR      r0,[r4,#0xd68]        ;2729
00319c  e3500002          CMP      r0,#2                 ;2729
0031a0  8affffca          BHI      |L1.12496|
                  |L1.12708|
;;;2748   			}
;;;2749   		}
;;;2750   
;;;2751   		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
0031a4  e5940d64          LDR      r0,[r4,#0xd64]
0031a8  e3500000          CMP      r0,#0
0031ac  0a000003          BEQ      |L1.12736|
0031b0  e5940d68          LDR      r0,[r4,#0xd68]
0031b4  e1500009          CMP      r0,r9
0031b8  8a000000          BHI      |L1.12736|
;;;2752   			selected = dev->gc_dirtiest;
0031bc  e5946d64          LDR      r6,[r4,#0xd64]
                  |L1.12736|
;;;2753   	}
0031c0  e1a00000          MOV      r0,r0
                  |L1.12740|
;;;2754   
;;;2755   	/*
;;;2756   	 * If nothing has been selected for a while, try the oldest dirty
;;;2757   	 * because that's gumming up the works.
;;;2758   	 */
;;;2759   
;;;2760   	if (!selected && dev->param.is_yaffs2 &&
0031c4  e3560000          CMP      r6,#0
0031c8  1a000022          BNE      |L1.12888|
0031cc  e5940030          LDR      r0,[r4,#0x30]
0031d0  e3500000          CMP      r0,#0
0031d4  0a00001f          BEQ      |L1.12888|
;;;2761   	    dev->gc_not_done >= (background ? 10 : 20)) {
0031d8  e3570000          CMP      r7,#0
0031dc  e5940d6c          LDR      r0,[r4,#0xd6c]
0031e0  0a000001          BEQ      |L1.12780|
0031e4  e3a0100a          MOV      r1,#0xa
0031e8  ea000000          B        |L1.12784|
                  |L1.12780|
0031ec  e3a01014          MOV      r1,#0x14
                  |L1.12784|
0031f0  e1500001          CMP      r0,r1
0031f4  3a000017          BCC      |L1.12888|
;;;2762   		yaffs2_find_oldest_dirty_seq(dev);
0031f8  e1a00004          MOV      r0,r4
0031fc  ebfffffe          BL       yaffs2_find_oldest_dirty_seq
;;;2763   		if (dev->oldest_dirty_block > 0) {
003200  e5940df8          LDR      r0,[r4,#0xdf8]
003204  e3500000          CMP      r0,#0
003208  0a000010          BEQ      |L1.12880|
;;;2764   			selected = dev->oldest_dirty_block;
00320c  e5946df8          LDR      r6,[r4,#0xdf8]
;;;2765   			dev->gc_dirtiest = selected;
003210  e5846d64          STR      r6,[r4,#0xd64]
;;;2766   			dev->oldest_dirty_gc_count++;
003214  e5940e2c          LDR      r0,[r4,#0xe2c]
003218  e2800001          ADD      r0,r0,#1
00321c  e5840e2c          STR      r0,[r4,#0xe2c]
;;;2767   			bi = yaffs_get_block_info(dev, selected);
003220  e1a01006          MOV      r1,r6
003224  e1a00004          MOV      r0,r4
003228  ebfffffe          BL       yaffs_get_block_info
00322c  e1a05000          MOV      r5,r0
;;;2768   			dev->gc_pages_in_use =
003230  e1d500b0          LDRH     r0,[r5,#0]
003234  e1a00b00          LSL      r0,r0,#22
003238  e1a00b20          LSR      r0,r0,#22
00323c  e5951000          LDR      r1,[r5,#0]
003240  e1a01601          LSL      r1,r1,#12
003244  e0600b21          RSB      r0,r0,r1,LSR #22
003248  e5840d68          STR      r0,[r4,#0xd68]
00324c  ea000001          B        |L1.12888|
                  |L1.12880|
;;;2769   			    bi->pages_in_use - bi->soft_del_pages;
;;;2770   		} else {
;;;2771   			dev->gc_not_done = 0;
003250  e3a00000          MOV      r0,#0
003254  e5840d6c          STR      r0,[r4,#0xd6c]
                  |L1.12888|
;;;2772   		}
;;;2773   	}
;;;2774   
;;;2775   	if (selected) {
003258  e3560000          CMP      r6,#0
00325c  0a00001d          BEQ      |L1.13016|
;;;2776   		yaffs_trace(YAFFS_TRACE_GC,
003260  e51f0814          LDR      r0,|L1.10836|
003264  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
003268  e3100040          TST      r0,#0x40
00326c  0a000006          BEQ      |L1.12940|
003270  e594000c          LDR      r0,[r4,#0xc]
003274  e5941d68          LDR      r1,[r4,#0xd68]
003278  e0402001          SUB      r2,r0,r1
00327c  e1a01006          MOV      r1,r6
003280  e28f0fbf          ADR      r0,|L1.13700|
003284  e59d3014          LDR      r3,[sp,#0x14]
003288  ebfffffe          BL       sysprintf
                  |L1.12940|
;;;2777   			"GC Selected block %d with %d free, prioritised:%d",
;;;2778   			selected,
;;;2779   			dev->param.chunks_per_block - dev->gc_pages_in_use,
;;;2780   			prioritised);
;;;2781   
;;;2782   		dev->n_gc_blocks++;
00328c  e5940e30          LDR      r0,[r4,#0xe30]
003290  e2800001          ADD      r0,r0,#1
003294  e5840e30          STR      r0,[r4,#0xe30]
;;;2783   		if (background)
003298  e3570000          CMP      r7,#0
00329c  0a000002          BEQ      |L1.12972|
;;;2784   			dev->bg_gcs++;
0032a0  e5940e34          LDR      r0,[r4,#0xe34]
0032a4  e2800001          ADD      r0,r0,#1
0032a8  e5840e34          STR      r0,[r4,#0xe34]
                  |L1.12972|
;;;2785   
;;;2786   		dev->gc_dirtiest = 0;
0032ac  e3a00000          MOV      r0,#0
0032b0  e5840d64          STR      r0,[r4,#0xd64]
;;;2787   		dev->gc_pages_in_use = 0;
0032b4  e5840d68          STR      r0,[r4,#0xd68]
;;;2788   		dev->gc_not_done = 0;
0032b8  e5840d6c          STR      r0,[r4,#0xd6c]
;;;2789   		if (dev->refresh_skip > 0)
0032bc  e5940dfc          LDR      r0,[r4,#0xdfc]
0032c0  e3500000          CMP      r0,#0
0032c4  da00001a          BLE      |L1.13108|
;;;2790   			dev->refresh_skip--;
0032c8  e5940dfc          LDR      r0,[r4,#0xdfc]
0032cc  e2400001          SUB      r0,r0,#1
0032d0  e5840dfc          STR      r0,[r4,#0xdfc]
0032d4  ea000016          B        |L1.13108|
                  |L1.13016|
;;;2791   	} else {
;;;2792   		dev->gc_not_done++;
0032d8  e5940d6c          LDR      r0,[r4,#0xd6c]
0032dc  e2800001          ADD      r0,r0,#1
0032e0  e5840d6c          STR      r0,[r4,#0xd6c]
;;;2793   		yaffs_trace(YAFFS_TRACE_GC,
0032e4  e51f0898          LDR      r0,|L1.10836|
0032e8  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
0032ec  e3100040          TST      r0,#0x40
0032f0  0a00000f          BEQ      |L1.13108|
0032f4  e3570000          CMP      r7,#0
0032f8  0a000001          BEQ      |L1.13060|
0032fc  e28f3faf          ADR      r3,|L1.13760|
003300  ea000000          B        |L1.13064|
                  |L1.13060|
003304  e28f3fae          ADR      r3,|L1.13764|
                  |L1.13064|
003308  e5940df8          LDR      r0,[r4,#0xdf8]
00330c  e5941d64          LDR      r1,[r4,#0xd64]
003310  e5942d68          LDR      r2,[r4,#0xd68]
003314  e58d0008          STR      r0,[sp,#8]
003318  e58d300c          STR      r3,[sp,#0xc]
00331c  e88d0006          STM      sp,{r1,r2}
003320  e1a03009          MOV      r3,r9
003324  e59f029c          LDR      r0,|L1.13768|
003328  e5941d60          LDR      r1,[r4,#0xd60]
00332c  e5942d6c          LDR      r2,[r4,#0xd6c]
003330  ebfffffe          BL       sysprintf
                  |L1.13108|
;;;2794   			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
;;;2795   			dev->gc_block_finder, dev->gc_not_done, threshold,
;;;2796   			dev->gc_dirtiest, dev->gc_pages_in_use,
;;;2797   			dev->oldest_dirty_block, background ? " bg" : "");
;;;2798   	}
;;;2799   
;;;2800   	return selected;
003334  e1a00006          MOV      r0,r6
003338  e28dd024          ADD      sp,sp,#0x24
;;;2801   }
00333c  e8bd8ff0          POP      {r4-r11,pc}
;;;2802   
                          ENDP

                  yaffs_check_gc PROC
;;;2811    */
;;;2812   static int yaffs_check_gc(struct yaffs_dev *dev, int background)
003340  e92d5ff0          PUSH     {r4-r12,lr}
;;;2813   {
003344  e1a04000          MOV      r4,r0
003348  e1a06001          MOV      r6,r1
;;;2814   	int aggressive = 0;
00334c  e3a05000          MOV      r5,#0
;;;2815   	int gc_ok = YAFFS_OK;
003350  e3a0b001          MOV      r11,#1
;;;2816   	int max_tries = 0;
003354  e3a07000          MOV      r7,#0
;;;2817   	int min_erased;
;;;2818   	int erased_chunks;
;;;2819   	int checkpt_block_adjust;
;;;2820   
;;;2821   	if (dev->param.gc_control && (dev->param.gc_control(dev) & 1) == 0)
003358  e5940070          LDR      r0,[r4,#0x70]
00335c  e3500000          CMP      r0,#0
003360  0a000006          BEQ      |L1.13184|
003364  e5941070          LDR      r1,[r4,#0x70]
003368  e1a00004          MOV      r0,r4
00336c  e12fff31          BLX      r1
003370  e3100001          TST      r0,#1
003374  1a000001          BNE      |L1.13184|
;;;2822   		return YAFFS_OK;
003378  e3a00001          MOV      r0,#1
                  |L1.13180|
;;;2823   
;;;2824   	if (dev->gc_disable)
;;;2825   		/* Bail out so we don't get recursive gc */
;;;2826   		return YAFFS_OK;
;;;2827   
;;;2828   	/* This loop should pass the first time.
;;;2829   	 * Only loops here if the collection does not increase space.
;;;2830   	 */
;;;2831   
;;;2832   	do {
;;;2833   		max_tries++;
;;;2834   
;;;2835   		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
;;;2836   
;;;2837   		min_erased =
;;;2838   		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
;;;2839   		erased_chunks =
;;;2840   		    dev->n_erased_blocks * dev->param.chunks_per_block;
;;;2841   
;;;2842   		/* If we need a block soon then do aggressive gc. */
;;;2843   		if (dev->n_erased_blocks < min_erased)
;;;2844   			aggressive = 1;
;;;2845   		else {
;;;2846   			if (!background
;;;2847   			    && erased_chunks > (dev->n_free_chunks / 4))
;;;2848   				break;
;;;2849   
;;;2850   			if (dev->gc_skip > 20)
;;;2851   				dev->gc_skip = 20;
;;;2852   			if (erased_chunks < dev->n_free_chunks / 2 ||
;;;2853   			    dev->gc_skip < 1 || background)
;;;2854   				aggressive = 0;
;;;2855   			else {
;;;2856   				dev->gc_skip--;
;;;2857   				break;
;;;2858   			}
;;;2859   		}
;;;2860   
;;;2861   		dev->gc_skip = 5;
;;;2862   
;;;2863   		/* If we don't already have a block being gc'd then see if we
;;;2864   		 * should start another */
;;;2865   
;;;2866   		if (dev->gc_block < 1 && !aggressive) {
;;;2867   			dev->gc_block = yaffs2_find_refresh_block(dev);
;;;2868   			dev->gc_chunk = 0;
;;;2869   			dev->n_clean_ups = 0;
;;;2870   		}
;;;2871   		if (dev->gc_block < 1) {
;;;2872   			dev->gc_block =
;;;2873   			    yaffs_find_gc_block(dev, aggressive, background);
;;;2874   			dev->gc_chunk = 0;
;;;2875   			dev->n_clean_ups = 0;
;;;2876   		}
;;;2877   
;;;2878   		if (dev->gc_block > 0) {
;;;2879   			dev->all_gcs++;
;;;2880   			if (!aggressive)
;;;2881   				dev->passive_gc_count++;
;;;2882   
;;;2883   			yaffs_trace(YAFFS_TRACE_GC,
;;;2884   				"yaffs: GC n_erased_blocks %d aggressive %d",
;;;2885   				dev->n_erased_blocks, aggressive);
;;;2886   
;;;2887   			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
;;;2888   		}
;;;2889   
;;;2890   		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
;;;2891   		    dev->gc_block > 0) {
;;;2892   			yaffs_trace(YAFFS_TRACE_GC,
;;;2893   				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
;;;2894   				dev->n_erased_blocks, max_tries,
;;;2895   				dev->gc_block);
;;;2896   		}
;;;2897   	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
;;;2898   		 (dev->gc_block > 0) && (max_tries < 2));
;;;2899   
;;;2900   	return aggressive ? gc_ok : YAFFS_OK;
;;;2901   }
00337c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.13184|
003380  e5940d5c          LDR      r0,[r4,#0xd5c]        ;2824
003384  e3500000          CMP      r0,#0                 ;2824
003388  0a000001          BEQ      |L1.13204|
00338c  e3a00001          MOV      r0,#1                 ;2826
003390  eafffff9          B        |L1.13180|
                  |L1.13204|
003394  e1a00000          MOV      r0,r0                 ;2832
                  |L1.13208|
003398  e2877001          ADD      r7,r7,#1              ;2833
00339c  e1a00004          MOV      r0,r4                 ;2835
0033a0  ebfffffe          BL       yaffs_calc_checkpt_blocks_required
0033a4  e1a09000          MOV      r9,r0                 ;2835
0033a8  e594101c          LDR      r1,[r4,#0x1c]         ;2837
0033ac  e0810009          ADD      r0,r1,r9              ;2837
0033b0  e280a001          ADD      r10,r0,#1             ;2837
0033b4  e5940128          LDR      r0,[r4,#0x128]        ;2839
0033b8  e594100c          LDR      r1,[r4,#0xc]          ;2839
0033bc  e0080190          MUL      r8,r0,r1              ;2839
0033c0  e5940128          LDR      r0,[r4,#0x128]        ;2843
0033c4  e150000a          CMP      r0,r10                ;2843
0033c8  aa000001          BGE      |L1.13268|
0033cc  e3a05001          MOV      r5,#1                 ;2844
0033d0  ea00001d          B        |L1.13388|
                  |L1.13268|
0033d4  e3560000          CMP      r6,#0                 ;2846
0033d8  1a000006          BNE      |L1.13304|
0033dc  e5940d4c          LDR      r0,[r4,#0xd4c]        ;2847
0033e0  e1a01fc0          ASR      r1,r0,#31             ;2847
0033e4  e0801f21          ADD      r1,r0,r1,LSR #30      ;2847
0033e8  e1a01141          ASR      r1,r1,#2              ;2847
0033ec  e1510008          CMP      r1,r8                 ;2847
0033f0  aa000000          BGE      |L1.13304|
0033f4  ea00005d          B        |L1.13680|
                  |L1.13304|
0033f8  e5940d78          LDR      r0,[r4,#0xd78]        ;2850
0033fc  e3500014          CMP      r0,#0x14              ;2850
003400  9a000001          BLS      |L1.13324|
003404  e3a00014          MOV      r0,#0x14              ;2851
003408  e5840d78          STR      r0,[r4,#0xd78]        ;2851
                  |L1.13324|
00340c  e5940d4c          LDR      r0,[r4,#0xd4c]        ;2852
003410  e0801fa0          ADD      r1,r0,r0,LSR #31      ;2852
003414  e1a010c1          ASR      r1,r1,#1              ;2852
003418  e1510008          CMP      r1,r8                 ;2852
00341c  ca000004          BGT      |L1.13364|
003420  e5941d78          LDR      r1,[r4,#0xd78]        ;2853
003424  e3510000          CMP      r1,#0                 ;2853
003428  0a000001          BEQ      |L1.13364|
00342c  e3560000          CMP      r6,#0                 ;2853
003430  0a000001          BEQ      |L1.13372|
                  |L1.13364|
003434  e3a05000          MOV      r5,#0                 ;2854
003438  ea000003          B        |L1.13388|
                  |L1.13372|
00343c  e5940d78          LDR      r0,[r4,#0xd78]        ;2856
003440  e2400001          SUB      r0,r0,#1              ;2856
003444  e5840d78          STR      r0,[r4,#0xd78]        ;2856
003448  ea000048          B        |L1.13680|
                  |L1.13388|
00344c  e3a00005          MOV      r0,#5                 ;2861
003450  e5840d78          STR      r0,[r4,#0xd78]        ;2861
003454  e5940d70          LDR      r0,[r4,#0xd70]        ;2866
003458  e3500000          CMP      r0,#0                 ;2866
00345c  1a000007          BNE      |L1.13440|
003460  e3550000          CMP      r5,#0                 ;2866
003464  1a000005          BNE      |L1.13440|
003468  e1a00004          MOV      r0,r4                 ;2867
00346c  ebfffffe          BL       yaffs2_find_refresh_block
003470  e5840d70          STR      r0,[r4,#0xd70]        ;2867
003474  e3a00000          MOV      r0,#0                 ;2868
003478  e5840d74          STR      r0,[r4,#0xd74]        ;2868
00347c  e5840d54          STR      r0,[r4,#0xd54]        ;2869
                  |L1.13440|
003480  e5940d70          LDR      r0,[r4,#0xd70]        ;2871
003484  e3500000          CMP      r0,#0                 ;2871
003488  1a000007          BNE      |L1.13484|
00348c  e1a02006          MOV      r2,r6                 ;2872
003490  e1a01005          MOV      r1,r5                 ;2872
003494  e1a00004          MOV      r0,r4                 ;2872
003498  ebfffffe          BL       yaffs_find_gc_block
00349c  e5840d70          STR      r0,[r4,#0xd70]        ;2872
0034a0  e3a00000          MOV      r0,#0                 ;2874
0034a4  e5840d74          STR      r0,[r4,#0xd74]        ;2874
0034a8  e5840d54          STR      r0,[r4,#0xd54]        ;2875
                  |L1.13484|
0034ac  e5940d70          LDR      r0,[r4,#0xd70]        ;2878
0034b0  e3500000          CMP      r0,#0                 ;2878
0034b4  0a000014          BEQ      |L1.13580|
0034b8  e5940e24          LDR      r0,[r4,#0xe24]        ;2879
0034bc  e2800001          ADD      r0,r0,#1              ;2879
0034c0  e5840e24          STR      r0,[r4,#0xe24]        ;2879
0034c4  e3550000          CMP      r5,#0                 ;2880
0034c8  1a000002          BNE      |L1.13528|
0034cc  e5940e28          LDR      r0,[r4,#0xe28]        ;2881
0034d0  e2800001          ADD      r0,r0,#1              ;2881
0034d4  e5840e28          STR      r0,[r4,#0xe28]        ;2881
                  |L1.13528|
0034d8  e51f0a8c          LDR      r0,|L1.10836|
0034dc  e5d00000          LDRB     r0,[r0,#0]            ;2883  ; yaffs_trace_mask
0034e0  e3100040          TST      r0,#0x40              ;2883
0034e4  0a000003          BEQ      |L1.13560|
0034e8  e1a02005          MOV      r2,r5                 ;2883
0034ec  e28f00d8          ADR      r0,|L1.13772|
0034f0  e5941128          LDR      r1,[r4,#0x128]        ;2883
0034f4  ebfffffe          BL       sysprintf
                  |L1.13560|
0034f8  e1a02005          MOV      r2,r5                 ;2887
0034fc  e5941d70          LDR      r1,[r4,#0xd70]        ;2887
003500  e1a00004          MOV      r0,r4                 ;2887
003504  ebfffffe          BL       yaffs_gc_block
003508  e1a0b000          MOV      r11,r0                ;2887
                  |L1.13580|
00350c  e5940128          LDR      r0,[r4,#0x128]        ;2890
003510  e594101c          LDR      r1,[r4,#0x1c]         ;2890
003514  e1500001          CMP      r0,r1                 ;2890
003518  aa00000b          BGE      |L1.13644|
00351c  e5940d70          LDR      r0,[r4,#0xd70]        ;2891
003520  e3500000          CMP      r0,#0                 ;2891
003524  0a000008          BEQ      |L1.13644|
003528  e51f0adc          LDR      r0,|L1.10836|
00352c  e5d00000          LDRB     r0,[r0,#0]            ;2892  ; yaffs_trace_mask
003530  e3100040          TST      r0,#0x40              ;2892
003534  0a000004          BEQ      |L1.13644|
003538  e1a02007          MOV      r2,r7                 ;2892
00353c  e59f00bc          LDR      r0,|L1.13824|
003540  e5941128          LDR      r1,[r4,#0x128]        ;2892
003544  e5943d70          LDR      r3,[r4,#0xd70]        ;2892
003548  ebfffffe          BL       sysprintf
                  |L1.13644|
00354c  e5940128          LDR      r0,[r4,#0x128]        ;2897
003550  e594101c          LDR      r1,[r4,#0x1c]         ;2897
003554  e1500001          CMP      r0,r1                 ;2897
003558  aa000004          BGE      |L1.13680|
00355c  e5940d70          LDR      r0,[r4,#0xd70]        ;2898
003560  e3500000          CMP      r0,#0                 ;2898
003564  0a000001          BEQ      |L1.13680|
003568  e3570002          CMP      r7,#2                 ;2898
00356c  baffff89          BLT      |L1.13208|
                  |L1.13680|
003570  e1a00000          MOV      r0,r0                 ;2848
003574  e3550000          CMP      r5,#0                 ;2900
003578  0a000021          BEQ      |L1.13828|
00357c  e1a0000b          MOV      r0,r11                ;2900
003580  eaffff7d          B        |L1.13180|
                  |L1.13700|
003584  79616666          DCB      "yaffs: GC Selected block %d with %d free, prioritised:%"
003588  733a2047
00358c  43205365
003590  6c656374
003594  65642062
003598  6c6f636b
00359c  20256420
0035a0  77697468
0035a4  20256420
0035a8  66726565
0035ac  2c207072
0035b0  696f7269
0035b4  74697365
0035b8  643a25  
0035bb  640a00            DCB      "d\n",0
0035be  00                DCB      0
0035bf  00                DCB      0
                  |L1.13760|
0035c0  20626700          DCB      " bg",0
                  |L1.13764|
0035c4  00                DCB      0
0035c5  00                DCB      0
0035c6  00                DCB      0
0035c7  00                DCB      0
                  |L1.13768|
                          DCD      ||.constdata||+0x11c
                  |L1.13772|
0035cc  79616666          DCB      "yaffs: yaffs: GC n_erased_blocks %d aggressive %d\n",0
0035d0  733a2079
0035d4  61666673
0035d8  3a204743
0035dc  206e5f65
0035e0  72617365
0035e4  645f626c
0035e8  6f636b73
0035ec  20256420
0035f0  61676772
0035f4  65737369
0035f8  76652025
0035fc  640a00  
0035ff  00                DCB      0
                  |L1.13824|
                          DCD      ||.constdata||+0x170
                  |L1.13828|
003604  e3a00001          MOV      r0,#1                 ;2900
003608  eaffff5b          B        |L1.13180|
;;;2902   
                          ENDP

                  yaffs_update_oh PROC
;;;3274    */
;;;3275   int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
00360c  e92d4fff          PUSH     {r0-r11,lr}
;;;3276   		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
;;;3277   {
003610  e24ddf69          SUB      sp,sp,#0x1a4
003614  e1a04000          MOV      r4,r0
003618  e1a0a001          MOV      r10,r1
;;;3278   
;;;3279   	struct yaffs_block_info *bi;
;;;3280   	struct yaffs_dev *dev = in->my_dev;
00361c  e5940008          LDR      r0,[r4,#8]
003620  e58d01a0          STR      r0,[sp,#0x1a0]
;;;3281   	int prev_chunk_id;
;;;3282   	int ret_val = 0;
003624  e3a00000          MOV      r0,#0
003628  e58d019c          STR      r0,[sp,#0x19c]
;;;3283   	int new_chunk_id;
;;;3284   	struct yaffs_ext_tags new_tags;
;;;3285   	struct yaffs_ext_tags old_tags;
;;;3286   	const YCHAR *alias = NULL;
00362c  e58d0104          STR      r0,[sp,#0x104]
;;;3287   	u8 *buffer = NULL;
003630  e3a09000          MOV      r9,#0
;;;3288   	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
;;;3289   	struct yaffs_obj_hdr *oh = NULL;
003634  e3a05000          MOV      r5,#0
003638  e3a01000          MOV      r1,#0
;;;3290   	loff_t file_size = 0;
00363c  e1a07001          MOV      r7,r1
003640  e1a08001          MOV      r8,r1
;;;3291   
;;;3292   	yaffs_strcpy(old_name, _Y("silly old name"));
003644  e28f1fb6          ADR      r1,|L1.14628|
003648  e28d0004          ADD      r0,sp,#4
00364c  ebfffffe          BL       strcpy
;;;3293   
;;;3294   	if (in->fake && in != dev->root_dir && !force && !xmod)
003650  e5d40000          LDRB     r0,[r4,#0]
003654  e1a00e00          LSL      r0,r0,#28
003658  e1b00fa0          LSRS     r0,r0,#31
00365c  0a00000c          BEQ      |L1.13972|
003660  e59d01a0          LDR      r0,[sp,#0x1a0]
003664  e5900d80          LDR      r0,[r0,#0xd80]
003668  e1500004          CMP      r0,r4
00366c  0a000008          BEQ      |L1.13972|
003670  e59d01ac          LDR      r0,[sp,#0x1ac]
003674  e3500000          CMP      r0,#0
003678  1a000005          BNE      |L1.13972|
00367c  e59d01dc          LDR      r0,[sp,#0x1dc]
003680  e3500000          CMP      r0,#0
003684  1a000002          BNE      |L1.13972|
;;;3295   		return ret_val;
003688  e59d019c          LDR      r0,[sp,#0x19c]
                  |L1.13964|
00368c  e28ddf6d          ADD      sp,sp,#0x1b4
;;;3296   
;;;3297   	yaffs_check_gc(dev, 0);
;;;3298   	yaffs_check_obj_details_loaded(in);
;;;3299   
;;;3300   	buffer = yaffs_get_temp_buffer(in->my_dev);
;;;3301   	oh = (struct yaffs_obj_hdr *)buffer;
;;;3302   
;;;3303   	prev_chunk_id = in->hdr_chunk;
;;;3304   
;;;3305   	if (prev_chunk_id > 0) {
;;;3306   		yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
;;;3307   					  buffer, &old_tags);
;;;3308   
;;;3309   		yaffs_verify_oh(in, oh, &old_tags, 0);
;;;3310   		memcpy(old_name, oh->name, sizeof(oh->name));
;;;3311   		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
;;;3312   	} else {
;;;3313   		memset(buffer, 0xff, dev->data_bytes_per_chunk);
;;;3314   	}
;;;3315   
;;;3316   	oh->type = in->variant_type;
;;;3317   	oh->yst_mode = in->yst_mode;
;;;3318   	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
;;;3319   
;;;3320   	yaffs_load_attribs_oh(oh, in);
;;;3321   
;;;3322   	if (in->parent)
;;;3323   		oh->parent_obj_id = in->parent->obj_id;
;;;3324   	else
;;;3325   		oh->parent_obj_id = 0;
;;;3326   
;;;3327   	if (name && *name) {
;;;3328   		memset(oh->name, 0, sizeof(oh->name));
;;;3329   		yaffs_load_oh_from_name(dev, oh->name, name);
;;;3330   	} else if (prev_chunk_id > 0) {
;;;3331   		memcpy(oh->name, old_name, sizeof(oh->name));
;;;3332   	} else {
;;;3333   		memset(oh->name, 0, sizeof(oh->name));
;;;3334   	}
;;;3335   
;;;3336   	oh->is_shrink = is_shrink;
;;;3337   
;;;3338   	switch (in->variant_type) {
;;;3339   	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;3340   		/* Should not happen */
;;;3341   		break;
;;;3342   	case YAFFS_OBJECT_TYPE_FILE:
;;;3343   		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
;;;3344   		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
;;;3345   			file_size = in->variant.file_variant.file_size;
;;;3346   		yaffs_oh_size_load(oh, file_size);
;;;3347   		break;
;;;3348   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;3349   		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
;;;3350   		break;
;;;3351   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;3352   		/* Do nothing */
;;;3353   		break;
;;;3354   	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;3355   		/* Do nothing */
;;;3356   		break;
;;;3357   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;3358   		alias = in->variant.symlink_variant.alias;
;;;3359   		if (!alias)
;;;3360   			alias = _Y("no alias");
;;;3361   		yaffs_strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
;;;3362   		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
;;;3363   		break;
;;;3364   	}
;;;3365   
;;;3366   	/* process any xattrib modifications */
;;;3367   	if (xmod)
;;;3368   		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
;;;3369   
;;;3370   	/* Tags */
;;;3371   	memset(&new_tags, 0, sizeof(new_tags));
;;;3372   	in->serial++;
;;;3373   	new_tags.chunk_id = 0;
;;;3374   	new_tags.obj_id = in->obj_id;
;;;3375   	new_tags.serial_number = in->serial;
;;;3376   
;;;3377   	/* Add extra info for file header */
;;;3378   	new_tags.extra_available = 1;
;;;3379   	new_tags.extra_parent_id = oh->parent_obj_id;
;;;3380   	new_tags.extra_file_size = file_size;
;;;3381   	new_tags.extra_is_shrink = oh->is_shrink;
;;;3382   	new_tags.extra_equiv_id = oh->equiv_id;
;;;3383   	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
;;;3384   	new_tags.extra_obj_type = in->variant_type;
;;;3385   	yaffs_verify_oh(in, oh, &new_tags, 1);
;;;3386   
;;;3387   	/* Create new chunk in NAND */
;;;3388   	new_chunk_id =
;;;3389   	    yaffs_write_new_chunk(dev, buffer, &new_tags,
;;;3390   				  (prev_chunk_id > 0) ? 1 : 0);
;;;3391   
;;;3392   	if (buffer)
;;;3393   		yaffs_release_temp_buffer(dev, buffer);
;;;3394   
;;;3395   	if (new_chunk_id < 0)
;;;3396   		return new_chunk_id;
;;;3397   
;;;3398   	in->hdr_chunk = new_chunk_id;
;;;3399   
;;;3400   	if (prev_chunk_id > 0)
;;;3401   		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
;;;3402   
;;;3403   	if (!yaffs_obj_cache_dirty(in))
;;;3404   		in->dirty = 0;
;;;3405   
;;;3406   	/* If this was a shrink, then mark the block
;;;3407   	 * that the chunk lives on */
;;;3408   	if (is_shrink) {
;;;3409   		bi = yaffs_get_block_info(in->my_dev,
;;;3410   					  new_chunk_id /
;;;3411   					  in->my_dev->param.chunks_per_block);
;;;3412   		bi->has_shrink_hdr = 1;
;;;3413   	}
;;;3414   
;;;3415   
;;;3416   	return new_chunk_id;
;;;3417   }
003690  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.13972|
003694  e3a01000          MOV      r1,#0                 ;3297
003698  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3297
00369c  ebfffffe          BL       yaffs_check_gc
0036a0  e1a00004          MOV      r0,r4                 ;3298
0036a4  ebfffffe          BL       yaffs_check_obj_details_loaded
0036a8  e5940008          LDR      r0,[r4,#8]            ;3300
0036ac  ebfffffe          BL       yaffs_get_temp_buffer
0036b0  e1a09000          MOV      r9,r0                 ;3300
0036b4  e1a05009          MOV      r5,r9                 ;3301
0036b8  e5946028          LDR      r6,[r4,#0x28]         ;3303
0036bc  e3560000          CMP      r6,#0                 ;3305
0036c0  da000012          BLE      |L1.14096|
0036c4  e28d3f42          ADD      r3,sp,#0x108          ;3306
0036c8  e1a02009          MOV      r2,r9                 ;3306
0036cc  e1a01006          MOV      r1,r6                 ;3306
0036d0  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3306
0036d4  ebfffffe          BL       yaffs_rd_chunk_tags_nand
0036d8  e3a03000          MOV      r3,#0                 ;3309
0036dc  e28d2f42          ADD      r2,sp,#0x108          ;3309
0036e0  e1a01005          MOV      r1,r5                 ;3309
0036e4  e1a00004          MOV      r0,r4                 ;3309
0036e8  ebfffffe          BL       yaffs_verify_oh
0036ec  e3a02c01          MOV      r2,#0x100             ;3310
0036f0  e285100a          ADD      r1,r5,#0xa            ;3310
0036f4  e28d0004          ADD      r0,sp,#4              ;3310
0036f8  ebfffffe          BL       __aeabi_memcpy
0036fc  e3a020ff          MOV      r2,#0xff              ;3311
003700  e3a01c02          MOV      r1,#0x200             ;3311
003704  e1a00009          MOV      r0,r9                 ;3311
003708  ebfffffe          BL       __aeabi_memset
00370c  ea000004          B        |L1.14116|
                  |L1.14096|
003710  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3313
003714  e3a020ff          MOV      r2,#0xff              ;3313
003718  e59010a4          LDR      r1,[r0,#0xa4]         ;3313
00371c  e1a00009          MOV      r0,r9                 ;3313
003720  ebfffffe          BL       __aeabi_memset
                  |L1.14116|
003724  e5d40064          LDRB     r0,[r4,#0x64]         ;3316
003728  e5c50000          STRB     r0,[r5,#0]            ;3316
00372c  e5940034          LDR      r0,[r4,#0x34]         ;3317
003730  e585010c          STR      r0,[r5,#0x10c]        ;3317
003734  e59d01d8          LDR      r0,[sp,#0x1d8]        ;3318
003738  e58501e8          STR      r0,[r5,#0x1e8]        ;3318
00373c  e58501f8          STR      r0,[r5,#0x1f8]        ;3318
003740  e1a01004          MOV      r1,r4                 ;3320
003744  e1a00005          MOV      r0,r5                 ;3320
003748  ebfffffe          BL       yaffs_load_attribs_oh
00374c  e594001c          LDR      r0,[r4,#0x1c]         ;3322
003750  e3500000          CMP      r0,#0                 ;3322
003754  0a000003          BEQ      |L1.14184|
003758  e594001c          LDR      r0,[r4,#0x1c]         ;3323
00375c  e5900030          LDR      r0,[r0,#0x30]         ;3323
003760  e5850004          STR      r0,[r5,#4]            ;3323
003764  ea000001          B        |L1.14192|
                  |L1.14184|
003768  e3a00000          MOV      r0,#0                 ;3325
00376c  e5850004          STR      r0,[r5,#4]            ;3325
                  |L1.14192|
003770  e35a0000          CMP      r10,#0                ;3327
003774  0a00000a          BEQ      |L1.14244|
003778  e5da0000          LDRB     r0,[r10,#0]           ;3327
00377c  e3500000          CMP      r0,#0                 ;3327
003780  0a000007          BEQ      |L1.14244|
003784  e3a01c01          MOV      r1,#0x100             ;3328
003788  e285000a          ADD      r0,r5,#0xa            ;3328
00378c  ebfffffe          BL       __aeabi_memclr
003790  e1a0200a          MOV      r2,r10                ;3329
003794  e285100a          ADD      r1,r5,#0xa            ;3329
003798  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3329
00379c  ebfffffe          BL       yaffs_load_oh_from_name
0037a0  ea000009          B        |L1.14284|
                  |L1.14244|
0037a4  e3560000          CMP      r6,#0                 ;3330
0037a8  da000004          BLE      |L1.14272|
0037ac  e3a02c01          MOV      r2,#0x100             ;3331
0037b0  e28d1004          ADD      r1,sp,#4              ;3331
0037b4  e285000a          ADD      r0,r5,#0xa            ;3331
0037b8  ebfffffe          BL       __aeabi_memcpy
0037bc  ea000002          B        |L1.14284|
                  |L1.14272|
0037c0  e3a01c01          MOV      r1,#0x100             ;3333
0037c4  e285000a          ADD      r0,r5,#0xa            ;3333
0037c8  ebfffffe          BL       __aeabi_memclr
                  |L1.14284|
0037cc  e59d01b0          LDR      r0,[sp,#0x1b0]        ;3336
0037d0  e58501fc          STR      r0,[r5,#0x1fc]        ;3336
0037d4  e5d40064          LDRB     r0,[r4,#0x64]         ;3338
0037d8  e3500006          CMP      r0,#6                 ;3338
0037dc  308ff100          ADDCC    pc,pc,r0,LSL #2       ;3338
0037e0  ea00002c          B        |L1.14488|
0037e4  ea000004          B        |L1.14332|
0037e8  ea000005          B        |L1.14340|
0037ec  ea00001a          B        |L1.14428|
0037f0  ea000017          B        |L1.14420|
0037f4  ea000010          B        |L1.14396|
0037f8  ea000013          B        |L1.14412|
                  |L1.14332|
0037fc  e1a00000          MOV      r0,r0                 ;3339
003800  ea000024          B        |L1.14488|
                  |L1.14340|
003804  e1a00000          MOV      r0,r0                 ;3342
003808  e5950004          LDR      r0,[r5,#4]            ;3343
00380c  e3500004          CMP      r0,#4                 ;3343
003810  0a000004          BEQ      |L1.14376|
003814  e5950004          LDR      r0,[r5,#4]            ;3344
003818  e3500003          CMP      r0,#3                 ;3344
00381c  0a000001          BEQ      |L1.14376|
003820  e5947068          LDR      r7,[r4,#0x68]         ;3345
003824  e594806c          LDR      r8,[r4,#0x6c]         ;3345
                  |L1.14376|
003828  e1a02007          MOV      r2,r7                 ;3346
00382c  e1a03008          MOV      r3,r8                 ;3346
003830  e1a00005          MOV      r0,r5                 ;3346
003834  ebfffffe          BL       yaffs_oh_size_load
003838  ea000016          B        |L1.14488|
                  |L1.14396|
00383c  e1a00000          MOV      r0,r0                 ;3348
003840  e594006c          LDR      r0,[r4,#0x6c]         ;3349
003844  e5850128          STR      r0,[r5,#0x128]        ;3349
003848  ea000012          B        |L1.14488|
                  |L1.14412|
00384c  e1a00000          MOV      r0,r0                 ;3351
003850  ea000010          B        |L1.14488|
                  |L1.14420|
003854  e1a00000          MOV      r0,r0                 ;3354
003858  ea00000e          B        |L1.14488|
                  |L1.14428|
00385c  e1a00000          MOV      r0,r0                 ;3357
003860  e5940068          LDR      r0,[r4,#0x68]         ;3358
003864  e58d0104          STR      r0,[sp,#0x104]        ;3358
003868  e59d0104          LDR      r0,[sp,#0x104]        ;3359
00386c  e3500000          CMP      r0,#0                 ;3359
003870  1a000001          BNE      |L1.14460|
003874  e28f00b8          ADR      r0,|L1.14644|
003878  e58d0104          STR      r0,[sp,#0x104]        ;3360
                  |L1.14460|
00387c  e3a0209f          MOV      r2,#0x9f              ;3361
003880  e2850f4b          ADD      r0,r5,#0x12c          ;3361
003884  e59d1104          LDR      r1,[sp,#0x104]        ;3361
003888  ebfffffe          BL       strncpy
00388c  e3a00000          MOV      r0,#0                 ;3362
003890  e5c501cb          STRB     r0,[r5,#0x1cb]        ;3362
003894  e1a00000          MOV      r0,r0                 ;3363
                  |L1.14488|
003898  e1a00000          MOV      r0,r0                 ;3341
00389c  e59d01dc          LDR      r0,[sp,#0x1dc]        ;3367
0038a0  e3500000          CMP      r0,#0                 ;3367
0038a4  0a000003          BEQ      |L1.14520|
0038a8  e1a01009          MOV      r1,r9                 ;3368
0038ac  e1a00004          MOV      r0,r4                 ;3368
0038b0  e59d21dc          LDR      r2,[sp,#0x1dc]        ;3368
0038b4  ebfffffe          BL       yaffs_apply_xattrib_mod
                  |L1.14520|
0038b8  e3a01048          MOV      r1,#0x48              ;3371
0038bc  e28d0e15          ADD      r0,sp,#0x150          ;3371
0038c0  ebfffffe          BL       __aeabi_memclr4
0038c4  e5d40002          LDRB     r0,[r4,#2]            ;3372
0038c8  e2800001          ADD      r0,r0,#1              ;3372
0038cc  e5c40002          STRB     r0,[r4,#2]            ;3372
0038d0  e3a00000          MOV      r0,#0                 ;3373
0038d4  e58d0158          STR      r0,[sp,#0x158]        ;3373
0038d8  e5940030          LDR      r0,[r4,#0x30]         ;3374
0038dc  e58d0154          STR      r0,[sp,#0x154]        ;3374
0038e0  e5d40002          LDRB     r0,[r4,#2]            ;3375
0038e4  e58d016c          STR      r0,[sp,#0x16c]        ;3375
0038e8  e3a00001          MOV      r0,#1                 ;3378
0038ec  e58d0174          STR      r0,[sp,#0x174]        ;3378
0038f0  e5950004          LDR      r0,[r5,#4]            ;3379
0038f4  e58d0178          STR      r0,[sp,#0x178]        ;3379
0038f8  e58d7188          STR      r7,[sp,#0x188]        ;3380
0038fc  e58d818c          STR      r8,[sp,#0x18c]        ;3380
003900  e59501fc          LDR      r0,[r5,#0x1fc]        ;3381
003904  e58d017c          STR      r0,[sp,#0x17c]        ;3381
003908  e5950128          LDR      r0,[r5,#0x128]        ;3382
00390c  e58d0190          STR      r0,[sp,#0x190]        ;3382
003910  e59501f8          LDR      r0,[r5,#0x1f8]        ;3383
003914  e3500000          CMP      r0,#0                 ;3383
003918  da000008          BLE      |L1.14656|
00391c  e3a00001          MOV      r0,#1                 ;3383
003920  ea000007          B        |L1.14660|
                  |L1.14628|
003924  73696c6c          DCB      "silly old name",0
003928  79206f6c
00392c  64206e61
003930  6d6500  
003933  00                DCB      0
                  |L1.14644|
003934  6e6f2061          DCB      "no alias",0
003938  6c696173
00393c  00      
00393d  00                DCB      0
00393e  00                DCB      0
00393f  00                DCB      0
                  |L1.14656|
003940  e3a00000          MOV      r0,#0                 ;3383
                  |L1.14660|
003944  e58d0180          STR      r0,[sp,#0x180]        ;3383
003948  e5d40064          LDRB     r0,[r4,#0x64]         ;3384
00394c  e5cd0184          STRB     r0,[sp,#0x184]        ;3384
003950  e3a03001          MOV      r3,#1                 ;3385
003954  e28d2e15          ADD      r2,sp,#0x150          ;3385
003958  e1a01005          MOV      r1,r5                 ;3385
00395c  e1a00004          MOV      r0,r4                 ;3385
003960  ebfffffe          BL       yaffs_verify_oh
003964  e3560000          CMP      r6,#0                 ;3388
003968  da000001          BLE      |L1.14708|
00396c  e3a00001          MOV      r0,#1                 ;3390
003970  ea000000          B        |L1.14712|
                  |L1.14708|
003974  e3a00000          MOV      r0,#0                 ;3390
                  |L1.14712|
003978  e1a03000          MOV      r3,r0                 ;3390
00397c  e28d2e15          ADD      r2,sp,#0x150          ;3390
003980  e1a01009          MOV      r1,r9                 ;3390
003984  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3390
003988  ebfffffe          BL       yaffs_write_new_chunk
00398c  e58d0198          STR      r0,[sp,#0x198]        ;3390
003990  e3590000          CMP      r9,#0                 ;3392
003994  0a000002          BEQ      |L1.14756|
003998  e1a01009          MOV      r1,r9                 ;3393
00399c  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3393
0039a0  ebfffffe          BL       yaffs_release_temp_buffer
                  |L1.14756|
0039a4  e59d0198          LDR      r0,[sp,#0x198]        ;3395
0039a8  e3500000          CMP      r0,#0                 ;3395
0039ac  aa000001          BGE      |L1.14776|
0039b0  e59d0198          LDR      r0,[sp,#0x198]        ;3396
0039b4  eaffff34          B        |L1.13964|
                  |L1.14776|
0039b8  e59d0198          LDR      r0,[sp,#0x198]        ;3398
0039bc  e5840028          STR      r0,[r4,#0x28]         ;3398
0039c0  e3560000          CMP      r6,#0                 ;3400
0039c4  da000004          BLE      |L1.14812|
0039c8  e59f33bc          LDR      r3,|L1.15756|
0039cc  e3a02001          MOV      r2,#1                 ;3401
0039d0  e1a01006          MOV      r1,r6                 ;3401
0039d4  e59d01a0          LDR      r0,[sp,#0x1a0]        ;3401
0039d8  ebfffffe          BL       yaffs_chunk_del
                  |L1.14812|
0039dc  e1a00004          MOV      r0,r4                 ;3403
0039e0  ebfffffe          BL       yaffs_obj_cache_dirty
0039e4  e3500000          CMP      r0,#0                 ;3403
0039e8  1a000002          BNE      |L1.14840|
0039ec  e5d40000          LDRB     r0,[r4,#0]            ;3404
0039f0  e3c00040          BIC      r0,r0,#0x40           ;3404
0039f4  e5c40000          STRB     r0,[r4,#0]            ;3404
                  |L1.14840|
0039f8  e59d01b0          LDR      r0,[sp,#0x1b0]        ;3408
0039fc  e3500000          CMP      r0,#0                 ;3408
003a00  0a00000b          BEQ      |L1.14900|
003a04  e5940008          LDR      r0,[r4,#8]            ;3409
003a08  e590100c          LDR      r1,[r0,#0xc]          ;3409
003a0c  e59d0198          LDR      r0,[sp,#0x198]        ;3409
003a10  ebfffffe          BL       __aeabi_idivmod
003a14  e58d0000          STR      r0,[sp,#0]            ;3409
003a18  e5940008          LDR      r0,[r4,#8]            ;3409
003a1c  e59d1000          LDR      r1,[sp,#0]            ;3409
003a20  ebfffffe          BL       yaffs_get_block_info
003a24  e1a0b000          MOV      r11,r0                ;3409
003a28  e59b0000          LDR      r0,[r11,#0]           ;3412
003a2c  e3801102          ORR      r1,r0,#0x80000000     ;3412
003a30  e58b1000          STR      r1,[r11,#0]           ;3412
                  |L1.14900|
003a34  e59d0198          LDR      r0,[sp,#0x198]        ;3416
003a38  eaffff13          B        |L1.13964|
;;;3418   
                          ENDP

                  yaffs_fix_null_name PROC
;;;4409    */
;;;4410   static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
003a3c  e92d41f0          PUSH     {r4-r8,lr}
;;;4411   				int buffer_size)
;;;4412   {
003a40  e24dd028          SUB      sp,sp,#0x28
003a44  e1a05000          MOV      r5,r0
003a48  e1a06001          MOV      r6,r1
003a4c  e1a07002          MOV      r7,r2
;;;4413   	/* Create an object name if we could not find one. */
;;;4414   	if (yaffs_strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
003a50  e1a00006          MOV      r0,r6
003a54  ebfffffe          BL       strlen
003a58  e35000ff          CMP      r0,#0xff
003a5c  9a000001          BLS      |L1.14952|
003a60  e3a000ff          MOV      r0,#0xff
003a64  ea000001          B        |L1.14960|
                  |L1.14952|
003a68  e1a00006          MOV      r0,r6
003a6c  ebfffffe          BL       strlen
                  |L1.14960|
003a70  e3500000          CMP      r0,#0
003a74  1a00001b          BNE      |L1.15080|
;;;4415   		YCHAR local_name[20];
;;;4416   		YCHAR num_string[20];
;;;4417   		YCHAR *x = &num_string[19];
003a78  e28d4013          ADD      r4,sp,#0x13
;;;4418   		unsigned v = obj->obj_id;
003a7c  e5958030          LDR      r8,[r5,#0x30]
;;;4419   		num_string[19] = 0;
003a80  e3a00000          MOV      r0,#0
003a84  e5cd0013          STRB     r0,[sp,#0x13]
;;;4420   		while (v > 0) {
003a88  ea000009          B        |L1.15028|
                  |L1.14988|
;;;4421   			x--;
003a8c  e2444001          SUB      r4,r4,#1
;;;4422   			*x = '0' + (v % 10);
003a90  e3a0100a          MOV      r1,#0xa
003a94  e1a00008          MOV      r0,r8
003a98  ebfffffe          BL       __aeabi_uidivmod
003a9c  e2810030          ADD      r0,r1,#0x30
003aa0  e5c40000          STRB     r0,[r4,#0]
;;;4423   			v /= 10;
003aa4  e3a0100a          MOV      r1,#0xa
003aa8  e1a00008          MOV      r0,r8
003aac  ebfffffe          BL       __aeabi_uidivmod
003ab0  e1a08000          MOV      r8,r0
                  |L1.15028|
003ab4  e3580000          CMP      r8,#0                 ;4420
003ab8  1afffff3          BNE      |L1.14988|
;;;4424   		}
;;;4425   		/* make up a name */
;;;4426   		yaffs_strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
003abc  e28f1fb3          ADR      r1,|L1.15760|
003ac0  e28d0014          ADD      r0,sp,#0x14
003ac4  ebfffffe          BL       strcpy
;;;4427   		yaffs_strcat(local_name, x);
003ac8  e1a01004          MOV      r1,r4
003acc  e28d0014          ADD      r0,sp,#0x14
003ad0  ebfffffe          BL       strcat
;;;4428   		yaffs_strncpy(name, local_name, buffer_size - 1);
003ad4  e2472001          SUB      r2,r7,#1
003ad8  e28d1014          ADD      r1,sp,#0x14
003adc  e1a00006          MOV      r0,r6
003ae0  ebfffffe          BL       strncpy
;;;4429   	}
003ae4  e1a00000          MOV      r0,r0
                  |L1.15080|
;;;4430   }
003ae8  e28dd028          ADD      sp,sp,#0x28
003aec  e8bd81f0          POP      {r4-r8,pc}
;;;4431   
                          ENDP

                  yaffs_load_name_from_oh PROC
;;;3199   
;;;3200   static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
003af0  e92d41f0          PUSH     {r4-r8,lr}
;;;3201   				    const YCHAR *oh_name, int buff_size)
;;;3202   {
003af4  e1a04000          MOV      r4,r0
003af8  e1a05001          MOV      r5,r1
003afc  e1a06002          MOV      r6,r2
003b00  e1a07003          MOV      r7,r3
;;;3203   #ifdef CONFIG_YAFFS_AUTO_UNICODE
;;;3204   	if (dev->param.auto_unicode) {
;;;3205   		if (*oh_name) {
;;;3206   			/* It is an ASCII name, do an ASCII to
;;;3207   			 * unicode conversion */
;;;3208   			const char *ascii_oh_name = (const char *)oh_name;
;;;3209   			int n = buff_size - 1;
;;;3210   			while (n > 0 && *ascii_oh_name) {
;;;3211   				*name = *ascii_oh_name;
;;;3212   				name++;
;;;3213   				ascii_oh_name++;
;;;3214   				n--;
;;;3215   			}
;;;3216   		} else {
;;;3217   			yaffs_strncpy(name, oh_name + 1, buff_size - 1);
;;;3218   		}
;;;3219   	} else {
;;;3220   #else
;;;3221   	dev = dev;
003b04  e1a00000          MOV      r0,r0
;;;3222   	{
;;;3223   #endif
;;;3224   		yaffs_strncpy(name, oh_name, buff_size - 1);
003b08  e2472001          SUB      r2,r7,#1
003b0c  e1a01006          MOV      r1,r6
003b10  e1a00005          MOV      r0,r5
003b14  ebfffffe          BL       strncpy
;;;3225   	}
;;;3226   }
003b18  e8bd81f0          POP      {r4-r8,pc}
;;;3227   
                          ENDP

                  yaffs_get_obj_name PROC
;;;4431   
;;;4432   int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
003b1c  e92d41f0          PUSH     {r4-r8,lr}
;;;4433   {
003b20  e1a04000          MOV      r4,r0
003b24  e1a07001          MOV      r7,r1
003b28  e1a05002          MOV      r5,r2
;;;4434   	memset(name, 0, buffer_size * sizeof(YCHAR));
003b2c  e1a01005          MOV      r1,r5
003b30  e1a00007          MOV      r0,r7
003b34  ebfffffe          BL       __aeabi_memclr
;;;4435   	yaffs_check_obj_details_loaded(obj);
003b38  e1a00004          MOV      r0,r4
003b3c  ebfffffe          BL       yaffs_check_obj_details_loaded
;;;4436   	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
003b40  e5940030          LDR      r0,[r4,#0x30]
003b44  e3500002          CMP      r0,#2
003b48  1a000004          BNE      |L1.15200|
;;;4437   		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
003b4c  e2452001          SUB      r2,r5,#1
003b50  e28f1f8f          ADR      r1,|L1.15764|
003b54  e1a00007          MOV      r0,r7
003b58  ebfffffe          BL       strncpy
003b5c  ea000022          B        |L1.15340|
                  |L1.15200|
;;;4438   	} else if (obj->short_name[0]) {
003b60  e5d40038          LDRB     r0,[r4,#0x38]
003b64  e3500000          CMP      r0,#0
003b68  0a000003          BEQ      |L1.15228|
;;;4439   		yaffs_strcpy(name, obj->short_name);
003b6c  e2841038          ADD      r1,r4,#0x38
003b70  e1a00007          MOV      r0,r7
003b74  ebfffffe          BL       strcpy
003b78  ea00001b          B        |L1.15340|
                  |L1.15228|
;;;4440   	} else if (obj->hdr_chunk > 0) {
003b7c  e5940028          LDR      r0,[r4,#0x28]
003b80  e3500000          CMP      r0,#0
003b84  da000018          BLE      |L1.15340|
;;;4441   		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
003b88  e5940008          LDR      r0,[r4,#8]
003b8c  ebfffffe          BL       yaffs_get_temp_buffer
003b90  e1a06000          MOV      r6,r0
;;;4442   
;;;4443   		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
003b94  e1a08006          MOV      r8,r6
;;;4444   
;;;4445   		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
003b98  e5940008          LDR      r0,[r4,#8]
003b9c  e59010a4          LDR      r1,[r0,#0xa4]
003ba0  e1a00006          MOV      r0,r6
003ba4  ebfffffe          BL       __aeabi_memclr
;;;4446   
;;;4447   		if (obj->hdr_chunk > 0) {
003ba8  e5940028          LDR      r0,[r4,#0x28]
003bac  e3500000          CMP      r0,#0
003bb0  da000004          BLE      |L1.15304|
;;;4448   			yaffs_rd_chunk_tags_nand(obj->my_dev,
003bb4  e3a03000          MOV      r3,#0
003bb8  e1a02006          MOV      r2,r6
003bbc  e5940008          LDR      r0,[r4,#8]
003bc0  e5941028          LDR      r1,[r4,#0x28]
003bc4  ebfffffe          BL       yaffs_rd_chunk_tags_nand
                  |L1.15304|
;;;4449   						 obj->hdr_chunk,
;;;4450   						 buffer, NULL);
;;;4451   		}
;;;4452   		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
003bc8  e1a03005          MOV      r3,r5
003bcc  e288200a          ADD      r2,r8,#0xa
003bd0  e1a01007          MOV      r1,r7
003bd4  e5940008          LDR      r0,[r4,#8]
003bd8  ebfffffe          BL       yaffs_load_name_from_oh
;;;4453   					buffer_size);
;;;4454   
;;;4455   		yaffs_release_temp_buffer(obj->my_dev, buffer);
003bdc  e1a01006          MOV      r1,r6
003be0  e5940008          LDR      r0,[r4,#8]
003be4  ebfffffe          BL       yaffs_release_temp_buffer
;;;4456   	}
003be8  e1a00000          MOV      r0,r0
                  |L1.15340|
;;;4457   
;;;4458   	yaffs_fix_null_name(obj, name, buffer_size);
003bec  e1a02005          MOV      r2,r5
003bf0  e1a01007          MOV      r1,r7
003bf4  e1a00004          MOV      r0,r4
003bf8  ebfffffe          BL       yaffs_fix_null_name
;;;4459   
;;;4460   	return yaffs_strnlen(name, YAFFS_MAX_NAME_LENGTH);
003bfc  e1a00007          MOV      r0,r7
003c00  ebfffffe          BL       strlen
003c04  e35000ff          CMP      r0,#0xff
003c08  9a000001          BLS      |L1.15380|
003c0c  e3a000ff          MOV      r0,#0xff
                  |L1.15376|
;;;4461   }
003c10  e8bd81f0          POP      {r4-r8,pc}
                  |L1.15380|
003c14  e1a00007          MOV      r0,r7                 ;4460
003c18  ebfffffe          BL       strlen
003c1c  eafffffb          B        |L1.15376|
;;;4462   
                          ENDP

                  yaffs_find_by_name PROC
;;;4325   
;;;4326   struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
003c20  e92d41f0          PUSH     {r4-r8,lr}
;;;4327   				     const YCHAR *name)
;;;4328   {
003c24  e24ddc01          SUB      sp,sp,#0x100
003c28  e1a04000          MOV      r4,r0
003c2c  e1a07001          MOV      r7,r1
;;;4329   	int sum;
;;;4330   	struct list_head *i;
;;;4331   	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
;;;4332   	struct yaffs_obj *l;
;;;4333   
;;;4334   	if (!name)
003c30  e3570000          CMP      r7,#0
003c34  1a000002          BNE      |L1.15428|
;;;4335   		return NULL;
003c38  e3a00000          MOV      r0,#0
                  |L1.15420|
003c3c  e28ddc01          ADD      sp,sp,#0x100
;;;4336   
;;;4337   	if (!directory) {
;;;4338   		yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;4339   			"tragedy: yaffs_find_by_name: null pointer directory"
;;;4340   			);
;;;4341   		BUG();
;;;4342   		return NULL;
;;;4343   	}
;;;4344   	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;4345   		yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;4346   			"tragedy: yaffs_find_by_name: non-directory"
;;;4347   			);
;;;4348   		BUG();
;;;4349   	}
;;;4350   
;;;4351   	sum = yaffs_calc_name_sum(name);
;;;4352   
;;;4353   	list_for_each(i, &directory->variant.dir_variant.children) {
;;;4354   		l = list_entry(i, struct yaffs_obj, siblings);
;;;4355   
;;;4356   		if (l->parent != directory)
;;;4357   			BUG();
;;;4358   
;;;4359   		yaffs_check_obj_details_loaded(l);
;;;4360   
;;;4361   		/* Special case for lost-n-found */
;;;4362   		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
;;;4363   			if (!yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME))
;;;4364   				return l;
;;;4365   		} else if (l->sum == sum || l->hdr_chunk <= 0) {
;;;4366   			/* LostnFound chunk called Objxxx
;;;4367   			 * Do a real check
;;;4368   			 */
;;;4369   			yaffs_get_obj_name(l, buffer,
;;;4370   				YAFFS_MAX_NAME_LENGTH + 1);
;;;4371   			if (!yaffs_strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
;;;4372   				return l;
;;;4373   		}
;;;4374   	}
;;;4375   	return NULL;
;;;4376   }
003c40  e8bd81f0          POP      {r4-r8,pc}
                  |L1.15428|
003c44  e3540000          CMP      r4,#0                 ;4337
003c48  1a00000d          BNE      |L1.15492|
003c4c  e59f014c          LDR      r0,|L1.15776|
003c50  e5900000          LDR      r0,[r0,#0]            ;4338  ; yaffs_trace_mask
003c54  e310020f          TST      r0,#0xf0000000        ;4338
003c58  0a000001          BEQ      |L1.15460|
003c5c  e28f0d05          ADR      r0,|L1.15780|
003c60  ebfffffe          BL       sysprintf
                  |L1.15460|
003c64  e1a00000          MOV      r0,r0                 ;4341
003c68  e59f2170          LDR      r2,|L1.15840|
003c6c  e59f1170          LDR      r1,|L1.15844|
003c70  e59f0170          LDR      r0,|L1.15848|
003c74  ebfffffe          BL       sysprintf
003c78  e1a00000          MOV      r0,r0                 ;4341
003c7c  e3a00000          MOV      r0,#0                 ;4342
003c80  eaffffed          B        |L1.15420|
                  |L1.15492|
003c84  e5d40064          LDRB     r0,[r4,#0x64]         ;4344
003c88  e3500003          CMP      r0,#3                 ;4344
003c8c  0a00000b          BEQ      |L1.15552|
003c90  e59f0108          LDR      r0,|L1.15776|
003c94  e5900000          LDR      r0,[r0,#0]            ;4345  ; yaffs_trace_mask
003c98  e310020f          TST      r0,#0xf0000000        ;4345
003c9c  0a000001          BEQ      |L1.15528|
003ca0  e28f0f51          ADR      r0,|L1.15852|
003ca4  ebfffffe          BL       sysprintf
                  |L1.15528|
003ca8  e1a00000          MOV      r0,r0                 ;4348
003cac  e59f216c          LDR      r2,|L1.15904|
003cb0  e59f112c          LDR      r1,|L1.15844|
003cb4  e59f012c          LDR      r0,|L1.15848|
003cb8  ebfffffe          BL       sysprintf
003cbc  e1a00000          MOV      r0,r0                 ;4348
                  |L1.15552|
003cc0  e1a00007          MOV      r0,r7                 ;4351
003cc4  ebfffffe          BL       yaffs_calc_name_sum
003cc8  e1a08000          MOV      r8,r0                 ;4351
003ccc  e5946068          LDR      r6,[r4,#0x68]         ;4353
003cd0  ea000028          B        |L1.15736|
                  |L1.15572|
003cd4  e2465020          SUB      r5,r6,#0x20           ;4354
003cd8  e595001c          LDR      r0,[r5,#0x1c]         ;4356
003cdc  e1500004          CMP      r0,r4                 ;4356
003ce0  0a000005          BEQ      |L1.15612|
003ce4  e1a00000          MOV      r0,r0                 ;4357
003ce8  e59f2134          LDR      r2,|L1.15908|
003cec  e59f10f0          LDR      r1,|L1.15844|
003cf0  e59f00f0          LDR      r0,|L1.15848|
003cf4  ebfffffe          BL       sysprintf
003cf8  e1a00000          MOV      r0,r0                 ;4357
                  |L1.15612|
003cfc  e1a00005          MOV      r0,r5                 ;4359
003d00  ebfffffe          BL       yaffs_check_obj_details_loaded
003d04  e5950030          LDR      r0,[r5,#0x30]         ;4362
003d08  e3500002          CMP      r0,#2                 ;4362
003d0c  1a000006          BNE      |L1.15660|
003d10  e28f107c          ADR      r1,|L1.15764|
003d14  e1a00007          MOV      r0,r7                 ;4363
003d18  ebfffffe          BL       strcmp
003d1c  e3500000          CMP      r0,#0                 ;4363
003d20  1a000013          BNE      |L1.15732|
003d24  e1a00005          MOV      r0,r5                 ;4364
003d28  eaffffc3          B        |L1.15420|
                  |L1.15660|
003d2c  e1d500b4          LDRH     r0,[r5,#4]            ;4365
003d30  e1500008          CMP      r0,r8                 ;4365
003d34  0a000002          BEQ      |L1.15684|
003d38  e5950028          LDR      r0,[r5,#0x28]         ;4365
003d3c  e3500000          CMP      r0,#0                 ;4365
003d40  ca00000b          BGT      |L1.15732|
                  |L1.15684|
003d44  e3a02c01          MOV      r2,#0x100             ;4369
003d48  e1a0100d          MOV      r1,sp                 ;4369
003d4c  e1a00005          MOV      r0,r5                 ;4369
003d50  ebfffffe          BL       yaffs_get_obj_name
003d54  e3a020ff          MOV      r2,#0xff              ;4371
003d58  e1a0100d          MOV      r1,sp                 ;4371
003d5c  e1a00007          MOV      r0,r7                 ;4371
003d60  ebfffffe          BL       strncmp
003d64  e3500000          CMP      r0,#0                 ;4371
003d68  1a000001          BNE      |L1.15732|
003d6c  e1a00005          MOV      r0,r5                 ;4372
003d70  eaffffb1          B        |L1.15420|
                  |L1.15732|
003d74  e5966000          LDR      r6,[r6,#0]            ;4353
                  |L1.15736|
003d78  e2840068          ADD      r0,r4,#0x68           ;4353
003d7c  e1560000          CMP      r6,r0                 ;4353
003d80  1affffd3          BNE      |L1.15572|
003d84  e3a00000          MOV      r0,#0                 ;4375
003d88  eaffffab          B        |L1.15420|
                  |L1.15756|
                          DCD      0x00000d49
                  |L1.15760|
003d90  6f626a00          DCB      "obj",0
                  |L1.15764|
003d94  6c6f7374          DCB      "lost+found",0
003d98  2b666f75
003d9c  6e6400  
003d9f  00                DCB      0
                  |L1.15776|
                          DCD      yaffs_trace_mask
                  |L1.15780|
003da4  79616666          DCB      "yaffs: tragedy: yaffs_find_by_name: null pointer direct"
003da8  733a2074
003dac  72616765
003db0  64793a20
003db4  79616666
003db8  735f6669
003dbc  6e645f62
003dc0  795f6e61
003dc4  6d653a20
003dc8  6e756c6c
003dcc  20706f69
003dd0  6e746572
003dd4  20646972
003dd8  656374  
003ddb  6f72790a          DCB      "ory\n",0
003ddf  00      
                  |L1.15840|
                          DCD      0x000010f5
                  |L1.15844|
                          DCD      ||.text||+0x1f2c
                  |L1.15848|
                          DCD      ||.text||+0x2b4
                  |L1.15852|
003dec  79616666          DCB      "yaffs: tragedy: yaffs_find_by_name: non-directory\n",0
003df0  733a2074
003df4  72616765
003df8  64793a20
003dfc  79616666
003e00  735f6669
003e04  6e645f62
003e08  795f6e61
003e0c  6d653a20
003e10  6e6f6e2d
003e14  64697265
003e18  63746f72
003e1c  790a00  
003e1f  00                DCB      0
                  |L1.15904|
                          DCD      0x000010fc
                  |L1.15908|
                          DCD      0x00001105
                          ENDP

                  yaffs_change_obj_name PROC
;;;1319   
;;;1320   static int yaffs_change_obj_name(struct yaffs_obj *obj,
003e28  e92d5ffc          PUSH     {r2-r12,lr}
;;;1321   				 struct yaffs_obj *new_dir,
;;;1322   				 const YCHAR *new_name, int force, int shadows)
;;;1323   {
003e2c  e1a04000          MOV      r4,r0
003e30  e1a05001          MOV      r5,r1
003e34  e1a07002          MOV      r7,r2
003e38  e1a08003          MOV      r8,r3
003e3c  e59d9030          LDR      r9,[sp,#0x30]
;;;1324   	int unlink_op;
;;;1325   	int del_op;
;;;1326   	struct yaffs_obj *existing_target;
;;;1327   
;;;1328   	if (new_dir == NULL)
003e40  e3550000          CMP      r5,#0
003e44  1a000000          BNE      |L1.15948|
;;;1329   		new_dir = obj->parent;	/* use the old directory */
003e48  e594501c          LDR      r5,[r4,#0x1c]
                  |L1.15948|
;;;1330   
;;;1331   	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
003e4c  e5d50064          LDRB     r0,[r5,#0x64]
003e50  e3500003          CMP      r0,#3
003e54  0a00000b          BEQ      |L1.16008|
;;;1332   		yaffs_trace(YAFFS_TRACE_ALWAYS,
003e58  e51f00c0          LDR      r0,|L1.15776|
003e5c  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
003e60  e310020f          TST      r0,#0xf0000000
003e64  0a000001          BEQ      |L1.15984|
003e68  e59f03fc          LDR      r0,|L1.17004|
003e6c  ebfffffe          BL       sysprintf
                  |L1.15984|
;;;1333   			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
;;;1334   			);
;;;1335   		BUG();
003e70  e1a00000          MOV      r0,r0
003e74  e59f23f4          LDR      r2,|L1.17008|
003e78  e51f109c          LDR      r1,|L1.15844|
003e7c  e51f009c          LDR      r0,|L1.15848|
003e80  ebfffffe          BL       sysprintf
003e84  e1a00000          MOV      r0,r0
                  |L1.16008|
;;;1336   	}
;;;1337   
;;;1338   	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
003e88  e5940008          LDR      r0,[r4,#8]
003e8c  e5900d98          LDR      r0,[r0,#0xd98]
003e90  e1500005          CMP      r0,r5
003e94  1a000001          BNE      |L1.16032|
003e98  e3a00001          MOV      r0,#1
003e9c  ea000000          B        |L1.16036|
                  |L1.16032|
003ea0  e3a00000          MOV      r0,#0
                  |L1.16036|
003ea4  e1a0a000          MOV      r10,r0
;;;1339   	del_op = (new_dir == obj->my_dev->del_dir);
003ea8  e5940008          LDR      r0,[r4,#8]
003eac  e5900d9c          LDR      r0,[r0,#0xd9c]
003eb0  e1500005          CMP      r0,r5
003eb4  1a000001          BNE      |L1.16064|
003eb8  e3a00001          MOV      r0,#1
003ebc  ea000000          B        |L1.16068|
                  |L1.16064|
003ec0  e3a00000          MOV      r0,#0
                  |L1.16068|
003ec4  e1a0b000          MOV      r11,r0
;;;1340   
;;;1341   	existing_target = yaffs_find_by_name(new_dir, new_name);
003ec8  e1a01007          MOV      r1,r7
003ecc  e1a00005          MOV      r0,r5
003ed0  ebfffffe          BL       yaffs_find_by_name
003ed4  e1a06000          MOV      r6,r0
;;;1342   
;;;1343   	/* If the object is a file going into the unlinked directory,
;;;1344   	 *   then it is OK to just stuff it in since duplicate names are OK.
;;;1345   	 *   else only proceed if the new name does not exist and we're putting
;;;1346   	 *   it into a directory.
;;;1347   	 */
;;;1348   	if (!(unlink_op || del_op || force ||
003ed8  e35a0000          CMP      r10,#0
003edc  1a000007          BNE      |L1.16128|
003ee0  e35b0000          CMP      r11,#0
003ee4  1a000005          BNE      |L1.16128|
003ee8  e3580000          CMP      r8,#0
003eec  1a000003          BNE      |L1.16128|
003ef0  e3590000          CMP      r9,#0
003ef4  ca000001          BGT      |L1.16128|
003ef8  e3560000          CMP      r6,#0
003efc  1a000002          BNE      |L1.16140|
                  |L1.16128|
;;;1349   	      shadows > 0 || !existing_target) ||
;;;1350   	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
003f00  e5d50064          LDRB     r0,[r5,#0x64]
003f04  e3500003          CMP      r0,#3
003f08  0a000001          BEQ      |L1.16148|
                  |L1.16140|
;;;1351   		return YAFFS_FAIL;
003f0c  e3a00000          MOV      r0,#0
                  |L1.16144|
;;;1352   
;;;1353   	yaffs_set_obj_name(obj, new_name);
;;;1354   	obj->dirty = 1;
;;;1355   	yaffs_add_obj_to_dir(new_dir, obj);
;;;1356   
;;;1357   	if (unlink_op)
;;;1358   		obj->unlinked = 1;
;;;1359   
;;;1360   	/* If it is a deletion then we mark it as a shrink for gc  */
;;;1361   	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
;;;1362   		return YAFFS_OK;
;;;1363   
;;;1364   	return YAFFS_FAIL;
;;;1365   }
003f10  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.16148|
003f14  e1a01007          MOV      r1,r7                 ;1353
003f18  e1a00004          MOV      r0,r4                 ;1353
003f1c  ebfffffe          BL       yaffs_set_obj_name
003f20  e5d40000          LDRB     r0,[r4,#0]            ;1354
003f24  e3800040          ORR      r0,r0,#0x40           ;1354
003f28  e5c40000          STRB     r0,[r4,#0]            ;1354
003f2c  e1a01004          MOV      r1,r4                 ;1355
003f30  e1a00005          MOV      r0,r5                 ;1355
003f34  ebfffffe          BL       yaffs_add_obj_to_dir
003f38  e35a0000          CMP      r10,#0                ;1357
003f3c  0a000002          BEQ      |L1.16204|
003f40  e5d40000          LDRB     r0,[r4,#0]            ;1358
003f44  e3800004          ORR      r0,r0,#4              ;1358
003f48  e5c40000          STRB     r0,[r4,#0]            ;1358
                  |L1.16204|
003f4c  e3a00000          MOV      r0,#0                 ;1361
003f50  e1a0300b          MOV      r3,r11                ;1361
003f54  e58d0004          STR      r0,[sp,#4]            ;1361
003f58  e1a02000          MOV      r2,r0                 ;1361
003f5c  e1a01007          MOV      r1,r7                 ;1361
003f60  e1a00004          MOV      r0,r4                 ;1361
003f64  e58d9000          STR      r9,[sp,#0]            ;1361
003f68  ebfffffe          BL       yaffs_update_oh
003f6c  e3500000          CMP      r0,#0                 ;1361
003f70  ba000001          BLT      |L1.16252|
003f74  e3a00001          MOV      r0,#1                 ;1362
003f78  eaffffe4          B        |L1.16144|
                  |L1.16252|
003f7c  e3a00000          MOV      r0,#0                 ;1364
003f80  eaffffe2          B        |L1.16144|
;;;1366   
                          ENDP

                  yaffs_wr_data_obj PROC
;;;2995   
;;;2996   static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
003f84  e92d4ff0          PUSH     {r4-r11,lr}
;;;2997   			     const u8 *buffer, int n_bytes, int use_reserve)
;;;2998   {
003f88  e24dd094          SUB      sp,sp,#0x94
003f8c  e1a07000          MOV      r7,r0
003f90  e1a08001          MOV      r8,r1
003f94  e1a09002          MOV      r9,r2
003f98  e1a04003          MOV      r4,r3
003f9c  e59db0b8          LDR      r11,[sp,#0xb8]
;;;2999   	/* Find old chunk Need to do this to get serial number
;;;3000   	 * Write new one and patch into tree.
;;;3001   	 * Invalidate old tags.
;;;3002   	 */
;;;3003   
;;;3004   	int prev_chunk_id;
;;;3005   	struct yaffs_ext_tags prev_tags;
;;;3006   	int new_chunk_id;
;;;3007   	struct yaffs_ext_tags new_tags;
;;;3008   	struct yaffs_dev *dev = in->my_dev;
003fa0  e597a008          LDR      r10,[r7,#8]
;;;3009   
;;;3010   	yaffs_check_gc(dev, 0);
003fa4  e3a01000          MOV      r1,#0
003fa8  e1a0000a          MOV      r0,r10
003fac  ebfffffe          BL       yaffs_check_gc
;;;3011   
;;;3012   	/* Get the previous chunk at this location in the file if it exists.
;;;3013   	 * If it does not exist then put a zero into the tree. This creates
;;;3014   	 * the tnode now, rather than later when it is harder to clean up.
;;;3015   	 */
;;;3016   	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
003fb0  e28d2048          ADD      r2,sp,#0x48
003fb4  e1a01008          MOV      r1,r8
003fb8  e1a00007          MOV      r0,r7
003fbc  ebfffffe          BL       yaffs_find_chunk_in_file
003fc0  e1a05000          MOV      r5,r0
;;;3017   	if (prev_chunk_id < 1 &&
003fc4  e3550001          CMP      r5,#1
003fc8  aa000009          BGE      |L1.16372|
;;;3018   	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
003fcc  e3a03000          MOV      r3,#0
003fd0  e1a02003          MOV      r2,r3
003fd4  e1a01008          MOV      r1,r8
003fd8  e1a00007          MOV      r0,r7
003fdc  ebfffffe          BL       yaffs_put_chunk_in_file
003fe0  e3500000          CMP      r0,#0
003fe4  1a000002          BNE      |L1.16372|
;;;3019   		return 0;
003fe8  e3a00000          MOV      r0,#0
                  |L1.16364|
003fec  e28dd094          ADD      sp,sp,#0x94
;;;3020   
;;;3021   	/* Set up new tags */
;;;3022   	memset(&new_tags, 0, sizeof(new_tags));
;;;3023   
;;;3024   	new_tags.chunk_id = inode_chunk;
;;;3025   	new_tags.obj_id = in->obj_id;
;;;3026   	new_tags.serial_number =
;;;3027   	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
;;;3028   	new_tags.n_bytes = n_bytes;
;;;3029   
;;;3030   	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
;;;3031   		yaffs_trace(YAFFS_TRACE_ERROR,
;;;3032   		  "Writing %d bytes to chunk!!!!!!!!!",
;;;3033   		   n_bytes);
;;;3034   		BUG();
;;;3035   	}
;;;3036   
;;;3037   	new_chunk_id =
;;;3038   	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
;;;3039   
;;;3040   	if (new_chunk_id > 0) {
;;;3041   		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
;;;3042   
;;;3043   		if (prev_chunk_id > 0)
;;;3044   			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
;;;3045   
;;;3046   		yaffs_verify_file_sane(in);
;;;3047   	}
;;;3048   	return new_chunk_id;
;;;3049   
;;;3050   }
003ff0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.16372|
003ff4  e3a01048          MOV      r1,#0x48              ;3022
003ff8  e1a0000d          MOV      r0,sp                 ;3022
003ffc  ebfffffe          BL       __aeabi_memclr4
004000  e58d8008          STR      r8,[sp,#8]            ;3024
004004  e5970030          LDR      r0,[r7,#0x30]         ;3025
004008  e58d0004          STR      r0,[sp,#4]            ;3025
00400c  e3550000          CMP      r5,#0                 ;3026
004010  da000002          BLE      |L1.16416|
004014  e59d0064          LDR      r0,[sp,#0x64]         ;3027
004018  e2800001          ADD      r0,r0,#1              ;3027
00401c  ea000000          B        |L1.16420|
                  |L1.16416|
004020  e3a00001          MOV      r0,#1                 ;3027
                  |L1.16420|
004024  e58d001c          STR      r0,[sp,#0x1c]         ;3027
004028  e58d400c          STR      r4,[sp,#0xc]          ;3028
00402c  e3540001          CMP      r4,#1                 ;3030
004030  ba000002          BLT      |L1.16448|
004034  e59a0008          LDR      r0,[r10,#8]           ;3030
004038  e1500004          CMP      r0,r4                 ;3030
00403c  2a00000c          BCS      |L1.16500|
                  |L1.16448|
004040  e51f02a8          LDR      r0,|L1.15776|
004044  e5900000          LDR      r0,[r0,#0]            ;3031  ; yaffs_trace_mask
004048  e3100101          TST      r0,#0x40000000        ;3031
00404c  0a000002          BEQ      |L1.16476|
004050  e1a01004          MOV      r1,r4                 ;3031
004054  e28f0f86          ADR      r0,|L1.17012|
004058  ebfffffe          BL       sysprintf
                  |L1.16476|
00405c  e1a00000          MOV      r0,r0                 ;3034
004060  e59f2238          LDR      r2,|L1.17056|
004064  e51f1288          LDR      r1,|L1.15844|
004068  e51f0288          LDR      r0,|L1.15848|
00406c  ebfffffe          BL       sysprintf
004070  e1a00000          MOV      r0,r0                 ;3034
                  |L1.16500|
004074  e1a0300b          MOV      r3,r11                ;3037
004078  e1a0200d          MOV      r2,sp                 ;3037
00407c  e1a01009          MOV      r1,r9                 ;3037
004080  e1a0000a          MOV      r0,r10                ;3037
004084  ebfffffe          BL       yaffs_write_new_chunk
004088  e1a06000          MOV      r6,r0                 ;3037
00408c  e3560000          CMP      r6,#0                 ;3040
004090  da00000d          BLE      |L1.16588|
004094  e3a03000          MOV      r3,#0                 ;3041
004098  e1a02006          MOV      r2,r6                 ;3041
00409c  e1a01008          MOV      r1,r8                 ;3041
0040a0  e1a00007          MOV      r0,r7                 ;3041
0040a4  ebfffffe          BL       yaffs_put_chunk_in_file
0040a8  e3550000          CMP      r5,#0                 ;3043
0040ac  da000004          BLE      |L1.16580|
0040b0  e59f31ec          LDR      r3,|L1.17060|
0040b4  e3a02001          MOV      r2,#1                 ;3044
0040b8  e1a01005          MOV      r1,r5                 ;3044
0040bc  e1a0000a          MOV      r0,r10                ;3044
0040c0  ebfffffe          BL       yaffs_chunk_del
                  |L1.16580|
0040c4  e1a00007          MOV      r0,r7                 ;3046
0040c8  ebfffffe          BL       yaffs_verify_file_sane
                  |L1.16588|
0040cc  e1a00006          MOV      r0,r6                 ;3048
0040d0  eaffffc5          B        |L1.16364|
;;;3051   
                          ENDP

                  yaffs_flush_file_cache PROC
;;;1395   
;;;1396   static void yaffs_flush_file_cache(struct yaffs_obj *obj)
0040d4  e92d4ff8          PUSH     {r3-r11,lr}
;;;1397   {
0040d8  e1a06000          MOV      r6,r0
;;;1398   	struct yaffs_dev *dev = obj->my_dev;
0040dc  e5967008          LDR      r7,[r6,#8]
;;;1399   	int lowest = -99;	/* Stop compiler whining. */
0040e0  e3e09062          MVN      r9,#0x62
;;;1400   	int i;
;;;1401   	struct yaffs_cache *cache;
;;;1402   	int chunk_written = 0;
0040e4  e3a0a000          MOV      r10,#0
;;;1403   	int n_caches = obj->my_dev->param.n_caches;
0040e8  e5960008          LDR      r0,[r6,#8]
0040ec  e5908020          LDR      r8,[r0,#0x20]
;;;1404   
;;;1405   	if (n_caches < 1)
0040f0  e3580001          CMP      r8,#1
0040f4  aa000000          BGE      |L1.16636|
                  |L1.16632|
;;;1406   		return;
;;;1407   	do {
;;;1408   		cache = NULL;
;;;1409   
;;;1410   		/* Find the lowest dirty chunk for this object */
;;;1411   		for (i = 0; i < n_caches; i++) {
;;;1412   			if (dev->cache[i].object == obj &&
;;;1413   			    dev->cache[i].dirty) {
;;;1414   				if (!cache ||
;;;1415   				    dev->cache[i].chunk_id < lowest) {
;;;1416   					cache = &dev->cache[i];
;;;1417   					lowest = cache->chunk_id;
;;;1418   				}
;;;1419   			}
;;;1420   		}
;;;1421   
;;;1422   		if (cache && !cache->locked) {
;;;1423   			/* Write it out and free it up */
;;;1424   			chunk_written =
;;;1425   			    yaffs_wr_data_obj(cache->object,
;;;1426   					      cache->chunk_id,
;;;1427   					      cache->data,
;;;1428   					      cache->n_bytes, 1);
;;;1429   			cache->dirty = 0;
;;;1430   			cache->object = NULL;
;;;1431   		}
;;;1432   	} while (cache && chunk_written > 0);
;;;1433   
;;;1434   	if (cache)
;;;1435   		/* Hoosterman, disk full while writing cache out. */
;;;1436   		yaffs_trace(YAFFS_TRACE_ERROR,
;;;1437   			"yaffs tragedy: no space during cache write");
;;;1438   }
0040f8  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.16636|
0040fc  e1a00000          MOV      r0,r0                 ;1407
                  |L1.16640|
004100  e3a04000          MOV      r4,#0                 ;1408
004104  e3a05000          MOV      r5,#0                 ;1411
004108  ea000017          B        |L1.16748|
                  |L1.16652|
00410c  e0651185          RSB      r1,r5,r5,LSL #3       ;1412
004110  e5970d90          LDR      r0,[r7,#0xd90]        ;1412
004114  e7900101          LDR      r0,[r0,r1,LSL #2]     ;1412
004118  e1500006          CMP      r0,r6                 ;1412
00411c  1a000011          BNE      |L1.16744|
004120  e0651185          RSB      r1,r5,r5,LSL #3       ;1413
004124  e5970d90          LDR      r0,[r7,#0xd90]        ;1413
004128  e0800101          ADD      r0,r0,r1,LSL #2       ;1413
00412c  e590000c          LDR      r0,[r0,#0xc]          ;1413
004130  e3500000          CMP      r0,#0                 ;1413
004134  0a00000b          BEQ      |L1.16744|
004138  e3540000          CMP      r4,#0                 ;1414
00413c  0a000005          BEQ      |L1.16728|
004140  e0651185          RSB      r1,r5,r5,LSL #3       ;1415
004144  e5970d90          LDR      r0,[r7,#0xd90]        ;1415
004148  e0800101          ADD      r0,r0,r1,LSL #2       ;1415
00414c  e5900004          LDR      r0,[r0,#4]            ;1415
004150  e1500009          CMP      r0,r9                 ;1415
004154  aa000003          BGE      |L1.16744|
                  |L1.16728|
004158  e0651185          RSB      r1,r5,r5,LSL #3       ;1416
00415c  e5970d90          LDR      r0,[r7,#0xd90]        ;1416
004160  e0804101          ADD      r4,r0,r1,LSL #2       ;1416
004164  e5949004          LDR      r9,[r4,#4]            ;1417
                  |L1.16744|
004168  e2855001          ADD      r5,r5,#1              ;1411
                  |L1.16748|
00416c  e1550008          CMP      r5,r8                 ;1411
004170  baffffe5          BLT      |L1.16652|
004174  e3540000          CMP      r4,#0                 ;1422
004178  0a00000c          BEQ      |L1.16816|
00417c  e5940014          LDR      r0,[r4,#0x14]         ;1422
004180  e3500000          CMP      r0,#0                 ;1422
004184  1a000009          BNE      |L1.16816|
004188  e3a00001          MOV      r0,#1                 ;1424
00418c  e58d0000          STR      r0,[sp,#0]            ;1424
004190  e8940003          LDM      r4,{r0,r1}            ;1424
004194  e5942018          LDR      r2,[r4,#0x18]         ;1424
004198  e5943010          LDR      r3,[r4,#0x10]         ;1424
00419c  ebfffffe          BL       yaffs_wr_data_obj
0041a0  e1a0a000          MOV      r10,r0                ;1424
0041a4  e3a00000          MOV      r0,#0                 ;1429
0041a8  e584000c          STR      r0,[r4,#0xc]          ;1429
0041ac  e5840000          STR      r0,[r4,#0]            ;1430
                  |L1.16816|
0041b0  e3540000          CMP      r4,#0                 ;1432
0041b4  0a000001          BEQ      |L1.16832|
0041b8  e35a0000          CMP      r10,#0                ;1432
0041bc  caffffcf          BGT      |L1.16640|
                  |L1.16832|
0041c0  e3540000          CMP      r4,#0                 ;1434
0041c4  0a000005          BEQ      |L1.16864|
0041c8  e51f0430          LDR      r0,|L1.15776|
0041cc  e5900000          LDR      r0,[r0,#0]            ;1436  ; yaffs_trace_mask
0041d0  e3100101          TST      r0,#0x40000000        ;1436
0041d4  0a000001          BEQ      |L1.16864|
0041d8  e28f00c8          ADR      r0,|L1.17064|
0041dc  ebfffffe          BL       sysprintf
                  |L1.16864|
0041e0  e1a00000          MOV      r0,r0
0041e4  eaffffc3          B        |L1.16632|
;;;1439   
                          ENDP

                  yaffs_flush_whole_cache PROC
;;;1444   
;;;1445   void yaffs_flush_whole_cache(struct yaffs_dev *dev)
0041e8  e92d41f0          PUSH     {r4-r8,lr}
;;;1446   {
0041ec  e1a04000          MOV      r4,r0
;;;1447   	struct yaffs_obj *obj;
;;;1448   	int n_caches = dev->param.n_caches;
0041f0  e5947020          LDR      r7,[r4,#0x20]
;;;1449   	int i;
;;;1450   
;;;1451   	/* Find a dirty object in the cache and flush it...
;;;1452   	 * until there are no further dirty objects.
;;;1453   	 */
;;;1454   	do {
0041f4  e1a00000          MOV      r0,r0
                  |L1.16888|
;;;1455   		obj = NULL;
0041f8  e3a06000          MOV      r6,#0
;;;1456   		for (i = 0; i < n_caches && !obj; i++) {
0041fc  e3a05000          MOV      r5,#0
004200  ea00000e          B        |L1.16960|
                  |L1.16900|
;;;1457   			if (dev->cache[i].object && dev->cache[i].dirty)
004204  e0651185          RSB      r1,r5,r5,LSL #3
004208  e5940d90          LDR      r0,[r4,#0xd90]
00420c  e7900101          LDR      r0,[r0,r1,LSL #2]
004210  e3500000          CMP      r0,#0
004214  0a000008          BEQ      |L1.16956|
004218  e0651185          RSB      r1,r5,r5,LSL #3
00421c  e5940d90          LDR      r0,[r4,#0xd90]
004220  e0800101          ADD      r0,r0,r1,LSL #2
004224  e590000c          LDR      r0,[r0,#0xc]
004228  e3500000          CMP      r0,#0
00422c  0a000002          BEQ      |L1.16956|
;;;1458   				obj = dev->cache[i].object;
004230  e0651185          RSB      r1,r5,r5,LSL #3
004234  e5940d90          LDR      r0,[r4,#0xd90]
004238  e7906101          LDR      r6,[r0,r1,LSL #2]
                  |L1.16956|
00423c  e2855001          ADD      r5,r5,#1              ;1456
                  |L1.16960|
004240  e1550007          CMP      r5,r7                 ;1456
004244  aa000001          BGE      |L1.16976|
004248  e3560000          CMP      r6,#0                 ;1456
00424c  0affffec          BEQ      |L1.16900|
                  |L1.16976|
;;;1459   		}
;;;1460   		if (obj)
004250  e3560000          CMP      r6,#0
004254  0a000001          BEQ      |L1.16992|
;;;1461   			yaffs_flush_file_cache(obj);
004258  e1a00006          MOV      r0,r6
00425c  ebfffffe          BL       yaffs_flush_file_cache
                  |L1.16992|
;;;1462   	} while (obj);
004260  e3560000          CMP      r6,#0
004264  1affffe3          BNE      |L1.16888|
;;;1463   
;;;1464   }
004268  e8bd81f0          POP      {r4-r8,pc}
                  |L1.17004|
                          DCD      ||.constdata||+0x1bc
                  |L1.17008|
                          DCD      0x00000537
                  |L1.17012|
004274  79616666          DCB      "yaffs: Writing %d bytes to chunk!!!!!!!!!\n",0
004278  733a2057
00427c  72697469
004280  6e672025
004284  64206279
004288  74657320
00428c  746f2063
004290  68756e6b
004294  21212121
004298  21212121
00429c  210a00  
00429f  00                DCB      0
                  |L1.17056|
                          DCD      0x00000bda
                  |L1.17060|
                          DCD      0x00000be4
                  |L1.17064|
0042a8  79616666          DCB      "yaffs: yaffs tragedy: no space during cache write\n",0
0042ac  733a2079
0042b0  61666673
0042b4  20747261
0042b8  67656479
0042bc  3a206e6f
0042c0  20737061
0042c4  63652064
0042c8  7572696e
0042cc  67206361
0042d0  63686520
0042d4  77726974
0042d8  650a00  
0042db  00                DCB      0
                          ENDP

                  yaffs_grab_chunk_worker PROC
;;;1470    */
;;;1471   static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
0042dc  e1a01000          MOV      r1,r0
;;;1472   {
;;;1473   	int i;
;;;1474   
;;;1475   	if (dev->param.n_caches > 0) {
0042e0  e5910020          LDR      r0,[r1,#0x20]
0042e4  e3500000          CMP      r0,#0
0042e8  da00000e          BLE      |L1.17192|
;;;1476   		for (i = 0; i < dev->param.n_caches; i++) {
0042ec  e3a02000          MOV      r2,#0
0042f0  ea000009          B        |L1.17180|
                  |L1.17140|
;;;1477   			if (!dev->cache[i].object)
0042f4  e0623182          RSB      r3,r2,r2,LSL #3
0042f8  e5910d90          LDR      r0,[r1,#0xd90]
0042fc  e7900103          LDR      r0,[r0,r3,LSL #2]
004300  e3500000          CMP      r0,#0
004304  1a000003          BNE      |L1.17176|
;;;1478   				return &dev->cache[i];
004308  e0623182          RSB      r3,r2,r2,LSL #3
00430c  e5910d90          LDR      r0,[r1,#0xd90]
004310  e0800103          ADD      r0,r0,r3,LSL #2
                  |L1.17172|
;;;1479   		}
;;;1480   	}
;;;1481   	return NULL;
;;;1482   }
004314  e12fff1e          BX       lr
                  |L1.17176|
004318  e2822001          ADD      r2,r2,#1              ;1476
                  |L1.17180|
00431c  e5910020          LDR      r0,[r1,#0x20]         ;1476
004320  e1500002          CMP      r0,r2                 ;1476
004324  cafffff2          BGT      |L1.17140|
                  |L1.17192|
004328  e3a00000          MOV      r0,#0                 ;1481
00432c  eafffff8          B        |L1.17172|
;;;1483   
                          ENDP

                  yaffs_grab_chunk_cache PROC
;;;1484   static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
004330  e92d41f0          PUSH     {r4-r8,lr}
;;;1485   {
004334  e1a04000          MOV      r4,r0
;;;1486   	struct yaffs_cache *cache;
;;;1487   	struct yaffs_obj *the_obj;
;;;1488   	int usage;
;;;1489   	int i;
;;;1490   
;;;1491   	if (dev->param.n_caches < 1)
004338  e5940020          LDR      r0,[r4,#0x20]
00433c  e3500001          CMP      r0,#1
004340  aa000001          BGE      |L1.17228|
;;;1492   		return NULL;
004344  e3a00000          MOV      r0,#0
                  |L1.17224|
;;;1493   
;;;1494   	/* Try find a non-dirty one... */
;;;1495   
;;;1496   	cache = yaffs_grab_chunk_worker(dev);
;;;1497   
;;;1498   	if (!cache) {
;;;1499   		/* They were all dirty, find the LRU object and flush
;;;1500   		 * its cache, then  find again.
;;;1501   		 * NB what's here is not very accurate,
;;;1502   		 * we actually flush the object with the LRU chunk.
;;;1503   		 */
;;;1504   
;;;1505   		/* With locking we can't assume we can use entry zero,
;;;1506   		 * Set the_obj to a valid pointer for Coverity. */
;;;1507   		the_obj = dev->cache[0].object;
;;;1508   		usage = -1;
;;;1509   		cache = NULL;
;;;1510   
;;;1511   		for (i = 0; i < dev->param.n_caches; i++) {
;;;1512   			if (dev->cache[i].object &&
;;;1513   			    !dev->cache[i].locked &&
;;;1514   			    (dev->cache[i].last_use < usage ||
;;;1515   			    !cache)) {
;;;1516   				usage = dev->cache[i].last_use;
;;;1517   				the_obj = dev->cache[i].object;
;;;1518   				cache = &dev->cache[i];
;;;1519   			}
;;;1520   		}
;;;1521   
;;;1522   		if (!cache || cache->dirty) {
;;;1523   			/* Flush and try again */
;;;1524   			yaffs_flush_file_cache(the_obj);
;;;1525   			cache = yaffs_grab_chunk_worker(dev);
;;;1526   		}
;;;1527   	}
;;;1528   	return cache;
;;;1529   }
004348  e8bd81f0          POP      {r4-r8,pc}
                  |L1.17228|
00434c  e1a00004          MOV      r0,r4                 ;1496
004350  ebfffffe          BL       yaffs_grab_chunk_worker
004354  e1a06000          MOV      r6,r0                 ;1496
004358  e3560000          CMP      r6,#0                 ;1498
00435c  1a000030          BNE      |L1.17444|
004360  e5940d90          LDR      r0,[r4,#0xd90]        ;1507
004364  e5907000          LDR      r7,[r0,#0]            ;1507
004368  e3e08000          MVN      r8,#0                 ;1508
00436c  e3a06000          MOV      r6,#0                 ;1509
004370  e3a05000          MOV      r5,#0                 ;1511
004374  ea00001d          B        |L1.17392|
                  |L1.17272|
004378  e0651185          RSB      r1,r5,r5,LSL #3       ;1512
00437c  e5940d90          LDR      r0,[r4,#0xd90]        ;1512
004380  e7900101          LDR      r0,[r0,r1,LSL #2]     ;1512
004384  e3500000          CMP      r0,#0                 ;1512
004388  0a000017          BEQ      |L1.17388|
00438c  e0651185          RSB      r1,r5,r5,LSL #3       ;1513
004390  e5940d90          LDR      r0,[r4,#0xd90]        ;1513
004394  e0800101          ADD      r0,r0,r1,LSL #2       ;1513
004398  e5900014          LDR      r0,[r0,#0x14]         ;1513
00439c  e3500000          CMP      r0,#0                 ;1513
0043a0  1a000011          BNE      |L1.17388|
0043a4  e0651185          RSB      r1,r5,r5,LSL #3       ;1514
0043a8  e5940d90          LDR      r0,[r4,#0xd90]        ;1514
0043ac  e0800101          ADD      r0,r0,r1,LSL #2       ;1514
0043b0  e5900008          LDR      r0,[r0,#8]            ;1514
0043b4  e1500008          CMP      r0,r8                 ;1514
0043b8  ba000001          BLT      |L1.17348|
0043bc  e3560000          CMP      r6,#0                 ;1515
0043c0  1a000009          BNE      |L1.17388|
                  |L1.17348|
0043c4  e0651185          RSB      r1,r5,r5,LSL #3       ;1516
0043c8  e5940d90          LDR      r0,[r4,#0xd90]        ;1516
0043cc  e0800101          ADD      r0,r0,r1,LSL #2       ;1516
0043d0  e5908008          LDR      r8,[r0,#8]            ;1516
0043d4  e0651185          RSB      r1,r5,r5,LSL #3       ;1517
0043d8  e5940d90          LDR      r0,[r4,#0xd90]        ;1517
0043dc  e7907101          LDR      r7,[r0,r1,LSL #2]     ;1517
0043e0  e0651185          RSB      r1,r5,r5,LSL #3       ;1518
0043e4  e5940d90          LDR      r0,[r4,#0xd90]        ;1518
0043e8  e0806101          ADD      r6,r0,r1,LSL #2       ;1518
                  |L1.17388|
0043ec  e2855001          ADD      r5,r5,#1              ;1511
                  |L1.17392|
0043f0  e5940020          LDR      r0,[r4,#0x20]         ;1511
0043f4  e1500005          CMP      r0,r5                 ;1511
0043f8  caffffde          BGT      |L1.17272|
0043fc  e3560000          CMP      r6,#0                 ;1522
004400  0a000002          BEQ      |L1.17424|
004404  e596000c          LDR      r0,[r6,#0xc]          ;1522
004408  e3500000          CMP      r0,#0                 ;1522
00440c  0a000004          BEQ      |L1.17444|
                  |L1.17424|
004410  e1a00007          MOV      r0,r7                 ;1524
004414  ebfffffe          BL       yaffs_flush_file_cache
004418  e1a00004          MOV      r0,r4                 ;1525
00441c  ebfffffe          BL       yaffs_grab_chunk_worker
004420  e1a06000          MOV      r6,r0                 ;1525
                  |L1.17444|
004424  e1a00006          MOV      r0,r6                 ;1528
004428  eaffffc6          B        |L1.17224|
;;;1530   
                          ENDP

                  yaffs_find_chunk_cache PROC
;;;1531   /* Find a cached chunk */
;;;1532   static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
00442c  e92d4010          PUSH     {r4,lr}
;;;1533   						  int chunk_id)
;;;1534   {
004430  e1a03000          MOV      r3,r0
004434  e1a0c001          MOV      r12,r1
;;;1535   	struct yaffs_dev *dev = obj->my_dev;
004438  e5931008          LDR      r1,[r3,#8]
;;;1536   	int i;
;;;1537   
;;;1538   	if (dev->param.n_caches < 1)
00443c  e5910020          LDR      r0,[r1,#0x20]
004440  e3500001          CMP      r0,#1
004444  aa000001          BGE      |L1.17488|
;;;1539   		return NULL;
004448  e3a00000          MOV      r0,#0
                  |L1.17484|
;;;1540   
;;;1541   	for (i = 0; i < dev->param.n_caches; i++) {
;;;1542   		if (dev->cache[i].object == obj &&
;;;1543   		    dev->cache[i].chunk_id == chunk_id) {
;;;1544   			dev->cache_hits++;
;;;1545   
;;;1546   			return &dev->cache[i];
;;;1547   		}
;;;1548   	}
;;;1549   	return NULL;
;;;1550   }
00444c  e8bd8010          POP      {r4,pc}
                  |L1.17488|
004450  e3a02000          MOV      r2,#0                 ;1541
004454  ea000012          B        |L1.17572|
                  |L1.17496|
004458  e0624182          RSB      r4,r2,r2,LSL #3       ;1542
00445c  e5910d90          LDR      r0,[r1,#0xd90]        ;1542
004460  e7900104          LDR      r0,[r0,r4,LSL #2]     ;1542
004464  e1500003          CMP      r0,r3                 ;1542
004468  1a00000c          BNE      |L1.17568|
00446c  e0624182          RSB      r4,r2,r2,LSL #3       ;1543
004470  e5910d90          LDR      r0,[r1,#0xd90]        ;1543
004474  e0800104          ADD      r0,r0,r4,LSL #2       ;1543
004478  e5900004          LDR      r0,[r0,#4]            ;1543
00447c  e150000c          CMP      r0,r12                ;1543
004480  1a000006          BNE      |L1.17568|
004484  e5910e5c          LDR      r0,[r1,#0xe5c]        ;1544
004488  e2800001          ADD      r0,r0,#1              ;1544
00448c  e5810e5c          STR      r0,[r1,#0xe5c]        ;1544
004490  e0624182          RSB      r4,r2,r2,LSL #3       ;1546
004494  e5910d90          LDR      r0,[r1,#0xd90]        ;1546
004498  e0800104          ADD      r0,r0,r4,LSL #2       ;1546
00449c  eaffffea          B        |L1.17484|
                  |L1.17568|
0044a0  e2822001          ADD      r2,r2,#1              ;1541
                  |L1.17572|
0044a4  e5910020          LDR      r0,[r1,#0x20]         ;1541
0044a8  e1500002          CMP      r0,r2                 ;1541
0044ac  caffffe9          BGT      |L1.17496|
0044b0  e3a00000          MOV      r0,#0                 ;1549
0044b4  eaffffe4          B        |L1.17484|
;;;1551   
                          ENDP

                  yaffs_use_cache PROC
;;;1552   /* Mark the chunk for the least recently used algorithym */
;;;1553   static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
0044b8  e92d4030          PUSH     {r4,r5,lr}
;;;1554   			    int is_write)
;;;1555   {
0044bc  e1a03001          MOV      r3,r1
;;;1556   	int i;
;;;1557   
;;;1558   	if (dev->param.n_caches < 1)
0044c0  e590c020          LDR      r12,[r0,#0x20]
0044c4  e35c0001          CMP      r12,#1
0044c8  aa000000          BGE      |L1.17616|
                  |L1.17612|
;;;1559   		return;
;;;1560   
;;;1561   	if (dev->cache_last_use < 0 ||
;;;1562   		dev->cache_last_use > 100000000) {
;;;1563   		/* Reset the cache usages */
;;;1564   		for (i = 1; i < dev->param.n_caches; i++)
;;;1565   			dev->cache[i].last_use = 0;
;;;1566   
;;;1567   		dev->cache_last_use = 0;
;;;1568   	}
;;;1569   	dev->cache_last_use++;
;;;1570   	cache->last_use = dev->cache_last_use;
;;;1571   
;;;1572   	if (is_write)
;;;1573   		cache->dirty = 1;
;;;1574   }
0044cc  e8bd8030          POP      {r4,r5,pc}
                  |L1.17616|
0044d0  e590cd94          LDR      r12,[r0,#0xd94]       ;1561
0044d4  e35c0000          CMP      r12,#0                ;1561
0044d8  ba000003          BLT      |L1.17644|
0044dc  e590cd94          LDR      r12,[r0,#0xd94]       ;1562
0044e0  e59f4318          LDR      r4,|L1.18432|
0044e4  e15c0004          CMP      r12,r4                ;1562
0044e8  da00000c          BLE      |L1.17696|
                  |L1.17644|
0044ec  e3a01001          MOV      r1,#1                 ;1564
0044f0  ea000005          B        |L1.17676|
                  |L1.17652|
0044f4  e3a0c000          MOV      r12,#0                ;1565
0044f8  e0615181          RSB      r5,r1,r1,LSL #3       ;1565
0044fc  e5904d90          LDR      r4,[r0,#0xd90]        ;1565
004500  e0844105          ADD      r4,r4,r5,LSL #2       ;1565
004504  e584c008          STR      r12,[r4,#8]           ;1565
004508  e2811001          ADD      r1,r1,#1              ;1564
                  |L1.17676|
00450c  e590c020          LDR      r12,[r0,#0x20]        ;1564
004510  e15c0001          CMP      r12,r1                ;1564
004514  cafffff6          BGT      |L1.17652|
004518  e3a0c000          MOV      r12,#0                ;1567
00451c  e580cd94          STR      r12,[r0,#0xd94]       ;1567
                  |L1.17696|
004520  e590cd94          LDR      r12,[r0,#0xd94]       ;1569
004524  e28cc001          ADD      r12,r12,#1            ;1569
004528  e580cd94          STR      r12,[r0,#0xd94]       ;1569
00452c  e590cd94          LDR      r12,[r0,#0xd94]       ;1570
004530  e583c008          STR      r12,[r3,#8]           ;1570
004534  e3520000          CMP      r2,#0                 ;1572
004538  0a000001          BEQ      |L1.17732|
00453c  e3a0c001          MOV      r12,#1                ;1573
004540  e583c00c          STR      r12,[r3,#0xc]         ;1573
                  |L1.17732|
004544  e1a00000          MOV      r0,r0
004548  eaffffdf          B        |L1.17612|
;;;1575   
                          ENDP

                  yaffs_invalidate_chunk_cache PROC
;;;1579    */
;;;1580   static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
00454c  e92d4070          PUSH     {r4-r6,lr}
;;;1581   {
004550  e1a05000          MOV      r5,r0
004554  e1a06001          MOV      r6,r1
;;;1582   	struct yaffs_cache *cache;
;;;1583   
;;;1584   	if (object->my_dev->param.n_caches > 0) {
004558  e5950008          LDR      r0,[r5,#8]
00455c  e5900020          LDR      r0,[r0,#0x20]
004560  e3500000          CMP      r0,#0
004564  da000007          BLE      |L1.17800|
;;;1585   		cache = yaffs_find_chunk_cache(object, chunk_id);
004568  e1a01006          MOV      r1,r6
00456c  e1a00005          MOV      r0,r5
004570  ebfffffe          BL       yaffs_find_chunk_cache
004574  e1a04000          MOV      r4,r0
;;;1586   
;;;1587   		if (cache)
004578  e3540000          CMP      r4,#0
00457c  0a000001          BEQ      |L1.17800|
;;;1588   			cache->object = NULL;
004580  e3a00000          MOV      r0,#0
004584  e5840000          STR      r0,[r4,#0]
                  |L1.17800|
;;;1589   	}
;;;1590   }
004588  e8bd8070          POP      {r4-r6,pc}
;;;1591   
                          ENDP

                  yaffs_handle_defered_free PROC
;;;1653   
;;;1654   void yaffs_handle_defered_free(struct yaffs_obj *obj)
00458c  e92d4010          PUSH     {r4,lr}
;;;1655   {
004590  e1a04000          MOV      r4,r0
;;;1656   	if (obj->defered_free)
004594  e5d40001          LDRB     r0,[r4,#1]
004598  e1a00f00          LSL      r0,r0,#30
00459c  e1b00fa0          LSRS     r0,r0,#31
0045a0  0a000001          BEQ      |L1.17836|
;;;1657   		yaffs_free_obj(obj);
0045a4  e1a00004          MOV      r0,r4
0045a8  ebfffffe          BL       yaffs_free_obj
                  |L1.17836|
;;;1658   }
0045ac  e8bd8010          POP      {r4,pc}
;;;1659   
                          ENDP

                  yaffs_soft_del_file PROC
;;;1679   
;;;1680   static void yaffs_soft_del_file(struct yaffs_obj *obj)
0045b0  e92d4010          PUSH     {r4,lr}
;;;1681   {
0045b4  e1a04000          MOV      r4,r0
;;;1682   	if (!obj->deleted ||
0045b8  e5d40000          LDRB     r0,[r4,#0]
0045bc  e3100001          TST      r0,#1
0045c0  0a000006          BEQ      |L1.17888|
;;;1683   	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
0045c4  e5d40064          LDRB     r0,[r4,#0x64]
0045c8  e3500001          CMP      r0,#1
0045cc  1a000003          BNE      |L1.17888|
;;;1684   	    obj->soft_del)
0045d0  e5d40000          LDRB     r0,[r4,#0]
0045d4  e1a00f00          LSL      r0,r0,#30
0045d8  e1b00fa0          LSRS     r0,r0,#31
0045dc  0a000000          BEQ      |L1.17892|
                  |L1.17888|
;;;1685   		return;
;;;1686   
;;;1687   	if (obj->n_data_chunks <= 0) {
;;;1688   		/* Empty file with no duplicate object headers,
;;;1689   		 * just delete it immediately */
;;;1690   		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
;;;1691   		obj->variant.file_variant.top = NULL;
;;;1692   		yaffs_trace(YAFFS_TRACE_TRACING,
;;;1693   			"yaffs: Deleting empty file %d",
;;;1694   			obj->obj_id);
;;;1695   		yaffs_generic_obj_del(obj);
;;;1696   	} else {
;;;1697   		yaffs_soft_del_worker(obj,
;;;1698   				      obj->variant.file_variant.top,
;;;1699   				      obj->variant.
;;;1700   				      file_variant.top_level, 0);
;;;1701   		obj->soft_del = 1;
;;;1702   	}
;;;1703   }
0045e0  e8bd8010          POP      {r4,pc}
                  |L1.17892|
0045e4  e594002c          LDR      r0,[r4,#0x2c]         ;1687
0045e8  e3500000          CMP      r0,#0                 ;1687
0045ec  ca00000e          BGT      |L1.17964|
0045f0  e5940008          LDR      r0,[r4,#8]            ;1690
0045f4  e5941084          LDR      r1,[r4,#0x84]         ;1690
0045f8  ebfffffe          BL       yaffs_free_tnode
0045fc  e3a00000          MOV      r0,#0                 ;1691
004600  e5840084          STR      r0,[r4,#0x84]         ;1691
004604  e51f086c          LDR      r0,|L1.15776|
004608  e1d000b0          LDRH     r0,[r0,#0]            ;1692  ; yaffs_trace_mask
00460c  e3100c01          TST      r0,#0x100             ;1692
004610  0a000002          BEQ      |L1.17952|
004614  e28f0f7a          ADR      r0,|L1.18436|
004618  e5941030          LDR      r1,[r4,#0x30]         ;1692
00461c  ebfffffe          BL       sysprintf
                  |L1.17952|
004620  e1a00004          MOV      r0,r4                 ;1695
004624  ebfffffe          BL       yaffs_generic_obj_del
004628  ea000007          B        |L1.17996|
                  |L1.17964|
00462c  e3a03000          MOV      r3,#0                 ;1697
004630  e5941084          LDR      r1,[r4,#0x84]         ;1697
004634  e5942080          LDR      r2,[r4,#0x80]         ;1697
004638  e1a00004          MOV      r0,r4                 ;1697
00463c  ebfffffe          BL       yaffs_soft_del_worker
004640  e5d40000          LDRB     r0,[r4,#0]            ;1701
004644  e3800002          ORR      r0,r0,#2              ;1701
004648  e5c40000          STRB     r0,[r4,#0]            ;1701
                  |L1.17996|
00464c  e1a00000          MOV      r0,r0
004650  eaffffe2          B        |L1.17888|
;;;1704   
                          ENDP

                  yaffs_prune_worker PROC
;;;1719   
;;;1720   static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
004654  e92d47f0          PUSH     {r4-r10,lr}
;;;1721   					      struct yaffs_tnode *tn, u32 level,
;;;1722   					      int del0)
;;;1723   {
004658  e1a08000          MOV      r8,r0
00465c  e1a05001          MOV      r5,r1
004660  e1a07002          MOV      r7,r2
004664  e1a09003          MOV      r9,r3
;;;1724   	int i;
;;;1725   	int has_data;
;;;1726   
;;;1727   	if (!tn)
004668  e3550000          CMP      r5,#0
00466c  1a000001          BNE      |L1.18040|
;;;1728   		return tn;
004670  e1a00005          MOV      r0,r5
                  |L1.18036|
;;;1729   
;;;1730   	has_data = 0;
;;;1731   
;;;1732   	if (level > 0) {
;;;1733   		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
;;;1734   			if (tn->internal[i]) {
;;;1735   				tn->internal[i] =
;;;1736   				    yaffs_prune_worker(dev,
;;;1737   						tn->internal[i],
;;;1738   						level - 1,
;;;1739   						(i == 0) ? del0 : 1);
;;;1740   			}
;;;1741   
;;;1742   			if (tn->internal[i])
;;;1743   				has_data++;
;;;1744   		}
;;;1745   	} else {
;;;1746   		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
;;;1747   		u32 *map = (u32 *) tn;
;;;1748   
;;;1749   		for (i = 0; !has_data && i < tnode_size_u32; i++) {
;;;1750   			if (map[i])
;;;1751   				has_data++;
;;;1752   		}
;;;1753   	}
;;;1754   
;;;1755   	if (has_data == 0 && del0) {
;;;1756   		/* Free and return NULL */
;;;1757   		yaffs_free_tnode(dev, tn);
;;;1758   		tn = NULL;
;;;1759   	}
;;;1760   	return tn;
;;;1761   }
004674  e8bd87f0          POP      {r4-r10,pc}
                  |L1.18040|
004678  e3a06000          MOV      r6,#0                 ;1730
00467c  e3570000          CMP      r7,#0                 ;1732
004680  0a000017          BEQ      |L1.18148|
004684  e3a04000          MOV      r4,#0                 ;1733
004688  ea000012          B        |L1.18136|
                  |L1.18060|
00468c  e7950104          LDR      r0,[r5,r4,LSL #2]     ;1734
004690  e3500000          CMP      r0,#0                 ;1734
004694  0a00000a          BEQ      |L1.18116|
004698  e3540000          CMP      r4,#0                 ;1735
00469c  1a000001          BNE      |L1.18088|
0046a0  e1a00009          MOV      r0,r9                 ;1739
0046a4  ea000000          B        |L1.18092|
                  |L1.18088|
0046a8  e3a00001          MOV      r0,#1                 ;1739
                  |L1.18092|
0046ac  e1a03000          MOV      r3,r0                 ;1739
0046b0  e2472001          SUB      r2,r7,#1              ;1739
0046b4  e7951104          LDR      r1,[r5,r4,LSL #2]     ;1739
0046b8  e1a00008          MOV      r0,r8                 ;1739
0046bc  ebfffffe          BL       yaffs_prune_worker
0046c0  e7850104          STR      r0,[r5,r4,LSL #2]     ;1739
                  |L1.18116|
0046c4  e7950104          LDR      r0,[r5,r4,LSL #2]     ;1742
0046c8  e3500000          CMP      r0,#0                 ;1742
0046cc  0a000000          BEQ      |L1.18132|
0046d0  e2866001          ADD      r6,r6,#1              ;1743
                  |L1.18132|
0046d4  e2844001          ADD      r4,r4,#1              ;1733
                  |L1.18136|
0046d8  e3540008          CMP      r4,#8                 ;1733
0046dc  baffffea          BLT      |L1.18060|
0046e0  ea00000e          B        |L1.18208|
                  |L1.18148|
0046e4  e59820b4          LDR      r2,[r8,#0xb4]         ;1746
0046e8  e1a00122          LSR      r0,r2,#2              ;1746
0046ec  e1a01005          MOV      r1,r5                 ;1747
0046f0  e3a04000          MOV      r4,#0                 ;1749
0046f4  ea000004          B        |L1.18188|
                  |L1.18168|
0046f8  e7912104          LDR      r2,[r1,r4,LSL #2]     ;1750
0046fc  e3520000          CMP      r2,#0                 ;1750
004700  0a000000          BEQ      |L1.18184|
004704  e2866001          ADD      r6,r6,#1              ;1751
                  |L1.18184|
004708  e2844001          ADD      r4,r4,#1              ;1749
                  |L1.18188|
00470c  e3560000          CMP      r6,#0                 ;1749
004710  1a000001          BNE      |L1.18204|
004714  e1540000          CMP      r4,r0                 ;1749
004718  bafffff6          BLT      |L1.18168|
                  |L1.18204|
00471c  e1a00000          MOV      r0,r0                 ;1753
                  |L1.18208|
004720  e3560000          CMP      r6,#0                 ;1755
004724  1a000005          BNE      |L1.18240|
004728  e3590000          CMP      r9,#0                 ;1755
00472c  0a000003          BEQ      |L1.18240|
004730  e1a01005          MOV      r1,r5                 ;1757
004734  e1a00008          MOV      r0,r8                 ;1757
004738  ebfffffe          BL       yaffs_free_tnode
00473c  e3a05000          MOV      r5,#0                 ;1758
                  |L1.18240|
004740  e1a00005          MOV      r0,r5                 ;1760
004744  eaffffca          B        |L1.18036|
;;;1762   
                          ENDP

                  yaffs_prune_tree PROC
;;;1763   static int yaffs_prune_tree(struct yaffs_dev *dev,
004748  e92d47f0          PUSH     {r4-r10,lr}
;;;1764   			    struct yaffs_file_var *file_struct)
;;;1765   {
00474c  e1a08000          MOV      r8,r0
004750  e1a04001          MOV      r4,r1
;;;1766   	int i;
;;;1767   	int has_data;
;;;1768   	int done = 0;
004754  e3a09000          MOV      r9,#0
;;;1769   	struct yaffs_tnode *tn;
;;;1770   
;;;1771   	if (file_struct->top_level < 1)
004758  e5940018          LDR      r0,[r4,#0x18]
00475c  e3500001          CMP      r0,#1
004760  aa000001          BGE      |L1.18284|
;;;1772   		return YAFFS_OK;
004764  e3a00001          MOV      r0,#1
                  |L1.18280|
;;;1773   
;;;1774   	file_struct->top =
;;;1775   	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
;;;1776   
;;;1777   	/* Now we have a tree with all the non-zero branches NULL but
;;;1778   	 * the height is the same as it was.
;;;1779   	 * Let's see if we can trim internal tnodes to shorten the tree.
;;;1780   	 * We can do this if only the 0th element in the tnode is in use
;;;1781   	 * (ie all the non-zero are NULL)
;;;1782   	 */
;;;1783   
;;;1784   	while (file_struct->top_level && !done) {
;;;1785   		tn = file_struct->top;
;;;1786   
;;;1787   		has_data = 0;
;;;1788   		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
;;;1789   			if (tn->internal[i])
;;;1790   				has_data++;
;;;1791   		}
;;;1792   
;;;1793   		if (!has_data) {
;;;1794   			file_struct->top = tn->internal[0];
;;;1795   			file_struct->top_level--;
;;;1796   			yaffs_free_tnode(dev, tn);
;;;1797   		} else {
;;;1798   			done = 1;
;;;1799   		}
;;;1800   	}
;;;1801   
;;;1802   	return YAFFS_OK;
;;;1803   }
004768  e8bd87f0          POP      {r4-r10,pc}
                  |L1.18284|
00476c  e3a03000          MOV      r3,#0                 ;1774
004770  e1a00008          MOV      r0,r8                 ;1774
004774  e594101c          LDR      r1,[r4,#0x1c]         ;1774
004778  e5942018          LDR      r2,[r4,#0x18]         ;1774
00477c  ebfffffe          BL       yaffs_prune_worker
004780  e584001c          STR      r0,[r4,#0x1c]         ;1774
004784  ea000016          B        |L1.18404|
                  |L1.18312|
004788  e594501c          LDR      r5,[r4,#0x1c]         ;1785
00478c  e3a07000          MOV      r7,#0                 ;1787
004790  e3a06001          MOV      r6,#1                 ;1788
004794  ea000004          B        |L1.18348|
                  |L1.18328|
004798  e7950106          LDR      r0,[r5,r6,LSL #2]     ;1789
00479c  e3500000          CMP      r0,#0                 ;1789
0047a0  0a000000          BEQ      |L1.18344|
0047a4  e2877001          ADD      r7,r7,#1              ;1790
                  |L1.18344|
0047a8  e2866001          ADD      r6,r6,#1              ;1788
                  |L1.18348|
0047ac  e3560008          CMP      r6,#8                 ;1788
0047b0  bafffff8          BLT      |L1.18328|
0047b4  e3570000          CMP      r7,#0                 ;1793
0047b8  1a000008          BNE      |L1.18400|
0047bc  e5950000          LDR      r0,[r5,#0]            ;1794
0047c0  e584001c          STR      r0,[r4,#0x1c]         ;1794
0047c4  e5940018          LDR      r0,[r4,#0x18]         ;1795
0047c8  e2400001          SUB      r0,r0,#1              ;1795
0047cc  e5840018          STR      r0,[r4,#0x18]         ;1795
0047d0  e1a01005          MOV      r1,r5                 ;1796
0047d4  e1a00008          MOV      r0,r8                 ;1796
0047d8  ebfffffe          BL       yaffs_free_tnode
0047dc  ea000000          B        |L1.18404|
                  |L1.18400|
0047e0  e3a09001          MOV      r9,#1                 ;1798
                  |L1.18404|
0047e4  e5940018          LDR      r0,[r4,#0x18]         ;1784
0047e8  e3500000          CMP      r0,#0                 ;1784
0047ec  0a000001          BEQ      |L1.18424|
0047f0  e3590000          CMP      r9,#0                 ;1784
0047f4  0affffe3          BEQ      |L1.18312|
                  |L1.18424|
0047f8  e3a00001          MOV      r0,#1                 ;1802
0047fc  eaffffd9          B        |L1.18280|
                  |L1.18432|
                          DCD      0x05f5e100
                  |L1.18436|
004804  79616666          DCB      "yaffs: yaffs: Deleting empty file %d\n",0
004808  733a2079
00480c  61666673
004810  3a204465
004814  6c657469
004818  6e672065
00481c  6d707479
004820  2066696c
004824  65202564
004828  0a00    
00482a  00                DCB      0
00482b  00                DCB      0
                          ENDP

                  yaffs_alloc_empty_obj PROC
;;;1807   /* alloc_empty_obj gets us a clean Object.*/
;;;1808   static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
00482c  e92d4070          PUSH     {r4-r6,lr}
;;;1809   {
004830  e1a05000          MOV      r5,r0
;;;1810   	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
004834  e1a00005          MOV      r0,r5
004838  ebfffffe          BL       yaffs_alloc_raw_obj
00483c  e1a04000          MOV      r4,r0
;;;1811   
;;;1812   	if (!obj)
004840  e3540000          CMP      r4,#0
004844  1a000001          BNE      |L1.18512|
;;;1813   		return obj;
004848  e1a00004          MOV      r0,r4
                  |L1.18508|
;;;1814   
;;;1815   	dev->n_obj++;
;;;1816   
;;;1817   	/* Now sweeten it up... */
;;;1818   
;;;1819   	memset(obj, 0, sizeof(struct yaffs_obj));
;;;1820   	obj->being_created = 1;
;;;1821   
;;;1822   	obj->my_dev = dev;
;;;1823   	obj->hdr_chunk = 0;
;;;1824   	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
;;;1825   	INIT_LIST_HEAD(&(obj->hard_links));
;;;1826   	INIT_LIST_HEAD(&(obj->hash_link));
;;;1827   	INIT_LIST_HEAD(&obj->siblings);
;;;1828   
;;;1829   	/* Now make the directory sane */
;;;1830   	if (dev->root_dir) {
;;;1831   		obj->parent = dev->root_dir;
;;;1832   		list_add(&(obj->siblings),
;;;1833   			 &dev->root_dir->variant.dir_variant.children);
;;;1834   	}
;;;1835   
;;;1836   	/* Add it to the lost and found directory.
;;;1837   	 * NB Can't put root or lost-n-found in lost-n-found so
;;;1838   	 * check if lost-n-found exists first
;;;1839   	 */
;;;1840   	if (dev->lost_n_found)
;;;1841   		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
;;;1842   
;;;1843   	obj->being_created = 0;
;;;1844   
;;;1845   	dev->checkpoint_blocks_required = 0;	/* force recalculation */
;;;1846   
;;;1847   	return obj;
;;;1848   }
00484c  e8bd8070          POP      {r4-r6,pc}
                  |L1.18512|
004850  e595013c          LDR      r0,[r5,#0x13c]        ;1815
004854  e2800001          ADD      r0,r0,#1              ;1815
004858  e585013c          STR      r0,[r5,#0x13c]        ;1815
00485c  e3a01088          MOV      r1,#0x88              ;1819
004860  e1a00004          MOV      r0,r4                 ;1819
004864  ebfffffe          BL       __aeabi_memclr4
004868  e5d40001          LDRB     r0,[r4,#1]            ;1820
00486c  e3800004          ORR      r0,r0,#4              ;1820
004870  e5c40001          STRB     r0,[r4,#1]            ;1820
004874  e5845008          STR      r5,[r4,#8]            ;1822
004878  e3a00000          MOV      r0,#0                 ;1823
00487c  e5840028          STR      r0,[r4,#0x28]         ;1823
004880  e5c40064          STRB     r0,[r4,#0x64]         ;1824
004884  e1a00000          MOV      r0,r0                 ;1825
004888  e2840014          ADD      r0,r4,#0x14           ;1825
00488c  e5840014          STR      r0,[r4,#0x14]         ;1825
004890  e2840014          ADD      r0,r4,#0x14           ;1825
004894  e5840018          STR      r0,[r4,#0x18]         ;1825
004898  e1a00000          MOV      r0,r0                 ;1825
00489c  e1a00000          MOV      r0,r0                 ;1826
0048a0  e284000c          ADD      r0,r4,#0xc            ;1826
0048a4  e584000c          STR      r0,[r4,#0xc]          ;1826
0048a8  e284000c          ADD      r0,r4,#0xc            ;1826
0048ac  e5840010          STR      r0,[r4,#0x10]         ;1826
0048b0  e1a00000          MOV      r0,r0                 ;1826
0048b4  e1a00000          MOV      r0,r0                 ;1827
0048b8  e2840020          ADD      r0,r4,#0x20           ;1827
0048bc  e5840020          STR      r0,[r4,#0x20]         ;1827
0048c0  e2840020          ADD      r0,r4,#0x20           ;1827
0048c4  e5840024          STR      r0,[r4,#0x24]         ;1827
0048c8  e1a00000          MOV      r0,r0                 ;1827
0048cc  e5950d80          LDR      r0,[r5,#0xd80]        ;1830
0048d0  e3500000          CMP      r0,#0                 ;1830
0048d4  0a000005          BEQ      |L1.18672|
0048d8  e5950d80          LDR      r0,[r5,#0xd80]        ;1831
0048dc  e584001c          STR      r0,[r4,#0x1c]         ;1831
0048e0  e5950d80          LDR      r0,[r5,#0xd80]        ;1832
0048e4  e2801068          ADD      r1,r0,#0x68           ;1832
0048e8  e2840020          ADD      r0,r4,#0x20           ;1832
0048ec  ebfffffe          BL       list_add
                  |L1.18672|
0048f0  e5950d84          LDR      r0,[r5,#0xd84]        ;1840
0048f4  e3500000          CMP      r0,#0                 ;1840
0048f8  0a000002          BEQ      |L1.18696|
0048fc  e1a01004          MOV      r1,r4                 ;1841
004900  e5950d84          LDR      r0,[r5,#0xd84]        ;1841
004904  ebfffffe          BL       yaffs_add_obj_to_dir
                  |L1.18696|
004908  e5d40001          LDRB     r0,[r4,#1]            ;1843
00490c  e3c00004          BIC      r0,r0,#4              ;1843
004910  e5c40001          STRB     r0,[r4,#1]            ;1843
004914  e3a00000          MOV      r0,#0                 ;1845
004918  e5850114          STR      r0,[r5,#0x114]        ;1845
00491c  e1a00004          MOV      r0,r4                 ;1847
004920  eaffffc9          B        |L1.18508|
;;;1849   
                          ENDP

                  yaffs_find_nice_bucket PROC
;;;1850   static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
004924  e92d4010          PUSH     {r4,lr}
;;;1851   {
004928  e1a01000          MOV      r1,r0
;;;1852   	int i;
;;;1853   	int l = 999;
00492c  e59f066c          LDR      r0,|L1.20384|
;;;1854   	int lowest = 999999;
004930  e59f366c          LDR      r3,|L1.20388|
;;;1855   
;;;1856   	/* Search for the shortest list or one that
;;;1857   	 * isn't too long.
;;;1858   	 */
;;;1859   
;;;1860   	for (i = 0; i < 10 && lowest > 4; i++) {
004934  e3a02000          MOV      r2,#0
004938  ea000012          B        |L1.18824|
                  |L1.18748|
;;;1861   		dev->bucket_finder++;
00493c  e591cd48          LDR      r12,[r1,#0xd48]
004940  e28cc001          ADD      r12,r12,#1
004944  e581cd48          STR      r12,[r1,#0xd48]
;;;1862   		dev->bucket_finder %= YAFFS_NOBJECT_BUCKETS;
004948  e5d1cd48          LDRB     r12,[r1,#0xd48]
00494c  e581cd48          STR      r12,[r1,#0xd48]
;;;1863   		if (dev->obj_bucket[dev->bucket_finder].count < lowest) {
004950  e591cd48          LDR      r12,[r1,#0xd48]
004954  e08cc08c          ADD      r12,r12,r12,LSL #1
004958  e2814f52          ADD      r4,r1,#0x148
00495c  e084c10c          ADD      r12,r4,r12,LSL #2
004960  e59cc008          LDR      r12,[r12,#8]
004964  e15c0003          CMP      r12,r3
004968  aa000005          BGE      |L1.18820|
;;;1864   			lowest = dev->obj_bucket[dev->bucket_finder].count;
00496c  e591cd48          LDR      r12,[r1,#0xd48]
004970  e08cc08c          ADD      r12,r12,r12,LSL #1
004974  e2814f52          ADD      r4,r1,#0x148
004978  e084c10c          ADD      r12,r4,r12,LSL #2
00497c  e59c3008          LDR      r3,[r12,#8]
;;;1865   			l = dev->bucket_finder;
004980  e5910d48          LDR      r0,[r1,#0xd48]
                  |L1.18820|
004984  e2822001          ADD      r2,r2,#1              ;1860
                  |L1.18824|
004988  e352000a          CMP      r2,#0xa               ;1860
00498c  aa000001          BGE      |L1.18840|
004990  e3530004          CMP      r3,#4                 ;1860
004994  caffffe8          BGT      |L1.18748|
                  |L1.18840|
;;;1866   		}
;;;1867   	}
;;;1868   
;;;1869   	return l;
;;;1870   }
004998  e8bd8010          POP      {r4,pc}
;;;1871   
                          ENDP

                  yaffs_new_obj_id PROC
;;;1872   static int yaffs_new_obj_id(struct yaffs_dev *dev)
00499c  e92d41f0          PUSH     {r4-r8,lr}
;;;1873   {
0049a0  e1a05000          MOV      r5,r0
;;;1874   	int bucket = yaffs_find_nice_bucket(dev);
0049a4  e1a00005          MOV      r0,r5
0049a8  ebfffffe          BL       yaffs_find_nice_bucket
0049ac  e1a06000          MOV      r6,r0
;;;1875   	int found = 0;
0049b0  e3a08000          MOV      r8,#0
;;;1876   	struct list_head *i;
;;;1877   	u32 n = (u32) bucket;
0049b4  e1a07006          MOV      r7,r6
;;;1878   
;;;1879   	/* Now find an object value that has not already been taken
;;;1880   	 * by scanning the list.
;;;1881   	 */
;;;1882   
;;;1883   	while (!found) {
0049b8  ea000011          B        |L1.18948|
                  |L1.18876|
;;;1884   		found = 1;
0049bc  e3a08001          MOV      r8,#1
;;;1885   		n += YAFFS_NOBJECT_BUCKETS;
0049c0  e2877c01          ADD      r7,r7,#0x100
;;;1886   		if (1 || dev->obj_bucket[bucket].count > 0) {
;;;1887   			list_for_each(i, &dev->obj_bucket[bucket].list) {
0049c4  e0860086          ADD      r0,r6,r6,LSL #1
0049c8  e2851f52          ADD      r1,r5,#0x148
0049cc  e7914100          LDR      r4,[r1,r0,LSL #2]
0049d0  ea000006          B        |L1.18928|
                  |L1.18900|
;;;1888   				/* If there is already one in the list */
;;;1889   				if (i && list_entry(i, struct yaffs_obj,
0049d4  e3540000          CMP      r4,#0
0049d8  0a000003          BEQ      |L1.18924|
0049dc  e5940024          LDR      r0,[r4,#0x24]
0049e0  e1500007          CMP      r0,r7
0049e4  1a000000          BNE      |L1.18924|
;;;1890   						    hash_link)->obj_id == n) {
;;;1891   					found = 0;
0049e8  e3a08000          MOV      r8,#0
                  |L1.18924|
0049ec  e5944000          LDR      r4,[r4,#0]            ;1887
                  |L1.18928|
0049f0  e0860086          ADD      r0,r6,r6,LSL #1       ;1887
0049f4  e2851f52          ADD      r1,r5,#0x148          ;1887
0049f8  e0810100          ADD      r0,r1,r0,LSL #2       ;1887
0049fc  e1500004          CMP      r0,r4                 ;1887
004a00  1afffff3          BNE      |L1.18900|
                  |L1.18948|
004a04  e3580000          CMP      r8,#0                 ;1883
004a08  0affffeb          BEQ      |L1.18876|
;;;1892   				}
;;;1893   			}
;;;1894   		}
;;;1895   	}
;;;1896   	return n;
004a0c  e1a00007          MOV      r0,r7
;;;1897   }
004a10  e8bd81f0          POP      {r4-r8,pc}
;;;1898   
                          ENDP

                  yaffs_hash_obj PROC
;;;1899   static void yaffs_hash_obj(struct yaffs_obj *in)
004a14  e92d4070          PUSH     {r4-r6,lr}
;;;1900   {
004a18  e1a04000          MOV      r4,r0
;;;1901   	int bucket = yaffs_hash_fn(in->obj_id);
004a1c  e5940030          LDR      r0,[r4,#0x30]
004a20  ebfffffe          BL       yaffs_hash_fn
004a24  e1a05000          MOV      r5,r0
;;;1902   	struct yaffs_dev *dev = in->my_dev;
004a28  e5946008          LDR      r6,[r4,#8]
;;;1903   
;;;1904   	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
004a2c  e0850085          ADD      r0,r5,r5,LSL #1
004a30  e2862f52          ADD      r2,r6,#0x148
004a34  e0821100          ADD      r1,r2,r0,LSL #2
004a38  e284000c          ADD      r0,r4,#0xc
004a3c  ebfffffe          BL       list_add
;;;1905   	dev->obj_bucket[bucket].count++;
004a40  e0850085          ADD      r0,r5,r5,LSL #1
004a44  e2861f52          ADD      r1,r6,#0x148
004a48  e0810100          ADD      r0,r1,r0,LSL #2
004a4c  e5900008          LDR      r0,[r0,#8]
004a50  e2800001          ADD      r0,r0,#1
004a54  e0851085          ADD      r1,r5,r5,LSL #1
004a58  e2862f52          ADD      r2,r6,#0x148
004a5c  e0821101          ADD      r1,r2,r1,LSL #2
004a60  e5810008          STR      r0,[r1,#8]
;;;1906   }
004a64  e8bd8070          POP      {r4-r6,pc}
;;;1907   
                          ENDP

                  yaffs_new_obj PROC
;;;1927   
;;;1928   struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
004a68  e92d41f0          PUSH     {r4-r8,lr}
;;;1929   				enum yaffs_obj_type type)
;;;1930   {
004a6c  e1a08000          MOV      r8,r0
004a70  e1a07001          MOV      r7,r1
004a74  e1a05002          MOV      r5,r2
;;;1931   	struct yaffs_obj *the_obj = NULL;
004a78  e3a04000          MOV      r4,#0
;;;1932   	struct yaffs_tnode *tn = NULL;
004a7c  e3a06000          MOV      r6,#0
;;;1933   
;;;1934   	if (number < 0)
004a80  e3570000          CMP      r7,#0
004a84  aa000002          BGE      |L1.19092|
;;;1935   		number = yaffs_new_obj_id(dev);
004a88  e1a00008          MOV      r0,r8
004a8c  ebfffffe          BL       yaffs_new_obj_id
004a90  e1a07000          MOV      r7,r0
                  |L1.19092|
;;;1936   
;;;1937   	if (type == YAFFS_OBJECT_TYPE_FILE) {
004a94  e3550001          CMP      r5,#1
004a98  1a000006          BNE      |L1.19128|
;;;1938   		tn = yaffs_get_tnode(dev);
004a9c  e1a00008          MOV      r0,r8
004aa0  ebfffffe          BL       yaffs_get_tnode
004aa4  e1a06000          MOV      r6,r0
;;;1939   		if (!tn)
004aa8  e3560000          CMP      r6,#0
004aac  1a000001          BNE      |L1.19128|
;;;1940   			return NULL;
004ab0  e3a00000          MOV      r0,#0
                  |L1.19124|
;;;1941   	}
;;;1942   
;;;1943   	the_obj = yaffs_alloc_empty_obj(dev);
;;;1944   	if (!the_obj) {
;;;1945   		if (tn)
;;;1946   			yaffs_free_tnode(dev, tn);
;;;1947   		return NULL;
;;;1948   	}
;;;1949   
;;;1950   	the_obj->fake = 0;
;;;1951   	the_obj->rename_allowed = 1;
;;;1952   	the_obj->unlink_allowed = 1;
;;;1953   	the_obj->obj_id = number;
;;;1954   	yaffs_hash_obj(the_obj);
;;;1955   	the_obj->variant_type = type;
;;;1956   	yaffs_load_current_time(the_obj, 1, 1);
;;;1957   
;;;1958   	switch (type) {
;;;1959   	case YAFFS_OBJECT_TYPE_FILE:
;;;1960   		the_obj->variant.file_variant.file_size = 0;
;;;1961   		the_obj->variant.file_variant.scanned_size = 0;
;;;1962   		the_obj->variant.file_variant.shrink_size =
;;;1963   						yaffs_max_file_size(dev);
;;;1964   		the_obj->variant.file_variant.top_level = 0;
;;;1965   		the_obj->variant.file_variant.top = tn;
;;;1966   		break;
;;;1967   	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;1968   		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
;;;1969   		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
;;;1970   		break;
;;;1971   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;1972   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;1973   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;1974   		/* No action required */
;;;1975   		break;
;;;1976   	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;1977   		/* todo this should not happen */
;;;1978   		break;
;;;1979   	}
;;;1980   	return the_obj;
;;;1981   }
004ab4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.19128|
004ab8  e1a00008          MOV      r0,r8                 ;1943
004abc  ebfffffe          BL       yaffs_alloc_empty_obj
004ac0  e1a04000          MOV      r4,r0                 ;1943
004ac4  e3540000          CMP      r4,#0                 ;1944
004ac8  1a000006          BNE      |L1.19176|
004acc  e3560000          CMP      r6,#0                 ;1945
004ad0  0a000002          BEQ      |L1.19168|
004ad4  e1a01006          MOV      r1,r6                 ;1946
004ad8  e1a00008          MOV      r0,r8                 ;1946
004adc  ebfffffe          BL       yaffs_free_tnode
                  |L1.19168|
004ae0  e3a00000          MOV      r0,#0                 ;1947
004ae4  eafffff2          B        |L1.19124|
                  |L1.19176|
004ae8  e5d40000          LDRB     r0,[r4,#0]            ;1950
004aec  e3c00008          BIC      r0,r0,#8              ;1950
004af0  e5c40000          STRB     r0,[r4,#0]            ;1950
004af4  e5d40000          LDRB     r0,[r4,#0]            ;1951
004af8  e3800010          ORR      r0,r0,#0x10           ;1951
004afc  e5c40000          STRB     r0,[r4,#0]            ;1951
004b00  e5d40000          LDRB     r0,[r4,#0]            ;1952
004b04  e3800020          ORR      r0,r0,#0x20           ;1952
004b08  e5c40000          STRB     r0,[r4,#0]            ;1952
004b0c  e5847030          STR      r7,[r4,#0x30]         ;1953
004b10  e1a00004          MOV      r0,r4                 ;1954
004b14  ebfffffe          BL       yaffs_hash_obj
004b18  e5c45064          STRB     r5,[r4,#0x64]         ;1955
004b1c  e3a02001          MOV      r2,#1                 ;1956
004b20  e1a01002          MOV      r1,r2                 ;1956
004b24  e1a00004          MOV      r0,r4                 ;1956
004b28  ebfffffe          BL       yaffs_load_current_time
004b2c  e3550006          CMP      r5,#6                 ;1958
004b30  308ff105          ADDCC    pc,pc,r5,LSL #2       ;1958
004b34  ea000026          B        |L1.19412|
004b38  ea000023          B        |L1.19404|
004b3c  ea000003          B        |L1.19280|
004b40  ea00001d          B        |L1.19388|
004b44  ea00000e          B        |L1.19332|
004b48  ea00001d          B        |L1.19396|
004b4c  ea00001d          B        |L1.19400|
                  |L1.19280|
004b50  e1a00000          MOV      r0,r0                 ;1959
004b54  e3a01000          MOV      r1,#0                 ;1959
004b58  e5841068          STR      r1,[r4,#0x68]         ;1960
004b5c  e584106c          STR      r1,[r4,#0x6c]         ;1960
004b60  e5841070          STR      r1,[r4,#0x70]         ;1961
004b64  e5841074          STR      r1,[r4,#0x74]         ;1961
004b68  e1a00008          MOV      r0,r8                 ;1962
004b6c  ebfffffe          BL       yaffs_max_file_size
004b70  e1c407f8          STRD     r0,r1,[r4,#0x78]      ;1962
004b74  e3a00000          MOV      r0,#0                 ;1964
004b78  e5840080          STR      r0,[r4,#0x80]         ;1964
004b7c  e5846084          STR      r6,[r4,#0x84]         ;1965
004b80  ea000013          B        |L1.19412|
                  |L1.19332|
004b84  e1a00000          MOV      r0,r0                 ;1967
004b88  e1a00000          MOV      r0,r0                 ;1968
004b8c  e2840068          ADD      r0,r4,#0x68           ;1968
004b90  e5840068          STR      r0,[r4,#0x68]         ;1968
004b94  e2840068          ADD      r0,r4,#0x68           ;1968
004b98  e584006c          STR      r0,[r4,#0x6c]         ;1968
004b9c  e1a00000          MOV      r0,r0                 ;1968
004ba0  e1a00000          MOV      r0,r0                 ;1969
004ba4  e2840070          ADD      r0,r4,#0x70           ;1969
004ba8  e5840070          STR      r0,[r4,#0x70]         ;1969
004bac  e2840070          ADD      r0,r4,#0x70           ;1969
004bb0  e5840074          STR      r0,[r4,#0x74]         ;1969
004bb4  e1a00000          MOV      r0,r0                 ;1969
004bb8  ea000005          B        |L1.19412|
                  |L1.19388|
004bbc  e1a00000          MOV      r0,r0                 ;1971
004bc0  e1a00000          MOV      r0,r0                 ;1972
                  |L1.19396|
004bc4  e1a00000          MOV      r0,r0                 ;1973
                  |L1.19400|
004bc8  ea000001          B        |L1.19412|
                  |L1.19404|
004bcc  e1a00000          MOV      r0,r0                 ;1976
004bd0  e1a00000          MOV      r0,r0                 ;1978
                  |L1.19412|
004bd4  e1a00000          MOV      r0,r0                 ;1966
004bd8  e1a00004          MOV      r0,r4                 ;1980
004bdc  eaffffb4          B        |L1.19124|
;;;1982   
                          ENDP

                  yaffs_create_fake_dir PROC
;;;1983   static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
004be0  e92d41f0          PUSH     {r4-r8,lr}
;;;1984   					       int number, u32 mode)
;;;1985   {
004be4  e1a05000          MOV      r5,r0
004be8  e1a07001          MOV      r7,r1
004bec  e1a06002          MOV      r6,r2
;;;1986   
;;;1987   	struct yaffs_obj *obj =
004bf0  e3a02003          MOV      r2,#3
004bf4  e1a01007          MOV      r1,r7
004bf8  e1a00005          MOV      r0,r5
004bfc  ebfffffe          BL       yaffs_new_obj
004c00  e1a04000          MOV      r4,r0
;;;1988   	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
;;;1989   
;;;1990   	if (!obj)
004c04  e3540000          CMP      r4,#0
004c08  1a000001          BNE      |L1.19476|
;;;1991   		return NULL;
004c0c  e3a00000          MOV      r0,#0
                  |L1.19472|
;;;1992   
;;;1993   	obj->fake = 1;	/* it is fake so it might not use NAND */
;;;1994   	obj->rename_allowed = 0;
;;;1995   	obj->unlink_allowed = 0;
;;;1996   	obj->deleted = 0;
;;;1997   	obj->unlinked = 0;
;;;1998   	obj->yst_mode = mode;
;;;1999   	obj->my_dev = dev;
;;;2000   	obj->hdr_chunk = 0;	/* Not a valid chunk. */
;;;2001   	return obj;
;;;2002   
;;;2003   }
004c10  e8bd81f0          POP      {r4-r8,pc}
                  |L1.19476|
004c14  e5d40000          LDRB     r0,[r4,#0]            ;1993
004c18  e3800008          ORR      r0,r0,#8              ;1993
004c1c  e5c40000          STRB     r0,[r4,#0]            ;1993
004c20  e5d40000          LDRB     r0,[r4,#0]            ;1994
004c24  e3c00010          BIC      r0,r0,#0x10           ;1994
004c28  e5c40000          STRB     r0,[r4,#0]            ;1994
004c2c  e5d40000          LDRB     r0,[r4,#0]            ;1995
004c30  e3c00020          BIC      r0,r0,#0x20           ;1995
004c34  e5c40000          STRB     r0,[r4,#0]            ;1995
004c38  e5d40000          LDRB     r0,[r4,#0]            ;1996
004c3c  e3c00001          BIC      r0,r0,#1              ;1996
004c40  e5c40000          STRB     r0,[r4,#0]            ;1996
004c44  e5d40000          LDRB     r0,[r4,#0]            ;1997
004c48  e3c00004          BIC      r0,r0,#4              ;1997
004c4c  e5c40000          STRB     r0,[r4,#0]            ;1997
004c50  e5846034          STR      r6,[r4,#0x34]         ;1998
004c54  e5845008          STR      r5,[r4,#8]            ;1999
004c58  e3a00000          MOV      r0,#0                 ;2000
004c5c  e5840028          STR      r0,[r4,#0x28]         ;2000
004c60  e1a00004          MOV      r0,r4                 ;2001
004c64  eaffffe9          B        |L1.19472|
;;;2004   
                          ENDP

                  yaffs_init_tnodes_and_objs PROC
;;;2005   
;;;2006   static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
004c68  e92d4070          PUSH     {r4-r6,lr}
;;;2007   {
004c6c  e1a04000          MOV      r4,r0
;;;2008   	int i;
;;;2009   
;;;2010   	dev->n_obj = 0;
004c70  e3a00000          MOV      r0,#0
004c74  e584013c          STR      r0,[r4,#0x13c]
;;;2011   	dev->n_tnodes = 0;
004c78  e5840140          STR      r0,[r4,#0x140]
;;;2012   	yaffs_init_raw_tnodes_and_objs(dev);
004c7c  e1a00004          MOV      r0,r4
004c80  ebfffffe          BL       yaffs_init_raw_tnodes_and_objs
;;;2013   
;;;2014   	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
004c84  e3a05000          MOV      r5,#0
004c88  ea000014          B        |L1.19680|
                  |L1.19596|
;;;2015   		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
004c8c  e1a00000          MOV      r0,r0
004c90  e0850085          ADD      r0,r5,r5,LSL #1
004c94  e2841f52          ADD      r1,r4,#0x148
004c98  e0810100          ADD      r0,r1,r0,LSL #2
004c9c  e0851085          ADD      r1,r5,r5,LSL #1
004ca0  e2842f52          ADD      r2,r4,#0x148
004ca4  e7820101          STR      r0,[r2,r1,LSL #2]
004ca8  e0850085          ADD      r0,r5,r5,LSL #1
004cac  e2841f52          ADD      r1,r4,#0x148
004cb0  e0810100          ADD      r0,r1,r0,LSL #2
004cb4  e0851085          ADD      r1,r5,r5,LSL #1
004cb8  e2842f52          ADD      r2,r4,#0x148
004cbc  e0821101          ADD      r1,r2,r1,LSL #2
004cc0  e5810004          STR      r0,[r1,#4]
004cc4  e1a00000          MOV      r0,r0
;;;2016   		dev->obj_bucket[i].count = 0;
004cc8  e3a00000          MOV      r0,#0
004ccc  e0851085          ADD      r1,r5,r5,LSL #1
004cd0  e2842f52          ADD      r2,r4,#0x148
004cd4  e0821101          ADD      r1,r2,r1,LSL #2
004cd8  e5810008          STR      r0,[r1,#8]
004cdc  e2855001          ADD      r5,r5,#1              ;2014
                  |L1.19680|
004ce0  e3550c01          CMP      r5,#0x100             ;2014
004ce4  baffffe8          BLT      |L1.19596|
;;;2017   	}
;;;2018   }
004ce8  e8bd8070          POP      {r4-r6,pc}
;;;2019   
                          ENDP

                  yaffs_find_or_create_by_number PROC
;;;2020   struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
004cec  e92d41f0          PUSH     {r4-r8,lr}
;;;2021   						 int number,
;;;2022   						 enum yaffs_obj_type type)
;;;2023   {
004cf0  e1a06000          MOV      r6,r0
004cf4  e1a04001          MOV      r4,r1
004cf8  e1a07002          MOV      r7,r2
;;;2024   	struct yaffs_obj *the_obj = NULL;
004cfc  e3a05000          MOV      r5,#0
;;;2025   
;;;2026   	if (number > 0)
004d00  e3540000          CMP      r4,#0
004d04  da000003          BLE      |L1.19736|
;;;2027   		the_obj = yaffs_find_by_number(dev, number);
004d08  e1a01004          MOV      r1,r4
004d0c  e1a00006          MOV      r0,r6
004d10  ebfffffe          BL       yaffs_find_by_number
004d14  e1a05000          MOV      r5,r0
                  |L1.19736|
;;;2028   
;;;2029   	if (!the_obj)
004d18  e3550000          CMP      r5,#0
004d1c  1a000004          BNE      |L1.19764|
;;;2030   		the_obj = yaffs_new_obj(dev, number, type);
004d20  e1a02007          MOV      r2,r7
004d24  e1a01004          MOV      r1,r4
004d28  e1a00006          MOV      r0,r6
004d2c  ebfffffe          BL       yaffs_new_obj
004d30  e1a05000          MOV      r5,r0
                  |L1.19764|
;;;2031   
;;;2032   	return the_obj;
004d34  e1a00005          MOV      r0,r5
;;;2033   
;;;2034   }
004d38  e8bd81f0          POP      {r4-r8,pc}
;;;2035   
                          ENDP

                  yaffs_update_parent PROC
;;;2069   
;;;2070   static void yaffs_update_parent(struct yaffs_obj *obj)
004d3c  e92d407c          PUSH     {r2-r6,lr}
;;;2071   {
004d40  e1a04000          MOV      r4,r0
;;;2072   	struct yaffs_dev *dev;
;;;2073   
;;;2074   	if (!obj)
004d44  e3540000          CMP      r4,#0
004d48  1a000000          BNE      |L1.19792|
                  |L1.19788|
;;;2075   		return;
;;;2076   	dev = obj->my_dev;
;;;2077   	obj->dirty = 1;
;;;2078   	yaffs_load_current_time(obj, 0, 1);
;;;2079   	if (dev->param.defered_dir_update) {
;;;2080   		struct list_head *link = &obj->variant.dir_variant.dirty;
;;;2081   
;;;2082   		if (list_empty(link)) {
;;;2083   			list_add(link, &dev->dirty_dirs);
;;;2084   			yaffs_trace(YAFFS_TRACE_BACKGROUND,
;;;2085   			  "Added object %d to dirty directories",
;;;2086   			   obj->obj_id);
;;;2087   		}
;;;2088   
;;;2089   	} else {
;;;2090   		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
;;;2091   	}
;;;2092   }
004d4c  e8bd807c          POP      {r2-r6,pc}
                  |L1.19792|
004d50  e5945008          LDR      r5,[r4,#8]            ;2076
004d54  e5d40000          LDRB     r0,[r4,#0]            ;2077
004d58  e3800040          ORR      r0,r0,#0x40           ;2077
004d5c  e5c40000          STRB     r0,[r4,#0]            ;2077
004d60  e3a02001          MOV      r2,#1                 ;2078
004d64  e3a01000          MOV      r1,#0                 ;2078
004d68  e1a00004          MOV      r0,r4                 ;2078
004d6c  ebfffffe          BL       yaffs_load_current_time
004d70  e5950084          LDR      r0,[r5,#0x84]         ;2079
004d74  e3500000          CMP      r0,#0                 ;2079
004d78  0a00000f          BEQ      |L1.19900|
004d7c  e2846070          ADD      r6,r4,#0x70           ;2080
004d80  e1a00006          MOV      r0,r6                 ;2082
004d84  ebfffffe          BL       list_empty
004d88  e3500000          CMP      r0,#0                 ;2082
004d8c  0a000009          BEQ      |L1.19896|
004d90  e2851c0e          ADD      r1,r5,#0xe00          ;2083
004d94  e1a00006          MOV      r0,r6                 ;2083
004d98  ebfffffe          BL       list_add
004d9c  e59f0204          LDR      r0,|L1.20392|
004da0  e5900000          LDR      r0,[r0,#0]            ;2084  ; yaffs_trace_mask
004da4  e3100602          TST      r0,#0x200000          ;2084
004da8  0a000002          BEQ      |L1.19896|
004dac  e28f0f7e          ADR      r0,|L1.20396|
004db0  e5941030          LDR      r1,[r4,#0x30]         ;2084
004db4  ebfffffe          BL       sysprintf
                  |L1.19896|
004db8  ea000007          B        |L1.19932|
                  |L1.19900|
004dbc  e3a00000          MOV      r0,#0                 ;2090
004dc0  e58d0000          STR      r0,[sp,#0]            ;2090
004dc4  e58d0004          STR      r0,[sp,#4]            ;2090
004dc8  e1a03000          MOV      r3,r0                 ;2090
004dcc  e1a02000          MOV      r2,r0                 ;2090
004dd0  e1a01000          MOV      r1,r0                 ;2090
004dd4  e1a00004          MOV      r0,r4                 ;2090
004dd8  ebfffffe          BL       yaffs_update_oh
                  |L1.19932|
004ddc  e1a00000          MOV      r0,r0
004de0  eaffffd9          B        |L1.19788|
;;;2093   
                          ENDP

                  yaffs_update_dirty_dirs PROC
;;;2094   void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
004de4  e92d41fc          PUSH     {r2-r8,lr}
;;;2095   {
004de8  e1a05000          MOV      r5,r0
;;;2096   	struct list_head *link;
;;;2097   	struct yaffs_obj *obj;
;;;2098   	struct yaffs_dir_var *d_s;
;;;2099   	union yaffs_obj_var *o_v;
;;;2100   
;;;2101   	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
004dec  e59f01b4          LDR      r0,|L1.20392|
004df0  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
004df4  e3100602          TST      r0,#0x200000
004df8  0a000001          BEQ      |L1.19972|
004dfc  e28f0f76          ADR      r0,|L1.20444|
004e00  ebfffffe          BL       sysprintf
                  |L1.19972|
;;;2102   
;;;2103   	while (!list_empty(&dev->dirty_dirs)) {
004e04  ea000018          B        |L1.20076|
                  |L1.19976|
;;;2104   		link = dev->dirty_dirs.next;
004e08  e5956e00          LDR      r6,[r5,#0xe00]
;;;2105   		list_del_init(link);
004e0c  e1a00006          MOV      r0,r6
004e10  ebfffffe          BL       list_del_init
;;;2106   
;;;2107   		d_s = list_entry(link, struct yaffs_dir_var, dirty);
004e14  e2467008          SUB      r7,r6,#8
;;;2108   		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
004e18  e2478000          SUB      r8,r7,#0
;;;2109   		obj = list_entry(o_v, struct yaffs_obj, variant);
004e1c  e2484068          SUB      r4,r8,#0x68
;;;2110   
;;;2111   		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
004e20  e59f0180          LDR      r0,|L1.20392|
004e24  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
004e28  e3100602          TST      r0,#0x200000
004e2c  0a000002          BEQ      |L1.20028|
004e30  e28f0f72          ADR      r0,|L1.20480|
004e34  e5941030          LDR      r1,[r4,#0x30]
004e38  ebfffffe          BL       sysprintf
                  |L1.20028|
;;;2112   			obj->obj_id);
;;;2113   
;;;2114   		if (obj->dirty)
004e3c  e5d40000          LDRB     r0,[r4,#0]
004e40  e1a00c80          LSL      r0,r0,#25
004e44  e1b00fa0          LSRS     r0,r0,#31
004e48  0a000007          BEQ      |L1.20076|
;;;2115   			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
004e4c  e3a00000          MOV      r0,#0
004e50  e58d0000          STR      r0,[sp,#0]
004e54  e58d0004          STR      r0,[sp,#4]
004e58  e1a03000          MOV      r3,r0
004e5c  e1a02000          MOV      r2,r0
004e60  e1a01000          MOV      r1,r0
004e64  e1a00004          MOV      r0,r4
004e68  ebfffffe          BL       yaffs_update_oh
                  |L1.20076|
004e6c  e2850c0e          ADD      r0,r5,#0xe00          ;2103
004e70  ebfffffe          BL       list_empty
004e74  e3500000          CMP      r0,#0                 ;2103
004e78  0affffe2          BEQ      |L1.19976|
;;;2116   	}
;;;2117   }
004e7c  e8bd81fc          POP      {r2-r8,pc}
;;;2118   
                          ENDP

                  yaffs_del_link PROC
;;;3915   
;;;3916   static int yaffs_del_link(struct yaffs_obj *in)
004e80  e92d4010          PUSH     {r4,lr}
;;;3917   {
004e84  e1a04000          MOV      r4,r0
;;;3918   	/* remove this hardlink from the list associated with the equivalent
;;;3919   	 * object
;;;3920   	 */
;;;3921   	list_del_init(&in->hard_links);
004e88  e2840014          ADD      r0,r4,#0x14
004e8c  ebfffffe          BL       list_del_init
;;;3922   	return yaffs_generic_obj_del(in);
004e90  e1a00004          MOV      r0,r4
004e94  ebfffffe          BL       yaffs_generic_obj_del
;;;3923   }
004e98  e8bd8010          POP      {r4,pc}
;;;3924   
                          ENDP

                  yaffs_del_symlink PROC
;;;3907   
;;;3908   static int yaffs_del_symlink(struct yaffs_obj *in)
004e9c  e92d4010          PUSH     {r4,lr}
;;;3909   {
004ea0  e1a04000          MOV      r4,r0
;;;3910   	yaffs_free(in->variant.symlink_variant.alias);
004ea4  e5940068          LDR      r0,[r4,#0x68]
004ea8  ebfffffe          BL       yaffs_free
;;;3911   	in->variant.symlink_variant.alias = NULL;
004eac  e3a00000          MOV      r0,#0
004eb0  e5840068          STR      r0,[r4,#0x68]
;;;3912   
;;;3913   	return yaffs_generic_obj_del(in);
004eb4  e1a00004          MOV      r0,r4
004eb8  ebfffffe          BL       yaffs_generic_obj_del
;;;3914   }
004ebc  e8bd8010          POP      {r4,pc}
;;;3915   
                          ENDP

                  yaffs_is_non_empty_dir PROC
;;;3891   
;;;3892   int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
004ec0  e92d4010          PUSH     {r4,lr}
;;;3893   {
004ec4  e1a04000          MOV      r4,r0
;;;3894   	return (obj &&
004ec8  e3540000          CMP      r4,#0
004ecc  0a000008          BEQ      |L1.20212|
;;;3895   		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
004ed0  e5d40064          LDRB     r0,[r4,#0x64]
004ed4  e3500003          CMP      r0,#3
004ed8  1a000005          BNE      |L1.20212|
;;;3896   		!(list_empty(&obj->variant.dir_variant.children));
004edc  e2840068          ADD      r0,r4,#0x68
004ee0  ebfffffe          BL       list_empty
004ee4  e3500000          CMP      r0,#0
004ee8  1a000001          BNE      |L1.20212|
004eec  e3a00001          MOV      r0,#1                 ;3894
                  |L1.20208|
;;;3897   }
004ef0  e8bd8010          POP      {r4,pc}
                  |L1.20212|
004ef4  e3a00000          MOV      r0,#0                 ;3894
004ef8  eafffffc          B        |L1.20208|
;;;3898   
                          ENDP

                  yaffs_del_dir PROC
;;;3899   static int yaffs_del_dir(struct yaffs_obj *obj)
004efc  e92d4010          PUSH     {r4,lr}
;;;3900   {
004f00  e1a04000          MOV      r4,r0
;;;3901   	/* First check that the directory is empty. */
;;;3902   	if (yaffs_is_non_empty_dir(obj))
004f04  e1a00004          MOV      r0,r4
004f08  ebfffffe          BL       yaffs_is_non_empty_dir
004f0c  e3500000          CMP      r0,#0
004f10  0a000001          BEQ      |L1.20252|
;;;3903   		return YAFFS_FAIL;
004f14  e3a00000          MOV      r0,#0
                  |L1.20248|
;;;3904   
;;;3905   	return yaffs_generic_obj_del(obj);
;;;3906   }
004f18  e8bd8010          POP      {r4,pc}
                  |L1.20252|
004f1c  e1a00004          MOV      r0,r4                 ;3905
004f20  ebfffffe          BL       yaffs_generic_obj_del
004f24  eafffffb          B        |L1.20248|
;;;3907   
                          ENDP

                  yaffs_rd_data_obj PROC
;;;2919   
;;;2920   static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
004f28  e92d41f0          PUSH     {r4-r8,lr}
;;;2921   {
004f2c  e1a04000          MOV      r4,r0
004f30  e1a07001          MOV      r7,r1
004f34  e1a05002          MOV      r5,r2
;;;2922   	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
004f38  e3a02000          MOV      r2,#0
004f3c  e1a01007          MOV      r1,r7
004f40  e1a00004          MOV      r0,r4
004f44  ebfffffe          BL       yaffs_find_chunk_in_file
004f48  e1a06000          MOV      r6,r0
;;;2923   
;;;2924   	if (nand_chunk >= 0)
004f4c  e3560000          CMP      r6,#0
004f50  ba000005          BLT      |L1.20332|
;;;2925   		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
004f54  e3a03000          MOV      r3,#0
004f58  e1a02005          MOV      r2,r5
004f5c  e1a01006          MOV      r1,r6
004f60  e5940008          LDR      r0,[r4,#8]
004f64  ebfffffe          BL       yaffs_rd_chunk_tags_nand
                  |L1.20328|
;;;2926   						buffer, NULL);
;;;2927   	else {
;;;2928   		yaffs_trace(YAFFS_TRACE_NANDACCESS,
;;;2929   			"Chunk %d not found zero instead",
;;;2930   			nand_chunk);
;;;2931   		/* get sane (zero) data if you read a hole */
;;;2932   		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
;;;2933   		return 0;
;;;2934   	}
;;;2935   
;;;2936   }
004f68  e8bd81f0          POP      {r4-r8,pc}
                  |L1.20332|
004f6c  e59f0034          LDR      r0,|L1.20392|
004f70  e1d000b0          LDRH     r0,[r0,#0]            ;2928  ; yaffs_trace_mask
004f74  e3100b02          TST      r0,#0x800             ;2928
004f78  0a000002          BEQ      |L1.20360|
004f7c  e1a01006          MOV      r1,r6                 ;2928
004f80  e28f0094          ADR      r0,|L1.20508|
004f84  ebfffffe          BL       sysprintf
                  |L1.20360|
004f88  e5940008          LDR      r0,[r4,#8]            ;2932
004f8c  e59010a4          LDR      r1,[r0,#0xa4]         ;2932
004f90  e1a00005          MOV      r0,r5                 ;2932
004f94  ebfffffe          BL       __aeabi_memclr
004f98  e3a00000          MOV      r0,#0                 ;2933
004f9c  eafffff1          B        |L1.20328|
                  |L1.20384|
                          DCD      0x000003e7
                  |L1.20388|
                          DCD      0x000f423f
                  |L1.20392|
                          DCD      yaffs_trace_mask
                  |L1.20396|
004fac  79616666          DCB      "yaffs: Added object %d to dirty directories\n",0
004fb0  733a2041
004fb4  64646564
004fb8  206f626a
004fbc  65637420
004fc0  25642074
004fc4  6f206469
004fc8  72747920
004fcc  64697265
004fd0  63746f72
004fd4  6965730a
004fd8  00      
004fd9  00                DCB      0
004fda  00                DCB      0
004fdb  00                DCB      0
                  |L1.20444|
004fdc  79616666          DCB      "yaffs: Update dirty directories\n",0
004fe0  733a2055
004fe4  70646174
004fe8  65206469
004fec  72747920
004ff0  64697265
004ff4  63746f72
004ff8  6965730a
004ffc  00      
004ffd  00                DCB      0
004ffe  00                DCB      0
004fff  00                DCB      0
                  |L1.20480|
005000  79616666          DCB      "yaffs: Update directory %d\n",0
005004  733a2055
005008  70646174
00500c  65206469
005010  72656374
005014  6f727920
005018  25640a00
                  |L1.20508|
00501c  79616666          DCB      "yaffs: Chunk %d not found zero instead\n",0
005020  733a2043
005024  68756e6b
005028  20256420
00502c  6e6f7420
005030  666f756e
005034  64207a65
005038  726f2069
00503c  6e737465
005040  61640a00
                          ENDP

                  yaffs_prune_chunks PROC
;;;3687   
;;;3688   static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
005044  e92d4ff0          PUSH     {r4-r11,lr}
;;;3689   {
005048  e24dd01c          SUB      sp,sp,#0x1c
00504c  e1a0a000          MOV      r10,r0
005050  e1a07002          MOV      r7,r2
005054  e1a08003          MOV      r8,r3
;;;3690   
;;;3691   	struct yaffs_dev *dev = in->my_dev;
005058  e59a4008          LDR      r4,[r10,#8]
;;;3692   	loff_t old_size = in->variant.file_variant.file_size;
00505c  e59a5068          LDR      r5,[r10,#0x68]
005060  e59a606c          LDR      r6,[r10,#0x6c]
005064  e3a00000          MOV      r0,#0
005068  e1a01000          MOV      r1,r0
00506c  e0500005          SUBS     r0,r0,r5
005070  e0d10006          SBCS     r0,r1,r6
;;;3693   	int i;
;;;3694   	int chunk_id;
;;;3695   	u32 dummy;
;;;3696   	int last_del;
;;;3697   	int start_del;
;;;3698   
;;;3699   	if (old_size > 0)
005074  aa00000c          BGE      |L1.20652|
;;;3700   		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
005078  e28d0018          ADD      r0,sp,#0x18
00507c  e28d1014          ADD      r1,sp,#0x14
005080  e58d1000          STR      r1,[sp,#0]
005084  e2551001          SUBS     r1,r5,#1
005088  e58d0004          STR      r0,[sp,#4]
00508c  e2c60000          SBC      r0,r6,#0
005090  e58d1008          STR      r1,[sp,#8]
005094  e1a02001          MOV      r2,r1
005098  e58d000c          STR      r0,[sp,#0xc]
00509c  e1a03000          MOV      r3,r0
0050a0  e1a00004          MOV      r0,r4
0050a4  ebfffffe          BL       yaffs_addr_to_chunk
0050a8  ea000001          B        |L1.20660|
                  |L1.20652|
;;;3701   	else
;;;3702   		last_del = 0;
0050ac  e3a00000          MOV      r0,#0
0050b0  e58d0014          STR      r0,[sp,#0x14]
                  |L1.20660|
;;;3703   
;;;3704   	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
0050b4  e28d0018          ADD      r0,sp,#0x18
0050b8  e28d1010          ADD      r1,sp,#0x10
0050bc  e58d0004          STR      r0,[sp,#4]
0050c0  e58d1000          STR      r1,[sp,#0]
0050c4  e59400a4          LDR      r0,[r4,#0xa4]
0050c8  e0902007          ADDS     r2,r0,r7
0050cc  e0a81fc0          ADC      r1,r8,r0,ASR #31
0050d0  e2520001          SUBS     r0,r2,#1
0050d4  e2c11000          SBC      r1,r1,#0
0050d8  e1cd00f8          STRD     r0,r1,[sp,#8]
0050dc  e1a02000          MOV      r2,r0
0050e0  e1a03001          MOV      r3,r1
0050e4  e1a00004          MOV      r0,r4
0050e8  ebfffffe          BL       yaffs_addr_to_chunk
;;;3705   				&start_del, &dummy);
;;;3706   	last_del++;
0050ec  e59d0014          LDR      r0,[sp,#0x14]
0050f0  e2800001          ADD      r0,r0,#1
0050f4  e58d0014          STR      r0,[sp,#0x14]
;;;3707   	start_del++;
0050f8  e59d0010          LDR      r0,[sp,#0x10]
0050fc  e2800001          ADD      r0,r0,#1
005100  e58d0010          STR      r0,[sp,#0x10]
;;;3708   
;;;3709   	/* Delete backwards so that we don't end up with holes if
;;;3710   	 * power is lost part-way through the operation.
;;;3711   	 */
;;;3712   	for (i = last_del; i >= start_del; i--) {
005104  e59db014          LDR      r11,[sp,#0x14]
005108  ea000025          B        |L1.20900|
                  |L1.20748|
;;;3713   		/* NB this could be optimised somewhat,
;;;3714   		 * eg. could retrieve the tags and write them without
;;;3715   		 * using yaffs_chunk_del
;;;3716   		 */
;;;3717   
;;;3718   		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
00510c  e3a02000          MOV      r2,#0
005110  e1a0100b          MOV      r1,r11
005114  e1a0000a          MOV      r0,r10
005118  ebfffffe          BL       yaffs_find_del_file_chunk
00511c  e1a09000          MOV      r9,r0
;;;3719   
;;;3720   		if (chunk_id < 1)
005120  e3590001          CMP      r9,#1
005124  aa000000          BGE      |L1.20780|
;;;3721   			continue;
005128  ea00001c          B        |L1.20896|
                  |L1.20780|
;;;3722   
;;;3723   		if (chunk_id <
00512c  e59400d0          LDR      r0,[r4,#0xd0]
005130  e594100c          LDR      r1,[r4,#0xc]
005134  e0000091          MUL      r0,r1,r0
005138  e1500009          CMP      r0,r9
00513c  ca000005          BGT      |L1.20824|
;;;3724   		    (dev->internal_start_block * dev->param.chunks_per_block) ||
;;;3725   		    chunk_id >=
005140  e59400d4          LDR      r0,[r4,#0xd4]
005144  e2800001          ADD      r0,r0,#1
005148  e594100c          LDR      r1,[r4,#0xc]
00514c  e0000091          MUL      r0,r1,r0
005150  e1500009          CMP      r0,r9
005154  ca000008          BGT      |L1.20860|
                  |L1.20824|
;;;3726   		    ((dev->internal_end_block + 1) *
;;;3727   		      dev->param.chunks_per_block)) {
;;;3728   			yaffs_trace(YAFFS_TRACE_ALWAYS,
005158  e51f01b8          LDR      r0,|L1.20392|
00515c  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
005160  e310020f          TST      r0,#0xf0000000
005164  0a00000c          BEQ      |L1.20892|
005168  e1a0200b          MOV      r2,r11
00516c  e1a01009          MOV      r1,r9
005170  e28f0f82          ADR      r0,|L1.21376|
005174  ebfffffe          BL       sysprintf
005178  ea000007          B        |L1.20892|
                  |L1.20860|
;;;3729   				"Found daft chunk_id %d for %d",
;;;3730   				chunk_id, i);
;;;3731   		} else {
;;;3732   			in->n_data_chunks--;
00517c  e59a002c          LDR      r0,[r10,#0x2c]
005180  e2400001          SUB      r0,r0,#1
005184  e58a002c          STR      r0,[r10,#0x2c]
;;;3733   			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
005188  e59f3218          LDR      r3,|L1.21416|
00518c  e3a02001          MOV      r2,#1
005190  e1a01009          MOV      r1,r9
005194  e1a00004          MOV      r0,r4
005198  ebfffffe          BL       yaffs_chunk_del
                  |L1.20892|
00519c  e1a00000          MOV      r0,r0                 ;3721
                  |L1.20896|
0051a0  e24bb001          SUB      r11,r11,#1            ;3712
                  |L1.20900|
0051a4  e59d0010          LDR      r0,[sp,#0x10]         ;3712
0051a8  e15b0000          CMP      r11,r0                ;3712
0051ac  aaffffd6          BGE      |L1.20748|
;;;3734   		}
;;;3735   	}
;;;3736   }
0051b0  e28dd01c          ADD      sp,sp,#0x1c
0051b4  e8bd8ff0          POP      {r4-r11,pc}
;;;3737   
                          ENDP

                  yaffs_resize_file_down PROC
;;;3738   void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
0051b8  e92d47ff          PUSH     {r0-r10,lr}
;;;3739   {
0051bc  e1a06000          MOV      r6,r0
0051c0  e1a04002          MOV      r4,r2
0051c4  e1a05003          MOV      r5,r3
;;;3740   	int new_full;
;;;3741   	u32 new_partial;
;;;3742   	struct yaffs_dev *dev = obj->my_dev;
0051c8  e5968008          LDR      r8,[r6,#8]
;;;3743   
;;;3744   	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
0051cc  e28d0008          ADD      r0,sp,#8
0051d0  e28d100c          ADD      r1,sp,#0xc
0051d4  e1a02004          MOV      r2,r4
0051d8  e1a03005          MOV      r3,r5
0051dc  e58d0004          STR      r0,[sp,#4]
0051e0  e1a00008          MOV      r0,r8
0051e4  e58d1000          STR      r1,[sp,#0]
0051e8  ebfffffe          BL       yaffs_addr_to_chunk
;;;3745   
;;;3746   	yaffs_prune_chunks(obj, new_size);
0051ec  e1a02004          MOV      r2,r4
0051f0  e1a03005          MOV      r3,r5
0051f4  e1a00006          MOV      r0,r6
0051f8  ebfffffe          BL       yaffs_prune_chunks
;;;3747   
;;;3748   	if (new_partial != 0) {
0051fc  e59d0008          LDR      r0,[sp,#8]
005200  e3500000          CMP      r0,#0
005204  0a000018          BEQ      |L1.21100|
;;;3749   		int last_chunk = 1 + new_full;
005208  e59d000c          LDR      r0,[sp,#0xc]
00520c  e2809001          ADD      r9,r0,#1
;;;3750   		u8 *local_buffer = yaffs_get_temp_buffer(dev);
005210  e1a00008          MOV      r0,r8
005214  ebfffffe          BL       yaffs_get_temp_buffer
005218  e1a07000          MOV      r7,r0
;;;3751   
;;;3752   		/* Rewrite the last chunk with its new size and zero pad */
;;;3753   		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
00521c  e1a02007          MOV      r2,r7
005220  e1a01009          MOV      r1,r9
005224  e1a00006          MOV      r0,r6
005228  ebfffffe          BL       yaffs_rd_data_obj
;;;3754   		memset(local_buffer + new_partial, 0,
00522c  e59820a4          LDR      r2,[r8,#0xa4]
005230  e59d3008          LDR      r3,[sp,#8]
005234  e0421003          SUB      r1,r2,r3
005238  e0870003          ADD      r0,r7,r3
00523c  ebfffffe          BL       __aeabi_memclr
;;;3755   		       dev->data_bytes_per_chunk - new_partial);
;;;3756   
;;;3757   		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
005240  e3a00001          MOV      r0,#1
005244  e58d0000          STR      r0,[sp,#0]
005248  e1a02007          MOV      r2,r7
00524c  e1a01009          MOV      r1,r9
005250  e1a00006          MOV      r0,r6
005254  e59d3008          LDR      r3,[sp,#8]
005258  ebfffffe          BL       yaffs_wr_data_obj
;;;3758   				  new_partial, 1);
;;;3759   
;;;3760   		yaffs_release_temp_buffer(dev, local_buffer);
00525c  e1a01007          MOV      r1,r7
005260  e1a00008          MOV      r0,r8
005264  ebfffffe          BL       yaffs_release_temp_buffer
;;;3761   	}
005268  e1a00000          MOV      r0,r0
                  |L1.21100|
;;;3762   
;;;3763   	obj->variant.file_variant.file_size = new_size;
00526c  e1c646f8          STRD     r4,r5,[r6,#0x68]
;;;3764   
;;;3765   	yaffs_prune_tree(dev, &obj->variant.file_variant);
005270  e2861068          ADD      r1,r6,#0x68
005274  e1a00008          MOV      r0,r8
005278  ebfffffe          BL       yaffs_prune_tree
;;;3766   }
00527c  e8bd87ff          POP      {r0-r10,pc}
;;;3767   
                          ENDP

                  yaffs_resize_file PROC
;;;3768   int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
005280  e92d47fc          PUSH     {r2-r10,lr}
;;;3769   {
005284  e1a04000          MOV      r4,r0
005288  e1a05002          MOV      r5,r2
00528c  e1a06003          MOV      r6,r3
;;;3770   	struct yaffs_dev *dev = in->my_dev;
005290  e5949008          LDR      r9,[r4,#8]
;;;3771   	loff_t old_size = in->variant.file_variant.file_size;
005294  e5947068          LDR      r7,[r4,#0x68]
005298  e594806c          LDR      r8,[r4,#0x6c]
;;;3772   
;;;3773   	yaffs_flush_file_cache(in);
00529c  e1a00004          MOV      r0,r4
0052a0  ebfffffe          BL       yaffs_flush_file_cache
;;;3774   	yaffs_invalidate_whole_cache(in);
0052a4  e1a00004          MOV      r0,r4
0052a8  ebfffffe          BL       yaffs_invalidate_whole_cache
;;;3775   
;;;3776   	yaffs_check_gc(dev, 0);
0052ac  e3a01000          MOV      r1,#0
0052b0  e1a00009          MOV      r0,r9
0052b4  ebfffffe          BL       yaffs_check_gc
;;;3777   
;;;3778   	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
0052b8  e5d40064          LDRB     r0,[r4,#0x64]
0052bc  e3500001          CMP      r0,#1
0052c0  0a000001          BEQ      |L1.21196|
;;;3779   		return YAFFS_FAIL;
0052c4  e3a00000          MOV      r0,#0
                  |L1.21192|
;;;3780   
;;;3781   	if (new_size == old_size)
;;;3782   		return YAFFS_OK;
;;;3783   
;;;3784   	if (new_size > old_size) {
;;;3785   		yaffs2_handle_hole(in, new_size);
;;;3786   		in->variant.file_variant.file_size = new_size;
;;;3787   	} else {
;;;3788   		/* new_size < old_size */
;;;3789   		yaffs_resize_file_down(in, new_size);
;;;3790   	}
;;;3791   
;;;3792   	/* Write a new object header to reflect the resize.
;;;3793   	 * show we've shrunk the file, if need be
;;;3794   	 * Do this only if the file is not in the deleted directories
;;;3795   	 * and is not shadowed.
;;;3796   	 */
;;;3797   	if (in->parent &&
;;;3798   	    !in->is_shadowed &&
;;;3799   	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
;;;3800   	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
;;;3801   		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
;;;3802   
;;;3803   	return YAFFS_OK;
;;;3804   }
0052c8  e8bd87fc          POP      {r2-r10,pc}
                  |L1.21196|
0052cc  e0250007          EOR      r0,r5,r7              ;3779
0052d0  e0261008          EOR      r1,r6,r8              ;3779
0052d4  e1900001          ORRS     r0,r0,r1              ;3781
0052d8  1a000001          BNE      |L1.21220|
0052dc  e3a00001          MOV      r0,#1                 ;3782
0052e0  eafffff8          B        |L1.21192|
                  |L1.21220|
0052e4  e0570005          SUBS     r0,r7,r5              ;3782
0052e8  e0d80006          SBCS     r0,r8,r6              ;3782
0052ec  aa000006          BGE      |L1.21260|
0052f0  e1a02005          MOV      r2,r5                 ;3785
0052f4  e1a03006          MOV      r3,r6                 ;3785
0052f8  e1a00004          MOV      r0,r4                 ;3785
0052fc  ebfffffe          BL       yaffs2_handle_hole
005300  e5845068          STR      r5,[r4,#0x68]         ;3786
005304  e584606c          STR      r6,[r4,#0x6c]         ;3786
005308  ea000003          B        |L1.21276|
                  |L1.21260|
00530c  e1a02005          MOV      r2,r5                 ;3789
005310  e1a03006          MOV      r3,r6                 ;3789
005314  e1a00004          MOV      r0,r4                 ;3789
005318  ebfffffe          BL       yaffs_resize_file_down
                  |L1.21276|
00531c  e594001c          LDR      r0,[r4,#0x1c]         ;3797
005320  e3500000          CMP      r0,#0                 ;3797
005324  0a000013          BEQ      |L1.21368|
005328  e5d40001          LDRB     r0,[r4,#1]            ;3798
00532c  e1a00e00          LSL      r0,r0,#28             ;3798
005330  e1b00fa0          LSRS     r0,r0,#31             ;3798
005334  1a00000f          BNE      |L1.21368|
005338  e594001c          LDR      r0,[r4,#0x1c]         ;3799
00533c  e5900030          LDR      r0,[r0,#0x30]         ;3799
005340  e3500003          CMP      r0,#3                 ;3799
005344  0a00000b          BEQ      |L1.21368|
005348  e594001c          LDR      r0,[r4,#0x1c]         ;3800
00534c  e5900030          LDR      r0,[r0,#0x30]         ;3800
005350  e3500004          CMP      r0,#4                 ;3800
005354  0a000007          BEQ      |L1.21368|
005358  e3a00000          MOV      r0,#0                 ;3801
00535c  e58d0000          STR      r0,[sp,#0]            ;3801
005360  e58d0004          STR      r0,[sp,#4]            ;3801
005364  e1a03000          MOV      r3,r0                 ;3801
005368  e1a02000          MOV      r2,r0                 ;3801
00536c  e1a01000          MOV      r1,r0                 ;3801
005370  e1a00004          MOV      r0,r4                 ;3801
005374  ebfffffe          BL       yaffs_update_oh
                  |L1.21368|
005378  e3a00001          MOV      r0,#1                 ;3803
00537c  eaffffd1          B        |L1.21192|
                  |L1.21376|
005380  79616666          DCB      "yaffs: Found daft chunk_id %d for %d\n",0
005384  733a2046
005388  6f756e64
00538c  20646166
005390  74206368
005394  756e6b5f
005398  69642025
00539c  6420666f
0053a0  72202564
0053a4  0a00    
0053a6  00                DCB      0
0053a7  00                DCB      0
                  |L1.21416|
                          DCD      0x00000e95
                          ENDP

                  yaffs_unlink_file_if_needed PROC
;;;3827    */
;;;3828   static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
0053ac  e92d40f8          PUSH     {r3-r7,lr}
;;;3829   {
0053b0  e1a04000          MOV      r4,r0
;;;3830   	int ret_val;
;;;3831   	int del_now = 0;
0053b4  e3a07000          MOV      r7,#0
;;;3832   	struct yaffs_dev *dev = in->my_dev;
0053b8  e5946008          LDR      r6,[r4,#8]
;;;3833   
;;;3834   	if (!in->my_inode)
0053bc  e5940060          LDR      r0,[r4,#0x60]
0053c0  e3500000          CMP      r0,#0
0053c4  1a000000          BNE      |L1.21452|
;;;3835   		del_now = 1;
0053c8  e3a07001          MOV      r7,#1
                  |L1.21452|
;;;3836   
;;;3837   	if (del_now) {
0053cc  e3570000          CMP      r7,#0
0053d0  0a000024          BEQ      |L1.21608|
;;;3838   		ret_val =
0053d4  e3a00000          MOV      r0,#0
0053d8  e58d0000          STR      r0,[sp,#0]
0053dc  e5940008          LDR      r0,[r4,#8]
0053e0  e3a03000          MOV      r3,#0
0053e4  e59f227c          LDR      r2,|L1.22120|
0053e8  e5901d9c          LDR      r1,[r0,#0xd9c]
0053ec  e1a00004          MOV      r0,r4
0053f0  ebfffffe          BL       yaffs_change_obj_name
0053f4  e1a05000          MOV      r5,r0
;;;3839   		    yaffs_change_obj_name(in, in->my_dev->del_dir,
;;;3840   					  _Y("deleted"), 0, 0);
;;;3841   		yaffs_trace(YAFFS_TRACE_TRACING,
0053f8  e51f0458          LDR      r0,|L1.20392|
0053fc  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
005400  e3100c01          TST      r0,#0x100
005404  0a000002          BEQ      |L1.21524|
005408  e28f0f97          ADR      r0,|L1.22124|
00540c  e5941030          LDR      r1,[r4,#0x30]
005410  ebfffffe          BL       sysprintf
                  |L1.21524|
;;;3842   			"yaffs: immediate deletion of file %d",
;;;3843   			in->obj_id);
;;;3844   		in->deleted = 1;
005414  e5d40000          LDRB     r0,[r4,#0]
005418  e3800001          ORR      r0,r0,#1
00541c  e5c40000          STRB     r0,[r4,#0]
;;;3845   		in->my_dev->n_deleted_files++;
005420  e5940008          LDR      r0,[r4,#8]
005424  e5900da4          LDR      r0,[r0,#0xda4]
005428  e2800001          ADD      r0,r0,#1
00542c  e5941008          LDR      r1,[r4,#8]
005430  e5810da4          STR      r0,[r1,#0xda4]
;;;3846   		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
005434  e5960080          LDR      r0,[r6,#0x80]
005438  e3500000          CMP      r0,#0
00543c  1a000002          BNE      |L1.21580|
005440  e5960030          LDR      r0,[r6,#0x30]
005444  e3500000          CMP      r0,#0
005448  0a000003          BEQ      |L1.21596|
                  |L1.21580|
00544c  e3a02000          MOV      r2,#0
005450  e1a03002          MOV      r3,r2
;;;3847   			yaffs_resize_file(in, 0);
005454  e1a00004          MOV      r0,r4
005458  ebfffffe          BL       yaffs_resize_file
                  |L1.21596|
;;;3848   		yaffs_soft_del_file(in);
00545c  e1a00004          MOV      r0,r4
005460  ebfffffe          BL       yaffs_soft_del_file
005464  ea000008          B        |L1.21644|
                  |L1.21608|
;;;3849   	} else {
;;;3850   		ret_val =
005468  e3a00000          MOV      r0,#0
00546c  e58d0000          STR      r0,[sp,#0]
005470  e5940008          LDR      r0,[r4,#8]
005474  e3a03000          MOV      r3,#0
005478  e28f2f87          ADR      r2,|L1.22172|
00547c  e5901d98          LDR      r1,[r0,#0xd98]
005480  e1a00004          MOV      r0,r4
005484  ebfffffe          BL       yaffs_change_obj_name
005488  e1a05000          MOV      r5,r0
                  |L1.21644|
;;;3851   		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
;;;3852   					  _Y("unlinked"), 0, 0);
;;;3853   	}
;;;3854   	return ret_val;
00548c  e1a00005          MOV      r0,r5
;;;3855   }
005490  e8bd80f8          POP      {r3-r7,pc}
;;;3856   
                          ENDP

                  yaffs_del_file PROC
;;;3857   int yaffs_del_file(struct yaffs_obj *in)
005494  e92d41f0          PUSH     {r4-r8,lr}
;;;3858   {
005498  e1a04000          MOV      r4,r0
;;;3859   	int ret_val = YAFFS_OK;
00549c  e3a07001          MOV      r7,#1
;;;3860   	int deleted;	/* Need to cache value on stack if in is freed */
;;;3861   	struct yaffs_dev *dev = in->my_dev;
0054a0  e5946008          LDR      r6,[r4,#8]
;;;3862   
;;;3863   	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
0054a4  e5960080          LDR      r0,[r6,#0x80]
0054a8  e3500000          CMP      r0,#0
0054ac  1a000002          BNE      |L1.21692|
0054b0  e5960030          LDR      r0,[r6,#0x30]
0054b4  e3500000          CMP      r0,#0
0054b8  0a000003          BEQ      |L1.21708|
                  |L1.21692|
0054bc  e3a02000          MOV      r2,#0
0054c0  e1a03002          MOV      r3,r2
;;;3864   		yaffs_resize_file(in, 0);
0054c4  e1a00004          MOV      r0,r4
0054c8  ebfffffe          BL       yaffs_resize_file
                  |L1.21708|
;;;3865   
;;;3866   	if (in->n_data_chunks > 0) {
0054cc  e594002c          LDR      r0,[r4,#0x2c]
0054d0  e3500000          CMP      r0,#0
0054d4  da000022          BLE      |L1.21860|
;;;3867   		/* Use soft deletion if there is data in the file.
;;;3868   		 * That won't be the case if it has been resized to zero.
;;;3869   		 */
;;;3870   		if (!in->unlinked)
0054d8  e5d40000          LDRB     r0,[r4,#0]
0054dc  e1a00e80          LSL      r0,r0,#29
0054e0  e1b00fa0          LSRS     r0,r0,#31
0054e4  1a000002          BNE      |L1.21748|
;;;3871   			ret_val = yaffs_unlink_file_if_needed(in);
0054e8  e1a00004          MOV      r0,r4
0054ec  ebfffffe          BL       yaffs_unlink_file_if_needed
0054f0  e1a07000          MOV      r7,r0
                  |L1.21748|
;;;3872   
;;;3873   		deleted = in->deleted;
0054f4  e5d40000          LDRB     r0,[r4,#0]
0054f8  e2005001          AND      r5,r0,#1
;;;3874   
;;;3875   		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
0054fc  e3570001          CMP      r7,#1
005500  1a000011          BNE      |L1.21836|
005504  e5d40000          LDRB     r0,[r4,#0]
005508  e1a00e80          LSL      r0,r0,#29
00550c  e1b00fa0          LSRS     r0,r0,#31
005510  0a00000d          BEQ      |L1.21836|
005514  e5d40000          LDRB     r0,[r4,#0]
005518  e3100001          TST      r0,#1
00551c  1a00000a          BNE      |L1.21836|
;;;3876   			in->deleted = 1;
005520  e5d40000          LDRB     r0,[r4,#0]
005524  e3800001          ORR      r0,r0,#1
005528  e5c40000          STRB     r0,[r4,#0]
;;;3877   			deleted = 1;
00552c  e3a05001          MOV      r5,#1
;;;3878   			in->my_dev->n_deleted_files++;
005530  e5940008          LDR      r0,[r4,#8]
005534  e5900da4          LDR      r0,[r0,#0xda4]
005538  e2800001          ADD      r0,r0,#1
00553c  e5941008          LDR      r1,[r4,#8]
005540  e5810da4          STR      r0,[r1,#0xda4]
;;;3879   			yaffs_soft_del_file(in);
005544  e1a00004          MOV      r0,r4
005548  ebfffffe          BL       yaffs_soft_del_file
                  |L1.21836|
;;;3880   		}
;;;3881   		return deleted ? YAFFS_OK : YAFFS_FAIL;
00554c  e3550000          CMP      r5,#0
005550  0a000001          BEQ      |L1.21852|
005554  e3a00001          MOV      r0,#1
                  |L1.21848|
;;;3882   	} else {
;;;3883   		/* The file has no data chunks so we toss it immediately */
;;;3884   		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
;;;3885   		in->variant.file_variant.top = NULL;
;;;3886   		yaffs_generic_obj_del(in);
;;;3887   
;;;3888   		return YAFFS_OK;
;;;3889   	}
;;;3890   }
005558  e8bd81f0          POP      {r4-r8,pc}
                  |L1.21852|
00555c  e3a00000          MOV      r0,#0                 ;3881
005560  eafffffc          B        |L1.21848|
                  |L1.21860|
005564  e5940008          LDR      r0,[r4,#8]            ;3884
005568  e5941084          LDR      r1,[r4,#0x84]         ;3884
00556c  ebfffffe          BL       yaffs_free_tnode
005570  e3a00000          MOV      r0,#0                 ;3885
005574  e5840084          STR      r0,[r4,#0x84]         ;3885
005578  e1a00004          MOV      r0,r4                 ;3886
00557c  ebfffffe          BL       yaffs_generic_obj_del
005580  e3a00001          MOV      r0,#1                 ;3888
005584  eafffff3          B        |L1.21848|
;;;3891   
                          ENDP

                  yaffs_del_obj PROC
;;;3924   
;;;3925   int yaffs_del_obj(struct yaffs_obj *obj)
005588  e92d4070          PUSH     {r4-r6,lr}
;;;3926   {
00558c  e1a04000          MOV      r4,r0
;;;3927   	int ret_val = -1;
005590  e3e05000          MVN      r5,#0
;;;3928   
;;;3929   	switch (obj->variant_type) {
005594  e5d40064          LDRB     r0,[r4,#0x64]
005598  e3500006          CMP      r0,#6
00559c  308ff100          ADDCC    pc,pc,r0,LSL #2
0055a0  ea00002d          B        |L1.22108|
0055a4  ea000029          B        |L1.22096|
0055a8  ea000003          B        |L1.21948|
0055ac  ea000018          B        |L1.22036|
0055b0  ea000006          B        |L1.21968|
0055b4  ea00001b          B        |L1.22056|
0055b8  ea00001f          B        |L1.22076|
                  |L1.21948|
;;;3930   	case YAFFS_OBJECT_TYPE_FILE:
0055bc  e1a00000          MOV      r0,r0
;;;3931   		ret_val = yaffs_del_file(obj);
0055c0  e1a00004          MOV      r0,r4
0055c4  ebfffffe          BL       yaffs_del_file
0055c8  e1a05000          MOV      r5,r0
;;;3932   		break;
0055cc  ea000022          B        |L1.22108|
                  |L1.21968|
;;;3933   	case YAFFS_OBJECT_TYPE_DIRECTORY:
0055d0  e1a00000          MOV      r0,r0
;;;3934   		if (!list_empty(&obj->variant.dir_variant.dirty)) {
0055d4  e2840070          ADD      r0,r4,#0x70
0055d8  ebfffffe          BL       list_empty
0055dc  e3500000          CMP      r0,#0
0055e0  1a000008          BNE      |L1.22024|
;;;3935   			yaffs_trace(YAFFS_TRACE_BACKGROUND,
0055e4  e51f0644          LDR      r0,|L1.20392|
0055e8  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
0055ec  e3100602          TST      r0,#0x200000
0055f0  0a000002          BEQ      |L1.22016|
0055f4  e28f00ac          ADR      r0,|L1.22184|
0055f8  e5941030          LDR      r1,[r4,#0x30]
0055fc  ebfffffe          BL       sysprintf
                  |L1.22016|
;;;3936   				"Remove object %d from dirty directories",
;;;3937   				obj->obj_id);
;;;3938   			list_del_init(&obj->variant.dir_variant.dirty);
005600  e2840070          ADD      r0,r4,#0x70
005604  ebfffffe          BL       list_del_init
                  |L1.22024|
;;;3939   		}
;;;3940   		return yaffs_del_dir(obj);
005608  e1a00004          MOV      r0,r4
00560c  ebfffffe          BL       yaffs_del_dir
                  |L1.22032|
;;;3941   // 		break;
;;;3942   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;3943   		ret_val = yaffs_del_symlink(obj);
;;;3944   		break;
;;;3945   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;3946   		ret_val = yaffs_del_link(obj);
;;;3947   		break;
;;;3948   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;3949   		ret_val = yaffs_generic_obj_del(obj);
;;;3950   		break;
;;;3951   	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;3952   		ret_val = 0;
;;;3953   		break;		/* should not happen. */
;;;3954   	}
;;;3955   	return ret_val;
;;;3956   }
005610  e8bd8070          POP      {r4-r6,pc}
                  |L1.22036|
005614  e1a00000          MOV      r0,r0                 ;3942
005618  e1a00004          MOV      r0,r4                 ;3943
00561c  ebfffffe          BL       yaffs_del_symlink
005620  e1a05000          MOV      r5,r0                 ;3943
005624  ea00000c          B        |L1.22108|
                  |L1.22056|
005628  e1a00000          MOV      r0,r0                 ;3945
00562c  e1a00004          MOV      r0,r4                 ;3946
005630  ebfffffe          BL       yaffs_del_link
005634  e1a05000          MOV      r5,r0                 ;3946
005638  ea000007          B        |L1.22108|
                  |L1.22076|
00563c  e1a00000          MOV      r0,r0                 ;3948
005640  e1a00004          MOV      r0,r4                 ;3949
005644  ebfffffe          BL       yaffs_generic_obj_del
005648  e1a05000          MOV      r5,r0                 ;3949
00564c  ea000002          B        |L1.22108|
                  |L1.22096|
005650  e1a00000          MOV      r0,r0                 ;3951
005654  e3a05000          MOV      r5,#0                 ;3952
005658  e1a00000          MOV      r0,r0                 ;3953
                  |L1.22108|
00565c  e1a00000          MOV      r0,r0                 ;3932
005660  e1a00005          MOV      r0,r5                 ;3955
005664  eaffffe9          B        |L1.22032|
                  |L1.22120|
                          DCD      ||.text||+0x2a48
                  |L1.22124|
00566c  79616666          DCB      "yaffs: yaffs: immediate deletion of file %d\n",0
005670  733a2079
005674  61666673
005678  3a20696d
00567c  6d656469
005680  61746520
005684  64656c65
005688  74696f6e
00568c  206f6620
005690  66696c65
005694  2025640a
005698  00      
005699  00                DCB      0
00569a  00                DCB      0
00569b  00                DCB      0
                  |L1.22172|
00569c  756e6c69          DCB      "unlinked",0
0056a0  6e6b6564
0056a4  00      
0056a5  00                DCB      0
0056a6  00                DCB      0
0056a7  00                DCB      0
                  |L1.22184|
0056a8  79616666          DCB      "yaffs: Remove object %d from dirty directories\n",0
0056ac  733a2052
0056b0  656d6f76
0056b4  65206f62
0056b8  6a656374
0056bc  20256420
0056c0  66726f6d
0056c4  20646972
0056c8  74792064
0056cc  69726563
0056d0  746f7269
0056d4  65730a00
                          ENDP

                  yaffs_create_obj PROC
;;;2125   
;;;2126   static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
0056d8  e92d4ffe          PUSH     {r1-r11,lr}
;;;2127   					  struct yaffs_obj *parent,
;;;2128   					  const YCHAR *name,
;;;2129   					  u32 mode,
;;;2130   					  u32 uid,
;;;2131   					  u32 gid,
;;;2132   					  struct yaffs_obj *equiv_obj,
;;;2133   					  const YCHAR *alias_str, u32 rdev)
;;;2134   {
0056dc  e1a05000          MOV      r5,r0
0056e0  e1a06001          MOV      r6,r1
0056e4  e1a09002          MOV      r9,r2
0056e8  e1a0a003          MOV      r10,r3
0056ec  e59d7038          LDR      r7,[sp,#0x38]
0056f0  e59db030          LDR      r11,[sp,#0x30]
;;;2135   	struct yaffs_obj *in;
;;;2136   	YCHAR *str = NULL;
0056f4  e3a08000          MOV      r8,#0
;;;2137   	struct yaffs_dev *dev = parent->my_dev;
0056f8  e5960008          LDR      r0,[r6,#8]
0056fc  e58d0008          STR      r0,[sp,#8]
;;;2138   
;;;2139   	/* Check if the entry exists.
;;;2140   	 * If it does then fail the call since we don't want a dup. */
;;;2141   	if (yaffs_find_by_name(parent, name))
005700  e1a01009          MOV      r1,r9
005704  e1a00006          MOV      r0,r6
005708  ebfffffe          BL       yaffs_find_by_name
00570c  e3500000          CMP      r0,#0
005710  0a000001          BEQ      |L1.22300|
;;;2142   		return NULL;
005714  e3a00000          MOV      r0,#0
                  |L1.22296|
;;;2143   
;;;2144   	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
;;;2145   		str = yaffs_clone_str(alias_str);
;;;2146   		if (!str)
;;;2147   			return NULL;
;;;2148   	}
;;;2149   
;;;2150   	in = yaffs_new_obj(dev, -1, type);
;;;2151   
;;;2152   	if (!in) {
;;;2153   		yaffs_free(str);
;;;2154   		return NULL;
;;;2155   	}
;;;2156   
;;;2157   	in->hdr_chunk = 0;
;;;2158   	in->valid = 1;
;;;2159   	in->variant_type = type;
;;;2160   
;;;2161   	in->yst_mode = mode;
;;;2162   
;;;2163   	yaffs_attribs_init(in, gid, uid, rdev);
;;;2164   
;;;2165   	in->n_data_chunks = 0;
;;;2166   
;;;2167   	yaffs_set_obj_name(in, name);
;;;2168   	in->dirty = 1;
;;;2169   
;;;2170   	yaffs_add_obj_to_dir(parent, in);
;;;2171   
;;;2172   	in->my_dev = parent->my_dev;
;;;2173   
;;;2174   	switch (type) {
;;;2175   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;2176   		in->variant.symlink_variant.alias = str;
;;;2177   		break;
;;;2178   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;2179   		in->variant.hardlink_variant.equiv_obj = equiv_obj;
;;;2180   		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
;;;2181   		list_add(&in->hard_links, &equiv_obj->hard_links);
;;;2182   		break;
;;;2183   	case YAFFS_OBJECT_TYPE_FILE:
;;;2184   	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;2185   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;2186   	case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;2187   		/* do nothing */
;;;2188   		break;
;;;2189   	}
;;;2190   
;;;2191   	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
;;;2192   		/* Could not create the object header, fail */
;;;2193   		yaffs_del_obj(in);
;;;2194   		in = NULL;
;;;2195   	}
;;;2196   
;;;2197   	if (in)
;;;2198   		yaffs_update_parent(parent);
;;;2199   
;;;2200   	return in;
;;;2201   }
005718  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.22300|
00571c  e3550002          CMP      r5,#2                 ;2144
005720  1a000006          BNE      |L1.22336|
005724  e59d003c          LDR      r0,[sp,#0x3c]         ;2145
005728  ebfffffe          BL       yaffs_clone_str
00572c  e1a08000          MOV      r8,r0                 ;2145
005730  e3580000          CMP      r8,#0                 ;2146
005734  1a000001          BNE      |L1.22336|
005738  e3a00000          MOV      r0,#0                 ;2147
00573c  eafffff5          B        |L1.22296|
                  |L1.22336|
005740  e1a02005          MOV      r2,r5                 ;2150
005744  e3e01000          MVN      r1,#0                 ;2150
005748  e59d0008          LDR      r0,[sp,#8]            ;2150
00574c  ebfffffe          BL       yaffs_new_obj
005750  e1a04000          MOV      r4,r0                 ;2150
005754  e3540000          CMP      r4,#0                 ;2152
005758  1a000003          BNE      |L1.22380|
00575c  e1a00008          MOV      r0,r8                 ;2153
005760  ebfffffe          BL       yaffs_free
005764  e3a00000          MOV      r0,#0                 ;2154
005768  eaffffea          B        |L1.22296|
                  |L1.22380|
00576c  e3a00000          MOV      r0,#0                 ;2157
005770  e5840028          STR      r0,[r4,#0x28]         ;2157
005774  e5d40000          LDRB     r0,[r4,#0]            ;2158
005778  e3800080          ORR      r0,r0,#0x80           ;2158
00577c  e5c40000          STRB     r0,[r4,#0]            ;2158
005780  e5c45064          STRB     r5,[r4,#0x64]         ;2159
005784  e584a034          STR      r10,[r4,#0x34]        ;2161
005788  e1a0200b          MOV      r2,r11                ;2163
00578c  e1a00004          MOV      r0,r4                 ;2163
005790  e59d1034          LDR      r1,[sp,#0x34]         ;2163
005794  e59d3040          LDR      r3,[sp,#0x40]         ;2163
005798  ebfffffe          BL       yaffs_attribs_init
00579c  e3a00000          MOV      r0,#0                 ;2165
0057a0  e584002c          STR      r0,[r4,#0x2c]         ;2165
0057a4  e1a01009          MOV      r1,r9                 ;2167
0057a8  e1a00004          MOV      r0,r4                 ;2167
0057ac  ebfffffe          BL       yaffs_set_obj_name
0057b0  e5d40000          LDRB     r0,[r4,#0]            ;2168
0057b4  e3800040          ORR      r0,r0,#0x40           ;2168
0057b8  e5c40000          STRB     r0,[r4,#0]            ;2168
0057bc  e1a01004          MOV      r1,r4                 ;2170
0057c0  e1a00006          MOV      r0,r6                 ;2170
0057c4  ebfffffe          BL       yaffs_add_obj_to_dir
0057c8  e5960008          LDR      r0,[r6,#8]            ;2172
0057cc  e5840008          STR      r0,[r4,#8]            ;2172
0057d0  e3550006          CMP      r5,#6                 ;2174
0057d4  308ff105          ADDCC    pc,pc,r5,LSL #2       ;2174
0057d8  ea000015          B        |L1.22580|
0057dc  ea000013          B        |L1.22576|
0057e0  ea00000e          B        |L1.22560|
0057e4  ea000002          B        |L1.22516|
0057e8  ea00000e          B        |L1.22568|
0057ec  ea000003          B        |L1.22528|
0057f0  ea00000d          B        |L1.22572|
                  |L1.22516|
0057f4  e1a00000          MOV      r0,r0                 ;2175
0057f8  e5848068          STR      r8,[r4,#0x68]         ;2176
0057fc  ea00000c          B        |L1.22580|
                  |L1.22528|
005800  e1a00000          MOV      r0,r0                 ;2178
005804  e5847068          STR      r7,[r4,#0x68]         ;2179
005808  e5970030          LDR      r0,[r7,#0x30]         ;2180
00580c  e584006c          STR      r0,[r4,#0x6c]         ;2180
005810  e2871014          ADD      r1,r7,#0x14           ;2181
005814  e2840014          ADD      r0,r4,#0x14           ;2181
005818  ebfffffe          BL       list_add
00581c  ea000004          B        |L1.22580|
                  |L1.22560|
005820  e1a00000          MOV      r0,r0                 ;2183
005824  e1a00000          MOV      r0,r0                 ;2184
                  |L1.22568|
005828  e1a00000          MOV      r0,r0                 ;2185
                  |L1.22572|
00582c  e1a00000          MOV      r0,r0                 ;2186
                  |L1.22576|
005830  e1a00000          MOV      r0,r0                 ;2188
                  |L1.22580|
005834  e1a00000          MOV      r0,r0                 ;2177
005838  e3a00000          MOV      r0,#0                 ;2191
00583c  e58d0000          STR      r0,[sp,#0]            ;2191
005840  e58d0004          STR      r0,[sp,#4]            ;2191
005844  e1a03000          MOV      r3,r0                 ;2191
005848  e1a02000          MOV      r2,r0                 ;2191
00584c  e1a01009          MOV      r1,r9                 ;2191
005850  e1a00004          MOV      r0,r4                 ;2191
005854  ebfffffe          BL       yaffs_update_oh
005858  e3500000          CMP      r0,#0                 ;2191
00585c  aa000002          BGE      |L1.22636|
005860  e1a00004          MOV      r0,r4                 ;2193
005864  ebfffffe          BL       yaffs_del_obj
005868  e3a04000          MOV      r4,#0                 ;2194
                  |L1.22636|
00586c  e3540000          CMP      r4,#0                 ;2197
005870  0a000001          BEQ      |L1.22652|
005874  e1a00006          MOV      r0,r6                 ;2198
005878  ebfffffe          BL       yaffs_update_parent
                  |L1.22652|
00587c  e1a00004          MOV      r0,r4                 ;2200
005880  eaffffa4          B        |L1.22296|
;;;2202   
                          ENDP

                  yaffs_create_file PROC
;;;2203   struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
005884  e92d41f0          PUSH     {r4-r8,lr}
;;;2204   				    const YCHAR *name, u32 mode, u32 uid,
;;;2205   				    u32 gid)
;;;2206   {
005888  e24dd018          SUB      sp,sp,#0x18
00588c  e1a04000          MOV      r4,r0
005890  e1a05001          MOV      r5,r1
005894  e1a06002          MOV      r6,r2
005898  e1a07003          MOV      r7,r3
00589c  e59d8030          LDR      r8,[sp,#0x30]
;;;2207   	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
0058a0  e3a00000          MOV      r0,#0
0058a4  e58d0008          STR      r0,[sp,#8]
0058a8  e58d8004          STR      r8,[sp,#4]
0058ac  e58d000c          STR      r0,[sp,#0xc]
0058b0  e1a03006          MOV      r3,r6
0058b4  e1a02005          MOV      r2,r5
0058b8  e1a01004          MOV      r1,r4
0058bc  e58d0010          STR      r0,[sp,#0x10]
0058c0  e3a00001          MOV      r0,#1
0058c4  e58d7000          STR      r7,[sp,#0]
0058c8  ebfffffe          BL       yaffs_create_obj
0058cc  e28dd018          ADD      sp,sp,#0x18
;;;2208   				uid, gid, NULL, NULL, 0);
;;;2209   }
0058d0  e8bd81f0          POP      {r4-r8,pc}
;;;2210   
                          ENDP

                  yaffs_create_dir PROC
;;;2211   struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
0058d4  e92d41f0          PUSH     {r4-r8,lr}
;;;2212   				   u32 mode, u32 uid, u32 gid)
;;;2213   {
0058d8  e24dd018          SUB      sp,sp,#0x18
0058dc  e1a04000          MOV      r4,r0
0058e0  e1a05001          MOV      r5,r1
0058e4  e1a06002          MOV      r6,r2
0058e8  e1a07003          MOV      r7,r3
0058ec  e59d8030          LDR      r8,[sp,#0x30]
;;;2214   	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
0058f0  e3a00000          MOV      r0,#0
0058f4  e58d0008          STR      r0,[sp,#8]
0058f8  e58d8004          STR      r8,[sp,#4]
0058fc  e58d000c          STR      r0,[sp,#0xc]
005900  e1a03006          MOV      r3,r6
005904  e1a02005          MOV      r2,r5
005908  e1a01004          MOV      r1,r4
00590c  e58d0010          STR      r0,[sp,#0x10]
005910  e3a00003          MOV      r0,#3
005914  e58d7000          STR      r7,[sp,#0]
005918  ebfffffe          BL       yaffs_create_obj
00591c  e28dd018          ADD      sp,sp,#0x18
;;;2215   				mode, uid, gid, NULL, NULL, 0);
;;;2216   }
005920  e8bd81f0          POP      {r4-r8,pc}
;;;2217   
                          ENDP

                  yaffs_create_special PROC
;;;2218   struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
005924  e92d43f0          PUSH     {r4-r9,lr}
;;;2219   				       const YCHAR *name, u32 mode, u32 uid,
;;;2220   				       u32 gid, u32 rdev)
;;;2221   {
005928  e24dd014          SUB      sp,sp,#0x14
00592c  e1a04000          MOV      r4,r0
005930  e1a05001          MOV      r5,r1
005934  e1a06002          MOV      r6,r2
005938  e1a07003          MOV      r7,r3
00593c  e1cd83d0          LDRD     r8,r9,[sp,#0x30]
;;;2222   	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
005940  e3a00000          MOV      r0,#0
005944  e58d0008          STR      r0,[sp,#8]
005948  e58d8004          STR      r8,[sp,#4]
00594c  e1a03006          MOV      r3,r6
005950  e1a02005          MOV      r2,r5
005954  e1a01004          MOV      r1,r4
005958  e58d000c          STR      r0,[sp,#0xc]
00595c  e58d9010          STR      r9,[sp,#0x10]
005960  e3a00005          MOV      r0,#5
005964  e58d7000          STR      r7,[sp,#0]
005968  ebfffffe          BL       yaffs_create_obj
00596c  e28dd014          ADD      sp,sp,#0x14
;;;2223   				uid, gid, NULL, NULL, rdev);
;;;2224   }
005970  e8bd83f0          POP      {r4-r9,pc}
;;;2225   
                          ENDP

                  yaffs_create_symlink PROC
;;;2226   struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
005974  e92d43f0          PUSH     {r4-r9,lr}
;;;2227   				       const YCHAR *name, u32 mode, u32 uid,
;;;2228   				       u32 gid, const YCHAR *alias)
;;;2229   {
005978  e24dd014          SUB      sp,sp,#0x14
00597c  e1a04000          MOV      r4,r0
005980  e1a05001          MOV      r5,r1
005984  e1a06002          MOV      r6,r2
005988  e1a07003          MOV      r7,r3
00598c  e1cd83d0          LDRD     r8,r9,[sp,#0x30]
;;;2230   	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
005990  e3a00000          MOV      r0,#0
005994  e58d0008          STR      r0,[sp,#8]
005998  e58d900c          STR      r9,[sp,#0xc]
00599c  e58d8004          STR      r8,[sp,#4]
0059a0  e1a03006          MOV      r3,r6
0059a4  e1a02005          MOV      r2,r5
0059a8  e1a01004          MOV      r1,r4
0059ac  e58d0010          STR      r0,[sp,#0x10]
0059b0  e3a00002          MOV      r0,#2
0059b4  e58d7000          STR      r7,[sp,#0]
0059b8  ebfffffe          BL       yaffs_create_obj
0059bc  e28dd014          ADD      sp,sp,#0x14
;;;2231   				uid, gid, NULL, alias, 0);
;;;2232   }
0059c0  e8bd83f0          POP      {r4-r9,pc}
;;;2233   
                          ENDP

                  yaffs_get_equivalent_obj PROC
;;;4381   
;;;4382   struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
0059c4  e92d4010          PUSH     {r4,lr}
;;;4383   {
0059c8  e1a04000          MOV      r4,r0
;;;4384   	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
0059cc  e3540000          CMP      r4,#0
0059d0  0a000005          BEQ      |L1.23020|
0059d4  e5d40064          LDRB     r0,[r4,#0x64]
0059d8  e3500004          CMP      r0,#4
0059dc  1a000002          BNE      |L1.23020|
;;;4385   		obj = obj->variant.hardlink_variant.equiv_obj;
0059e0  e5944068          LDR      r4,[r4,#0x68]
;;;4386   		yaffs_check_obj_details_loaded(obj);
0059e4  e1a00004          MOV      r0,r4
0059e8  ebfffffe          BL       yaffs_check_obj_details_loaded
                  |L1.23020|
;;;4387   	}
;;;4388   	return obj;
0059ec  e1a00004          MOV      r0,r4
;;;4389   }
0059f0  e8bd8010          POP      {r4,pc}
;;;4390   
                          ENDP

                  yaffs_link_obj PROC
;;;2234   /* yaffs_link_obj returns the object id of the equivalent object.*/
;;;2235   struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
0059f4  e92d4070          PUSH     {r4-r6,lr}
;;;2236   				 struct yaffs_obj *equiv_obj)
;;;2237   {
0059f8  e24dd018          SUB      sp,sp,#0x18
0059fc  e1a05000          MOV      r5,r0
005a00  e1a06001          MOV      r6,r1
005a04  e1a04002          MOV      r4,r2
;;;2238   	/* Get the real object in case we were fed a hard link obj */
;;;2239   	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
005a08  e1a00004          MOV      r0,r4
005a0c  ebfffffe          BL       yaffs_get_equivalent_obj
005a10  e1a04000          MOV      r4,r0
;;;2240   
;;;2241   	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
005a14  e3a00000          MOV      r0,#0
005a18  e98d0011          STMIB    sp,{r0,r4}
005a1c  e58d000c          STR      r0,[sp,#0xc]
005a20  e58d0010          STR      r0,[sp,#0x10]
005a24  e58d0000          STR      r0,[sp,#0]
005a28  e1a03000          MOV      r3,r0
005a2c  e1a02006          MOV      r2,r6
005a30  e1a01005          MOV      r1,r5
005a34  e3a00004          MOV      r0,#4
005a38  ebfffffe          BL       yaffs_create_obj
005a3c  e3500000          CMP      r0,#0
005a40  0a000002          BEQ      |L1.23120|
;;;2242   			parent, name, 0, 0, 0,
;;;2243   			equiv_obj, NULL, 0))
;;;2244   		return equiv_obj;
005a44  e1a00004          MOV      r0,r4
                  |L1.23112|
005a48  e28dd018          ADD      sp,sp,#0x18
;;;2245   
;;;2246   	return NULL;
;;;2247   
;;;2248   }
005a4c  e8bd8070          POP      {r4-r6,pc}
                  |L1.23120|
005a50  e3a00000          MOV      r0,#0                 ;2246
005a54  eafffffb          B        |L1.23112|
;;;2249   
                          ENDP

                  yaffs_deinit_blocks PROC
;;;2253   
;;;2254   static void yaffs_deinit_blocks(struct yaffs_dev *dev)
005a58  e92d4010          PUSH     {r4,lr}
;;;2255   {
005a5c  e1a04000          MOV      r4,r0
;;;2256   	if (dev->block_info_alt && dev->block_info)
005a60  e5d40120          LDRB     r0,[r4,#0x120]
005a64  e3100001          TST      r0,#1
005a68  0a000005          BEQ      |L1.23172|
005a6c  e5940118          LDR      r0,[r4,#0x118]
005a70  e3500000          CMP      r0,#0
005a74  0a000002          BEQ      |L1.23172|
;;;2257   		yaffs_free(dev->block_info);
005a78  e5940118          LDR      r0,[r4,#0x118]
005a7c  ebfffffe          BL       yaffs_free
005a80  ea000001          B        |L1.23180|
                  |L1.23172|
;;;2258   	else
;;;2259   		yaffs_free(dev->block_info);
005a84  e5940118          LDR      r0,[r4,#0x118]
005a88  ebfffffe          BL       yaffs_free
                  |L1.23180|
;;;2260   
;;;2261   	dev->block_info_alt = 0;
005a8c  e5940120          LDR      r0,[r4,#0x120]
005a90  e3c00001          BIC      r0,r0,#1
005a94  e5840120          STR      r0,[r4,#0x120]
;;;2262   
;;;2263   	dev->block_info = NULL;
005a98  e3a00000          MOV      r0,#0
005a9c  e5840118          STR      r0,[r4,#0x118]
;;;2264   
;;;2265   	if (dev->chunk_bits_alt && dev->chunk_bits)
005aa0  e5d40120          LDRB     r0,[r4,#0x120]
005aa4  e1a00f00          LSL      r0,r0,#30
005aa8  e1b00fa0          LSRS     r0,r0,#31
005aac  0a000005          BEQ      |L1.23240|
005ab0  e594011c          LDR      r0,[r4,#0x11c]
005ab4  e3500000          CMP      r0,#0
005ab8  0a000002          BEQ      |L1.23240|
;;;2266   		yaffs_free(dev->chunk_bits);
005abc  e594011c          LDR      r0,[r4,#0x11c]
005ac0  ebfffffe          BL       yaffs_free
005ac4  ea000001          B        |L1.23248|
                  |L1.23240|
;;;2267   	else
;;;2268   		yaffs_free(dev->chunk_bits);
005ac8  e594011c          LDR      r0,[r4,#0x11c]
005acc  ebfffffe          BL       yaffs_free
                  |L1.23248|
;;;2269   	dev->chunk_bits_alt = 0;
005ad0  e5940120          LDR      r0,[r4,#0x120]
005ad4  e3c00002          BIC      r0,r0,#2
005ad8  e5840120          STR      r0,[r4,#0x120]
;;;2270   	dev->chunk_bits = NULL;
005adc  e3a00000          MOV      r0,#0
005ae0  e584011c          STR      r0,[r4,#0x11c]
;;;2271   }
005ae4  e8bd8010          POP      {r4,pc}
;;;2272   
                          ENDP

                  yaffs_init_blocks PROC
;;;2273   static int yaffs_init_blocks(struct yaffs_dev *dev)
005ae8  e92d4070          PUSH     {r4-r6,lr}
;;;2274   {
005aec  e1a04000          MOV      r4,r0
;;;2275   	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
005af0  e59400d4          LDR      r0,[r4,#0xd4]
005af4  e59410d0          LDR      r1,[r4,#0xd0]
005af8  e0400001          SUB      r0,r0,r1
005afc  e2805001          ADD      r5,r0,#1
;;;2276   
;;;2277   	dev->block_info = NULL;
005b00  e3a00000          MOV      r0,#0
005b04  e5840118          STR      r0,[r4,#0x118]
;;;2278   	dev->chunk_bits = NULL;
005b08  e584011c          STR      r0,[r4,#0x11c]
;;;2279   	dev->alloc_block = -1;	/* force it to get a new one */
005b0c  e3e00000          MVN      r0,#0
005b10  e584012c          STR      r0,[r4,#0x12c]
;;;2280   
;;;2281   	/* If the first allocation strategy fails, thry the alternate one */
;;;2282   // 	dev->block_info = kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
;;;2283   	dev->block_info = yaffs_malloc(n_blocks * sizeof(struct yaffs_block_info));
005b14  e1a00185          LSL      r0,r5,#3
005b18  ebfffffe          BL       yaffs_malloc
005b1c  e5840118          STR      r0,[r4,#0x118]
;;;2284   	if (!dev->block_info) {
005b20  e5940118          LDR      r0,[r4,#0x118]
005b24  e3500000          CMP      r0,#0
005b28  1a000006          BNE      |L1.23368|
;;;2285   // 		dev->block_info = vmalloc(n_blocks * sizeof(struct yaffs_block_info));
;;;2286   		dev->block_info = yaffs_malloc(n_blocks * sizeof(struct yaffs_block_info));
005b2c  e1a00185          LSL      r0,r5,#3
005b30  ebfffffe          BL       yaffs_malloc
005b34  e5840118          STR      r0,[r4,#0x118]
;;;2287   		dev->block_info_alt = 1;
005b38  e5940120          LDR      r0,[r4,#0x120]
005b3c  e3800001          ORR      r0,r0,#1
005b40  e5840120          STR      r0,[r4,#0x120]
005b44  ea000002          B        |L1.23380|
                  |L1.23368|
;;;2288   	} else {
;;;2289   		dev->block_info_alt = 0;
005b48  e5940120          LDR      r0,[r4,#0x120]
005b4c  e3c00001          BIC      r0,r0,#1
005b50  e5840120          STR      r0,[r4,#0x120]
                  |L1.23380|
;;;2290   	}
;;;2291   
;;;2292   	if (!dev->block_info)
005b54  e5940118          LDR      r0,[r4,#0x118]
005b58  e3500000          CMP      r0,#0
005b5c  1a000000          BNE      |L1.23396|
;;;2293   		goto alloc_error;
005b60  ea000024          B        |L1.23544|
                  |L1.23396|
;;;2294   
;;;2295   	/* Set up dynamic blockinfo stuff. Round up bytes. */
;;;2296   	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
005b64  e594100c          LDR      r1,[r4,#0xc]
005b68  e2810007          ADD      r0,r1,#7
005b6c  e1a01fc0          ASR      r1,r0,#31
005b70  e0801ea1          ADD      r1,r0,r1,LSR #29
005b74  e1a011c1          ASR      r1,r1,#3
005b78  e5841124          STR      r1,[r4,#0x124]
;;;2297   // 	dev->chunk_bits = kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
;;;2298   	dev->chunk_bits = yaffs_malloc(dev->chunk_bit_stride * n_blocks);
005b7c  e5941124          LDR      r1,[r4,#0x124]
005b80  e0000591          MUL      r0,r1,r5
005b84  ebfffffe          BL       yaffs_malloc
005b88  e584011c          STR      r0,[r4,#0x11c]
;;;2299   	if (!dev->chunk_bits) {
005b8c  e594011c          LDR      r0,[r4,#0x11c]
005b90  e3500000          CMP      r0,#0
005b94  1a000007          BNE      |L1.23480|
;;;2300   // 		dev->chunk_bits = vmalloc(dev->chunk_bit_stride * n_blocks);
;;;2301   		dev->chunk_bits = yaffs_malloc(dev->chunk_bit_stride * n_blocks);
005b98  e5941124          LDR      r1,[r4,#0x124]
005b9c  e0000591          MUL      r0,r1,r5
005ba0  ebfffffe          BL       yaffs_malloc
005ba4  e584011c          STR      r0,[r4,#0x11c]
;;;2302   		dev->chunk_bits_alt = 1;
005ba8  e5940120          LDR      r0,[r4,#0x120]
005bac  e3800002          ORR      r0,r0,#2
005bb0  e5840120          STR      r0,[r4,#0x120]
005bb4  ea000002          B        |L1.23492|
                  |L1.23480|
;;;2303   	} else {
;;;2304   		dev->chunk_bits_alt = 0;
005bb8  e5940120          LDR      r0,[r4,#0x120]
005bbc  e3c00002          BIC      r0,r0,#2
005bc0  e5840120          STR      r0,[r4,#0x120]
                  |L1.23492|
;;;2305   	}
;;;2306   	if (!dev->chunk_bits)
005bc4  e594011c          LDR      r0,[r4,#0x11c]
005bc8  e3500000          CMP      r0,#0
005bcc  1a000000          BNE      |L1.23508|
;;;2307   		goto alloc_error;
005bd0  ea000008          B        |L1.23544|
                  |L1.23508|
;;;2308   
;;;2309   	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
005bd4  e1a01185          LSL      r1,r5,#3
005bd8  e5940118          LDR      r0,[r4,#0x118]
005bdc  ebfffffe          BL       __aeabi_memclr4
;;;2310   	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
005be0  e5942124          LDR      r2,[r4,#0x124]
005be4  e0010592          MUL      r1,r2,r5
005be8  e594011c          LDR      r0,[r4,#0x11c]
005bec  ebfffffe          BL       __aeabi_memclr
;;;2311   	return YAFFS_OK;
005bf0  e3a00001          MOV      r0,#1
                  |L1.23540|
;;;2312   
;;;2313   alloc_error:
;;;2314   	yaffs_deinit_blocks(dev);
;;;2315   	return YAFFS_FAIL;
;;;2316   }
005bf4  e8bd8070          POP      {r4-r6,pc}
                  |L1.23544|
005bf8  e1a00000          MOV      r0,r0                 ;2313
005bfc  e1a00004          MOV      r0,r4                 ;2314
005c00  ebfffffe          BL       yaffs_deinit_blocks
005c04  e3a00000          MOV      r0,#0                 ;2315
005c08  eafffff9          B        |L1.23540|
;;;2317   
                          ENDP

                  yaffs_bg_gc PROC
;;;2907    */
;;;2908   int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
005c0c  e92d4070          PUSH     {r4-r6,lr}
;;;2909   {
005c10  e1a04000          MOV      r4,r0
005c14  e1a05001          MOV      r5,r1
;;;2910   	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
005c18  e5940128          LDR      r0,[r4,#0x128]
005c1c  e594100c          LDR      r1,[r4,#0xc]
005c20  e0060190          MUL      r6,r0,r1
;;;2911   
;;;2912   	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
005c24  e51f0c84          LDR      r0,|L1.20392|
005c28  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
005c2c  e3100602          TST      r0,#0x200000
005c30  0a000002          BEQ      |L1.23616|
005c34  e1a01005          MOV      r1,r5
005c38  e28f0f87          ADR      r0,|L1.24156|
005c3c  ebfffffe          BL       sysprintf
                  |L1.23616|
;;;2913   
;;;2914   	yaffs_check_gc(dev, 1);
005c40  e3a01001          MOV      r1,#1
005c44  e1a00004          MOV      r0,r4
005c48  ebfffffe          BL       yaffs_check_gc
;;;2915   	return erased_chunks > dev->n_free_chunks / 2;
005c4c  e5941d4c          LDR      r1,[r4,#0xd4c]
005c50  e0810fa1          ADD      r0,r1,r1,LSR #31
005c54  e15600c0          CMP      r6,r0,ASR #1
005c58  da000001          BLE      |L1.23652|
005c5c  e3a00001          MOV      r0,#1
                  |L1.23648|
;;;2916   }
005c60  e8bd8070          POP      {r4-r6,pc}
                  |L1.23652|
005c64  e3a00000          MOV      r0,#0                 ;2915
005c68  eafffffc          B        |L1.23648|
;;;2917   
                          ENDP

                  yaffs_do_xattrib_mod PROC
;;;3053   
;;;3054   static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
005c6c  e92d47f0          PUSH     {r4-r10,lr}
;;;3055   				const YCHAR *name, const void *value, int size,
;;;3056   				int flags)
;;;3057   {
005c70  e24dd020          SUB      sp,sp,#0x20
005c74  e1a07000          MOV      r7,r0
005c78  e1a04001          MOV      r4,r1
005c7c  e1a05002          MOV      r5,r2
005c80  e1a06003          MOV      r6,r3
005c84  e1cd84d0          LDRD     r8,r9,[sp,#0x40]
;;;3058   	struct yaffs_xattr_mod xmod;
;;;3059   	int result;
;;;3060   
;;;3061   	xmod.set = set;
005c88  e58d4008          STR      r4,[sp,#8]
;;;3062   	xmod.name = name;
005c8c  e58d500c          STR      r5,[sp,#0xc]
;;;3063   	xmod.data = value;
005c90  e58d6010          STR      r6,[sp,#0x10]
;;;3064   	xmod.size = size;
005c94  e58d8014          STR      r8,[sp,#0x14]
;;;3065   	xmod.flags = flags;
005c98  e58d9018          STR      r9,[sp,#0x18]
;;;3066   	xmod.result = -ENOSPC;
005c9c  e3e0001b          MVN      r0,#0x1b
005ca0  e58d001c          STR      r0,[sp,#0x1c]
;;;3067   
;;;3068   	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
005ca4  e28d0008          ADD      r0,sp,#8
005ca8  e3a01000          MOV      r1,#0
005cac  e58d1000          STR      r1,[sp,#0]
005cb0  e1a03001          MOV      r3,r1
005cb4  e1a02001          MOV      r2,r1
005cb8  e58d0004          STR      r0,[sp,#4]
005cbc  e1a00007          MOV      r0,r7
005cc0  ebfffffe          BL       yaffs_update_oh
005cc4  e1a0a000          MOV      r10,r0
;;;3069   
;;;3070   	if (result > 0)
005cc8  e35a0000          CMP      r10,#0
005ccc  da000002          BLE      |L1.23772|
;;;3071   		return xmod.result;
005cd0  e59d001c          LDR      r0,[sp,#0x1c]
                  |L1.23764|
005cd4  e28dd020          ADD      sp,sp,#0x20
;;;3072   	else
;;;3073   		return -ENOSPC;
;;;3074   }
005cd8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.23772|
005cdc  e3e0001b          MVN      r0,#0x1b              ;3073
005ce0  eafffffb          B        |L1.23764|
;;;3075   
                          ENDP

                  yaffs_do_xattrib_fetch PROC
;;;3098   
;;;3099   static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
005ce4  e92d4ff0          PUSH     {r4-r11,lr}
;;;3100   				  void *value, int size)
;;;3101   {
005ce8  e24dd05c          SUB      sp,sp,#0x5c
005cec  e1a04000          MOV      r4,r0
005cf0  e1a05001          MOV      r5,r1
005cf4  e1a08002          MOV      r8,r2
005cf8  e1a09003          MOV      r9,r3
;;;3102   	char *buffer = NULL;
005cfc  e3a06000          MOV      r6,#0
;;;3103   	int result;
;;;3104   	struct yaffs_ext_tags tags;
;;;3105   	struct yaffs_dev *dev = obj->my_dev;
005d00  e594a008          LDR      r10,[r4,#8]
;;;3106   	int x_offs = sizeof(struct yaffs_obj_hdr);
005d04  e3a00c02          MOV      r0,#0x200
005d08  e58d000c          STR      r0,[sp,#0xc]
;;;3107   	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
005d0c  e59a00a4          LDR      r0,[r10,#0xa4]
005d10  e2400c02          SUB      r0,r0,#0x200
005d14  e58d0008          STR      r0,[sp,#8]
;;;3108   	char *x_buffer;
;;;3109   	int retval = 0;
005d18  e3a00000          MOV      r0,#0
005d1c  e58d0004          STR      r0,[sp,#4]
;;;3110   
;;;3111   	if (obj->hdr_chunk < 1)
005d20  e5940028          LDR      r0,[r4,#0x28]
005d24  e3500001          CMP      r0,#1
005d28  aa000002          BGE      |L1.23864|
;;;3112   		return -ENODATA;
005d2c  e3e0003c          MVN      r0,#0x3c
                  |L1.23856|
005d30  e28dd05c          ADD      sp,sp,#0x5c
;;;3113   
;;;3114   	/* If we know that the object has no xattribs then don't do all the
;;;3115   	 * reading and parsing.
;;;3116   	 */
;;;3117   	if (obj->xattr_known && !obj->has_xattr) {
;;;3118   		if (name)
;;;3119   			return -ENODATA;
;;;3120   		else
;;;3121   			return 0;
;;;3122   	}
;;;3123   
;;;3124   	buffer = (char *)yaffs_get_temp_buffer(dev);
;;;3125   	if (!buffer)
;;;3126   		return -ENOMEM;
;;;3127   
;;;3128   	result =
;;;3129   	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
;;;3130   
;;;3131   	if (result != YAFFS_OK)
;;;3132   		retval = -ENOENT;
;;;3133   	else {
;;;3134   		x_buffer = buffer + x_offs;
;;;3135   
;;;3136   		if (!obj->xattr_known) {
;;;3137   			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
;;;3138   			obj->xattr_known = 1;
;;;3139   		}
;;;3140   
;;;3141   		if (name)
;;;3142   			retval = nval_get(x_buffer, x_size, name, value, size);
;;;3143   		else
;;;3144   			retval = nval_list(x_buffer, x_size, value, size);
;;;3145   	}
;;;3146   	yaffs_release_temp_buffer(dev, (u8 *) buffer);
;;;3147   	return retval;
;;;3148   }
005d34  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.23864|
005d38  e5d40001          LDRB     r0,[r4,#1]            ;3117
005d3c  e1a00d80          LSL      r0,r0,#27             ;3117
005d40  e1b00fa0          LSRS     r0,r0,#31             ;3117
005d44  0a000009          BEQ      |L1.23920|
005d48  e5d40001          LDRB     r0,[r4,#1]            ;3117
005d4c  e1a00d00          LSL      r0,r0,#26             ;3117
005d50  e1b00fa0          LSRS     r0,r0,#31             ;3117
005d54  1a000005          BNE      |L1.23920|
005d58  e3550000          CMP      r5,#0                 ;3118
005d5c  0a000001          BEQ      |L1.23912|
005d60  e3e0003c          MVN      r0,#0x3c              ;3119
005d64  eafffff1          B        |L1.23856|
                  |L1.23912|
005d68  e3a00000          MOV      r0,#0                 ;3121
005d6c  eaffffef          B        |L1.23856|
                  |L1.23920|
005d70  e1a0000a          MOV      r0,r10                ;3124
005d74  ebfffffe          BL       yaffs_get_temp_buffer
005d78  e1a06000          MOV      r6,r0                 ;3124
005d7c  e3560000          CMP      r6,#0                 ;3125
005d80  1a000001          BNE      |L1.23948|
005d84  e3e0000b          MVN      r0,#0xb               ;3126
005d88  eaffffe8          B        |L1.23856|
                  |L1.23948|
005d8c  e28d3010          ADD      r3,sp,#0x10           ;3128
005d90  e1a02006          MOV      r2,r6                 ;3128
005d94  e1a0000a          MOV      r0,r10                ;3128
005d98  e5941028          LDR      r1,[r4,#0x28]         ;3128
005d9c  ebfffffe          BL       yaffs_rd_chunk_tags_nand
005da0  e1a07000          MOV      r7,r0                 ;3128
005da4  e3570001          CMP      r7,#1                 ;3131
005da8  0a000002          BEQ      |L1.23992|
005dac  e3e00001          MVN      r0,#1                 ;3132
005db0  e58d0004          STR      r0,[sp,#4]            ;3132
005db4  ea000023          B        |L1.24136|
                  |L1.23992|
005db8  e59d000c          LDR      r0,[sp,#0xc]          ;3134
005dbc  e086b000          ADD      r11,r6,r0             ;3134
005dc0  e5d40001          LDRB     r0,[r4,#1]            ;3136
005dc4  e1a00d80          LSL      r0,r0,#27             ;3136
005dc8  e1b00fa0          LSRS     r0,r0,#31             ;3136
005dcc  1a00000d          BNE      |L1.24072|
005dd0  e1a0000b          MOV      r0,r11                ;3137
005dd4  e59d1008          LDR      r1,[sp,#8]            ;3137
005dd8  ebfffffe          BL       nval_hasvalues
005ddc  e3a01020          MOV      r1,#0x20              ;3137
005de0  e0010280          AND      r0,r1,r0,LSL #5       ;3137
005de4  e58d0000          STR      r0,[sp,#0]            ;3137
005de8  e5d40001          LDRB     r0,[r4,#1]            ;3137
005dec  e3c01020          BIC      r1,r0,#0x20           ;3137
005df0  e59d0000          LDR      r0,[sp,#0]            ;3137
005df4  e1800001          ORR      r0,r0,r1              ;3137
005df8  e5c40001          STRB     r0,[r4,#1]            ;3137
005dfc  e5d40001          LDRB     r0,[r4,#1]            ;3138
005e00  e3800010          ORR      r0,r0,#0x10           ;3138
005e04  e5c40001          STRB     r0,[r4,#1]            ;3138
                  |L1.24072|
005e08  e3550000          CMP      r5,#0                 ;3141
005e0c  0a000007          BEQ      |L1.24112|
005e10  e1a03008          MOV      r3,r8                 ;3142
005e14  e1a02005          MOV      r2,r5                 ;3142
005e18  e58d9000          STR      r9,[sp,#0]            ;3142
005e1c  e1a0000b          MOV      r0,r11                ;3142
005e20  e59d1008          LDR      r1,[sp,#8]            ;3142
005e24  ebfffffe          BL       nval_get
005e28  e58d0004          STR      r0,[sp,#4]            ;3142
005e2c  ea000005          B        |L1.24136|
                  |L1.24112|
005e30  e1a03009          MOV      r3,r9                 ;3144
005e34  e1a02008          MOV      r2,r8                 ;3144
005e38  e1a0000b          MOV      r0,r11                ;3144
005e3c  e59d1008          LDR      r1,[sp,#8]            ;3144
005e40  ebfffffe          BL       nval_list
005e44  e58d0004          STR      r0,[sp,#4]            ;3144
                  |L1.24136|
005e48  e1a01006          MOV      r1,r6                 ;3146
005e4c  e1a0000a          MOV      r0,r10                ;3146
005e50  ebfffffe          BL       yaffs_release_temp_buffer
005e54  e59d0004          LDR      r0,[sp,#4]            ;3147
005e58  eaffffb4          B        |L1.23856|
                  |L1.24156|
005e5c  79616666          DCB      "yaffs: Background gc %u\n",0
005e60  733a2042
005e64  61636b67
005e68  726f756e
005e6c  64206763
005e70  2025750a
005e74  00      
005e75  00                DCB      0
005e76  00                DCB      0
005e77  00                DCB      0
                          ENDP

                  yaffs_set_xattrib PROC
;;;3149   
;;;3150   int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
005e78  e92d41fc          PUSH     {r2-r8,lr}
;;;3151   		      const void *value, int size, int flags)
;;;3152   {
005e7c  e1a07000          MOV      r7,r0
005e80  e1a04001          MOV      r4,r1
005e84  e1a05002          MOV      r5,r2
005e88  e1a06003          MOV      r6,r3
005e8c  e59d8020          LDR      r8,[sp,#0x20]
;;;3153   	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
005e90  e1a03005          MOV      r3,r5
005e94  e1a02004          MOV      r2,r4
005e98  e3a01001          MOV      r1,#1
005e9c  e1a00007          MOV      r0,r7
005ea0  e88d0140          STM      sp,{r6,r8}
005ea4  ebfffffe          BL       yaffs_do_xattrib_mod
;;;3154   }
005ea8  e8bd81fc          POP      {r2-r8,pc}
;;;3155   
                          ENDP

                  yaffs_remove_xattrib PROC
;;;3156   int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
005eac  e92d407c          PUSH     {r2-r6,lr}
;;;3157   {
005eb0  e1a05000          MOV      r5,r0
005eb4  e1a04001          MOV      r4,r1
;;;3158   	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
005eb8  e3a00000          MOV      r0,#0
005ebc  e58d0000          STR      r0,[sp,#0]
005ec0  e58d0004          STR      r0,[sp,#4]
005ec4  e1a03000          MOV      r3,r0
005ec8  e1a02004          MOV      r2,r4
005ecc  e1a01000          MOV      r1,r0
005ed0  e1a00005          MOV      r0,r5
005ed4  ebfffffe          BL       yaffs_do_xattrib_mod
;;;3159   }
005ed8  e8bd807c          POP      {r2-r6,pc}
;;;3160   
                          ENDP

                  yaffs_get_xattrib PROC
;;;3161   int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
005edc  e92d41f0          PUSH     {r4-r8,lr}
;;;3162   		      int size)
;;;3163   {
005ee0  e1a04000          MOV      r4,r0
005ee4  e1a05001          MOV      r5,r1
005ee8  e1a06002          MOV      r6,r2
005eec  e1a07003          MOV      r7,r3
;;;3164   	return yaffs_do_xattrib_fetch(obj, name, value, size);
005ef0  e1a03007          MOV      r3,r7
005ef4  e1a02006          MOV      r2,r6
005ef8  e1a01005          MOV      r1,r5
005efc  e1a00004          MOV      r0,r4
005f00  ebfffffe          BL       yaffs_do_xattrib_fetch
;;;3165   }
005f04  e8bd81f0          POP      {r4-r8,pc}
;;;3166   
                          ENDP

                  yaffs_list_xattrib PROC
;;;3167   int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
005f08  e92d4070          PUSH     {r4-r6,lr}
;;;3168   {
005f0c  e1a06000          MOV      r6,r0
005f10  e1a04001          MOV      r4,r1
005f14  e1a05002          MOV      r5,r2
;;;3169   	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
005f18  e1a03005          MOV      r3,r5
005f1c  e1a02004          MOV      r2,r4
005f20  e3a01000          MOV      r1,#0
005f24  e1a00006          MOV      r0,r6
005f28  ebfffffe          BL       yaffs_do_xattrib_fetch
;;;3170   }
005f2c  e8bd8070          POP      {r4-r6,pc}
;;;3171   
                          ENDP

                  yaffs_file_rd PROC
;;;3428   
;;;3429   int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
005f30  e92d5fff          PUSH     {r0-r12,lr}
;;;3430   {
005f34  e24dd010          SUB      sp,sp,#0x10
005f38  e1a07000          MOV      r7,r0
005f3c  e1a08001          MOV      r8,r1
;;;3431   	int chunk;
;;;3432   	u32 start;
;;;3433   	int n_copy;
;;;3434   	int n = n_bytes;
005f40  e59d9048          LDR      r9,[sp,#0x48]
;;;3435   	int n_done = 0;
005f44  e3a0b000          MOV      r11,#0
;;;3436   	struct yaffs_cache *cache;
;;;3437   	struct yaffs_dev *dev;
;;;3438   
;;;3439   	dev = in->my_dev;
005f48  e5976008          LDR      r6,[r7,#8]
;;;3440   
;;;3441   	while (n > 0) {
005f4c  ea00005d          B        |L1.24776|
                  |L1.24400|
;;;3442   		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
005f50  e28d0008          ADD      r0,sp,#8
005f54  e28d100c          ADD      r1,sp,#0xc
005f58  e58d0004          STR      r0,[sp,#4]
005f5c  e58d1000          STR      r1,[sp,#0]
005f60  e1a00006          MOV      r0,r6
005f64  e1cd21d8          LDRD     r2,r3,[sp,#0x18]
005f68  ebfffffe          BL       yaffs_addr_to_chunk
;;;3443   		chunk++;
005f6c  e59d000c          LDR      r0,[sp,#0xc]
005f70  e2800001          ADD      r0,r0,#1
005f74  e58d000c          STR      r0,[sp,#0xc]
;;;3444   
;;;3445   		/* OK now check for the curveball where the start and end are in
;;;3446   		 * the same chunk.
;;;3447   		 */
;;;3448   		if ((start + n) < dev->data_bytes_per_chunk)
005f78  e59d0008          LDR      r0,[sp,#8]
005f7c  e0800009          ADD      r0,r0,r9
005f80  e59610a4          LDR      r1,[r6,#0xa4]
005f84  e1500001          CMP      r0,r1
005f88  2a000001          BCS      |L1.24468|
;;;3449   			n_copy = n;
005f8c  e1a05009          MOV      r5,r9
005f90  ea000002          B        |L1.24480|
                  |L1.24468|
;;;3450   		else
;;;3451   			n_copy = dev->data_bytes_per_chunk - start;
005f94  e59600a4          LDR      r0,[r6,#0xa4]
005f98  e59d1008          LDR      r1,[sp,#8]
005f9c  e0405001          SUB      r5,r0,r1
                  |L1.24480|
;;;3452   
;;;3453   		cache = yaffs_find_chunk_cache(in, chunk);
005fa0  e1a00007          MOV      r0,r7
005fa4  e59d100c          LDR      r1,[sp,#0xc]
005fa8  ebfffffe          BL       yaffs_find_chunk_cache
005fac  e1a04000          MOV      r4,r0
;;;3454   
;;;3455   		/* If the chunk is already in the cache or it is less than
;;;3456   		 * a whole chunk or we're using inband tags then use the cache
;;;3457   		 * (if there is caching) else bypass the cache.
;;;3458   		 */
;;;3459   		if (cache || n_copy != dev->data_bytes_per_chunk ||
005fb0  e3540000          CMP      r4,#0
005fb4  1a000005          BNE      |L1.24528|
005fb8  e59600a4          LDR      r0,[r6,#0xa4]
005fbc  e1500005          CMP      r0,r5
005fc0  1a000002          BNE      |L1.24528|
;;;3460   		    dev->param.inband_tags) {
005fc4  e5960004          LDR      r0,[r6,#4]
005fc8  e3500000          CMP      r0,#0
005fcc  0a000032          BEQ      |L1.24732|
                  |L1.24528|
;;;3461   			if (dev->param.n_caches > 0) {
005fd0  e5960020          LDR      r0,[r6,#0x20]
005fd4  e3500000          CMP      r0,#0
005fd8  da00001f          BLE      |L1.24668|
;;;3462   
;;;3463   				/* If we can't find the data in the cache,
;;;3464   				 * then load it up. */
;;;3465   
;;;3466   				if (!cache) {
005fdc  e3540000          CMP      r4,#0
005fe0  1a00000e          BNE      |L1.24608|
;;;3467   					cache =
005fe4  e5970008          LDR      r0,[r7,#8]
005fe8  ebfffffe          BL       yaffs_grab_chunk_cache
005fec  e1a04000          MOV      r4,r0
;;;3468   					    yaffs_grab_chunk_cache(in->my_dev);
;;;3469   					cache->object = in;
005ff0  e5847000          STR      r7,[r4,#0]
;;;3470   					cache->chunk_id = chunk;
005ff4  e59d000c          LDR      r0,[sp,#0xc]
005ff8  e5840004          STR      r0,[r4,#4]
;;;3471   					cache->dirty = 0;
005ffc  e3a00000          MOV      r0,#0
006000  e584000c          STR      r0,[r4,#0xc]
;;;3472   					cache->locked = 0;
006004  e5840014          STR      r0,[r4,#0x14]
;;;3473   					yaffs_rd_data_obj(in, chunk,
006008  e5942018          LDR      r2,[r4,#0x18]
00600c  e1a00007          MOV      r0,r7
006010  e59d100c          LDR      r1,[sp,#0xc]
006014  ebfffffe          BL       yaffs_rd_data_obj
;;;3474   							  cache->data);
;;;3475   					cache->n_bytes = 0;
006018  e3a00000          MOV      r0,#0
00601c  e5840010          STR      r0,[r4,#0x10]
                  |L1.24608|
;;;3476   				}
;;;3477   
;;;3478   				yaffs_use_cache(dev, cache, 0);
006020  e3a02000          MOV      r2,#0
006024  e1a01004          MOV      r1,r4
006028  e1a00006          MOV      r0,r6
00602c  ebfffffe          BL       yaffs_use_cache
;;;3479   
;;;3480   				cache->locked = 1;
006030  e3a00001          MOV      r0,#1
006034  e5840014          STR      r0,[r4,#0x14]
;;;3481   
;;;3482   				memcpy(buffer, &cache->data[start], n_copy);
006038  e5940018          LDR      r0,[r4,#0x18]
00603c  e59d2008          LDR      r2,[sp,#8]
006040  e0801002          ADD      r1,r0,r2
006044  e1a02005          MOV      r2,r5
006048  e1a00008          MOV      r0,r8
00604c  ebfffffe          BL       __aeabi_memcpy
;;;3483   
;;;3484   				cache->locked = 0;
006050  e3a00000          MOV      r0,#0
006054  e5840014          STR      r0,[r4,#0x14]
006058  ea000013          B        |L1.24748|
                  |L1.24668|
;;;3485   			} else {
;;;3486   				/* Read into the local buffer then copy.. */
;;;3487   
;;;3488   				u8 *local_buffer =
00605c  e1a00006          MOV      r0,r6
006060  ebfffffe          BL       yaffs_get_temp_buffer
006064  e1a0a000          MOV      r10,r0
;;;3489   				    yaffs_get_temp_buffer(dev);
;;;3490   				yaffs_rd_data_obj(in, chunk, local_buffer);
006068  e1a0200a          MOV      r2,r10
00606c  e1a00007          MOV      r0,r7
006070  e59d100c          LDR      r1,[sp,#0xc]
006074  ebfffffe          BL       yaffs_rd_data_obj
;;;3491   
;;;3492   				memcpy(buffer, &local_buffer[start], n_copy);
006078  e59d0008          LDR      r0,[sp,#8]
00607c  e08a1000          ADD      r1,r10,r0
006080  e1a02005          MOV      r2,r5
006084  e1a00008          MOV      r0,r8
006088  ebfffffe          BL       __aeabi_memcpy
;;;3493   
;;;3494   				yaffs_release_temp_buffer(dev, local_buffer);
00608c  e1a0100a          MOV      r1,r10
006090  e1a00006          MOV      r0,r6
006094  ebfffffe          BL       yaffs_release_temp_buffer
;;;3495   			}
006098  ea000003          B        |L1.24748|
                  |L1.24732|
;;;3496   		} else {
;;;3497   			/* A full chunk. Read directly into the buffer. */
;;;3498   			yaffs_rd_data_obj(in, chunk, buffer);
00609c  e1a02008          MOV      r2,r8
0060a0  e1a00007          MOV      r0,r7
0060a4  e59d100c          LDR      r1,[sp,#0xc]
0060a8  ebfffffe          BL       yaffs_rd_data_obj
                  |L1.24748|
;;;3499   		}
;;;3500   		n -= n_copy;
0060ac  e0499005          SUB      r9,r9,r5
;;;3501   		offset += n_copy;
0060b0  e1cd01d8          LDRD     r0,r1,[sp,#0x18]
0060b4  e0900005          ADDS     r0,r0,r5
0060b8  e0a11fc5          ADC      r1,r1,r5,ASR #31
0060bc  e1cd01f8          STRD     r0,r1,[sp,#0x18]
;;;3502   		buffer += n_copy;
0060c0  e0888005          ADD      r8,r8,r5
;;;3503   		n_done += n_copy;
0060c4  e08bb005          ADD      r11,r11,r5
                  |L1.24776|
0060c8  e3590000          CMP      r9,#0                 ;3441
0060cc  caffff9f          BGT      |L1.24400|
;;;3504   	}
;;;3505   	return n_done;
0060d0  e1a0000b          MOV      r0,r11
0060d4  e28dd020          ADD      sp,sp,#0x20
;;;3506   }
0060d8  e8bd9ff0          POP      {r4-r12,pc}
;;;3507   
                          ENDP

                  yaffs_do_file_wr PROC
;;;3508   int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
0060dc  e92d5fff          PUSH     {r0-r12,lr}
;;;3509   		     int n_bytes, int write_through)
;;;3510   {
0060e0  e24dd030          SUB      sp,sp,#0x30
0060e4  e1a06000          MOV      r6,r0
0060e8  e1a07002          MOV      r7,r2
0060ec  e1a08003          MOV      r8,r3
;;;3511   
;;;3512   	int chunk;
;;;3513   	u32 start;
;;;3514   	int n_copy;
;;;3515   	int n = n_bytes;
0060f0  e59db068          LDR      r11,[sp,#0x68]
;;;3516   	int n_done = 0;
0060f4  e3a0a000          MOV      r10,#0
;;;3517   	int n_writeback;
;;;3518   	loff_t start_write = offset;
0060f8  e58d7018          STR      r7,[sp,#0x18]
0060fc  e58d801c          STR      r8,[sp,#0x1c]
;;;3519   	int chunk_written = 0;
006100  e3a00000          MOV      r0,#0
006104  e58d0014          STR      r0,[sp,#0x14]
;;;3520   	u32 n_bytes_read;
;;;3521   	loff_t chunk_start;
;;;3522   	struct yaffs_dev *dev;
;;;3523   
;;;3524   	dev = in->my_dev;
006108  e5965008          LDR      r5,[r6,#8]
;;;3525   
;;;3526   	while (n > 0 && chunk_written >= 0) {
00610c  ea0000da          B        |L1.25724|
                  |L1.24848|
;;;3527   		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
006110  e28d0028          ADD      r0,sp,#0x28
006114  e28d102c          ADD      r1,sp,#0x2c
006118  e1a02007          MOV      r2,r7
00611c  e1a03008          MOV      r3,r8
006120  e58d0004          STR      r0,[sp,#4]
006124  e1a00005          MOV      r0,r5
006128  e58d1000          STR      r1,[sp,#0]
00612c  ebfffffe          BL       yaffs_addr_to_chunk
;;;3528   
;;;3529   		if (((loff_t)chunk) *
006130  e59d002c          LDR      r0,[sp,#0x2c]
006134  e59510a4          LDR      r1,[r5,#0xa4]
006138  e0c32190          SMULL    r2,r3,r0,r1
00613c  e59d0028          LDR      r0,[sp,#0x28]
006140  e0900002          ADDS     r0,r0,r2
006144  e2a31000          ADC      r1,r3,#0
006148  e0200007          EOR      r0,r0,r7
00614c  e0211008          EOR      r1,r1,r8
006150  e1900001          ORRS     r0,r0,r1
006154  1a000003          BNE      |L1.24936|
;;;3530   		    dev->data_bytes_per_chunk + start != offset ||
;;;3531   		    start >= dev->data_bytes_per_chunk) {
006158  e59500a4          LDR      r0,[r5,#0xa4]
00615c  e59d1028          LDR      r1,[sp,#0x28]
006160  e1500001          CMP      r0,r1
006164  8a00000a          BHI      |L1.24980|
                  |L1.24936|
;;;3532   			yaffs_trace(YAFFS_TRACE_ERROR,
006168  e59f036c          LDR      r0,|L1.25820|
00616c  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
006170  e3100101          TST      r0,#0x40000000
006174  0a000006          BEQ      |L1.24980|
006178  e59d002c          LDR      r0,[sp,#0x2c]
00617c  e59d1028          LDR      r1,[sp,#0x28]
006180  e1a02007          MOV      r2,r7
006184  e1a03008          MOV      r3,r8
006188  e1cd00f0          STRD     r0,r1,[sp,#0]
00618c  e28f0fd3          ADR      r0,|L1.25824|
006190  ebfffffe          BL       sysprintf
                  |L1.24980|
;;;3533   				"AddrToChunk of offset %lld gives chunk %d start %d",
;;;3534   				offset, chunk, start);
;;;3535   		}
;;;3536   		chunk++;	/* File pos to chunk in file offset */
006194  e59d002c          LDR      r0,[sp,#0x2c]
006198  e2800001          ADD      r0,r0,#1
00619c  e58d002c          STR      r0,[sp,#0x2c]
;;;3537   
;;;3538   		/* OK now check for the curveball where the start and end are in
;;;3539   		 * the same chunk.
;;;3540   		 */
;;;3541   
;;;3542   		if ((start + n) < dev->data_bytes_per_chunk) {
0061a0  e59d0028          LDR      r0,[sp,#0x28]
0061a4  e080000b          ADD      r0,r0,r11
0061a8  e59510a4          LDR      r1,[r5,#0xa4]
0061ac  e1500001          CMP      r0,r1
0061b0  2a000030          BCS      |L1.25208|
;;;3543   			n_copy = n;
0061b4  e1a0900b          MOV      r9,r11
;;;3544   
;;;3545   			/* Now calculate how many bytes to write back....
;;;3546   			 * If we're overwriting and not writing to then end of
;;;3547   			 * file then we need to write back as much as was there
;;;3548   			 * before.
;;;3549   			 */
;;;3550   
;;;3551   			chunk_start = (((loff_t)(chunk - 1)) *
0061b8  e59d002c          LDR      r0,[sp,#0x2c]
0061bc  e2402001          SUB      r2,r0,#1
0061c0  e59500a4          LDR      r0,[r5,#0xa4]
0061c4  e0c01092          SMULL    r1,r0,r2,r0
0061c8  e58d000c          STR      r0,[sp,#0xc]
0061cc  e58d1008          STR      r1,[sp,#8]
;;;3552   					dev->data_bytes_per_chunk);
;;;3553   
;;;3554   			if (chunk_start > in->variant.file_variant.file_size)
0061d0  e1c626d8          LDRD     r2,r3,[r6,#0x68]
0061d4  e59d1008          LDR      r1,[sp,#8]
0061d8  e0521001          SUBS     r1,r2,r1
0061dc  e59d000c          LDR      r0,[sp,#0xc]
0061e0  e0d30000          SBCS     r0,r3,r0
0061e4  aa000002          BGE      |L1.25076|
;;;3555   				n_bytes_read = 0;	/* Past end of file */
0061e8  e3a00000          MOV      r0,#0
0061ec  e58d0010          STR      r0,[sp,#0x10]
0061f0  ea000003          B        |L1.25092|
                  |L1.25076|
;;;3556   			else
;;;3557   				n_bytes_read =
0061f4  e5961068          LDR      r1,[r6,#0x68]
0061f8  e59d0008          LDR      r0,[sp,#8]
0061fc  e0510000          SUBS     r0,r1,r0
006200  e58d0010          STR      r0,[sp,#0x10]
                  |L1.25092|
;;;3558   				    in->variant.file_variant.file_size -
;;;3559   				    chunk_start;
;;;3560   
;;;3561   			if (n_bytes_read > dev->data_bytes_per_chunk)
006204  e59510a4          LDR      r1,[r5,#0xa4]
006208  e59d0010          LDR      r0,[sp,#0x10]
00620c  e1510000          CMP      r1,r0
006210  2a000001          BCS      |L1.25116|
;;;3562   				n_bytes_read = dev->data_bytes_per_chunk;
006214  e59500a4          LDR      r0,[r5,#0xa4]
006218  e58d0010          STR      r0,[sp,#0x10]
                  |L1.25116|
;;;3563   
;;;3564   			n_writeback =
00621c  e59d0028          LDR      r0,[sp,#0x28]
006220  e080100b          ADD      r1,r0,r11
006224  e59d0010          LDR      r0,[sp,#0x10]
006228  e1510000          CMP      r1,r0
00622c  2a000001          BCS      |L1.25144|
;;;3565   			    (n_bytes_read >
;;;3566   			     (start + n)) ? n_bytes_read : (start + n);
006230  e59d0010          LDR      r0,[sp,#0x10]
006234  ea000001          B        |L1.25152|
                  |L1.25144|
006238  e59d0028          LDR      r0,[sp,#0x28]
00623c  e080000b          ADD      r0,r0,r11
                  |L1.25152|
006240  e58d0024          STR      r0,[sp,#0x24]
;;;3567   
;;;3568   			if (n_writeback < 0 ||
006244  e59d0024          LDR      r0,[sp,#0x24]
006248  e3500000          CMP      r0,#0
00624c  ba000003          BLT      |L1.25184|
;;;3569   			    n_writeback > dev->data_bytes_per_chunk)
006250  e59510a4          LDR      r1,[r5,#0xa4]
006254  e59d0024          LDR      r0,[sp,#0x24]
006258  e1510000          CMP      r1,r0
00625c  aa00000a          BGE      |L1.25228|
                  |L1.25184|
;;;3570   				BUG();
006260  e1a00000          MOV      r0,r0
006264  e59f22b0          LDR      r2,|L1.25884|
006268  e59f12b0          LDR      r1,|L1.25888|
00626c  e59f02b0          LDR      r0,|L1.25892|
006270  ebfffffe          BL       sysprintf
006274  ea000004          B        |L1.25228|
                  |L1.25208|
;;;3571   
;;;3572   		} else {
;;;3573   			n_copy = dev->data_bytes_per_chunk - start;
006278  e59500a4          LDR      r0,[r5,#0xa4]
00627c  e59d1028          LDR      r1,[sp,#0x28]
006280  e0409001          SUB      r9,r0,r1
;;;3574   			n_writeback = dev->data_bytes_per_chunk;
006284  e59500a4          LDR      r0,[r5,#0xa4]
006288  e58d0024          STR      r0,[sp,#0x24]
                  |L1.25228|
;;;3575   		}
;;;3576   
;;;3577   		if (n_copy != dev->data_bytes_per_chunk ||
00628c  e59500a4          LDR      r0,[r5,#0xa4]
006290  e1500009          CMP      r0,r9
006294  1a000002          BNE      |L1.25252|
;;;3578   		    dev->param.inband_tags) {
006298  e5950004          LDR      r0,[r5,#4]
00629c  e3500000          CMP      r0,#0
0062a0  0a000060          BEQ      |L1.25640|
                  |L1.25252|
;;;3579   			/* An incomplete start or end chunk (or maybe both
;;;3580   			 * start and end chunk), or we're using inband tags,
;;;3581   			 * so we want to use the cache buffers.
;;;3582   			 */
;;;3583   			if (dev->param.n_caches > 0) {
0062a4  e5950020          LDR      r0,[r5,#0x20]
0062a8  e3500000          CMP      r0,#0
0062ac  da000045          BLE      |L1.25544|
;;;3584   				struct yaffs_cache *cache;
;;;3585   
;;;3586   				/* If we can't find the data in the cache, then
;;;3587   				 * load the cache */
;;;3588   				cache = yaffs_find_chunk_cache(in, chunk);
0062b0  e1a00006          MOV      r0,r6
0062b4  e59d102c          LDR      r1,[sp,#0x2c]
0062b8  ebfffffe          BL       yaffs_find_chunk_cache
0062bc  e1a04000          MOV      r4,r0
;;;3589   
;;;3590   				if (!cache &&
0062c0  e3540000          CMP      r4,#0
0062c4  1a000012          BNE      |L1.25364|
;;;3591   				    yaffs_check_alloc_available(dev, 1)) {
0062c8  e3a01001          MOV      r1,#1
0062cc  e1a00005          MOV      r0,r5
0062d0  ebfffffe          BL       yaffs_check_alloc_available
0062d4  e3500000          CMP      r0,#0
0062d8  0a00000d          BEQ      |L1.25364|
;;;3592   					cache = yaffs_grab_chunk_cache(dev);
0062dc  e1a00005          MOV      r0,r5
0062e0  ebfffffe          BL       yaffs_grab_chunk_cache
0062e4  e1a04000          MOV      r4,r0
;;;3593   					cache->object = in;
0062e8  e5846000          STR      r6,[r4,#0]
;;;3594   					cache->chunk_id = chunk;
0062ec  e59d002c          LDR      r0,[sp,#0x2c]
0062f0  e5840004          STR      r0,[r4,#4]
;;;3595   					cache->dirty = 0;
0062f4  e3a00000          MOV      r0,#0
0062f8  e584000c          STR      r0,[r4,#0xc]
;;;3596   					cache->locked = 0;
0062fc  e5840014          STR      r0,[r4,#0x14]
;;;3597   					yaffs_rd_data_obj(in, chunk,
006300  e5942018          LDR      r2,[r4,#0x18]
006304  e1a00006          MOV      r0,r6
006308  e59d102c          LDR      r1,[sp,#0x2c]
00630c  ebfffffe          BL       yaffs_rd_data_obj
006310  ea00000a          B        |L1.25408|
                  |L1.25364|
;;;3598   							  cache->data);
;;;3599   				} else if (cache &&
006314  e3540000          CMP      r4,#0
006318  0a000008          BEQ      |L1.25408|
;;;3600   					   !cache->dirty &&
00631c  e594000c          LDR      r0,[r4,#0xc]
006320  e3500000          CMP      r0,#0
006324  1a000005          BNE      |L1.25408|
;;;3601   					   !yaffs_check_alloc_available(dev,
006328  e3a01001          MOV      r1,#1
00632c  e1a00005          MOV      r0,r5
006330  ebfffffe          BL       yaffs_check_alloc_available
006334  e3500000          CMP      r0,#0
006338  1a000000          BNE      |L1.25408|
;;;3602   									1)) {
;;;3603   					/* Drop the cache if it was a read cache
;;;3604   					 * item and no space check has been made
;;;3605   					 * for it.
;;;3606   					 */
;;;3607   					cache = NULL;
00633c  e3a04000          MOV      r4,#0
                  |L1.25408|
;;;3608   				}
;;;3609   
;;;3610   				if (cache) {
006340  e3540000          CMP      r4,#0
006344  0a00001c          BEQ      |L1.25532|
;;;3611   					yaffs_use_cache(dev, cache, 1);
006348  e3a02001          MOV      r2,#1
00634c  e1a01004          MOV      r1,r4
006350  e1a00005          MOV      r0,r5
006354  ebfffffe          BL       yaffs_use_cache
;;;3612   					cache->locked = 1;
006358  e3a00001          MOV      r0,#1
00635c  e5840014          STR      r0,[r4,#0x14]
;;;3613   
;;;3614   					memcpy(&cache->data[start], buffer,
006360  e5941018          LDR      r1,[r4,#0x18]
006364  e59d2028          LDR      r2,[sp,#0x28]
006368  e0810002          ADD      r0,r1,r2
00636c  e1a02009          MOV      r2,r9
006370  e59d1034          LDR      r1,[sp,#0x34]
006374  ebfffffe          BL       __aeabi_memcpy
;;;3615   					       n_copy);
;;;3616   
;;;3617   					cache->locked = 0;
006378  e3a00000          MOV      r0,#0
00637c  e5840014          STR      r0,[r4,#0x14]
;;;3618   					cache->n_bytes = n_writeback;
006380  e59d0024          LDR      r0,[sp,#0x24]
006384  e5840010          STR      r0,[r4,#0x10]
;;;3619   
;;;3620   					if (write_through) {
006388  e59d006c          LDR      r0,[sp,#0x6c]
00638c  e3500000          CMP      r0,#0
006390  0a00000b          BEQ      |L1.25540|
;;;3621   						chunk_written =
006394  e3a00001          MOV      r0,#1
006398  e58d0000          STR      r0,[sp,#0]
00639c  e8940003          LDM      r4,{r0,r1}
0063a0  e5942018          LDR      r2,[r4,#0x18]
0063a4  e5943010          LDR      r3,[r4,#0x10]
0063a8  ebfffffe          BL       yaffs_wr_data_obj
0063ac  e58d0014          STR      r0,[sp,#0x14]
;;;3622   						    yaffs_wr_data_obj
;;;3623   						    (cache->object,
;;;3624   						     cache->chunk_id,
;;;3625   						     cache->data,
;;;3626   						     cache->n_bytes, 1);
;;;3627   						cache->dirty = 0;
0063b0  e3a00000          MOV      r0,#0
0063b4  e584000c          STR      r0,[r4,#0xc]
0063b8  ea000001          B        |L1.25540|
                  |L1.25532|
;;;3628   					}
;;;3629   				} else {
;;;3630   					chunk_written = -1;	/* fail write */
0063bc  e3e00000          MVN      r0,#0
0063c0  e58d0014          STR      r0,[sp,#0x14]
                  |L1.25540|
;;;3631   				}
;;;3632   			} else {
0063c4  ea000022          B        |L1.25684|
                  |L1.25544|
;;;3633   				/* An incomplete start or end chunk (or maybe
;;;3634   				 * both start and end chunk). Read into the
;;;3635   				 * local buffer then copy over and write back.
;;;3636   				 */
;;;3637   
;;;3638   				u8 *local_buffer = yaffs_get_temp_buffer(dev);
0063c8  e1a00005          MOV      r0,r5
0063cc  ebfffffe          BL       yaffs_get_temp_buffer
0063d0  e1a04000          MOV      r4,r0
;;;3639   
;;;3640   				yaffs_rd_data_obj(in, chunk, local_buffer);
0063d4  e1a02004          MOV      r2,r4
0063d8  e1a00006          MOV      r0,r6
0063dc  e59d102c          LDR      r1,[sp,#0x2c]
0063e0  ebfffffe          BL       yaffs_rd_data_obj
;;;3641   				memcpy(&local_buffer[start], buffer, n_copy);
0063e4  e59d1028          LDR      r1,[sp,#0x28]
0063e8  e0840001          ADD      r0,r4,r1
0063ec  e1a02009          MOV      r2,r9
0063f0  e59d1034          LDR      r1,[sp,#0x34]
0063f4  ebfffffe          BL       __aeabi_memcpy
;;;3642   
;;;3643   				chunk_written =
0063f8  e3a00000          MOV      r0,#0
0063fc  e58d0000          STR      r0,[sp,#0]
006400  e1a02004          MOV      r2,r4
006404  e1a00006          MOV      r0,r6
006408  e59d102c          LDR      r1,[sp,#0x2c]
00640c  e59d3024          LDR      r3,[sp,#0x24]
006410  ebfffffe          BL       yaffs_wr_data_obj
006414  e58d0014          STR      r0,[sp,#0x14]
;;;3644   				    yaffs_wr_data_obj(in, chunk,
;;;3645   						      local_buffer,
;;;3646   						      n_writeback, 0);
;;;3647   
;;;3648   				yaffs_release_temp_buffer(dev, local_buffer);
006418  e1a01004          MOV      r1,r4
00641c  e1a00005          MOV      r0,r5
006420  ebfffffe          BL       yaffs_release_temp_buffer
;;;3649   			}
006424  ea00000a          B        |L1.25684|
                  |L1.25640|
;;;3650   		} else {
;;;3651   			/* A full chunk. Write directly from the buffer. */
;;;3652   
;;;3653   			chunk_written =
006428  e3a00000          MOV      r0,#0
00642c  e58d0000          STR      r0,[sp,#0]
006430  e59530a4          LDR      r3,[r5,#0xa4]
006434  e1a00006          MOV      r0,r6
006438  e59d102c          LDR      r1,[sp,#0x2c]
00643c  e59d2034          LDR      r2,[sp,#0x34]
006440  ebfffffe          BL       yaffs_wr_data_obj
006444  e58d0014          STR      r0,[sp,#0x14]
;;;3654   			    yaffs_wr_data_obj(in, chunk, buffer,
;;;3655   					      dev->data_bytes_per_chunk, 0);
;;;3656   
;;;3657   			/* Since we've overwritten the cached data,
;;;3658   			 * we better invalidate it. */
;;;3659   			yaffs_invalidate_chunk_cache(in, chunk);
006448  e1a00006          MOV      r0,r6
00644c  e59d102c          LDR      r1,[sp,#0x2c]
006450  ebfffffe          BL       yaffs_invalidate_chunk_cache
                  |L1.25684|
;;;3660   		}
;;;3661   
;;;3662   		if (chunk_written >= 0) {
006454  e59d0014          LDR      r0,[sp,#0x14]
006458  e3500000          CMP      r0,#0
00645c  ba000006          BLT      |L1.25724|
;;;3663   			n -= n_copy;
006460  e04bb009          SUB      r11,r11,r9
006464  e0977009          ADDS     r7,r7,r9
006468  e0a88fc9          ADC      r8,r8,r9,ASR #31
;;;3664   			offset += n_copy;
;;;3665   			buffer += n_copy;
00646c  e59d0034          LDR      r0,[sp,#0x34]
006470  e0800009          ADD      r0,r0,r9
006474  e58d0034          STR      r0,[sp,#0x34]
;;;3666   			n_done += n_copy;
006478  e08aa009          ADD      r10,r10,r9
                  |L1.25724|
00647c  e35b0000          CMP      r11,#0                ;3526
006480  da000002          BLE      |L1.25744|
006484  e59d0014          LDR      r0,[sp,#0x14]         ;3526
006488  e3500000          CMP      r0,#0                 ;3526
00648c  aaffff1f          BGE      |L1.24848|
                  |L1.25744|
;;;3667   		}
;;;3668   	}
;;;3669   
;;;3670   	/* Update file object */
;;;3671   
;;;3672   	if ((start_write + n_done) > in->variant.file_variant.file_size)
006490  e1c626d8          LDRD     r2,r3,[r6,#0x68]
006494  e1cd01d8          LDRD     r0,r1,[sp,#0x18]
006498  e090000a          ADDS     r0,r0,r10
00649c  e0a11fca          ADC      r1,r1,r10,ASR #31
0064a0  e0520000          SUBS     r0,r2,r0
0064a4  e0d30001          SBCS     r0,r3,r1
0064a8  aa000005          BGE      |L1.25796|
;;;3673   		in->variant.file_variant.file_size = (start_write + n_done);
0064ac  e59d1018          LDR      r1,[sp,#0x18]
0064b0  e091100a          ADDS     r1,r1,r10
0064b4  e59d001c          LDR      r0,[sp,#0x1c]
0064b8  e0a00fca          ADC      r0,r0,r10,ASR #31
0064bc  e586006c          STR      r0,[r6,#0x6c]
0064c0  e5861068          STR      r1,[r6,#0x68]
                  |L1.25796|
;;;3674   
;;;3675   	in->dirty = 1;
0064c4  e5d60000          LDRB     r0,[r6,#0]
0064c8  e3800040          ORR      r0,r0,#0x40
0064cc  e5c60000          STRB     r0,[r6,#0]
;;;3676   	return n_done;
0064d0  e1a0000a          MOV      r0,r10
0064d4  e28dd040          ADD      sp,sp,#0x40
;;;3677   }
0064d8  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.25820|
                          DCD      yaffs_trace_mask
                  |L1.25824|
0064e0  79616666          DCB      "yaffs: AddrToChunk of offset %lld gives chunk %d start "
0064e4  733a2041
0064e8  64647254
0064ec  6f436875
0064f0  6e6b206f
0064f4  66206f66
0064f8  66736574
0064fc  20256c6c
006500  64206769
006504  76657320
006508  6368756e
00650c  6b202564
006510  20737461
006514  727420  
006517  25640a00          DCB      "%d\n",0
00651b  00                DCB      0
                  |L1.25884|
                          DCD      0x00000df2
                  |L1.25888|
                          DCD      ||.text||+0x1f2c
                  |L1.25892|
                          DCD      ||.text||+0x2b4
                          ENDP

                  yaffs_wr_file PROC
;;;3678   
;;;3679   int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
006528  e92d47fc          PUSH     {r2-r10,lr}
;;;3680   		  int n_bytes, int write_through)
;;;3681   {
00652c  e1a06000          MOV      r6,r0
006530  e1a07001          MOV      r7,r1
006534  e1a04002          MOV      r4,r2
006538  e1a05003          MOV      r5,r3
00653c  e1cd82d8          LDRD     r8,r9,[sp,#0x28]
;;;3682   	yaffs2_handle_hole(in, offset);
006540  e1a02004          MOV      r2,r4
006544  e1a03005          MOV      r3,r5
006548  e1a00006          MOV      r0,r6
00654c  ebfffffe          BL       yaffs2_handle_hole
;;;3683   	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
006550  e1a02004          MOV      r2,r4
006554  e1a03005          MOV      r3,r5
006558  e1a01007          MOV      r1,r7
00655c  e1a00006          MOV      r0,r6
006560  e1cd80f0          STRD     r8,r9,[sp,#0]
006564  ebfffffe          BL       yaffs_do_file_wr
;;;3684   }
006568  e8bd87fc          POP      {r2-r10,pc}
;;;3685   
                          ENDP

                  yaffs_flush_file PROC
;;;3805   
;;;3806   int yaffs_flush_file(struct yaffs_obj *in, int update_time, int data_sync)
00656c  e92d407c          PUSH     {r2-r6,lr}
;;;3807   {
006570  e1a04000          MOV      r4,r0
006574  e1a05001          MOV      r5,r1
006578  e1a06002          MOV      r6,r2
;;;3808   	if (!in->dirty)
00657c  e5d40000          LDRB     r0,[r4,#0]
006580  e1a00c80          LSL      r0,r0,#25
006584  e1b00fa0          LSRS     r0,r0,#31
006588  1a000001          BNE      |L1.26004|
;;;3809   		return YAFFS_OK;
00658c  e3a00001          MOV      r0,#1
                  |L1.26000|
;;;3810   
;;;3811   	yaffs_flush_file_cache(in);
;;;3812   
;;;3813   	if (data_sync)
;;;3814   		return YAFFS_OK;
;;;3815   
;;;3816   	if (update_time)
;;;3817   		yaffs_load_current_time(in, 0, 0);
;;;3818   
;;;3819   	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
;;;3820   				YAFFS_OK : YAFFS_FAIL;
;;;3821   }
006590  e8bd807c          POP      {r2-r6,pc}
                  |L1.26004|
006594  e1a00004          MOV      r0,r4                 ;3811
006598  ebfffffe          BL       yaffs_flush_file_cache
00659c  e3560000          CMP      r6,#0                 ;3813
0065a0  0a000001          BEQ      |L1.26028|
0065a4  e3a00001          MOV      r0,#1                 ;3814
0065a8  eafffff8          B        |L1.26000|
                  |L1.26028|
0065ac  e3550000          CMP      r5,#0                 ;3816
0065b0  0a000003          BEQ      |L1.26052|
0065b4  e3a02000          MOV      r2,#0                 ;3817
0065b8  e1a01002          MOV      r1,r2                 ;3817
0065bc  e1a00004          MOV      r0,r4                 ;3817
0065c0  ebfffffe          BL       yaffs_load_current_time
                  |L1.26052|
0065c4  e3a00000          MOV      r0,#0                 ;3819
0065c8  e58d0000          STR      r0,[sp,#0]            ;3819
0065cc  e58d0004          STR      r0,[sp,#4]            ;3819
0065d0  e1a03000          MOV      r3,r0                 ;3819
0065d4  e1a02000          MOV      r2,r0                 ;3819
0065d8  e1a01000          MOV      r1,r0                 ;3819
0065dc  e1a00004          MOV      r0,r4                 ;3819
0065e0  ebfffffe          BL       yaffs_update_oh
0065e4  e1a00fc0          ASR      r0,r0,#31             ;3819
0065e8  e2800001          ADD      r0,r0,#1              ;3819
0065ec  eaffffe7          B        |L1.26000|
;;;3822   
                          ENDP

                  yaffs_unlink_worker PROC
;;;3957   
;;;3958   static int yaffs_unlink_worker(struct yaffs_obj *obj)
0065f0  e92d41f0          PUSH     {r4-r8,lr}
;;;3959   {
0065f4  e24ddf42          SUB      sp,sp,#0x108
0065f8  e1a04000          MOV      r4,r0
;;;3960   	int del_now = 0;
0065fc  e3a07000          MOV      r7,#0
;;;3961   
;;;3962   	if (!obj)
006600  e3540000          CMP      r4,#0
006604  1a000002          BNE      |L1.26132|
;;;3963   		return YAFFS_FAIL;
006608  e3a00000          MOV      r0,#0
                  |L1.26124|
00660c  e28ddf42          ADD      sp,sp,#0x108
;;;3964   
;;;3965   	if (!obj->my_inode)
;;;3966   		del_now = 1;
;;;3967   
;;;3968   	yaffs_update_parent(obj->parent);
;;;3969   
;;;3970   	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
;;;3971   		return yaffs_del_link(obj);
;;;3972   	} else if (!list_empty(&obj->hard_links)) {
;;;3973   		/* Curve ball: We're unlinking an object that has a hardlink.
;;;3974   		 *
;;;3975   		 * This problem arises because we are not strictly following
;;;3976   		 * The Linux link/inode model.
;;;3977   		 *
;;;3978   		 * We can't really delete the object.
;;;3979   		 * Instead, we do the following:
;;;3980   		 * - Select a hardlink.
;;;3981   		 * - Unhook it from the hard links
;;;3982   		 * - Move it from its parent directory so that the rename works.
;;;3983   		 * - Rename the object to the hardlink's name.
;;;3984   		 * - Delete the hardlink
;;;3985   		 */
;;;3986   
;;;3987   		struct yaffs_obj *hl;
;;;3988   		struct yaffs_obj *parent;
;;;3989   		int ret_val;
;;;3990   		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
;;;3991   
;;;3992   		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
;;;3993   				hard_links);
;;;3994   
;;;3995   		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
;;;3996   		parent = hl->parent;
;;;3997   
;;;3998   		list_del_init(&hl->hard_links);
;;;3999   
;;;4000   		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
;;;4001   
;;;4002   		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
;;;4003   
;;;4004   		if (ret_val == YAFFS_OK)
;;;4005   			ret_val = yaffs_generic_obj_del(hl);
;;;4006   
;;;4007   		return ret_val;
;;;4008   
;;;4009   	} else if (del_now) {
;;;4010   		switch (obj->variant_type) {
;;;4011   		case YAFFS_OBJECT_TYPE_FILE:
;;;4012   			return yaffs_del_file(obj);
;;;4013   // 			break;
;;;4014   		case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;4015   			list_del_init(&obj->variant.dir_variant.dirty);
;;;4016   			return yaffs_del_dir(obj);
;;;4017   // 			break;
;;;4018   		case YAFFS_OBJECT_TYPE_SYMLINK:
;;;4019   			return yaffs_del_symlink(obj);
;;;4020   // 			break;
;;;4021   		case YAFFS_OBJECT_TYPE_SPECIAL:
;;;4022   			return yaffs_generic_obj_del(obj);
;;;4023   // 			break;
;;;4024   		case YAFFS_OBJECT_TYPE_HARDLINK:
;;;4025   		case YAFFS_OBJECT_TYPE_UNKNOWN:
;;;4026   		default:
;;;4027   			return YAFFS_FAIL;
;;;4028   		}
;;;4029   	} else if (yaffs_is_non_empty_dir(obj)) {
;;;4030   		return YAFFS_FAIL;
;;;4031   	} else {
;;;4032   		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
;;;4033   						_Y("unlinked"), 0, 0);
;;;4034   	}
;;;4035   }
006610  e8bd81f0          POP      {r4-r8,pc}
                  |L1.26132|
006614  e5940060          LDR      r0,[r4,#0x60]         ;3965
006618  e3500000          CMP      r0,#0                 ;3965
00661c  1a000000          BNE      |L1.26148|
006620  e3a07001          MOV      r7,#1                 ;3966
                  |L1.26148|
006624  e594001c          LDR      r0,[r4,#0x1c]         ;3968
006628  ebfffffe          BL       yaffs_update_parent
00662c  e5d40064          LDRB     r0,[r4,#0x64]         ;3970
006630  e3500004          CMP      r0,#4                 ;3970
006634  1a000002          BNE      |L1.26180|
006638  e1a00004          MOV      r0,r4                 ;3971
00663c  ebfffffe          BL       yaffs_del_link
006640  eafffff1          B        |L1.26124|
                  |L1.26180|
006644  e2840014          ADD      r0,r4,#0x14           ;3972
006648  ebfffffe          BL       list_empty
00664c  e3500000          CMP      r0,#0                 ;3972
006650  1a00001b          BNE      |L1.26308|
006654  e5940014          LDR      r0,[r4,#0x14]         ;3992
006658  e2405014          SUB      r5,r0,#0x14           ;3992
00665c  e3a02c01          MOV      r2,#0x100             ;3995
006660  e28d1008          ADD      r1,sp,#8              ;3995
006664  e1a00005          MOV      r0,r5                 ;3995
006668  ebfffffe          BL       yaffs_get_obj_name
00666c  e595801c          LDR      r8,[r5,#0x1c]         ;3996
006670  e2850014          ADD      r0,r5,#0x14           ;3998
006674  ebfffffe          BL       list_del_init
006678  e5941008          LDR      r1,[r4,#8]            ;4000
00667c  e5910d98          LDR      r0,[r1,#0xd98]        ;4000
006680  e1a01005          MOV      r1,r5                 ;4000
006684  ebfffffe          BL       yaffs_add_obj_to_dir
006688  e3a00000          MOV      r0,#0                 ;4002
00668c  e58d0000          STR      r0,[sp,#0]            ;4002
006690  e1a03000          MOV      r3,r0                 ;4002
006694  e28d2008          ADD      r2,sp,#8              ;4002
006698  e1a01008          MOV      r1,r8                 ;4002
00669c  e1a00004          MOV      r0,r4                 ;4002
0066a0  ebfffffe          BL       yaffs_change_obj_name
0066a4  e1a06000          MOV      r6,r0                 ;4002
0066a8  e3560001          CMP      r6,#1                 ;4004
0066ac  1a000002          BNE      |L1.26300|
0066b0  e1a00005          MOV      r0,r5                 ;4005
0066b4  ebfffffe          BL       yaffs_generic_obj_del
0066b8  e1a06000          MOV      r6,r0                 ;4005
                  |L1.26300|
0066bc  e1a00006          MOV      r0,r6                 ;4007
0066c0  eaffffd1          B        |L1.26124|
                  |L1.26308|
0066c4  e1a00000          MOV      r0,r0                 ;4009
0066c8  e3570000          CMP      r7,#0                 ;4009
0066cc  0a000020          BEQ      |L1.26452|
0066d0  e5d40064          LDRB     r0,[r4,#0x64]         ;4010
0066d4  e3500006          CMP      r0,#6                 ;4010
0066d8  308ff100          ADDCC    pc,pc,r0,LSL #2       ;4010
0066dc  ea000017          B        |L1.26432|
0066e0  ea000019          B        |L1.26444|
0066e4  ea000003          B        |L1.26360|
0066e8  ea00000c          B        |L1.26400|
0066ec  ea000005          B        |L1.26376|
0066f0  ea000014          B        |L1.26440|
0066f4  ea00000d          B        |L1.26416|
                  |L1.26360|
0066f8  e1a00000          MOV      r0,r0                 ;4011
0066fc  e1a00004          MOV      r0,r4                 ;4012
006700  ebfffffe          BL       yaffs_del_file
006704  eaffffc0          B        |L1.26124|
                  |L1.26376|
006708  e1a00000          MOV      r0,r0                 ;4014
00670c  e2840070          ADD      r0,r4,#0x70           ;4015
006710  ebfffffe          BL       list_del_init
006714  e1a00004          MOV      r0,r4                 ;4016
006718  ebfffffe          BL       yaffs_del_dir
00671c  eaffffba          B        |L1.26124|
                  |L1.26400|
006720  e1a00000          MOV      r0,r0                 ;4018
006724  e1a00004          MOV      r0,r4                 ;4019
006728  ebfffffe          BL       yaffs_del_symlink
00672c  eaffffb6          B        |L1.26124|
                  |L1.26416|
006730  e1a00000          MOV      r0,r0                 ;4021
006734  e1a00004          MOV      r0,r4                 ;4022
006738  ebfffffe          BL       yaffs_generic_obj_del
00673c  eaffffb2          B        |L1.26124|
                  |L1.26432|
006740  e1a00000          MOV      r0,r0                 ;4024
006744  e1a00000          MOV      r0,r0                 ;4024
                  |L1.26440|
006748  e1a00000          MOV      r0,r0                 ;4025
                  |L1.26444|
00674c  e3a00000          MOV      r0,#0                 ;4027
006750  eaffffad          B        |L1.26124|
                  |L1.26452|
006754  e1a00004          MOV      r0,r4                 ;4029
006758  ebfffffe          BL       yaffs_is_non_empty_dir
00675c  e3500000          CMP      r0,#0                 ;4029
006760  0a000001          BEQ      |L1.26476|
006764  e3a00000          MOV      r0,#0                 ;4030
006768  eaffffa7          B        |L1.26124|
                  |L1.26476|
00676c  e3a00000          MOV      r0,#0                 ;4032
006770  e58d0000          STR      r0,[sp,#0]            ;4032
006774  e5940008          LDR      r0,[r4,#8]            ;4032
006778  e3a03000          MOV      r3,#0                 ;4032
00677c  e59f27b4          LDR      r2,|L1.28472|
006780  e5901d98          LDR      r1,[r0,#0xd98]        ;4032
006784  e1a00004          MOV      r0,r4                 ;4032
006788  ebfffffe          BL       yaffs_change_obj_name
00678c  eaffff9e          B        |L1.26124|
;;;4036   
                          ENDP

                  yaffs_unlink_obj PROC
;;;4037   static int yaffs_unlink_obj(struct yaffs_obj *obj)
006790  e92d4010          PUSH     {r4,lr}
;;;4038   {
006794  e1a04000          MOV      r4,r0
;;;4039   	if (obj && obj->unlink_allowed)
006798  e3540000          CMP      r4,#0
00679c  0a000006          BEQ      |L1.26556|
0067a0  e5d40000          LDRB     r0,[r4,#0]
0067a4  e1a00d00          LSL      r0,r0,#26
0067a8  e1b00fa0          LSRS     r0,r0,#31
0067ac  0a000002          BEQ      |L1.26556|
;;;4040   		return yaffs_unlink_worker(obj);
0067b0  e1a00004          MOV      r0,r4
0067b4  ebfffffe          BL       yaffs_unlink_worker
                  |L1.26552|
;;;4041   
;;;4042   	return YAFFS_FAIL;
;;;4043   }
0067b8  e8bd8010          POP      {r4,pc}
                  |L1.26556|
0067bc  e3a00000          MOV      r0,#0                 ;4042
0067c0  eafffffc          B        |L1.26552|
;;;4044   
                          ENDP

                  yaffs_unlinker PROC
;;;4045   int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
0067c4  e92d4070          PUSH     {r4-r6,lr}
;;;4046   {
0067c8  e1a04000          MOV      r4,r0
0067cc  e1a05001          MOV      r5,r1
;;;4047   	struct yaffs_obj *obj;
;;;4048   
;;;4049   	obj = yaffs_find_by_name(dir, name);
0067d0  e1a01005          MOV      r1,r5
0067d4  e1a00004          MOV      r0,r4
0067d8  ebfffffe          BL       yaffs_find_by_name
0067dc  e1a06000          MOV      r6,r0
;;;4050   	return yaffs_unlink_obj(obj);
0067e0  e1a00006          MOV      r0,r6
0067e4  ebfffffe          BL       yaffs_unlink_obj
;;;4051   }
0067e8  e8bd8070          POP      {r4-r6,pc}
;;;4052   
                          ENDP

                  yaffs_rename_obj PROC
;;;4055    */
;;;4056   int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
0067ec  e92d5ffc          PUSH     {r2-r12,lr}
;;;4057   		     struct yaffs_obj *new_dir, const YCHAR *new_name)
;;;4058   {
0067f0  e1a04000          MOV      r4,r0
0067f4  e1a0a001          MOV      r10,r1
0067f8  e1a05002          MOV      r5,r2
0067fc  e1a08003          MOV      r8,r3
;;;4059   	struct yaffs_obj *obj = NULL;
006800  e3a07000          MOV      r7,#0
;;;4060   	struct yaffs_obj *existing_target = NULL;
006804  e3a06000          MOV      r6,#0
;;;4061   	int force = 0;
006808  e3a00000          MOV      r0,#0
00680c  e58d0004          STR      r0,[sp,#4]
;;;4062   	int result;
;;;4063   	struct yaffs_dev *dev;
;;;4064   
;;;4065   	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
006810  e3540000          CMP      r4,#0
006814  0a000002          BEQ      |L1.26660|
006818  e5d40064          LDRB     r0,[r4,#0x64]
00681c  e3500003          CMP      r0,#3
006820  0a000007          BEQ      |L1.26692|
                  |L1.26660|
;;;4066   		BUG();
006824  e1a00000          MOV      r0,r0
006828  e59f270c          LDR      r2,|L1.28476|
00682c  e51f1314          LDR      r1,|L1.25888|
006830  e51f0314          LDR      r0,|L1.25892|
006834  ebfffffe          BL       sysprintf
006838  e1a00000          MOV      r0,r0
;;;4067   		return YAFFS_FAIL;
00683c  e3a00000          MOV      r0,#0
                  |L1.26688|
;;;4068   	}
;;;4069   	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;4070   		BUG();
;;;4071   		return YAFFS_FAIL;
;;;4072   	}
;;;4073   
;;;4074   	dev = old_dir->my_dev;
;;;4075   
;;;4076   #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
;;;4077   	/* Special case for case insemsitive systems.
;;;4078   	 * While look-up is case insensitive, the name isn't.
;;;4079   	 * Therefore we might want to change x.txt to X.txt
;;;4080   	 */
;;;4081   	if (old_dir == new_dir &&
;;;4082   		old_name && new_name &&
;;;4083   		yaffs_strcmp(old_name, new_name) == 0)
;;;4084   		force = 1;
;;;4085   #endif
;;;4086   
;;;4087   	if (yaffs_strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
;;;4088   	    YAFFS_MAX_NAME_LENGTH)
;;;4089   		/* ENAMETOOLONG */
;;;4090   		return YAFFS_FAIL;
;;;4091   
;;;4092   	if (old_name)
;;;4093   		obj = yaffs_find_by_name(old_dir, old_name);
;;;4094   	else{
;;;4095   		obj = old_dir;
;;;4096   		old_dir = obj->parent;
;;;4097   	}
;;;4098   
;;;4099   	if (obj && obj->rename_allowed) {
;;;4100   		/* Now handle an existing target, if there is one */
;;;4101   		existing_target = yaffs_find_by_name(new_dir, new_name);
;;;4102   		if (yaffs_is_non_empty_dir(existing_target)) {
;;;4103   			return YAFFS_FAIL;	/* ENOTEMPTY */
;;;4104   		} else if (existing_target && existing_target != obj) {
;;;4105   			/* Nuke the target first, using shadowing,
;;;4106   			 * but only if it isn't the same object.
;;;4107   			 *
;;;4108   			 * Note we must disable gc here otherwise it can mess
;;;4109   			 * up the shadowing.
;;;4110   			 *
;;;4111   			 */
;;;4112   			dev->gc_disable = 1;
;;;4113   			yaffs_change_obj_name(obj, new_dir, new_name, force,
;;;4114   					      existing_target->obj_id);
;;;4115   			existing_target->is_shadowed = 1;
;;;4116   			yaffs_unlink_obj(existing_target);
;;;4117   			dev->gc_disable = 0;
;;;4118   		}
;;;4119   
;;;4120   		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
;;;4121   
;;;4122   		yaffs_update_parent(old_dir);
;;;4123   		if (new_dir != old_dir)
;;;4124   			yaffs_update_parent(new_dir);
;;;4125   
;;;4126   		return result;
;;;4127   	}
;;;4128   	return YAFFS_FAIL;
;;;4129   }
006840  e8bd9ffc          POP      {r2-r12,pc}
                  |L1.26692|
006844  e3550000          CMP      r5,#0                 ;4069
006848  0a000002          BEQ      |L1.26712|
00684c  e5d50064          LDRB     r0,[r5,#0x64]         ;4069
006850  e3500003          CMP      r0,#3                 ;4069
006854  0a000007          BEQ      |L1.26744|
                  |L1.26712|
006858  e1a00000          MOV      r0,r0                 ;4070
00685c  e59f26dc          LDR      r2,|L1.28480|
006860  e51f1348          LDR      r1,|L1.25888|
006864  e51f0348          LDR      r0,|L1.25892|
006868  ebfffffe          BL       sysprintf
00686c  e1a00000          MOV      r0,r0                 ;4070
006870  e3a00000          MOV      r0,#0                 ;4071
006874  eafffff1          B        |L1.26688|
                  |L1.26744|
006878  e5949008          LDR      r9,[r4,#8]            ;4074
00687c  e1a00008          MOV      r0,r8                 ;4087
006880  ebfffffe          BL       strlen
006884  e3500c01          CMP      r0,#0x100             ;4087
006888  9a000001          BLS      |L1.26772|
00688c  e3a00c01          MOV      r0,#0x100             ;4087
006890  ea000001          B        |L1.26780|
                  |L1.26772|
006894  e1a00008          MOV      r0,r8                 ;4087
006898  ebfffffe          BL       strlen
                  |L1.26780|
00689c  e35000ff          CMP      r0,#0xff              ;4087
0068a0  9a000001          BLS      |L1.26796|
0068a4  e3a00000          MOV      r0,#0                 ;4090
0068a8  eaffffe4          B        |L1.26688|
                  |L1.26796|
0068ac  e35a0000          CMP      r10,#0                ;4092
0068b0  0a000004          BEQ      |L1.26824|
0068b4  e1a0100a          MOV      r1,r10                ;4093
0068b8  e1a00004          MOV      r0,r4                 ;4093
0068bc  ebfffffe          BL       yaffs_find_by_name
0068c0  e1a07000          MOV      r7,r0                 ;4093
0068c4  ea000001          B        |L1.26832|
                  |L1.26824|
0068c8  e1a07004          MOV      r7,r4                 ;4095
0068cc  e597401c          LDR      r4,[r7,#0x1c]         ;4096
                  |L1.26832|
0068d0  e3570000          CMP      r7,#0                 ;4099
0068d4  0a000031          BEQ      |L1.27040|
0068d8  e5d70000          LDRB     r0,[r7,#0]            ;4099
0068dc  e1a00d80          LSL      r0,r0,#27             ;4099
0068e0  e1b00fa0          LSRS     r0,r0,#31             ;4099
0068e4  0a00002d          BEQ      |L1.27040|
0068e8  e1a01008          MOV      r1,r8                 ;4101
0068ec  e1a00005          MOV      r0,r5                 ;4101
0068f0  ebfffffe          BL       yaffs_find_by_name
0068f4  e1a06000          MOV      r6,r0                 ;4101
0068f8  e1a00006          MOV      r0,r6                 ;4102
0068fc  ebfffffe          BL       yaffs_is_non_empty_dir
006900  e3500000          CMP      r0,#0                 ;4102
006904  0a000001          BEQ      |L1.26896|
006908  e3a00000          MOV      r0,#0                 ;4103
00690c  eaffffcb          B        |L1.26688|
                  |L1.26896|
006910  e3560000          CMP      r6,#0                 ;4104
006914  0a000011          BEQ      |L1.26976|
006918  e1560007          CMP      r6,r7                 ;4104
00691c  0a00000f          BEQ      |L1.26976|
006920  e3a00001          MOV      r0,#1                 ;4112
006924  e5890d5c          STR      r0,[r9,#0xd5c]        ;4112
006928  e5960030          LDR      r0,[r6,#0x30]         ;4113
00692c  e58d0000          STR      r0,[sp,#0]            ;4113
006930  e1a02008          MOV      r2,r8                 ;4113
006934  e1a01005          MOV      r1,r5                 ;4113
006938  e1a00007          MOV      r0,r7                 ;4113
00693c  e59d3004          LDR      r3,[sp,#4]            ;4113
006940  ebfffffe          BL       yaffs_change_obj_name
006944  e5d60001          LDRB     r0,[r6,#1]            ;4115
006948  e3800008          ORR      r0,r0,#8              ;4115
00694c  e5c60001          STRB     r0,[r6,#1]            ;4115
006950  e1a00006          MOV      r0,r6                 ;4116
006954  ebfffffe          BL       yaffs_unlink_obj
006958  e3a00000          MOV      r0,#0                 ;4117
00695c  e5890d5c          STR      r0,[r9,#0xd5c]        ;4117
                  |L1.26976|
006960  e3a00000          MOV      r0,#0                 ;4120
006964  e3a03001          MOV      r3,#1                 ;4120
006968  e1a02008          MOV      r2,r8                 ;4120
00696c  e1a01005          MOV      r1,r5                 ;4120
006970  e58d0000          STR      r0,[sp,#0]            ;4120
006974  e1a00007          MOV      r0,r7                 ;4120
006978  ebfffffe          BL       yaffs_change_obj_name
00697c  e1a0b000          MOV      r11,r0                ;4120
006980  e1a00004          MOV      r0,r4                 ;4122
006984  ebfffffe          BL       yaffs_update_parent
006988  e1550004          CMP      r5,r4                 ;4123
00698c  0a000001          BEQ      |L1.27032|
006990  e1a00005          MOV      r0,r5                 ;4124
006994  ebfffffe          BL       yaffs_update_parent
                  |L1.27032|
006998  e1a0000b          MOV      r0,r11                ;4126
00699c  eaffffa7          B        |L1.26688|
                  |L1.27040|
0069a0  e3a00000          MOV      r0,#0                 ;4128
0069a4  eaffffa5          B        |L1.26688|
;;;4130   
                          ENDP

                  yaffs_handle_shadowed_obj PROC
;;;4132   
;;;4133   void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
0069a8  e92d41f0          PUSH     {r4-r8,lr}
;;;4134   			       int backward_scanning)
;;;4135   {
0069ac  e1a05000          MOV      r5,r0
0069b0  e1a07001          MOV      r7,r1
0069b4  e1a06002          MOV      r6,r2
;;;4136   	struct yaffs_obj *obj;
;;;4137   
;;;4138   	if (backward_scanning) {
0069b8  e3560000          CMP      r6,#0
0069bc  0a000006          BEQ      |L1.27100|
;;;4139   		/* Handle YAFFS2 case (backward scanning)
;;;4140   		 * If the shadowed object exists then ignore.
;;;4141   		 */
;;;4142   		obj = yaffs_find_by_number(dev, obj_id);
0069c0  e1a01007          MOV      r1,r7
0069c4  e1a00005          MOV      r0,r5
0069c8  ebfffffe          BL       yaffs_find_by_number
0069cc  e1a04000          MOV      r4,r0
;;;4143   		if (obj)
0069d0  e3540000          CMP      r4,#0
0069d4  0a000000          BEQ      |L1.27100|
                  |L1.27096|
;;;4144   			return;
;;;4145   	}
;;;4146   
;;;4147   	/* Let's create it (if it does not exist) assuming it is a file so that
;;;4148   	 * it can do shrinking etc.
;;;4149   	 * We put it in unlinked dir to be cleaned up after the scanning
;;;4150   	 */
;;;4151   	obj =
;;;4152   	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
;;;4153   	if (!obj)
;;;4154   		return;
;;;4155   	obj->is_shadowed = 1;
;;;4156   	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
;;;4157   	obj->variant.file_variant.shrink_size = 0;
;;;4158   	obj->valid = 1;		/* So that we don't read any other info. */
;;;4159   }
0069d8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.27100|
0069dc  e3a02001          MOV      r2,#1                 ;4151
0069e0  e1a01007          MOV      r1,r7                 ;4151
0069e4  e1a00005          MOV      r0,r5                 ;4151
0069e8  ebfffffe          BL       yaffs_find_or_create_by_number
0069ec  e1a04000          MOV      r4,r0                 ;4151
0069f0  e3540000          CMP      r4,#0                 ;4153
0069f4  1a000000          BNE      |L1.27132|
0069f8  eafffff6          B        |L1.27096|
                  |L1.27132|
0069fc  e5d40001          LDRB     r0,[r4,#1]            ;4155
006a00  e3800008          ORR      r0,r0,#8              ;4155
006a04  e5c40001          STRB     r0,[r4,#1]            ;4155
006a08  e1a01004          MOV      r1,r4                 ;4156
006a0c  e5950d98          LDR      r0,[r5,#0xd98]        ;4156
006a10  ebfffffe          BL       yaffs_add_obj_to_dir
006a14  e3a01000          MOV      r1,#0                 ;4156
006a18  e5841078          STR      r1,[r4,#0x78]         ;4157
006a1c  e584107c          STR      r1,[r4,#0x7c]         ;4157
006a20  e5d40000          LDRB     r0,[r4,#0]            ;4158
006a24  e3800080          ORR      r0,r0,#0x80           ;4158
006a28  e5c40000          STRB     r0,[r4,#0]            ;4158
006a2c  e1a00000          MOV      r0,r0
006a30  eaffffe8          B        |L1.27096|
;;;4160   
                          ENDP

                  yaffs_link_fixup PROC
;;;4161   void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
006a34  e92d47f0          PUSH     {r4-r10,lr}
;;;4162   {
006a38  e1a09000          MOV      r9,r0
006a3c  e1a06001          MOV      r6,r1
;;;4163   	struct list_head *lh;
;;;4164   	struct list_head *save;
;;;4165   	struct yaffs_obj *hl;
;;;4166   	struct yaffs_obj *in;
;;;4167   
;;;4168   	list_for_each_safe(lh, save, hard_list) {
006a40  e5967000          LDR      r7,[r6,#0]
006a44  e5960000          LDR      r0,[r6,#0]
006a48  e5908000          LDR      r8,[r0,#0]
006a4c  ea000015          B        |L1.27304|
                  |L1.27216|
;;;4169   		hl = list_entry(lh, struct yaffs_obj, hard_links);
006a50  e2474014          SUB      r4,r7,#0x14
;;;4170   		in = yaffs_find_by_number(dev,
006a54  e1a00009          MOV      r0,r9
006a58  e594106c          LDR      r1,[r4,#0x6c]
006a5c  ebfffffe          BL       yaffs_find_by_number
006a60  e1a05000          MOV      r5,r0
;;;4171   					hl->variant.hardlink_variant.equiv_id);
;;;4172   
;;;4173   		if (in) {
006a64  e3550000          CMP      r5,#0
006a68  0a000004          BEQ      |L1.27264|
;;;4174   			/* Add the hardlink pointers */
;;;4175   			hl->variant.hardlink_variant.equiv_obj = in;
006a6c  e5845068          STR      r5,[r4,#0x68]
;;;4176   			list_add(&hl->hard_links, &in->hard_links);
006a70  e2851014          ADD      r1,r5,#0x14
006a74  e2840014          ADD      r0,r4,#0x14
006a78  ebfffffe          BL       list_add
006a7c  ea000007          B        |L1.27296|
                  |L1.27264|
;;;4177   		} else {
;;;4178   			/* Todo Need to report/handle this better.
;;;4179   			 * Got a problem... hardlink to a non-existant object
;;;4180   			 */
;;;4181   			hl->variant.hardlink_variant.equiv_obj = NULL;
006a80  e3a00000          MOV      r0,#0
006a84  e5840068          STR      r0,[r4,#0x68]
;;;4182   			INIT_LIST_HEAD(&hl->hard_links);
006a88  e1a00000          MOV      r0,r0
006a8c  e2840014          ADD      r0,r4,#0x14
006a90  e5840014          STR      r0,[r4,#0x14]
006a94  e2840014          ADD      r0,r4,#0x14
006a98  e5840018          STR      r0,[r4,#0x18]
006a9c  e1a00000          MOV      r0,r0
                  |L1.27296|
006aa0  e1a07008          MOV      r7,r8                 ;4168
006aa4  e5988000          LDR      r8,[r8,#0]            ;4168
                  |L1.27304|
006aa8  e1570006          CMP      r7,r6                 ;4168
006aac  1affffe7          BNE      |L1.27216|
;;;4183   		}
;;;4184   	}
;;;4185   }
006ab0  e8bd87f0          POP      {r4-r10,pc}
;;;4186   
                          ENDP

                  yaffs_strip_deleted_objs PROC
;;;4187   static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
006ab4  e92d41f0          PUSH     {r4-r8,lr}
;;;4188   {
006ab8  e1a04000          MOV      r4,r0
;;;4189   	/*
;;;4190   	 *  Sort out state of unlinked and deleted objects after scanning.
;;;4191   	 */
;;;4192   	struct list_head *i;
;;;4193   	struct list_head *n;
;;;4194   	struct yaffs_obj *l;
;;;4195   
;;;4196   	if (dev->read_only)
006abc  e59400c8          LDR      r0,[r4,#0xc8]
006ac0  e3500000          CMP      r0,#0
006ac4  0a000000          BEQ      |L1.27340|
                  |L1.27336|
;;;4197   		return;
;;;4198   
;;;4199   	/* Soft delete all the unlinked files */
;;;4200   	list_for_each_safe(i, n,
;;;4201   			   &dev->unlinked_dir->variant.dir_variant.children) {
;;;4202   		l = list_entry(i, struct yaffs_obj, siblings);
;;;4203   		yaffs_del_obj(l);
;;;4204   	}
;;;4205   
;;;4206   	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
;;;4207   		l = list_entry(i, struct yaffs_obj, siblings);
;;;4208   		yaffs_del_obj(l);
;;;4209   	}
;;;4210   }
006ac8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.27340|
006acc  e5940d98          LDR      r0,[r4,#0xd98]        ;4200
006ad0  e5905068          LDR      r5,[r0,#0x68]         ;4200
006ad4  e5940d98          LDR      r0,[r4,#0xd98]        ;4200
006ad8  e5900068          LDR      r0,[r0,#0x68]         ;4200
006adc  e5906000          LDR      r6,[r0,#0]            ;4200
006ae0  ea000004          B        |L1.27384|
                  |L1.27364|
006ae4  e2457020          SUB      r7,r5,#0x20           ;4202
006ae8  e1a00007          MOV      r0,r7                 ;4203
006aec  ebfffffe          BL       yaffs_del_obj
006af0  e1a05006          MOV      r5,r6                 ;4200
006af4  e5966000          LDR      r6,[r6,#0]            ;4200
                  |L1.27384|
006af8  e5940d98          LDR      r0,[r4,#0xd98]        ;4200
006afc  e2800068          ADD      r0,r0,#0x68           ;4200
006b00  e1500005          CMP      r0,r5                 ;4200
006b04  1afffff6          BNE      |L1.27364|
006b08  e5940d9c          LDR      r0,[r4,#0xd9c]        ;4206
006b0c  e5905068          LDR      r5,[r0,#0x68]         ;4206
006b10  e5940d9c          LDR      r0,[r4,#0xd9c]        ;4206
006b14  e5900068          LDR      r0,[r0,#0x68]         ;4206
006b18  e5906000          LDR      r6,[r0,#0]            ;4206
006b1c  ea000004          B        |L1.27444|
                  |L1.27424|
006b20  e2457020          SUB      r7,r5,#0x20           ;4207
006b24  e1a00007          MOV      r0,r7                 ;4208
006b28  ebfffffe          BL       yaffs_del_obj
006b2c  e1a05006          MOV      r5,r6                 ;4206
006b30  e5966000          LDR      r6,[r6,#0]            ;4206
                  |L1.27444|
006b34  e5940d9c          LDR      r0,[r4,#0xd9c]        ;4206
006b38  e2800068          ADD      r0,r0,#0x68           ;4206
006b3c  e1500005          CMP      r0,r5                 ;4206
006b40  1afffff6          BNE      |L1.27424|
006b44  e1a00000          MOV      r0,r0
006b48  eaffffde          B        |L1.27336|
;;;4211   
                          ENDP

                  yaffs_has_null_parent PROC
;;;4229   
;;;4230   static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
006b4c  e1a02000          MOV      r2,r0
;;;4231   {
;;;4232   	return (obj == dev->del_dir ||
006b50  e5920d9c          LDR      r0,[r2,#0xd9c]
006b54  e1500001          CMP      r0,r1
006b58  0a000005          BEQ      |L1.27508|
;;;4233   		obj == dev->unlinked_dir || obj == dev->root_dir);
006b5c  e5920d98          LDR      r0,[r2,#0xd98]
006b60  e1500001          CMP      r0,r1
006b64  0a000002          BEQ      |L1.27508|
006b68  e5920d80          LDR      r0,[r2,#0xd80]
006b6c  e1500001          CMP      r0,r1
006b70  1a000001          BNE      |L1.27516|
                  |L1.27508|
006b74  e3a00001          MOV      r0,#1                 ;4232
                  |L1.27512|
;;;4234   }
006b78  e12fff1e          BX       lr
                  |L1.27516|
006b7c  e3a00000          MOV      r0,#0                 ;4232
006b80  eafffffc          B        |L1.27512|
;;;4235   
                          ENDP

                  yaffs_fix_hanging_objs PROC
;;;4236   static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
006b84  e92d5ff0          PUSH     {r4-r12,lr}
;;;4237   {
006b88  e1a04000          MOV      r4,r0
;;;4238   	struct yaffs_obj *obj;
;;;4239   	struct yaffs_obj *parent;
;;;4240   	int i;
;;;4241   	struct list_head *lh;
;;;4242   	struct list_head *n;
;;;4243   	int depth_limit;
;;;4244   	int hanging;
;;;4245   
;;;4246   	if (dev->read_only)
006b8c  e59400c8          LDR      r0,[r4,#0xc8]
006b90  e3500000          CMP      r0,#0
006b94  0a000000          BEQ      |L1.27548|
                  |L1.27544|
;;;4247   		return;
;;;4248   
;;;4249   	/* Iterate through the objects in each hash entry,
;;;4250   	 * looking at each object.
;;;4251   	 * Make sure it is rooted.
;;;4252   	 */
;;;4253   
;;;4254   	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
;;;4255   		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
;;;4256   			obj = list_entry(lh, struct yaffs_obj, hash_link);
;;;4257   			parent = obj->parent;
;;;4258   
;;;4259   			if (yaffs_has_null_parent(dev, obj)) {
;;;4260   				/* These directories are not hanging */
;;;4261   				hanging = 0;
;;;4262   			} else if (!parent ||
;;;4263   				   parent->variant_type !=
;;;4264   				   YAFFS_OBJECT_TYPE_DIRECTORY) {
;;;4265   				hanging = 1;
;;;4266   			} else if (yaffs_has_null_parent(dev, parent)) {
;;;4267   				hanging = 0;
;;;4268   			} else {
;;;4269   				/*
;;;4270   				 * Need to follow the parent chain to
;;;4271   				 * see if it is hanging.
;;;4272   				 */
;;;4273   				hanging = 0;
;;;4274   				depth_limit = 100;
;;;4275   
;;;4276   				while (parent != dev->root_dir &&
;;;4277   				       parent->parent &&
;;;4278   				       parent->parent->variant_type ==
;;;4279   				       YAFFS_OBJECT_TYPE_DIRECTORY &&
;;;4280   				       depth_limit > 0) {
;;;4281   					parent = parent->parent;
;;;4282   					depth_limit--;
;;;4283   				}
;;;4284   				if (parent != dev->root_dir)
;;;4285   					hanging = 1;
;;;4286   			}
;;;4287   			if (hanging) {
;;;4288   				yaffs_trace(YAFFS_TRACE_SCAN,
;;;4289   					"Hanging object %d moved to lost and found",
;;;4290   					obj->obj_id);
;;;4291   				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
;;;4292   			}
;;;4293   		}
;;;4294   	}
;;;4295   }
006b98  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.27548|
006b9c  e3a06000          MOV      r6,#0                 ;4254
006ba0  ea000047          B        |L1.27844|
                  |L1.27556|
006ba4  e0860086          ADD      r0,r6,r6,LSL #1       ;4255
006ba8  e2841f52          ADD      r1,r4,#0x148          ;4255
006bac  e7918100          LDR      r8,[r1,r0,LSL #2]     ;4255
006bb0  e0860086          ADD      r0,r6,r6,LSL #1       ;4255
006bb4  e2841f52          ADD      r1,r4,#0x148          ;4255
006bb8  e7910100          LDR      r0,[r1,r0,LSL #2]     ;4255
006bbc  e5909000          LDR      r9,[r0,#0]            ;4255
006bc0  ea000039          B        |L1.27820|
                  |L1.27588|
006bc4  e248700c          SUB      r7,r8,#0xc            ;4256
006bc8  e597501c          LDR      r5,[r7,#0x1c]         ;4257
006bcc  e1a01007          MOV      r1,r7                 ;4259
006bd0  e1a00004          MOV      r0,r4                 ;4259
006bd4  ebfffffe          BL       yaffs_has_null_parent
006bd8  e3500000          CMP      r0,#0                 ;4259
006bdc  0a000001          BEQ      |L1.27624|
006be0  e3a0b000          MOV      r11,#0                ;4261
006be4  ea000022          B        |L1.27764|
                  |L1.27624|
006be8  e3550000          CMP      r5,#0                 ;4262
006bec  0a000002          BEQ      |L1.27644|
006bf0  e5d50064          LDRB     r0,[r5,#0x64]         ;4263
006bf4  e3500003          CMP      r0,#3                 ;4263
006bf8  0a000001          BEQ      |L1.27652|
                  |L1.27644|
006bfc  e3a0b001          MOV      r11,#1                ;4265
006c00  ea00001b          B        |L1.27764|
                  |L1.27652|
006c04  e1a01005          MOV      r1,r5                 ;4266
006c08  e1a00004          MOV      r0,r4                 ;4266
006c0c  ebfffffe          BL       yaffs_has_null_parent
006c10  e3500000          CMP      r0,#0                 ;4266
006c14  0a000001          BEQ      |L1.27680|
006c18  e3a0b000          MOV      r11,#0                ;4267
006c1c  ea000014          B        |L1.27764|
                  |L1.27680|
006c20  e3a0b000          MOV      r11,#0                ;4273
006c24  e3a0a064          MOV      r10,#0x64             ;4274
006c28  ea000001          B        |L1.27700|
                  |L1.27692|
006c2c  e595501c          LDR      r5,[r5,#0x1c]         ;4281
006c30  e24aa001          SUB      r10,r10,#1            ;4282
                  |L1.27700|
006c34  e5940d80          LDR      r0,[r4,#0xd80]        ;4276
006c38  e1500005          CMP      r0,r5                 ;4276
006c3c  0a000008          BEQ      |L1.27748|
006c40  e595001c          LDR      r0,[r5,#0x1c]         ;4277
006c44  e3500000          CMP      r0,#0                 ;4277
006c48  0a000005          BEQ      |L1.27748|
006c4c  e595001c          LDR      r0,[r5,#0x1c]         ;4278
006c50  e5d00064          LDRB     r0,[r0,#0x64]         ;4278
006c54  e3500003          CMP      r0,#3                 ;4278
006c58  1a000001          BNE      |L1.27748|
006c5c  e35a0000          CMP      r10,#0                ;4280
006c60  cafffff1          BGT      |L1.27692|
                  |L1.27748|
006c64  e5940d80          LDR      r0,[r4,#0xd80]        ;4284
006c68  e1500005          CMP      r0,r5                 ;4284
006c6c  0a000000          BEQ      |L1.27764|
006c70  e3a0b001          MOV      r11,#1                ;4285
                  |L1.27764|
006c74  e35b0000          CMP      r11,#0                ;4287
006c78  0a000009          BEQ      |L1.27812|
006c7c  e51f07a8          LDR      r0,|L1.25820|
006c80  e5d00000          LDRB     r0,[r0,#0]            ;4288  ; yaffs_trace_mask
006c84  e3100008          TST      r0,#8                 ;4288
006c88  0a000002          BEQ      |L1.27800|
006c8c  e28f0e2b          ADR      r0,|L1.28484|
006c90  e5971030          LDR      r1,[r7,#0x30]         ;4288
006c94  ebfffffe          BL       sysprintf
                  |L1.27800|
006c98  e1a01007          MOV      r1,r7                 ;4291
006c9c  e5940d84          LDR      r0,[r4,#0xd84]        ;4291
006ca0  ebfffffe          BL       yaffs_add_obj_to_dir
                  |L1.27812|
006ca4  e1a08009          MOV      r8,r9                 ;4255
006ca8  e5999000          LDR      r9,[r9,#0]            ;4255
                  |L1.27820|
006cac  e0860086          ADD      r0,r6,r6,LSL #1       ;4255
006cb0  e2841f52          ADD      r1,r4,#0x148          ;4255
006cb4  e0810100          ADD      r0,r1,r0,LSL #2       ;4255
006cb8  e1500008          CMP      r0,r8                 ;4255
006cbc  1affffc0          BNE      |L1.27588|
006cc0  e2866001          ADD      r6,r6,#1              ;4254
                  |L1.27844|
006cc4  e3560c01          CMP      r6,#0x100             ;4254
006cc8  baffffb5          BLT      |L1.27556|
006ccc  e1a00000          MOV      r0,r0
006cd0  eaffffb0          B        |L1.27544|
;;;4296   
                          ENDP

                  yaffs_del_dir_contents PROC
;;;4299    */
;;;4300   static void yaffs_del_dir_contents(struct yaffs_obj *dir)
006cd4  e92d41f0          PUSH     {r4-r8,lr}
;;;4301   {
006cd8  e1a04000          MOV      r4,r0
;;;4302   	struct yaffs_obj *obj;
;;;4303   	struct list_head *lh;
;;;4304   	struct list_head *n;
;;;4305   
;;;4306   	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
006cdc  e5d40064          LDRB     r0,[r4,#0x64]
006ce0  e3500003          CMP      r0,#3
006ce4  0a000005          BEQ      |L1.27904|
;;;4307   		BUG();
006ce8  e1a00000          MOV      r0,r0
006cec  e59f2284          LDR      r2,|L1.28536|
006cf0  e51f17d8          LDR      r1,|L1.25888|
006cf4  e51f07d8          LDR      r0,|L1.25892|
006cf8  ebfffffe          BL       sysprintf
006cfc  e1a00000          MOV      r0,r0
                  |L1.27904|
;;;4308   
;;;4309   	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
006d00  e5946068          LDR      r6,[r4,#0x68]
006d04  e5940068          LDR      r0,[r4,#0x68]
006d08  e5907000          LDR      r7,[r0,#0]
006d0c  ea000010          B        |L1.27988|
                  |L1.27920|
;;;4310   		obj = list_entry(lh, struct yaffs_obj, siblings);
006d10  e2465020          SUB      r5,r6,#0x20
;;;4311   		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
006d14  e5d50064          LDRB     r0,[r5,#0x64]
006d18  e3500003          CMP      r0,#3
006d1c  1a000001          BNE      |L1.27944|
;;;4312   			yaffs_del_dir_contents(obj);
006d20  e1a00005          MOV      r0,r5
006d24  ebfffffe          BL       yaffs_del_dir_contents
                  |L1.27944|
;;;4313   		yaffs_trace(YAFFS_TRACE_SCAN,
006d28  e51f0854          LDR      r0,|L1.25820|
006d2c  e5d00000          LDRB     r0,[r0,#0]  ; yaffs_trace_mask
006d30  e3100008          TST      r0,#8
006d34  0a000002          BEQ      |L1.27972|
006d38  e28f0f8f          ADR      r0,|L1.28540|
006d3c  e5951030          LDR      r1,[r5,#0x30]
006d40  ebfffffe          BL       sysprintf
                  |L1.27972|
;;;4314   			"Deleting lost_found object %d",
;;;4315   			obj->obj_id);
;;;4316   		yaffs_unlink_obj(obj);
006d44  e1a00005          MOV      r0,r5
006d48  ebfffffe          BL       yaffs_unlink_obj
006d4c  e1a06007          MOV      r6,r7                 ;4309
006d50  e5977000          LDR      r7,[r7,#0]            ;4309
                  |L1.27988|
006d54  e2840068          ADD      r0,r4,#0x68           ;4309
006d58  e1560000          CMP      r6,r0                 ;4309
006d5c  1affffeb          BNE      |L1.27920|
;;;4317   	}
;;;4318   }
006d60  e8bd81f0          POP      {r4-r8,pc}
;;;4319   
                          ENDP

                  yaffs_empty_l_n_f PROC
;;;4320   static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
006d64  e92d4010          PUSH     {r4,lr}
;;;4321   {
006d68  e1a04000          MOV      r4,r0
;;;4322   	yaffs_del_dir_contents(dev->lost_n_found);
006d6c  e5940d84          LDR      r0,[r4,#0xd84]
006d70  ebfffffe          BL       yaffs_del_dir_contents
;;;4323   }
006d74  e8bd8010          POP      {r4,pc}
;;;4324   
                          ENDP

                  yaffs_get_obj_length PROC
;;;4462   
;;;4463   loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
006d78  e92d4010          PUSH     {r4,lr}
;;;4464   {
006d7c  e1a04000          MOV      r4,r0
;;;4465   	/* Dereference any hard linking */
;;;4466   	obj = yaffs_get_equivalent_obj(obj);
006d80  e1a00004          MOV      r0,r4
006d84  ebfffffe          BL       yaffs_get_equivalent_obj
006d88  e1a04000          MOV      r4,r0
;;;4467   
;;;4468   	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
006d8c  e5d40064          LDRB     r0,[r4,#0x64]
006d90  e3500001          CMP      r0,#1
006d94  1a000001          BNE      |L1.28064|
;;;4469   		return obj->variant.file_variant.file_size;
006d98  e1c406d8          LDRD     r0,r1,[r4,#0x68]
                  |L1.28060|
;;;4470   	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
;;;4471   		if (!obj->variant.symlink_variant.alias)
;;;4472   			return 0;
;;;4473   		return yaffs_strnlen(obj->variant.symlink_variant.alias,
;;;4474   				     YAFFS_MAX_ALIAS_LENGTH);
;;;4475   	} else {
;;;4476   		/* Only a directory should drop through to here */
;;;4477   		return obj->my_dev->data_bytes_per_chunk;
;;;4478   	}
;;;4479   }
006d9c  e8bd8010          POP      {r4,pc}
                  |L1.28064|
006da0  e5d40064          LDRB     r0,[r4,#0x64]         ;4470
006da4  e3500002          CMP      r0,#2                 ;4470
006da8  1a00000f          BNE      |L1.28140|
006dac  e5940068          LDR      r0,[r4,#0x68]         ;4471
006db0  e3500000          CMP      r0,#0                 ;4471
006db4  1a000002          BNE      |L1.28100|
006db8  e3a00000          MOV      r0,#0                 ;4471
006dbc  e1a01000          MOV      r1,r0                 ;4471
006dc0  eafffff5          B        |L1.28060|
                  |L1.28100|
006dc4  e5940068          LDR      r0,[r4,#0x68]         ;4473
006dc8  ebfffffe          BL       strlen
006dcc  e350009f          CMP      r0,#0x9f              ;4473
006dd0  9a000001          BLS      |L1.28124|
006dd4  e3a0009f          MOV      r0,#0x9f              ;4473
006dd8  ea000001          B        |L1.28132|
                  |L1.28124|
006ddc  e5940068          LDR      r0,[r4,#0x68]         ;4473
006de0  ebfffffe          BL       strlen
                  |L1.28132|
006de4  e3a01000          MOV      r1,#0                 ;4473
006de8  eaffffeb          B        |L1.28060|
                  |L1.28140|
006dec  e5940008          LDR      r0,[r4,#8]            ;4477
006df0  e59000a4          LDR      r0,[r0,#0xa4]         ;4477
006df4  e1a01fc0          ASR      r1,r0,#31             ;4477
006df8  eaffffe7          B        |L1.28060|
;;;4480   
                          ENDP

                  yaffs_get_obj_link_count PROC
;;;4481   int yaffs_get_obj_link_count(struct yaffs_obj *obj)
006dfc  e1a01000          MOV      r1,r0
;;;4482   {
;;;4483   	int count = 0;
006e00  e3a00000          MOV      r0,#0
;;;4484   	struct list_head *i;
;;;4485   
;;;4486   	if (!obj->unlinked)
006e04  e5d13000          LDRB     r3,[r1,#0]
006e08  e1a03e83          LSL      r3,r3,#29
006e0c  e1b03fa3          LSRS     r3,r3,#31
006e10  1a000000          BNE      |L1.28184|
;;;4487   		count++;	/* the object itself */
006e14  e2800001          ADD      r0,r0,#1
                  |L1.28184|
;;;4488   
;;;4489   	list_for_each(i, &obj->hard_links)
006e18  e5912014          LDR      r2,[r1,#0x14]
006e1c  ea000001          B        |L1.28200|
                  |L1.28192|
;;;4490   	    count++;		/* add the hard links; */
006e20  e2800001          ADD      r0,r0,#1
006e24  e5922000          LDR      r2,[r2,#0]            ;4489
                  |L1.28200|
006e28  e2813014          ADD      r3,r1,#0x14           ;4489
006e2c  e1520003          CMP      r2,r3                 ;4489
006e30  1afffffa          BNE      |L1.28192|
;;;4491   
;;;4492   	return count;
;;;4493   }
006e34  e12fff1e          BX       lr
;;;4494   
                          ENDP

                  yaffs_get_obj_inode PROC
;;;4495   int yaffs_get_obj_inode(struct yaffs_obj *obj)
006e38  e92d4010          PUSH     {r4,lr}
;;;4496   {
006e3c  e1a04000          MOV      r4,r0
;;;4497   	obj = yaffs_get_equivalent_obj(obj);
006e40  e1a00004          MOV      r0,r4
006e44  ebfffffe          BL       yaffs_get_equivalent_obj
006e48  e1a04000          MOV      r4,r0
;;;4498   
;;;4499   	return obj->obj_id;
006e4c  e5940030          LDR      r0,[r4,#0x30]
;;;4500   }
006e50  e8bd8010          POP      {r4,pc}
;;;4501   
                          ENDP

                  yaffs_get_obj_type PROC
;;;4502   unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
006e54  e92d4010          PUSH     {r4,lr}
;;;4503   {
006e58  e1a04000          MOV      r4,r0
;;;4504   	obj = yaffs_get_equivalent_obj(obj);
006e5c  e1a00004          MOV      r0,r4
006e60  ebfffffe          BL       yaffs_get_equivalent_obj
006e64  e1a04000          MOV      r4,r0
;;;4505   
;;;4506   	switch (obj->variant_type) {
006e68  e5d40064          LDRB     r0,[r4,#0x64]
006e6c  e3500006          CMP      r0,#6
006e70  308ff100          ADDCC    pc,pc,r0,LSL #2
006e74  ea00002c          B        |L1.28460|
006e78  ea00002b          B        |L1.28460|
006e7c  ea000003          B        |L1.28304|
006e80  ea000008          B        |L1.28328|
006e84  ea000004          B        |L1.28316|
006e88  ea000009          B        |L1.28340|
006e8c  ea00000b          B        |L1.28352|
                  |L1.28304|
;;;4507   	case YAFFS_OBJECT_TYPE_FILE:
006e90  e1a00000          MOV      r0,r0
;;;4508   		return DT_REG;
006e94  e3a00008          MOV      r0,#8
                  |L1.28312|
;;;4509   // 		break;
;;;4510   	case YAFFS_OBJECT_TYPE_DIRECTORY:
;;;4511   		return DT_DIR;
;;;4512   // 		break;
;;;4513   	case YAFFS_OBJECT_TYPE_SYMLINK:
;;;4514   		return DT_LNK;
;;;4515   // 		break;
;;;4516   	case YAFFS_OBJECT_TYPE_HARDLINK:
;;;4517   		return DT_REG;
;;;4518   // 		break;
;;;4519   	case YAFFS_OBJECT_TYPE_SPECIAL:
;;;4520   		if (S_ISFIFO(obj->yst_mode))
;;;4521   			return DT_FIFO;
;;;4522   		if (S_ISCHR(obj->yst_mode))
;;;4523   			return DT_CHR;
;;;4524   		if (S_ISBLK(obj->yst_mode))
;;;4525   			return DT_BLK;
;;;4526   		if (S_ISSOCK(obj->yst_mode))
;;;4527   			return DT_SOCK;
;;;4528   		return DT_REG;
;;;4529   // 		break;
;;;4530   	default:
;;;4531   		return DT_REG;
;;;4532   // 		break;
;;;4533   	}
;;;4534   }
006e98  e8bd8010          POP      {r4,pc}
                  |L1.28316|
006e9c  e1a00000          MOV      r0,r0                 ;4510
006ea0  e3a00004          MOV      r0,#4                 ;4511
006ea4  eafffffb          B        |L1.28312|
                  |L1.28328|
006ea8  e1a00000          MOV      r0,r0                 ;4513
006eac  e3a0000a          MOV      r0,#0xa               ;4514
006eb0  eafffff8          B        |L1.28312|
                  |L1.28340|
006eb4  e1a00000          MOV      r0,r0                 ;4516
006eb8  e3a00008          MOV      r0,#8                 ;4517
006ebc  eafffff5          B        |L1.28312|
                  |L1.28352|
006ec0  e1a00000          MOV      r0,r0                 ;4519
006ec4  e1d403b4          LDRH     r0,[r4,#0x34]         ;4520
006ec8  e2000a0f          AND      r0,r0,#0xf000         ;4520
006ecc  e3500a01          CMP      r0,#0x1000            ;4520
006ed0  1a000001          BNE      |L1.28380|
006ed4  e3a00001          MOV      r0,#1                 ;4521
006ed8  eaffffee          B        |L1.28312|
                  |L1.28380|
006edc  e1d403b4          LDRH     r0,[r4,#0x34]         ;4522
006ee0  e2000a0f          AND      r0,r0,#0xf000         ;4522
006ee4  e3500a02          CMP      r0,#0x2000            ;4522
006ee8  1a000001          BNE      |L1.28404|
006eec  e3a00002          MOV      r0,#2                 ;4523
006ef0  eaffffe8          B        |L1.28312|
                  |L1.28404|
006ef4  e1d403b4          LDRH     r0,[r4,#0x34]         ;4524
006ef8  e2000a0f          AND      r0,r0,#0xf000         ;4524
006efc  e3500a06          CMP      r0,#0x6000            ;4524
006f00  1a000001          BNE      |L1.28428|
006f04  e3a00006          MOV      r0,#6                 ;4525
006f08  eaffffe2          B        |L1.28312|
                  |L1.28428|
006f0c  e1d403b4          LDRH     r0,[r4,#0x34]         ;4526
006f10  e2000a0f          AND      r0,r0,#0xf000         ;4526
006f14  e3500903          CMP      r0,#0xc000            ;4526
006f18  1a000001          BNE      |L1.28452|
006f1c  e3a0000c          MOV      r0,#0xc               ;4527
006f20  eaffffdc          B        |L1.28312|
                  |L1.28452|
006f24  e3a00008          MOV      r0,#8                 ;4528
006f28  eaffffda          B        |L1.28312|
                  |L1.28460|
006f2c  e1a00000          MOV      r0,r0                 ;4530
006f30  e3a00008          MOV      r0,#8                 ;4531
006f34  eaffffd7          B        |L1.28312|
                  |L1.28472|
                          DCD      ||.text||+0x569c
                  |L1.28476|
                          DCD      0x00000fe2
                  |L1.28480|
                          DCD      0x00000fe6
                  |L1.28484|
006f44  79616666          DCB      "yaffs: Hanging object %d moved to lost and found\n",0
006f48  733a2048
006f4c  616e6769
006f50  6e67206f
006f54  626a6563
006f58  74202564
006f5c  206d6f76
006f60  65642074
006f64  6f206c6f
006f68  73742061
006f6c  6e642066
006f70  6f756e64
006f74  0a00    
006f76  00                DCB      0
006f77  00                DCB      0
                  |L1.28536|
                          DCD      0x000010d3
                  |L1.28540|
006f7c  79616666          DCB      "yaffs: Deleting lost_found object %d\n",0
006f80  733a2044
006f84  656c6574
006f88  696e6720
006f8c  6c6f7374
006f90  5f666f75
006f94  6e64206f
006f98  626a6563
006f9c  74202564
006fa0  0a00    
006fa2  00                DCB      0
006fa3  00                DCB      0
                          ENDP

                  yaffs_get_symlink_alias PROC
;;;4535   
;;;4536   YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
006fa4  e92d4010          PUSH     {r4,lr}
;;;4537   {
006fa8  e1a04000          MOV      r4,r0
;;;4538   	obj = yaffs_get_equivalent_obj(obj);
006fac  e1a00004          MOV      r0,r4
006fb0  ebfffffe          BL       yaffs_get_equivalent_obj
006fb4  e1a04000          MOV      r4,r0
;;;4539   	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
006fb8  e5d40064          LDRB     r0,[r4,#0x64]
006fbc  e3500002          CMP      r0,#2
006fc0  1a000002          BNE      |L1.28624|
;;;4540   		return yaffs_clone_str(obj->variant.symlink_variant.alias);
006fc4  e5940068          LDR      r0,[r4,#0x68]
006fc8  ebfffffe          BL       yaffs_clone_str
                  |L1.28620|
;;;4541   	else
;;;4542   		return yaffs_clone_str(_Y(""));
;;;4543   }
006fcc  e8bd8010          POP      {r4,pc}
                  |L1.28624|
006fd0  e28f0f9e          ADR      r0,|L1.29264|
006fd4  ebfffffe          BL       yaffs_clone_str
006fd8  eafffffb          B        |L1.28620|
;;;4544   
                          ENDP

                  yaffs_check_dev_fns PROC
;;;4546   
;;;4547   static int yaffs_check_dev_fns(const struct yaffs_dev *dev)
006fdc  e1a01000          MOV      r1,r0
;;;4548   {
;;;4549   	/* Common functions, gotta have */
;;;4550   	if (!dev->param.erase_fn || !dev->param.initialise_flash_fn)
006fe0  e591004c          LDR      r0,[r1,#0x4c]
006fe4  e3500000          CMP      r0,#0
006fe8  0a000002          BEQ      |L1.28664|
006fec  e5910050          LDR      r0,[r1,#0x50]
006ff0  e3500000          CMP      r0,#0
006ff4  1a000001          BNE      |L1.28672|
                  |L1.28664|
;;;4551   		return 0;
006ff8  e3a00000          MOV      r0,#0
                  |L1.28668|
;;;4552   
;;;4553   	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
;;;4554   	if (dev->param.write_chunk_tags_fn &&
;;;4555   	    dev->param.read_chunk_tags_fn &&
;;;4556   	    !dev->param.write_chunk_fn &&
;;;4557   	    !dev->param.read_chunk_fn &&
;;;4558   	    dev->param.bad_block_fn && dev->param.query_block_fn)
;;;4559   		return 1;
;;;4560   
;;;4561   	/* Can use the "spare" style interface for yaffs1 */
;;;4562   	if (!dev->param.is_yaffs2 &&
;;;4563   	    !dev->param.write_chunk_tags_fn &&
;;;4564   	    !dev->param.read_chunk_tags_fn &&
;;;4565   	    dev->param.write_chunk_fn &&
;;;4566   	    dev->param.read_chunk_fn &&
;;;4567   	    !dev->param.bad_block_fn && !dev->param.query_block_fn)
;;;4568   		return 1;
;;;4569   
;;;4570   	return 0;		/* bad */
;;;4571   }
006ffc  e12fff1e          BX       lr
                  |L1.28672|
007000  e5910058          LDR      r0,[r1,#0x58]         ;4554
007004  e3500000          CMP      r0,#0                 ;4554
007008  0a000010          BEQ      |L1.28752|
00700c  e591005c          LDR      r0,[r1,#0x5c]         ;4555
007010  e3500000          CMP      r0,#0                 ;4555
007014  0a00000d          BEQ      |L1.28752|
007018  e5910044          LDR      r0,[r1,#0x44]         ;4556
00701c  e3500000          CMP      r0,#0                 ;4556
007020  1a00000a          BNE      |L1.28752|
007024  e5910048          LDR      r0,[r1,#0x48]         ;4557
007028  e3500000          CMP      r0,#0                 ;4557
00702c  1a000007          BNE      |L1.28752|
007030  e5910060          LDR      r0,[r1,#0x60]         ;4558
007034  e3500000          CMP      r0,#0                 ;4558
007038  0a000004          BEQ      |L1.28752|
00703c  e5910064          LDR      r0,[r1,#0x64]         ;4558
007040  e3500000          CMP      r0,#0                 ;4558
007044  0a000001          BEQ      |L1.28752|
007048  e3a00001          MOV      r0,#1                 ;4559
00704c  eaffffea          B        |L1.28668|
                  |L1.28752|
007050  e5910030          LDR      r0,[r1,#0x30]         ;4562
007054  e3500000          CMP      r0,#0                 ;4562
007058  1a000013          BNE      |L1.28844|
00705c  e5910058          LDR      r0,[r1,#0x58]         ;4563
007060  e3500000          CMP      r0,#0                 ;4563
007064  1a000010          BNE      |L1.28844|
007068  e591005c          LDR      r0,[r1,#0x5c]         ;4564
00706c  e3500000          CMP      r0,#0                 ;4564
007070  1a00000d          BNE      |L1.28844|
007074  e5910044          LDR      r0,[r1,#0x44]         ;4565
007078  e3500000          CMP      r0,#0                 ;4565
00707c  0a00000a          BEQ      |L1.28844|
007080  e5910048          LDR      r0,[r1,#0x48]         ;4566
007084  e3500000          CMP      r0,#0                 ;4566
007088  0a000007          BEQ      |L1.28844|
00708c  e5910060          LDR      r0,[r1,#0x60]         ;4567
007090  e3500000          CMP      r0,#0                 ;4567
007094  1a000004          BNE      |L1.28844|
007098  e5910064          LDR      r0,[r1,#0x64]         ;4567
00709c  e3500000          CMP      r0,#0                 ;4567
0070a0  1a000001          BNE      |L1.28844|
0070a4  e3a00001          MOV      r0,#1                 ;4568
0070a8  eaffffd3          B        |L1.28668|
                  |L1.28844|
0070ac  e3a00000          MOV      r0,#0                 ;4570
0070b0  eaffffd1          B        |L1.28668|
;;;4572   
                          ENDP

                  yaffs_create_initial_dir PROC
;;;4573   static int yaffs_create_initial_dir(struct yaffs_dev *dev)
0070b4  e92d4010          PUSH     {r4,lr}
;;;4574   {
0070b8  e1a04000          MOV      r4,r0
;;;4575   	/* Initialise the unlinked, deleted, root and lost+found directories */
;;;4576   	dev->lost_n_found = dev->root_dir = NULL;
0070bc  e3a00000          MOV      r0,#0
0070c0  e5840d80          STR      r0,[r4,#0xd80]
0070c4  e5840d84          STR      r0,[r4,#0xd84]
;;;4577   	dev->unlinked_dir = dev->del_dir = NULL;
0070c8  e5840d9c          STR      r0,[r4,#0xd9c]
0070cc  e5840d98          STR      r0,[r4,#0xd98]
;;;4578   	dev->unlinked_dir =
0070d0  e3a02901          MOV      r2,#0x4000
0070d4  e3a01003          MOV      r1,#3
0070d8  e1a00004          MOV      r0,r4
0070dc  ebfffffe          BL       yaffs_create_fake_dir
0070e0  e5840d98          STR      r0,[r4,#0xd98]
;;;4579   	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
;;;4580   	dev->del_dir =
0070e4  e3a02901          MOV      r2,#0x4000
0070e8  e3a01004          MOV      r1,#4
0070ec  e1a00004          MOV      r0,r4
0070f0  ebfffffe          BL       yaffs_create_fake_dir
0070f4  e5840d9c          STR      r0,[r4,#0xd9c]
;;;4581   	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
;;;4582   	dev->root_dir =
0070f8  e59f2154          LDR      r2,|L1.29268|
0070fc  e3a01001          MOV      r1,#1
007100  e1a00004          MOV      r0,r4
007104  ebfffffe          BL       yaffs_create_fake_dir
007108  e5840d80          STR      r0,[r4,#0xd80]
;;;4583   	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
;;;4584   				  YAFFS_ROOT_MODE | S_IFDIR);
;;;4585   	dev->lost_n_found =
00710c  e59f2140          LDR      r2,|L1.29268|
007110  e3a01002          MOV      r1,#2
007114  e1a00004          MOV      r0,r4
007118  ebfffffe          BL       yaffs_create_fake_dir
00711c  e5840d84          STR      r0,[r4,#0xd84]
;;;4586   	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
;;;4587   				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
;;;4588   
;;;4589   	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
007120  e5940d84          LDR      r0,[r4,#0xd84]
007124  e3500000          CMP      r0,#0
007128  0a00000d          BEQ      |L1.29028|
00712c  e5940d80          LDR      r0,[r4,#0xd80]
007130  e3500000          CMP      r0,#0
007134  0a00000a          BEQ      |L1.29028|
007138  e5940d98          LDR      r0,[r4,#0xd98]
00713c  e3500000          CMP      r0,#0
007140  0a000007          BEQ      |L1.29028|
;;;4590   	    && dev->del_dir) {
007144  e5940d9c          LDR      r0,[r4,#0xd9c]
007148  e3500000          CMP      r0,#0
00714c  0a000004          BEQ      |L1.29028|
;;;4591   		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
007150  e5940d80          LDR      r0,[r4,#0xd80]
007154  e5941d84          LDR      r1,[r4,#0xd84]
007158  ebfffffe          BL       yaffs_add_obj_to_dir
;;;4592   		return YAFFS_OK;
00715c  e3a00001          MOV      r0,#1
                  |L1.29024|
;;;4593   	}
;;;4594   	return YAFFS_FAIL;
;;;4595   }
007160  e8bd8010          POP      {r4,pc}
                  |L1.29028|
007164  e3a00000          MOV      r0,#0                 ;4594
007168  eafffffc          B        |L1.29024|
;;;4596   
                          ENDP

                  yaffs_deinitialise PROC
;;;4912   
;;;4913   void yaffs_deinitialise(struct yaffs_dev *dev)
00716c  e92d4070          PUSH     {r4-r6,lr}
;;;4914   {
007170  e1a04000          MOV      r4,r0
;;;4915   	if (dev->is_mounted) {
007174  e59400c4          LDR      r0,[r4,#0xc4]
007178  e3500000          CMP      r0,#0
00717c  0a000032          BEQ      |L1.29260|
;;;4916   		int i;
;;;4917   
;;;4918   		yaffs_deinit_blocks(dev);
007180  e1a00004          MOV      r0,r4
007184  ebfffffe          BL       yaffs_deinit_blocks
;;;4919   		yaffs_deinit_tnodes_and_objs(dev);
007188  e1a00004          MOV      r0,r4
00718c  ebfffffe          BL       yaffs_deinit_tnodes_and_objs
;;;4920   		yaffs_summary_deinit(dev);
007190  e1a00004          MOV      r0,r4
007194  ebfffffe          BL       yaffs_summary_deinit
;;;4921   
;;;4922   		if (dev->param.n_caches > 0 && dev->cache) {
007198  e5940020          LDR      r0,[r4,#0x20]
00719c  e3500000          CMP      r0,#0
0071a0  da000016          BLE      |L1.29184|
0071a4  e5940d90          LDR      r0,[r4,#0xd90]
0071a8  e3500000          CMP      r0,#0
0071ac  0a000013          BEQ      |L1.29184|
;;;4923   
;;;4924   			for (i = 0; i < dev->param.n_caches; i++) {
0071b0  e3a05000          MOV      r5,#0
0071b4  ea00000a          B        |L1.29156|
                  |L1.29112|
;;;4925   				yaffs_free(dev->cache[i].data);
0071b8  e0652185          RSB      r2,r5,r5,LSL #3
0071bc  e5941d90          LDR      r1,[r4,#0xd90]
0071c0  e0811102          ADD      r1,r1,r2,LSL #2
0071c4  e5910018          LDR      r0,[r1,#0x18]
0071c8  ebfffffe          BL       yaffs_free
;;;4926   				dev->cache[i].data = NULL;
0071cc  e3a00000          MOV      r0,#0
0071d0  e0652185          RSB      r2,r5,r5,LSL #3
0071d4  e5941d90          LDR      r1,[r4,#0xd90]
0071d8  e0811102          ADD      r1,r1,r2,LSL #2
0071dc  e5810018          STR      r0,[r1,#0x18]
0071e0  e2855001          ADD      r5,r5,#1              ;4924
                  |L1.29156|
0071e4  e5940020          LDR      r0,[r4,#0x20]         ;4924
0071e8  e1500005          CMP      r0,r5                 ;4924
0071ec  cafffff1          BGT      |L1.29112|
;;;4927   			}
;;;4928   
;;;4929   			yaffs_free(dev->cache);
0071f0  e5940d90          LDR      r0,[r4,#0xd90]
0071f4  ebfffffe          BL       yaffs_free
;;;4930   			dev->cache = NULL;
0071f8  e3a00000          MOV      r0,#0
0071fc  e5840d90          STR      r0,[r4,#0xd90]
                  |L1.29184|
;;;4931   		}
;;;4932   
;;;4933   		yaffs_free(dev->gc_cleanup_list);
007200  e5940d50          LDR      r0,[r4,#0xd50]
007204  ebfffffe          BL       yaffs_free
;;;4934   
;;;4935   		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
007208  e3a05000          MOV      r5,#0
00720c  ea000003          B        |L1.29216|
                  |L1.29200|
;;;4936   			yaffs_free(dev->temp_buffer[i].buffer);
007210  e2841edb          ADD      r1,r4,#0xdb0
007214  e7910185          LDR      r0,[r1,r5,LSL #3]
007218  ebfffffe          BL       yaffs_free
00721c  e2855001          ADD      r5,r5,#1              ;4935
                  |L1.29216|
007220  e3550006          CMP      r5,#6                 ;4935
007224  bafffff9          BLT      |L1.29200|
;;;4937   
;;;4938   		dev->is_mounted = 0;
007228  e3a00000          MOV      r0,#0
00722c  e58400c4          STR      r0,[r4,#0xc4]
;;;4939   
;;;4940   		if (dev->param.deinitialise_flash_fn)
007230  e5940054          LDR      r0,[r4,#0x54]
007234  e3500000          CMP      r0,#0
007238  0a000002          BEQ      |L1.29256|
;;;4941   			dev->param.deinitialise_flash_fn(dev);
00723c  e5941054          LDR      r1,[r4,#0x54]
007240  e1a00004          MOV      r0,r4
007244  e12fff31          BLX      r1
                  |L1.29256|
;;;4942   	}
007248  e1a00000          MOV      r0,r0
                  |L1.29260|
;;;4943   }
00724c  e8bd8070          POP      {r4-r6,pc}
                  |L1.29264|
007250  00                DCB      0
007251  00                DCB      0
007252  00                DCB      0
007253  00                DCB      0
                  |L1.29268|
                          DCD      0x000041b6
                          ENDP

                  yaffs_guts_initialise PROC
;;;4596   
;;;4597   int yaffs_guts_initialise(struct yaffs_dev *dev)
007258  e92d47f0          PUSH     {r4-r10,lr}
;;;4598   {
00725c  e1a04000          MOV      r4,r0
;;;4599   	int init_failed = 0;
007260  e3a05000          MOV      r5,#0
;;;4600   	unsigned x;
;;;4601   	int bits;
;;;4602   
;;;4603   	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()");
007264  e51f0d90          LDR      r0,|L1.25820|
007268  e1d000b0          LDRH     r0,[r0,#0]  ; yaffs_trace_mask
00726c  e3100c01          TST      r0,#0x100
007270  0a000001          BEQ      |L1.29308|
007274  e28f0fbe          ADR      r0,|L1.30068|
007278  ebfffffe          BL       sysprintf
                  |L1.29308|
;;;4604   
;;;4605   	/* Check stuff that must be set */
;;;4606   
;;;4607   	if (!dev) {
00727c  e3540000          CMP      r4,#0
007280  1a000007          BNE      |L1.29348|
;;;4608   		yaffs_trace(YAFFS_TRACE_ALWAYS,
007284  e51f0db0          LDR      r0,|L1.25820|
007288  e5900000          LDR      r0,[r0,#0]  ; yaffs_trace_mask
00728c  e310020f          TST      r0,#0xf0000000
007290  0a000001          BEQ      |L1.29340|
007294  e28f0c03          ADR      r0,|L1.30108|
007298  ebfffffe          BL       sysprintf
                  |L1.29340|
;;;4609   			"yaffs: Need a device"
;;;4610   			);
;;;4611   		return YAFFS_FAIL;
00729c  e3a00000          MOV      r0,#0
                  |L1.29344|
;;;4612   	}
;;;4613   
;;;4614   	if (dev->is_mounted) {
;;;4615   		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
;;;4616   		return YAFFS_FAIL;
;;;4617   	}
;;;4618   
;;;4619   	dev->internal_start_block = dev->param.start_block;
;;;4620   	dev->internal_end_block = dev->param.end_block;
;;;4621   	dev->block_offset = 0;
;;;4622   	dev->chunk_offset = 0;
;;;4623   	dev->n_free_chunks = 0;
;;;4624   
;;;4625   	dev->gc_block = 0;
;;;4626   
;;;4627   	if (dev->param.start_block == 0) {
;;;4628   		dev->internal_start_block = dev->param.start_block + 1;
;;;4629   		dev->internal_end_block = dev->param.end_block + 1;
;;;4630   		dev->block_offset = 1;
;;;4631   		dev->chunk_offset = dev->param.chunks_per_block;
;;;4632   	}
;;;4633   
;;;4634   	/* Check geometry parameters. */
;;;4635   
;;;4636   	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
;;;4637   		dev->param.total_bytes_per_chunk < 1024) ||
;;;4638   		(!dev->param.is_yaffs2 &&
;;;4639   			dev->param.total_bytes_per_chunk < 512) ||
;;;4640   		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
;;;4641   		 dev->param.chunks_per_block < 2 ||
;;;4642   		 dev->param.n_reserved_blocks < 2 ||
;;;4643   		dev->internal_start_block <= 0 ||
;;;4644   		dev->internal_end_block <= 0 ||
;;;4645   		dev->internal_end_block <=
;;;4646   		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
;;;4647   		) {
;;;4648   		/* otherwise it is too small */
;;;4649   		yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;4650   			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
;;;4651   			dev->param.total_bytes_per_chunk,
;;;4652   			dev->param.is_yaffs2 ? "2" : "",
;;;4653   			dev->param.inband_tags);
;;;4654   		return YAFFS_FAIL;
;;;4655   	}
;;;4656   
;;;4657   	if (yaffs_init_nand(dev) != YAFFS_OK) {
;;;4658   		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
;;;4659   		return YAFFS_FAIL;
;;;4660   	}
;;;4661   
;;;4662   	/* Sort out space for inband tags, if required */
;;;4663   	if (dev->param.inband_tags)
;;;4664   		dev->data_bytes_per_chunk =
;;;4665   		    dev->param.total_bytes_per_chunk -
;;;4666   		    sizeof(struct yaffs_packed_tags2_tags_only);
;;;4667   	else
;;;4668   		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
;;;4669   
;;;4670   	/* Got the right mix of functions? */
;;;4671   	if (!yaffs_check_dev_fns(dev)) {
;;;4672   		/* Function missing */
;;;4673   		yaffs_trace(YAFFS_TRACE_ALWAYS,
;;;4674   			"device function(s) missing or wrong");
;;;4675   
;;;4676   		return YAFFS_FAIL;
;;;4677   	}
;;;4678   
;;;4679   	/* Finished with most checks. Further checks happen later on too. */
;;;4680   
;;;4681   	dev->is_mounted = 1;
;;;4682   
;;;4683   	/* OK now calculate a few things for the device */
;;;4684   
;;;4685   	/*
;;;4686   	 *  Calculate all the chunk size manipulation numbers:
;;;4687   	 */
;;;4688   	x = dev->data_bytes_per_chunk;
;;;4689   	/* We always use dev->chunk_shift and dev->chunk_div */
;;;4690   	dev->chunk_shift = calc_shifts(x);
;;;4691   	x >>= dev->chunk_shift;
;;;4692   	dev->chunk_div = x;
;;;4693   	/* We only use chunk mask if chunk_div is 1 */
;;;4694   	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
;;;4695   
;;;4696   	/*
;;;4697   	 * Calculate chunk_grp_bits.
;;;4698   	 * We need to find the next power of 2 > than internal_end_block
;;;4699   	 */
;;;4700   
;;;4701   	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
;;;4702   
;;;4703   	bits = calc_shifts_ceiling(x);
;;;4704   
;;;4705   	/* Set up tnode width if wide tnodes are enabled. */
;;;4706   	if (!dev->param.wide_tnodes_disabled) {
;;;4707   		/* bits must be even so that we end up with 32-bit words */
;;;4708   		if (bits & 1)
;;;4709   			bits++;
;;;4710   		if (bits < 16)
;;;4711   			dev->tnode_width = 16;
;;;4712   		else
;;;4713   			dev->tnode_width = bits;
;;;4714   	} else {
;;;4715   		dev->tnode_width = 16;
;;;4716   	}
;;;4717   
;;;4718   	dev->tnode_mask = (1 << dev->tnode_width) - 1;
;;;4719   
;;;4720   	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
;;;4721   	 * so if the bitwidth of the
;;;4722   	 * chunk range we're using is greater than 16 we need
;;;4723   	 * to figure out chunk shift and chunk_grp_size
;;;4724   	 */
;;;4725   
;;;4726   	if (bits <= dev->tnode_width)
;;;4727   		dev->chunk_grp_bits = 0;
;;;4728   	else
;;;4729   		dev->chunk_grp_bits = bits - dev->tnode_width;
;;;4730   
;;;4731   	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
;;;4732   	if (dev->tnode_size < sizeof(struct yaffs_tnode))
;;;4733   		dev->tnode_size = sizeof(struct yaffs_tnode);
;;;4734   
;;;4735   	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
;;;4736   
;;;4737   	if (dev->param.chunks_per_block < dev->chunk_grp_size) {
;;;4738   		/* We have a problem because the soft delete won't work if
;;;4739   		 * the chunk group size > chunks per block.
;;;4740   		 * This can be remedied by using larger "virtual blocks".
;;;4741   		 */
;;;4742   		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
;;;4743   
;;;4744   		return YAFFS_FAIL;
;;;4745   	}
;;;4746   
;;;4747   	/* Finished verifying the device, continue with initialisation */
;;;4748   
;;;4749   	/* More device initialisation */
;;;4750   	dev->all_gcs = 0;
;;;4751   	dev->passive_gc_count = 0;
;;;4752   	dev->oldest_dirty_gc_count = 0;
;;;4753   	dev->bg_gcs = 0;
;;;4754   	dev->gc_block_finder = 0;
;;;4755   	dev->buffered_block = -1;
;;;4756   	dev->doing_buffered_block_rewrite = 0;
;;;4757   	dev->n_deleted_files = 0;
;;;4758   	dev->n_bg_deletions = 0;
;;;4759   	dev->n_unlinked_files = 0;
;;;4760   	dev->n_ecc_fixed = 0;
;;;4761   	dev->n_ecc_unfixed = 0;
;;;4762   	dev->n_tags_ecc_fixed = 0;
;;;4763   	dev->n_tags_ecc_unfixed = 0;
;;;4764   	dev->n_erase_failures = 0;
;;;4765   	dev->n_erased_blocks = 0;
;;;4766   	dev->gc_disable = 0;
;;;4767   	dev->has_pending_prioritised_gc = 1;
;;;4768   		/* Assume the worst for now, will get fixed on first GC */
;;;4769   	INIT_LIST_HEAD(&dev->dirty_dirs);
;;;4770   	dev->oldest_dirty_seq = 0;
;;;4771   	dev->oldest_dirty_block = 0;
;;;4772   
;;;4773   	/* Initialise temporary buffers and caches. */
;;;4774   	if (!yaffs_init_tmp_buffers(dev))
;;;4775   		init_failed = 1;
;;;4776   
;;;4777   	dev->cache = NULL;
;;;4778   	dev->gc_cleanup_list = NULL;
;;;4779   
;;;4780   	if (!init_failed && dev->param.n_caches > 0) {
;;;4781   		int i;
;;;4782   		void *buf;
;;;4783   		int cache_bytes =
;;;4784   		    dev->param.n_caches * sizeof(struct yaffs_cache);
;;;4785   
;;;4786   		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
;;;4787   			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
;;;4788   
;;;4789   // 		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
;;;4790   		dev->cache = yaffs_malloc(cache_bytes);
;;;4791   
;;;4792   		buf = (u8 *) dev->cache;
;;;4793   
;;;4794   		if (dev->cache)
;;;4795   			memset(dev->cache, 0, cache_bytes);
;;;4796   
;;;4797   		for (i = 0; i < dev->param.n_caches && buf; i++) {
;;;4798   			dev->cache[i].object = NULL;
;;;4799   			dev->cache[i].last_use = 0;
;;;4800   			dev->cache[i].dirty = 0;
;;;4801   // 			dev->cache[i].data = buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
;;;4802   			dev->cache[i].data = buf = yaffs_malloc(dev->param.total_bytes_per_chunk);
;;;4803   		}
;;;4804   		if (!buf)
;;;4805   			init_failed = 1;
;;;4806   
;;;4807   		dev->cache_last_use = 0;
;;;4808   	}
;;;4809   
;;;4810   	dev->cache_hits = 0;
;;;4811   
;;;4812   	if (!init_failed) {
;;;4813   // 		dev->gc_cleanup_list = kmalloc(dev->param.chunks_per_block * sizeof(u32), GFP_NOFS);
;;;4814   		dev->gc_cleanup_list = yaffs_malloc(dev->param.chunks_per_block * sizeof(u32));
;;;4815   		if (!dev->gc_cleanup_list)
;;;4816   			init_failed = 1;
;;;4817   	}
;;;4818   
;;;4819   	if (dev->param.is_yaffs2)
;;;4820   		dev->param.use_header_file_size = 1;
;;;4821   
;;;4822   	if (!init_failed && !yaffs_init_blocks(dev))
;;;4823   		init_failed = 1;
;;;4824   
;;;4825   	yaffs_init_tnodes_and_objs(dev);
;;;4826   
;;;4827   	if (!init_failed && !yaffs_create_initial_dir(dev))
;;;4828   		init_failed = 1;
;;;4829   
;;;4830   	if (!init_failed && dev->param.is_yaffs2 &&
;;;4831   		!dev->param.disable_summary &&
;;;4832   		!yaffs_summary_init(dev))
;;;4833   		init_failed = 1;
;;;4834   
;;;4835   	if (!init_failed) {
;;;4836   		/* Now scan the flash. */
;;;4837   		if (dev->param.is_yaffs2) {
;;;4838   			if (yaffs2_checkpt_restore(dev)) {
;;;4839   				yaffs_check_obj_details_loaded(dev->root_dir);
;;;4840   				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
;;;4841   					YAFFS_TRACE_MOUNT,
;;;4842   					"yaffs: restored from checkpoint"
;;;4843   					);
;;;4844   			} else {
;;;4845   
;;;4846   				/* Clean up the mess caused by an aborted
;;;4847   				 * checkpoint load then scan backwards.
;;;4848   				 */
;;;4849   				yaffs_deinit_blocks(dev);
;;;4850   
;;;4851   				yaffs_deinit_tnodes_and_objs(dev);
;;;4852   
;;;4853   				dev->n_erased_blocks = 0;
;;;4854   				dev->n_free_chunks = 0;
;;;4855   				dev->alloc_block = -1;
;;;4856   				dev->alloc_page = -1;
;;;4857   				dev->n_deleted_files = 0;
;;;4858   				dev->n_unlinked_files = 0;
;;;4859   				dev->n_bg_deletions = 0;
;;;4860   
;;;4861   				if (!init_failed && !yaffs_init_blocks(dev))
;;;4862   					init_failed = 1;
;;;4863   
;;;4864   				yaffs_init_tnodes_and_objs(dev);
;;;4865   
;;;4866   				if (!init_failed
;;;4867   				    && !yaffs_create_initial_dir(dev))
;;;4868   					init_failed = 1;
;;;4869   
;;;4870   				if (!init_failed && !yaffs2_scan_backwards(dev))
;;;4871   					init_failed = 1;
;;;4872   			}
;;;4873   		} else if (!yaffs1_scan(dev)) {
;;;4874   			init_failed = 1;
;;;4875   		}
;;;4876   
;;;4877   		yaffs_strip_deleted_objs(dev);
;;;4878   		yaffs_fix_hanging_objs(dev);
;;;4879   		if (dev->param.empty_lost_n_found)
;;;4880   			yaffs_empty_l_n_f(dev);
;;;4881   	}
;;;4882   
;;;4883   	if (init_failed) {
;;;4884   		/* Clean up the mess */
;;;4885   		yaffs_trace(YAFFS_TRACE_TRACING,
;;;4886   		  "yaffs: yaffs_guts_initialise() aborted.");
;;;4887   
;;;4888   		yaffs_deinitialise(dev);
;;;4889   		return YAFFS_FAIL;
;;;4890   	}
;;;4891   
;;;4892   	/* Zero out stats */
;;;4893   	dev->n_page_reads = 0;
;;;4894   	dev->n_page_writes = 0;
;;;4895   	dev->n_erasures = 0;
;;;4896   	dev->n_gc_copies = 0;
;;;4897   	dev->n_retried_writes = 0;
;;;4898   
;;;4899   	dev->n_retired_blocks = 0;
;;;4900   
;;;4901   	yaffs_verify_free_chunks(dev);
;;;4902   	yaffs_verify_blocks(dev);
;;;4903   
;;;4904   	/* Clean up any aborted checkpoint data */
;;;4905   	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
;;;4906   		yaffs2_checkpt_invalidate(dev);
;;;4907   
;;;4908   	yaffs_trace(YAFFS_TRACE_TRACING,
;;;4909   	  "yaffs: yaffs_guts_initialise() done.");
;;;4910   	return YAFFS_OK;
;;;4911   }
0072a0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.29348|
0072a4  e59400c4          LDR      r0,[r4,#0xc4]         ;4614
0072a8  e3500000          CMP      r0,#0                 ;4614
0072ac  0a000007          BEQ      |L1.29392|
0072b0  e51f0ddc          LDR      r0,|L1.25820|
0072b4  e5900000          LDR      r0,[r0,#0]            ;4615  ; yaffs_trace_mask
0072b8  e310020f          TST      r0,#0xf0000000        ;4615
0072bc  0a000001          BEQ      |L1.29384|
0072c0  e28f0fbd          ADR      r0,|L1.30140|
0072c4  ebfffffe          BL       sysprintf
                  |L1.29384|
0072c8  e3a00000          MOV      r0,#0                 ;4616
0072cc  eafffff3          B        |L1.29344|
                  |L1.29392|
0072d0  e5940014          LDR      r0,[r4,#0x14]         ;4619
0072d4  e58400d0          STR      r0,[r4,#0xd0]         ;4619
0072d8  e5940018          LDR      r0,[r4,#0x18]         ;4620
0072dc  e58400d4          STR      r0,[r4,#0xd4]         ;4620
0072e0  e3a00000          MOV      r0,#0                 ;4621
0072e4  e58400d8          STR      r0,[r4,#0xd8]         ;4621
0072e8  e58400dc          STR      r0,[r4,#0xdc]         ;4622
0072ec  e5840d4c          STR      r0,[r4,#0xd4c]        ;4623
0072f0  e5840d70          STR      r0,[r4,#0xd70]        ;4625
0072f4  e5940014          LDR      r0,[r4,#0x14]         ;4627
0072f8  e3500000          CMP      r0,#0                 ;4627
0072fc  1a000009          BNE      |L1.29480|
007300  e5940014          LDR      r0,[r4,#0x14]         ;4628
007304  e2800001          ADD      r0,r0,#1              ;4628
007308  e58400d0          STR      r0,[r4,#0xd0]         ;4628
00730c  e5940018          LDR      r0,[r4,#0x18]         ;4629
007310  e2800001          ADD      r0,r0,#1              ;4629
007314  e58400d4          STR      r0,[r4,#0xd4]         ;4629
007318  e3a00001          MOV      r0,#1                 ;4630
00731c  e58400d8          STR      r0,[r4,#0xd8]         ;4630
007320  e594000c          LDR      r0,[r4,#0xc]          ;4631
007324  e58400dc          STR      r0,[r4,#0xdc]         ;4631
                  |L1.29480|
007328  e5940004          LDR      r0,[r4,#4]            ;4636
00732c  e3500000          CMP      r0,#0                 ;4636
007330  1a000005          BNE      |L1.29516|
007334  e5940030          LDR      r0,[r4,#0x30]         ;4636
007338  e3500000          CMP      r0,#0                 ;4636
00733c  0a000002          BEQ      |L1.29516|
007340  e5940008          LDR      r0,[r4,#8]            ;4637
007344  e3500b01          CMP      r0,#0x400             ;4637
007348  3a00001e          BCC      |L1.29640|
                  |L1.29516|
00734c  e5940030          LDR      r0,[r4,#0x30]         ;4638
007350  e3500000          CMP      r0,#0                 ;4638
007354  1a000002          BNE      |L1.29540|
007358  e5940008          LDR      r0,[r4,#8]            ;4639
00735c  e3500c02          CMP      r0,#0x200             ;4639
007360  3a000018          BCC      |L1.29640|
                  |L1.29540|
007364  e5940004          LDR      r0,[r4,#4]            ;4640
007368  e3500000          CMP      r0,#0                 ;4640
00736c  0a000002          BEQ      |L1.29564|
007370  e5940030          LDR      r0,[r4,#0x30]         ;4640
007374  e3500000          CMP      r0,#0                 ;4640
007378  0a000012          BEQ      |L1.29640|
                  |L1.29564|
00737c  e594000c          LDR      r0,[r4,#0xc]          ;4641
007380  e3500002          CMP      r0,#2                 ;4641
007384  ba00000f          BLT      |L1.29640|
007388  e594001c          LDR      r0,[r4,#0x1c]         ;4642
00738c  e3500002          CMP      r0,#2                 ;4642
007390  ba00000c          BLT      |L1.29640|
007394  e59400d0          LDR      r0,[r4,#0xd0]         ;4643
007398  e3500000          CMP      r0,#0                 ;4643
00739c  da000009          BLE      |L1.29640|
0073a0  e59400d4          LDR      r0,[r4,#0xd4]         ;4644
0073a4  e3500000          CMP      r0,#0                 ;4644
0073a8  da000006          BLE      |L1.29640|
0073ac  e59400d0          LDR      r0,[r4,#0xd0]         ;4645
0073b0  e594101c          LDR      r1,[r4,#0x1c]         ;4645
0073b4  e0800001          ADD      r0,r0,r1              ;4645
0073b8  e2800002          ADD      r0,r0,#2              ;4645
0073bc  e59410d4          LDR      r1,[r4,#0xd4]         ;4645
0073c0  e1500001          CMP      r0,r1                 ;4645
0073c4  ba000010          BLT      |L1.29708|
                  |L1.29640|
0073c8  e51f0ef4          LDR      r0,|L1.25820|
0073cc  e5900000          LDR      r0,[r0,#0]            ;4649  ; yaffs_trace_mask
0073d0  e310020f          TST      r0,#0xf0000000        ;4649
0073d4  0a00000a          BEQ      |L1.29700|
0073d8  e5940030          LDR      r0,[r4,#0x30]         ;4649
0073dc  e3500000          CMP      r0,#0                 ;4649
0073e0  e5943004          LDR      r3,[r4,#4]            ;4649
0073e4  0a000001          BEQ      |L1.29680|
0073e8  e28f0f7b          ADR      r0,|L1.30172|
0073ec  ea000000          B        |L1.29684|
                  |L1.29680|
0073f0  e28f0d07          ADR      r0,|L1.30136|
                  |L1.29684|
0073f4  e1a02000          MOV      r2,r0                 ;4649
0073f8  e59f01e0          LDR      r0,|L1.30176|
0073fc  e5941008          LDR      r1,[r4,#8]            ;4649
007400  ebfffffe          BL       sysprintf
                  |L1.29700|
007404  e3a00000          MOV      r0,#0                 ;4654
007408  eaffffa4          B        |L1.29344|
                  |L1.29708|
00740c  e1a00004          MOV      r0,r4                 ;4657
007410  ebfffffe          BL       yaffs_init_nand
007414  e3500001          CMP      r0,#1                 ;4657
007418  0a000007          BEQ      |L1.29756|
00741c  e51f0f48          LDR      r0,|L1.25820|
007420  e5900000          LDR      r0,[r0,#0]            ;4658  ; yaffs_trace_mask
007424  e310020f          TST      r0,#0xf0000000        ;4658
007428  0a000001          BEQ      |L1.29748|
00742c  e28f0e1b          ADR      r0,|L1.30180|
007430  ebfffffe          BL       sysprintf
                  |L1.29748|
007434  e3a00000          MOV      r0,#0                 ;4659
007438  eaffff98          B        |L1.29344|
                  |L1.29756|
00743c  e5940004          LDR      r0,[r4,#4]            ;4663
007440  e3500000          CMP      r0,#0                 ;4663
007444  0a000003          BEQ      |L1.29784|
007448  e5940008          LDR      r0,[r4,#8]            ;4664
00744c  e2400010          SUB      r0,r0,#0x10           ;4664
007450  e58400a4          STR      r0,[r4,#0xa4]         ;4664
007454  ea000001          B        |L1.29792|
                  |L1.29784|
007458  e5940008          LDR      r0,[r4,#8]            ;4668
00745c  e58400a4          STR      r0,[r4,#0xa4]         ;4668
                  |L1.29792|
007460  e1a00004          MOV      r0,r4                 ;4671
007464  ebfffffe          BL       yaffs_check_dev_fns
007468  e3500000          CMP      r0,#0                 ;4671
00746c  1a000007          BNE      |L1.29840|
007470  e51f0f9c          LDR      r0,|L1.25820|
007474  e5900000          LDR      r0,[r0,#0]            ;4673  ; yaffs_trace_mask
007478  e310020f          TST      r0,#0xf0000000        ;4673
00747c  0a000001          BEQ      |L1.29832|
007480  e28f0f5f          ADR      r0,|L1.30212|
007484  ebfffffe          BL       sysprintf
                  |L1.29832|
007488  e3a00000          MOV      r0,#0                 ;4676
00748c  eaffff83          B        |L1.29344|
                  |L1.29840|
007490  e3a00001          MOV      r0,#1                 ;4681
007494  e58400c4          STR      r0,[r4,#0xc4]         ;4681
007498  e59480a4          LDR      r8,[r4,#0xa4]         ;4688
00749c  e1a00008          MOV      r0,r8                 ;4690
0074a0  e3a01000          MOV      r1,#0                 ;4690
0074a4  e3500000          CMP      r0,#0                 ;4690
0074a8  1a000001          BNE      |L1.29876|
0074ac  e3a02000          MOV      r2,#0                 ;4690
0074b0  ea000005          B        |L1.29900|
                  |L1.29876|
0074b4  ea000001          B        |L1.29888|
                  |L1.29880|
0074b8  e1a000a0          LSR      r0,r0,#1              ;4690
0074bc  e2811001          ADD      r1,r1,#1              ;4690
                  |L1.29888|
0074c0  e3100001          TST      r0,#1                 ;4690
0074c4  0afffffb          BEQ      |L1.29880|
0074c8  e1a02001          MOV      r2,r1                 ;4690
                  |L1.29900|
0074cc  e1a00000          MOV      r0,r0                 ;4690
0074d0  e58420b8          STR      r2,[r4,#0xb8]         ;4690
0074d4  e5d400b8          LDRB     r0,[r4,#0xb8]         ;4691
0074d8  e1a08038          LSR      r8,r8,r0              ;4691
0074dc  e58480bc          STR      r8,[r4,#0xbc]         ;4692
0074e0  e5d400b8          LDRB     r0,[r4,#0xb8]         ;4694
0074e4  e3a01001          MOV      r1,#1                 ;4694
0074e8  e1a00011          LSL      r0,r1,r0              ;4694
0074ec  e2400001          SUB      r0,r0,#1              ;4694
0074f0  e58400c0          STR      r0,[r4,#0xc0]         ;4694
0074f4  e59410d4          LDR      r1,[r4,#0xd4]         ;4701
0074f8  e2811001          ADD      r1,r1,#1              ;4701
0074fc  e594000c          LDR      r0,[r4,#0xc]          ;4701
007500  e0080190          MUL      r8,r0,r1              ;4701
007504  e1a00008          MOV      r0,r8                 ;4703
007508  e3a03000          MOV      r3,#0                 ;4703
00750c  e1a02003          MOV      r2,r3                 ;4703
007510  e1a01003          MOV      r1,r3                 ;4703
007514  ea000004          B        |L1.29996|
                  |L1.29976|
007518  e3100001          TST      r0,#1                 ;4703
00751c  0a000000          BEQ      |L1.29988|
007520  e2822001          ADD      r2,r2,#1              ;4703
                  |L1.29988|
007524  e1a000a0          LSR      r0,r0,#1              ;4703
007528  e2811001          ADD      r1,r1,#1              ;4703
                  |L1.29996|
00752c  e3500001          CMP      r0,#1                 ;4703
007530  8afffff8          BHI      |L1.29976|
007534  e3520000          CMP      r2,#0                 ;4703
007538  0a000000          BEQ      |L1.30016|
00753c  e2811001          ADD      r1,r1,#1              ;4703
                  |L1.30016|
007540  e1a00000          MOV      r0,r0                 ;4703
007544  e1a06001          MOV      r6,r1                 ;4703
007548  e594007c          LDR      r0,[r4,#0x7c]         ;4706
00754c  e3500000          CMP      r0,#0                 ;4706
007550  1a000038          BNE      |L1.30264|
007554  e3160001          TST      r6,#1                 ;4708
007558  0a000000          BEQ      |L1.30048|
00755c  e2866001          ADD      r6,r6,#1              ;4709
                  |L1.30048|
007560  e3560010          CMP      r6,#0x10              ;4710
007564  aa000031          BGE      |L1.30256|
007568  e3a00010          MOV      r0,#0x10              ;4711
00756c  e58400ac          STR      r0,[r4,#0xac]         ;4711
007570  ea000032          B        |L1.30272|
                  |L1.30068|
007574  79616666          DCB      "yaffs: yaffs: yaffs_guts_initialise()\n",0
007578  733a2079
00757c  61666673
007580  3a207961
007584  6666735f
007588  67757473
00758c  5f696e69
007590  7469616c
007594  69736528
007598  290a00  
00759b  00                DCB      0
                  |L1.30108|
00759c  79616666          DCB      "yaffs: yaffs: Need a device\n"
0075a0  733a2079
0075a4  61666673
0075a8  3a204e65
0075ac  65642061
0075b0  20646576
0075b4  6963650a
                  |L1.30136|
0075b8  00                DCB      0
0075b9  00                DCB      0
0075ba  00                DCB      0
0075bb  00                DCB      0
                  |L1.30140|
0075bc  79616666          DCB      "yaffs: device already mounted\n",0
0075c0  733a2064
0075c4  65766963
0075c8  6520616c
0075cc  72656164
0075d0  79206d6f
0075d4  756e7465
0075d8  640a00  
0075db  00                DCB      0
                  |L1.30172|
0075dc  3200              DCB      "2",0
0075de  00                DCB      0
0075df  00                DCB      0
                  |L1.30176|
                          DCD      ||.constdata||+0x200
                  |L1.30180|
0075e4  79616666          DCB      "yaffs: InitialiseNAND failed\n",0
0075e8  733a2049
0075ec  6e697469
0075f0  616c6973
0075f4  654e414e
0075f8  44206661
0075fc  696c6564
007600  0a00    
007602  00                DCB      0
007603  00                DCB      0
                  |L1.30212|
007604  79616666          DCB      "yaffs: device function(s) missing or wrong\n",0
007608  733a2064
00760c  65766963
007610  65206675
007614  6e637469
007618  6f6e2873
00761c  29206d69
007620  7373696e
007624  67206f72
007628  2077726f
00762c  6e670a00
                  |L1.30256|
007630  e58460ac          STR      r6,[r4,#0xac]         ;4713
007634  ea000001          B        |L1.30272|
                  |L1.30264|
007638  e3a00010          MOV      r0,#0x10              ;4715
00763c  e58400ac          STR      r0,[r4,#0xac]         ;4715
                  |L1.30272|
007640  e5d400ac          LDRB     r0,[r4,#0xac]         ;4718
007644  e3a01001          MOV      r1,#1                 ;4718
007648  e1a00011          LSL      r0,r1,r0              ;4718
00764c  e2400001          SUB      r0,r0,#1              ;4718
007650  e58400b0          STR      r0,[r4,#0xb0]         ;4718
007654  e59400ac          LDR      r0,[r4,#0xac]         ;4726
007658  e1500006          CMP      r0,r6                 ;4726
00765c  3a000002          BCC      |L1.30316|
007660  e3a00000          MOV      r0,#0                 ;4727
007664  e1c40ab8          STRH     r0,[r4,#0xa8]         ;4727
007668  ea000002          B        |L1.30328|
                  |L1.30316|
00766c  e1d40abc          LDRH     r0,[r4,#0xac]         ;4729
007670  e0460000          SUB      r0,r6,r0              ;4729
007674  e1c40ab8          STRH     r0,[r4,#0xa8]         ;4729
                  |L1.30328|
007678  e59400ac          LDR      r0,[r4,#0xac]         ;4731
00767c  e1a00200          LSL      r0,r0,#4              ;4731
007680  e1a001a0          LSR      r0,r0,#3              ;4731
007684  e58400b4          STR      r0,[r4,#0xb4]         ;4731
007688  e59400b4          LDR      r0,[r4,#0xb4]         ;4732
00768c  e3500020          CMP      r0,#0x20              ;4732
007690  2a000001          BCS      |L1.30364|
007694  e3a00020          MOV      r0,#0x20              ;4733
007698  e58400b4          STR      r0,[r4,#0xb4]         ;4733
                  |L1.30364|
00769c  e5d400a8          LDRB     r0,[r4,#0xa8]         ;4735
0076a0  e3a01001          MOV      r1,#1                 ;4735
0076a4  e1a00011          LSL      r0,r1,r0              ;4735
0076a8  e1c40aba          STRH     r0,[r4,#0xaa]         ;4735
0076ac  e594000c          LDR      r0,[r4,#0xc]          ;4737
0076b0  e1d41aba          LDRH     r1,[r4,#0xaa]         ;4737
0076b4  e1500001          CMP      r0,r1                 ;4737
0076b8  aa000007          BGE      |L1.30428|
0076bc  e59f0330          LDR      r0,|L1.31220|
0076c0  e5900000          LDR      r0,[r0,#0]            ;4742  ; yaffs_trace_mask
0076c4  e310020f          TST      r0,#0xf0000000        ;4742
0076c8  0a000001          BEQ      |L1.30420|
0076cc  e28f0fc9          ADR      r0,|L1.31224|
0076d0  ebfffffe          BL       sysprintf
                  |L1.30420|
0076d4  e3a00000          MOV      r0,#0                 ;4744
0076d8  eafffef0          B        |L1.29344|
                  |L1.30428|
0076dc  e3a00000          MOV      r0,#0                 ;4750
0076e0  e5840e24          STR      r0,[r4,#0xe24]        ;4750
0076e4  e5840e28          STR      r0,[r4,#0xe28]        ;4751
0076e8  e5840e2c          STR      r0,[r4,#0xe2c]        ;4752
0076ec  e5840e34          STR      r0,[r4,#0xe34]        ;4753
0076f0  e5840d60          STR      r0,[r4,#0xd60]        ;4754
0076f4  e3e00000          MVN      r0,#0                 ;4755
0076f8  e5840d88          STR      r0,[r4,#0xd88]        ;4755
0076fc  e3a00000          MOV      r0,#0                 ;4756
007700  e5840d8c          STR      r0,[r4,#0xd8c]        ;4756
007704  e5840da4          STR      r0,[r4,#0xda4]        ;4757
007708  e5840dac          STR      r0,[r4,#0xdac]        ;4758
00770c  e5840da8          STR      r0,[r4,#0xda8]        ;4759
007710  e5840e40          STR      r0,[r4,#0xe40]        ;4760
007714  e5840e44          STR      r0,[r4,#0xe44]        ;4761
007718  e5840e48          STR      r0,[r4,#0xe48]        ;4762
00771c  e5840e4c          STR      r0,[r4,#0xe4c]        ;4763
007720  e5840e1c          STR      r0,[r4,#0xe1c]        ;4764
007724  e5840128          STR      r0,[r4,#0x128]        ;4765
007728  e5840d5c          STR      r0,[r4,#0xd5c]        ;4766
00772c  e3a00001          MOV      r0,#1                 ;4767
007730  e5840d58          STR      r0,[r4,#0xd58]        ;4767
007734  e1a00000          MOV      r0,r0                 ;4769
007738  e2840c0e          ADD      r0,r4,#0xe00          ;4769
00773c  e5840e00          STR      r0,[r4,#0xe00]        ;4769
007740  e2840c0e          ADD      r0,r4,#0xe00          ;4769
007744  e5840e04          STR      r0,[r4,#0xe04]        ;4769
007748  e1a00000          MOV      r0,r0                 ;4769
00774c  e3a00000          MOV      r0,#0                 ;4770
007750  e5840df4          STR      r0,[r4,#0xdf4]        ;4770
007754  e5840df8          STR      r0,[r4,#0xdf8]        ;4771
007758  e1a00004          MOV      r0,r4                 ;4774
00775c  ebfffffe          BL       yaffs_init_tmp_buffers
007760  e3500000          CMP      r0,#0                 ;4774
007764  1a000000          BNE      |L1.30572|
007768  e3a05001          MOV      r5,#1                 ;4775
                  |L1.30572|
00776c  e3a00000          MOV      r0,#0                 ;4777
007770  e5840d90          STR      r0,[r4,#0xd90]        ;4777
007774  e5840d50          STR      r0,[r4,#0xd50]        ;4778
007778  e3550000          CMP      r5,#0                 ;4780
00777c  1a000035          BNE      |L1.30808|
007780  e5940020          LDR      r0,[r4,#0x20]         ;4780
007784  e3500000          CMP      r0,#0                 ;4780
007788  da000032          BLE      |L1.30808|
00778c  e5940020          LDR      r0,[r4,#0x20]         ;4783
007790  e0600180          RSB      r0,r0,r0,LSL #3       ;4783
007794  e1a0a100          LSL      r10,r0,#2             ;4783
007798  e5940020          LDR      r0,[r4,#0x20]         ;4786
00779c  e3500014          CMP      r0,#0x14              ;4786
0077a0  da000001          BLE      |L1.30636|
0077a4  e3a00014          MOV      r0,#0x14              ;4787
0077a8  e5840020          STR      r0,[r4,#0x20]         ;4787
                  |L1.30636|
0077ac  e1a0000a          MOV      r0,r10                ;4790
0077b0  ebfffffe          BL       yaffs_malloc
0077b4  e5840d90          STR      r0,[r4,#0xd90]        ;4790
0077b8  e5949d90          LDR      r9,[r4,#0xd90]        ;4792
0077bc  e5940d90          LDR      r0,[r4,#0xd90]        ;4794
0077c0  e3500000          CMP      r0,#0                 ;4794
0077c4  0a000002          BEQ      |L1.30676|
0077c8  e1a0100a          MOV      r1,r10                ;4795
0077cc  e5940d90          LDR      r0,[r4,#0xd90]        ;4795
0077d0  ebfffffe          BL       __aeabi_memclr4
                  |L1.30676|
0077d4  e3a07000          MOV      r7,#0                 ;4797
0077d8  ea000013          B        |L1.30764|
                  |L1.30684|
0077dc  e3a00000          MOV      r0,#0                 ;4798
0077e0  e0672187          RSB      r2,r7,r7,LSL #3       ;4798
0077e4  e5941d90          LDR      r1,[r4,#0xd90]        ;4798
0077e8  e7810102          STR      r0,[r1,r2,LSL #2]     ;4798
0077ec  e0672187          RSB      r2,r7,r7,LSL #3       ;4799
0077f0  e5941d90          LDR      r1,[r4,#0xd90]        ;4799
0077f4  e0811102          ADD      r1,r1,r2,LSL #2       ;4799
0077f8  e5810008          STR      r0,[r1,#8]            ;4799
0077fc  e0672187          RSB      r2,r7,r7,LSL #3       ;4800
007800  e5941d90          LDR      r1,[r4,#0xd90]        ;4800
007804  e0811102          ADD      r1,r1,r2,LSL #2       ;4800
007808  e581000c          STR      r0,[r1,#0xc]          ;4800
00780c  e5940008          LDR      r0,[r4,#8]            ;4802
007810  ebfffffe          BL       yaffs_malloc
007814  e1a09000          MOV      r9,r0                 ;4802
007818  e0672187          RSB      r2,r7,r7,LSL #3       ;4802
00781c  e5941d90          LDR      r1,[r4,#0xd90]        ;4802
007820  e0811102          ADD      r1,r1,r2,LSL #2       ;4802
007824  e5810018          STR      r0,[r1,#0x18]         ;4802
007828  e2877001          ADD      r7,r7,#1              ;4797
                  |L1.30764|
00782c  e5940020          LDR      r0,[r4,#0x20]         ;4797
007830  e1500007          CMP      r0,r7                 ;4797
007834  da000001          BLE      |L1.30784|
007838  e3590000          CMP      r9,#0                 ;4797
00783c  1affffe6          BNE      |L1.30684|
                  |L1.30784|
007840  e3590000          CMP      r9,#0                 ;4804
007844  1a000000          BNE      |L1.30796|
007848  e3a05001          MOV      r5,#1                 ;4805
                  |L1.30796|
00784c  e3a00000          MOV      r0,#0                 ;4807
007850  e5840d94          STR      r0,[r4,#0xd94]        ;4807
007854  e1a00000          MOV      r0,r0                 ;4808
                  |L1.30808|
007858  e3a00000          MOV      r0,#0                 ;4810
00785c  e5840e5c          STR      r0,[r4,#0xe5c]        ;4810
007860  e3550000          CMP      r5,#0                 ;4812
007864  1a000007          BNE      |L1.30856|
007868  e594100c          LDR      r1,[r4,#0xc]          ;4814
00786c  e1a00101          LSL      r0,r1,#2              ;4814
007870  ebfffffe          BL       yaffs_malloc
007874  e5840d50          STR      r0,[r4,#0xd50]        ;4814
007878  e5940d50          LDR      r0,[r4,#0xd50]        ;4815
00787c  e3500000          CMP      r0,#0                 ;4815
007880  1a000000          BNE      |L1.30856|
007884  e3a05001          MOV      r5,#1                 ;4816
                  |L1.30856|
007888  e5940030          LDR      r0,[r4,#0x30]         ;4819
00788c  e3500000          CMP      r0,#0                 ;4819
007890  0a000001          BEQ      |L1.30876|
007894  e3a00001          MOV      r0,#1                 ;4820
007898  e5840074          STR      r0,[r4,#0x74]         ;4820
                  |L1.30876|
00789c  e3550000          CMP      r5,#0                 ;4822
0078a0  1a000004          BNE      |L1.30904|
0078a4  e1a00004          MOV      r0,r4                 ;4822
0078a8  ebfffffe          BL       yaffs_init_blocks
0078ac  e3500000          CMP      r0,#0                 ;4822
0078b0  1a000000          BNE      |L1.30904|
0078b4  e3a05001          MOV      r5,#1                 ;4823
                  |L1.30904|
0078b8  e1a00004          MOV      r0,r4                 ;4825
0078bc  ebfffffe          BL       yaffs_init_tnodes_and_objs
0078c0  e3550000          CMP      r5,#0                 ;4827
0078c4  1a000004          BNE      |L1.30940|
0078c8  e1a00004          MOV      r0,r4                 ;4827
0078cc  ebfffffe          BL       yaffs_create_initial_dir
0078d0  e3500000          CMP      r0,#0                 ;4827
0078d4  1a000000          BNE      |L1.30940|
0078d8  e3a05001          MOV      r5,#1                 ;4828
                  |L1.30940|
0078dc  e3550000          CMP      r5,#0                 ;4830
0078e0  1a00000a          BNE      |L1.30992|
0078e4  e5940030          LDR      r0,[r4,#0x30]         ;4830
0078e8  e3500000          CMP      r0,#0                 ;4830
0078ec  0a000007          BEQ      |L1.30992|
0078f0  e594008c          LDR      r0,[r4,#0x8c]         ;4831
0078f4  e3500000          CMP      r0,#0                 ;4831
0078f8  1a000004          BNE      |L1.30992|
0078fc  e1a00004          MOV      r0,r4                 ;4832
007900  ebfffffe          BL       yaffs_summary_init
007904  e3500000          CMP      r0,#0                 ;4832
007908  1a000000          BNE      |L1.30992|
00790c  e3a05001          MOV      r5,#1                 ;4833
                  |L1.30992|
007910  e3550000          CMP      r5,#0                 ;4835
007914  1a000058          BNE      |L1.31356|
007918  e5940030          LDR      r0,[r4,#0x30]         ;4837
00791c  e3500000          CMP      r0,#0                 ;4837
007920  0a000047          BEQ      |L1.31300|
007924  e1a00004          MOV      r0,r4                 ;4838
007928  ebfffffe          BL       yaffs2_checkpt_restore
00792c  e3500000          CMP      r0,#0                 ;4838
007930  0a000009          BEQ      |L1.31068|
007934  e5940d80          LDR      r0,[r4,#0xd80]        ;4839
007938  ebfffffe          BL       yaffs_check_obj_details_loaded
00793c  e59f00b0          LDR      r0,|L1.31220|
007940  e5900000          LDR      r0,[r0,#0]            ;4840  ; yaffs_trace_mask
007944  e59f10cc          LDR      r1,|L1.31256|
007948  e1100001          TST      r0,r1                 ;4840
00794c  0a000041          BEQ      |L1.31320|
007950  e28f00c4          ADR      r0,|L1.31260|
007954  ebfffffe          BL       sysprintf
007958  ea00003e          B        |L1.31320|
                  |L1.31068|
00795c  e1a00004          MOV      r0,r4                 ;4849
007960  ebfffffe          BL       yaffs_deinit_blocks
007964  e1a00004          MOV      r0,r4                 ;4851
007968  ebfffffe          BL       yaffs_deinit_tnodes_and_objs
00796c  e3a00000          MOV      r0,#0                 ;4853
007970  e5840128          STR      r0,[r4,#0x128]        ;4853
007974  e5840d4c          STR      r0,[r4,#0xd4c]        ;4854
007978  e3e00000          MVN      r0,#0                 ;4855
00797c  e584012c          STR      r0,[r4,#0x12c]        ;4855
007980  e5840130          STR      r0,[r4,#0x130]        ;4856
007984  e3a00000          MOV      r0,#0                 ;4857
007988  e5840da4          STR      r0,[r4,#0xda4]        ;4857
00798c  e5840da8          STR      r0,[r4,#0xda8]        ;4858
007990  e5840dac          STR      r0,[r4,#0xdac]        ;4859
007994  e3550000          CMP      r5,#0                 ;4861
007998  1a000004          BNE      |L1.31152|
00799c  e1a00004          MOV      r0,r4                 ;4861
0079a0  ebfffffe          BL       yaffs_init_blocks
0079a4  e3500000          CMP      r0,#0                 ;4861
0079a8  1a000000          BNE      |L1.31152|
0079ac  e3a05001          MOV      r5,#1                 ;4862
                  |L1.31152|
0079b0  e1a00004          MOV      r0,r4                 ;4864
0079b4  ebfffffe          BL       yaffs_init_tnodes_and_objs
0079b8  e3550000          CMP      r5,#0                 ;4866
0079bc  1a000004          BNE      |L1.31188|
0079c0  e1a00004          MOV      r0,r4                 ;4867
0079c4  ebfffffe          BL       yaffs_create_initial_dir
0079c8  e3500000          CMP      r0,#0                 ;4867
0079cc  1a000000          BNE      |L1.31188|
0079d0  e3a05001          MOV      r5,#1                 ;4868
                  |L1.31188|
0079d4  e3550000          CMP      r5,#0                 ;4870
0079d8  1a00001e          BNE      |L1.31320|
0079dc  e1a00004          MOV      r0,r4                 ;4870
0079e0  ebfffffe          BL       yaffs2_scan_backwards
0079e4  e3500000          CMP      r0,#0                 ;4870
0079e8  1a00001a          BNE      |L1.31320|
0079ec  e3a05001          MOV      r5,#1                 ;4871
0079f0  ea000018          B        |L1.31320|
                  |L1.31220|
                          DCD      yaffs_trace_mask
                  |L1.31224|
0079f8  79616666          DCB      "yaffs: chunk group too large\n",0
0079fc  733a2063
007a00  68756e6b
007a04  2067726f
007a08  75702074
007a0c  6f6f206c
007a10  61726765
007a14  0a00    
007a16  00                DCB      0
007a17  00                DCB      0
                  |L1.31256|
                          DCD      0x00808000
                  |L1.31260|
007a1c  79616666          DCB      "yaffs: yaffs: restored from checkpoint\n",0
007a20  733a2079
007a24  61666673
007a28  3a207265
007a2c  73746f72
007a30  65642066
007a34  726f6d20
007a38  63686563
007a3c  6b706f69
007a40  6e740a00
                  |L1.31300|
007a44  e1a00004          MOV      r0,r4                 ;4873
007a48  ebfffffe          BL       yaffs1_scan
007a4c  e3500000          CMP      r0,#0                 ;4873
007a50  1a000000          BNE      |L1.31320|
007a54  e3a05001          MOV      r5,#1                 ;4874
                  |L1.31320|
007a58  e1a00004          MOV      r0,r4                 ;4877
007a5c  ebfffffe          BL       yaffs_strip_deleted_objs
007a60  e1a00004          MOV      r0,r4                 ;4878
007a64  ebfffffe          BL       yaffs_fix_hanging_objs
007a68  e5940034          LDR      r0,[r4,#0x34]         ;4879
007a6c  e3500000          CMP      r0,#0                 ;4879
007a70  0a000001          BEQ      |L1.31356|
007a74  e1a00004          MOV      r0,r4                 ;4880
007a78  ebfffffe          BL       yaffs_empty_l_n_f
                  |L1.31356|
007a7c  e3550000          CMP      r5,#0                 ;4883
007a80  0a000009          BEQ      |L1.31404|
007a84  e51f0098          LDR      r0,|L1.31220|
007a88  e1d000b0          LDRH     r0,[r0,#0]            ;4885  ; yaffs_trace_mask
007a8c  e3100c01          TST      r0,#0x100             ;4885
007a90  0a000001          BEQ      |L1.31388|
007a94  e28f0f7b          ADR      r0,|L1.31880|
007a98  ebfffffe          BL       sysprintf
                  |L1.31388|
007a9c  e1a00004          MOV      r0,r4                 ;4888
007aa0  ebfffffe          BL       yaffs_deinitialise
007aa4  e3a00000          MOV      r0,#0                 ;4889
007aa8  eafffdfc          B        |L1.29344|
                  |L1.31404|
007aac  e3a00000          MOV      r0,#0                 ;4893
007ab0  e5840e14          STR      r0,[r4,#0xe14]        ;4893
007ab4  e5840e10          STR      r0,[r4,#0xe10]        ;4894
007ab8  e5840e18          STR      r0,[r4,#0xe18]        ;4895
007abc  e5840e20          STR      r0,[r4,#0xe20]        ;4896
007ac0  e5840e38          STR      r0,[r4,#0xe38]        ;4897
007ac4  e5840e3c          STR      r0,[r4,#0xe3c]        ;4899
007ac8  e1a00004          MOV      r0,r4                 ;4901
007acc  ebfffffe          BL       yaffs_verify_free_chunks
007ad0  e1a00004          MOV      r0,r4                 ;4902
007ad4  ebfffffe          BL       yaffs_verify_blocks
007ad8  e59400cc          LDR      r0,[r4,#0xcc]         ;4905
007adc  e3500000          CMP      r0,#0                 ;4905
007ae0  1a000004          BNE      |L1.31480|
007ae4  e59400f4          LDR      r0,[r4,#0xf4]         ;4905
007ae8  e3500000          CMP      r0,#0                 ;4905
007aec  da000001          BLE      |L1.31480|
007af0  e1a00004          MOV      r0,r4                 ;4906
007af4  ebfffffe          BL       yaffs2_checkpt_invalidate
                  |L1.31480|
007af8  e51f010c          LDR      r0,|L1.31220|
007afc  e1d000b0          LDRH     r0,[r0,#0]            ;4908  ; yaffs_trace_mask
007b00  e3100c01          TST      r0,#0x100             ;4908
007b04  0a000001          BEQ      |L1.31504|
007b08  e28f0f6a          ADR      r0,|L1.31928|
007b0c  ebfffffe          BL       sysprintf
                  |L1.31504|
007b10  e3a00001          MOV      r0,#1                 ;4910
007b14  eafffde1          B        |L1.29344|
;;;4912   
                          ENDP

                  yaffs_count_free_chunks PROC
;;;4944   
;;;4945   int yaffs_count_free_chunks(struct yaffs_dev *dev)
007b18  e92d4010          PUSH     {r4,lr}
;;;4946   {
007b1c  e1a01000          MOV      r1,r0
;;;4947   	int n_free = 0;
007b20  e3a00000          MOV      r0,#0
;;;4948   	int b;
;;;4949   	struct yaffs_block_info *blk;
;;;4950   
;;;4951   	blk = dev->block_info;
007b24  e5912118          LDR      r2,[r1,#0x118]
;;;4952   	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
007b28  e59130d0          LDR      r3,[r1,#0xd0]
007b2c  ea00001e          B        |L1.31660|
                  |L1.31536|
;;;4953   		switch (blk->block_state) {
007b30  e592c000          LDR      r12,[r2,#0]
007b34  e1a0c40c          LSL      r12,r12,#8
007b38  e1a0ce2c          LSR      r12,r12,#28
007b3c  e35c0003          CMP      r12,#3
007b40  0a000006          BEQ      |L1.31584|
007b44  e35c0004          CMP      r12,#4
007b48  0a000006          BEQ      |L1.31592|
007b4c  e35c0005          CMP      r12,#5
007b50  0a000006          BEQ      |L1.31600|
007b54  e35c0008          CMP      r12,#8
007b58  1a00000e          BNE      |L1.31640|
007b5c  ea000002          B        |L1.31596|
                  |L1.31584|
;;;4954   		case YAFFS_BLOCK_STATE_EMPTY:
007b60  e1a00000          MOV      r0,r0
;;;4955   		case YAFFS_BLOCK_STATE_ALLOCATING:
007b64  e1a00000          MOV      r0,r0
                  |L1.31592|
;;;4956   		case YAFFS_BLOCK_STATE_COLLECTING:
007b68  e1a00000          MOV      r0,r0
                  |L1.31596|
;;;4957   		case YAFFS_BLOCK_STATE_FULL:
007b6c  e1a00000          MOV      r0,r0
                  |L1.31600|
;;;4958   			n_free +=
007b70  e591c00c          LDR      r12,[r1,#0xc]
007b74  e5924000          LDR      r4,[r2,#0]
007b78  e1a04604          LSL      r4,r4,#12
007b7c  e04ccb24          SUB      r12,r12,r4,LSR #22
007b80  e1d240b0          LDRH     r4,[r2,#0]
007b84  e1a04b04          LSL      r4,r4,#22
007b88  e1a04b24          LSR      r4,r4,#22
007b8c  e08cc004          ADD      r12,r12,r4
007b90  e080000c          ADD      r0,r0,r12
;;;4959   			    (dev->param.chunks_per_block - blk->pages_in_use +
;;;4960   			     blk->soft_del_pages);
;;;4961   			break;
007b94  ea000001          B        |L1.31648|
                  |L1.31640|
;;;4962   		default:
007b98  e1a00000          MOV      r0,r0
;;;4963   			break;
007b9c  e1a00000          MOV      r0,r0
                  |L1.31648|
007ba0  e1a00000          MOV      r0,r0                 ;4961
;;;4964   		}
;;;4965   		blk++;
007ba4  e2822008          ADD      r2,r2,#8
007ba8  e2833001          ADD      r3,r3,#1              ;4952
                  |L1.31660|
007bac  e591c0d4          LDR      r12,[r1,#0xd4]        ;4952
007bb0  e15c0003          CMP      r12,r3                ;4952
007bb4  aaffffdd          BGE      |L1.31536|
;;;4966   	}
;;;4967   	return n_free;
;;;4968   }
007bb8  e8bd8010          POP      {r4,pc}
;;;4969   
                          ENDP

                  yaffs_get_n_free_chunks PROC
;;;4970   int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
007bbc  e92d41f0          PUSH     {r4-r8,lr}
;;;4971   {
007bc0  e1a04000          MOV      r4,r0
;;;4972   	/* This is what we report to the outside world */
;;;4973   	int n_free;
;;;4974   	int n_dirty_caches;
;;;4975   	int blocks_for_checkpt;
;;;4976   	int i;
;;;4977   
;;;4978   	n_free = dev->n_free_chunks;
007bc4  e5945d4c          LDR      r5,[r4,#0xd4c]
;;;4979   	n_free += dev->n_deleted_files;
007bc8  e5940da4          LDR      r0,[r4,#0xda4]
007bcc  e0855000          ADD      r5,r5,r0
;;;4980   
;;;4981   	/* Now count and subtract the number of dirty chunks in the cache. */
;;;4982   
;;;4983   	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
007bd0  e3a08000          MOV      r8,#0
007bd4  e3a07000          MOV      r7,#0
007bd8  ea000007          B        |L1.31740|
                  |L1.31708|
;;;4984   		if (dev->cache[i].dirty)
007bdc  e0671187          RSB      r1,r7,r7,LSL #3
007be0  e5940d90          LDR      r0,[r4,#0xd90]
007be4  e0800101          ADD      r0,r0,r1,LSL #2
007be8  e590000c          LDR      r0,[r0,#0xc]
007bec  e3500000          CMP      r0,#0
007bf0  0a000000          BEQ      |L1.31736|
;;;4985   			n_dirty_caches++;
007bf4  e2888001          ADD      r8,r8,#1
                  |L1.31736|
007bf8  e2877001          ADD      r7,r7,#1              ;4983
                  |L1.31740|
007bfc  e5940020          LDR      r0,[r4,#0x20]         ;4983
007c00  e1500007          CMP      r0,r7                 ;4983
007c04  cafffff4          BGT      |L1.31708|
;;;4986   	}
;;;4987   
;;;4988   	n_free -= n_dirty_caches;
007c08  e0455008          SUB      r5,r5,r8
;;;4989   
;;;4990   	n_free -=
007c0c  e594001c          LDR      r0,[r4,#0x1c]
007c10  e2800001          ADD      r0,r0,#1
007c14  e594100c          LDR      r1,[r4,#0xc]
007c18  e0000091          MUL      r0,r1,r0
007c1c  e0455000          SUB      r5,r5,r0
;;;4991   	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
;;;4992   
;;;4993   	/* Now figure checkpoint space and report that... */
;;;4994   	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
007c20  e1a00004          MOV      r0,r4
007c24  ebfffffe          BL       yaffs_calc_checkpt_blocks_required
007c28  e1a06000          MOV      r6,r0
;;;4995   
;;;4996   	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
007c2c  e594000c          LDR      r0,[r4,#0xc]
007c30  e0000096          MUL      r0,r6,r0
007c34  e0455000          SUB      r5,r5,r0
;;;4997   
;;;4998   	if (n_free < 0)
007c38  e3550000          CMP      r5,#0
007c3c  aa000000          BGE      |L1.31812|
;;;4999   		n_free = 0;
007c40  e3a05000          MOV      r5,#0
                  |L1.31812|
;;;5000   
;;;5001   	return n_free;
007c44  e1a00005          MOV      r0,r5
;;;5002   }
007c48  e8bd81f0          POP      {r4-r8,pc}
;;;5003   
                          ENDP

                  yaffs_oh_to_size PROC
;;;5013   
;;;5014   loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
007c4c  e92d40f0          PUSH     {r4-r7,lr}
;;;5015   {
007c50  e1a02000          MOV      r2,r0
;;;5016   	loff_t retval;
;;;5017   
;;;5018   	if (~(oh->file_size_high))
007c54  e59231f0          LDR      r3,[r2,#0x1f0]
007c58  e1f03003          MVNS     r3,r3
007c5c  0a000006          BEQ      |L1.31868|
;;;5019   		retval = (((loff_t) oh->file_size_high) << 32) |
007c60  e3a04000          MOV      r4,#0
007c64  e0045004          AND      r5,r4,r4
007c68  e592c124          LDR      r12,[r2,#0x124]
007c6c  e184000c          ORR      r0,r4,r12
007c70  e59231f0          LDR      r3,[r2,#0x1f0]
007c74  e1831005          ORR      r1,r3,r5
007c78  ea000001          B        |L1.31876|
                  |L1.31868|
;;;5020   			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
;;;5021   	else
;;;5022   		retval = (loff_t) oh->file_size_low;
007c7c  e3a01000          MOV      r1,#0
007c80  e5920124          LDR      r0,[r2,#0x124]
                  |L1.31876|
;;;5023   
;;;5024   	return retval;
;;;5025   }
007c84  e8bd80f0          POP      {r4-r7,pc}
                  |L1.31880|
007c88  79616666          DCB      "yaffs: yaffs: yaffs_guts_initialise() aborted.\n",0
007c8c  733a2079
007c90  61666673
007c94  3a207961
007c98  6666735f
007c9c  67757473
007ca0  5f696e69
007ca4  7469616c
007ca8  69736528
007cac  29206162
007cb0  6f727465
007cb4  642e0a00
                  |L1.31928|
007cb8  79616666          DCB      "yaffs: yaffs: yaffs_guts_initialise() done.\n",0
007cbc  733a2079
007cc0  61666673
007cc4  3a207961
007cc8  6666735f
007ccc  67757473
007cd0  5f696e69
007cd4  7469616c
007cd8  69736528
007cdc  2920646f
007ce0  6e652e0a
007ce4  00      
007ce5  00                DCB      0
007ce6  00                DCB      0
007ce7  00                DCB      0
                          ENDP

                  list_empty PROC
;;;97     /* Test if the list is empty */
;;;98     static __inline int list_empty(struct list_head *entry)
007ce8  e1a01000          MOV      r1,r0
;;;99     {
;;;100    	return (entry->next == entry);
007cec  e5910000          LDR      r0,[r1,#0]
007cf0  e1500001          CMP      r0,r1
007cf4  1a000001          BNE      |L1.32000|
007cf8  e3a00001          MOV      r0,#1
                  |L1.31996|
;;;101    }
007cfc  e12fff1e          BX       lr
                  |L1.32000|
007d00  e3a00000          MOV      r0,#0                 ;100
007d04  eafffffc          B        |L1.31996|
;;;102    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  79616666          DCB      0x79,0x61,0x66,0x66
000004  733a203e          DCB      0x73,0x3a,0x20,0x3e
000008  3e426c6f          DCB      0x3e,0x42,0x6c,0x6f
00000c  636b2025          DCB      0x63,0x6b,0x20,0x25
000010  64206572          DCB      0x64,0x20,0x65,0x72
000014  61737572          DCB      0x61,0x73,0x75,0x72
000018  65207375          DCB      0x65,0x20,0x73,0x75
00001c  70706f73          DCB      0x70,0x70,0x6f,0x73
000020  65646c79          DCB      0x65,0x64,0x6c,0x79
000024  204f4b2c          DCB      0x20,0x4f,0x4b,0x2c
000028  20627574          DCB      0x20,0x62,0x75,0x74
00002c  20636875          DCB      0x20,0x63,0x68,0x75
000030  6e6b2025          DCB      0x6e,0x6b,0x20,0x25
000034  64206e6f          DCB      0x64,0x20,0x6e,0x6f
000038  74206572          DCB      0x74,0x20,0x65,0x72
00003c  61736564          DCB      0x61,0x73,0x65,0x64
000040  0a000000          DCB      0x0a,0x00,0x00,0x00
000044  79616666          DCB      0x79,0x61,0x66,0x66
000048  733a2079          DCB      0x73,0x3a,0x20,0x79
00004c  61666673          DCB      0x61,0x66,0x66,0x73
000050  20747261          DCB      0x20,0x74,0x72,0x61
000054  67656479          DCB      0x67,0x65,0x64,0x79
000058  3a206e6f          DCB      0x3a,0x20,0x6e,0x6f
00005c  206d6f72          DCB      0x20,0x6d,0x6f,0x72
000060  65206572          DCB      0x65,0x20,0x65,0x72
000064  61736564          DCB      0x61,0x73,0x65,0x64
000068  20626c6f          DCB      0x20,0x62,0x6c,0x6f
00006c  636b732c          DCB      0x63,0x6b,0x73,0x2c
000070  20627574          DCB      0x20,0x62,0x75,0x74
000074  20746865          DCB      0x20,0x74,0x68,0x65
000078  72652073          DCB      0x72,0x65,0x20,0x73
00007c  686f756c          DCB      0x68,0x6f,0x75,0x6c
000080  64206861          DCB      0x64,0x20,0x68,0x61
000084  76652062          DCB      0x76,0x65,0x20,0x62
000088  65656e20          DCB      0x65,0x65,0x6e,0x20
00008c  25640a00          DCB      0x25,0x64,0x0a,0x00
000090  79616666          DCB      0x79,0x61,0x66,0x66
000094  733a2074          DCB      0x73,0x3a,0x20,0x74
000098  72616765          DCB      0x72,0x61,0x67,0x65
00009c  64793a20          DCB      0x64,0x79,0x3a,0x20
0000a0  54727969          DCB      0x54,0x72,0x79,0x69
0000a4  6e672074          DCB      0x6e,0x67,0x20,0x74
0000a8  6f206164          DCB      0x6f,0x20,0x61,0x64
0000ac  6420616e          DCB      0x64,0x20,0x61,0x6e
0000b0  206f626a          DCB      0x20,0x6f,0x62,0x6a
0000b4  65637420          DCB      0x65,0x63,0x74,0x20
0000b8  746f2061          DCB      0x74,0x6f,0x20,0x61
0000bc  206e756c          DCB      0x20,0x6e,0x75,0x6c
0000c0  6c20706f          DCB      0x6c,0x20,0x70,0x6f
0000c4  696e7465          DCB      0x69,0x6e,0x74,0x65
0000c8  72206469          DCB      0x72,0x20,0x64,0x69
0000cc  72656374          DCB      0x72,0x65,0x63,0x74
0000d0  6f72790a          DCB      0x6f,0x72,0x79,0x0a
0000d4  00000000          DCB      0x00,0x00,0x00,0x00
0000d8  79616666          DCB      0x79,0x61,0x66,0x66
0000dc  733a2043          DCB      0x73,0x3a,0x20,0x43
0000e0  6f6c6c65          DCB      0x6f,0x6c,0x6c,0x65
0000e4  6374696e          DCB      0x63,0x74,0x69,0x6e
0000e8  6720626c          DCB      0x67,0x20,0x62,0x6c
0000ec  6f636b20          DCB      0x6f,0x63,0x6b,0x20
0000f0  25642c20          DCB      0x25,0x64,0x2c,0x20
0000f4  696e2075          DCB      0x69,0x6e,0x20,0x75
0000f8  73652025          DCB      0x73,0x65,0x20,0x25
0000fc  642c2073          DCB      0x64,0x2c,0x20,0x73
000100  6872696e          DCB      0x68,0x72,0x69,0x6e
000104  6b202564          DCB      0x6b,0x20,0x25,0x64
000108  2c207768          DCB      0x2c,0x20,0x77,0x68
00010c  6f6c655f          DCB      0x6f,0x6c,0x65,0x5f
000110  626c6f63          DCB      0x62,0x6c,0x6f,0x63
000114  6b202564          DCB      0x6b,0x20,0x25,0x64
000118  0a000000          DCB      0x0a,0x00,0x00,0x00
00011c  79616666          DCB      0x79,0x61,0x66,0x66
000120  733a2047          DCB      0x73,0x3a,0x20,0x47
000124  43206e6f          DCB      0x43,0x20,0x6e,0x6f
000128  6e653a20          DCB      0x6e,0x65,0x3a,0x20
00012c  66696e64          DCB      0x66,0x69,0x6e,0x64
000130  65722025          DCB      0x65,0x72,0x20,0x25
000134  6420736b          DCB      0x64,0x20,0x73,0x6b
000138  69702025          DCB      0x69,0x70,0x20,0x25
00013c  64207468          DCB      0x64,0x20,0x74,0x68
000140  72657368          DCB      0x72,0x65,0x73,0x68
000144  6f6c6420          DCB      0x6f,0x6c,0x64,0x20
000148  25642064          DCB      0x25,0x64,0x20,0x64
00014c  69727469          DCB      0x69,0x72,0x74,0x69
000150  65737420          DCB      0x65,0x73,0x74,0x20
000154  25642075          DCB      0x25,0x64,0x20,0x75
000158  73696e67          DCB      0x73,0x69,0x6e,0x67
00015c  20256420          DCB      0x20,0x25,0x64,0x20
000160  6f6c6465          DCB      0x6f,0x6c,0x64,0x65
000164  73742025          DCB      0x73,0x74,0x20,0x25
000168  6425730a          DCB      0x64,0x25,0x73,0x0a
00016c  00000000          DCB      0x00,0x00,0x00,0x00
000170  79616666          DCB      0x79,0x61,0x66,0x66
000174  733a2079          DCB      0x73,0x3a,0x20,0x79
000178  61666673          DCB      0x61,0x66,0x66,0x73
00017c  3a204743          DCB      0x3a,0x20,0x47,0x43
000180  20212121          DCB      0x20,0x21,0x21,0x21
000184  6e6f2072          DCB      0x6e,0x6f,0x20,0x72
000188  65636c61          DCB      0x65,0x63,0x6c,0x61
00018c  696d2121          DCB      0x69,0x6d,0x21,0x21
000190  21206e5f          DCB      0x21,0x20,0x6e,0x5f
000194  65726173          DCB      0x65,0x72,0x61,0x73
000198  65645f62          DCB      0x65,0x64,0x5f,0x62
00019c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
0001a0  73202564          DCB      0x73,0x20,0x25,0x64
0001a4  20616674          DCB      0x20,0x61,0x66,0x74
0001a8  65722074          DCB      0x65,0x72,0x20,0x74
0001ac  72792025          DCB      0x72,0x79,0x20,0x25
0001b0  6420626c          DCB      0x64,0x20,0x62,0x6c
0001b4  6f636b20          DCB      0x6f,0x63,0x6b,0x20
0001b8  25640a00          DCB      0x25,0x64,0x0a,0x00
0001bc  79616666          DCB      0x79,0x61,0x66,0x66
0001c0  733a2074          DCB      0x73,0x3a,0x20,0x74
0001c4  72616765          DCB      0x72,0x61,0x67,0x65
0001c8  64793a20          DCB      0x64,0x79,0x3a,0x20
0001cc  79616666          DCB      0x79,0x61,0x66,0x66
0001d0  735f6368          DCB      0x73,0x5f,0x63,0x68
0001d4  616e6765          DCB      0x61,0x6e,0x67,0x65
0001d8  5f6f626a          DCB      0x5f,0x6f,0x62,0x6a
0001dc  5f6e616d          DCB      0x5f,0x6e,0x61,0x6d
0001e0  653a206e          DCB      0x65,0x3a,0x20,0x6e
0001e4  65775f64          DCB      0x65,0x77,0x5f,0x64
0001e8  69722069          DCB      0x69,0x72,0x20,0x69
0001ec  73206e6f          DCB      0x73,0x20,0x6e,0x6f
0001f0  74206120          DCB      0x74,0x20,0x61,0x20
0001f4  64697265          DCB      0x64,0x69,0x72,0x65
0001f8  63746f72          DCB      0x63,0x74,0x6f,0x72
0001fc  790a0000          DCB      0x79,0x0a,0x00,0x00
000200  79616666          DCB      0x79,0x61,0x66,0x66
000204  733a204e          DCB      0x73,0x3a,0x20,0x4e
000208  414e4420          DCB      0x41,0x4e,0x44,0x20
00020c  67656f6d          DCB      0x67,0x65,0x6f,0x6d
000210  65747279          DCB      0x65,0x74,0x72,0x79
000214  2070726f          DCB      0x20,0x70,0x72,0x6f
000218  626c656d          DCB      0x62,0x6c,0x65,0x6d
00021c  733a2063          DCB      0x73,0x3a,0x20,0x63
000220  68756e6b          DCB      0x68,0x75,0x6e,0x6b
000224  2073697a          DCB      0x20,0x73,0x69,0x7a
000228  65202564          DCB      0x65,0x20,0x25,0x64
00022c  2c207479          DCB      0x2c,0x20,0x74,0x79
000230  70652069          DCB      0x70,0x65,0x20,0x69
000234  73207961          DCB      0x73,0x20,0x79,0x61
000238  66667325          DCB      0x66,0x66,0x73,0x25
00023c  732c2069          DCB      0x73,0x2c,0x20,0x69
000240  6e62616e          DCB      0x6e,0x62,0x61,0x6e
000244  645f7461          DCB      0x64,0x5f,0x74,0x61
000248  67732025          DCB      0x67,0x73,0x20,0x25
00024c  64200a00          DCB      0x64,0x20,0x0a,0x00
