; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uart2drv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart2drv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uart2drv.crf src\UserDrv\uart2drv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART2SetRS232Power PROC
;;;359    }
;;;360    BOOL UART2SetRS232Power(BOOL flag)
000000  e92d4010          PUSH     {r4,lr}
;;;361    {
000004  e1a04000          MOV      r4,r0
;;;362        if(flag)
000008  e3540000          CMP      r4,#0
00000c  0a000003          BEQ      |L1.32|
;;;363        {         
;;;364            GPIO_ClrBit(CONVERT_CHIP_PORT, CONVERT_CHIP_PIN);     
000010  e3a01c02          MOV      r1,#0x200
000014  e3a00d06          MOV      r0,#0x180
000018  ebfffffe          BL       GPIO_ClrBit
00001c  ea000002          B        |L1.44|
                  |L1.32|
;;;365        }
;;;366        else
;;;367        {
;;;368            GPIO_SetBit(CONVERT_CHIP_PORT, CONVERT_CHIP_PIN);    
000020  e3a01c02          MOV      r1,#0x200
000024  e3a00d06          MOV      r0,#0x180
000028  ebfffffe          BL       GPIO_SetBit
                  |L1.44|
;;;369                
;;;370        }
;;;371        return TRUE;
00002c  e3a00001          MOV      r0,#1
;;;372    }
000030  e8bd8010          POP      {r4,pc}
;;;373    INT UART2Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
                          ENDP

                  hwInit PROC
;;;68     /*-----------------------------------------*/
;;;69     static BOOL hwInit(UINT32 baudRate)
000034  e92d4070          PUSH     {r4-r6,lr}
;;;70     {
000038  e1a05000          MOV      r5,r0
;;;71         int retval;
;;;72         outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
00003c  e3a0020b          MOV      r0,#0xb0000000
000040  e5900218          LDR      r0,[r0,#0x218]
000044  e3800008          ORR      r0,r0,#8
000048  e3a0120b          MOV      r1,#0xb0000000
00004c  e5810218          STR      r0,[r1,#0x218]
;;;73         
;;;74         // GPF11, 12 //TX, RX
;;;75         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0x9<<12));
000050  e3a0020b          MOV      r0,#0xb0000000
000054  e590009c          LDR      r0,[r0,#0x9c]
000058  e3c00a0f          BIC      r0,r0,#0xf000
00005c  e3800a09          ORR      r0,r0,#0x9000
000060  e581009c          STR      r0,[r1,#0x9c]
;;;76         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0x9<<16));
000064  e3a0020b          MOV      r0,#0xb0000000
000068  e590009c          LDR      r0,[r0,#0x9c]
00006c  e3c0080f          BIC      r0,r0,#0xf0000
000070  e3800809          ORR      r0,r0,#0x90000
000074  e581009c          STR      r0,[r1,#0x9c]
;;;77         
;;;78         
;;;79         if(octopusModeFlag)
000078  e59f037c          LDR      r0,|L1.1020|
00007c  e5d00000          LDRB     r0,[r0,#0]  ; octopusModeFlag
000080  e3500000          CMP      r0,#0
000084  0a000018          BEQ      |L1.236|
;;;80         //if((octopusModeFlag) && GPIO_ReadBit(GPIOJ, BIT1))
;;;81         {//GPF13 rts(DE active high), 14 cts (RE active low) //output low
;;;82             outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20));
000088  e3a0020b          MOV      r0,#0xb0000000
00008c  e590009c          LDR      r0,[r0,#0x9c]
000090  e3c0060f          BIC      r0,r0,#0xf00000
000094  e581009c          STR      r0,[r1,#0x9c]
;;;83             outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0<<24));
000098  e3a0020b          MOV      r0,#0xb0000000
00009c  e590009c          LDR      r0,[r0,#0x9c]
0000a0  e3c0040f          BIC      r0,r0,#0xf000000
0000a4  e581009c          STR      r0,[r1,#0x9c]
;;;84             
;;;85             GPIO_OpenBit(GPIOF, BIT13, DIR_OUTPUT, NO_PULL_UP); 
0000a8  e3a03000          MOV      r3,#0
0000ac  e3a02001          MOV      r2,#1
0000b0  e3a01a02          MOV      r1,#0x2000
0000b4  e3a00d05          MOV      r0,#0x140
0000b8  ebfffffe          BL       GPIO_OpenBit
;;;86             GPIO_OpenBit(GPIOF, BIT14, DIR_OUTPUT, NO_PULL_UP); 
0000bc  e3a03000          MOV      r3,#0
0000c0  e3a02001          MOV      r2,#1
0000c4  e3a01901          MOV      r1,#0x4000
0000c8  e3a00d05          MOV      r0,#0x140
0000cc  ebfffffe          BL       GPIO_OpenBit
;;;87             
;;;88             //disable
;;;89             GPIO_ClrBit(GPIOF, BIT13); //RTS low disable TX
0000d0  e3a01a02          MOV      r1,#0x2000
0000d4  e3a00d05          MOV      r0,#0x140
0000d8  ebfffffe          BL       GPIO_ClrBit
;;;90             GPIO_SetBit(GPIOF, BIT14); //CTS high disable RX   
0000dc  e3a01901          MOV      r1,#0x4000
0000e0  e3a00d05          MOV      r0,#0x140
0000e4  ebfffffe          BL       GPIO_SetBit
0000e8  ea00000a          B        |L1.280|
                  |L1.236|
;;;91     
;;;92             
;;;93         }
;;;94         else
;;;95         {//GPF13, 14 //RTS, CTS
;;;96             outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0x9<<20)); 
0000ec  e3a0020b          MOV      r0,#0xb0000000
0000f0  e590009c          LDR      r0,[r0,#0x9c]
0000f4  e3c0060f          BIC      r0,r0,#0xf00000
0000f8  e3800609          ORR      r0,r0,#0x900000
0000fc  e3a0120b          MOV      r1,#0xb0000000
000100  e581009c          STR      r0,[r1,#0x9c]
;;;97             outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0x9<<24)); 
000104  e3a0020b          MOV      r0,#0xb0000000
000108  e590009c          LDR      r0,[r0,#0x9c]
00010c  e3c0040f          BIC      r0,r0,#0xf000000
000110  e3800409          ORR      r0,r0,#0x9000000
000114  e581009c          STR      r0,[r1,#0x9c]
                  |L1.280|
;;;98         }
;;;99         
;;;100        //GPI4 Ooctopus Power Ctrl pin
;;;101        outpw(REG_SYS_GPI_MFPL,(inpw(REG_SYS_GPI_MFPL) & ~(0xF<<16)) | (0x0<<16));
000118  e3a0020b          MOV      r0,#0xb0000000
00011c  e59000b0          LDR      r0,[r0,#0xb0]
000120  e3c0080f          BIC      r0,r0,#0xf0000
000124  e3a0120b          MOV      r1,#0xb0000000
000128  e58100b0          STR      r0,[r1,#0xb0]
;;;102        GPIO_OpenBit(OCTOPUS_POWER_CTRL_PORT, OCTOPUS_POWER_CTRL_PIN, DIR_OUTPUT, NO_PULL_UP); 
00012c  e3a03000          MOV      r3,#0
000130  e3a02001          MOV      r2,#1
000134  e3a01010          MOV      r1,#0x10
000138  e3a00c02          MOV      r0,#0x200
00013c  ebfffffe          BL       GPIO_OpenBit
;;;103        GPIO_SetBit(OCTOPUS_POWER_CTRL_PORT, OCTOPUS_POWER_CTRL_PIN);//high:shut down
000140  e3a01010          MOV      r1,#0x10
000144  e3a00c02          MOV      r0,#0x200
000148  ebfffffe          BL       GPIO_SetBit
;;;104        
;;;105        //GPF10 5V Power pin
;;;106        outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<8)) | (0x0<<8));
00014c  e3a0020b          MOV      r0,#0xb0000000
000150  e590009c          LDR      r0,[r0,#0x9c]
000154  e3c00c0f          BIC      r0,r0,#0xf00
000158  e3a0120b          MOV      r1,#0xb0000000
00015c  e581009c          STR      r0,[r1,#0x9c]
;;;107        GPIO_OpenBit(POWER_PORT, POWER_PIN, DIR_OUTPUT, NO_PULL_UP); 
000160  e3a03000          MOV      r3,#0
000164  e3a02001          MOV      r2,#1
000168  e3a01b01          MOV      r1,#0x400
00016c  e3a00d05          MOV      r0,#0x140
000170  ebfffffe          BL       GPIO_OpenBit
;;;108        GPIO_ClrBit(POWER_PORT, POWER_PIN);
000174  e3a01b01          MOV      r1,#0x400
000178  e3a00d05          MOV      r0,#0x140
00017c  ebfffffe          BL       GPIO_ClrBit
;;;109        
;;;110        
;;;111        //RS232/rs485 Power pin GPG9
;;;112        outpw(REG_SYS_GPG_MFPH,(inpw(REG_SYS_GPG_MFPH) & ~(0xFu<<4)) | (0x0u<<4));
000180  e3a0020b          MOV      r0,#0xb0000000
000184  e59000a4          LDR      r0,[r0,#0xa4]
000188  e3c000f0          BIC      r0,r0,#0xf0
00018c  e3a0120b          MOV      r1,#0xb0000000
000190  e58100a4          STR      r0,[r1,#0xa4]
;;;113        GPIO_OpenBit(CONVERT_CHIP_PORT, CONVERT_CHIP_PIN, DIR_OUTPUT, NO_PULL_UP); 
000194  e3a03000          MOV      r3,#0
000198  e3a02001          MOV      r2,#1
00019c  e3a01c02          MOV      r1,#0x200
0001a0  e3a00d06          MOV      r0,#0x180
0001a4  ebfffffe          BL       GPIO_OpenBit
;;;114        UART2SetRS232Power(FALSE);
0001a8  e3a00000          MOV      r0,#0
0001ac  ebfffffe          BL       UART2SetRS232Power
;;;115        /*
;;;116        //12V enable pin PG6
;;;117        outpw(REG_SYS_GPG_MFPL,(inpw(REG_SYS_GPG_MFPL) & ~(0xF<<24)) | (0x0u<<24));  
;;;118        GPIO_OpenBit(POWER_12V_PORT, POWER_12V_PIN, DIR_OUTPUT, NO_PULL_UP); 
;;;119        GPIO_ClrBit(POWER_12V_PORT, POWER_12V_PIN);
;;;120        */
;;;121        //12V enable pin PI15
;;;122        outpw(REG_SYS_GPI_MFPH,(inpw(REG_SYS_GPI_MFPH) & ~(0xF<<28)) | (0x0<<28));  
0001b0  e3a0020b          MOV      r0,#0xb0000000
0001b4  e59000b4          LDR      r0,[r0,#0xb4]
0001b8  e3c0020f          BIC      r0,r0,#0xf0000000
0001bc  e3a0120b          MOV      r1,#0xb0000000
0001c0  e58100b4          STR      r0,[r1,#0xb4]
;;;123        GPIO_OpenBit(POWER_12V_2_PORT, POWER_12V_2_PIN, DIR_OUTPUT, NO_PULL_UP); 
0001c4  e3a03000          MOV      r3,#0
0001c8  e3a02001          MOV      r2,#1
0001cc  e3a01902          MOV      r1,#0x8000
0001d0  e3a00c02          MOV      r0,#0x200
0001d4  ebfffffe          BL       GPIO_OpenBit
;;;124        GPIO_ClrBit(POWER_12V_2_PORT, POWER_12V_2_PIN);
0001d8  e3a01902          MOV      r1,#0x8000
0001dc  e3a00c02          MOV      r0,#0x200
0001e0  ebfffffe          BL       GPIO_ClrBit
;;;125        
;;;126        /* configure UART */
;;;127        param.uFreq = 12000000;
0001e4  e59f0214          LDR      r0,|L1.1024|
0001e8  e59f1214          LDR      r1,|L1.1028|
0001ec  e5810000          STR      r0,[r1,#0]  ; param
;;;128        param.uBaudRate = baudRate;
0001f0  e2810000          ADD      r0,r1,#0
0001f4  e5805004          STR      r5,[r0,#4]  ; param
;;;129        param.ucUartNo = UART2;
0001f8  e3a00002          MOV      r0,#2
0001fc  e5c10008          STRB     r0,[r1,#8]  ; param
;;;130        param.ucDataBits = DATA_BITS_8;
000200  e3a00003          MOV      r0,#3
000204  e5c10009          STRB     r0,[r1,#9]  ; param
;;;131        param.ucStopBits = STOP_BITS_1;
000208  e3a00000          MOV      r0,#0
00020c  e5c1000a          STRB     r0,[r1,#0xa]  ; param
;;;132        param.ucParity = PARITY_NONE;
000210  e5c1000b          STRB     r0,[r1,#0xb]  ; param
;;;133        param.ucRxTriggerLevel = UART_FCR_RFITL_1BYTE;
000214  e5c1000c          STRB     r0,[r1,#0xc]  ; param
;;;134        retval = uartOpen(&param);
000218  e2810000          ADD      r0,r1,#0
00021c  ebfffffe          BL       uartOpen
000220  e1a04000          MOV      r4,r0
;;;135        if(retval != 0) 
000224  e3540000          CMP      r4,#0
000228  0a000003          BEQ      |L1.572|
;;;136        {
;;;137            sysprintf("hwInit Open UART error!\n");
00022c  e28f0f75          ADR      r0,|L1.1032|
000230  ebfffffe          BL       sysprintf
;;;138            return FALSE;
000234  e3a00000          MOV      r0,#0
                  |L1.568|
;;;139        }
;;;140    
;;;141        /* set TX interrupt mode */
;;;142        retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTPOLLMODE /*UARTINTMODE*/ , 0);
;;;143        //retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTINTMODE , 0);
;;;144        if (retval != 0) 
;;;145        {
;;;146            sysprintf("hwInit Set TX interrupt mode fail!\n");
;;;147            return FALSE;
;;;148        }
;;;149    
;;;150        /* set RX interrupt mode */
;;;151        retval = uartIoctl(param.ucUartNo, UART_IOC_SETRXMODE, UARTINTMODE, 0);
;;;152        if (retval != 0) 
;;;153        {
;;;154            sysprintf("hwInit Set RX interrupt mode fail!\n");
;;;155            return FALSE;
;;;156        }
;;;157        
;;;158        return TRUE;
;;;159    }
000238  e8bd8070          POP      {r4-r6,pc}
                  |L1.572|
00023c  e59f11c0          LDR      r1,|L1.1028|
000240  e5d10008          LDRB     r0,[r1,#8]            ;142  ; param
000244  e3a03000          MOV      r3,#0                 ;142
000248  e1a02003          MOV      r2,r3                 ;142
00024c  e3a01001          MOV      r1,#1                 ;142
000250  ebfffffe          BL       uartIoctl
000254  e1a04000          MOV      r4,r0                 ;142
000258  e3540000          CMP      r4,#0                 ;144
00025c  0a000003          BEQ      |L1.624|
000260  e28f0f6f          ADR      r0,|L1.1060|
000264  ebfffffe          BL       sysprintf
000268  e3a00000          MOV      r0,#0                 ;147
00026c  eafffff1          B        |L1.568|
                  |L1.624|
000270  e59f118c          LDR      r1,|L1.1028|
000274  e5d10008          LDRB     r0,[r1,#8]            ;151  ; param
000278  e3a03000          MOV      r3,#0                 ;151
00027c  e3a02001          MOV      r2,#1                 ;151
000280  e3a01002          MOV      r1,#2                 ;151
000284  ebfffffe          BL       uartIoctl
000288  e1a04000          MOV      r4,r0                 ;151
00028c  e3540000          CMP      r4,#0                 ;152
000290  0a000003          BEQ      |L1.676|
000294  e28f0f6b          ADR      r0,|L1.1096|
000298  ebfffffe          BL       sysprintf
00029c  e3a00000          MOV      r0,#0                 ;155
0002a0  eaffffe4          B        |L1.568|
                  |L1.676|
0002a4  e3a00001          MOV      r0,#1                 ;158
0002a8  eaffffe2          B        |L1.568|
;;;160     
                          ENDP

                  UART2DrvInit PROC
;;;163    /*-----------------------------------------*/
;;;164    BOOL UART2DrvInit(UINT32 baudRate)
0002ac  e92d4070          PUSH     {r4-r6,lr}
;;;165    {
0002b0  e1a05000          MOV      r5,r0
;;;166        int retval = TRUE;;
0002b4  e3a04001          MOV      r4,#1
;;;167        sysprintf("UART2DrvInit!!\n");
0002b8  e28f0f6b          ADR      r0,|L1.1132|
0002bc  ebfffffe          BL       sysprintf
;;;168        retval = hwInit(baudRate);
0002c0  e1a00005          MOV      r0,r5
0002c4  ebfffffe          BL       hwInit
0002c8  e1a04000          MOV      r4,r0
;;;169        return retval;
0002cc  e1a00004          MOV      r0,r4
;;;170    }
0002d0  e8bd8070          POP      {r4-r6,pc}
;;;171    #define UART_WRITE_SIZE 256
                          ENDP

                  UART2Write PROC
;;;172    INT32 UART2Write(PUINT8 pucBuf, UINT32 uLen)
0002d4  e92d47f0          PUSH     {r4-r10,lr}
;;;173    {
0002d8  e1a08000          MOV      r8,r0
0002dc  e1a04001          MOV      r4,r1
;;;174        /*               
;;;175        terninalPrintf("Reader>=");
;;;176        for(int i=0;i<uLen;i++)
;;;177        terninalPrintf("%02x ",pucBuf[i]);
;;;178        terninalPrintf("\n  ");
;;;179                         
;;;180        for(int k=0;k<uLen;k++)
;;;181        {
;;;182            if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;183                terninalPrintf("%c",pucBuf[k]);
;;;184        } 
;;;185        terninalPrintf("\n"); 
;;;186        */
;;;187        
;;;188        if(octopusModeFlag)
0002e0  e59f0114          LDR      r0,|L1.1020|
0002e4  e5d00000          LDRB     r0,[r0,#0]  ; octopusModeFlag
0002e8  e3500000          CMP      r0,#0
0002ec  0a000085          BEQ      |L1.1288|
;;;189        //if((octopusModeFlag) && GPIO_ReadBit(GPIOJ, BIT1))
;;;190        {
;;;191            int i = 0;
0002f0  e3a06000          MOV      r6,#0
;;;192            int total = 0;
0002f4  e3a07000          MOV      r7,#0
;;;193            int leftLen = 0;
0002f8  e3a09000          MOV      r9,#0
;;;194            int n;
;;;195            //terninalPrintf("octopusModeFlag = TRUE\n");
;;;196            for(i = 0; i< uLen/UART_WRITE_SIZE; i++)
0002fc  e1a00000          MOV      r0,r0
000300  ea000014          B        |L1.856|
                  |L1.772|
;;;197            {            
;;;198                n = uartWrite(param.ucUartNo, pucBuf + i*UART_WRITE_SIZE, UART_WRITE_SIZE); ;//QModemWrite(buff + i*FTP_UART_WRITE_SIZE, FTP_UART_WRITE_SIZE);
000304  e0881406          ADD      r1,r8,r6,LSL #8
000308  e59f20f4          LDR      r2,|L1.1028|
00030c  e5d20008          LDRB     r0,[r2,#8]  ; param
000310  e3a02c01          MOV      r2,#0x100
000314  ebfffffe          BL       uartWrite
000318  e1a05000          MOV      r5,r0
;;;199                if(n != UART_WRITE_SIZE)
00031c  e3550c01          CMP      r5,#0x100
000320  0a000003          BEQ      |L1.820|
;;;200                {
;;;201                    sysprintf(" == UART2Write write error\r\n");
000324  e28f0e15          ADR      r0,|L1.1148|
000328  ebfffffe          BL       sysprintf
;;;202                    return 0;
00032c  e3a00000          MOV      r0,#0
                  |L1.816|
;;;203                }
;;;204                else
;;;205                {
;;;206                    total = total + n;
;;;207                    sysprintf("%08d (%d:%d)\r", total, n, i*UART_WRITE_SIZE);
;;;208                    
;;;209                    vTaskDelay(100/portTICK_RATE_MS);
;;;210                }
;;;211            }
;;;212            leftLen = uLen-(uLen/UART_WRITE_SIZE*UART_WRITE_SIZE);
;;;213            if(leftLen > 0)
;;;214            {
;;;215                n = uartWrite(param.ucUartNo, pucBuf + uLen/UART_WRITE_SIZE*UART_WRITE_SIZE, leftLen);
;;;216                if(n != leftLen)
;;;217                {
;;;218                    sysprintf(" == UART2Write write error\r\n");
;;;219                    return 0;
;;;220                }
;;;221                else
;;;222                {
;;;223                    total = total + n;
;;;224                    sysprintf("\r\n%08d _2 (%d:%d)\r", total, n, leftLen);
;;;225                }
;;;226            }
;;;227            if(total == uLen)
;;;228            {
;;;229                sysprintf(" == UART2Write write OK\r\n");
;;;230                return uLen;
;;;231            }
;;;232            else
;;;233            {
;;;234                sysprintf(" == UART2Write write len error [%s:%s]\r\n", total == uLen);
;;;235                return uLen;
;;;236            }
;;;237                
;;;238        }
;;;239        else
;;;240        {
;;;241            
;;;242            //terninalPrintf("octopusModeFlag = FALSE\n");
;;;243                               
;;;244                /* DEBUG LED *///terninalPrintf(">=");
;;;245                /* DEBUG LED *///for(int i=0;i<uLen;i++)
;;;246                /* DEBUG LED *///terninalPrintf("%02x ",pucBuf[i]);
;;;247                /* DEBUG LED *///terninalPrintf("\n  ");
;;;248                                /*                 
;;;249                               for(int k=0;k<uLen;k++)
;;;250                               {
;;;251                                    if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;252                                        terninalPrintf("%c",pucBuf[k]);
;;;253                               } 
;;;254                               terninalPrintf("\n"); 
;;;255                                */
;;;256            return uartWrite(param.ucUartNo, pucBuf, uLen);
;;;257        }
;;;258    }
000330  e8bd87f0          POP      {r4-r10,pc}
                  |L1.820|
000334  e0877005          ADD      r7,r7,r5              ;206
000338  e1a03406          LSL      r3,r6,#8              ;207
00033c  e1a02005          MOV      r2,r5                 ;207
000340  e1a01007          MOV      r1,r7                 ;207
000344  e28f0e15          ADR      r0,|L1.1180|
000348  ebfffffe          BL       sysprintf
00034c  e3a0000a          MOV      r0,#0xa               ;209
000350  ebfffffe          BL       vTaskDelay
000354  e2866001          ADD      r6,r6,#1              ;196
                  |L1.856|
000358  e1560424          CMP      r6,r4,LSR #8          ;196
00035c  3affffe8          BCC      |L1.772|
000360  e1a00424          LSR      r0,r4,#8              ;212
000364  e0449400          SUB      r9,r4,r0,LSL #8       ;212
000368  e3590000          CMP      r9,#0                 ;213
00036c  da000012          BLE      |L1.956|
000370  e1a02424          LSR      r2,r4,#8              ;215
000374  e0881402          ADD      r1,r8,r2,LSL #8       ;215
000378  e59f2084          LDR      r2,|L1.1028|
00037c  e5d20008          LDRB     r0,[r2,#8]            ;215  ; param
000380  e1a02009          MOV      r2,r9                 ;215
000384  ebfffffe          BL       uartWrite
000388  e1a05000          MOV      r5,r0                 ;215
00038c  e1550009          CMP      r5,r9                 ;216
000390  0a000003          BEQ      |L1.932|
000394  e28f00e0          ADR      r0,|L1.1148|
000398  ebfffffe          BL       sysprintf
00039c  e3a00000          MOV      r0,#0                 ;219
0003a0  eaffffe2          B        |L1.816|
                  |L1.932|
0003a4  e0877005          ADD      r7,r7,r5              ;223
0003a8  e1a03009          MOV      r3,r9                 ;224
0003ac  e1a02005          MOV      r2,r5                 ;224
0003b0  e1a01007          MOV      r1,r7                 ;224
0003b4  e28f00f0          ADR      r0,|L1.1196|
0003b8  ebfffffe          BL       sysprintf
                  |L1.956|
0003bc  e1570004          CMP      r7,r4                 ;227
0003c0  1a000003          BNE      |L1.980|
0003c4  e28f00f4          ADR      r0,|L1.1216|
0003c8  ebfffffe          BL       sysprintf
0003cc  e1a00004          MOV      r0,r4                 ;230
0003d0  eaffffd6          B        |L1.816|
                  |L1.980|
0003d4  e1570004          CMP      r7,r4                 ;234
0003d8  1a000001          BNE      |L1.996|
0003dc  e3a00001          MOV      r0,#1                 ;234
0003e0  ea000000          B        |L1.1000|
                  |L1.996|
0003e4  e3a00000          MOV      r0,#0                 ;234
                  |L1.1000|
0003e8  e1a01000          MOV      r1,r0                 ;234
0003ec  e28f00e8          ADR      r0,|L1.1244|
0003f0  ebfffffe          BL       sysprintf
0003f4  e1a00004          MOV      r0,r4                 ;235
0003f8  eaffffcc          B        |L1.816|
                  |L1.1020|
                          DCD      octopusModeFlag
                  |L1.1024|
                          DCD      0x00b71b00
                  |L1.1028|
                          DCD      param
                  |L1.1032|
000408  6877496e          DCB      "hwInit Open UART error!\n",0
00040c  6974204f
000410  70656e20
000414  55415254
000418  20657272
00041c  6f72210a
000420  00      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L1.1060|
000424  6877496e          DCB      "hwInit Set TX interrupt mode fail!\n",0
000428  69742053
00042c  65742054
000430  5820696e
000434  74657272
000438  75707420
00043c  6d6f6465
000440  20666169
000444  6c210a00
                  |L1.1096|
000448  6877496e          DCB      "hwInit Set RX interrupt mode fail!\n",0
00044c  69742053
000450  65742052
000454  5820696e
000458  74657272
00045c  75707420
000460  6d6f6465
000464  20666169
000468  6c210a00
                  |L1.1132|
00046c  55415254          DCB      "UART2DrvInit!!\n",0
000470  32447276
000474  496e6974
000478  21210a00
                  |L1.1148|
00047c  203d3d20          DCB      " == UART2Write write error\r\n",0
000480  55415254
000484  32577269
000488  74652077
00048c  72697465
000490  20657272
000494  6f720d0a
000498  00      
000499  00                DCB      0
00049a  00                DCB      0
00049b  00                DCB      0
                  |L1.1180|
00049c  25303864          DCB      "%08d (%d:%d)\r",0
0004a0  20282564
0004a4  3a256429
0004a8  0d00    
0004aa  00                DCB      0
0004ab  00                DCB      0
                  |L1.1196|
0004ac  0d0a2530          DCB      "\r\n%08d _2 (%d:%d)\r",0
0004b0  3864205f
0004b4  32202825
0004b8  643a2564
0004bc  290d00  
0004bf  00                DCB      0
                  |L1.1216|
0004c0  203d3d20          DCB      " == UART2Write write OK\r\n",0
0004c4  55415254
0004c8  32577269
0004cc  74652077
0004d0  72697465
0004d4  204f4b0d
0004d8  0a00    
0004da  00                DCB      0
0004db  00                DCB      0
                  |L1.1244|
0004dc  203d3d20          DCB      " == UART2Write write len error [%s:%s]\r\n",0
0004e0  55415254
0004e4  32577269
0004e8  74652077
0004ec  72697465
0004f0  206c656e
0004f4  20657272
0004f8  6f72205b
0004fc  25733a25
000500  735d0d0a
000504  00      
000505  00                DCB      0
000506  00                DCB      0
000507  00                DCB      0
                  |L1.1288|
000508  e1a00000          MOV      r0,r0                 ;238
00050c  e51f1110          LDR      r1,|L1.1028|
000510  e5d10008          LDRB     r0,[r1,#8]            ;256  ; param
000514  e1a02004          MOV      r2,r4                 ;256
000518  e1a01008          MOV      r1,r8                 ;256
00051c  ebfffffe          BL       uartWrite
000520  eaffff82          B        |L1.816|
;;;259    INT32 UART2Read(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART2Read PROC
000524  e92d4070          PUSH     {r4-r6,lr}
;;;260    {
000528  e1a04000          MOV      r4,r0
00052c  e1a05001          MOV      r5,r1
;;;261        
;;;262        /* 
;;;263        INT32 temp;
;;;264        memset(pucBuf,0x00,uLen);
;;;265        temp = uartRead(param.ucUartNo, pucBuf, uLen);
;;;266        if(temp > 0)
;;;267        {
;;;268            terninalPrintf("<=");
;;;269            int counter = 0; 
;;;270            for(int i=0;i<temp;i++)
;;;271            {
;;;272    
;;;273                terninalPrintf("%02x ",pucBuf[i]);
;;;274            }
;;;275            terninalPrintf("\n  ");
;;;276            for(int k=0;k<temp;k++)
;;;277            {
;;;278                if((pucBuf[k] >= 0x20) && (pucBuf[k] <= 0x7E))
;;;279                    terninalPrintf("%c",pucBuf[k]);
;;;280            } 
;;;281            terninalPrintf("\n");
;;;282        }    
;;;283        return temp;  
;;;284        */
;;;285        
;;;286        
;;;287        
;;;288        
;;;289        
;;;290        
;;;291        return uartRead(param.ucUartNo, pucBuf, uLen);
000530  e51f1134          LDR      r1,|L1.1028|
000534  e5d10008          LDRB     r0,[r1,#8]  ; param
000538  e1a02005          MOV      r2,r5
00053c  e1a01004          MOV      r1,r4
000540  ebfffffe          BL       uartRead
;;;292    }
000544  e8bd8070          POP      {r4-r6,pc}
;;;293    BaseType_t UART2ReadWait(TickType_t time)
                          ENDP

                  UART2ReadWait PROC
000548  e92d4010          PUSH     {r4,lr}
;;;294    {
00054c  e1a04000          MOV      r4,r0
;;;295        return  uartWaitReadEvent(param.ucUartNo, time);
000550  e51f1154          LDR      r1,|L1.1028|
000554  e5d10008          LDRB     r0,[r1,#8]  ; param
000558  e1a01004          MOV      r1,r4
00055c  ebfffffe          BL       uartWaitReadEvent
;;;296    }
000560  e8bd8010          POP      {r4,pc}
;;;297    
                          ENDP

                  UART2SetPower PROC
;;;298    BOOL UART2SetPower(BOOL flag)
000564  e92d4010          PUSH     {r4,lr}
;;;299    {
000568  e1a04000          MOV      r4,r0
;;;300        if(octopusModeFlag)
00056c  e51f0178          LDR      r0,|L1.1020|
000570  e5d00000          LDRB     r0,[r0,#0]  ; octopusModeFlag
000574  e3500000          CMP      r0,#0
000578  0a000032          BEQ      |L1.1608|
;;;301        //if((octopusModeFlag) && GPIO_ReadBit(GPIOJ, BIT1))
;;;302        {          
;;;303            if(flag)
00057c  e3540000          CMP      r4,#0
000580  0a00001a          BEQ      |L1.1520|
;;;304            {         
;;;305                GPIO_SetBit(POWER_12V_PORT, POWER_12V_PIN);
000584  e3a01040          MOV      r1,#0x40
000588  e3a00d06          MOV      r0,#0x180
00058c  ebfffffe          BL       GPIO_SetBit
;;;306                GPIO_SetBit(POWER_12V_2_PORT, POWER_12V_2_PIN);
000590  e3a01902          MOV      r1,#0x8000
000594  e3a00c02          MOV      r0,#0x200
000598  ebfffffe          BL       GPIO_SetBit
;;;307                
;;;308                // GPF11, 12, 13, 14 //TX, RX, RTS, CTS
;;;309                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0x9<<12));
00059c  e3a0020b          MOV      r0,#0xb0000000
0005a0  e590009c          LDR      r0,[r0,#0x9c]
0005a4  e3c00a0f          BIC      r0,r0,#0xf000
0005a8  e3800a09          ORR      r0,r0,#0x9000
0005ac  e3a0120b          MOV      r1,#0xb0000000
0005b0  e581009c          STR      r0,[r1,#0x9c]
;;;310                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0x9<<16));
0005b4  e3a0020b          MOV      r0,#0xb0000000
0005b8  e590009c          LDR      r0,[r0,#0x9c]
0005bc  e3c0080f          BIC      r0,r0,#0xf0000
0005c0  e3800809          ORR      r0,r0,#0x90000
0005c4  e581009c          STR      r0,[r1,#0x9c]
;;;311    
;;;312                GPIO_SetBit(GPIOF, BIT13); //RTS high enable TX
0005c8  e3a01a02          MOV      r1,#0x2000
0005cc  e3a00d05          MOV      r0,#0x140
0005d0  ebfffffe          BL       GPIO_SetBit
;;;313                GPIO_ClrBit(GPIOF, BIT14); //CTS low enable RX
0005d4  e3a01901          MOV      r1,#0x4000
0005d8  e3a00d05          MOV      r0,#0x140
0005dc  ebfffffe          BL       GPIO_ClrBit
;;;314                
;;;315                //outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<18)) | (0x1<<18)); 
;;;316                
;;;317                GPIO_ClrBit(OCTOPUS_POWER_CTRL_PORT, OCTOPUS_POWER_CTRL_PIN);              
0005e0  e3a01010          MOV      r1,#0x10
0005e4  e3a00c02          MOV      r0,#0x200
0005e8  ebfffffe          BL       GPIO_ClrBit
0005ec  ea00004c          B        |L1.1828|
                  |L1.1520|
;;;318            }
;;;319            else
;;;320            {
;;;321                GPIO_SetBit(OCTOPUS_POWER_CTRL_PORT, OCTOPUS_POWER_CTRL_PIN);//high:shut down
0005f0  e3a01010          MOV      r1,#0x10
0005f4  e3a00c02          MOV      r0,#0x200
0005f8  ebfffffe          BL       GPIO_SetBit
;;;322                
;;;323                //outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<18)) | (0x0<<18)); 
;;;324                
;;;325                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0<<12));
0005fc  e3a0020b          MOV      r0,#0xb0000000
000600  e590009c          LDR      r0,[r0,#0x9c]
000604  e3c00a0f          BIC      r0,r0,#0xf000
000608  e3a0120b          MOV      r1,#0xb0000000
00060c  e581009c          STR      r0,[r1,#0x9c]
;;;326                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0<<16));
000610  e3a0020b          MOV      r0,#0xb0000000
000614  e590009c          LDR      r0,[r0,#0x9c]
000618  e3c0080f          BIC      r0,r0,#0xf0000
00061c  e581009c          STR      r0,[r1,#0x9c]
;;;327    
;;;328                GPIO_ClrBit(GPIOF, BIT13); //RTS low disable TX
000620  e3a01a02          MOV      r1,#0x2000
000624  e3a00d05          MOV      r0,#0x140
000628  ebfffffe          BL       GPIO_ClrBit
;;;329                GPIO_SetBit(GPIOF, BIT14); //CTS high disable RX
00062c  e3a01901          MOV      r1,#0x4000
000630  e3a00d05          MOV      r0,#0x140
000634  ebfffffe          BL       GPIO_SetBit
;;;330    
;;;331                //GPIO_ClrBit(POWER_12V_PORT, POWER_12V_PIN);      not need close 12V power 20200507 by Steven 
;;;332                GPIO_ClrBit(POWER_12V_2_PORT, POWER_12V_2_PIN);
000638  e3a01902          MOV      r1,#0x8000
00063c  e3a00c02          MOV      r0,#0x200
000640  ebfffffe          BL       GPIO_ClrBit
000644  ea000036          B        |L1.1828|
                  |L1.1608|
;;;333            }
;;;334        }
;;;335        else
;;;336        {
;;;337            if(flag)
000648  e3540000          CMP      r4,#0
00064c  0a00001c          BEQ      |L1.1732|
;;;338            {         
;;;339                // GPF11, 12, 13, 14 //TX, RX, RTS, CTS
;;;340                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0x9<<12));
000650  e3a0020b          MOV      r0,#0xb0000000
000654  e590009c          LDR      r0,[r0,#0x9c]
000658  e3c00a0f          BIC      r0,r0,#0xf000
00065c  e3800a09          ORR      r0,r0,#0x9000
000660  e3a0120b          MOV      r1,#0xb0000000
000664  e581009c          STR      r0,[r1,#0x9c]
;;;341                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0x9<<16));
000668  e3a0020b          MOV      r0,#0xb0000000
00066c  e590009c          LDR      r0,[r0,#0x9c]
000670  e3c0080f          BIC      r0,r0,#0xf0000
000674  e3800809          ORR      r0,r0,#0x90000
000678  e581009c          STR      r0,[r1,#0x9c]
;;;342                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0x9<<20)); 
00067c  e3a0020b          MOV      r0,#0xb0000000
000680  e590009c          LDR      r0,[r0,#0x9c]
000684  e3c0060f          BIC      r0,r0,#0xf00000
000688  e3800609          ORR      r0,r0,#0x900000
00068c  e581009c          STR      r0,[r1,#0x9c]
;;;343                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0x9<<24)); 
000690  e3a0020b          MOV      r0,#0xb0000000
000694  e590009c          LDR      r0,[r0,#0x9c]
000698  e3c0040f          BIC      r0,r0,#0xf000000
00069c  e3800409          ORR      r0,r0,#0x9000000
0006a0  e581009c          STR      r0,[r1,#0x9c]
;;;344                outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<18)) | (0x1<<18)); 
0006a4  e3a0020b          MOV      r0,#0xb0000000
0006a8  e5900218          LDR      r0,[r0,#0x218]
0006ac  e3800701          ORR      r0,r0,#0x40000
0006b0  e5810218          STR      r0,[r1,#0x218]
;;;345                GPIO_SetBit(POWER_PORT, POWER_PIN);   
0006b4  e3a01b01          MOV      r1,#0x400
0006b8  e3a00d05          MOV      r0,#0x140
0006bc  ebfffffe          BL       GPIO_SetBit
0006c0  ea000017          B        |L1.1828|
                  |L1.1732|
;;;346                          
;;;347            }
;;;348            else
;;;349            {
;;;350                GPIO_ClrBit(POWER_PORT, POWER_PIN);
0006c4  e3a01b01          MOV      r1,#0x400
0006c8  e3a00d05          MOV      r0,#0x140
0006cc  ebfffffe          BL       GPIO_ClrBit
;;;351                outpw(REG_CLK_PCLKEN0,(inpw(REG_CLK_PCLKEN0) & ~(0x1<<18)) | (0x0<<18)); 
0006d0  e3a0020b          MOV      r0,#0xb0000000
0006d4  e5900218          LDR      r0,[r0,#0x218]
0006d8  e3c00701          BIC      r0,r0,#0x40000
0006dc  e3a0120b          MOV      r1,#0xb0000000
0006e0  e5810218          STR      r0,[r1,#0x218]
;;;352                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0<<12));
0006e4  e3a0020b          MOV      r0,#0xb0000000
0006e8  e590009c          LDR      r0,[r0,#0x9c]
0006ec  e3c00a0f          BIC      r0,r0,#0xf000
0006f0  e581009c          STR      r0,[r1,#0x9c]
;;;353                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0<<16));
0006f4  e3a0020b          MOV      r0,#0xb0000000
0006f8  e590009c          LDR      r0,[r0,#0x9c]
0006fc  e3c0080f          BIC      r0,r0,#0xf0000
000700  e581009c          STR      r0,[r1,#0x9c]
;;;354                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0<<20)); 
000704  e3a0020b          MOV      r0,#0xb0000000
000708  e590009c          LDR      r0,[r0,#0x9c]
00070c  e3c0060f          BIC      r0,r0,#0xf00000
000710  e581009c          STR      r0,[r1,#0x9c]
;;;355                outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0<<24));         
000714  e3a0020b          MOV      r0,#0xb0000000
000718  e590009c          LDR      r0,[r0,#0x9c]
00071c  e3c0040f          BIC      r0,r0,#0xf000000
000720  e581009c          STR      r0,[r1,#0x9c]
                  |L1.1828|
;;;356            }
;;;357        }
;;;358        return TRUE;
000724  e3a00001          MOV      r0,#1
;;;359    }
000728  e8bd8010          POP      {r4,pc}
;;;360    BOOL UART2SetRS232Power(BOOL flag)
                          ENDP

                  UART2Ioctl PROC
;;;372    }
;;;373    INT UART2Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
00072c  e92d4070          PUSH     {r4-r6,lr}
;;;374    {
000730  e1a04000          MOV      r4,r0
000734  e1a05001          MOV      r5,r1
000738  e1a06002          MOV      r6,r2
;;;375        if(UART_IOC_SET_OCTOPUS_MODE == uCmd)
00073c  e3540028          CMP      r4,#0x28
000740  1a000004          BNE      |L1.1880|
;;;376        {
;;;377            //terninalPrintf("UART2Ioctl [UART_IOC_SET_OCTOPUS_MODE]\r\n");
;;;378            octopusModeFlag = TRUE;
000744  e3a00001          MOV      r0,#1
000748  e51f1354          LDR      r1,|L1.1020|
00074c  e5c10000          STRB     r0,[r1,#0]  ; octopusModeFlag
;;;379            return Successful;
000750  e3a00000          MOV      r0,#0
                  |L1.1876|
;;;380        }
;;;381        else
;;;382            return uartIoctl(param.ucUartNo, uCmd, uArg0, uArg1);
;;;383    }
000754  e8bd8070          POP      {r4-r6,pc}
                  |L1.1880|
000758  e51f135c          LDR      r1,|L1.1028|
00075c  e5d10008          LDRB     r0,[r1,#8]            ;382  ; param
000760  e1a03006          MOV      r3,r6                 ;382
000764  e1a02005          MOV      r2,r5                 ;382
000768  e1a01004          MOV      r1,r4                 ;382
00076c  ebfffffe          BL       uartIoctl
000770  eafffff7          B        |L1.1876|
;;;384    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  octopusModeFlag
000000  00                DCB      0x00
