; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\uartdrv.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uartdrv.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\uartdrv.crf src\userdrv\uartdrv.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART2SetRS232Power PROC
;;;175    }
;;;176    BOOL UART2SetRS232Power(BOOL flag)
000000  e92d4010          PUSH     {r4,lr}
;;;177    {
000004  e1a04000          MOV      r4,r0
;;;178        if(flag)
000008  e3540000          CMP      r4,#0
00000c  0a000003          BEQ      |L1.32|
;;;179        {         
;;;180            GPIO_SetBit(RS232_POWER_PORT, RS232_POWER_PIN);    
000010  e3a01c02          MOV      r1,#0x200
000014  e3a00d06          MOV      r0,#0x180
000018  ebfffffe          BL       GPIO_SetBit
00001c  ea000002          B        |L1.44|
                  |L1.32|
;;;181        }
;;;182        else
;;;183        {
;;;184            GPIO_ClrBit(RS232_POWER_PORT, RS232_POWER_PIN);         
000020  e3a01c02          MOV      r1,#0x200
000024  e3a00d06          MOV      r0,#0x180
000028  ebfffffe          BL       GPIO_ClrBit
                  |L1.44|
;;;185        }
;;;186        return TRUE;
00002c  e3a00001          MOV      r0,#1
;;;187    }
000030  e8bd8010          POP      {r4,pc}
;;;188    INT UART2Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
                          ENDP

                  UART2SetPower PROC
;;;163    
;;;164    BOOL UART2SetPower(BOOL flag)
000034  e92d4010          PUSH     {r4,lr}
;;;165    {
000038  e1a04000          MOV      r4,r0
;;;166        if(flag)
00003c  e3540000          CMP      r4,#0
000040  0a000003          BEQ      |L1.84|
;;;167        {         
;;;168            GPIO_SetBit(POWER_PORT, POWER_PIN);    
000044  e3a01b01          MOV      r1,#0x400
000048  e3a00d05          MOV      r0,#0x140
00004c  ebfffffe          BL       GPIO_SetBit
000050  ea000002          B        |L1.96|
                  |L1.84|
;;;169        }
;;;170        else
;;;171        {
;;;172            GPIO_ClrBit(POWER_PORT, POWER_PIN);         
000054  e3a01b01          MOV      r1,#0x400
000058  e3a00d05          MOV      r0,#0x140
00005c  ebfffffe          BL       GPIO_ClrBit
                  |L1.96|
;;;173        }
;;;174        return TRUE;
000060  e3a00001          MOV      r0,#1
;;;175    }
000064  e8bd8010          POP      {r4,pc}
;;;176    BOOL UART2SetRS232Power(BOOL flag)
                          ENDP

                  hwInit PROC
;;;45     /*-----------------------------------------*/
;;;46     static BOOL hwInit(UINT32 baudRate)
000068  e92d4070          PUSH     {r4-r6,lr}
;;;47     {
00006c  e1a05000          MOV      r5,r0
;;;48         int retval;
;;;49         outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000070  e3a0020b          MOV      r0,#0xb0000000
000074  e5900218          LDR      r0,[r0,#0x218]
000078  e3800008          ORR      r0,r0,#8
00007c  e3a0120b          MOV      r1,#0xb0000000
000080  e5810218          STR      r0,[r1,#0x218]
;;;50         
;;;51         // GPF11, 12, 13, 14 //TX, RX, RTS, CTS
;;;52         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<12)) | (0x9<<12));
000084  e3a0020b          MOV      r0,#0xb0000000
000088  e590009c          LDR      r0,[r0,#0x9c]
00008c  e3c00a0f          BIC      r0,r0,#0xf000
000090  e3800a09          ORR      r0,r0,#0x9000
000094  e581009c          STR      r0,[r1,#0x9c]
;;;53         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<16)) | (0x9<<16));
000098  e3a0020b          MOV      r0,#0xb0000000
00009c  e590009c          LDR      r0,[r0,#0x9c]
0000a0  e3c0080f          BIC      r0,r0,#0xf0000
0000a4  e3800809          ORR      r0,r0,#0x90000
0000a8  e581009c          STR      r0,[r1,#0x9c]
;;;54         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<20)) | (0x9<<20)); 
0000ac  e3a0020b          MOV      r0,#0xb0000000
0000b0  e590009c          LDR      r0,[r0,#0x9c]
0000b4  e3c0060f          BIC      r0,r0,#0xf00000
0000b8  e3800609          ORR      r0,r0,#0x900000
0000bc  e581009c          STR      r0,[r1,#0x9c]
;;;55         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<24)) | (0x9<<24)); 
0000c0  e3a0020b          MOV      r0,#0xb0000000
0000c4  e590009c          LDR      r0,[r0,#0x9c]
0000c8  e3c0040f          BIC      r0,r0,#0xf000000
0000cc  e3800409          ORR      r0,r0,#0x9000000
0000d0  e581009c          STR      r0,[r1,#0x9c]
;;;56         
;;;57         //GPF10 Power pin
;;;58         outpw(REG_SYS_GPF_MFPH,(inpw(REG_SYS_GPF_MFPH) & ~(0xF<<8)) | (0x0<<8));
0000d4  e3a0020b          MOV      r0,#0xb0000000
0000d8  e590009c          LDR      r0,[r0,#0x9c]
0000dc  e3c00c0f          BIC      r0,r0,#0xf00
0000e0  e581009c          STR      r0,[r1,#0x9c]
;;;59         GPIO_OpenBit(POWER_PORT, POWER_PIN, DIR_OUTPUT, NO_PULL_UP); 
0000e4  e3a03000          MOV      r3,#0
0000e8  e3a02001          MOV      r2,#1
0000ec  e3a01b01          MOV      r1,#0x400
0000f0  e3a00d05          MOV      r0,#0x140
0000f4  ebfffffe          BL       GPIO_OpenBit
;;;60         UART2SetPower(FALSE);
0000f8  e3a00000          MOV      r0,#0
0000fc  ebfffffe          BL       UART2SetPower
;;;61         
;;;62         //RS232 Power pin GPE7
;;;63         outpw(REG_SYS_GPE_MFPL,(inpw(REG_SYS_GPE_MFPL) & ~(0xFu<<28)) | (0x0u<<28));
000100  e3a0020b          MOV      r0,#0xb0000000
000104  e5900090          LDR      r0,[r0,#0x90]
000108  e3c0020f          BIC      r0,r0,#0xf0000000
00010c  e3a0120b          MOV      r1,#0xb0000000
000110  e5810090          STR      r0,[r1,#0x90]
;;;64         GPIO_OpenBit(RS232_POWER_PORT, RS232_POWER_PIN, DIR_OUTPUT, NO_PULL_UP); 
000114  e3a03000          MOV      r3,#0
000118  e3a02001          MOV      r2,#1
00011c  e3a01c02          MOV      r1,#0x200
000120  e3a00d06          MOV      r0,#0x180
000124  ebfffffe          BL       GPIO_OpenBit
;;;65         UART2SetRS232Power(FALSE);
000128  e3a00000          MOV      r0,#0
00012c  ebfffffe          BL       UART2SetRS232Power
;;;66         
;;;67         /* configure UART */
;;;68         param.uFreq = 12000000;
000130  e59f0178          LDR      r0,|L1.688|
000134  e59f1178          LDR      r1,|L1.692|
000138  e5810000          STR      r0,[r1,#0]  ; param
;;;69         param.uBaudRate = baudRate;
00013c  e2810000          ADD      r0,r1,#0
000140  e5805004          STR      r5,[r0,#4]  ; param
;;;70         param.ucUartNo = UART2;
000144  e3a00002          MOV      r0,#2
000148  e5c10008          STRB     r0,[r1,#8]  ; param
;;;71         param.ucDataBits = DATA_BITS_8;
00014c  e3a00003          MOV      r0,#3
000150  e5c10009          STRB     r0,[r1,#9]  ; param
;;;72         param.ucStopBits = STOP_BITS_1;
000154  e3a00000          MOV      r0,#0
000158  e5c1000a          STRB     r0,[r1,#0xa]  ; param
;;;73         param.ucParity = PARITY_NONE;
00015c  e5c1000b          STRB     r0,[r1,#0xb]  ; param
;;;74         param.ucRxTriggerLevel = UART_FCR_RFITL_1BYTE;
000160  e5c1000c          STRB     r0,[r1,#0xc]  ; param
;;;75         retval = uartOpen(&param);
000164  e2810000          ADD      r0,r1,#0
000168  ebfffffe          BL       uartOpen
00016c  e1a04000          MOV      r4,r0
;;;76         if(retval != 0) 
000170  e3540000          CMP      r4,#0
000174  0a000003          BEQ      |L1.392|
;;;77         {
;;;78             sysprintf("hwInit Open UART error!\n");
000178  e28f0f4e          ADR      r0,|L1.696|
00017c  ebfffffe          BL       sysprintf
;;;79             return FALSE;
000180  e3a00000          MOV      r0,#0
                  |L1.388|
;;;80         }
;;;81     
;;;82         /* set TX interrupt mode */
;;;83         retval = uartIoctl(param.ucUartNo, UART_IOC_SETTXMODE, UARTPOLLMODE /*UARTINTMODE*/ , 0);
;;;84         if (retval != 0) 
;;;85         {
;;;86             sysprintf("hwInit Set TX interrupt mode fail!\n");
;;;87             return FALSE;
;;;88         }
;;;89     
;;;90         /* set RX interrupt mode */
;;;91         retval = uartIoctl(param.ucUartNo, UART_IOC_SETRXMODE, UARTINTMODE, 0);
;;;92         if (retval != 0) 
;;;93         {
;;;94             sysprintf("hwInit Set RX interrupt mode fail!\n");
;;;95             return FALSE;
;;;96         }
;;;97         
;;;98         return TRUE;
;;;99     }
000184  e8bd8070          POP      {r4-r6,pc}
                  |L1.392|
000188  e59f1124          LDR      r1,|L1.692|
00018c  e5d10008          LDRB     r0,[r1,#8]            ;83  ; param
000190  e3a03000          MOV      r3,#0                 ;83
000194  e1a02003          MOV      r2,r3                 ;83
000198  e3a01001          MOV      r1,#1                 ;83
00019c  ebfffffe          BL       uartIoctl
0001a0  e1a04000          MOV      r4,r0                 ;83
0001a4  e3540000          CMP      r4,#0                 ;84
0001a8  0a000003          BEQ      |L1.444|
0001ac  e28f0e12          ADR      r0,|L1.724|
0001b0  ebfffffe          BL       sysprintf
0001b4  e3a00000          MOV      r0,#0                 ;87
0001b8  eafffff1          B        |L1.388|
                  |L1.444|
0001bc  e59f10f0          LDR      r1,|L1.692|
0001c0  e5d10008          LDRB     r0,[r1,#8]            ;91  ; param
0001c4  e3a03000          MOV      r3,#0                 ;91
0001c8  e3a02001          MOV      r2,#1                 ;91
0001cc  e3a01002          MOV      r1,#2                 ;91
0001d0  ebfffffe          BL       uartIoctl
0001d4  e1a04000          MOV      r4,r0                 ;91
0001d8  e3540000          CMP      r4,#0                 ;92
0001dc  0a000003          BEQ      |L1.496|
0001e0  e28f0e11          ADR      r0,|L1.760|
0001e4  ebfffffe          BL       sysprintf
0001e8  e3a00000          MOV      r0,#0                 ;95
0001ec  eaffffe4          B        |L1.388|
                  |L1.496|
0001f0  e3a00001          MOV      r0,#1                 ;98
0001f4  eaffffe2          B        |L1.388|
;;;100    #if(0)
                          ENDP

                  UART2DrvInit PROC
;;;142    /*-----------------------------------------*/
;;;143    BOOL UART2DrvInit(UINT32 baudRate)
0001f8  e92d4070          PUSH     {r4-r6,lr}
;;;144    {
0001fc  e1a05000          MOV      r5,r0
;;;145        int retval = TRUE;;
000200  e3a04001          MOV      r4,#1
;;;146        sysprintf("UART2DrvInit!!\n");
000204  e28f0e11          ADR      r0,|L1.796|
000208  ebfffffe          BL       sysprintf
;;;147        retval = hwInit(baudRate);
00020c  e1a00005          MOV      r0,r5
000210  ebfffffe          BL       hwInit
000214  e1a04000          MOV      r4,r0
;;;148        //xTaskCreate( vRxTask, "vRxTask", 1024, NULL, UART2_THREAD_PROI, NULL );
;;;149        return retval;
000218  e1a00004          MOV      r0,r4
;;;150    }
00021c  e8bd8070          POP      {r4-r6,pc}
;;;151    INT32 UART2Write(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART2Write PROC
000220  e92d4070          PUSH     {r4-r6,lr}
;;;152    {
000224  e1a04000          MOV      r4,r0
000228  e1a05001          MOV      r5,r1
;;;153        return uartWrite(param.ucUartNo, pucBuf, uLen);
00022c  e59f1080          LDR      r1,|L1.692|
000230  e5d10008          LDRB     r0,[r1,#8]  ; param
000234  e1a02005          MOV      r2,r5
000238  e1a01004          MOV      r1,r4
00023c  ebfffffe          BL       uartWrite
;;;154    }
000240  e8bd8070          POP      {r4-r6,pc}
;;;155    INT32 UART2Read(PUINT8 pucBuf, UINT32 uLen)
                          ENDP

                  UART2Read PROC
000244  e92d4070          PUSH     {r4-r6,lr}
;;;156    {
000248  e1a04000          MOV      r4,r0
00024c  e1a05001          MOV      r5,r1
;;;157        return uartRead(param.ucUartNo, pucBuf, uLen);
000250  e59f105c          LDR      r1,|L1.692|
000254  e5d10008          LDRB     r0,[r1,#8]  ; param
000258  e1a02005          MOV      r2,r5
00025c  e1a01004          MOV      r1,r4
000260  ebfffffe          BL       uartRead
;;;158    }
000264  e8bd8070          POP      {r4-r6,pc}
;;;159    BaseType_t UART2ReadWait(TickType_t time)
                          ENDP

                  UART2ReadWait PROC
000268  e92d4010          PUSH     {r4,lr}
;;;160    {
00026c  e1a04000          MOV      r4,r0
;;;161        return  uartWaitReadEvent(param.ucUartNo, time);
000270  e59f103c          LDR      r1,|L1.692|
000274  e5d10008          LDRB     r0,[r1,#8]  ; param
000278  e1a01004          MOV      r1,r4
00027c  ebfffffe          BL       uartWaitReadEvent
;;;162    }
000280  e8bd8010          POP      {r4,pc}
;;;163    
                          ENDP

                  UART2Ioctl PROC
;;;187    }
;;;188    INT UART2Ioctl(UINT32 uCmd, UINT32 uArg0, UINT32 uArg1)
000284  e92d4070          PUSH     {r4-r6,lr}
;;;189    {
000288  e1a04000          MOV      r4,r0
00028c  e1a05001          MOV      r5,r1
000290  e1a06002          MOV      r6,r2
;;;190        return uartIoctl(param.ucUartNo, uCmd, uArg0, uArg1);
000294  e59f1018          LDR      r1,|L1.692|
000298  e5d10008          LDRB     r0,[r1,#8]  ; param
00029c  e1a03006          MOV      r3,r6
0002a0  e1a02005          MOV      r2,r5
0002a4  e1a01004          MOV      r1,r4
0002a8  ebfffffe          BL       uartIoctl
;;;191    }
0002ac  e8bd8070          POP      {r4-r6,pc}
;;;192    
                          ENDP

                  |L1.688|
                          DCD      0x00b71b00
                  |L1.692|
                          DCD      param
                  |L1.696|
0002b8  6877496e          DCB      "hwInit Open UART error!\n",0
0002bc  6974204f
0002c0  70656e20
0002c4  55415254
0002c8  20657272
0002cc  6f72210a
0002d0  00      
0002d1  00                DCB      0
0002d2  00                DCB      0
0002d3  00                DCB      0
                  |L1.724|
0002d4  6877496e          DCB      "hwInit Set TX interrupt mode fail!\n",0
0002d8  69742053
0002dc  65742054
0002e0  5820696e
0002e4  74657272
0002e8  75707420
0002ec  6d6f6465
0002f0  20666169
0002f4  6c210a00
                  |L1.760|
0002f8  6877496e          DCB      "hwInit Set RX interrupt mode fail!\n",0
0002fc  69742053
000300  65742052
000304  5820696e
000308  74657272
00030c  75707420
000310  6d6f6465
000314  20666169
000318  6c210a00
                  |L1.796|
00031c  55415254          DCB      "UART2DrvInit!!\n",0
000320  32447276
000324  496e6974
000328  21210a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  param
                          %        16
