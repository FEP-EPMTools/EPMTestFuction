; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\obj\gpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\gpio.d --cpu=ARM926EJ-S --apcs=interwork -O0 -I.\src -I..\..\common\src\BSP\Driver\Include -I..\..\common\src\FreeRTOS -I..\..\common\src\FreeRTOS\Source\include -I..\..\common\src\FreeRTOS\Source\portable\RVDS\ARM926EJ-S -I..\..\common\src\BSP\ThirdParty\FATFS\src -I.\src\userdrv -I.\src\syshal -I.\src\user -I.\src\userdrv\vl53l0x\core\inc -I.\src\userdrv\vl53l0x\platform\inc -I.\src\syshal\json -I.\src\syshal\modemlib -I..\..\common\src\BSP\ThirdParty\yaffs2 -I..\..\common\src\BSP\ThirdParty\yaffs2\include -I..\..\common\src\BSP\ThirdParty\yaffs2\include\asm -I..\..\common\src\BSP\ThirdParty\yaffs2\include\linux -I.\src\syshal\yaffs2 -I..\..\common\src\BSP\Library\SmartcardLib\Include -I.\src\syshal\cardlib -I.\src\syshal\cardlog -I.\src\syshal\blk -I..\..\common\src\BSP\Library\USB_HOST\Inc -I..\..\common\src\BSP\Library\USB_HOST\Inc\usb_uvc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Toshiba -DEPM_PROJECT -DCONFIG_YAFFS_DIRECT -DCONFIG_YAFFS_SHORT_NAMES_IN_RAM -DCONFIG_YAFFS_YAFFS2 -DNO_Y_INLINE -DCONFIG_YAFFS_PROVIDE_DEFS -DCONFIG_YAFFSFS_PROVIDE_VALUES --omf_browse=.\obj\gpio.crf ..\..\common\src\BSP\Driver\Source\gpio.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler PROC
;;;36      */
;;;37     void GPIO_IRQHandler(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;38     {
;;;39         UINT32 reg;
;;;40         INT32 i,mask;
;;;41         reg = inpw(REG_AIC_ISRH);
000004  e59f0ba0          LDR      r0,|L1.2988|
000008  e5905114          LDR      r5,[r0,#0x114]
;;;42         mask = 0x02000000; /* INT56 */
00000c  e3a06402          MOV      r6,#0x2000000
;;;43         reg = inpw(REG_GPIO_ISR);
000010  e2800a01          ADD      r0,r0,#0x1000
000014  e59053fc          LDR      r5,[r0,#0x3fc]
;;;44         for(i=0; i<MAX_PORT; i++)
000018  e3a04000          MOV      r4,#0
00001c  ea00000f          B        |L1.96|
                  |L1.32|
;;;45             if( gpioCfg.IRQCallback[i] != NULL && (reg & (1<<i)) ) {
000020  e59f0b88          LDR      r0,|L1.2992|
000024  e7900104          LDR      r0,[r0,r4,LSL #2]
000028  e3500000          CMP      r0,#0
00002c  0a00000a          BEQ      |L1.92|
000030  e3a00001          MOV      r0,#1
000034  e1150410          TST      r5,r0,LSL r4
000038  0a000007          BEQ      |L1.92|
;;;46                 gpioCfg.IRQCallback[i](inpw(REG_GPIOA_ISR+i*0x40), gpioCfg.IRQUserData[i]);
00003c  e59f3b70          LDR      r3,|L1.2996|
000040  e7931104          LDR      r1,[r3,r4,LSL #2]
000044  e59f3b6c          LDR      r3,|L1.3000|
000048  e0833304          ADD      r3,r3,r4,LSL #6
00004c  e5930018          LDR      r0,[r3,#0x18]
000050  e59f3b58          LDR      r3,|L1.2992|
000054  e7932104          LDR      r2,[r3,r4,LSL #2]
000058  e12fff32          BLX      r2
                  |L1.92|
00005c  e2844001          ADD      r4,r4,#1              ;44
                  |L1.96|
000060  e354000a          CMP      r4,#0xa               ;44
000064  baffffed          BLT      |L1.32|
;;;47             }
;;;48         outpw(REG_AIC_SCCRH, mask);   /* Clear interrupt */
000068  e59f0b3c          LDR      r0,|L1.2988|
00006c  e580614c          STR      r6,[r0,#0x14c]
;;;49     }
000070  e8bd8070          POP      {r4-r6,pc}
;;;50     
                          ENDP

                  GPIO_IRQHandler0 PROC
                  |L1.116|
;;;55      */
;;;56     void GPIO_IRQHandler0(void)
000074  e92d4070          PUSH     {r4-r6,lr}
;;;57     {
;;;58         UINT32 reg;
;;;59         INT32 mask;
;;;60         reg = inpw(REG_AIC_ISR);
000078  e59f0b2c          LDR      r0,|L1.2988|
00007c  e5904110          LDR      r4,[r0,#0x110]
;;;61         mask = 0x10;
000080  e3a05010          MOV      r5,#0x10
;;;62         if(gpioCfg.EINTIRQCallback[0] != NULL) {
000084  e59f0b30          LDR      r0,|L1.3004|
000088  e5900064          LDR      r0,[r0,#0x64]  ; gpioCfg
00008c  e3500000          CMP      r0,#0
000090  0a000004          BEQ      |L1.168|
;;;63             gpioCfg.EINTIRQCallback[0](reg, gpioCfg.EINTIRQUserData[0]);
000094  e59f0b20          LDR      r0,|L1.3004|
000098  e5901084          LDR      r1,[r0,#0x84]  ; gpioCfg
00009c  e5902064          LDR      r2,[r0,#0x64]  ; gpioCfg
0000a0  e1a00004          MOV      r0,r4
0000a4  e12fff32          BLX      r2
                  |L1.168|
;;;64         }
;;;65         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
0000a8  e59f0afc          LDR      r0,|L1.2988|
0000ac  e5805148          STR      r5,[r0,#0x148]
;;;66     }
0000b0  e8bd8070          POP      {r4-r6,pc}
;;;67     
                          ENDP

                  GPIO_IRQHandler1 PROC
                  |L1.180|
;;;72      */
;;;73     void GPIO_IRQHandler1(void)
0000b4  e92d4070          PUSH     {r4-r6,lr}
;;;74     {
;;;75         UINT32 reg;
;;;76         INT32 mask;
;;;77         reg = inpw(REG_AIC_ISR);
0000b8  e59f0aec          LDR      r0,|L1.2988|
0000bc  e5904110          LDR      r4,[r0,#0x110]
;;;78         mask = 0x20;
0000c0  e3a05020          MOV      r5,#0x20
;;;79         //terninalPrintf("touch\r\n");
;;;80         if(gpioCfg.EINTIRQCallback[1] != NULL) {
0000c4  e59f0af0          LDR      r0,|L1.3004|
0000c8  e5900068          LDR      r0,[r0,#0x68]
0000cc  e3500000          CMP      r0,#0
0000d0  0a000004          BEQ      |L1.232|
;;;81             gpioCfg.EINTIRQCallback[1](reg, gpioCfg.EINTIRQUserData[1]);
0000d4  e59f0ae0          LDR      r0,|L1.3004|
0000d8  e5901088          LDR      r1,[r0,#0x88]
0000dc  e5902068          LDR      r2,[r0,#0x68]
0000e0  e1a00004          MOV      r0,r4
0000e4  e12fff32          BLX      r2
                  |L1.232|
;;;82         }
;;;83         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
0000e8  e59f0abc          LDR      r0,|L1.2988|
0000ec  e5805148          STR      r5,[r0,#0x148]
;;;84     }
0000f0  e8bd8070          POP      {r4-r6,pc}
;;;85     
                          ENDP

                  GPIO_IRQHandler2 PROC
                  |L1.244|
;;;90      */
;;;91     void GPIO_IRQHandler2(void)
0000f4  e92d4070          PUSH     {r4-r6,lr}
;;;92     {
;;;93         UINT32 reg;
;;;94         INT32 mask;
;;;95         reg = inpw(REG_AIC_ISR);
0000f8  e59f0aac          LDR      r0,|L1.2988|
0000fc  e5904110          LDR      r4,[r0,#0x110]
;;;96         mask = 0x40;
000100  e3a05040          MOV      r5,#0x40
;;;97         if(gpioCfg.EINTIRQCallback[2] != NULL) {
000104  e59f0ab0          LDR      r0,|L1.3004|
000108  e590006c          LDR      r0,[r0,#0x6c]
00010c  e3500000          CMP      r0,#0
000110  0a000004          BEQ      |L1.296|
;;;98             gpioCfg.EINTIRQCallback[2](reg, gpioCfg.EINTIRQUserData[2]);
000114  e59f0aa0          LDR      r0,|L1.3004|
000118  e590108c          LDR      r1,[r0,#0x8c]
00011c  e590206c          LDR      r2,[r0,#0x6c]
000120  e1a00004          MOV      r0,r4
000124  e12fff32          BLX      r2
                  |L1.296|
;;;99         }
;;;100        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000128  e59f0a7c          LDR      r0,|L1.2988|
00012c  e5805148          STR      r5,[r0,#0x148]
;;;101    }
000130  e8bd8070          POP      {r4-r6,pc}
;;;102    
                          ENDP

                  GPIO_IRQHandler3 PROC
                  |L1.308|
;;;107     */
;;;108    void GPIO_IRQHandler3(void)
000134  e92d4070          PUSH     {r4-r6,lr}
;;;109    {
;;;110        UINT32 reg;
;;;111        INT32 mask;
;;;112        reg = inpw(REG_AIC_ISR);
000138  e59f0a6c          LDR      r0,|L1.2988|
00013c  e5904110          LDR      r4,[r0,#0x110]
;;;113        mask = 0x80;
000140  e3a05080          MOV      r5,#0x80
;;;114        if(gpioCfg.EINTIRQCallback[3] != NULL) {
000144  e59f0a70          LDR      r0,|L1.3004|
000148  e5900070          LDR      r0,[r0,#0x70]
00014c  e3500000          CMP      r0,#0
000150  0a000004          BEQ      |L1.360|
;;;115            gpioCfg.EINTIRQCallback[3](reg, gpioCfg.EINTIRQUserData[3]);
000154  e59f0a60          LDR      r0,|L1.3004|
000158  e5901090          LDR      r1,[r0,#0x90]
00015c  e5902070          LDR      r2,[r0,#0x70]
000160  e1a00004          MOV      r0,r4
000164  e12fff32          BLX      r2
                  |L1.360|
;;;116        }
;;;117        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000168  e59f0a3c          LDR      r0,|L1.2988|
00016c  e5805148          STR      r5,[r0,#0x148]
;;;118    }
000170  e8bd8070          POP      {r4-r6,pc}
;;;119    
                          ENDP

                  GPIO_IRQHandler4 PROC
                  |L1.372|
;;;124     */
;;;125    void GPIO_IRQHandler4(void)
000174  e92d4070          PUSH     {r4-r6,lr}
;;;126    {
;;;127        UINT32 reg;
;;;128        INT32 mask;
;;;129        reg = inpw(REG_AIC_ISR);
000178  e59f0a2c          LDR      r0,|L1.2988|
00017c  e5904110          LDR      r4,[r0,#0x110]
;;;130        mask = 0x100;
000180  e3a05c01          MOV      r5,#0x100
;;;131        if(gpioCfg.EINTIRQCallback[4] != NULL) {
000184  e59f0a30          LDR      r0,|L1.3004|
000188  e5900074          LDR      r0,[r0,#0x74]
00018c  e3500000          CMP      r0,#0
000190  0a000004          BEQ      |L1.424|
;;;132            gpioCfg.EINTIRQCallback[4](reg, gpioCfg.EINTIRQUserData[4]);
000194  e59f0a20          LDR      r0,|L1.3004|
000198  e5901094          LDR      r1,[r0,#0x94]
00019c  e5902074          LDR      r2,[r0,#0x74]
0001a0  e1a00004          MOV      r0,r4
0001a4  e12fff32          BLX      r2
                  |L1.424|
;;;133        }
;;;134        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
0001a8  e59f09fc          LDR      r0,|L1.2988|
0001ac  e5805148          STR      r5,[r0,#0x148]
;;;135    }
0001b0  e8bd8070          POP      {r4-r6,pc}
;;;136    
                          ENDP

                  GPIO_IRQHandler5 PROC
                  |L1.436|
;;;141     */
;;;142    void GPIO_IRQHandler5(void)
0001b4  e92d4070          PUSH     {r4-r6,lr}
;;;143    {
;;;144        UINT32 reg;
;;;145        INT32 mask;
;;;146        reg = inpw(REG_AIC_ISR);
0001b8  e59f09ec          LDR      r0,|L1.2988|
0001bc  e5904110          LDR      r4,[r0,#0x110]
;;;147        mask = 0x200;
0001c0  e3a05c02          MOV      r5,#0x200
;;;148        if(gpioCfg.EINTIRQCallback[5] != NULL) {
0001c4  e59f09f0          LDR      r0,|L1.3004|
0001c8  e5900078          LDR      r0,[r0,#0x78]
0001cc  e3500000          CMP      r0,#0
0001d0  0a000004          BEQ      |L1.488|
;;;149            gpioCfg.EINTIRQCallback[5](reg, gpioCfg.EINTIRQUserData[5]);
0001d4  e59f09e0          LDR      r0,|L1.3004|
0001d8  e5901098          LDR      r1,[r0,#0x98]
0001dc  e5902078          LDR      r2,[r0,#0x78]
0001e0  e1a00004          MOV      r0,r4
0001e4  e12fff32          BLX      r2
                  |L1.488|
;;;150        }
;;;151        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
0001e8  e59f09bc          LDR      r0,|L1.2988|
0001ec  e5805148          STR      r5,[r0,#0x148]
;;;152    }
0001f0  e8bd8070          POP      {r4-r6,pc}
;;;153    
                          ENDP

                  GPIO_IRQHandler6 PROC
                  |L1.500|
;;;158     */
;;;159    void GPIO_IRQHandler6(void)
0001f4  e92d4070          PUSH     {r4-r6,lr}
;;;160    {
;;;161        UINT32 reg;
;;;162        INT32 mask;
;;;163        reg = inpw(REG_AIC_ISR);
0001f8  e59f09ac          LDR      r0,|L1.2988|
0001fc  e5904110          LDR      r4,[r0,#0x110]
;;;164        mask = 0x400;
000200  e3a05b01          MOV      r5,#0x400
;;;165        if(gpioCfg.EINTIRQCallback[6] != NULL) {
000204  e59f09b0          LDR      r0,|L1.3004|
000208  e590007c          LDR      r0,[r0,#0x7c]
00020c  e3500000          CMP      r0,#0
000210  0a000004          BEQ      |L1.552|
;;;166            gpioCfg.EINTIRQCallback[6](reg, gpioCfg.EINTIRQUserData[6]);
000214  e59f09a0          LDR      r0,|L1.3004|
000218  e590109c          LDR      r1,[r0,#0x9c]
00021c  e590207c          LDR      r2,[r0,#0x7c]
000220  e1a00004          MOV      r0,r4
000224  e12fff32          BLX      r2
                  |L1.552|
;;;167        }
;;;168        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000228  e59f097c          LDR      r0,|L1.2988|
00022c  e5805148          STR      r5,[r0,#0x148]
;;;169    }
000230  e8bd8070          POP      {r4-r6,pc}
;;;170    
                          ENDP

                  GPIO_IRQHandler7 PROC
                  |L1.564|
;;;175     */
;;;176    void GPIO_IRQHandler7(void)
000234  e92d4070          PUSH     {r4-r6,lr}
;;;177    {
;;;178        UINT32 reg;
;;;179        INT32 mask;
;;;180        reg = inpw(REG_AIC_ISR);
000238  e59f096c          LDR      r0,|L1.2988|
00023c  e5904110          LDR      r4,[r0,#0x110]
;;;181        mask = 0x800;
000240  e3a05b02          MOV      r5,#0x800
;;;182        if(gpioCfg.EINTIRQCallback[7] != NULL) {
000244  e59f0970          LDR      r0,|L1.3004|
000248  e5900080          LDR      r0,[r0,#0x80]
00024c  e3500000          CMP      r0,#0
000250  0a000004          BEQ      |L1.616|
;;;183            gpioCfg.EINTIRQCallback[7](reg, gpioCfg.EINTIRQUserData[7]);
000254  e59f0960          LDR      r0,|L1.3004|
000258  e59010a0          LDR      r1,[r0,#0xa0]
00025c  e5902080          LDR      r2,[r0,#0x80]
000260  e1a00004          MOV      r0,r4
000264  e12fff32          BLX      r2
                  |L1.616|
;;;184        }
;;;185        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000268  e59f093c          LDR      r0,|L1.2988|
00026c  e5805148          STR      r5,[r0,#0x148]
;;;186    }
000270  e8bd8070          POP      {r4-r6,pc}
;;;187    
                          ENDP

                  GPIO_Open PROC
;;;199     */
;;;200    INT32 GPIO_Open(GPIO_PORT port, GPIO_DIR direction, GPIO_PULL pull)
000274  e92d4070          PUSH     {r4-r6,lr}
;;;201    {
000278  e1a03000          MOV      r3,r0
00027c  e1a04001          MOV      r4,r1
000280  e1a05002          MOV      r5,r2
;;;202        UINT32 mask;
;;;203        INT32 portIndex;
;;;204        INT32 offset;
;;;205    
;;;206        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000284  e3a0020b          MOV      r0,#0xb0000000
000288  e5900218          LDR      r0,[r0,#0x218]
00028c  e3800008          ORR      r0,r0,#8
000290  e3a0620b          MOV      r6,#0xb0000000
000294  e5860218          STR      r0,[r6,#0x218]
;;;207        offset = (INT32)port;
000298  e1a01003          MOV      r1,r3
;;;208        portIndex = port / 0x40;
00029c  e1a00003          MOV      r0,r3
0002a0  e1a06fc3          ASR      r6,r3,#31
0002a4  e0836d26          ADD      r6,r3,r6,LSR #26
0002a8  e1a0c346          ASR      r12,r6,#6
;;;209        mask = maskTbl[portIndex];
0002ac  e59f090c          LDR      r0,|L1.3008|
0002b0  e790210c          LDR      r2,[r0,r12,LSL #2]
;;;210    
;;;211        if(gpioCfg.bitBusyFlag[portIndex] != 0) {
0002b4  e59f0900          LDR      r0,|L1.3004|
0002b8  e080008c          ADD      r0,r0,r12,LSL #1
0002bc  e1d000b0          LDRH     r0,[r0,#0]
0002c0  e3500000          CMP      r0,#0
0002c4  0a000001          BEQ      |L1.720|
;;;212            return GPIO_ERR_PORT_BUSY;
0002c8  e3e00000          MVN      r0,#0
                  |L1.716|
;;;213        }
;;;214    
;;;215        /* Set all bits in the port to busy */
;;;216        gpioCfg.bitBusyFlag[portIndex] = mask;
;;;217    
;;;218        /* Set port direction */
;;;219        if(direction == DIR_OUTPUT) {
;;;220            outpw(REG_GPIOA_DIR + offset , mask);
;;;221        } else {
;;;222            outpw(REG_GPIOA_DIR + offset , 0);
;;;223        }
;;;224    
;;;225        if(pull == PULL_UP) {
;;;226            outpw(REG_GPIOA_PUEN + offset , mask);
;;;227        } else {
;;;228            outpw(REG_GPIOA_PUEN + offset , 0);
;;;229        }
;;;230    
;;;231        return SUCCESSFUL;
;;;232    }
0002cc  e8bd8070          POP      {r4-r6,pc}
                  |L1.720|
0002d0  e59f68e4          LDR      r6,|L1.3004|
0002d4  e086608c          ADD      r6,r6,r12,LSL #1      ;216
0002d8  e1c620b0          STRH     r2,[r6,#0]            ;216
0002dc  e3540001          CMP      r4,#1                 ;219
0002e0  1a000002          BNE      |L1.752|
0002e4  e59f08cc          LDR      r0,|L1.3000|
0002e8  e7812000          STR      r2,[r1,r0]            ;220
0002ec  ea000002          B        |L1.764|
                  |L1.752|
0002f0  e3a00000          MOV      r0,#0                 ;222
0002f4  e59f68bc          LDR      r6,|L1.3000|
0002f8  e7810006          STR      r0,[r1,r6]            ;222
                  |L1.764|
0002fc  e3550001          CMP      r5,#1                 ;225
000300  1a000003          BNE      |L1.788|
000304  e59f08ac          LDR      r0,|L1.3000|
000308  e0800001          ADD      r0,r0,r1              ;226
00030c  e5802020          STR      r2,[r0,#0x20]         ;226
000310  ea000003          B        |L1.804|
                  |L1.788|
000314  e3a00000          MOV      r0,#0                 ;228
000318  e59f6898          LDR      r6,|L1.3000|
00031c  e0866001          ADD      r6,r6,r1              ;228
000320  e5860020          STR      r0,[r6,#0x20]         ;228
                  |L1.804|
000324  e3a00000          MOV      r0,#0                 ;231
000328  eaffffe7          B        |L1.716|
;;;233    
                          ENDP

                  GPIO_Close PROC
;;;243     */
;;;244    INT32 GPIO_Close(GPIO_PORT port)
00032c  e1a01000          MOV      r1,r0
;;;245    {
;;;246        INT32 offset;
;;;247        INT32 portIndex;
;;;248    
;;;249        offset = (INT32)port;
000330  e1a02001          MOV      r2,r1
;;;250        portIndex = (port / 0x40);
000334  e1a00001          MOV      r0,r1
000338  e1a0cfc1          ASR      r12,r1,#31
00033c  e081cd2c          ADD      r12,r1,r12,LSR #26
000340  e1a0334c          ASR      r3,r12,#6
;;;251    
;;;252        /* Clean the busy flag */
;;;253        gpioCfg.bitBusyFlag[portIndex] = 0;
000344  e3a00000          MOV      r0,#0
000348  e59fc86c          LDR      r12,|L1.3004|
00034c  e08cc083          ADD      r12,r12,r3,LSL #1
000350  e1cc00b0          STRH     r0,[r12,#0]
;;;254    
;;;255        /* Reset to input */
;;;256        outpw(REG_GPIOA_DIR + offset, 0);
000354  e59fc85c          LDR      r12,|L1.3000|
000358  e782000c          STR      r0,[r2,r12]
;;;257    
;;;258        /* Reset to pull-up */
;;;259        outpw(REG_GPIOA_PUEN + offset, 0);
00035c  e08cc002          ADD      r12,r12,r2
000360  e58c0020          STR      r0,[r12,#0x20]
;;;260    
;;;261        return SUCCESSFUL;
;;;262    }
000364  e12fff1e          BX       lr
;;;263    
                          ENDP

                  GPIO_Set PROC
;;;274     */
;;;275    INT32 GPIO_Set(GPIO_PORT port, UINT32 bitMap)
000368  e1a02000          MOV      r2,r0
;;;276    {
;;;277        INT32 offset;
;;;278        INT32 reg;
;;;279    
;;;280        offset = (INT32)port;
00036c  e1a0c002          MOV      r12,r2
;;;281    
;;;282        reg = inpw(REG_GPIOA_DATAOUT + offset);
000370  e59f0840          LDR      r0,|L1.3000|
000374  e080000c          ADD      r0,r0,r12
000378  e5903004          LDR      r3,[r0,#4]
;;;283        reg = reg | bitMap;
00037c  e1833001          ORR      r3,r3,r1
;;;284        outpw(REG_GPIOA_DATAOUT + offset, reg);
000380  e59f0830          LDR      r0,|L1.3000|
000384  e080000c          ADD      r0,r0,r12
000388  e5803004          STR      r3,[r0,#4]
;;;285    
;;;286        return SUCCESSFUL;
00038c  e3a00000          MOV      r0,#0
;;;287    }
000390  e12fff1e          BX       lr
;;;288    
                          ENDP

                  GPIO_Clr PROC
;;;299    */
;;;300    INT32 GPIO_Clr(GPIO_PORT port, UINT32 bitMap)
000394  e1a02000          MOV      r2,r0
;;;301    {
;;;302        INT32 offset;
;;;303        INT32 reg;
;;;304    
;;;305        offset = (INT32)port;
000398  e1a0c002          MOV      r12,r2
;;;306    
;;;307        reg = inpw(REG_GPIOA_DATAOUT + offset);
00039c  e59f0814          LDR      r0,|L1.3000|
0003a0  e080000c          ADD      r0,r0,r12
0003a4  e5903004          LDR      r3,[r0,#4]
;;;308        reg = reg & (~bitMap);
0003a8  e1c33001          BIC      r3,r3,r1
;;;309        outpw(REG_GPIOA_DATAOUT + offset, reg);
0003ac  e59f0804          LDR      r0,|L1.3000|
0003b0  e080000c          ADD      r0,r0,r12
0003b4  e5803004          STR      r3,[r0,#4]
;;;310    
;;;311        return SUCCESSFUL;
0003b8  e3a00000          MOV      r0,#0
;;;312    }
0003bc  e12fff1e          BX       lr
;;;313    
                          ENDP

                  GPIO_ReadPort PROC
;;;323    */
;;;324    UINT32 GPIO_ReadPort(GPIO_PORT port)
0003c0  e1a01000          MOV      r1,r0
;;;325    {
;;;326        UINT32 reg;
;;;327        INT32 offset;
;;;328    
;;;329        offset = (INT32)port;
0003c4  e1a02001          MOV      r2,r1
;;;330    
;;;331        reg = inpw(REG_GPIOA_DATAIN + offset);
0003c8  e59f37e8          LDR      r3,|L1.3000|
0003cc  e0833002          ADD      r3,r3,r2
0003d0  e5930008          LDR      r0,[r3,#8]
;;;332    
;;;333        return reg;
;;;334    }
0003d4  e12fff1e          BX       lr
;;;335    
                          ENDP

                  GPIO_SetPortDir PROC
;;;345    */
;;;346    INT32 GPIO_SetPortDir(GPIO_PORT port, GPIO_DIR direction)
0003d8  e92d4030          PUSH     {r4,r5,lr}
;;;347    {
0003dc  e1a02000          MOV      r2,r0
0003e0  e1a03001          MOV      r3,r1
;;;348        INT32 offset;
;;;349        INT32 mask;
;;;350        INT32 portIndex;
;;;351    
;;;352        offset = (INT32)port;
0003e4  e1a01002          MOV      r1,r2
;;;353        portIndex = (port / 0x40);
0003e8  e1a00002          MOV      r0,r2
0003ec  e1a05fc2          ASR      r5,r2,#31
0003f0  e0825d25          ADD      r5,r2,r5,LSR #26
0003f4  e1a04345          ASR      r4,r5,#6
;;;354        mask = maskTbl[portIndex];
0003f8  e59f07c0          LDR      r0,|L1.3008|
0003fc  e790c104          LDR      r12,[r0,r4,LSL #2]
;;;355    
;;;356        if(direction == DIR_OUTPUT) {
000400  e3530001          CMP      r3,#1
000404  1a000002          BNE      |L1.1044|
;;;357            outpw(REG_GPIOA_DIR + offset, mask);
000408  e59f07a8          LDR      r0,|L1.3000|
00040c  e781c000          STR      r12,[r1,r0]
000410  ea000002          B        |L1.1056|
                  |L1.1044|
;;;358        } else {
;;;359            outpw(REG_GPIOA_DIR + offset, 0x0);
000414  e3a00000          MOV      r0,#0
000418  e59f5798          LDR      r5,|L1.3000|
00041c  e7810005          STR      r0,[r1,r5]
                  |L1.1056|
;;;360        }
;;;361    
;;;362        return SUCCESSFUL;
000420  e3a00000          MOV      r0,#0
;;;363    }
000424  e8bd8030          POP      {r4,r5,pc}
;;;364    
                          ENDP

                  GPIO_OpenBit PROC
;;;377     */
;;;378    INT32 GPIO_OpenBit(GPIO_PORT port, UINT32 bit, GPIO_DIR direction, GPIO_PULL pull)
000428  e92d41f0          PUSH     {r4-r8,lr}
;;;379    {
00042c  e1a0c000          MOV      r12,r0
000430  e1a04001          MOV      r4,r1
000434  e1a06002          MOV      r6,r2
000438  e1a07003          MOV      r7,r3
;;;380        UINT32 reg;
;;;381        UINT32 mask;
;;;382        INT32 portIndex;
;;;383        INT32 offset;
;;;384    
;;;385        offset = (INT32)port;
00043c  e1a0100c          MOV      r1,r12
;;;386        portIndex = (port / 0x040);
000440  e1a0000c          MOV      r0,r12
000444  e1a08fcc          ASR      r8,r12,#31
000448  e08c8d28          ADD      r8,r12,r8,LSR #26
00044c  e1a05348          ASR      r5,r8,#6
;;;387        mask = (UINT32)bit;
000450  e1a03004          MOV      r3,r4
;;;388    
;;;389        if((gpioCfg.bitBusyFlag[portIndex]&mask) != 0) {
000454  e59f0760          LDR      r0,|L1.3004|
000458  e0800085          ADD      r0,r0,r5,LSL #1
00045c  e1d000b0          LDRH     r0,[r0,#0]
000460  e1100003          TST      r0,r3
000464  0a000001          BEQ      |L1.1136|
;;;390            return GPIO_ERR_BIT_BUSY;
000468  e3e00002          MVN      r0,#2
                  |L1.1132|
;;;391        }
;;;392    
;;;393        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] | mask;
;;;394    
;;;395        reg = inpw(REG_GPIOA_DIR + offset);
;;;396        reg = reg & (~mask);
;;;397    
;;;398        if(direction == DIR_OUTPUT) {
;;;399            reg = reg | mask;
;;;400        }
;;;401    
;;;402        outpw(REG_GPIOA_DIR + offset, reg);
;;;403    
;;;404        reg = inpw(REG_GPIOA_PUEN + offset);
;;;405        reg = reg & (~mask);
;;;406    
;;;407        if(pull == PULL_UP) {
;;;408            reg = reg | mask;
;;;409        }
;;;410    
;;;411        outpw(REG_GPIOA_PUEN + offset, reg);
;;;412    
;;;413        return SUCCESSFUL;
;;;414    }
00046c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1136|
000470  e59f0744          LDR      r0,|L1.3004|
000474  e0800085          ADD      r0,r0,r5,LSL #1       ;393
000478  e1d000b0          LDRH     r0,[r0,#0]            ;393
00047c  e1800003          ORR      r0,r0,r3              ;393
000480  e59f8734          LDR      r8,|L1.3004|
000484  e0888085          ADD      r8,r8,r5,LSL #1       ;393
000488  e1c800b0          STRH     r0,[r8,#0]            ;393
00048c  e59f0724          LDR      r0,|L1.3000|
000490  e7912000          LDR      r2,[r1,r0]            ;395
000494  e1c22003          BIC      r2,r2,r3              ;396
000498  e3560001          CMP      r6,#1                 ;398
00049c  1a000000          BNE      |L1.1188|
0004a0  e1822003          ORR      r2,r2,r3              ;399
                  |L1.1188|
0004a4  e59f070c          LDR      r0,|L1.3000|
0004a8  e7812000          STR      r2,[r1,r0]            ;402
0004ac  e0800001          ADD      r0,r0,r1              ;404
0004b0  e5902020          LDR      r2,[r0,#0x20]         ;404
0004b4  e1c22003          BIC      r2,r2,r3              ;405
0004b8  e3570001          CMP      r7,#1                 ;407
0004bc  1a000000          BNE      |L1.1220|
0004c0  e1822003          ORR      r2,r2,r3              ;408
                  |L1.1220|
0004c4  e59f06ec          LDR      r0,|L1.3000|
0004c8  e0800001          ADD      r0,r0,r1              ;411
0004cc  e5802020          STR      r2,[r0,#0x20]         ;411
0004d0  e3a00000          MOV      r0,#0                 ;413
0004d4  eaffffe4          B        |L1.1132|
;;;415    
                          ENDP

                  GPIO_CloseBit PROC
;;;426    */
;;;427    INT32 GPIO_CloseBit(GPIO_PORT port, UINT32 bit)
0004d8  e92d4070          PUSH     {r4-r6,lr}
;;;428    {
0004dc  e1a02000          MOV      r2,r0
0004e0  e1a03001          MOV      r3,r1
;;;429        UINT32 reg;
;;;430        UINT32 mask;
;;;431        INT32 portIndex;
;;;432        INT32 offset;
;;;433    
;;;434        offset = (INT32)port;
0004e4  e1a01002          MOV      r1,r2
;;;435        portIndex = (port / 0x40);
0004e8  e1a00002          MOV      r0,r2
0004ec  e1a06fc2          ASR      r6,r2,#31
0004f0  e0826d26          ADD      r6,r2,r6,LSR #26
0004f4  e1a05346          ASR      r5,r6,#6
;;;436        mask = (UINT32)bit;
0004f8  e1a04003          MOV      r4,r3
;;;437    
;;;438        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] & (~mask);
0004fc  e59f06b8          LDR      r0,|L1.3004|
000500  e0800085          ADD      r0,r0,r5,LSL #1
000504  e1d000b0          LDRH     r0,[r0,#0]
000508  e1c00004          BIC      r0,r0,r4
00050c  e59f66a8          LDR      r6,|L1.3004|
000510  e0866085          ADD      r6,r6,r5,LSL #1
000514  e1c600b0          STRH     r0,[r6,#0]
;;;439    
;;;440        reg = inpw(REG_GPIOA_DIR + offset);
000518  e59f0698          LDR      r0,|L1.3000|
00051c  e791c000          LDR      r12,[r1,r0]
;;;441        reg = reg & (~mask);
000520  e1ccc004          BIC      r12,r12,r4
;;;442        outpw(REG_GPIOA_DIR + offset, reg);
000524  e781c000          STR      r12,[r1,r0]
;;;443    
;;;444        reg = inpw(REG_GPIOA_PUEN + offset);
000528  e0800001          ADD      r0,r0,r1
00052c  e590c020          LDR      r12,[r0,#0x20]
;;;445        reg = reg & (~mask);
000530  e1ccc004          BIC      r12,r12,r4
;;;446        outpw(REG_GPIOA_PUEN + offset, reg);
000534  e59f067c          LDR      r0,|L1.3000|
000538  e0800001          ADD      r0,r0,r1
00053c  e580c020          STR      r12,[r0,#0x20]
;;;447    
;;;448        return SUCCESSFUL;
000540  e3a00000          MOV      r0,#0
;;;449    }
000544  e8bd8070          POP      {r4-r6,pc}
;;;450    
                          ENDP

                  GPIO_SetBit PROC
;;;462     */
;;;463    INT32 GPIO_SetBit(GPIO_PORT port, UINT32 bit)
000548  e92d4010          PUSH     {r4,lr}
;;;464    {
00054c  e1a02000          MOV      r2,r0
;;;465        UINT32 bitMap;
;;;466        INT32 offset;
;;;467        INT32 reg;
;;;468    
;;;469        offset = (INT32)port;
000550  e1a03002          MOV      r3,r2
;;;470        bitMap = (UINT32)bit;
000554  e1a04001          MOV      r4,r1
;;;471    
;;;472        reg = inpw(REG_GPIOA_DATAOUT + offset);
000558  e59f0658          LDR      r0,|L1.3000|
00055c  e0800003          ADD      r0,r0,r3
000560  e590c004          LDR      r12,[r0,#4]
;;;473        reg = reg | bitMap;
000564  e18cc004          ORR      r12,r12,r4
;;;474        outpw(REG_GPIOA_DATAOUT + offset, reg);
000568  e59f0648          LDR      r0,|L1.3000|
00056c  e0800003          ADD      r0,r0,r3
000570  e580c004          STR      r12,[r0,#4]
;;;475    
;;;476        return SUCCESSFUL;
000574  e3a00000          MOV      r0,#0
;;;477    }
000578  e8bd8010          POP      {r4,pc}
;;;478    
                          ENDP

                  GPIO_ClrISR PROC
;;;489    */
;;;490    INT32 GPIO_ClrISR(GPIO_PORT port, UINT32 bitMap)
00057c  e1a02000          MOV      r2,r0
;;;491    {
;;;492        INT32 offset;
;;;493    
;;;494        offset = (INT32)port;
000580  e1a03002          MOV      r3,r2
;;;495    
;;;496        outpw(REG_GPIOA_ISR + offset, bitMap);
000584  e59f062c          LDR      r0,|L1.3000|
000588  e0800003          ADD      r0,r0,r3
00058c  e5801018          STR      r1,[r0,#0x18]
;;;497    
;;;498        return SUCCESSFUL;
000590  e3a00000          MOV      r0,#0
;;;499    }
000594  e12fff1e          BX       lr
;;;500    
                          ENDP

                  GPIO_ClrISRBit PROC
;;;511     */
;;;512    INT32 GPIO_ClrISRBit(GPIO_PORT port, UINT32 bit)
000598  e1a02000          MOV      r2,r0
;;;513    {
;;;514        UINT32 bitMap;
;;;515        INT32 offset;
;;;516    
;;;517        offset = (INT32)port;
00059c  e1a03002          MOV      r3,r2
;;;518        bitMap = (UINT32)bit;
0005a0  e1a0c001          MOV      r12,r1
;;;519    
;;;520        outpw(REG_GPIOA_ISR + offset, bitMap);
0005a4  e59f060c          LDR      r0,|L1.3000|
0005a8  e0800003          ADD      r0,r0,r3
0005ac  e580c018          STR      r12,[r0,#0x18]
;;;521    
;;;522        return SUCCESSFUL;
0005b0  e3a00000          MOV      r0,#0
;;;523    }
0005b4  e12fff1e          BX       lr
;;;524    
                          ENDP

                  GPIO_ClrBit PROC
;;;535    */
;;;536    INT32 GPIO_ClrBit(GPIO_PORT port, UINT32 bit)
0005b8  e92d4010          PUSH     {r4,lr}
;;;537    {
0005bc  e1a02000          MOV      r2,r0
;;;538        UINT32 bitMap;
;;;539        INT32 offset;
;;;540        INT32 reg;
;;;541    
;;;542        offset = (INT32)port;
0005c0  e1a03002          MOV      r3,r2
;;;543        bitMap = (UINT32)bit;
0005c4  e1a04001          MOV      r4,r1
;;;544    
;;;545        reg = inpw(REG_GPIOA_DATAOUT + offset);
0005c8  e59f05e8          LDR      r0,|L1.3000|
0005cc  e0800003          ADD      r0,r0,r3
0005d0  e590c004          LDR      r12,[r0,#4]
;;;546        reg = reg & (~bitMap);
0005d4  e1ccc004          BIC      r12,r12,r4
;;;547        outpw(REG_GPIOA_DATAOUT + offset, reg);
0005d8  e59f05d8          LDR      r0,|L1.3000|
0005dc  e0800003          ADD      r0,r0,r3
0005e0  e580c004          STR      r12,[r0,#4]
;;;548    
;;;549        return SUCCESSFUL;
0005e4  e3a00000          MOV      r0,#0
;;;550    }
0005e8  e8bd8010          POP      {r4,pc}
;;;551    
                          ENDP

                  GPIO_ReadBit PROC
;;;561    */
;;;562    INT32 GPIO_ReadBit(GPIO_PORT port, UINT32 bit)
0005ec  e92d4010          PUSH     {r4,lr}
;;;563    {
0005f0  e1a02000          MOV      r2,r0
;;;564        UINT32 reg;
;;;565        UINT32 bitMap;
;;;566        INT32 offset;
;;;567    
;;;568        offset = (INT32)port;
0005f4  e1a0c002          MOV      r12,r2
;;;569        bitMap = (UINT32)bit;
0005f8  e1a04001          MOV      r4,r1
;;;570    
;;;571        reg = inpw(REG_GPIOA_DATAIN + offset);
0005fc  e59f05b4          LDR      r0,|L1.3000|
000600  e080000c          ADD      r0,r0,r12
000604  e5903008          LDR      r3,[r0,#8]
;;;572    
;;;573        return ((reg & bitMap)?1:0);
000608  e1130004          TST      r3,r4
00060c  0a000001          BEQ      |L1.1560|
000610  e3a00001          MOV      r0,#1
                  |L1.1556|
;;;574    }
000614  e8bd8010          POP      {r4,pc}
                  |L1.1560|
000618  e3a00000          MOV      r0,#0                 ;573
00061c  eafffffc          B        |L1.1556|
;;;575    
                          ENDP

                  GPIO_SetBitDir PROC
;;;587    */
;;;588    INT32 GPIO_SetBitDir(GPIO_PORT port, UINT32 bit, GPIO_DIR direction)
000620  e92d4030          PUSH     {r4,r5,lr}
;;;589    {
000624  e1a03000          MOV      r3,r0
000628  e1a0c002          MOV      r12,r2
;;;590        UINT32 reg;
;;;591        UINT32 bitMap;
;;;592        INT32 offset;
;;;593    
;;;594        offset = (INT32)port;
00062c  e1a05003          MOV      r5,r3
;;;595        bitMap = (UINT32)bit;
000630  e1a04001          MOV      r4,r1
;;;596    
;;;597        reg = inpw(REG_GPIOA_DIR + offset);
000634  e59f057c          LDR      r0,|L1.3000|
000638  e7952000          LDR      r2,[r5,r0]
;;;598        reg = reg & (~bitMap);
00063c  e1c22004          BIC      r2,r2,r4
;;;599    
;;;600        if(direction == DIR_OUTPUT) {
000640  e35c0001          CMP      r12,#1
000644  1a000000          BNE      |L1.1612|
;;;601            reg = reg | bitMap;
000648  e1822004          ORR      r2,r2,r4
                  |L1.1612|
;;;602        }
;;;603    
;;;604        outpw(REG_GPIOA_DIR + offset, reg);
00064c  e59f0564          LDR      r0,|L1.3000|
000650  e7852000          STR      r2,[r5,r0]
;;;605    
;;;606        return SUCCESSFUL;
000654  e3a00000          MOV      r0,#0
;;;607    }
000658  e8bd8030          POP      {r4,r5,pc}
;;;608    
                          ENDP

                  GPIO_BitIsUsed PROC
;;;617    */
;;;618    BOOL GPIO_BitIsUsed(GPIO_PORT port, UINT32 bit)
00065c  e92d4010          PUSH     {r4,lr}
;;;619    {
000660  e1a02000          MOV      r2,r0
;;;620        UINT32 mask;
;;;621        INT32 portIndex;
;;;622    
;;;623        portIndex = (port / 0x40);
000664  e1a00002          MOV      r0,r2
000668  e1a04fc2          ASR      r4,r2,#31
00066c  e0824d24          ADD      r4,r2,r4,LSR #26
000670  e1a0c344          ASR      r12,r4,#6
;;;624        mask = (UINT32)bit;
000674  e1a03001          MOV      r3,r1
;;;625    
;;;626        return ((gpioCfg.bitBusyFlag[portIndex] & mask)?TRUE:FALSE);
000678  e59f053c          LDR      r0,|L1.3004|
00067c  e080008c          ADD      r0,r0,r12,LSL #1
000680  e1d000b0          LDRH     r0,[r0,#0]
000684  e1100003          TST      r0,r3
000688  0a000001          BEQ      |L1.1684|
00068c  e3a00001          MOV      r0,#1
                  |L1.1680|
;;;627    }
000690  e8bd8010          POP      {r4,pc}
                  |L1.1684|
000694  e3a00000          MOV      r0,#0                 ;626
000698  eafffffc          B        |L1.1680|
;;;628    
                          ENDP

                  GPIO_EnableInt PROC
;;;640     */
;;;641    INT32 GPIO_EnableInt(GPIO_PORT port, GPIO_CALLBACK callback, UINT32 userData)
00069c  e92d41f0          PUSH     {r4-r8,lr}
;;;642    {
0006a0  e1a04000          MOV      r4,r0
0006a4  e1a05001          MOV      r5,r1
0006a8  e1a06002          MOV      r6,r2
;;;643        INT32 portIndex;
;;;644        portIndex = (INT32)port/0x40;
0006ac  e1a00004          MOV      r0,r4
0006b0  e1a01fc4          ASR      r1,r4,#31
0006b4  e0841d21          ADD      r1,r4,r1,LSR #26
0006b8  e1a07341          ASR      r7,r1,#6
;;;645        if(callback != NULL) {
0006bc  e3550000          CMP      r5,#0
0006c0  0a000003          BEQ      |L1.1748|
;;;646            gpioCfg.IRQCallback[portIndex] = (GPIO_CALLBACK)callback;
0006c4  e59f04e4          LDR      r0,|L1.2992|
0006c8  e7805107          STR      r5,[r0,r7,LSL #2]
;;;647            gpioCfg.IRQUserData[portIndex] = userData;
0006cc  e2800028          ADD      r0,r0,#0x28
0006d0  e7806107          STR      r6,[r0,r7,LSL #2]
                  |L1.1748|
;;;648        }
;;;649        sysInstallISR(IRQ_LEVEL_7, GPIO_IRQn, (PVOID)GPIO_IRQHandler);
0006d4  e59f24e8          LDR      r2,|L1.3012|
0006d8  e3a01039          MOV      r1,#0x39
0006dc  e3a00007          MOV      r0,#7
0006e0  ebfffffe          BL       sysInstallISR
;;;650        sysEnableInterrupt(GPIO_IRQn);
0006e4  e3a00039          MOV      r0,#0x39
0006e8  ebfffffe          BL       sysEnableInterrupt
;;;651        return SUCCESSFUL;
0006ec  e3a00000          MOV      r0,#0
;;;652    }
0006f0  e8bd81f0          POP      {r4-r8,pc}
;;;653    
                          ENDP

                  GPIO_DisableInt PROC
;;;663     */
;;;664    INT32 GPIO_DisableInt(GPIO_PORT port)
0006f4  e92d4070          PUSH     {r4-r6,lr}
;;;665    {
0006f8  e1a04000          MOV      r4,r0
;;;666        INT32 i,portIndex;
;;;667        portIndex = (INT32)port/0x40;
0006fc  e1a00004          MOV      r0,r4
000700  e1a01fc4          ASR      r1,r4,#31
000704  e0841d21          ADD      r1,r4,r1,LSR #26
000708  e1a06341          ASR      r6,r1,#6
;;;668    
;;;669        gpioCfg.IRQCallback[portIndex] = NULL;
00070c  e3a00000          MOV      r0,#0
000710  e59f1498          LDR      r1,|L1.2992|
000714  e7810106          STR      r0,[r1,r6,LSL #2]
;;;670        gpioCfg.IRQUserData[portIndex] = 0;
000718  e2811028          ADD      r1,r1,#0x28
00071c  e7810106          STR      r0,[r1,r6,LSL #2]
;;;671    
;;;672        for(i=0; i<MAX_PORT; i++)
000720  e3a05000          MOV      r5,#0
000724  ea000006          B        |L1.1860|
                  |L1.1832|
;;;673            if(gpioCfg.IRQCallback[i]!=0)
000728  e59f0480          LDR      r0,|L1.2992|
00072c  e7900105          LDR      r0,[r0,r5,LSL #2]
000730  e3500000          CMP      r0,#0
000734  0a000001          BEQ      |L1.1856|
;;;674                return SUCCESSFUL;
000738  e3a00000          MOV      r0,#0
                  |L1.1852|
;;;675        sysDisableInterrupt(GPIO_IRQn);
;;;676        return SUCCESSFUL;
;;;677    }
00073c  e8bd8070          POP      {r4-r6,pc}
                  |L1.1856|
000740  e2855001          ADD      r5,r5,#1              ;672
                  |L1.1860|
000744  e355000a          CMP      r5,#0xa               ;672
000748  bafffff6          BLT      |L1.1832|
00074c  e3a00039          MOV      r0,#0x39              ;675
000750  ebfffffe          BL       sysDisableInterrupt
000754  e3a00000          MOV      r0,#0                 ;676
000758  eafffff7          B        |L1.1852|
;;;678    
                          ENDP

                  GPIO_EnableEINT PROC
;;;690     */
;;;691    INT32 GPIO_EnableEINT(GPIO_NIRQ nIrq, GPIO_CALLBACK callback, UINT32 userData)
00075c  e92d4070          PUSH     {r4-r6,lr}
;;;692    {
000760  e1a04000          MOV      r4,r0
000764  e1a05001          MOV      r5,r1
000768  e1a06002          MOV      r6,r2
;;;693        if(callback != NULL) {
00076c  e3550000          CMP      r5,#0
000770  0a000003          BEQ      |L1.1924|
;;;694            gpioCfg.EINTIRQCallback[nIrq] = (GPIO_CALLBACK)callback;
000774  e59f044c          LDR      r0,|L1.3016|
000778  e7805104          STR      r5,[r0,r4,LSL #2]
;;;695            gpioCfg.EINTIRQUserData[nIrq] = userData;
00077c  e2800020          ADD      r0,r0,#0x20
000780  e7806104          STR      r6,[r0,r4,LSL #2]
                  |L1.1924|
;;;696        }
;;;697        sysSetLocalInterrupt(ENABLE_IRQ);
000784  e3a0007f          MOV      r0,#0x7f
000788  ebfffffe          BL       sysSetLocalInterrupt
;;;698        switch(nIrq) {
00078c  e3540008          CMP      r4,#8
000790  308ff104          ADDCC    pc,pc,r4,LSL #2
000794  ea000047          B        |L1.2232|
000798  ea000006          B        |L1.1976|
00079c  ea00000d          B        |L1.2008|
0007a0  ea000014          B        |L1.2040|
0007a4  ea00001b          B        |L1.2072|
0007a8  ea000022          B        |L1.2104|
0007ac  ea000029          B        |L1.2136|
0007b0  ea000030          B        |L1.2168|
0007b4  ea000037          B        |L1.2200|
                  |L1.1976|
;;;699        case 0:
0007b8  e1a00000          MOV      r0,r0
;;;700            sysInstallISR(IRQ_LEVEL_7, EINT0_IRQn, (PVOID)GPIO_IRQHandler0);
0007bc  e24f2e75          ADR      r2,|L1.116|
0007c0  e3a01004          MOV      r1,#4
0007c4  e3a00007          MOV      r0,#7
0007c8  ebfffffe          BL       sysInstallISR
;;;701            sysEnableInterrupt(EINT0_IRQn);
0007cc  e3a00004          MOV      r0,#4
0007d0  ebfffffe          BL       sysEnableInterrupt
;;;702            break;
0007d4  ea000037          B        |L1.2232|
                  |L1.2008|
;;;703    
;;;704        case 1:
0007d8  e1a00000          MOV      r0,r0
;;;705            sysInstallISR(IRQ_LEVEL_7, EINT1_IRQn, (PVOID)GPIO_IRQHandler1);
0007dc  e24f2e73          ADR      r2,|L1.180|
0007e0  e3a01005          MOV      r1,#5
0007e4  e3a00007          MOV      r0,#7
0007e8  ebfffffe          BL       sysInstallISR
;;;706            sysEnableInterrupt(EINT1_IRQn);
0007ec  e3a00005          MOV      r0,#5
0007f0  ebfffffe          BL       sysEnableInterrupt
;;;707            break;
0007f4  ea00002f          B        |L1.2232|
                  |L1.2040|
;;;708    
;;;709        case 2:
0007f8  e1a00000          MOV      r0,r0
;;;710            sysInstallISR(IRQ_LEVEL_7, EINT2_IRQn, (PVOID)GPIO_IRQHandler2);
0007fc  e24f2e71          ADR      r2,|L1.244|
000800  e3a01006          MOV      r1,#6
000804  e3a00007          MOV      r0,#7
000808  ebfffffe          BL       sysInstallISR
;;;711            sysEnableInterrupt(EINT2_IRQn);
00080c  e3a00006          MOV      r0,#6
000810  ebfffffe          BL       sysEnableInterrupt
;;;712            break;
000814  ea000027          B        |L1.2232|
                  |L1.2072|
;;;713    
;;;714        case 3:
000818  e1a00000          MOV      r0,r0
;;;715            sysInstallISR(IRQ_LEVEL_7, EINT3_IRQn, (PVOID)GPIO_IRQHandler3);
00081c  e24f2e6f          ADR      r2,|L1.308|
000820  e3a01007          MOV      r1,#7
000824  e1a00001          MOV      r0,r1
000828  ebfffffe          BL       sysInstallISR
;;;716            sysEnableInterrupt(EINT3_IRQn);
00082c  e3a00007          MOV      r0,#7
000830  ebfffffe          BL       sysEnableInterrupt
;;;717            break;
000834  ea00001f          B        |L1.2232|
                  |L1.2104|
;;;718    
;;;719        case 4:
000838  e1a00000          MOV      r0,r0
;;;720            sysInstallISR(IRQ_LEVEL_7, EINT4_IRQn, (PVOID)GPIO_IRQHandler4);
00083c  e24f2e6d          ADR      r2,|L1.372|
000840  e3a01008          MOV      r1,#8
000844  e3a00007          MOV      r0,#7
000848  ebfffffe          BL       sysInstallISR
;;;721            sysEnableInterrupt(EINT4_IRQn);
00084c  e3a00008          MOV      r0,#8
000850  ebfffffe          BL       sysEnableInterrupt
;;;722            break;
000854  ea000017          B        |L1.2232|
                  |L1.2136|
;;;723    
;;;724        case 5:
000858  e1a00000          MOV      r0,r0
;;;725            sysInstallISR(IRQ_LEVEL_7, EINT5_IRQn, (PVOID)GPIO_IRQHandler5);
00085c  e24f2e6b          ADR      r2,|L1.436|
000860  e3a01009          MOV      r1,#9
000864  e3a00007          MOV      r0,#7
000868  ebfffffe          BL       sysInstallISR
;;;726            sysEnableInterrupt(EINT5_IRQn);
00086c  e3a00009          MOV      r0,#9
000870  ebfffffe          BL       sysEnableInterrupt
;;;727            break;
000874  ea00000f          B        |L1.2232|
                  |L1.2168|
;;;728    
;;;729        case 6:
000878  e1a00000          MOV      r0,r0
;;;730            sysInstallISR(IRQ_LEVEL_7, EINT6_IRQn, (PVOID)GPIO_IRQHandler6);
00087c  e24f2e69          ADR      r2,|L1.500|
000880  e3a0100a          MOV      r1,#0xa
000884  e3a00007          MOV      r0,#7
000888  ebfffffe          BL       sysInstallISR
;;;731            sysEnableInterrupt(EINT6_IRQn);
00088c  e3a0000a          MOV      r0,#0xa
000890  ebfffffe          BL       sysEnableInterrupt
;;;732            break;
000894  ea000007          B        |L1.2232|
                  |L1.2200|
;;;733    
;;;734        case 7:
000898  e1a00000          MOV      r0,r0
;;;735            sysInstallISR(IRQ_LEVEL_7, EINT7_IRQn, (PVOID)GPIO_IRQHandler7);
00089c  e24f2e67          ADR      r2,|L1.564|
0008a0  e3a0100b          MOV      r1,#0xb
0008a4  e3a00007          MOV      r0,#7
0008a8  ebfffffe          BL       sysInstallISR
;;;736            sysEnableInterrupt(EINT7_IRQn);
0008ac  e3a0000b          MOV      r0,#0xb
0008b0  ebfffffe          BL       sysEnableInterrupt
;;;737            break;
0008b4  e1a00000          MOV      r0,r0
                  |L1.2232|
0008b8  e1a00000          MOV      r0,r0                 ;702
;;;738        };
;;;739        return SUCCESSFUL;
0008bc  e3a00000          MOV      r0,#0
;;;740    }
0008c0  e8bd8070          POP      {r4-r6,pc}
;;;741    
                          ENDP

                  GPIO_EnableTriggerType PROC
;;;754     */
;;;755    INT32 GPIO_EnableTriggerType(GPIO_PORT port, UINT32 bitMap, GPIO_TRIGGER_TYPE triggerType)
0008c4  e92d4030          PUSH     {r4,r5,lr}
;;;756    {
0008c8  e1a04000          MOV      r4,r0
0008cc  e1a03001          MOV      r3,r1
0008d0  e1a0c002          MOV      r12,r2
;;;757        UINT32 reg;
;;;758        INT32 offset;
;;;759    
;;;760        offset = (INT32)port;
0008d4  e1a01004          MOV      r1,r4
;;;761    
;;;762        switch(triggerType) {
0008d8  e35c0005          CMP      r12,#5
0008dc  308ff10c          ADDCC    pc,pc,r12,LSL #2
0008e0  ea000077          B        |L1.2756|
0008e4  ea000003          B        |L1.2296|
0008e8  ea000019          B        |L1.2388|
0008ec  ea00002f          B        |L1.2480|
0008f0  ea000045          B        |L1.2572|
0008f4  ea00005b          B        |L1.2664|
                  |L1.2296|
;;;763        case LOW:
0008f8  e1a00000          MOV      r0,r0
;;;764            reg = inpw(REG_GPIOA_IMD+offset);
0008fc  e59f02b4          LDR      r0,|L1.3000|
000900  e0800001          ADD      r0,r0,r1
000904  e590200c          LDR      r2,[r0,#0xc]
;;;765            outpw(REG_GPIOA_IMD+offset,reg | bitMap);
000908  e1820003          ORR      r0,r2,r3
00090c  e59f52a4          LDR      r5,|L1.3000|
000910  e0855001          ADD      r5,r5,r1
000914  e585000c          STR      r0,[r5,#0xc]
;;;766    
;;;767            reg = inpw(REG_GPIOA_IREN+offset);
000918  e59f0298          LDR      r0,|L1.3000|
00091c  e0800001          ADD      r0,r0,r1
000920  e5902010          LDR      r2,[r0,#0x10]
;;;768            outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
000924  e1c20003          BIC      r0,r2,r3
000928  e59f5288          LDR      r5,|L1.3000|
00092c  e0855001          ADD      r5,r5,r1
000930  e5850010          STR      r0,[r5,#0x10]
;;;769    
;;;770            reg = inpw(REG_GPIOA_IFEN+offset);
000934  e59f027c          LDR      r0,|L1.3000|
000938  e0800001          ADD      r0,r0,r1
00093c  e5902014          LDR      r2,[r0,#0x14]
;;;771            outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
000940  e1820003          ORR      r0,r2,r3
000944  e59f526c          LDR      r5,|L1.3000|
000948  e0855001          ADD      r5,r5,r1
00094c  e5850014          STR      r0,[r5,#0x14]
;;;772            break;
000950  ea00005b          B        |L1.2756|
                  |L1.2388|
;;;773        case HIGH:
000954  e1a00000          MOV      r0,r0
;;;774            reg = inpw(REG_GPIOA_IMD+offset);
000958  e59f0258          LDR      r0,|L1.3000|
00095c  e0800001          ADD      r0,r0,r1
000960  e590200c          LDR      r2,[r0,#0xc]
;;;775            outpw(REG_GPIOA_IMD+offset,reg | bitMap);
000964  e1820003          ORR      r0,r2,r3
000968  e59f5248          LDR      r5,|L1.3000|
00096c  e0855001          ADD      r5,r5,r1
000970  e585000c          STR      r0,[r5,#0xc]
;;;776    
;;;777            reg = inpw(REG_GPIOA_IREN+offset);
000974  e59f023c          LDR      r0,|L1.3000|
000978  e0800001          ADD      r0,r0,r1
00097c  e5902010          LDR      r2,[r0,#0x10]
;;;778            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
000980  e1820003          ORR      r0,r2,r3
000984  e59f522c          LDR      r5,|L1.3000|
000988  e0855001          ADD      r5,r5,r1
00098c  e5850010          STR      r0,[r5,#0x10]
;;;779    
;;;780            reg = inpw(REG_GPIOA_IFEN+offset);
000990  e59f0220          LDR      r0,|L1.3000|
000994  e0800001          ADD      r0,r0,r1
000998  e5902014          LDR      r2,[r0,#0x14]
;;;781            outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
00099c  e1c20003          BIC      r0,r2,r3
0009a0  e59f5210          LDR      r5,|L1.3000|
0009a4  e0855001          ADD      r5,r5,r1
0009a8  e5850014          STR      r0,[r5,#0x14]
;;;782            break;
0009ac  ea000044          B        |L1.2756|
                  |L1.2480|
;;;783        case FALLING:
0009b0  e1a00000          MOV      r0,r0
;;;784            reg = inpw(REG_GPIOA_IMD+offset);
0009b4  e59f01fc          LDR      r0,|L1.3000|
0009b8  e0800001          ADD      r0,r0,r1
0009bc  e590200c          LDR      r2,[r0,#0xc]
;;;785            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
0009c0  e1c20003          BIC      r0,r2,r3
0009c4  e59f51ec          LDR      r5,|L1.3000|
0009c8  e0855001          ADD      r5,r5,r1
0009cc  e585000c          STR      r0,[r5,#0xc]
;;;786    
;;;787            reg = inpw(REG_GPIOA_IREN+offset);
0009d0  e59f01e0          LDR      r0,|L1.3000|
0009d4  e0800001          ADD      r0,r0,r1
0009d8  e5902010          LDR      r2,[r0,#0x10]
;;;788            outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
0009dc  e1c20003          BIC      r0,r2,r3
0009e0  e59f51d0          LDR      r5,|L1.3000|
0009e4  e0855001          ADD      r5,r5,r1
0009e8  e5850010          STR      r0,[r5,#0x10]
;;;789    
;;;790            reg = inpw(REG_GPIOA_IFEN+offset);
0009ec  e59f01c4          LDR      r0,|L1.3000|
0009f0  e0800001          ADD      r0,r0,r1
0009f4  e5902014          LDR      r2,[r0,#0x14]
;;;791            outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
0009f8  e1820003          ORR      r0,r2,r3
0009fc  e59f51b4          LDR      r5,|L1.3000|
000a00  e0855001          ADD      r5,r5,r1
000a04  e5850014          STR      r0,[r5,#0x14]
;;;792            break;
000a08  ea00002d          B        |L1.2756|
                  |L1.2572|
;;;793        case RISING:
000a0c  e1a00000          MOV      r0,r0
;;;794            reg = inpw(REG_GPIOA_IMD+offset);
000a10  e59f01a0          LDR      r0,|L1.3000|
000a14  e0800001          ADD      r0,r0,r1
000a18  e590200c          LDR      r2,[r0,#0xc]
;;;795            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
000a1c  e1c20003          BIC      r0,r2,r3
000a20  e59f5190          LDR      r5,|L1.3000|
000a24  e0855001          ADD      r5,r5,r1
000a28  e585000c          STR      r0,[r5,#0xc]
;;;796    
;;;797            reg = inpw(REG_GPIOA_IREN+offset);
000a2c  e59f0184          LDR      r0,|L1.3000|
000a30  e0800001          ADD      r0,r0,r1
000a34  e5902010          LDR      r2,[r0,#0x10]
;;;798            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
000a38  e1820003          ORR      r0,r2,r3
000a3c  e59f5174          LDR      r5,|L1.3000|
000a40  e0855001          ADD      r5,r5,r1
000a44  e5850010          STR      r0,[r5,#0x10]
;;;799    
;;;800            reg = inpw(REG_GPIOA_IFEN+offset);
000a48  e59f0168          LDR      r0,|L1.3000|
000a4c  e0800001          ADD      r0,r0,r1
000a50  e5902014          LDR      r2,[r0,#0x14]
;;;801            outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
000a54  e1c20003          BIC      r0,r2,r3
000a58  e59f5158          LDR      r5,|L1.3000|
000a5c  e0855001          ADD      r5,r5,r1
000a60  e5850014          STR      r0,[r5,#0x14]
;;;802            break;
000a64  ea000016          B        |L1.2756|
                  |L1.2664|
;;;803        case BOTH_EDGE:
000a68  e1a00000          MOV      r0,r0
;;;804            reg = inpw(REG_GPIOA_IMD+offset);
000a6c  e59f0144          LDR      r0,|L1.3000|
000a70  e0800001          ADD      r0,r0,r1
000a74  e590200c          LDR      r2,[r0,#0xc]
;;;805            outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
000a78  e1c20003          BIC      r0,r2,r3
000a7c  e59f5134          LDR      r5,|L1.3000|
000a80  e0855001          ADD      r5,r5,r1
000a84  e585000c          STR      r0,[r5,#0xc]
;;;806    
;;;807            reg = inpw(REG_GPIOA_IREN+offset);
000a88  e59f0128          LDR      r0,|L1.3000|
000a8c  e0800001          ADD      r0,r0,r1
000a90  e5902010          LDR      r2,[r0,#0x10]
;;;808            outpw(REG_GPIOA_IREN+offset,reg | bitMap);
000a94  e1820003          ORR      r0,r2,r3
000a98  e59f5118          LDR      r5,|L1.3000|
000a9c  e0855001          ADD      r5,r5,r1
000aa0  e5850010          STR      r0,[r5,#0x10]
;;;809    
;;;810            reg = inpw(REG_GPIOA_IFEN+offset);
000aa4  e59f010c          LDR      r0,|L1.3000|
000aa8  e0800001          ADD      r0,r0,r1
000aac  e5902014          LDR      r2,[r0,#0x14]
;;;811            outpw(REG_GPIOA_IFEN+offset,reg | bitMap);
000ab0  e1820003          ORR      r0,r2,r3
000ab4  e59f50fc          LDR      r5,|L1.3000|
000ab8  e0855001          ADD      r5,r5,r1
000abc  e5850014          STR      r0,[r5,#0x14]
;;;812            break;
000ac0  e1a00000          MOV      r0,r0
                  |L1.2756|
000ac4  e1a00000          MOV      r0,r0                 ;772
;;;813        }
;;;814        return SUCCESSFUL;
000ac8  e3a00000          MOV      r0,#0
;;;815    }
000acc  e8bd8030          POP      {r4,r5,pc}
;;;816    
                          ENDP

                  GPIO_DisableTriggerType PROC
;;;827     */
;;;828    INT32 GPIO_DisableTriggerType(GPIO_PORT port, UINT32 bitMap)
000ad0  e92d4010          PUSH     {r4,lr}
;;;829    {
000ad4  e1a02000          MOV      r2,r0
000ad8  e1a03001          MOV      r3,r1
;;;830        UINT32 reg;
;;;831        INT32 offset;
;;;832    
;;;833        offset = (INT32)port;
000adc  e1a01002          MOV      r1,r2
;;;834    
;;;835        reg = inpw(REG_GPIOA_IMD+offset);
000ae0  e59f00d0          LDR      r0,|L1.3000|
000ae4  e0800001          ADD      r0,r0,r1
000ae8  e590c00c          LDR      r12,[r0,#0xc]
;;;836        outpw(REG_GPIOA_IMD +offset,reg & ~bitMap);
000aec  e1cc0003          BIC      r0,r12,r3
000af0  e59f40c0          LDR      r4,|L1.3000|
000af4  e0844001          ADD      r4,r4,r1
000af8  e584000c          STR      r0,[r4,#0xc]
;;;837    
;;;838        reg = inpw(REG_GPIOA_IREN+offset);
000afc  e59f00b4          LDR      r0,|L1.3000|
000b00  e0800001          ADD      r0,r0,r1
000b04  e590c010          LDR      r12,[r0,#0x10]
;;;839        outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
000b08  e1cc0003          BIC      r0,r12,r3
000b0c  e59f40a4          LDR      r4,|L1.3000|
000b10  e0844001          ADD      r4,r4,r1
000b14  e5840010          STR      r0,[r4,#0x10]
;;;840    
;;;841        reg = inpw(REG_GPIOA_IFEN+offset);
000b18  e59f0098          LDR      r0,|L1.3000|
000b1c  e0800001          ADD      r0,r0,r1
000b20  e590c014          LDR      r12,[r0,#0x14]
;;;842        outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
000b24  e1cc0003          BIC      r0,r12,r3
000b28  e59f4088          LDR      r4,|L1.3000|
000b2c  e0844001          ADD      r4,r4,r1
000b30  e5840014          STR      r0,[r4,#0x14]
;;;843    
;;;844        return SUCCESSFUL;
000b34  e3a00000          MOV      r0,#0
;;;845    }
000b38  e8bd8010          POP      {r4,pc}
;;;846    
                          ENDP

                  GPIO_DisableEINT PROC
;;;856     */
;;;857    INT32 GPIO_DisableEINT(GPIO_NIRQ nIrq)
000b3c  e92d4010          PUSH     {r4,lr}
;;;858    {
000b40  e1a04000          MOV      r4,r0
;;;859        sysDisableInterrupt((IRQn_Type)(nIrq+4));
000b44  e2841004          ADD      r1,r4,#4
000b48  e20100ff          AND      r0,r1,#0xff
000b4c  ebfffffe          BL       sysDisableInterrupt
;;;860        gpioCfg.IRQCallback[nIrq] = NULL;
000b50  e3a00000          MOV      r0,#0
000b54  e59f1054          LDR      r1,|L1.2992|
000b58  e7810104          STR      r0,[r1,r4,LSL #2]
;;;861        gpioCfg.IRQUserData[nIrq] = 0;
000b5c  e2811028          ADD      r1,r1,#0x28
000b60  e7810104          STR      r0,[r1,r4,LSL #2]
;;;862        return SUCCESSFUL;
;;;863    }
000b64  e8bd8010          POP      {r4,pc}
;;;864    
                          ENDP

                  GPIO_EnableDebounce PROC
;;;890     */
;;;891    INT32 GPIO_EnableDebounce(INT32 debounceClkSel)
000b68  e1a02000          MOV      r2,r0
;;;892    {
;;;893        UINT32 reg;
;;;894    
;;;895        reg = inpw(REG_GPIO_DBNCECON);
000b6c  e59f0044          LDR      r0,|L1.3000|
000b70  e59013f0          LDR      r1,[r0,#0x3f0]
;;;896    
;;;897        /* Setting the debounce timing */
;;;898        reg = ((reg & ~0xf) | debounceClkSel);
000b74  e3c1000f          BIC      r0,r1,#0xf
000b78  e1801002          ORR      r1,r0,r2
;;;899    
;;;900        /* Enable the debounce function */
;;;901        reg = reg | 0x20;
000b7c  e3811020          ORR      r1,r1,#0x20
;;;902        outpw(REG_GPIO_DBNCECON, reg);
000b80  e59f0030          LDR      r0,|L1.3000|
000b84  e58013f0          STR      r1,[r0,#0x3f0]
;;;903    
;;;904        return SUCCESSFUL;
000b88  e3a00000          MOV      r0,#0
;;;905    }
000b8c  e12fff1e          BX       lr
;;;906    
                          ENDP

                  GPIO_DisableDebounce PROC
;;;914     */
;;;915    INT32 GPIO_DisableDebounce(void)
000b90  e59f0020          LDR      r0,|L1.3000|
;;;916    {
;;;917        UINT32 reg;
;;;918    
;;;919        reg = inpw(REG_GPIO_DBNCECON);
000b94  e59013f0          LDR      r1,[r0,#0x3f0]
;;;920    
;;;921        /* Setting the debounce timing */
;;;922        reg = ((reg & ~0xf));
000b98  e3c1100f          BIC      r1,r1,#0xf
;;;923    
;;;924        /* Enable the debounce function */
;;;925        reg = reg | 0x20;
000b9c  e3811020          ORR      r1,r1,#0x20
;;;926        outpw(REG_GPIO_DBNCECON, reg);
000ba0  e58013f0          STR      r1,[r0,#0x3f0]
;;;927    
;;;928        return SUCCESSFUL;
000ba4  e3a00000          MOV      r0,#0
;;;929    }
000ba8  e12fff1e          BX       lr
;;;930    
                          ENDP

                  |L1.2988|
                          DCD      0xb8002000
                  |L1.2992|
                          DCD      gpioCfg+0x14
                  |L1.2996|
                          DCD      gpioCfg+0x3c
                  |L1.3000|
                          DCD      0xb8003000
                  |L1.3004|
                          DCD      gpioCfg
                  |L1.3008|
                          DCD      maskTbl
                  |L1.3012|
                          DCD      GPIO_IRQHandler
                  |L1.3016|
                          DCD      gpioCfg+0x64

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gpioCfg
                          %        164

                          AREA ||.data||, DATA, ALIGN=2

                  maskTbl
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x00007fff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000003f
